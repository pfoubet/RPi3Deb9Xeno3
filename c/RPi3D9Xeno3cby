Template: samba-common/title
Type: title
Description: Samba server and utilities
Description-cs.UTF-8: Samba server a nástroje
Description-da.UTF-8: Sambaserver og -redskaber
Description-de.UTF-8: Samba-Server und Hilfsprogramme
Description-eo.UTF-8: Servilo Samba kaj utilaĵoj
Description-es.UTF-8: Servidor Samba y herramientas
Description-eu.UTF-8: Samba zerbitzaria eta tresnak
Description-fi.UTF-8: Samba-palvelin ja apuohjelmistoja
Description-fr.UTF-8: Serveur et utilitaires Samba
Description-gl.UTF-8: Servidor e utilidades Samba
Description-he.UTF-8: שרת סמבה ושירותים
Description-id.UTF-8: Server samba dan peralatan
Description-it.UTF-8: Server e utilità Samba
Description-ja.UTF-8: Samba サーバおよびユーティリティ
Description-nb.UTF-8: Samba-tjener og verktøy
Description-nl.UTF-8: Samba-server en hulpprogramma's
Description-no.UTF-8: Samba-tjener og verktøy
Description-pl.UTF-8: Serwer i narzędzia Samba
Description-pt.UTF-8: Servidor e utilitários Samba
Description-pt_BR.UTF-8: Servidor Samba e utilitários
Description-ru.UTF-8: Сервер Samba и утилиты
Description-sk.UTF-8: Samba server a nástroje
Description-sv.UTF-8: Sambaserver och verktyg
Description-th.UTF-8: เซิร์ฟเวอร์ samba และเครื่องมือ
Description-tr.UTF-8: Samba sunucusu ve yardımcı uygulamaları

Template: samba-common/dhcp
Type: boolean
Default: false
Description: Modify smb.conf to use WINS settings from DHCP?
 If your computer gets IP address information from a DHCP server on the
 network, the DHCP server may also provide information about WINS servers
 ("NetBIOS name servers") present on the network.  This requires a
 change to your smb.conf file so that DHCP-provided WINS settings will
 automatically be read from /etc/samba/dhcp.conf.
 .
 The dhcp-client package must be installed to take advantage of this
 feature.
Description-ar.UTF-8: تغيير smb.conf لاستعمال إعدادات WINS عبر DHCP
 إذا كان حاسوبك يحصل على معلومات عنوانه (IP adresse)  من خادم DHCP  المتواجد على الشبكة, فأنه باﻹمكان أيضا الحصول غلى معلومات حول خُدَّم  WINS ("خدم أسماء NetBIOS") المتواجد على الشبكة, هذا يتطلب تغييرا في ملفsmb.conf بحيث ان إعدادات  WINS المُقدمة من طرف DHCP ستقرأ آليا من ملف /etc/samba/dhcp.conf.
 .
 يجب تثبيت رزمة dhcp-client للاستفادة من هذه الميزة.
Description-ast.UTF-8: ¿Camudar smb.conf pa usar configuraciones WINS dende DHCP?
 Si'l to ordenador garra información dende direiciones IP dende un sirvidor DHCP nuna rede, el sirvidor DHCP tamién-y podría dar información acerca de sirvidores WINS ("NetBIOS name servers") presentes na rede. Esto requier camudar el to ficheru smb.conf ya que DHCP da la configuración de WINS qué será automáticamente lleío dende /etc/samba/dhcp.conf.
 .
 El paquete dhcp-client tien qu'instálase p'algamar la ventaxa d'esta carauterística.
Description-be.UTF-8: Змяніць файл наладак smb.conf такім чынам, каб ужываліся наладкі WINS, атрыманыя ад DHCP?
 Калі Ваша сістэма атрымлівае інфармацыю, датычную IP-адраса, ад сервера DHCP, той самы сервер можа паведамляць ёй і пра серверы WINS ("Серверы імёнаў NetBIOS"), якія прысутнічаюць у сетцы. Для гэтага неабходна адпаведным чынам змяніць Ваш файл наладак smb.conf. У выніку атрыманая праз DHCP інфармацыя аб WINS-серверах будзе аўтаматычна чытацца з файлу /etc/samba/dhcp.conf.
 .
 Каб скарыстацца гэтай магчымасцю, трэба ўсталяваць пакет dhcp-client.
Description-bg.UTF-8: Да се промени ли smb.conf да взима настройките за WINS от DHCP?
 Ако компютърът получава информация за мрежовите настройки от DHCP-сървър, този метод може да се използва и за получаване на информация за наличните WINS-сървъри (сървъри за имена NetBIOS). За целта е необходимо да се промени файлът с настройки smb.conf, така че WINS-настройките да се взимат от /etc/samba.dhcp.conf.
 .
 Тази настройки изисква инсталирането на пакета dhcp-client.
Description-bn.UTF-8: DHCP থেকে WINS সেটিং ব্যবহারের জন্য smb.conf সম্পাদনা করা হবে?
 যদি আপনার কম্পিউটার তার আইপি ঠিকানার তথ্য নেটওয়ার্কের একটি DHCP সার্ভার থেকে পায়, তাহলে DHCP সার্ভার নেটওয়ার্কে উপস্থিত WINS সার্ভার ("NetBIOS name servers") সম্পর্কেও তথ্য দিতে পারে। এতে আপনার smb.conf ফাইলে একটু পরিবর্তন করতে হবে যেন DHCP-প্রদত্ত WINS সেটিং স্বয়ংক্রিয়ভাবে /etc/samba/dhcp.conf থেকে পড়া হয়।
 .
 এই বৈশিষ্ট্যের সুবিধা নেয়ার জন্য dhcp-ক্লায়েন্ট প্যাকেজ অবশ্যই ইন্সটল করা থাকতে হবে।
Description-bs.UTF-8: Izmijeniti smb.conf za korištenje WINS postavki od DHCP-a?
 Ako vaš računar dobiva informacije o IP adresama od DHCP servera na mreži, DHCP server može također pružiti informacije o WINS serverima ("NetBIOS name servers") prisutnim na mreži.  Ovo zahtijeva izmjenu u vašoj smb.conf datoteci tako da WINS postavke dobivene od DHCP-a budu automatski pročitane iz /etc/samba/dhcp.conf.
 .
 dhcp-client paket mora biti instaliran kako bi se iskoristila ova mogućnost.
Description-ca.UTF-8: Voleu modificar el smb.conf perquè utilitzi els paràmetres de configuració del WINS del DHCP?
 Si el vostre ordinador obté la informació referent a la IP a través d'un servidor de DHCP, aquest també li donarà informació sobre els servidors de WINS ("servidors de nom de NetBIOS") presents a la xarxa. Aquesta opció precisa d'una modificació del fitxer smb.conf per tal que els paràmetres de WINS obtinguts a través del DHCP s'obtinguin a través de la lectura de /etc/samba/dhcp.conf.
 .
 Per beneficiar-vos d'aquesta característica cal que sigui instal·lat el paquet dhcp-client.
Description-cs.UTF-8: Upravit smb.conf, aby používal WINS nastavení z DHCP?
 Pokud váš počítač získává IP adresu z DHCP serveru, může vám tento server nabízet také informace o WINS serverech (jmenných serverech NetBIOSu), které jsou dostupné ve vaší síti. To vyžaduje zásah do souboru smb.conf, kde se nastaví, aby se informace o WINS serverech načítaly ze souboru /etc/samba/dhcp.conf.
 .
 Pro využití této vlastnosti musíte mít nainstalovaný balík dhcp-client.
Description-da.UTF-8: Ret smb.conf, så den benytter WINS-indstillinger fra DHCP?
 Hvis din computer får IP-adresseoplysninger fra en DHCP-server på netværket, kan DHCP-serveren også give oplysninger om WINS-servere (»NetBIOS navneservere«) på netværket. Dette kræver en ændring i din smb.conf-fil, så WINS-indstillingerne fra DHCP-serveren automatisk indlæses fra /etc/samba/dhcp.conf.
 .
 Pakken dhcp-client skal være installeret, for at kunne udnytte denne funktion.
Description-de.UTF-8: Soll smb.conf so abgeändert werden, dass per DHCP angebotene WINS-Einstellungen verwendet werden?
 Wenn Ihr Computer IP-Adress-Informationen von einem DHCP-Server im Netzwerk bezieht, ist es möglich, dass der DHCP-Server auch Informationen über im Netz vorhandene WINS-Server (»NetBIOS-Name-Server«) zur Verfügung stellt. Eine Änderung der Datei smb.conf ist erforderlich, damit die über DHCP angebotenen WINS-Einstellungen automatisch aus der Datei /etc/samba/dhcp.conf übernommen werden.
 .
 Sie müssen das Paket dhcp-client installiert haben, um diese Funktionalität nutzen zu können.
Description-dz.UTF-8: ཌི་ཨེཅ་སི་པི་ནང་ལས་ ཌབ་ལུ་ཨའི་ཨེན་ཨེསི་སྒྲིག་སྟངས་ཚུ་ལག་ལེན་འདབ་ནི་ལུ་ smb.conf ལེགས་བཅོས་འབད་ནི་ཨིན་ན་?
 ག་དེམ་ཅིག་འབད་ ཁྱོད་ཀྱི་གློག་རིག་གིས་ཡོངས་འབྲེལ་གུའི་ཌི་ཨེཅ་སི་པི་སར་བར་ནང་ལས་ ཨའི་པི་ཁ་བྱང་བརྡ་དོན་འཐོབ་པ་ཅིན་ ཌི་ཨེཅ་སི་པི་སར་བར་གིས་ཡང་ ཡོངས་འབྲེལ་གུ་ཡོད་པའི་ ཌབ་ལུ་ཨའི་ཨེན་ཨེསི་སར་བརསི་ ("NetBIOS name servers")གི་སྐོར་ལས་བརྡ་དོན་བྱིན་འོང་། འདི་གི་དོན་ལུ་ ཁྱོད་རའི་ smb.conf ཡིག་སྣོད་བསྒྱུར་བཅོས་འབད་དགོཔ་ཨིན་ དེ་འབད་བ་ཅིན་ བྱིན་ཡོད་པའི་ཌི་ཨེཅ་སི་པི་ ཌབ་ལུ་ཨའི་ཨེན་ཨེསི་སྒྲིག་སྟངས་འདི་ རང་བཞིན་གྱིས་ /etc/samba/dhcp.conf ནང་ལས་ལྷག་འོང་།
 .
 ཌི་ཨེཅ་སི་པི་༣-ཞབས་ཏོག་སྤྱོད་མི་ཐུམ་སྒྲིལ་འདི་ ཁྱད་རྣམ་འདི་གི་ཕན་ཐོགས་ལུ་གཞི་བཙུགས་འབད་དགོཔ་ཨིན།
Description-el.UTF-8: Τροποποίηση του smb.conf ώστε να χρησιμοποιεί τις ρυθμίσεις WINS από τον server DHCP;
 Αν ο υπολογιστής σας παίρνει πληροφορίες για την διεύθυνση IP από έναν server DHCP στο δίκτυο, ο server DHCP μπορεί επίσης να δώσει πληροφορίες σχετικά με server WINS ("NetBIOS name servers") που υπάρχουν στο δίκτυο. Αυτό απαιτεί μια αλλαγή στο αρχείο σας smb.conf ώστε ρυθμίσεις για τον server WINS που παρέχονται από τον εξυπηρετητή DHCP να διαβάζονται αυτόματα από από το αρχείο /etc/samba/dhcp.conf.
 .
 Για να εκμεταλλευτείτε αυτό το γνώρισμα θα πρέπει να εγκαταστήσετε το πακέτο dhcp-client.
Description-eo.UTF-8: Ĉu modifi la dosieron smb.conf por uzi la agordojn WINS el DHCP?
 Se via komputilo akiras sian adreson IP de retservilo DHCP, tiu servilo DHCP povos provizi informojn pri serviloj WINS ("nomserviloj NetBIOS") ĉeestantaj rete. Tio postulas ŝanĝojn en via dosiero smb.conf por ke la agordoj WINS provizitaj de servilo DHCP estu aŭtomate legitaj el la dosiero /etc/samba/dhcp.conf.
 .
 La pako dhcp-client devas esti instalita por profiti ĉi tiun trajton.
Description-es.UTF-8: ¿Modificar smb.conf para usar la configuración WINS que proviene de DHCP?
 Si su sistema recibe la dirección IP desde un servidor DHCP en la red, el servidor DHCP también puede proveerle informaciones sobre los servidores de WINS que haya en la red.  Esto requiere un cambio en el fichero smb.conf para que la configuración de WINS proveniente de DHCP se lea automáticamente de /etc/samba/dhcp.conf.
 .
 Hay que instalar el paquete dhcp-client para aprovechar esta funcionalidad.
Description-et.UTF-8: Muuta smb.conf, et kasutataks DHCP WINS seadeid?
 Kui su arvuti saab IP aadressi informatsiooni võrgus asuvalt DHCP serverilt, võib toosama DHCP server levitada infot ka võrgus asuvate WINS serverite ("NetBIOS nimeserverid") kohta. Kui soovid, et seda informatsiooni kasutataks, on vaja smb.conf faili sisse viia muudatus, et DHCP poolt jagatud WINS seaded automaatselt /etc/samba/dhcp.conf failist loetaks.
 .
 Et seda võimalust kasutada, peab olema paigaldatud dhcp-client pakk.
Description-eu.UTF-8: smb.conf WINS ezarpenak DHCP-tik jasotzeko eraldatu?
 Zure sistemak IP helbidea sareko DHCP zerbitzari batetik jasoz gero, zerbitzari horrek sareko WINS ("NetBIOS name servers") zerbitzarien datuak eman ditzake.  Honek smb.conf fitxategian aldaketa bat behar du DHCP bidezko WINS ezarpenak /etc/samba/dhcp.conf-etik irakurtzeko.
 .
 Eginbide honetaz baliatzeko dhcp-client bezeroa instalatuta egon izan behar du.
Description-fi.UTF-8: Muokataanko smb.conf käyttämään DHCP:ltä saatua WINS-asetusta?
 Jos tietokone saa verkkoasetukset verkon DHCP-palvelimelta, saattaa DHCP-palvelin tarjota tietoa myös verkon WINS-palvelimista ("NetBIOS-nimipalvelimista"). Tällöin on tiedostoa smb.conf muutettava, jotta DHCP:n tarjoamat WINS-asetukset luetaan automaattisesti tiedostosta /etc/samba/dhcp.conf.
 .
 Tätä ominaisuutta voi käyttää vain jos paketti dhcp-client on asennettu.
Description-fr.UTF-8: Modifier smb.conf pour utiliser les paramètres WINS fournis par DHCP ?
 Si votre ordinateur obtient ses paramètres IP à partir d'un serveur DHCP du réseau, ce serveur peut aussi fournir des informations sur les serveurs WINS (serveurs de noms NetBIOS) présents sur le réseau. Une modification du fichier smb.conf est nécessaire afin que les réglages WINS fournis par le serveur DHCP soient lus dans /etc/samba/dhcp.conf.
 .
 Le paquet dhcp-client doit être installé pour utiliser cette fonctionnalité.
Description-gl.UTF-8: ¿Modificar smb.conf para empregar a configuración WINS de DHCP?
 Se o seu ordenador obtén o enderezo IP dun servidor DHCP da rede, o servidor DHCP tamén pode fornecer información sobre os servidores WINS (servidores de nomes NetBIOS) que estean presentes na rede. Para facelo hai que modificar o ficheiro smb.conf para que a configuración WINS fornecida por DHCP se lea automaticamente de /etc/samba/dhcp.conf.
 .
 O paquete dhcp-client debe estar instalado para aproveitar esta característica.
Description-gu.UTF-8: DHCP માંથી WINS ગોઠવણીઓ ઉપયોગ કરવા માટે smb.conf બદલશો?
 જો તમારું કમ્પ્યુટર નેટવર્કમાં આઇપી સરનામાંની માહિતી DHCP સર્વરમાંથી લે છે તો,  DHCP સર્વર નેટવર્કમાં હાજર રહેલ WINS સર્વરો ("NetBIOS નામ સર્વરો") વિશેની માહિતી પણ પૂરી પાડી શકે છે.  આને માટે તમારે smb.conf ફાઇલમાં ફેરફાર કરવો પડશે જેથી DHCP એ પુરી પાડેલ WINS ગોઠવણીઓ આપમેળે /etc/samba/dhcp.conf માંથી વાંચી શકાય.
 .
 આ લાક્ષણિકતાનો લાભ લેવા માટે dhcp-ક્લાયન્ટ પેકેજ સ્થાપિત કરેલ હોવું જ જોઇએ.
Description-he.UTF-8: האם לשנות את הקובץ smb.conf כדי שישתמש בהגדרות WINS מתוך DHCP?
 במידה שמחשב זה מקבל כתובת IP משרת DHCP ברשת, ייתכן כי שרת ה-DHCP גם מספק מידע על שרתי WINS  ("שרתי מיפוי כתובות NetBIOS") הזמינים ברשת. שימוש במידע זה מצריך שינוי בקובץ smb.conf כדי שכתובת שרת ה-WINS שמספק שרת ה-DHCP, תיקרא בצורה אוטומטית מהקובץ /etc/samba/dhcp.conf.
 .
 על החבילה dhcp-client להיות מותקנת כדי לאפשר מאפיין זה.
Description-hu.UTF-8: Módosítod az smb.conf-ot, hogy a WINS beállításokat a DHCP-n keresztül érje el?
 Ha e gép az IP címeket egy DHCP kiszolgálótól kérdezi le a hálózaton, lehet, hogy a WINS kiszolgálók ("NetBIOS névkiszolgálók") listáját is le tudja kérdezni. Ehhez az smb.conf módosítása szükséges, hogy a DHCP-n keresztüli WINS beállításokat automatikusan kiolvassa a /etc/samba/dhcp.conf-ból.
 .
 A dhcp-client csomagnak telepítve kell lennie e képesség kihasználásához.
Description-id.UTF-8: Ubah smb.conf agar menggunakan setelan WINS dari DHCP?
 Jika komputer Anda mendapatkan alamat IP dari sebuah server DHCP di jaringan, server DHCP tersebut mungkin juga memberikan info tentang server WINS ("server NetBIOS") yang tersedia dalam jaringan. Berkas smb.conf perlu diubah agar setelan WINS dari server DHCP dapat dibaca otomatis dari /etc/samba/dhcp.conf.
 .
 Paket dhcp-client harus dipasang agar fitur ini dapat digunakan.
Description-it.UTF-8: Modificare smb.conf per usare le impostazioni WINS da DHCP?
 Se il computer acquisisce l'indirizzo IP da un server DHCP, tale server DHCP potrebbe fornire anche le informazioni sui server WINS (i name server per NetBIOS) presenti nella rete. È necessario modificare il file smb.conf per far leggere automaticamente da /etc/samba/dhcp.conf le impostazioni WINS fornite da DHCP.
 .
 Per usare questa funzionalità è necessario che il pacchetto dhcp-client sia installato.
Description-ja.UTF-8: DHCP から WINS 設定を使うよう smb.conf を変更しますか?
 あなたのコンピュータがネットワーク上の DHCP サーバから IP アドレス情報を取得しているのであれば、DHCP サーバはネットワーク上にある WINS サーバ (NetBIOS ネームサーバ) についての情報を提供することもできます。DHCP で提供される WINS 設定は /etc/samba/dhcp.conf から自動的に読み込まれるため、smb.conf ファイルを変更する必要があります。
 .
 この機能を使うためには、dhcp-client パッケージがインストールされている必要があります。
Description-ka.UTF-8: გსურთ smb.conf-ის შეცვლა WINS პარამეტრების DHCP-დან გამოსაყენებლად?
 თუ თქვენი კომპიუტერი IP მისამართს ქსელის DHCP სერვერიდან იღებს, მაშინ DHCP სერვერს შეიძლება ასევე გააჩნდეს ინფორმაცია ქსელში არსებულ WINS სერვერების („NetBIOS name servers“) შესახებ.  ამისათვის საჭიროა ცვლილება smb.conf ფაილში, რათა DHCP-ს მოწოდებული WINS პარამეტრები ავტომატურად ამოიკითხოს /etc/samba/dhcp.conf-დან.
 .
 ამ ფუნქციის გამოსაყენებლად აუცილებელია დაყენებული იყოს dhcp-client პაკეტი.
Description-km.UTF-8: កែប្រែ smb.conf ដើម្បី​ប្រើ​ការកំណត់​របស់ WINS ពី DHCP ?
 ប្រសិន​បើ​កុំព្យូទ័រ​របស់​អ្នក​ទទួល​​ព័ត៌មាន​អាសយដ្ឋាន IP ពី​ម៉ាស៊ីន​បម្រើ DHCP នៅ​លើ​បណ្ដាញ ម៉ាស៊ីន​បម្រើ​ DHCP អាច​ផ្ដល់​ផង​ដែរ​នូវ​ព័ត៌មាន​អំពី​ម៉ាស៊ីន​បម្រើ WINS ("ឈ្មោះ​ម៉ាស៊ីន​បម្រើ NetBIOS") ដែល​បង្ហាញ​នៅ​លើ​បណ្ដាញ ។ វា​ត្រូវ​ការ​ការ​ផ្លាស់ប្ដូរ​ទៅ​នឹង​ឯកសារ smb.conf របស់​អ្នក ដូច្នេះការ​កំណត់របស់ WINS ដែល​បានផ្ដល់​ដោយ DHCP នឹង​ត្រូវ​បាន​អាន​ដោយ​ស្វ័យ​ប្រវត្តិ​ពី /etc/samba/dhcp.conf.
 .
 កញ្ចប់​ម៉ាស៊ីន​ភ្ញៀវ dhcp ត្រូវ​តែ​បាន​ដំឡើង​ដើម្បី​ទទួល​បាន​ផលប្រយោជន៍របស់​លក្ខណៈ​ពិសេស​នេះ ។
Description-ko.UTF-8: smb.conf을 수정하여 DHCP의 WINS 설정을 사용하도록 할까요?
 컴퓨터가 네트워크 상에 있는 DHCP 서버에서 IP 주소 정보를 받아올 경우, DHCP 서버에서 네트워크 상에 있는 WINS 서버("NetBIOS 네임 서버")에 관한 정보를 받아올 수 있는 경우도 있습니다. 이를 위해서는 smb.conf 파일을 수정하여 DHCP에서 제공된 WINS 설정을 /etc/samba/dhcp.conf에서 자동으로 읽어들일 수 있도록 해야 합니다.
 .
 이 기능을 사용하기 위해서는 dhcp-client 꾸러미를 설치해야 합니다.
Description-ku.UTF-8: Bila smb.conf were guherandin da ku mîhengên WINS ji DHCP werin bikaranîn?
 Eger kompîtera te ji ser pêşkêşkarê ji DHCPê navnîşaneke IPê bistîne, dibe ku pêşkêşkara DHCP jî derbarê pêşkêşkara WINSê de agahiyan peyda bike ("NetBIOS navê pêşkêşkaran) ji ser torê pêşkêş bike. Ji bo vê divê pelê te yê smb.conf bê guherandin lewre mîhengên WINSê yên DHCP-pêşkêş dike ji /etc/samba/dhcp/confê xweber bên xwendin.
 .
 Ji bo bikaranîna vê fonksiyonê divê pakêta dhcp-client were sazkirin.
Description-lt.UTF-8: Pakeisti smb.conf, kad būtų naudojami WINS nustatymai iš DHCP?
 Jei šis kompiuteris gauna IP adresus iš tinklo DHCP serverio, DHCP serveris taip pat gali teikti informaciją apie tinklo WINS serverius (NetBIOS vardų serverius).  Kad WINS nustatymai, gauti per DHCP (saugomi rinkmenoje /etc/samba/dhcp.conf), būtų naudojami, reikia pakeisti rinkmeną smb.conf.
 .
 Kad būtų galima pasinaudoti šia galimybe, turi būti įdiegtas paketas dhcp-client.
Description-ml.UTF-8: DHCP യില്‍ നിന്നുള്ള WINS സെറ്റിങ്ങുകള്‍ ഉപയോഗിക്കാന്‍ smb.conf മാറ്റണോ?
 നിങ്ങളുടെ കമ്പ്യൂട്ടറിന് ഐപി വിലാസ വിവരം നെറ്റുവര്‍ക്കിലെ ഒരു DHCP സേവകനില്‍ നിന്നുമാണ് ലഭിക്കുന്നതെങ്കില്‍, DHCP സേവകന്‍ നെറ്റുവര്‍ക്കിലുള്ള WINS ("NetBIOS നാമ സേവകര്‍") സേവകന്മാരെക്കുറിച്ചുള്ള വിവരങ്ങള്‍ കൂടി നല്കിയേക്കാം. DHCP-നല്കിയ WINS സജ്ജീകരണങ്ങള്‍  /etc/samba/dhcp.conf ല്‍ നിന്നും സ്വയമേ വായിക്കുന്നതിന് നിങ്ങളുടെ smb.conf ഫയലില്‍ ഒരു മാറ്റം ആവശ്യമാണ്.
 .
 ഈ കഴിവുപയോഗിക്കാന്‍ dhcp-client പാക്കേജ് ഇന്‍സ്റ്റാള്‍‍ ചെയ്തിരിക്കേണ്ടതുണ്ട്.
Description-mr.UTF-8: डीएचसीपी(डायनमिक होस्ट कानफिगुरेशन प्रोटोकॉल) मधील डब्ल्युआयएनएस(विन्स) निर्धारणांचा उपयोग करण्यासाठी smb.conf मध्ये बदल करायचा का?
 संगणकाच्या जाळ्यावर,तुमच्या संगणकाला,डीएचसीपी परिसेवकामधून आयपी पत्ता मिळाला असेल,तर तो डीएचसीपी परिसेवक,संगणकाच्या जाळ्यावर असलेल्या डब्ल्यूआयएनएस परिसेवकांबद्दलही ("नेटबॉयस( एनईटी बीआयओएस) नांवाचा परिसेवक") माहिती देऊ शकेल. यासाठीच तुमच्या smb.conf संचिकेत बदल करणे आवश्यक आहे, तसे केल्याने डीएचसीपीने पुरविलेली डब्ल्यूआयएनएस निर्धारणे /ईटीसी/सांबा/डीएचसीपी सीओएनएफ (/etc/samba/dhcp.conf./) मधून आपोआप वाचली जाऊ शकतात.
 .
 या विशेष लक्षणाचा फायदा घेण्यासाठी,डीएचसीपी ३ ग्राहक पॅकेज अधिष्ठापित केले गेलेच पाहिजे.
Description-nb.UTF-8: Skal smb.conf endres til å bruke WINS-innstillinger fra DHCP?
 Hvis din datamaskin får informasjon om IP-adressen fra en DHCP-tjener på nettet, så kan DHCP-tjeneren også skaffe informasjon om WINS-tjenere («NetBIOS navnetjenere») på nettet. For å bruke dette må smb.conf-fila endres slik at WINS-innstillinger fra DHCP automatisk leses fra /etc/samba/dhcp.conf.
 .
 For å utnytte denne muligheten må pakka dhcp-client være installert.
Description-ne.UTF-8: DHCP बाट WINS सेटिङ प्रयोग गर्न smb.conf परिमार्जन गर्नुहोस्?
 यदि तपाईँको कम्प्युटरले सञ्जालमा DHCP सर्भरबाट IP ठेगाना जानकारी प्राप्त गर्छ भने, DHCP सर्भरले पनि सञ्जालमा वर्तमान WINS सर्भर ("NetBIOS name servers") का बारेमा जानकारी उपलब्ध गराउन सक्छ । यसका लागि तपाईँको smb.conf फाइलमा परिवर्तन आवश्यक हुन्छ ताकी DHCP ले उपलब्ध गराएका WINS सेटिङ /etc/samba/dhcp.conf. बाट स्वचालित रुपमा पढ्न सकियोस् ।
 .
 यो विशेषताको फाइदा लिन dhcp-क्लाइन्ट प्याकेज स्थापना गरिएको हुन पर्छ ।
Description-nl.UTF-8: smb.conf aanpassen om de WINS instellingen van DHCP te gebruiken?
 Indien uw computer zijn IP-adresinformatie van een DHCP-server op het netwerk haalt, voorziet deze mogelijk ook in informatie betreffende de op het netwerk aanwezige WINS-servers ("NetBIOS naamservers"). In dat geval is een wijziging aan het smb.conf bestand nodig, opdat de door DHCP doorgegeven WINS instellingen automatisch gelezen zouden worden van /etc/samba/dhcp.conf.
 .
 Het pakket dhcp-client moet geïnstalleerd zijn om van deze functionaliteit gebruik te kunnen maken.
Description-nn.UTF-8: Vil du endre smd.conf til å bruke WINS-innstillingar frå DHCP?
 Viss maskina di får IP-adresseinformasjon frå ein DHCP-tenar på nettverket, kan DHCP-tenaren også gje informasjon om WINS-tenarar («NetBIOS namnetenarar») som er tilstade på nettverket. Dette krev ei endring i smb.conf-fila slik at WINS-innstillingar som DHCP-tenaren oppgjev automatisk vert lest frå /etc/samba/dhcp.conf.
 .
 Pakka dhcp-client må vere installert for å ta i bruk dette.
Description-no.UTF-8: Skal smb.conf endres til å bruke WINS-innstillinger fra DHCP?
 Hvis din datamaskin får informasjon om IP-adressen fra en DHCP-tjener på nettet, så kan DHCP-tjeneren også skaffe informasjon om WINS-tjenere («NetBIOS navnetjenere») på nettet. For å bruke dette må smb.conf-fila endres slik at WINS-innstillinger fra DHCP automatisk leses fra /etc/samba/dhcp.conf.
 .
 For å utnytte denne muligheten må pakka dhcp-client være installert.
Description-pl.UTF-8: Czy zmienić smb.conf tak, by używał ustawień WINS z DHCP?
 Jeżeli ten komputer pobiera informacje o adresie IP z serwera DHCP przez sieć, serwer DHCP może również dostarczać informacji na temat serwerów WINS ("serwerów nazw NetBIOS") obecnych w sieci. Wymaga to zmiany w pliku smb.conf, aby dostarczone przez DHCP ustawienia WINS były automatycznie odczytywane z /etc/samba/dhcp.conf.
 .
 Aby móc skorzystać z tej funkcjonalności, musi być zainstalowany pakiet dhcp-client.
Description-pt.UTF-8: Modificar o smb.conf para utilizar definições de WINS a partir de DHCP?
 Se o seu computador obtém a informação do endereço IP a partir de um servidor de DHCP na rede, o servidor de DHCP pode também fornecer informação acerca de servidores de WINS ("servidor de nomes NetBIOS") presentes na rede.  Isto requer uma alteração no seu ficheiro smb.conf de modo que as definições de WINS fornecidas por DHCP sejam automaticamente lidas a partir de /etc/samba/dhcp.conf.
 .
 Para tirar partido desta funcionalidade tem de ter instalado o pacote dhcp-client.
Description-pt_BR.UTF-8: Modificar smb.conf para usar configurações WINS fornecidas via DHCP?
 Caso seu computador obtenha as informações de endereçamento IP de um servidor DHCP na rede, o servidor DHCP poderá também fornecer informações sobre servidores WINS ("servidores de nomes NetBIOS") presentes na rede. Isso requer uma alteração no seu arquivo smb.conf, assim as configurações WINS fornecidas via DHCP serão automaticamente lidas de /etc/samba/dhcp.conf.
 .
 O pacote dhcp-client deve estar instalado para que esse recurso possa ser utilizado.
Description-ro.UTF-8: Se modifică smb.conf pentru a folosi configurațiile WINS din DHCP?
 Dacă acest calculator primește informațiile IP (de configurare a rețelei) de la un server DHCP din rețea, acel server ar putea să ofere informații și despre serverele WINS („Serverele NetBIOS de nume”) prezente în rețea. Acest lucru necesită o schimbare a fișierului smb.conf astfel încât configurațiile WINS oferite prin DHCP vor fi citite automat din /etc/samba/dhcp.conf.
 .
 Pachetul dhcp-client trebuie să fie instalat pentru a beneficia de această facilitate.
Description-ru.UTF-8: Изменить smb.conf для использования настроек WINS из DHCP?
 Если компьютер получает информацию о своём IP-адресе от службы DHCP по сети, тогда DHCP-сервер также может предоставлять информацию о серверах WINS («серверы имён NetBIOS»), доступных в сети. Чтобы настройки WINS, предоставленные сервером DHCP, автоматически считывались из /etc/samba/dhcp.conf, нужно изменить файл smb.conf.
 .
 Чтобы использовать эту возможность, нужно установить пакет dhcp-client.
Description-sk.UTF-8: Upraviť smb.conf, aby používal nastavenie WINS z DHCP?
 Ak váš počítač získava IP adresu z DHCP servera, môže vám tento server ponúkať aj údaje o serveroch WINS (menných serveroch NetBIOS-u), ktoré sa nachádzajú na vašej sieti. To vyžaduje zásah do súboru smb.conf, kde sa nastaví načítavanie údajov o WINS serveroch zo súboru /etc/samba/dhcp.conf.
 .
 Aby ste mohli využiť túto vlastnosť, musíte mať nainštalovaný balík dhcp-client.
Description-sl.UTF-8: Spremeni smb.conf za uporabo WINS nastavitev pridobljenih s strani DHCP?
 Če vaš računalnik pridobiva informacije o IP naslovu prek DHCP strežnika, lahko ta strežnik ponuja tudi informacije o WINS strežnikih ("NetBIOS imenski strežniki"), ki so prisotni v omrežju. To zahteva spremembo v datoteki smb.conf ki bo omogočila samodejno branje nastavitev WINS iz /etc/samba/dhcp.conf.
 .
 Za uporabo teh možnosti mora biti nameščen paket dhcp-client.
Description-sq.UTF-8: Ta ndryshoj smb.conf për të përdorur rregullimet WINS nga DHCP?
 Nëse kompjuteri yt pajiset me adrese IP nga një shërbyes DHCP në rrjet, shërbyesi DHCP mundet gjithashtu të japë të dhëna rreth shërbyesve WINS ("shërbyesa emri NetBIOS") që ndodhen në rrjet.  Kjo ka nevojë për një ndryshim në skedën tënde smb.conf në mënyrë të tillë që rregullimet WINS që vijnë me DHCP të lexohen automatikisht nga /etc/samba/dhcp.conf.
 .
 Duhet instaluar paketa dhcp-client për të patur përparësi mbi këtë veti.
Description-sv.UTF-8: Ändra smb.conf till att använda WINS-inställningar från DHCP?
 Om din dator får en IP-address och information från en DHCP-server på nätverket kan även DHCP-server också skicka information om WINS-servrar ("NetBIOS namnservrar") i ditt nätverk.  Detta kräver en ändring i din fil smb.conf så att WINS-inställningar från DHCP-servern automatiskt kan läsas från /etc/samba/dhcp.conf.
 .
 Paketet dhcp-client måste installeras för att kunna använda denna funktion.
Description-ta.UTF-8: smb.conf ஐ டிஹெச்சிபி யிலிருந்து WINS அமைப்பை பயன்படுத்த மாற்றியமைக்கவா ?
 உங்கள் கணினி IP முகவரியை வலைப் பின்னலிலிருந்து டிஹெச்சிபி சேவையகத்தின் மூலம் பெறுமானால் அந்த டிஹெச்சிபி சேவையகம் வலைப் பின்னலில் உள்ள WINS servers (விண்ஸ் சேவையகங்கள்) ("NetBIOS name servers") நெட்பயாஸ் பெயர் சேவையகங்கள் குறித்த தகவல்களை தர இயலும். இதற்கு smb.conf கோப்பை டிஹெச்சிபி  தரும் WINS வடிவமைப்பை /etc/samba/dhcp.conf கோப்பிலிருந்து தானியங்கியாக படிக்கும் படி அமைக்க வேண்டும்.
 .
 இந்த வசதியை பயன்படுத்திக் கொள்ள டிஹெச்சிபி3 சார்ந்தோன் பொதியை நிறுவ வேண்டும்.
Description-th.UTF-8: จะแก้ไข smb.conf ให้ใช้ค่าตั้ง WINS จาก DHCP หรือไม่?
 ถ้าคอมพิวเตอร์ของคุณใช้ข้อมูลหมายเลข IP จากเซิร์ฟเวอร์ DHCP ในเครือข่าย เซิร์ฟเวอร์ DHCP ดังกล่าวอาจให้ข้อมูลเกี่ยวกับเซิร์ฟเวอร์ WINS ("name server ของ NetBIOS") ที่มีในเครือข่ายมาด้วย การจะใช้ข้อมูลดังกล่าวได้ จำเป็นต้องแก้ไขแฟ้ม smb.conf ของคุณ เพื่อให้มีการอ่านค่าตั้ง WINS ที่ได้จาก DHCP ในแฟ้ม /etc/samba/dhcp.conf โดยอัตโนมัติ
 .
 คุณต้องติดตั้งแพกเกจ dhcp-client ด้วย เพื่อจะใช้ความสามารถนี้
Description-tl.UTF-8: Baguhin ang smb.conf upang gumamit ng WINS setting mula sa DHCP?
 Kung ang computer ninyo ay kumukuha ng IP address mula sa DHCP server sa network, ang DHCP server ay maaaring magbigay ng impormasyon tungkol sa mga WINS server ("NetBIOS name server") na nasa network. Kinakailangan nito ng pagbabago sa inyong talaksang smb.conf upang ang bigay-ng-DHCP na WINS setting ay awtomatikong babasahin mula sa /etc/samba/dhcp.conf.
 .
 Ang paketeng dhcp-client ay dapat nakaluklok upang mapakinabangan ang feature na ito.
Description-tr.UTF-8: smb.conf dosyası WINS ayarları DHCP'den kullanılacak şekilde düzenlensin mi?
 Eğer bilgisayarınız IP adresini ağınızdaki bir DHCP sunucusundan alıyorsa, bu DHCP sunucusu ağınızda bulunan WINS sunucuları ("NetBIOS name servers") hakkında da bilgi veriyor olabilir. Bu, smb.conf dosyanızda DHCP tarafından sunulan WINS ayarlarının özdevimli olarak /etc/samba/dhcp.conf dosyasından okunmasını sağlayan bir değişikliği gerektirir.
 .
 Bu özellikten yararlanabilmek için dhcp-client paketinin kurulmuş olması gerekir.
Description-vi.UTF-8: Sửa đổi « smb.conf » để dùng thiết lập WINS từ DHCP ?
 Nếu máy tính của bạn lấy thông tin địa chỉ IP từ một trình phục vụ DHCP nằm trên mạng, trình phục vụ DHCP có lẽ cũng có khả năng cung cấp thông tin về trình phục vụ WINS (« NetBIOS name servers ») cũng nằm trên mạng. Dịch vụ này cần thiết bạn sửa đổi tập tin « smb.conf » của mình để cho phép thiết lập WINS do DHCP cung cấp sẽ được đọc tự động từ tập tin « /etc/samba/dhcp.conf ».
 .
 Để nhớ dịp tính năng này, bạn cần phải cài đặt gói « dhcp-client ».
Description-wo.UTF-8: Ndax nu soppi smb.con ba muy jëfandikoo komfiguraasioŋ bu DHCP?
 Bu fekkee sa kompiyutar mi ngi ame adrees IP ci ab serwóor DHCP bu ne ci resóo bi, kon serwóor DHCP bi man na yitam di joxe ay xamle yu aju ci serwóor WINS yi ("NetBIOS name servers") yi nekk ci resóo bi. Loolu nak dana laaj ak coppat ci sa fiise smb.conf, ngir ba komfiguraasioŋ yi DHCP bi di joxe ñukoy jaŋgale sune boppu ci fiise /etc/samba/dhcp.conf
 .
 Paket bu dhcp-client nak wareesna koo istale ngir jariñoo defiin wii.
Description-zh_CN.UTF-8: 要修改 smb.conf 以使用从 DHCP 获得的 WINS 设定吗？
 如果您的计算机是从网络上的 DHCP 服务器获取 IP 地址信息，该 DHCP 服务也可能会提供网络上的 WINS 服务器 (“NetBIOS 域名服务”) 信息。这需要对您的 smb.conf 进行修改，以自动从 /etc/samba/dhcp.conf 读取 DHCP 所提供的 WINS 设置。
 .
 必须安装 dhcp-client 软件包，才能使用此项特性。
Description-zh_TW.UTF-8: 要修改 smb.conf 以使用 DHCP 取得 WINS 設定嗎？
 如果您的電腦是從網絡上的 DHCP 伺服器取得 IP 地址資訊，該 DHCP 服務也可能會提供網路上的 WINS 伺服器 (“NetBIOS 名稱服務”) 資訊。這需要對您的 smb.conf 進行修改，以自動從 /etc/samba/dhcp.conf 讀取 DHCP 所提供的 WINS 設定。
 .
 必須安裝 dhcp-client 套件，才能使用此項特性。

Template: samba-common/do_debconf
Type: boolean
Default: true
Description: Configure smb.conf automatically?
 The rest of the configuration of Samba deals with questions that
 affect parameters in /etc/samba/smb.conf, which is the file used to
 configure the Samba programs (nmbd and smbd). Your current smb.conf
 contains an "include" line or an option that spans multiple lines,
 which could confuse the automated configuration process and require
 you to edit your smb.conf by hand to get it working again.
 .
 If you do not choose this option, you will have to handle
 any configuration changes yourself, and will not be able to take
 advantage of periodic configuration enhancements.
Description-ar.UTF-8: إعداد آلي لملف smb.conf ؟
 بقية إعدادات Samba  تعالج أسئلة تؤثر في المقاييس المتواجدة في الملف /etc/samba/smb.conf و الذي يستعمل لإعداد برامج Samba التالية ( nmbd و smbd). ملفك الحالي smb.conf يحتوي على سطر  'include' او على خيار يمتد لعدة أسطر, الشي الذي يمكن أن يشوش على عملية الإعداد الآلية, ويستلزم منك تحرير ملفك smb.conf يدويا لكي تتمكن من تشغبل ذلك مرة أخرى.
 .
 في حالة عدم اختيارك لهذا الخيار, عليك معالجة أي تغيير في الإعدادات بنفسك, و لن تستفيد من تحسينات الإعداد الدورية.
Description-ast.UTF-8: ¿Configurar smb.conf automáticamente?
 El restu de la configuración de Samba fina con entrugues qu'afeuten a los parámetros de /etc/samba/smb.conf, el cual ye'l ficheru usáu pa configurar el programa Samba (nmbd y smbd). El to smb.conf actual contién una llinia de 'include' o una opción que rellena múltiples llinies, lo cual puede confundir nel procesu de configuración automática y requier qu'edites el to smb.conf a manu pa poder a trabayar con él.
 .
 Si nun escueyes esta opción, tendrás que camudar manualmente la configuración por ti mesmu, y nun tendrás les ventaxes de les meyores de configuración periódiques.
Description-be.UTF-8: Наладзіць smb.conf аўтаматычна?
 Астатняя частка наладкі Samba датычыцца пытанняў, ад адказу на якія залежаць значэнні параметраў ў файле наладак /etc/samba/smb.conf. Гэты файл ужываецца праграмамі Samba (nmbd ды smbd). У Вашым файле smb.conf прысутнічае радок "include" альбо шматрадковы параметр, што можа зблытаць працэс аўтаматычнай наладкі, і прывесці да немагчымасці працы Samba без ручнога выпраўлення файла smb.conf.
 .
 Калі Вы не абярэце гэтую опцыю, змяняць наладкі давядзецца самастойна. Тады Вы будзеце пазбаўлены магчымасці спазнаць перавагі перыядычных паляпшэнняў канфігурацыі.
Description-bg.UTF-8: Автоматична настройка на smb.conf?
 Останалата част от настройката на Samba изисква промени на параметри в smb.conf (файлът с настройки за smbd и nmbd). В момента smb.conf съдържа директива „include“, която може да обърка процеса на автоматична настройка. Ако това се случи ще се наложи ръчно да поправите smb.conf.
 .
 Ако не изберете тази настройка, няма да можете да се възползвате от автоматичните промени на файла с настройки при обновяване на пакета.
Description-bn.UTF-8: স্বয়ংক্রিয়ভাবে smb.conf কনফিগার করা হবে?
 সাম্বা কনফিগারেশনের বাকি অংশ প্রশ্ন নিয়ে কাজ করে যা /etc/samba/smb.conf (যেটি সাম্বা প্রোগ্রাম, যেমন nmbd এবং smbd, কনফিগার করার জন্য ব্যবহার করা হয়) এর প্যারামিটার পরিবর্তন করে। আপনার বর্তমান smb.conf একটি "include" লাইন বা একটি অপশন ধারন করে যা একাধিক লাইন বর্ধিত করে, যা স্বয়ংক্রিয় কনফিগারেশন প্রক্রিয়াতে একটি দ্বিধা তৈরি করতে পারে এবং আপনার smb.conf ম্যানুয়ালী সম্পাদনা করতে হতে পারে কাজ করার জন্য।
 .
 যদি আপনি এই অপশনটি নির্বাচন না করেন, আপনাকে যেকোনো কনফিগারেশন পরিবর্তন নিজেকেই হ্যান্ডল করতে হবে, এবং আপনি পিরিয়ডিক কনফিগারেশন এনহ্যান্সমেন্টের সুবিধা নিতে পারবেন না।
Description-bs.UTF-8: Podesiti smb.conf automatski?
 Ostatak konfiguracije Samba-e se bavi pitanjima koja utiču na parametre u /etc/samba/smb.conf, a to je datoteka koja se koristi za podešavanje Samba programa (nmbd-a i smbd-a). Vaša trenutna smb.conf sadrži 'include' liniju ili opciju koja obuhvata nekoliko linija, što bi moglo zbuniti automatizovani konfiguracioni proces i zahtijevati od vas da ručno uredite smb.conf kako bi proradili.
 .
 Ako ne odaberete ovu opciju, moraćete sve izmjene konfiguracije sami napraviti i nećete moći iskoristiti periodična poboljšanja konfiguracije.
Description-ca.UTF-8: Voleu configurar el smb.conf automàticament?
 La resta de la configuració del Samba tracta amb qüestions que afecten els paràmetres del fitxer de configuració /etc/samba/smb.conf, que utilitzen els programes de Samba. La versió actual del smb.conf conté una línia «include» o una opció que abarca múltiples línies que podria confondre a la configuració automàtica i precisar de la seva edició manual per poder-lo fer funcionar de nou.
 .
 Si no escolliu aquesta opció, haureu de gestionar manualment qualsevol canvi de la configuració, i no us podreu beneficiar de les millores periòdiques.
Description-cs.UTF-8: Konfigurovat smb.conf automaticky?
 Zbytek konfigurace Samby se zabývá otázkami, které mění parametry v /etc/samba/smb.conf, což je soubor používaný pro nastavení programů nmbd a smbd (dohromady tvoří Sambu). Váš stávající smb.conf obsahuje řádek „include“ nebo volbu, která se táhne přes více řádků, což může zmást proces automatického nastavení a může způsobit, že pro znovuzprovoznění Samby budete muset upravit smb.conf ručně.
 .
 Pokud tuto možnost nepovolíte, budete muset zvládnout všechna nastavení sami a nebudete moci využívat výhod pravidelných vylepšení tohoto souboru.
Description-da.UTF-8: Sæt smb.conf op automatisk?
 Resten af Samba-opsætningen drejer sig om spørgsmål, der vedrører indstillingerne i filen /etc/samba/smb.conf, som benyttes til at sætte Samba-programmerne (nmbd og smbd) op. Din nuværende smb.conf indeholder en 'include'-linje eller en indstilling, der fylder flere linjer, hvilket kan forvirre den automatiske opsætning, og kræver at du redigerer din smb.conf selv for at få den til at fungere igen.
 .
 Hvis du ikke vælger denne indstilling, må du selv håndtere ændringer i opsætningen, og vil ikke kunne drage nytte af de løbende forbedringer i opsætningen.
Description-de.UTF-8: Soll smb.conf automatisch konfiguriert werden?
 Der Rest der Konfiguration von Samba betrifft Fragen über Parameter in /etc/samba/smb.conf (das ist die Datei, die genutzt wird, um die Samba-Programme (nmbd und smbd) zu konfigurieren). Ihre aktuelle smb.conf enthält eine »include«-Zeile oder eine mehrzeilige Option. Dies kann den automatischen Konfigurationsprozess stören, so dass Sie eventuell Ihre smb.conf-Datei manuell korrigieren müssen, um Samba wieder zum Laufen zu bekommen.
 .
 Wenn Sie diese Option nicht wählen, werden Sie jede Änderung an der Konfiguration manuell vornehmen müssen und können nicht den Vorteil von regelmäßigen Verbesserungen an der Konfiguration nutzen.
Description-dz.UTF-8: smb.conf འདི་རང་བཞིན་གྱིས་རིམ་སྒྲིག་འབད་ནི་ཨིན་ན?
 སམ་བ་གི་རིམ་སྒྲིག་གཞན་མི་ཚུ་ འདྲི་བ་དང་འབྲེལཝ་ལས་ /etc/samba/smb.conf ནང་ཚད་བཟུང་ལུ་ཕན་གནོད་འབྱུངམ་ཨིན་ འདི་ཡང་སམ་བ་ལས་རིམ་ (nmbd and smbd)ཚུ་རིམ་སྒྲིག་འབད་ནི་ལུ་དགོ་པའི་ཡིག་སྣོད་ཨིན། ཁྱོད་ཀྱི་ད་ལྟོའི་ smb.conf ནང་ལུ་ 'include'གྲལ་ཐིག་ ཡངན་ འཕར་ཚད་འགྱོ་མི་གྲལ་ཐིག་སྣ་མང་གི་གདམ་ཁ་ཚུ་ཡོདཔ་ཨིན་ དེ་གིས་ རང་བཞིན་ཅན་གྱི་རིམ་སྒྲིག་ལས་སྦྱོར་འདི་ མགུ་འཐོམ་བཅུགཔ་ཨིནམ་དང་ ལོག་སྟེ་ལཱ་འབད་ནིའི་དོན་ལུ་ ལག་པའི་ཐོག་ལས་ ཁྱོད་རའི་smb.conf ཞུན་དག་འབད་དགོཔ་ཨིན། 
 .
 ཁྱོད་ཀྱིས་ གདམ་ཁ་འདི་མ་གདམ་པ་ཅིན་ རིམ་སྒྲིག་གི་འགྱུར་བ་གང་རུང་ཅིག་ ཁྱོད་རང་གིས་ལེགས་སྐྱོང་འཐབ་དགོཔ་དང་ དུས་མཚམས་རིམ་སྒྲིག་གོང་སྤེལ་གྱི་ཁེ་ཕན་འཐོབ་མི་ཚུགས།
Description-el.UTF-8: Αυτόματη ρύθμιση του αρχείου smb.conf;
 Το υπόλοιπο της ρύθμισης της υπηρεσίας Samba έχει να κάνει με ερωτήσεις που επηρεάζουν παραμέτρους στο αρχείο etc/samba/smb.conf, που είναι το αρχείο που χρησιμοποιείται για την ρύθμιση των προγραμμάτων της Samba (nmbd και smbd). To παρόν αρχείο σας smb.conf περιέχει μια γραμμή 'include' ή μια επιλογή που εκτείνεται σε πολλαπλές γραμμές, που θα μπορούσαν να μπερδέψουν την διαδικασία της αυτόματης ρύθμισης και απαιτούν την διόρθωση του αρχείου smb.conf από σας με το χέρι ώστε να ξαναγίνει λειτουργικό.
 .
 Αν δεν διαλέξετε αυτή την επιλογή , θα πρέπει να χειριστείτε τις όποιες αλλαγές στις ρυθμίσεις μόνοι σας και δεν θα είστε σε θέση να εκμεταλλευτείτε τις βελτιώσεις που κατά καιρούς γίνονται σε αυτές.
Description-eo.UTF-8: Ĉu aŭtomate akomodi la dosieron smb.conf?
 La sekva agordado de Samba traktas aferojn koncernantajn la parametrojn en /etc/samba/smb.conf, uzata por agordi la programojn de Samba (nmbd kaj smbd). Via aktuala dosiero smb.conf enhavas linion "include" aŭ opcion kiu sterniĝas plurlinie, kio povus konfuzi la aŭtomatan akomodan procezon kaj postuli de vi mane agordi vian smb.conf por refunkciigi ĝin.
 .
 Se vi ne elektas tiun ĉi opcion, vi devos mem administri ĉiujn agordajn ŝanĝojn, kaj vi ne povos periode profiti agordajn plibonigojn.
Description-es.UTF-8: ¿Configurar smb.conf automáticamente?
 El resto de la configuración de Samba trata sobre cuestiones que afectan al contenido de «/etc/samba/smb.conf», el fichero utilizado para configurar los programas de Samba (nmbd y smbd). Su «smb.conf» actual contiene una línea «include» o una opción que atraviesa más de una línea, así que el proceso de configuración automática puede dejarlo con un «smb.conf» no válido, requiriendo que lo arregle a mano.
 .
 Si no escoge esta opción, tendrá que gestionar a mano cualquier cambio en la configuración de Samba, y no disfrutará de las mejoras periódicas que se realicen a la configuración.
Description-et.UTF-8: Seadistada smb.conf automaatselt?
 Ülejäänud Samba seadistus tegeleb /etc/samba/smb.conf parameetreid mõjutavate küsimustega - see on fail mille abil seadistatakse Samba programmid (nmbd ja smbd). Sinu praegune smb.conf sisaldab 'include' rida või mitmerealist valikut, mis võib automaatse seadistamise nurjata ning tekitada olukorra, kus pead smb.conf faili käsitsi töökorda seadma.
 .
 Kui sa seda seadet ei vali, pead iga seadistuse muudatuse ise läbi viima ega saa tunda rõõmu autmaatsest perioodilisest seadistuse täiustustamisest.
Description-eu.UTF-8: Smb.conf automatikoki konfiguratu?
 Konfigurazioaren hurrengo atalak /etc/samba/smb.conf fitxategiari dagozkion ezarpenenak dira, honek Samba programak (smbd eta nmbd) konfiguratzen ditu. smb.conf fitxategiak 'include' lerro bat edo hainbat lerrotan zabaldutako aukera bat du, horregatik konfigurazio automatikoaren prozesua honda daiteke, eta zuk eskuz konpondu beharko duzu berriro funtzionatzeko.
 .
 Aukera hau ez baduzu hautatzen, konfigurazioko edozein aldaketa eskuz egin beharko duzu eta ezingo duzu konfigurazioaren aldaketa automatikoez baliatu.
Description-fi.UTF-8: Tehdäänkö asetukset tiedostoon smb.conf automaattisesti?
 Loput Samban asetuksista ovat kysymyksiä jotka vaikuttavat parametreihin Samban ohjelmien (nmbd ja smbd) asetustiedostossa /etc/samba/smb.conf. Nyt tiedostossa smb.conf on "include"-rivi tai useita rivejä pitkä valitsin, mikä sotkee automatisoidun asetukset tekevän ohjelman ja pakottaa muokkaamaan tiedostoa smb.conf käsin, jotta se taas toimisi.
 .
 Jos et valitse tätä toimintoa, on kaikki asetusten muutokset tehtävä itse, etkä pääse hyötymään julkaistavista asetusten parannuksista.
Description-fr.UTF-8: Voulez-vous configurer smb.conf automatiquement ?
 La suite de la configuration de Samba pose des questions relatives aux paramètres de /etc/samba/smb.conf, le fichier utilisé pour configurer les programmes de Samba (nmbd et smbd). Le fichier actuel contient une ligne « include » ou une option qui s'étale sur plusieurs lignes : cela peut perturber la configuration automatique. Il est donc conseillé de gérer le contenu de ce fichier vous-même.
 .
 Si vous ne choisissez pas cette option, vous devrez gérer vous-même les modifications de configuration et vous ne pourrez pas bénéficier des améliorations faites dans la configuration.
Description-gl.UTF-8: ¿Configurar o ficheiro smb.conf automaticamente?
 O resto da configuración de Samba trata con cuestións que afectan aos parámetros de /etc/samba/smb.conf, que é o ficheiro que se emprega para configurar os programas de Samba (nmbd e smbd). O seu ficheiro smb.conf actual contén unha liña «include» ou unha opción que cobre varias liñas, o que pode confundir ao proceso de configuración automático e facer que teña que editar o ficheiro smb.conf a man para poñelo a funcionar outra vez.
 .
 Se non escolle esta opción ha ter que facer os cambios na configuración vostede mesmo, e non ha poder aproveitar as melloras periódicas na configuración.
Description-gu.UTF-8: smb.conf આપમેળે રુપરેખાંકિત કરશો?
 સામ્બા રુપરેખાંકનનાં બાકીનાં પ્રશ્નો /etc/samba/smb.conf નાં વિકલ્પો સાથે કામ પાર પાડે છે, જે સામ્બા કાર્યક્રમોને (nmbd અને smbd) રુપરેખાંકન કરવા માટે વપરાય છે. તમારી હાલની smb.conf ફાઇલ 'include' લીટી ધરાવે છે અથવા એક થી વધુ લીટીમાં વિસ્તારવાનો વિકલ્પ ધરાવે છે, જે આપમેળે રુપરેખાંકન ક્રિયાને મુંઝવણમાં મૂકી શકે છે અને તમારે smb.conf ફરી કામ કરતી કરવા માટે જાતે સુધારવી પડશે.
 .
 જો તમે આ વિકલ્પ પસંદ નહી કરો તો, તમારે બધા રુપરેખાંકનો તમારી જાતે કરવા પડશે, અને તમે આવૃતિક રુપરેખાંકન સુધારાઓનો લાભ લઇ શકશો નહી.
Description-he.UTF-8: האם להגדיר את smb.conf בצורה אוטומטית?
 שאר תהליך ההגדרה של סמבה עוסק בשאלות אשר משפיעות על פרמטרים בקובץ /etc/samba/smb.conf. קובץ זה הוא קובץ ההגדרות הראשי אשר מכיל את הפרמטרים של שרתי הרקע של סמבה (שהם smbd ו-nmbd). הקובץ smb.conf הנוכחי שלך כולל שורת 'include' או פרמטר אשר מתפרש על כמה שורות. פרמטרים אלו עשויים לבלבל את תהליך ההגדרה האוטומטי, ויצריכו עריכה ידנית של הקובץ smb.conf על מנת לתקן את הבעיות ולאפשר לסמבה לעבוד.
 .
 אם לא תבחר באפשרות זו, יהיה עליך לבצע שינויים בעצמך ובצורה ידנית. כמו כן, לא תוכל להשתמש בשיפורי תצורה אשר מתבצעים תקופתית.
Description-hu.UTF-8: Az smb.conf-ot automatikusan állítod be?
 A Samba további beállításaihoz a /etc/samba/smb.conf paramétereit befolyásoló további kérdéseket kell megválaszolni, ami a Samba programok (nmbd és smbd) beállítófájlja. A jelenlegi smb.conf tartalmaz egy 'include' sort, vagy egy több sorra tört opciót, ami megzavarhatja az automata beállító folyamot, és szükségessé teszi az smb.conf saját kezű szerkesztését, hogy az ismét működjön.
 .
 Ha nem élsz e lehetőséggel, minden beállítás változását neked kell felügyelned, és nem élvezheted az időszakos beállításhangolás előnyeit.
Description-id.UTF-8: Konfigurasikan smb.conf secara otomatis?
 Konfigurasi Samba selanjutnya berhubungan dengan pertanyaan seputar parameter dalam /etc/samba/smb.conf yang digunakan untuk mengonfigurasi program Samba (nmbd dan smbd). Konfigurasi smb.conf Anda saat ini berisi setelah yang lebih dari satu baris, yang dapat membingungkan proses konfigurasi otomatis. Anda harus mengubah smb.conf secara manual agar dapat digunakan lagi.
 .
 Jika Anda tidak mengambil pilihan ini, Anda harus menangani sendiri semua konfigurasi dan tidak dapat memanfaatkan keuntungan dari pembaharuan konfigurasi secara periodik.
Description-it.UTF-8: Configurare automaticamente smb.conf?
 Il resto della configurazione di Samba riguarda i parametri in /etc/samba/smb.conf, il file usato per configurare i programmi di Samba (nmbd e smbd). Attualmente il file smb.conf contiene una riga «include» o un'opzione che si estende su più righe; ciò potrebbe confondere il processo di configurazione automatica e richiere la modifica manuale del file smb.conf per renderlo nuovamente funzionante.
 .
 Chi rinuncia alla configurazione automatica dovrà gestire da solo qualunque cambiamento nella configurazione e non potrà beneficiare dei periodici miglioramenti della configurazione.
Description-ja.UTF-8: 自動的に smb.conf を設定しますか?
 Samba の設定の残りの部分は、Samba プログラム (nmbd および smbd) を設定するのに使うファイル /etc/samba/smb.conf にあるパラメータに影響する質問です。現在の smb.conf は、'include' 行または複数行にまたがるオプションを含んでいます。これは自動設定処理を混乱させる可能性があり、再びそれが作動するようにすべく smb.conf の手動での修正を必要とします。
 .
 この選択肢で「いいえ」と答えると、すべての設定の変更をあなた自身が面倒を見る必要があります。これは定期的な設定改善には向いていません。
Description-ka.UTF-8: გსურთ smb.conf-ის ავტომატური კონფიგურაცი?
 დარჩენილი Samba-ს კონფიგურაცია ეხება საკითხებს, რომლებსაც ზეგავლენა აქვს /etc/samba/smb.conf-ზე. ეს ფაილი Samba-ს პროგრამების (nmbd და smbd) კონფიგურაციისათვის გამოიყენება. თქვენი ამჟამინდელი smb.conf ფაილი შეიცავს 'include' სტრიქონს, ან პარამეტრს, რომელის მრავალ სტრიქონს მიმოიხილავს, რამაც შესაძლოა ავტომატური კონფიგურაციის პროცესი დააბნიოს და თქვენ smb.conf-ის ხელით დამუშავება მოგიწიოთ მის კვლავ ასამუშAვებლად.
 .
 თუ ამ პარამეტრს არ ამოირჩებთ, ნებისმიერი კონფიგურაციის ცვლილებების გატარება ხელით მოგიწევთ. ასევე ვერ გამოიყენებთ კნფიგურაციის პერიოდულ გაუმჯობესებებს.
Description-km.UTF-8: កំណត់​រចនាសម្ព័ន្ធ smb.conf ដោយ​ស្វ័យ​ប្រវត្តិ ?
 ការ​កំណត់​រចនា​សម្ព័ន្ធ​របស់ Samba ទាក់ទង​ជា​មួយ​នឹង​សំណួរ​ដែល​ប៉ះពាល់​ប៉ារ៉ាម៉ែត្រ​នៅ​ក្នុង in /etc/samba/smb.conf ដែល​ជា​ឯកសារ​បាន​ប្រើ​ដើម្បី​កំណត់​រចនាសម្ព័ន្ធ​កម្មវិធី Samba (nmbd និង smbd) ។ smb.conf បច្ចុប្បន្ន​របស់​អ្នក​មាន​បន្ទាត់ 'include' ឬ​ជម្រើស​ដែល​បញ្ចូល​បន្ទាត់​ជា​ច្រើន​ចូល​គ្នា ដែល​អាច​បន្លំ​ដំណើរ​ការ​កំណត់​រចនាសម្ព័ន្ធ ដោយ​ស្វ័យប្រវត្តិ ហើយ​តម្រូវ​ឲ្យ​អ្នក​កែសម្រួល smb.conf របស់​អ្នក​ដោយ​ដៃ​ដើម្បី​ឲ្យ​វា​ធ្វើការ​ម្ដង​ទៀត ។
 .
 ប្រសិន​បើ​អ្នក​មិន​ជ្រើស​ជម្រើស​នេះ​ទេ អ្នក​នឹង​ត្រូវ​តែ​គ្រប់គ្រង​ការ​ផ្លាស់ប្ដូរ​ការ​​កំណត់​រចនាសម្ព័ន្ធ​ណាមួយ​ដោយ​ខ្លួន​អ្នក​ផ្ទាល់ និង​មិន​អាច​បាន​ផល​ប្រយោជន៍​ពី​ការ​បង្កើន​ការ​កំណត់​រចនាសម្ព័ន្ធ​យ៉ាង​ទៀត​ទាត់​បាន​ទេ ។
Description-ko.UTF-8: smb.conf을 자동으로 설정할까요?
 앞으로 남은 Samba 설정은 Samba 프로그램들(nmbd와 smbd)을 설정할 때 사용하는 /etc/samba/smb.conf에 있는 각종 매개 변수들을 변경하는 질문들로 구성되어 있습니다. 현재의 smb.conf은 'include'를 사용하거나 여러 줄에 걸친 옵션을 사용하고 있습니다. 이는 자동 설정 과정에 혼돈을 줄 수 있으며 나중에 손으로 smb.conf을 수정하셔야 제대로 동작합니다.
 .
 이 옵션을 선택하지 않을 경우 설정 변경사항을 직접 다루셔야 하며 주기적 설정 변경 업그레이드 기능을 사용하지 못할 것입니다.
Description-ku.UTF-8: Bila smb.conf were jixweber mîhengkirin?
 Tevahiya vesazkirina peymana Sambayê ya bi pirsan bandorê li parametreya /etc/samba/smb.confê dikin yên bernameyên Sambayê (nmbd û smbd) vesaz kirine. Di smb.confa te ya niha de rêzikeke "include" an jî zêdetir rêzik, yên ku dikarin pêvajoya vesazkirina xweber têk bibin û hewcetî derxin ku tu smb.confê bi destan saz bikî da ku bixebite.
 .
 Eger tu vê vebijêrkê hilnebijêrî, dê pêwîst bibe ku tu hemû veaszkirinan bi serê xwe pêk bînî, û dê avantaja pêşdeçûna vesazkirina periyodîk pêk neyê.
Description-lt.UTF-8: Automatiškai konfigūruoti smb.conf?
 Likusi Samba konfigūravimo dalis susijusi su parametrais, nustatomais Samba konfigūracijos rinkmenoje -- /etc/samba/smb.conf. Ši rinkmena konfigūruoja Samba programas (nmbd ir smbd). Esamame smb.conf yra „include“ komanda arba nustatymas, užrašytas per kelias eilutes. Tai gali sutrikdyti automatinį konfigūravimo procesą, todėl gali prireikti rankiniu būdu paredaguoti smb.conf, kad Samba vėl pradėtų veikti.
 .
 Jei nepasirinksite šios galimybės, turėsite konfigūruoti Samba rankiniu būdu ir negalėsite pasinaudoti reguliariais automatiniais konfigūracijos patobulinimais.
Description-ml.UTF-8: smb.conf സ്വയമേ ക്രമീകരിക്കണോ?
 ബാക്കിയുള്ള സാംബ ക്രമീകരണം സാംബ പ്രോഗ്രാമുകളെ (nmbd യും smbd) ക്രമീകരിക്കാനുപയോഗിക്കുന്ന ഫയലായ /etc/samba/smb.conf ലെ പരാമീറ്ററുകളെ ബാധിക്കുന്ന ചോദ്യങ്ങളുമായി ബന്ധപ്പെട്ടതാണ്. നിങ്ങളുടെ ഇപ്പോഴത്തെ smb.conf ഒരു 'include' വരി അല്ലെങ്കില്‍ ഒന്നിലധികം വരിയില്‍ വ്യാപിച്ചുള്ള ഒരു തിരഞ്ഞെടുക്കാവുന്ന വില ഉള്‍‌ക്കൊള്ളുന്നതാണ്, അത് സ്വയമേയുള്ള ക്രമീകരണ പ്രക്രിയയെ ആശയക്കുഴപ്പത്തിലാക്കുകയും വീണ്ടും പ്രവര്‍ത്തിക്കുന്ന വിധത്തിലാക്കാന്‍ smb.conf കൈകൊണ്ട് മാറ്റുന്നത് ആവശ്യമാക്കുകയും ചെയ്യും.
 .
 ഈ തിരഞ്ഞെടുക്കാവുന്ന വില നിങ്ങള്‍‍ തിരഞ്ഞടുത്തില്ലെങ്കില്‍ എന്തെങ്കിലും ക്രമീകരണ മാറ്റങ്ങള്‍ നിങ്ങള്‍ക്ക് സ്വയം കൈകാര്യം ചെയ്യേണ്ടി വരുകയും സമയാസമയങ്ങളിലുള്ള ക്രമീകരണ പുരോഗതികളുടെ മുന്‍തൂക്കം നേടാന്‍ നിങ്ങള്‍ക്ക് സാധിക്കാതെ വരുകയും ചെയ്യും.
Description-mr.UTF-8: एसएमबी।सीओएनएफ smb.conf आपोआप संरचित करायचे का? 
 सांबाची बाकीची संरचना,सांबा आज्ञावलीची (एनएमबीडी व एसएमबीडी) संरचना करण्यासाठी वापरल्या जाणाऱ्या etc/samba/smb.conf /ईटीसी/सांबा/एसएमबी.सीओएनएफ या संचिकेमधील चलितमूल्यांवर परिणाम करणाऱ्या प्रश्नांबाबत आहे. तुमच्या सध्याच्या एसएमबी. सीओएनएफ smb.conf मध्ये,'अंतर्भाव' ओळ किंवा अनेक ओळी असलेला एक पर्याय आहे. व तो स्वयंचलित संरचना प्रक्रियेत गोंधळ करू शकतो आणि त्यामुळे तुम्हाला तुमची एसएमबी.सीओएनएफ,smb.conf,पुन्हा कार्यकारी होण्यासाठी स्वतःच संपादित करावी लागेल.
 .
 तुम्ही हा पर्याय निवडला नाहीत तर संरचनेतले बदल तुम्हालाच हाताळावे लागतील व तुम्हाला आवर्ती संरचना गुणसंवर्धनाचा चा लाभ घेता येणार नाही.
Description-nb.UTF-8: Sette opp smb.conf automatisk?
 Resten av Samba-oppsettet dreier seg om spørsmål som påvirker parametre i /etc/samba/smb.conf, som er oppsettsfila for Samba-programmene (nmbd og smbd). smb.conf-fila inneholder nå en  «include»-linje eller en parameter som går over flere linjer, som kanskje kan forvirre den automatiske oppsettsprosessen slik at du må endre smb.conf for hånd for å få den til å virke igjen.
 .
 Hvis du ikke velger automatisk oppsett, må du håndtere oppsettsendringer selv, og kan ikke dra nytte av periodiske forbedringer i oppsettet.
Description-ne.UTF-8: स्वचालित रुपमा smb.conf कन्फिगर गर्नुहुन्छ?
 साम्बाको बाँकी कन्फिगरेसन /etc/samba/smb.conf परामितिमा प्रभाव पार्ने प्रश्नसँग डिल गर्छ, जुन साम्बा कार्यक्रम कन्फिगर गर्न प्रयोग हुने फाइल हो (nmbd र smbd) । तपाईँको हालको smb.conf ले एउटा 'सम्मिलित' लाइन वा बहुभागिय लाइन ढाक्ने विकल्प समावेश गर्छ, जसले स्वचालित कन्फिगरेसन प्रक्रिया अस्तव्यस्त पार्न सक्छ र तपाईँले यसबाट फेरि कार्य गराउन हातैले smb.conf सम्पादन गर्नु पर्छ ।
 .
 यदि तपाईँले यो विकल्प छनौट नगरेमा, कुनै पनि कन्फिगरेसन परिवर्तन तपाईँ आफैले ह्यान्डल गर्नु पर्छ, र आवधिक कन्फिगरेसन वृद्धीको फाइदा लिन सक्नु हुने छैन ।
Description-nl.UTF-8: smb.conf automatisch instellen?
 De resterende Samba-configuratievragen hebben betrekking op parameters in /etc/samba/smb.conf, het configuratiebestand dat gebruikt wordt voor de Samba-programma's (nmbd en smbd). Uw huidige smb.conf bevat een "include"-regel of een optie die meerdere regels beslaat. Het kan zijn dat dit het automatische configuratieproces verstoort. In dat geval dient u uw smb.conf handmatig aan te passen om samba terug werkend te krijgen.
 .
 Indien u geen gebruik maakt van deze optie, dient u alle configuratie-instellingen zelf te doen, en zult u geen voordeel halen uit de periodieke configuratie-verbeteringen.
Description-nn.UTF-8: Setje opp smb.conf automatisk?
 Resten av oppsettet av Samba er spørsmål som handlar om parametrar i /etc/samba/smb.conf, som er fila som blir brukt til å setje opp Sambaprogram (nmbd og smbd). Den noverande smb.conf-fila inneheld ei «include»-linje eller ein opsjon som går over fleire linjer, noko som kan forvirre den automatiske oppsettsprosessen og gjer at du må redigere smb.conf-fila manuelt for å få det til å fungere igjen.
 .
 Viss du ikkje vel dette, så vil du måtte handtere endringar i oppsettet sjølv, og du vil ikkje vere i stand til å ta imot periodiske forbetringar i oppsettet.
Description-no.UTF-8: Sette opp smb.conf automatisk?
 Resten av Samba-oppsettet dreier seg om spørsmål som påvirker parametre i /etc/samba/smb.conf, som er oppsettsfila for Samba-programmene (nmbd og smbd). smb.conf-fila inneholder nå en  «include»-linje eller en parameter som går over flere linjer, som kanskje kan forvirre den automatiske oppsettsprosessen slik at du må endre smb.conf for hånd for å få den til å virke igjen.
 .
 Hvis du ikke velger automatisk oppsett, må du håndtere oppsettsendringer selv, og kan ikke dra nytte av periodiske forbedringer i oppsettet.
Description-pl.UTF-8: Czy automatycznie skonfigurować smb.conf?
 Pozostała część konfiguracji Samby związana jest z pytaniami wpływającymi na parametry w /etc/samba/smb.conf, który jest plikiem używanym do konfiguracji programów Samby (nmbd i smbd). Obecny smb.conf zawiera wiersz "include", bądź opcję obejmującą wiele wierszy, co może przeszkodzić procesowi zautomatyzowanej konfiguracji i wymagać od użytkownika ręcznej edycji pliku smb.conf, by mógł znowu być używany.
 .
 Jeżeli ta opcja nie zostanie wybrana, konieczne będzie samodzielnie zajmowanie się przez użytkownika wszelkimi zmianami konfiguracji i nie będzie można korzystać z okresowych jej ulepszeń.
Description-pt.UTF-8: Configurar automaticamente o smb.conf?
 O resto da configuração do Samba trata de questões que afectam parâmetros em /etc/samba/smb.conf, que é o ficheiro utilizado para configurar os programas do Samba (nmbd e smbd). O seu actual smb.conf contém uma linha "include" ou uma opção que se espalha por várias linhas, a qual pode confundir o processo de configuração automática e necessitar que você edite à mão o smb.conf para o ter novamente operacional.
 .
 Se não escolher esta opção, terá de lidar você mesmo com quaisquer alterações de configuração, e não poderá tirar partido de melhorias periódicas da configuração.
Description-pt_BR.UTF-8: Configurar smb.conf automaticamente?
 O restante da configuração do Samba lida com questões que afetam parâmetros no arquivo /etc/samba/smb.conf, que é o arquivo usado para configurar os programas Samba (nmbd e smbd). Seu arquivo smb.conf atual contém uma linha "include" ou uma opção que ocupa diversas linhas, o que pode confundir o processo de configuração automatizado e requerer que você edite seu arquivo smb.conf manualmente para torná-lo funcional novamente.
 .
 Caso você não escolha essa opção, você precisará lidar com quaisquer mudanças de configuração manualmente e você não poderá aproveitar os melhoramentos periódicos de configuração.
Description-ro.UTF-8: Se configurează smb.conf automat?
 Restul configurației Samba tratează întrebările care afectează parametrii din /etc/samba/smb.conf, fișierul utilizat pentru a configura programele Samba (nmbd și smbd). Actualul fișier smb.conf conține o linie „include” sau o opțiune care se desfășoară de-a lungul a mai multor linii, lucru care ar putea să creeze confuzie în procesul de configurare automată și ar putea duce la necesitatea editării manuale a fișierului smb.conf pentru a-l face din nou funcțional.
 .
 Dacă nu selectați aceasta opțiune, va trebui să gestionați personal orice schimbare a configurației și nu veți putea beneficia de îmbunătățirile periodice ale configurației.
Description-ru.UTF-8: Настроить smb.conf автоматически?
 Оставшаяся часть настройки Samba представляет собой вопросы, влияющие на параметры в /etc/samba/smb.conf. Этот файл используется для настройки программ Samba (nmbd и smbd). В текущем файле smb.conf есть строка «include» или параметр, состоящий из нескольких строк. При этом автоматическая настройка может быть нарушена, и для восстановления работоспособности потребуется отредактировать smb.conf вручную.
 .
 При отказе от этой возможности позаботиться обо всех изменениях конфигурации придётся самостоятельно, а приведёт к невозможности периодического обновления настроек.
Description-sk.UTF-8: Automaticky nastaviť smb.conf?
 Zvyšok nastavenia Samby sa zaoberá otázkami, ktoré ovplyvňujú parametre uvedené v /etc/samba/smb.conf, čo je konfiguračný súbor pre programy Samba (nmbd a smbd). Váš súčasný súbor smb.conf obsahuje riadok „include“ alebo voľbu, ktorá presahuje viac riadkov. Toto môže zapríčiniť zlé automatické nastavenie, takže pre správnu funkčnosť možno budete musieť upraviť smb.conf manuálne.
 .
 Ak si nezvolíte túto možnosť, budete musieť sami zvládnuť všetky nastavenia a nebudete môcť využívať výhody pravidelných vylepšení tohto súboru.
Description-sl.UTF-8: Samodejna nastavitev smb.conf?
 Ostanek nastavitev Sambe se nanaša na vprašanja, ki vplivajo na parametre v /etc/samba/smb.conf. Ta datoteka se uporablja za konfiguracijo Samba programov (nmbd in smbd). Vaš trenutni smb.conf vključuje vrstico 'include'  ali možnost, ki se razteza čez več vrstic konfiguracijske datoteke in lahko povzroči zmedo v procesu avtomatskih nastavitev. Za ponovno vzpostavitev delovanja bo potrebno ročno urejanje konfiguracijske datoteke z nastavitvami smb.conf.
 .
 Če ne izberete te možnosti, boste morali vse spremembe nastavitev opraviti sami in ne boste mogli uporabljati periodičnih samodejnih izboljšav nastavitev.
Description-sq.UTF-8: Ta konfiguroj smb.conf automatikisht?
 Pjesa e mbetur e konfigurimit Samba ka të bëjë me pyetje që prekin parametra në /etc/samba/smb.conf, e cili është skeda që përdoret për të konfiguruar programet Samba (nmbd dhe smbd). smb.conf yt i tanishëm përmban një rresht 'include' ose një mundësi që tendos rreshta të shumëfishtë, të cilët mund të hutojnë proçesin automatik të konfigurimit dhe të të kërkojë ta ndryshosh skedarin tënd smb.conf dorazi dhe ta vesh në punë sërish.
 .
 Nëse nuk zgjedh këtë mundësi, do të duhet të kryesh çdo ndryshim konfigurimi vetë, dhe nuk do kesh rastin të përfitosh nga përmirësime periodike konfigurimi.
Description-sv.UTF-8: Konfigurera smb.conf automatiskt?
 Resten av Samba-konfigurationen hanterar frågor som rör parametrar i /etc/samba/smb.conf, vilken är den fil som används för att konfigurera Samba-programmen (nmbd och smbd). Din aktuella smb.conf innehåller en "include"-rad eller ett alternativ som spänner över flera rader som kan göra Debconf förvirrad och kan innebära att du måste redigera din smb.conf på egen hand för att få det att fungera igen.
 .
 Om du inte väljer detta alternativ måste du hantera alla konfigurationsändringar på egen hand och kan därför inte utnyttja fördelarna med periodiska konfigurationsförbättringar.
Description-ta.UTF-8: smb.conf ஐ தானியங்கியாக வடிவமைக்கலாமா?
 மற்ற சாம்பா வடிவமைப்பு /etc/samba/smb.conf கோப்பில் உள்ள எல்லை செயல் அலகுகளை (parameters) பாதிக்கும் கேள்விகளைப் பற்றியது. இந்த கோப்பு சாம்பா நிரல்களை(nmbd and smbd) (என்எம்பிடி மற்றும் எஸ்எம்பிடி) வடிவமைக்க பயன்படுவது. உங்களது தற்போதைய smb.conf கோப்பு 'இன்க்லூட்' ('include') வரி அல்லது பல வரிகளை ஆக்கிரமிக்கும் தேர்வை உள்ளடக்கியது. இது தானியங்கி வடிவமைப்பு செயலை குழப்பலாம். அதனால் அது மீண்டும் வேலை செய்வதற்கு உங்களை கைமுறையாக உங்கள் smb.conf கோப்பை திருத்தக் கோரலாம்.
 .
 நீங்கள் இதை தேர்ந்தெடுக்காவிட்டால் எந்த வடிவமைப்பையும் நீங்களேதான் செய்ய வேண்டும். மேலும் அவ்வப்போது நிகழும் வடிவமைப்பு மேம்பாட்டு வசதியை இழக்க நேரும்.
Description-th.UTF-8: จะตั้งค่า smb.conf แบบอัตโนมัติหรือไม่?
 การตั้งค่า Samba ในส่วนที่เหลือ จะเป็นคำถามที่จะมีผลต่อค่าต่างๆ ใน /etc/samba/smb.conf ซึ่งเป็นแฟ้มที่ใช้กำหนดค่าโปรแกรมของ Samba (nmbd และ smbd)  แฟ้ม smb.conf ปัจจุบันของคุณ มีบรรทัด 'include' หรือมีตัวเลือกที่ยาวหลายบรรทัด ซึ่งจะเป็นปัญหาต่อกระบวนการตั้งค่าแบบอัตโนมัติ และคุณต้องแก้ไขแฟ้ม smb.conf ของคุณเองก่อน เพื่อให้สามารถใช้งานได้
 .
 ถ้าคุณไม่เลือกตัวเลือกนี้ คุณจะต้องจัดการการตั้งค่าต่างๆ เอง และจะไม่สามารถใช้ประโยชน์จากการต่อเติมค่าตั้งที่มีอยู่เป็นระยะได้
Description-tl.UTF-8: Awtomatikong isaayos ang smb.conf?
 Ang natitirang pagsasaayos ng Samba ay may mga katanungan tungkol sa mga parameter sa /etc/samba/smb.conf, na siyang talaksan na ginagamit sa pagsaayos ng mga programang Samba (nmbd at smbd). Ang kasalukuyang smb.conf ninyo ay naglalaman ng 'include' na linya o opsiyon na labis sa isang linya, na maaaring makalito  sa prosesong pagsaayos na awtomatiko at kakailanganin ninyong i-edit ang inyong smb.conf ng de kamay upang ito'y umandar muli. 
 .
 Kung hindi ninyo pinili ang opsiyon na ito, kakailanganin ninyong ayusin ang anumang pagbabagong pagsasaayos, at hindi ninyo mapapakinabangan ang mga paminsanang pagpapahusay ng pagsasaayos.
Description-tr.UTF-8: smb.conf dosyası özdevimli olarak yapılandırılsın mı?
 Geri kalan Samba yapılandırması, Samba uygulamalarını (nmbd ve smbd) yapılandırmak için kullanılan /etc/samba/smb.conf dosyasındaki parametreleri etkileyen sorularla sürecektir. Varolan smb.conf dosyanız, kendiliğinden yapılandırma sürecini şaşırtabilecek bir "include" satırı ya da birden fazla satıra yayılan bir seçenek içerdiğinden Samba'nın yeniden çalışabilmesi için bu dosyanın elle düzenlenmesi gerekebilir.
 .
 Eğer bu seçeneği seçmezseniz, bütün yapılandırma değişikliklerini kendiniz yapmak zorunda kalacak ve periyodik yapılandırma iyileştirmelerinin avantajlarını kullanamayacaksınız.
Description-vi.UTF-8: Tự động cấu hình « smb.conf » ?
 Phần còn lại của cấu hình Samba đề cập các câu hỏi về tham số trong tập tin « /etc/samba/smb.conf », tập tin được dùng để cấu hình các chương trình Samba (nmbd và smbd). Tập tin « smb.conf » hiện thời chứa một dòng « include » (gồm) hay một tùy chọn chiếm nhiều dòng, mà có thể gây ra lỗi trong tiến trình cấu hình tự động thì cần thiết bạn tự sửa đổi tập tin « smb.conf » mình để kích hoạt lại nó.
 .
 Không bật tùy chọn này thì bạn cần phải tự quản lý thay đổi cấu hình nào, và không thể nhớ dịp sự tăng cường cấu hình định kỳ.
Description-wo.UTF-8: Ndax ñu komfigureel smb.conf sunu boppu?
 Li des ci komfiguraasioŋ bu samba ay laaj la yu aju ci parameetar yu /etc/samba/smb.conf, nga xam ne mooy fiise biñuy jëfandikoo ngir komfigure prograam yu samba (nmbd ak smbd). Sa fiise smb.conf bii nga yore fii mune, amna aw bind wu 'include' walla ab tann bu tallalu ci ay bind yu bare, ta loolu man naa jaxase komfiguraasioŋ otomatik bi, ba taxna danga koy wara soppi ak sa loxo, ngir léppu awaat yoon.
 .
 Bu fekkee tannoo lii, kon bépp coppat booy def ci komfiguraasioŋ bi danga koy defal sa boppu, ta kon doo mana jariñu ci rafetal ak jekkal yiñuy farala def ci komfiguraasioŋ bi.
Description-zh_CN.UTF-8: 自动配置 smb.conf 吗？
 余下的 Samba 配置涉及那些影响 /etc/samba/smb.conf 中参数的问题。此文件是用来配置 Samba 程序 (nmbd 和 smbd)。您目前的 smb.conf 包括一个“include”行或者一个跨越多行的选项，这将搅乱自动配置程序并需要您手动修改 smb.conf 以使其正常工作。
 .
 如果您不选中此项，您就必须自己处理所有的配置改变，也无法享受到定期的配置改进特性。
Description-zh_TW.UTF-8: 自動設定 smb.conf 嗎？
 剩下的 Sabma 設定將處理那些會影響到 /etc/samba/smb.conf 中的參數的問題。這個檔案是用來設定 Sabma 程式（nmbd 和 smbd）。但您目前的 smb.conf 裡中包含了一行 "include"，或是有某個選項跨越多行，這將會攪亂自動設定程序，使得您必須手動修復 smb.conf 才能讓它正常運作。
 .
 如果您不選取這個選項，您就必須自行處理所有的設定上的改變，同時也將無法受益於定期的設定改進所帶來的好處。

Template: samba-common/workgroup
Type: string
Default: WORKGROUP
Description: Workgroup/Domain Name:
 Please specify the workgroup for this system.  This setting controls which
 workgroup the system will appear in when used as a server, the default
 workgroup to be used when browsing with various frontends, and the domain
 name used with the "security=domain" setting.
Description-ar.UTF-8:  اسم مجموعة العمل/الحقل:
 رجاءً حدد مجموعة العمل لهذا النظام. يتحكم هذا الإعداد باسم مجموعة العمل التي سيظهر بها النظام عند استخدامه كخادم، وهي مجموعة العمل الافتراضية التي يجب استخدامها عند التصفح باستخدام الواجهات المختلفة، واسم النطاق المستخدم في الإعداد "security=domain".
Description-ast.UTF-8: Nome de Grupu/Dominiu:
 Por favor, pon el grupu de trabayu pa esti sistema. Esta opción remana'l sistema de grupos de trabayu que s'espublizará cuando s'usa como un sirvidor, por defeutu el grupu de trabayu a ser usaos mientres la ñavegación con distintos interfaces, y el nome de dominiu usáu cola configuración "security=domain"
Description-be.UTF-8: Працоўная група/Імя дамену:
 Пазначце працоўную групу сістэмы. Гэта наладка кантралюе: у якой групе з'явіцца ваша сістэма ў якасці сервера; стандартную групу пры прагляданні сеціва; імя дамену, якое ўжываецца пры выкарыстанні наладкі security=domain.
Description-bg.UTF-8: Работна група/домейн:
 Въведете името на работната група, от която ще бъде част компютъра. Този параметър контролира името на компютъра, когато се използва като сървър, работната група по подразбиране при разглеждане на мрежата и името на домейна, което ще се използва при настройката „security=domain“.
Description-bn.UTF-8: ওয়ার্কগ্রুপ/ডোমেইন নাম:
 অনুগ্রহ করে এই সিস্টেমের জন্য ওয়ার্কগ্রুপ উল্লেখ করুন। সার্ভার হিসেবে ব্যবহারের সময় সিস্টেম কোন ওয়ার্কগ্রুপের হয়ে দেখা দেবে, অনেক ফ্রন্টএন্ডের সাথে ব্রাউজিং এর সময় ব্যবহৃত ডিফল্ট ওয়ার্কগ্রুপ, এবং "security=domain" সেটিং এ ব্যবহৃত ডোমেইন নাম এই সেটিং নিয়ন্ত্রন করে।
Description-ca.UTF-8: Grup de treball/nom del domini:
 Indiqueu el grup de treball per a aquest sistema. Aquest paràmetre controla en quin grup de treball apareixerà el sistema quan s'empre com a servidor, el grup de treball per defecte quan es navega amb diferents interfícies, i el nom de domini emprat amb el paràmetre «security=domain».
Description-cs.UTF-8: Skupina/název domény:
 Zadejte jméno skupiny, do které má počítač patřit. Při použití počítače v roli serveru se klientům bude jevit, že server patří do zadané skupiny. Jméno skupiny se také použije jako výchozí skupina v různých programech pro procházení sítí. A konečně tento parametr určuje název domény v případech, kdy používáte nastavení „security=domain“.
Description-da.UTF-8: Arbejdsgruppe/domænenavn:
 Angiv venligst arbejdsgruppen for dette system. Denne indstilling kontroller hvilken arbejdsgruppe systemet vil fremgå i, når den bruges som en server, standardarbejdsgruppen der bruges når der browses med forskellige grænseflader, og domænenavnet brugt med indstillingen »security=domain«.
Description-de.UTF-8: Arbeitsgruppen-/Domain-Name:
 Bitte geben Sie die Arbeitsgruppe für dieses System an. Diese Einstellung beeinflußt, in welcher Arbeitsgruppe das System erscheint, wenn es als Server verwendet wird, die zu verwendende Standard-Arbeitsgruppe, wenn das Netzwerk mit verschiedenen Programmen durchsucht wird sowie den Domain-Namen, der für die Einstellung »security=domain« verwendet wird.
Description-el.UTF-8: Όνομα Ομάδας Εργασίας/Τομέα:
 Παρακαλώ προσδιορίστε το όνομα της ομάδας εργασίας (workgroup) του συστήματος.  Η παράμετρος αυτή ελέγχει την ομάδα εργασίας με την οποία θα εμφανίζεται το σύστημα ως εξυπηρετητής, την προκαθορισμένη ομάδα εργασίας κατά την περιήγηση με διάφορα προγράμματα, και το όνομα του τομέα που χρησιμοποιείται στην ρύθμιση security=domain.
Description-eo.UTF-8: Laborgrupo/Domajno-Nomo:
 Bonvolu indiki la laborgrupon por tiu ĉi sistemo. Tiu ĉi difino regas kiun laborgrupon la sistemo aperigos kiam uzata kiel servilon, la implicitan laborgrupon uzatan dum esplorado per pluraj klientoj, kaj la domajno-nomon uzatan kun la parametro "security=domain".
Description-es.UTF-8: Nombre del dominio o del grupo de trabajo:
 Indique el grupo de trabajo de este equipo. Este parámetro controla el grupo de trabajo en el que aparecerá el equipo si se usa como un servidor, el grupo de trabajo a usar cuando explore la red con los distintos interfaces, y el nombre de dominio usado con el parámetro «security=domain».
Description-eu.UTF-8: Lantaldearen/Domeinuaren izena:
 Zehaztu sistema honetarako lantaldea. Ezarpen honek sistema zerbitzari moduan erabiltzean agertuko den lantaldea, zenbait interfaze bidez bistaratzean erabiliko den lehenetsitako lantaldea eta "security=domain" ezarpenak erabiltzen duen domeinu izena kontrolatzen ditu.
Description-fi.UTF-8: Työryhmän/Verkkoalueen nimi:
 Anna tämän järjestelmän työryhmän nimi. Asetuksella määritetään mihin työryhmään järjestelmä kuuluu sen toimiessa palvelimena, oletustyöryhmä selattaessa edustaohjelmilla ja asetuksen "security=domain" kanssa käytettävä verkkoalueen nimi.
Description-fr.UTF-8: Nom de domaine ou de groupe de travail :
 Veuillez indiquer le groupe de travail pour ce système. Ce réglage définit le groupe de travail où le système apparaîtra s'il est utilisé comme serveur, le groupe de travail utilisé par défaut avec les divers outils de Samba ainsi que le nom de domaine utilisé le cas échéant avec le paramètre « security=domain ».
Description-gl.UTF-8: Nome do grupo de traballo/dominio:
 Indique o grupo de traballo para este sistema. Este parámetro controla o grupo de traballo no que este sistema aparecerá cando funcione como servidor, o grupo de traballo que se usará ao navegar usando varios clientes, e o nome de dominio que se emprega coa configuración security=domain.
Description-he.UTF-8: שם קבוצת העבודה/מתחם (Workgroup/Domain):
 אנא ציין את שם קבוצת העבודה (Workgroup) עבור מערכת זו. הגדרה זו קובעת באיזו קבוצת עבודה תימצא מערכת זו כשישתמשו בה בתור שרת, מה תהיה ברירת המחדל לקבוצת העבודה שישתמשו בה בזמן דפדוף באמצעות ממשקים שונים, ושם המתחם (Domain) בעת שימוש באפשרות security=domain.
Description-id.UTF-8: Nama Domain/Workgrop:
 Mohon tentukan workgroup untuk sistem ini. Pengaturan kontrol workgroup apaa yang akan tampil jika digunakan sebagai server, workgrup bawaan akan digunakan ketika menjelajahi dengan berbagai frontends, dan nama doman digunakan dengan pengaturan "security=domain".
Description-it.UTF-8: Nome del Gruppo di lavoro/Dominio:
 Specificare il gruppo di lavoro per questo sistema. Questa impostazione controlla: in quale gruppo di lavoro appare il sistema quando è usato come server, il gruppo di lavoro predefinito usato nelle varie interfacce di navigazione e il nome del dominio se è usato il parametro «security=domain».
Description-ja.UTF-8: ワークグループ/ドメイン名:
 このシステムのワークグループを指定してください。この設定は、システムがサーバとして使われるときにどのワークグループとして現れるか、いくつかのフロントエンドでブラウジングされたときに使われるデフォルトのワークグループ、そして"security=domain" 設定が使われたときのドメイン名を制御します。
Description-ku.UTF-8: Navê Koma Xebatê/Domain:
 Tika ye Koma Xebatê ya vê pergalê diyar bike. Ev mîheng kontrol dike ka dê di bikaranîna pêşkêşkarekê de kîjan Koma Xebatê bê nîşandan, Koma Xebatê ya heyî ya dem bi dem fronted tê gerîn û navê domaînê ya bi mîhenga  "security=domain"ê tê bikaranîn.
Description-nb.UTF-8: Arbeidsgruppe/domenenavn:
 Oppgi arbeidsgruppen for dette systemet. Denne innstillingen styrer hvilken arbeidsgruppe systemet blir vist i når det brukes som en tjener, standard arbeidsgruppe som skal brukes når diverse forgrunnsmotorer brukes til å bla med, og  domenenavnet som brukes med innstillingen «security=domain».
Description-nl.UTF-8: Werkgroep/Domeinnaam:
 Tot welke werkgroep behoort dit systeem? Deze instelling bepaalt ook de werkgroep waarin dit systeem zal verschijnen wanneer het als server wordt gebruikt, de standaard werkgroep die gebruikt wordt bij het verkennen met de diverse interfaces, en de domeinnaam die wordt gebruikt voor de instelling "security=domain".
Description-no.UTF-8: Arbeidsgruppe/domenenavn:
 Oppgi arbeidsgruppen for dette systemet. Denne innstillingen styrer hvilken arbeidsgruppe systemet blir vist i når det brukes som en tjener, standard arbeidsgruppe som skal brukes når diverse forgrunnsmotorer brukes til å bla med, og  domenenavnet som brukes med innstillingen «security=domain».
Description-pl.UTF-8: Nazwa grupy roboczej/domeny:
 Proszę określić grupę roboczą systemu. To ustawienie określa grupę roboczą, w której pojawi się system, jeśli będzie użyty w roli serwera; domyślną grupę roboczą, która będzie użyta podczas przeglądania z poziomu różnych interfejsów oraz nazwę domeny używaną w ustawieniu "security=domain".
Description-pt.UTF-8: Nome do Grupo de trabalho/Domínio:
 Por favor especifique o grupo de trabalho para este sistema. Esta configuração controla qual o grupo de trabalho que irá aparecer quando for utilizado como servidor, o grupo de trabalho predefinido a ser utilizado ao navegar com vários frontends, e o nome de domínio utilizado com a configuração "security=domain".
Description-pt_BR.UTF-8: Grupo de Trabalho/Nome de Domínio:
 Por favor, especifique o grupo de trabalho para este sistema. Esta configuração controla em qual grupo de trabalho o sistema aparecerá quando usado como um servidor, qual o grupo de trabalho padrão a ser usado ao navegar usando vários "frontends", e qual o nome de domínio usado com a configuração "security=domain".
Description-ru.UTF-8: Рабочая группа/домен:
 Укажите рабочую группу системы. Этой настройкой задаётся рабочая группа, в которой будет появляться данный компьютер, если он используется как сервер, в качестве рабочей группы по умолчанию при просмотре сети из различных клиентских программ, а также в качестве имени домена при использовании параметра «security=domain».
Description-sk.UTF-8: Pracovná skupina/Názov domény:
 Zadajte názov pracovnej skupiny pre tento počítač. Táto voľba určuje v ktorej pracovnej skupine sa má tento systém objaviť keď sa k nemu pristupuje ako k serveru, pri prehliadaní rôznymi rozhraniami a názov domény, ktorá sa používa pri nastavení „security=domain“.
Description-sv.UTF-8: Arbetsgrupp/Domännamn:
 Ange vilken arbetsgrupp som dettaa system tillhör. Denna inställning anger vilken arbetsgrupp systemet kommer att hamna i när det används som server, inställningen anger vilken standardgrupp som kommer att sökas igenom med de klientprogram som finns och detta kommer att vara domännamnet som används tillsammans med inställningen "security=domain".
Description-th.UTF-8: เวร์กกรุ๊ป/ชื่อโดเมน:
 กรุณาระบุเวิร์กกรุ๊ปสำหรับระบบนี้ ค่านี้จะกำหนดเวิร์กกรุ๊ปที่ระบบนี้จะเข้าร่วมเมื่อใช้เป็นเซิร์ฟเวอร์, กำหนดเวิร์กกรุ๊ปปริยายที่จะใช้เมื่อท่องดูด้วยโปรแกรมต่างๆ และกำหนดชื่อโดเมนที่จะใช้ในกรณีที่ตั้งค่า "security=domain" ด้วย
Description-tr.UTF-8: Çalışma Grubu / Etki Alanı Adı:
 Lütfen bu sistem için bir çalışma grubu belirtin. Bu ayar sistemin sunucu olarak kullanıldığı durumda hangi çalışma grubunda gözükeceğini belirleyeceği gibi, ağda yapılacak göz atmalarda öntanımlı çalışma grubu olacak ve ayrıca "security=domain" ayarında etki alanı adı olarak kullanılacaktır.
Description-vi.UTF-8: Tên Nhóm làm việc/Miền:
 Hãy xác định nhóm làm việc cho hệ thống này. Thiết lập này điều khiển nhóm làm việc trong đó hệ thống sẽ xuất hiện khi dùng làm trình phục vụ (nhóm làm việc mặc định được dùng khi duyệt qua giao diện) và tên miền được dùng với thiết lập « security=domain » (bảo mật=miền).
Description-zh_TW.UTF-8: 群組/網域：
 請指定這個系統的群組。這個選項控制了當它做為伺服器時，這個系統會出現在哪個群組裡、以及很多前端程式在瀏覽時所會使用的預設群組，以及 "security=domain" 這個設定所會用到的網域名稱。

                                                                                                                                                                                                                                /*
 * This file is subject to the terms and conditions of the GNU General
 * Public License.  See the file "COPYING" in the main directory of this
 * archive for more details.
 *
 * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)
 * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.
 * Copyright (C) 2000, 2001, 2002 Ralf Baechle
 * Copyright (C) 2000, 2001 Broadcom Corporation
 */
#ifndef __ASM_SMP_OPS_H
#define __ASM_SMP_OPS_H

#include <linux/errno.h>

#include <asm/mips-cm.h>

#ifdef CONFIG_SMP

#include <linux/cpumask.h>

struct task_struct;

struct plat_smp_ops {
	void (*send_ipi_single)(int cpu, unsigned int action);
	void (*send_ipi_mask)(const struct cpumask *mask, unsigned int action);
	void (*init_secondary)(void);
	void (*smp_finish)(void);
	void (*boot_secondary)(int cpu, struct task_struct *idle);
	void (*smp_setup)(void);
	void (*prepare_cpus)(unsigned int max_cpus);
#ifdef CONFIG_HOTPLUG_CPU
	int (*cpu_disable)(void);
	void (*cpu_die)(unsigned int cpu);
#endif
};

extern void register_smp_ops(struct plat_smp_ops *ops);

static inline void plat_smp_setup(void)
{
	extern struct plat_smp_ops *mp_ops;	/* private */

	mp_ops->smp_setup();
}

extern void mips_smp_send_ipi_single(int cpu, unsigned int action);
extern void mips_smp_send_ipi_mask(const struct cpumask *mask,
				      unsigned int action);

#else /* !CONFIG_SMP */

struct plat_smp_ops;

static inline void plat_smp_setup(void)
{
	/* UP, nothing to do ...  */
}

static inline void register_smp_ops(struct plat_smp_ops *ops)
{
}

#endif /* !CONFIG_SMP */

static inline int register_up_smp_ops(void)
{
#ifdef CONFIG_SMP_UP
	extern struct plat_smp_ops up_smp_ops;

	register_smp_ops(&up_smp_ops);

	return 0;
#else
	return -ENODEV;
#endif
}

static inline int register_cmp_smp_ops(void)
{
#ifdef CONFIG_MIPS_CMP
	extern struct plat_smp_ops cmp_smp_ops;

	if (!mips_cm_present())
		return -ENODEV;

	register_smp_ops(&cmp_smp_ops);

	return 0;
#else
	return -ENODEV;
#endif
}

static inline int register_vsmp_smp_ops(void)
{
#ifdef CONFIG_MIPS_MT_SMP
	extern struct plat_smp_ops vsmp_smp_ops;

	register_smp_ops(&vsmp_smp_ops);

	return 0;
#else
	return -ENODEV;
#endif
}

#ifdef CONFIG_MIPS_CPS
extern int register_cps_smp_ops(void);
#else
static inline int register_cps_smp_ops(void)
{
	return -ENODEV;
}
#endif

#endif /* __ASM_SMP_OPS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Copyright (C) 2013 Imagination Technologies
 * Author: Paul Burton <paul.burton@imgtec.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#ifndef __MIPS_ASM_MIPS_CM_H__
#define __MIPS_ASM_MIPS_CM_H__

#include <linux/bitops.h>
#include <linux/errno.h>
#include <linux/io.h>
#include <linux/types.h>

/* The base address of the CM GCR block */
extern void __iomem *mips_cm_base;

/* The base address of the CM L2-only sync region */
extern void __iomem *mips_cm_l2sync_base;

/**
 * __mips_cm_phys_base - retrieve the physical base address of the CM
 *
 * This function returns the physical base address of the Coherence Manager
 * global control block, or 0 if no Coherence Manager is present. It provides
 * a default implementation which reads the CMGCRBase register where available,
 * and may be overridden by platforms which determine this address in a
 * different way by defining a function with the same prototype except for the
 * name mips_cm_phys_base (without underscores).
 */
extern phys_addr_t __mips_cm_phys_base(void);

/*
 * mips_cm_is64 - determine CM register width
 *
 * The CM register width is determined by the version of the CM, with CM3
 * introducing 64 bit GCRs and all prior CM versions having 32 bit GCRs.
 * However we may run a kernel built for MIPS32 on a system with 64 bit GCRs,
 * or vice-versa. This variable indicates the width of the memory accesses
 * that the kernel will perform to GCRs, which may differ from the actual
 * width of the GCRs.
 *
 * It's set to 0 for 32-bit accesses and 1 for 64-bit accesses.
 */
extern int mips_cm_is64;

/**
 * mips_cm_error_report - Report CM cache errors
 */
#ifdef CONFIG_MIPS_CM
extern void mips_cm_error_report(void);
#else
static inline void mips_cm_error_report(void) {}
#endif

/**
 * mips_cm_probe - probe for a Coherence Manager
 *
 * Attempt to detect the presence of a Coherence Manager. Returns 0 if a CM
 * is successfully detected, else -errno.
 */
#ifdef CONFIG_MIPS_CM
extern int mips_cm_probe(void);
#else
static inline int mips_cm_probe(void)
{
	return -ENODEV;
}
#endif

/**
 * mips_cm_present - determine whether a Coherence Manager is present
 *
 * Returns true if a CM is present in the system, else false.
 */
static inline bool mips_cm_present(void)
{
#ifdef CONFIG_MIPS_CM
	return mips_cm_base != NULL;
#else
	return false;
#endif
}

/**
 * mips_cm_has_l2sync - determine whether an L2-only sync region is present
 *
 * Returns true if the system implements an L2-only sync region, else false.
 */
static inline bool mips_cm_has_l2sync(void)
{
#ifdef CONFIG_MIPS_CM
	return mips_cm_l2sync_base != NULL;
#else
	return false;
#endif
}

/* Offsets to register blocks from the CM base address */
#define MIPS_CM_GCB_OFS		0x0000 /* Global Control Block */
#define MIPS_CM_CLCB_OFS	0x2000 /* Core Local Control Block */
#define MIPS_CM_COCB_OFS	0x4000 /* Core Other Control Block */
#define MIPS_CM_GDB_OFS		0x6000 /* Global Debug Block */

/* Total size of the CM memory mapped registers */
#define MIPS_CM_GCR_SIZE	0x8000

/* Size of the L2-only sync region */
#define MIPS_CM_L2SYNC_SIZE	0x1000

/* Macros to ease the creation of register access functions */
#define BUILD_CM_R_(name, off)					\
static inline unsigned long __iomem *addr_gcr_##name(void)	\
{								\
	return (unsigned long __iomem *)(mips_cm_base + (off));	\
}								\
								\
static inline u32 read32_gcr_##name(void)			\
{								\
	return __raw_readl(addr_gcr_##name());			\
}								\
								\
static inline u64 read64_gcr_##name(void)			\
{								\
	void __iomem *addr = addr_gcr_##name();			\
	u64 ret;						\
								\
	if (mips_cm_is64) {					\
		ret = __raw_readq(addr);			\
	} else {						\
		ret = __raw_readl(addr);			\
		ret |= (u64)__raw_readl(addr + 0x4) << 32;	\
	}							\
								\
	return ret;						\
}								\
								\
static inline unsigned long read_gcr_##name(void)		\
{								\
	if (mips_cm_is64)					\
		return read64_gcr_##name();			\
	else							\
		return read32_gcr_##name();			\
}

#define BUILD_CM__W(name, off)					\
static inline void write32_gcr_##name(u32 value)		\
{								\
	__raw_writel(value, addr_gcr_##name());			\
}								\
								\
static inline void write64_gcr_##name(u64 value)		\
{								\
	__raw_writeq(value, addr_gcr_##name());			\
}								\
								\
static inline void write_gcr_##name(unsigned long value)	\
{								\
	if (mips_cm_is64)					\
		write64_gcr_##name(value);			\
	else							\
		write32_gcr_##name(value);			\
}

#define BUILD_CM_RW(name, off)					\
	BUILD_CM_R_(name, off)					\
	BUILD_CM__W(name, off)

#define BUILD_CM_Cx_R_(name, off)				\
	BUILD_CM_R_(cl_##name, MIPS_CM_CLCB_OFS + (off))	\
	BUILD_CM_R_(co_##name, MIPS_CM_COCB_OFS + (off))

#define BUILD_CM_Cx__W(name, off)				\
	BUILD_CM__W(cl_##name, MIPS_CM_CLCB_OFS + (off))	\
	BUILD_CM__W(co_##name, MIPS_CM_COCB_OFS + (off))

#define BUILD_CM_Cx_RW(name, off)				\
	BUILD_CM_Cx_R_(name, off)				\
	BUILD_CM_Cx__W(name, off)

/* GCB register accessor functions */
BUILD_CM_R_(config,		MIPS_CM_GCB_OFS + 0x00)
BUILD_CM_RW(base,		MIPS_CM_GCB_OFS + 0x08)
BUILD_CM_RW(access,		MIPS_CM_GCB_OFS + 0x20)
BUILD_CM_R_(rev,		MIPS_CM_GCB_OFS + 0x30)
BUILD_CM_RW(err_control,	MIPS_CM_GCB_OFS + 0x38)
BUILD_CM_RW(error_mask,		MIPS_CM_GCB_OFS + 0x40)
BUILD_CM_RW(error_cause,	MIPS_CM_GCB_OFS + 0x48)
BUILD_CM_RW(error_addr,		MIPS_CM_GCB_OFS + 0x50)
BUILD_CM_RW(error_mult,		MIPS_CM_GCB_OFS + 0x58)
BUILD_CM_RW(l2_only_sync_base,	MIPS_CM_GCB_OFS + 0x70)
BUILD_CM_RW(gic_base,		MIPS_CM_GCB_OFS + 0x80)
BUILD_CM_RW(cpc_base,		MIPS_CM_GCB_OFS + 0x88)
BUILD_CM_RW(reg0_base,		MIPS_CM_GCB_OFS + 0x90)
BUILD_CM_RW(reg0_mask,		MIPS_CM_GCB_OFS + 0x98)
BUILD_CM_RW(reg1_base,		MIPS_CM_GCB_OFS + 0xa0)
BUILD_CM_RW(reg1_mask,		MIPS_CM_GCB_OFS + 0xa8)
BUILD_CM_RW(reg2_base,		MIPS_CM_GCB_OFS + 0xb0)
BUILD_CM_RW(reg2_mask,		MIPS_CM_GCB_OFS + 0xb8)
BUILD_CM_RW(reg3_base,		MIPS_CM_GCB_OFS + 0xc0)
BUILD_CM_RW(reg3_mask,		MIPS_CM_GCB_OFS + 0xc8)
BUILD_CM_R_(gic_status,		MIPS_CM_GCB_OFS + 0xd0)
BUILD_CM_R_(cpc_status,		MIPS_CM_GCB_OFS + 0xf0)
BUILD_CM_RW(l2_config,		MIPS_CM_GCB_OFS + 0x130)
BUILD_CM_RW(sys_config2,	MIPS_CM_GCB_OFS + 0x150)
BUILD_CM_RW(l2_pft_control,	MIPS_CM_GCB_OFS + 0x300)
BUILD_CM_RW(l2_pft_control_b,	MIPS_CM_GCB_OFS + 0x308)
BUILD_CM_RW(bev_base,		MIPS_CM_GCB_OFS + 0x680)

/* Core Local & Core Other register accessor functions */
BUILD_CM_Cx_RW(reset_release,	0x00)
BUILD_CM_Cx_RW(coherence,	0x08)
BUILD_CM_Cx_R_(config,		0x10)
BUILD_CM_Cx_RW(other,		0x18)
BUILD_CM_Cx_RW(reset_base,	0x20)
BUILD_CM_Cx_R_(id,		0x28)
BUILD_CM_Cx_RW(reset_ext_base,	0x30)
BUILD_CM_Cx_R_(tcid_0_priority,	0x40)
BUILD_CM_Cx_R_(tcid_1_priority,	0x48)
BUILD_CM_Cx_R_(tcid_2_priority,	0x50)
BUILD_CM_Cx_R_(tcid_3_priority,	0x58)
BUILD_CM_Cx_R_(tcid_4_priority,	0x60)
BUILD_CM_Cx_R_(tcid_5_priority,	0x68)
BUILD_CM_Cx_R_(tcid_6_priority,	0x70)
BUILD_CM_Cx_R_(tcid_7_priority,	0x78)
BUILD_CM_Cx_R_(tcid_8_priority,	0x80)

/* GCR_CONFIG register fields */
#define CM_GCR_CONFIG_NUMIOCU_SHF		8
#define CM_GCR_CONFIG_NUMIOCU_MSK		(_ULCAST_(0xf) << 8)
#define CM_GCR_CONFIG_PCORES_SHF		0
#define CM_GCR_CONFIG_PCORES_MSK		(_ULCAST_(0xff) << 0)

/* GCR_BASE register fields */
#define CM_GCR_BASE_GCRBASE_SHF			15
#define CM_GCR_BASE_GCRBASE_MSK			(_ULCAST_(0x1ffff) << 15)
#define CM_GCR_BASE_CMDEFTGT_SHF		0
#define CM_GCR_BASE_CMDEFTGT_MSK		(_ULCAST_(0x3) << 0)
#define  CM_GCR_BASE_CMDEFTGT_MEM		0
#define  CM_GCR_BASE_CMDEFTGT_RESERVED		1
#define  CM_GCR_BASE_CMDEFTGT_IOCU0		2
#define  CM_GCR_BASE_CMDEFTGT_IOCU1		3

/* GCR_RESET_EXT_BASE register fields */
#define CM_GCR_RESET_EXT_BASE_EVARESET		BIT(31)
#define CM_GCR_RESET_EXT_BASE_UEB		BIT(30)

/* GCR_ACCESS register fields */
#define CM_GCR_ACCESS_ACCESSEN_SHF		0
#define CM_GCR_ACCESS_ACCESSEN_MSK		(_ULCAST_(0xff) << 0)

/* GCR_REV register fields */
#define CM_GCR_REV_MAJOR_SHF			8
#define CM_GCR_REV_MAJOR_MSK			(_ULCAST_(0xff) << 8)
#define CM_GCR_REV_MINOR_SHF			0
#define CM_GCR_REV_MINOR_MSK			(_ULCAST_(0xff) << 0)

#define CM_ENCODE_REV(major, minor) \
		(((major) << CM_GCR_REV_MAJOR_SHF) | \
		 ((minor) << CM_GCR_REV_MINOR_SHF))

#define CM_REV_CM2				CM_ENCODE_REV(6, 0)
#define CM_REV_CM2_5				CM_ENCODE_REV(7, 0)
#define CM_REV_CM3				CM_ENCODE_REV(8, 0)

/* GCR_ERR_CONTROL register fields */
#define CM_GCR_ERR_CONTROL_L2_ECC_EN_SHF	1
#define CM_GCR_ERR_CONTROL_L2_ECC_EN_MSK	(_ULCAST_(0x1) << 1)
#define CM_GCR_ERR_CONTROL_L2_ECC_SUPPORT_SHF	0
#define CM_GCR_ERR_CONTROL_L2_ECC_SUPPORT_MSK	(_ULCAST_(0x1) << 0)

/* GCR_ERROR_CAUSE register fields */
#define CM_GCR_ERROR_CAUSE_ERRTYPE_SHF		27
#define CM_GCR_ERROR_CAUSE_ERRTYPE_MSK		(_ULCAST_(0x1f) << 27)
#define CM3_GCR_ERROR_CAUSE_ERRTYPE_SHF		58
#define CM3_GCR_ERROR_CAUSE_ERRTYPE_MSK		GENMASK_ULL(63, 58)
#define CM_GCR_ERROR_CAUSE_ERRINFO_SHF		0
#define CM_GCR_ERROR_CAUSE_ERRINGO_MSK		(_ULCAST_(0x7ffffff) << 0)

/* GCR_ERROR_MULT register fields */
#define CM_GCR_ERROR_MULT_ERR2ND_SHF		0
#define CM_GCR_ERROR_MULT_ERR2ND_MSK		(_ULCAST_(0x1f) << 0)

/* GCR_L2_ONLY_SYNC_BASE register fields */
#define CM_GCR_L2_ONLY_SYNC_BASE_SYNCBASE_SHF	12
#define CM_GCR_L2_ONLY_SYNC_BASE_SYNCBASE_MSK	(_ULCAST_(0xfffff) << 12)
#define CM_GCR_L2_ONLY_SYNC_BASE_SYNCEN_SHF	0
#define CM_GCR_L2_ONLY_SYNC_BASE_SYNCEN_MSK	(_ULCAST_(0x1) << 0)

/* GCR_GIC_BASE register fields */
#define CM_GCR_GIC_BASE_GICBASE_SHF		17
#define CM_GCR_GIC_BASE_GICBASE_MSK		(_ULCAST_(0x7fff) << 17)
#define CM_GCR_GIC_BASE_GICEN_SHF		0
#define CM_GCR_GIC_BASE_GICEN_MSK		(_ULCAST_(0x1) << 0)

/* GCR_CPC_BASE register fields */
#define CM_GCR_CPC_BASE_CPCBASE_SHF		15
#define CM_GCR_CPC_BASE_CPCBASE_MSK		(_ULCAST_(0x1ffff) << 15)
#define CM_GCR_CPC_BASE_CPCEN_SHF		0
#define CM_GCR_CPC_BASE_CPCEN_MSK		(_ULCAST_(0x1) << 0)

/* GCR_GIC_STATUS register fields */
#define CM_GCR_GIC_STATUS_GICEX_SHF		0
#define CM_GCR_GIC_STATUS_GICEX_MSK		(_ULCAST_(0x1) << 0)

/* GCR_REGn_BASE register fields */
#define CM_GCR_REGn_BASE_BASEADDR_SHF		16
#define CM_GCR_REGn_BASE_BASEADDR_MSK		(_ULCAST_(0xffff) << 16)

/* GCR_REGn_MASK register fields */
#define CM_GCR_REGn_MASK_ADDRMASK_SHF		16
#define CM_GCR_REGn_MASK_ADDRMASK_MSK		(_ULCAST_(0xffff) << 16)
#define CM_GCR_REGn_MASK_CCAOVR_SHF		5
#define CM_GCR_REGn_MASK_CCAOVR_MSK		(_ULCAST_(0x3) << 5)
#define CM_GCR_REGn_MASK_CCAOVREN_SHF		4
#define CM_GCR_REGn_MASK_CCAOVREN_MSK		(_ULCAST_(0x1) << 4)
#define CM_GCR_REGn_MASK_DROPL2_SHF		2
#define CM_GCR_REGn_MASK_DROPL2_MSK		(_ULCAST_(0x1) << 2)
#define CM_GCR_REGn_MASK_CMTGT_SHF		0
#define CM_GCR_REGn_MASK_CMTGT_MSK		(_ULCAST_(0x3) << 0)
#define  CM_GCR_REGn_MASK_CMTGT_DISABLED	(_ULCAST_(0x0) << 0)
#define  CM_GCR_REGn_MASK_CMTGT_MEM		(_ULCAST_(0x1) << 0)
#define  CM_GCR_REGn_MASK_CMTGT_IOCU0		(_ULCAST_(0x2) << 0)
#define  CM_GCR_REGn_MASK_CMTGT_IOCU1		(_ULCAST_(0x3) << 0)

/* GCR_GIC_STATUS register fields */
#define CM_GCR_GIC_STATUS_EX_SHF		0
#define CM_GCR_GIC_STATUS_EX_MSK		(_ULCAST_(0x1) << 0)

/* GCR_CPC_STATUS register fields */
#define CM_GCR_CPC_STATUS_EX_SHF		0
#define CM_GCR_CPC_STATUS_EX_MSK		(_ULCAST_(0x1) << 0)

/* GCR_L2_CONFIG register fields */
#define CM_GCR_L2_CONFIG_BYPASS_SHF		20
#define CM_GCR_L2_CONFIG_BYPASS_MSK		(_ULCAST_(0x1) << 20)
#define CM_GCR_L2_CONFIG_SET_SIZE_SHF		12
#define CM_GCR_L2_CONFIG_SET_SIZE_MSK		(_ULCAST_(0xf) << 12)
#define CM_GCR_L2_CONFIG_LINE_SIZE_SHF		8
#define CM_GCR_L2_CONFIG_LINE_SIZE_MSK		(_ULCAST_(0xf) << 8)
#define CM_GCR_L2_CONFIG_ASSOC_SHF		0
#define CM_GCR_L2_CONFIG_ASSOC_MSK		(_ULCAST_(0xff) << 0)

/* GCR_SYS_CONFIG2 register fields */
#define CM_GCR_SYS_CONFIG2_MAXVPW_SHF		0
#define CM_GCR_SYS_CONFIG2_MAXVPW_MSK		(_ULCAST_(0xf) << 0)

/* GCR_L2_PFT_CONTROL register fields */
#define CM_GCR_L2_PFT_CONTROL_PAGEMASK_SHF	12
#define CM_GCR_L2_PFT_CONTROL_PAGEMASK_MSK	(_ULCAST_(0xfffff) << 12)
#define CM_GCR_L2_PFT_CONTROL_PFTEN_SHF		8
#define CM_GCR_L2_PFT_CONTROL_PFTEN_MSK		(_ULCAST_(0x1) << 8)
#define CM_GCR_L2_PFT_CONTROL_NPFT_SHF		0
#define CM_GCR_L2_PFT_CONTROL_NPFT_MSK		(_ULCAST_(0xff) << 0)

/* GCR_L2_PFT_CONTROL_B register fields */
#define CM_GCR_L2_PFT_CONTROL_B_CEN_SHF		8
#define CM_GCR_L2_PFT_CONTROL_B_CEN_MSK		(_ULCAST_(0x1) << 8)
#define CM_GCR_L2_PFT_CONTROL_B_PORTID_SHF	0
#define CM_GCR_L2_PFT_CONTROL_B_PORTID_MSK	(_ULCAST_(0xff) << 0)

/* GCR_Cx_COHERENCE register fields */
#define CM_GCR_Cx_COHERENCE_COHDOMAINEN_SHF	0
#define CM_GCR_Cx_COHERENCE_COHDOMAINEN_MSK	(_ULCAST_(0xff) << 0)
#define CM3_GCR_Cx_COHERENCE_COHEN_MSK		(_ULCAST_(0x1) << 0)

/* GCR_Cx_CONFIG register fields */
#define CM_GCR_Cx_CONFIG_IOCUTYPE_SHF		10
#define CM_GCR_Cx_CONFIG_IOCUTYPE_MSK		(_ULCAST_(0x3) << 10)
#define CM_GCR_Cx_CONFIG_PVPE_SHF		0
#define CM_GCR_Cx_CONFIG_PVPE_MSK		(_ULCAST_(0x3ff) << 0)

/* GCR_Cx_OTHER register fields */
#define CM_GCR_Cx_OTHER_CORENUM_SHF		16
#define CM_GCR_Cx_OTHER_CORENUM_MSK		(_ULCAST_(0xffff) << 16)
#define CM3_GCR_Cx_OTHER_CORE_SHF		8
#define CM3_GCR_Cx_OTHER_CORE_MSK		(_ULCAST_(0x3f) << 8)
#define CM3_GCR_Cx_OTHER_VP_SHF			0
#define CM3_GCR_Cx_OTHER_VP_MSK			(_ULCAST_(0x7) << 0)

/* GCR_Cx_RESET_BASE register fields */
#define CM_GCR_Cx_RESET_BASE_BEVEXCBASE_SHF	12
#define CM_GCR_Cx_RESET_BASE_BEVEXCBASE_MSK	(_ULCAST_(0xfffff) << 12)

/* GCR_Cx_RESET_EXT_BASE register fields */
#define CM_GCR_Cx_RESET_EXT_BASE_EVARESET_SHF	31
#define CM_GCR_Cx_RESET_EXT_BASE_EVARESET_MSK	(_ULCAST_(0x1) << 31)
#define CM_GCR_Cx_RESET_EXT_BASE_UEB_SHF	30
#define CM_GCR_Cx_RESET_EXT_BASE_UEB_MSK	(_ULCAST_(0x1) << 30)
#define CM_GCR_Cx_RESET_EXT_BASE_BEVEXCMASK_SHF	20
#define CM_GCR_Cx_RESET_EXT_BASE_BEVEXCMASK_MSK	(_ULCAST_(0xff) << 20)
#define CM_GCR_Cx_RESET_EXT_BASE_BEVEXCPA_SHF	1
#define CM_GCR_Cx_RESET_EXT_BASE_BEVEXCPA_MSK	(_ULCAST_(0x7f) << 1)
#define CM_GCR_Cx_RESET_EXT_BASE_PRESENT_SHF	0
#define CM_GCR_Cx_RESET_EXT_BASE_PRESENT_MSK	(_ULCAST_(0x1) << 0)

/**
 * mips_cm_numcores - return the number of cores present in the system
 *
 * Returns the value of the PCORES field of the GCR_CONFIG register plus 1, or
 * zero if no Coherence Manager is present.
 */
static inline unsigned mips_cm_numcores(void)
{
	if (!mips_cm_present())
		return 0;

	return ((read_gcr_config() & CM_GCR_CONFIG_PCORES_MSK)
		>> CM_GCR_CONFIG_PCORES_SHF) + 1;
}

/**
 * mips_cm_numiocu - return the number of IOCUs present in the system
 *
 * Returns the value of the NUMIOCU field of the GCR_CONFIG register, or zero
 * if no Coherence Manager is present.
 */
static inline unsigned mips_cm_numiocu(void)
{
	if (!mips_cm_present())
		return 0;

	return (read_gcr_config() & CM_GCR_CONFIG_NUMIOCU_MSK)
		>> CM_GCR_CONFIG_NUMIOCU_SHF;
}

/**
 * mips_cm_l2sync - perform an L2-only sync operation
 *
 * If an L2-only sync region is present in the system then this function
 * performs and L2-only sync and returns zero. Otherwise it returns -ENODEV.
 */
static inline int mips_cm_l2sync(void)
{
	if (!mips_cm_has_l2sync())
		return -ENODEV;

	writel(0, mips_cm_l2sync_base);
	return 0;
}

/**
 * mips_cm_revision() - return CM revision
 *
 * Return: The revision of the CM, from GCR_REV, or 0 if no CM is present. The
 * return value should be checked against the CM_REV_* macros.
 */
static inline int mips_cm_revision(void)
{
	if (!mips_cm_present())
		return 0;

	return read_gcr_rev();
}

/**
 * mips_cm_max_vp_width() - return the width in bits of VP indices
 *
 * Return: the width, in bits, of VP indices in fields that combine core & VP
 * indices.
 */
static inline unsigned int mips_cm_max_vp_width(void)
{
	extern int smp_num_siblings;
	uint32_t cfg;

	if (mips_cm_revision() >= CM_REV_CM3)
		return read_gcr_sys_config2() & CM_GCR_SYS_CONFIG2_MAXVPW_MSK;

	if (mips_cm_present()) {
		/*
		 * We presume that all cores in the system will have the same
		 * number of VP(E)s, and if that ever changes then this will
		 * need revisiting.
		 */
		cfg = read_gcr_cl_config() & CM_GCR_Cx_CONFIG_PVPE_MSK;
		return (cfg >> CM_GCR_Cx_CONFIG_PVPE_SHF) + 1;
	}

	if (IS_ENABLED(CONFIG_SMP))
		return smp_num_siblings;

	return 1;
}

/**
 * mips_cm_vp_id() - calculate the hardware VP ID for a CPU
 * @cpu: the CPU whose VP ID to calculate
 *
 * Hardware such as the GIC uses identifiers for VPs which may not match the
 * CPU numbers used by Linux. This function calculates the hardware VP
 * identifier corresponding to a given CPU.
 *
 * Return: the VP ID for the CPU.
 */
static inline unsigned int mips_cm_vp_id(unsigned int cpu)
{
	unsigned int core = cpu_data[cpu].core;
	unsigned int vp = cpu_vpe_id(&cpu_data[cpu]);

	return (core * mips_cm_max_vp_width()) + vp;
}

#ifdef CONFIG_MIPS_CM

/**
 * mips_cm_lock_other - lock access to another core
 * @core: the other core to be accessed
 * @vp: the VP within the other core to be accessed
 *
 * Call before operating upon a core via the 'other' register region in
 * order to prevent the region being moved during access. Must be followed
 * by a call to mips_cm_unlock_other.
 */
extern void mips_cm_lock_other(unsigned int core, unsigned int vp);

/**
 * mips_cm_unlock_other - unlock access to another core
 *
 * Call after operating upon another core via the 'other' register region.
 * Must be called after mips_cm_lock_other.
 */
extern void mips_cm_unlock_other(void);

#else /* !CONFIG_MIPS_CM */

static inline void mips_cm_lock_other(unsigned int core, unsigned int vp) { }
static inline void mips_cm_unlock_other(void) { }

#endif /* !CONFIG_MIPS_CM */

#endif /* __MIPS_ASM_MIPS_CM_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 1998, 2001, 03 by Ralf Baechle
 *
 * RTC routines for PC style attached Dallas chip.
 */
#ifndef __ASM_MACH_GENERIC_MC146818RTC_H
#define __ASM_MACH_GENERIC_MC146818RTC_H

#include <asm/io.h>

#define RTC_PORT(x)	(0x70 + (x))
#define RTC_IRQ		8

static inline unsigned char CMOS_READ(unsigned long addr)
{
	outb_p(addr, RTC_PORT(0));
	return inb_p(RTC_PORT(1));
}

static inline void CMOS_WRITE(unsigned char data, unsigned long addr)
{
	outb_p(addr, RTC_PORT(0));
	outb_p(data, RTC_PORT(1));
}

#define RTC_ALWAYS_BCD	1

#ifndef mc146818_decode_year
#define mc146818_decode_year(year) ((year) < 70 ? (year) + 2000 : (year) + 1900)
#endif

#endif /* __ASM_MACH_GENERIC_MC146818RTC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2003 by Ralf Baechle
 */
#ifndef __ASM_MACH_GENERIC_IRQ_H
#define __ASM_MACH_GENERIC_IRQ_H

#ifndef NR_IRQS
#define NR_IRQS 128
#endif

#ifdef CONFIG_I8259
#ifndef I8259A_IRQ_BASE
#define I8259A_IRQ_BASE 0
#endif
#endif

#ifdef CONFIG_IRQ_MIPS_CPU

#ifndef MIPS_CPU_IRQ_BASE
#ifdef CONFIG_I8259
#define MIPS_CPU_IRQ_BASE 16
#else
#define MIPS_CPU_IRQ_BASE 0
#endif /* CONFIG_I8259 */
#endif

#ifdef CONFIG_IRQ_CPU_RM7K
#ifndef RM7K_CPU_IRQ_BASE
#define RM7K_CPU_IRQ_BASE (MIPS_CPU_IRQ_BASE+8)
#endif
#endif

#endif /* CONFIG_IRQ_MIPS_CPU */

#ifdef CONFIG_MIPS_GIC
#ifndef MIPS_GIC_IRQ_BASE
#define MIPS_GIC_IRQ_BASE (MIPS_CPU_IRQ_BASE + 8)
#endif
#endif /* CONFIG_MIPS_GIC */

#endif /* __ASM_MACH_GENERIC_IRQ_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2005 Embedded Alley Solutions, Inc
 * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
 */
#ifndef __ASM_MACH_GENERIC_KERNEL_ENTRY_H
#define __ASM_MACH_GENERIC_KERNEL_ENTRY_H

/* Intentionally empty macro, used in head.S. Override in
 * arch/mips/mach-xxx/kernel-entry-init.h when necessary.
 */
	.macro	kernel_entry_setup
	.endm

/*
 * Do SMP slave processor setup necessary before we can safely execute C code.
 */
	.macro	smp_slave_setup
	.endm


#endif /* __ASM_MACH_GENERIC_KERNEL_ENTRY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #include <asm-generic/topology.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2006  Ralf Baechle <ralf@linux-mips.org>
 *
 */
#ifndef __ASM_MACH_GENERIC_DMA_COHERENCE_H
#define __ASM_MACH_GENERIC_DMA_COHERENCE_H

struct device;

static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
	size_t size)
{
	return virt_to_phys(addr);
}

static inline dma_addr_t plat_map_dma_mem_page(struct device *dev,
	struct page *page)
{
	return page_to_phys(page);
}

static inline unsigned long plat_dma_addr_to_phys(struct device *dev,
	dma_addr_t dma_addr)
{
	return dma_addr;
}

static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr,
	size_t size, enum dma_data_direction direction)
{
}

static inline int plat_dma_supported(struct device *dev, u64 mask)
{
	/*
	 * we fall back to GFP_DMA when the mask isn't all 1s,
	 * so we can't guarantee allocations that must be
	 * within a tighter range than GFP_DMA..
	 */
	if (mask < DMA_BIT_MASK(24))
		return 0;

	return 1;
}

static inline int plat_device_is_coherent(struct device *dev)
{
#ifdef CONFIG_DMA_PERDEV_COHERENT
	return dev->archdata.dma_coherent;
#else
	switch (coherentio) {
	default:
	case IO_COHERENCE_DEFAULT:
		return hw_coherentio;
	case IO_COHERENCE_ENABLED:
		return 1;
	case IO_COHERENCE_DISABLED:
		return 0;
	}
#endif
}

#ifndef plat_post_dma_flush
static inline void plat_post_dma_flush(struct device *dev)
{
}
#endif

#ifdef CONFIG_SWIOTLB
static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
{
	return paddr;
}

static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
{
	return daddr;
}
#endif

#endif /* __ASM_MACH_GENERIC_DMA_COHERENCE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
 */
#ifndef __ASM_MACH_GENERIC_WAR_H
#define __ASM_MACH_GENERIC_WAR_H

#define R4600_V1_INDEX_ICACHEOP_WAR	0
#define R4600_V1_HIT_CACHEOP_WAR	0
#define R4600_V2_HIT_CACHEOP_WAR	0
#define R5432_CP0_INTERRUPT_WAR		0
#define BCM1250_M3_WAR			0
#define SIBYTE_1956_WAR			0
#define MIPS4K_ICACHE_REFILL_WAR	0
#define MIPS_CACHE_SYNC_WAR		0
#define TX49XX_ICACHE_INDEX_INV_WAR	0
#define ICACHE_REFILLS_WORKAROUND_WAR	0
#define R10000_LLSC_WAR			0
#define MIPS34K_MISSED_ITLB_WAR		0

#endif /* __ASM_MACH_GENERIC_WAR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef __ASM_MACH_GENERIC_KMALLOC_H
#define __ASM_MACH_GENERIC_KMALLOC_H


#ifndef CONFIG_DMA_COHERENT
/*
 * Total overkill for most systems but need as a safe default.
 * Set this one if any device in the system might do non-coherent DMA.
 */
#define ARCH_DMA_MINALIGN	128
#endif

#endif /* __ASM_MACH_GENERIC_KMALLOC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2003, 2004 Ralf Baechle
 */
#ifndef __ASM_MACH_GENERIC_MANGLE_PORT_H
#define __ASM_MACH_GENERIC_MANGLE_PORT_H

#define __swizzle_addr_b(port)	(port)
#define __swizzle_addr_w(port)	(port)
#define __swizzle_addr_l(port)	(port)
#define __swizzle_addr_q(port)	(port)

/*
 * Sane hardware offers swapping of PCI/ISA I/O space accesses in hardware;
 * less sane hardware forces software to fiddle with this...
 *
 * Regardless, if the host bus endianness mismatches that of PCI/ISA, then
 * you can't have the numerical value of data and byte addresses within
 * multibyte quantities both preserved at the same time.  Hence two
 * variations of functions: non-prefixed ones that preserve the value
 * and prefixed ones that preserve byte addresses.  The latters are
 * typically used for moving raw data between a peripheral and memory (cf.
 * string I/O functions), hence the "__mem_" prefix.
 */
#if defined(CONFIG_SWAP_IO_SPACE)

# define ioswabb(a, x)		(x)
# define __mem_ioswabb(a, x)	(x)
# define ioswabw(a, x)		le16_to_cpu(x)
# define __mem_ioswabw(a, x)	(x)
# define ioswabl(a, x)		le32_to_cpu(x)
# define __mem_ioswabl(a, x)	(x)
# define ioswabq(a, x)		le64_to_cpu(x)
# define __mem_ioswabq(a, x)	(x)

#else

# define ioswabb(a, x)		(x)
# define __mem_ioswabb(a, x)	(x)
# define ioswabw(a, x)		(x)
# define __mem_ioswabw(a, x)	cpu_to_le16(x)
# define ioswabl(a, x)		(x)
# define __mem_ioswabl(a, x)	cpu_to_le32(x)
# define ioswabq(a, x)		(x)
# define __mem_ioswabq(a, x)	cpu_to_le32(x)

#endif

#endif /* __ASM_MACH_GENERIC_MANGLE_PORT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *	include/asm-mips/mach-generic/ioremap.h
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License
 *	as published by the Free Software Foundation; either version
 *	2 of the License, or (at your option) any later version.
 */
#ifndef __ASM_MACH_GENERIC_IOREMAP_H
#define __ASM_MACH_GENERIC_IOREMAP_H

#include <linux/types.h>

/*
 * Allow physical addresses to be fixed up to help peripherals located
 * outside the low 32-bit range -- generic pass-through version.
 */
static inline phys_addr_t fixup_bigphys_addr(phys_addr_t phys_addr, phys_addr_t size)
{
	return phys_addr;
}

static inline void __iomem *plat_ioremap(phys_addr_t offset, unsigned long size,
	unsigned long flags)
{
	return NULL;
}

static inline int plat_iounmap(const volatile void __iomem *addr)
{
	return 0;
}

#endif /* __ASM_MACH_GENERIC_IOREMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 1994-1996  Linus Torvalds & authors
 *
 * Copied from i386; many of the especially older MIPS or ISA-based platforms
 * are basically identical.  Using this file probably implies i8259 PIC
 * support in a system but the very least interrupt numbers 0 - 15 need to
 * be put aside for legacy devices.
 */
#ifndef __ASM_MACH_GENERIC_IDE_H
#define __ASM_MACH_GENERIC_IDE_H

#ifdef __KERNEL__

#include <linux/pci.h>
#include <linux/stddef.h>
#include <asm/processor.h>

/* MIPS port and memory-mapped I/O string operations.  */
static inline void __ide_flush_prologue(void)
{
#ifdef CONFIG_SMP
	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)
		preempt_disable();
#endif
}

static inline void __ide_flush_epilogue(void)
{
#ifdef CONFIG_SMP
	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)
		preempt_enable();
#endif
}

static inline void __ide_flush_dcache_range(unsigned long addr, unsigned long size)
{
	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc) {
		unsigned long end = addr + size;

		while (addr < end) {
			local_flush_data_cache_page((void *)addr);
			addr += PAGE_SIZE;
		}
	}
}

/*
 * insw() and gang might be called with interrupts disabled, so we can't
 * send IPIs for flushing due to the potencial of deadlocks, see the comment
 * above smp_call_function() in arch/mips/kernel/smp.c.	 We work around the
 * problem by disabling preemption so we know we actually perform the flush
 * on the processor that actually has the lines to be flushed which hopefully
 * is even better for performance anyway.
 */
static inline void __ide_insw(unsigned long port, void *addr,
	unsigned int count)
{
	__ide_flush_prologue();
	insw(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 2);
	__ide_flush_epilogue();
}

static inline void __ide_insl(unsigned long port, void *addr, unsigned int count)
{
	__ide_flush_prologue();
	insl(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 4);
	__ide_flush_epilogue();
}

static inline void __ide_outsw(unsigned long port, const void *addr,
	unsigned long count)
{
	__ide_flush_prologue();
	outsw(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 2);
	__ide_flush_epilogue();
}

static inline void __ide_outsl(unsigned long port, const void *addr,
	unsigned long count)
{
	__ide_flush_prologue();
	outsl(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 4);
	__ide_flush_epilogue();
}

static inline void __ide_mm_insw(void __iomem *port, void *addr, u32 count)
{
	__ide_flush_prologue();
	readsw(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 2);
	__ide_flush_epilogue();
}

static inline void __ide_mm_insl(void __iomem *port, void *addr, u32 count)
{
	__ide_flush_prologue();
	readsl(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 4);
	__ide_flush_epilogue();
}

static inline void __ide_mm_outsw(void __iomem *port, void *addr, u32 count)
{
	__ide_flush_prologue();
	writesw(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 2);
	__ide_flush_epilogue();
}

static inline void __ide_mm_outsl(void __iomem * port, void *addr, u32 count)
{
	__ide_flush_prologue();
	writesl(port, addr, count);
	__ide_flush_dcache_range((unsigned long)addr, count * 4);
	__ide_flush_epilogue();
}

/* ide_insw calls insw, not __ide_insw.	 Why? */
#undef insw
#undef insl
#undef outsw
#undef outsl
#define insw(port, addr, count) __ide_insw(port, addr, count)
#define insl(port, addr, count) __ide_insl(port, addr, count)
#define outsw(port, addr, count) __ide_outsw(port, addr, count)
#define outsl(port, addr, count) __ide_outsl(port, addr, count)

#endif /* __KERNEL__ */

#endif /* __ASM_MACH_GENERIC_IDE_H */
                                                                                                                                                                              /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 1996, 1997, 1998, 2003 by Ralf Baechle
 */
#ifndef __ASM_MACH_GENERIC_FLOPPY_H
#define __ASM_MACH_GENERIC_FLOPPY_H

#include <linux/delay.h>
#include <linux/ioport.h>
#include <linux/sched.h>
#include <linux/linkage.h>
#include <linux/types.h>
#include <linux/mm.h>

#include <asm/bootinfo.h>
#include <asm/cachectl.h>
#include <asm/dma.h>
#include <asm/floppy.h>
#include <asm/io.h>
#include <asm/irq.h>
#include <asm/pgtable.h>

/*
 * How to access the FDC's registers.
 */
static inline unsigned char fd_inb(unsigned int port)
{
	return inb_p(port);
}

static inline void fd_outb(unsigned char value, unsigned int port)
{
	outb_p(value, port);
}

/*
 * How to access the floppy DMA functions.
 */
static inline void fd_enable_dma(void)
{
	enable_dma(FLOPPY_DMA);
}

static inline void fd_disable_dma(void)
{
	disable_dma(FLOPPY_DMA);
}

static inline int fd_request_dma(void)
{
	return request_dma(FLOPPY_DMA, "floppy");
}

static inline void fd_free_dma(void)
{
	free_dma(FLOPPY_DMA);
}

static inline void fd_clear_dma_ff(void)
{
	clear_dma_ff(FLOPPY_DMA);
}

static inline void fd_set_dma_mode(char mode)
{
	set_dma_mode(FLOPPY_DMA, mode);
}

static inline void fd_set_dma_addr(char *addr)
{
	set_dma_addr(FLOPPY_DMA, (unsigned long) addr);
}

static inline void fd_set_dma_count(unsigned int count)
{
	set_dma_count(FLOPPY_DMA, count);
}

static inline int fd_get_dma_residue(void)
{
	return get_dma_residue(FLOPPY_DMA);
}

static inline void fd_enable_irq(void)
{
	enable_irq(FLOPPY_IRQ);
}

static inline void fd_disable_irq(void)
{
	disable_irq(FLOPPY_IRQ);
}

static inline int fd_request_irq(void)
{
	return request_irq(FLOPPY_IRQ, floppy_interrupt,
			   0, "floppy", NULL);
}

static inline void fd_free_irq(void)
{
	free_irq(FLOPPY_IRQ, NULL);
}

#define fd_free_irq()		free_irq(FLOPPY_IRQ, NULL);


static inline unsigned long fd_getfdaddr1(void)
{
	return 0x3f0;
}

static inline unsigned long fd_dma_mem_alloc(unsigned long size)
{
	return __get_dma_pages(GFP_KERNEL, get_order(size));
}

static inline void fd_dma_mem_free(unsigned long addr, unsigned long size)
{
	free_pages(addr, get_order(size));
}

static inline unsigned long fd_drive_type(unsigned long n)
{
	if (n == 0)
		return 4;	/* 3,5", 1.44mb */

	return 0;
}

#endif /* __ASM_MACH_GENERIC_FLOPPY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
 * Copyright (C) 2000, 2002  Maciej W. Rozycki
 * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
 */
#ifndef _ASM_MACH_GENERIC_SPACES_H
#define _ASM_MACH_GENERIC_SPACES_H

#include <linux/const.h>

#include <asm/mipsregs.h>

/*
 * This gives the physical RAM offset.
 */
#ifndef PHYS_OFFSET
#define PHYS_OFFSET		_AC(0, UL)
#endif

#ifdef CONFIG_32BIT
#ifdef CONFIG_KVM_GUEST
#define CAC_BASE		_AC(0x40000000, UL)
#else
#define CAC_BASE		_AC(0x80000000, UL)
#endif
#ifndef IO_BASE
#define IO_BASE			_AC(0xa0000000, UL)
#endif
#ifndef UNCAC_BASE
#define UNCAC_BASE		_AC(0xa0000000, UL)
#endif

#ifndef MAP_BASE
#ifdef CONFIG_KVM_GUEST
#define MAP_BASE		_AC(0x60000000, UL)
#else
#define MAP_BASE		_AC(0xc0000000, UL)
#endif
#endif

/*
 * Memory above this physical address will be considered highmem.
 */
#ifndef HIGHMEM_START
#define HIGHMEM_START		_AC(0x20000000, UL)
#endif

#endif /* CONFIG_32BIT */

#ifdef CONFIG_64BIT

#ifndef CAC_BASE
#define CAC_BASE	PHYS_TO_XKPHYS(read_c0_config() & CONF_CM_CMASK, 0)
#endif

#ifndef IO_BASE
#define IO_BASE			_AC(0x9000000000000000, UL)
#endif

#ifndef UNCAC_BASE
#define UNCAC_BASE		_AC(0x9000000000000000, UL)
#endif

#ifndef MAP_BASE
#define MAP_BASE		_AC(0xc000000000000000, UL)
#endif

/*
 * Memory above this physical address will be considered highmem.
 * Fixme: 59 bits is a fictive number and makes assumptions about processors
 * in the distant future.  Nobody will care for a few years :-)
 */
#ifndef HIGHMEM_START
#define HIGHMEM_START		(_AC(1, UL) << _AC(59, UL))
#endif

#define TO_PHYS(x)		(	      ((x) & TO_PHYS_MASK))
#define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
#define TO_UNCAC(x)		(UNCAC_BASE | ((x) & TO_PHYS_MASK))

#endif /* CONFIG_64BIT */

/*
 * This handles the memory map.
 */
#ifndef PAGE_OFFSET
#define PAGE_OFFSET		(CAC_BASE + PHYS_OFFSET)
#endif

#ifndef FIXADDR_TOP
#ifdef CONFIG_KVM_GUEST
#define FIXADDR_TOP		((unsigned long)(long)(int)0x7ffe0000)
#else
#define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
#endif
#endif

#endif /* __ASM_MACH_GENERIC_SPACES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2003 Ralf Baechle
 */
#ifndef __ASM_MACH_GENERIC_CPU_FEATURE_OVERRIDES_H
#define __ASM_MACH_GENERIC_CPU_FEATURE_OVERRIDES_H

/* Intentionally empty file ...	 */

#endif /* __ASM_MACH_GENERIC_CPU_FEATURE_OVERRIDES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2014, Imagination Technologies Ltd.
 *
 * EVA functions for generic code
 */

#ifndef _ASM_EVA_H
#define _ASM_EVA_H

#include <kernel-entry-init.h>

#ifdef __ASSEMBLY__

#ifdef CONFIG_EVA

/*
 * EVA early init code
 *
 * Platforms must define their own 'platform_eva_init' macro in
 * their kernel-entry-init.h header. This macro usually does the
 * platform specific configuration of the segmentation registers,
 * and it is normally called from assembly code.
 *
 */

.macro eva_init
platform_eva_init
.endm

#else

.macro eva_init
.endm

#endif /* CONFIG_EVA */

#endif /* __ASSEMBLY__ */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 */
#ifndef __ASM_UPROBES_H
#define __ASM_UPROBES_H

#include <linux/notifier.h>
#include <linux/types.h>

#include <asm/break.h>
#include <asm/inst.h>

/*
 * We want this to be defined as union mips_instruction but that makes the
 * generic code blow up.
 */
typedef u32 uprobe_opcode_t;

/*
 * Classic MIPS (note this implementation doesn't consider microMIPS yet)
 * instructions are always 4 bytes but in order to deal with branches and
 * their delay slots, we treat instructions as having 8 bytes maximum.
 */
#define MAX_UINSN_BYTES			8
#define UPROBE_XOL_SLOT_BYTES		128	/* Max. cache line size */

#define UPROBE_BRK_UPROBE		0x000d000d	/* break 13 */
#define UPROBE_BRK_UPROBE_XOL		0x000e000d	/* break 14 */

#define UPROBE_SWBP_INSN		UPROBE_BRK_UPROBE
#define UPROBE_SWBP_INSN_SIZE		4

struct arch_uprobe {
	unsigned long	resume_epc;
	u32	insn[2];
	u32	ixol[2];
};

struct arch_uprobe_task {
	unsigned long saved_trap_nr;
};

#endif /* __ASM_UPROBES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *  DS1287 timer functions.
 *
 *  Copyright (C) 2008  Yoichi Yuasa <yuasa@linux-mips.org>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
#ifndef __ASM_DS1287_H
#define __ASM_DS1287_H

extern int ds1287_timer_state(void);
extern void ds1287_set_base_clock(unsigned int clock);
extern int ds1287_clockevent_init(int irq);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Architecture specific parts of the Floppy driver
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 1995 - 2000 Ralf Baechle
 */
#ifndef _ASM_FLOPPY_H
#define _ASM_FLOPPY_H

#include <linux/dma-mapping.h>

static inline void fd_cacheflush(char * addr, long size)
{
	dma_cache_sync(NULL, addr, size, DMA_BIDIRECTIONAL);
}

#define MAX_BUFFER_SECTORS 24


/*
 * And on Mips's the CMOS info fails also ...
 *
 * FIXME: This information should come from the ARC configuration tree
 *	  or wherever a particular machine has stored this ...
 */
#define FLOPPY0_TYPE		fd_drive_type(0)
#define FLOPPY1_TYPE		fd_drive_type(1)

#define FDC1			fd_getfdaddr1()

#define N_FDC 1			/* do you *really* want a second controller? */
#define N_DRIVE 8

/*
 * The DMA channel used by the floppy controller cannot access data at
 * addresses >= 16MB
 *
 * Went back to the 1MB limit, as some people had problems with the floppy
 * driver otherwise. It doesn't matter much for performance anyway, as most
 * floppy accesses go through the track buffer.
 *
 * On MIPSes using vdma, this actually means that *all* transfers go thru
 * the * track buffer since 0x1000000 is always smaller than KSEG0/1.
 * Actually this needs to be a bit more complicated since the so much different
 * hardware available with MIPS CPUs ...
 */
#define CROSS_64KB(a, s) ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)

#define EXTRA_FLOPPY_PARAMS

#include <floppy.h>

#endif /* _ASM_FLOPPY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2003 by Ralf Baechle
 */
#ifndef __ASM_MACH_EMMA2RH_IRQ_H
#define __ASM_MACH_EMMA2RH_IRQ_H

#define NR_IRQS 256

#include_next <irq.h>

#endif /* __ASM_MACH_EMMA2RH_IRQ_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __ASM_MACH_VR41XX_IRQ_H
#define __ASM_MACH_VR41XX_IRQ_H

#include <asm/vr41xx/irq.h> /* for MIPS_CPU_IRQ_BASE */

#include_next <irq.h>

#endif /* __ASM_MACH_VR41XX_IRQ_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * linux/arch/mips/include/asm/perf_event.h
 *
 * Copyright (C) 2010 MIPS Technologies, Inc.
 * Author: Deng-Cheng Zhu
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __MIPS_PERF_EVENT_H__
#define __MIPS_PERF_EVENT_H__
/* Leave it empty here. The file is required by linux/perf_event.h */
#endif /* __MIPS_PERF_EVENT_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _MIPS_SETUP_H
#define _MIPS_SETUP_H

#include <uapi/asm/setup.h>

extern void setup_early_printk(void);

#ifdef CONFIG_EARLY_PRINTK_8250
extern void setup_8250_early_printk_port(unsigned long base,
	unsigned int reg_shift, unsigned int timeout);
#else
static inline void setup_8250_early_printk_port(unsigned long base,
	unsigned int reg_shift, unsigned int timeout) {}
#endif

extern void set_handler(unsigned long offset, void *addr, unsigned long len);
extern void set_uncached_handler(unsigned long offset, void *addr, unsigned long len);

typedef void (*vi_handler_t)(void);
extern void *set_vi_handler(int n, vi_handler_t addr);

extern void *set_except_vector(int n, void *addr);
extern unsigned long ebase;
extern unsigned int hwrena;
extern void per_cpu_trap_init(bool);
extern void cpu_cache_init(void);

#endif /* __SETUP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (c) 1997, 1999 by Ralf Baechle
 * Copyright (c) 1999 Silicon Graphics, Inc.
 */
#ifndef _ASM_BCACHE_H
#define _ASM_BCACHE_H

#include <linux/types.h>

/* Some R4000 / R4400 / R4600 / R5000 machines may have a non-dma-coherent,
   chipset implemented caches.	On machines with other CPUs the CPU does the
   cache thing itself. */
struct bcache_ops {
	void (*bc_enable)(void);
	void (*bc_disable)(void);
	void (*bc_wback_inv)(unsigned long page, unsigned long size);
	void (*bc_inv)(unsigned long page, unsigned long size);
	void (*bc_prefetch_enable)(void);
	void (*bc_prefetch_disable)(void);
	bool (*bc_prefetch_is_enabled)(void);
};

extern void indy_sc_init(void);

#ifdef CONFIG_BOARD_SCACHE

extern struct bcache_ops *bcops;

static inline void bc_enable(void)
{
	bcops->bc_enable();
}

static inline void bc_disable(void)
{
	bcops->bc_disable();
}

static inline void bc_wback_inv(unsigned long page, unsigned long size)
{
	bcops->bc_wback_inv(page, size);
}

static inline void bc_inv(unsigned long page, unsigned long size)
{
	bcops->bc_inv(page, size);
}

static inline void bc_prefetch_enable(void)
{
	if (bcops->bc_prefetch_enable)
		bcops->bc_prefetch_enable();
}

static inline void bc_prefetch_disable(void)
{
	if (bcops->bc_prefetch_disable)
		bcops->bc_prefetch_disable();
}

static inline bool bc_prefetch_is_enabled(void)
{
	if (bcops->bc_prefetch_is_enabled)
		return bcops->bc_prefetch_is_enabled();

	return false;
}

#else /* !defined(CONFIG_BOARD_SCACHE) */

/* Not R4000 / R4400 / R4600 / R5000.  */

#define bc_enable() do { } while (0)
#define bc_disable() do { } while (0)
#define bc_wback_inv(page, size) do { } while (0)
#define bc_inv(page, size) do { } while (0)
#define bc_prefetch_enable() do { } while (0)
#define bc_prefetch_disable() do { } while (0)
#define bc_prefetch_is_enabled() 0

#endif /* !defined(CONFIG_BOARD_SCACHE) */

#endif /* _ASM_BCACHE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
 */
#ifndef __ASM_MIPS_MACH_IP22_WAR_H
#define __ASM_MIPS_MACH_IP22_WAR_H

/*
 * R4600 CPU modules for the Indy come with both V1.7 and V2.0 processors.
 */

#define R4600_V1_INDEX_ICACHEOP_WAR	1
#define R4600_V1_HIT_CACHEOP_WAR	1
#define R4600_V2_HIT_CACHEOP_WAR	1
#define R5432_CP0_INTERRUPT_WAR		0
#define BCM1250_M3_WAR			0
#define SIBYTE_1956_WAR			0
#define MIPS4K_ICACHE_REFILL_WAR	0
#define MIPS_CACHE_SYNC_WAR		0
#define TX49XX_ICACHE_INDEX_INV_WAR	0
#define ICACHE_REFILLS_WORKAROUND_WAR	0
#define R10000_LLSC_WAR			0
#define MIPS34K_MISSED_ITLB_WAR		0

#endif /* __ASM_MIPS_MACH_IP22_WAR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
 * Copyright (C) 2000, 2002  Maciej W. Rozycki
 * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
 */
#ifndef _ASM_MACH_IP22_SPACES_H
#define _ASM_MACH_IP22_SPACES_H


#ifdef CONFIG_64BIT

#define PAGE_OFFSET		0xffffffff80000000UL

#define CAC_BASE		0xffffffff80000000
#define IO_BASE			0xffffffffa0000000
#define UNCAC_BASE		0xffffffffa0000000
#define MAP_BASE		0xc000000000000000

#endif /* CONFIG_64BIT */

#include <asm/mach-generic/spaces.h>

#endif /* __ASM_MACH_IP22_SPACES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         95b44915e267400669b2724e0cce5967  /etc/samba/smb.conf
6e4c2dde6c6970f124de9493e2c286fa  /etc/idmapd.conf
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * device.h - generic, centralized driver model
 *
 * Copyright (c) 2001-2003 Patrick Mochel <mochel@osdl.org>
 * Copyright (c) 2004-2009 Greg Kroah-Hartman <gregkh@suse.de>
 * Copyright (c) 2008-2009 Novell Inc.
 *
 * This file is released under the GPLv2
 *
 * See Documentation/driver-model/ for more information.
 */

#ifndef _DEVICE_H_
#define _DEVICE_H_

#include <linux/ioport.h>
#include <linux/kobject.h>
#include <linux/klist.h>
#include <linux/list.h>
#include <linux/lockdep.h>
#include <linux/compiler.h>
#include <linux/types.h>
#include <linux/mutex.h>
#include <linux/pinctrl/devinfo.h>
#include <linux/pm.h>
#include <linux/atomic.h>
#include <linux/ratelimit.h>
#include <linux/uidgid.h>
#include <linux/gfp.h>
#include <asm/device.h>

struct device;
struct device_private;
struct device_driver;
struct driver_private;
struct module;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct iommu_fwspec;

struct bus_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct bus_type *bus, char *buf);
	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};

#define BUS_ATTR(_name, _mode, _show, _store)	\
	struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)
#define BUS_ATTR_RW(_name) \
	struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)
#define BUS_ATTR_RO(_name) \
	struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)

extern int __must_check bus_create_file(struct bus_type *,
					struct bus_attribute *);
extern void bus_remove_file(struct bus_type *, struct bus_attribute *);

/**
 * struct bus_type - The bus type of the device
 *
 * @name:	The name of the bus.
 * @dev_name:	Used for subsystems to enumerate devices like ("foo%u", dev->id).
 * @dev_root:	Default device to use as the parent.
 * @dev_attrs:	Default attributes of the devices on the bus.
 * @bus_groups:	Default attributes of the bus.
 * @dev_groups:	Default attributes of the devices on the bus.
 * @drv_groups: Default attributes of the device drivers on the bus.
 * @match:	Called, perhaps multiple times, whenever a new device or driver
 *		is added for this bus. It should return a positive value if the
 *		given device can be handled by the given driver and zero
 *		otherwise. It may also return error code if determining that
 *		the driver supports the device is not possible. In case of
 *		-EPROBE_DEFER it will queue the device for deferred probing.
 * @uevent:	Called when a device is added, removed, or a few other things
 *		that generate uevents to add the environment variables.
 * @probe:	Called when a new device or driver add to this bus, and callback
 *		the specific driver's probe to initial the matched device.
 * @remove:	Called when a device removed from this bus.
 * @shutdown:	Called at shut-down time to quiesce the device.
 *
 * @online:	Called to put the device back online (after offlining it).
 * @offline:	Called to put the device offline for hot-removal. May fail.
 *
 * @suspend:	Called when a device on this bus wants to go to sleep mode.
 * @resume:	Called to bring a device on this bus out of sleep mode.
 * @pm:		Power management operations of this bus, callback the specific
 *		device driver's pm-ops.
 * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU
 *              driver implementations to a bus and allow the driver to do
 *              bus-specific setup
 * @p:		The private data of the driver core, only the driver core can
 *		touch this.
 * @lock_key:	Lock class key for use by the lock validator
 *
 * A bus is a channel between the processor and one or more devices. For the
 * purposes of the device model, all devices are connected via a bus, even if
 * it is an internal, virtual, "platform" bus. Buses can plug into each other.
 * A USB controller is usually a PCI device, for example. The device model
 * represents the actual connections between buses and the devices they control.
 * A bus is represented by the bus_type structure. It contains the name, the
 * default attributes, the bus' methods, PM operations, and the driver core's
 * private data.
 */
struct bus_type {
	const char		*name;
	const char		*dev_name;
	struct device		*dev_root;
	struct device_attribute	*dev_attrs;	/* use dev_groups instead */
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;

	int (*match)(struct device *dev, struct device_driver *drv);
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
	int (*probe)(struct device *dev);
	int (*remove)(struct device *dev);
	void (*shutdown)(struct device *dev);

	int (*online)(struct device *dev);
	int (*offline)(struct device *dev);

	int (*suspend)(struct device *dev, pm_message_t state);
	int (*resume)(struct device *dev);

	const struct dev_pm_ops *pm;

	const struct iommu_ops *iommu_ops;

	struct subsys_private *p;
	struct lock_class_key lock_key;
};

extern int __must_check bus_register(struct bus_type *bus);

extern void bus_unregister(struct bus_type *bus);

extern int __must_check bus_rescan_devices(struct bus_type *bus);

/* iterator helpers for buses */
struct subsys_dev_iter {
	struct klist_iter		ki;
	const struct device_type	*type;
};
void subsys_dev_iter_init(struct subsys_dev_iter *iter,
			 struct bus_type *subsys,
			 struct device *start,
			 const struct device_type *type);
struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);
void subsys_dev_iter_exit(struct subsys_dev_iter *iter);

int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
		     int (*fn)(struct device *dev, void *data));
struct device *bus_find_device(struct bus_type *bus, struct device *start,
			       void *data,
			       int (*match)(struct device *dev, void *data));
struct device *bus_find_device_by_name(struct bus_type *bus,
				       struct device *start,
				       const char *name);
struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
					struct device *hint);
int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
		     void *data, int (*fn)(struct device_driver *, void *));
void bus_sort_breadthfirst(struct bus_type *bus,
			   int (*compare)(const struct device *a,
					  const struct device *b));
/*
 * Bus notifiers: Get notified of addition/removal of devices
 * and binding/unbinding of drivers to devices.
 * In the long run, it should be a replacement for the platform
 * notify hooks.
 */
struct notifier_block;

extern int bus_register_notifier(struct bus_type *bus,
				 struct notifier_block *nb);
extern int bus_unregister_notifier(struct bus_type *bus,
				   struct notifier_block *nb);

/* All 4 notifers below get called with the target struct device *
 * as an argument. Note that those functions are likely to be called
 * with the device lock held in the core, so be careful.
 */
#define BUS_NOTIFY_ADD_DEVICE		0x00000001 /* device added */
#define BUS_NOTIFY_DEL_DEVICE		0x00000002 /* device to be removed */
#define BUS_NOTIFY_REMOVED_DEVICE	0x00000003 /* device removed */
#define BUS_NOTIFY_BIND_DRIVER		0x00000004 /* driver about to be
						      bound */
#define BUS_NOTIFY_BOUND_DRIVER		0x00000005 /* driver bound to device */
#define BUS_NOTIFY_UNBIND_DRIVER	0x00000006 /* driver about to be
						      unbound */
#define BUS_NOTIFY_UNBOUND_DRIVER	0x00000007 /* driver is unbound
						      from the device */
#define BUS_NOTIFY_DRIVER_NOT_BOUND	0x00000008 /* driver fails to be bound */

extern struct kset *bus_get_kset(struct bus_type *bus);
extern struct klist *bus_get_device_klist(struct bus_type *bus);

/**
 * enum probe_type - device driver probe type to try
 *	Device drivers may opt in for special handling of their
 *	respective probe routines. This tells the core what to
 *	expect and prefer.
 *
 * @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well
 *	whether probed synchronously or asynchronously.
 * @PROBE_PREFER_ASYNCHRONOUS: Drivers for "slow" devices which
 *	probing order is not essential for booting the system may
 *	opt into executing their probes asynchronously.
 * @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need
 *	their probe routines to run synchronously with driver and
 *	device registration (with the exception of -EPROBE_DEFER
 *	handling - re-probing always ends up being done asynchronously).
 *
 * Note that the end goal is to switch the kernel to use asynchronous
 * probing by default, so annotating drivers with
 * %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us
 * to speed up boot process while we are validating the rest of the
 * drivers.
 */
enum probe_type {
	PROBE_DEFAULT_STRATEGY,
	PROBE_PREFER_ASYNCHRONOUS,
	PROBE_FORCE_SYNCHRONOUS,
};

/**
 * struct device_driver - The basic device driver structure
 * @name:	Name of the device driver.
 * @bus:	The bus which the device of this driver belongs to.
 * @owner:	The module owner.
 * @mod_name:	Used for built-in modules.
 * @suppress_bind_attrs: Disables bind/unbind via sysfs.
 * @probe_type:	Type of the probe (synchronous or asynchronous) to use.
 * @of_match_table: The open firmware table.
 * @acpi_match_table: The ACPI match table.
 * @probe:	Called to query the existence of a specific device,
 *		whether this driver can work with it, and bind the driver
 *		to a specific device.
 * @remove:	Called when the device is removed from the system to
 *		unbind a device from this driver.
 * @shutdown:	Called at shut-down time to quiesce the device.
 * @suspend:	Called to put the device to sleep mode. Usually to a
 *		low power state.
 * @resume:	Called to bring a device from sleep mode.
 * @groups:	Default attributes that get created by the driver core
 *		automatically.
 * @pm:		Power management operations of the device which matched
 *		this driver.
 * @p:		Driver core's private data, no one other than the driver
 *		core can touch this.
 *
 * The device driver-model tracks all of the drivers known to the system.
 * The main reason for this tracking is to enable the driver core to match
 * up drivers with new devices. Once drivers are known objects within the
 * system, however, a number of other things become possible. Device drivers
 * can export information and configuration variables that are independent
 * of any specific device.
 */
struct device_driver {
	const char		*name;
	struct bus_type		*bus;

	struct module		*owner;
	const char		*mod_name;	/* used for built-in modules */

	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */
	enum probe_type probe_type;

	const struct of_device_id	*of_match_table;
	const struct acpi_device_id	*acpi_match_table;

	int (*probe) (struct device *dev);
	int (*remove) (struct device *dev);
	void (*shutdown) (struct device *dev);
	int (*suspend) (struct device *dev, pm_message_t state);
	int (*resume) (struct device *dev);
	const struct attribute_group **groups;

	const struct dev_pm_ops *pm;

	struct driver_private *p;
};


extern int __must_check driver_register(struct device_driver *drv);
extern void driver_unregister(struct device_driver *drv);

extern struct device_driver *driver_find(const char *name,
					 struct bus_type *bus);
extern int driver_probe_done(void);
extern void wait_for_device_probe(void);


/* sysfs interface for exporting driver attributes */

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *driver, char *buf);
	ssize_t (*store)(struct device_driver *driver, const char *buf,
			 size_t count);
};

#define DRIVER_ATTR(_name, _mode, _show, _store) \
	struct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store)
#define DRIVER_ATTR_RW(_name) \
	struct driver_attribute driver_attr_##_name = __ATTR_RW(_name)
#define DRIVER_ATTR_RO(_name) \
	struct driver_attribute driver_attr_##_name = __ATTR_RO(_name)
#define DRIVER_ATTR_WO(_name) \
	struct driver_attribute driver_attr_##_name = __ATTR_WO(_name)

extern int __must_check driver_create_file(struct device_driver *driver,
					const struct driver_attribute *attr);
extern void driver_remove_file(struct device_driver *driver,
			       const struct driver_attribute *attr);

extern int __must_check driver_for_each_device(struct device_driver *drv,
					       struct device *start,
					       void *data,
					       int (*fn)(struct device *dev,
							 void *));
struct device *driver_find_device(struct device_driver *drv,
				  struct device *start, void *data,
				  int (*match)(struct device *dev, void *data));

/**
 * struct subsys_interface - interfaces to device functions
 * @name:       name of the device function
 * @subsys:     subsytem of the devices to attach to
 * @node:       the list of functions registered at the subsystem
 * @add_dev:    device hookup to device function handler
 * @remove_dev: device hookup to device function handler
 *
 * Simple interfaces attached to a subsystem. Multiple interfaces can
 * attach to a subsystem and its devices. Unlike drivers, they do not
 * exclusively claim or control devices. Interfaces usually represent
 * a specific functionality of a subsystem/class of devices.
 */
struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *dev, struct subsys_interface *sif);
	void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};

int subsys_interface_register(struct subsys_interface *sif);
void subsys_interface_unregister(struct subsys_interface *sif);

int subsys_system_register(struct bus_type *subsys,
			   const struct attribute_group **groups);
int subsys_virtual_register(struct bus_type *subsys,
			    const struct attribute_group **groups);

/**
 * struct class - device classes
 * @name:	Name of the class.
 * @owner:	The module owner.
 * @class_attrs: Default attributes of this class.
 * @dev_groups:	Default attributes of the devices that belong to the class.
 * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.
 * @dev_uevent:	Called when a device is added, removed from this class, or a
 *		few other things that generate uevents to add the environment
 *		variables.
 * @devnode:	Callback to provide the devtmpfs.
 * @class_release: Called to release this class.
 * @dev_release: Called to release the device.
 * @suspend:	Used to put the device to sleep mode, usually to a low power
 *		state.
 * @resume:	Used to bring the device from the sleep mode.
 * @shutdown:	Called at shut-down time to quiesce the device.
 * @ns_type:	Callbacks so sysfs can detemine namespaces.
 * @namespace:	Namespace of the device belongs to this class.
 * @pm:		The default device power management operations of this class.
 * @p:		The private data of the driver core, no one other than the
 *		driver core can touch this.
 *
 * A class is a higher-level view of a device that abstracts out low-level
 * implementation details. Drivers may see a SCSI disk or an ATA disk, but,
 * at the class level, they are all simply disks. Classes allow user space
 * to work with devices based on what they do, rather than how they are
 * connected or how they work.
 */
struct class {
	const char		*name;
	struct module		*owner;

	struct class_attribute		*class_attrs;
	const struct attribute_group	**dev_groups;
	struct kobject			*dev_kobj;

	int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
	char *(*devnode)(struct device *dev, umode_t *mode);

	void (*class_release)(struct class *class);
	void (*dev_release)(struct device *dev);

	int (*suspend)(struct device *dev, pm_message_t state);
	int (*resume)(struct device *dev);
	int (*shutdown)(struct device *dev);

	const struct kobj_ns_type_operations *ns_type;
	const void *(*namespace)(struct device *dev);

	const struct dev_pm_ops *pm;

	struct subsys_private *p;
};

struct class_dev_iter {
	struct klist_iter		ki;
	const struct device_type	*type;
};

extern struct kobject *sysfs_dev_block_kobj;
extern struct kobject *sysfs_dev_char_kobj;
extern int __must_check __class_register(struct class *class,
					 struct lock_class_key *key);
extern void class_unregister(struct class *class);

/* This is a #define to keep the compiler from merging different
 * instances of the __key variable */
#define class_register(class)			\
({						\
	static struct lock_class_key __key;	\
	__class_register(class, &__key);	\
})

struct class_compat;
struct class_compat *class_compat_register(const char *name);
void class_compat_unregister(struct class_compat *cls);
int class_compat_create_link(struct class_compat *cls, struct device *dev,
			     struct device *device_link);
void class_compat_remove_link(struct class_compat *cls, struct device *dev,
			      struct device *device_link);

extern void class_dev_iter_init(struct class_dev_iter *iter,
				struct class *class,
				struct device *start,
				const struct device_type *type);
extern struct device *class_dev_iter_next(struct class_dev_iter *iter);
extern void class_dev_iter_exit(struct class_dev_iter *iter);

extern int class_for_each_device(struct class *class, struct device *start,
				 void *data,
				 int (*fn)(struct device *dev, void *data));
extern struct device *class_find_device(struct class *class,
					struct device *start, const void *data,
					int (*match)(struct device *, const void *));

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *class, struct class_attribute *attr,
			char *buf);
	ssize_t (*store)(struct class *class, struct class_attribute *attr,
			const char *buf, size_t count);
};

#define CLASS_ATTR(_name, _mode, _show, _store) \
	struct class_attribute class_attr_##_name = __ATTR(_name, _mode, _show, _store)
#define CLASS_ATTR_RW(_name) \
	struct class_attribute class_attr_##_name = __ATTR_RW(_name)
#define CLASS_ATTR_RO(_name) \
	struct class_attribute class_attr_##_name = __ATTR_RO(_name)

extern int __must_check class_create_file_ns(struct class *class,
					     const struct class_attribute *attr,
					     const void *ns);
extern void class_remove_file_ns(struct class *class,
				 const struct class_attribute *attr,
				 const void *ns);

static inline int __must_check class_create_file(struct class *class,
					const struct class_attribute *attr)
{
	return class_create_file_ns(class, attr, NULL);
}

static inline void class_remove_file(struct class *class,
				     const struct class_attribute *attr)
{
	return class_remove_file_ns(class, attr, NULL);
}

/* Simple class attribute that is just a static string */
struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

/* Currently read-only only */
#define _CLASS_ATTR_STRING(_name, _mode, _str) \
	{ __ATTR(_name, _mode, show_class_attr_string, NULL), _str }
#define CLASS_ATTR_STRING(_name, _mode, _str) \
	struct class_attribute_string class_attr_##_name = \
		_CLASS_ATTR_STRING(_name, _mode, _str)

extern ssize_t show_class_attr_string(struct class *class, struct class_attribute *attr,
                        char *buf);

struct class_interface {
	struct list_head	node;
	struct class		*class;

	int (*add_dev)		(struct device *, struct class_interface *);
	void (*remove_dev)	(struct device *, struct class_interface *);
};

extern int __must_check class_interface_register(struct class_interface *);
extern void class_interface_unregister(struct class_interface *);

extern struct class * __must_check __class_create(struct module *owner,
						  const char *name,
						  struct lock_class_key *key);
extern void class_destroy(struct class *cls);

/* This is a #define to keep the compiler from merging different
 * instances of the __key variable */
#define class_create(owner, name)		\
({						\
	static struct lock_class_key __key;	\
	__class_create(owner, name, &__key);	\
})

/*
 * The type of device, "struct device" is embedded in. A class
 * or bus can contain devices of different types
 * like "partitions" and "disks", "mouse" and "event".
 * This identifies the device type and carries type-specific
 * information, equivalent to the kobj_type of a kobject.
 * If "name" is specified, the uevent will contain it in
 * the DEVTYPE variable.
 */
struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
	char *(*devnode)(struct device *dev, umode_t *mode,
			 kuid_t *uid, kgid_t *gid);
	void (*release)(struct device *dev);

	const struct dev_pm_ops *pm;
};

/* interface for exporting device attributes */
struct device_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
			char *buf);
	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t count);
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

ssize_t device_show_ulong(struct device *dev, struct device_attribute *attr,
			  char *buf);
ssize_t device_store_ulong(struct device *dev, struct device_attribute *attr,
			   const char *buf, size_t count);
ssize_t device_show_int(struct device *dev, struct device_attribute *attr,
			char *buf);
ssize_t device_store_int(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t count);
ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
			char *buf);
ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t count);

#define DEVICE_ATTR(_name, _mode, _show, _store) \
	struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
#define DEVICE_ATTR_RW(_name) \
	struct device_attribute dev_attr_##_name = __ATTR_RW(_name)
#define DEVICE_ATTR_RO(_name) \
	struct device_attribute dev_attr_##_name = __ATTR_RO(_name)
#define DEVICE_ATTR_WO(_name) \
	struct device_attribute dev_attr_##_name = __ATTR_WO(_name)
#define DEVICE_ULONG_ATTR(_name, _mode, _var) \
	struct dev_ext_attribute dev_attr_##_name = \
		{ __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &(_var) }
#define DEVICE_INT_ATTR(_name, _mode, _var) \
	struct dev_ext_attribute dev_attr_##_name = \
		{ __ATTR(_name, _mode, device_show_int, device_store_int), &(_var) }
#define DEVICE_BOOL_ATTR(_name, _mode, _var) \
	struct dev_ext_attribute dev_attr_##_name = \
		{ __ATTR(_name, _mode, device_show_bool, device_store_bool), &(_var) }
#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \
	struct device_attribute dev_attr_##_name =		\
		__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)

extern int device_create_file(struct device *device,
			      const struct device_attribute *entry);
extern void device_remove_file(struct device *dev,
			       const struct device_attribute *attr);
extern bool device_remove_file_self(struct device *dev,
				    const struct device_attribute *attr);
extern int __must_check device_create_bin_file(struct device *dev,
					const struct bin_attribute *attr);
extern void device_remove_bin_file(struct device *dev,
				   const struct bin_attribute *attr);

/* device resource management */
typedef void (*dr_release_t)(struct device *dev, void *res);
typedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);

#ifdef CONFIG_DEBUG_DEVRES
extern void *__devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,
				 int nid, const char *name) __malloc;
#define devres_alloc(release, size, gfp) \
	__devres_alloc_node(release, size, gfp, NUMA_NO_NODE, #release)
#define devres_alloc_node(release, size, gfp, nid) \
	__devres_alloc_node(release, size, gfp, nid, #release)
#else
extern void *devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,
			       int nid) __malloc;
static inline void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp)
{
	return devres_alloc_node(release, size, gfp, NUMA_NO_NODE);
}
#endif

extern void devres_for_each_res(struct device *dev, dr_release_t release,
				dr_match_t match, void *match_data,
				void (*fn)(struct device *, void *, void *),
				void *data);
extern void devres_free(void *res);
extern void devres_add(struct device *dev, void *res);
extern void *devres_find(struct device *dev, dr_release_t release,
			 dr_match_t match, void *match_data);
extern void *devres_get(struct device *dev, void *new_res,
			dr_match_t match, void *match_data);
extern void *devres_remove(struct device *dev, dr_release_t release,
			   dr_match_t match, void *match_data);
extern int devres_destroy(struct device *dev, dr_release_t release,
			  dr_match_t match, void *match_data);
extern int devres_release(struct device *dev, dr_release_t release,
			  dr_match_t match, void *match_data);

/* devres group */
extern void * __must_check devres_open_group(struct device *dev, void *id,
					     gfp_t gfp);
extern void devres_close_group(struct device *dev, void *id);
extern void devres_remove_group(struct device *dev, void *id);
extern int devres_release_group(struct device *dev, void *id);

/* managed devm_k.alloc/kfree for device drivers */
extern void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp) __malloc;
extern __printf(3, 0)
char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,
		      va_list ap) __malloc;
extern __printf(3, 4)
char *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...) __malloc;
static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
{
	return devm_kmalloc(dev, size, gfp | __GFP_ZERO);
}
static inline void *devm_kmalloc_array(struct device *dev,
				       size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
		return NULL;
	return devm_kmalloc(dev, n * size, flags);
}
static inline void *devm_kcalloc(struct device *dev,
				 size_t n, size_t size, gfp_t flags)
{
	return devm_kmalloc_array(dev, n, size, flags | __GFP_ZERO);
}
extern void devm_kfree(struct device *dev, void *p);
extern char *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp) __malloc;
extern void *devm_kmemdup(struct device *dev, const void *src, size_t len,
			  gfp_t gfp);

extern unsigned long devm_get_free_pages(struct device *dev,
					 gfp_t gfp_mask, unsigned int order);
extern void devm_free_pages(struct device *dev, unsigned long addr);

void __iomem *devm_ioremap_resource(struct device *dev, struct resource *res);

/* allows to add/remove a custom action to devres stack */
int devm_add_action(struct device *dev, void (*action)(void *), void *data);
void devm_remove_action(struct device *dev, void (*action)(void *), void *data);

static inline int devm_add_action_or_reset(struct device *dev,
					   void (*action)(void *), void *data)
{
	int ret;

	ret = devm_add_action(dev, action, data);
	if (ret)
		action(data);

	return ret;
}

struct device_dma_parameters {
	/*
	 * a low level driver may set these to teach IOMMU code about
	 * sg limitations.
	 */
	unsigned int max_segment_size;
	unsigned long segment_boundary_mask;
};

/**
 * struct device - The basic device structure
 * @parent:	The device's "parent" device, the device to which it is attached.
 * 		In most cases, a parent device is some sort of bus or host
 * 		controller. If parent is NULL, the device, is a top-level device,
 * 		which is not usually what you want.
 * @p:		Holds the private data of the driver core portions of the device.
 * 		See the comment of the struct device_private for detail.
 * @kobj:	A top-level, abstract class from which other classes are derived.
 * @init_name:	Initial name of the device.
 * @type:	The type of device.
 * 		This identifies the device type and carries type-specific
 * 		information.
 * @mutex:	Mutex to synchronize calls to its driver.
 * @bus:	Type of bus device is on.
 * @driver:	Which driver has allocated this
 * @platform_data: Platform data specific to the device.
 * 		Example: For devices on custom boards, as typical of embedded
 * 		and SOC based hardware, Linux often uses platform_data to point
 * 		to board-specific structures describing devices and how they
 * 		are wired.  That can include what ports are available, chip
 * 		variants, which GPIO pins act in what additional roles, and so
 * 		on.  This shrinks the "Board Support Packages" (BSPs) and
 * 		minimizes board-specific #ifdefs in drivers.
 * @driver_data: Private pointer for driver specific info.
 * @power:	For device power management.
 * 		See Documentation/power/devices.txt for details.
 * @pm_domain:	Provide callbacks that are executed during system suspend,
 * 		hibernation, system resume and during runtime PM transitions
 * 		along with subsystem-level and driver-level callbacks.
 * @pins:	For device pin management.
 *		See Documentation/pinctrl.txt for details.
 * @msi_list:	Hosts MSI descriptors
 * @msi_domain: The generic MSI domain this device is using.
 * @numa_node:	NUMA node this device is close to.
 * @dma_mask:	Dma mask (if dma'ble device).
 * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all
 * 		hardware supports 64-bit addresses for consistent allocations
 * 		such descriptors.
 * @dma_pfn_offset: offset of DMA memory range relatively of RAM
 * @dma_parms:	A low level driver may set these to teach IOMMU code about
 * 		segment limitations.
 * @dma_pools:	Dma pools (if dma'ble device).
 * @dma_mem:	Internal for coherent mem override.
 * @cma_area:	Contiguous memory area for dma allocations
 * @archdata:	For arch-specific additions.
 * @of_node:	Associated device tree node.
 * @fwnode:	Associated device node supplied by platform firmware.
 * @devt:	For creating the sysfs "dev".
 * @id:		device instance
 * @devres_lock: Spinlock to protect the resource of the device.
 * @devres_head: The resources list of the device.
 * @knode_class: The node used to add the device to the class list.
 * @class:	The class of the device.
 * @groups:	Optional attribute groups.
 * @release:	Callback to free the device after all references have
 * 		gone away. This should be set by the allocator of the
 * 		device (i.e. the bus driver that discovered the device).
 * @iommu_group: IOMMU group the device belongs to.
 * @iommu_fwspec: IOMMU-specific properties supplied by firmware.
 *
 * @offline_disabled: If set, the device is permanently online.
 * @offline:	Set after successful invocation of bus type's .offline().
 *
 * At the lowest level, every device in a Linux system is represented by an
 * instance of struct device. The device structure contains the information
 * that the device model core needs to model the system. Most subsystems,
 * however, track additional information about the devices they host. As a
 * result, it is rare for devices to be represented by bare device structures;
 * instead, that structure, like kobject structures, is usually embedded within
 * a higher-level representation of the device.
 */
struct device {
	struct device		*parent;

	struct device_private	*p;

	struct kobject kobj;
	const char		*init_name; /* initial name of the device */
	const struct device_type *type;

	struct mutex		mutex;	/* mutex to synchronize calls to
					 * its driver.
					 */

	struct bus_type	*bus;		/* type of bus device is on */
	struct device_driver *driver;	/* which driver has allocated this
					   device */
	void		*platform_data;	/* Platform specific data, device
					   core doesn't touch it */
	void		*driver_data;	/* Driver data, set and get with
					   dev_set/get_drvdata */
	struct dev_pm_info	power;
	struct dev_pm_domain	*pm_domain;

#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
	struct irq_domain	*msi_domain;
#endif
#ifdef CONFIG_PINCTRL
	struct dev_pin_info	*pins;
#endif
#ifdef CONFIG_GENERIC_MSI_IRQ
	struct list_head	msi_list;
#endif

#ifdef CONFIG_NUMA
	int		numa_node;	/* NUMA node this device is close to */
#endif
	u64		*dma_mask;	/* dma mask (if dma'able device) */
	u64		coherent_dma_mask;/* Like dma_mask, but for
					     alloc_coherent mappings as
					     not all hardware supports
					     64 bit addresses for consistent
					     allocations such descriptors. */
	unsigned long	dma_pfn_offset;

	struct device_dma_parameters *dma_parms;

	struct list_head	dma_pools;	/* dma pools (if dma'ble) */

	struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
					     override */
#ifdef CONFIG_DMA_CMA
	struct cma *cma_area;		/* contiguous memory area for dma
					   allocations */
#endif
	/* arch specific additions */
	struct dev_archdata	archdata;

	struct device_node	*of_node; /* associated device tree node */
	struct fwnode_handle	*fwnode; /* firmware device node */

	dev_t			devt;	/* dev_t, creates the sysfs "dev" */
	u32			id;	/* device instance */

	spinlock_t		devres_lock;
	struct list_head	devres_head;

	struct klist_node	knode_class;
	struct class		*class;
	const struct attribute_group **groups;	/* optional groups */

	void	(*release)(struct device *dev);
	struct iommu_group	*iommu_group;
	struct iommu_fwspec	*iommu_fwspec;

	bool			offline_disabled:1;
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
}

/* Get the wakeup routines, which depend on struct device */
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
		return dev->init_name;

	return kobject_name(&dev->kobj);
}

extern __printf(2, 3)
int dev_set_name(struct device *dev, const char *name, ...);

#ifdef CONFIG_NUMA
static inline int dev_to_node(struct device *dev)
{
	return dev->numa_node;
}
static inline void set_dev_node(struct device *dev, int node)
{
	dev->numa_node = node;
}
#else
static inline int dev_to_node(struct device *dev)
{
	return -1;
}
static inline void set_dev_node(struct device *dev, int node)
{
}
#endif

static inline struct irq_domain *dev_get_msi_domain(const struct device *dev)
{
#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
	return dev->msi_domain;
#else
	return NULL;
#endif
}

static inline void dev_set_msi_domain(struct device *dev, struct irq_domain *d)
{
#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
	dev->msi_domain = d;
#endif
}

static inline void *dev_get_drvdata(const struct device *dev)
{
	return dev->driver_data;
}

static inline void dev_set_drvdata(struct device *dev, void *data)
{
	dev->driver_data = data;
}

static inline struct pm_subsys_data *dev_to_psd(struct device *dev)
{
	return dev ? dev->power.subsys_data : NULL;
}

static inline unsigned int dev_get_uevent_suppress(const struct device *dev)
{
	return dev->kobj.uevent_suppress;
}

static inline void dev_set_uevent_suppress(struct device *dev, int val)
{
	dev->kobj.uevent_suppress = val;
}

static inline int device_is_registered(struct device *dev)
{
	return dev->kobj.state_in_sysfs;
}

static inline void device_enable_async_suspend(struct device *dev)
{
	if (!dev->power.is_prepared)
		dev->power.async_suspend = true;
}

static inline void device_disable_async_suspend(struct device *dev)
{
	if (!dev->power.is_prepared)
		dev->power.async_suspend = false;
}

static inline bool device_async_suspend_enabled(struct device *dev)
{
	return !!dev->power.async_suspend;
}

static inline void dev_pm_syscore_device(struct device *dev, bool val)
{
#ifdef CONFIG_PM_SLEEP
	dev->power.syscore = val;
#endif
}

static inline void device_lock(struct device *dev)
{
	mutex_lock(&dev->mutex);
}

static inline int device_lock_interruptible(struct device *dev)
{
	return mutex_lock_interruptible(&dev->mutex);
}

static inline int device_trylock(struct device *dev)
{
	return mutex_trylock(&dev->mutex);
}

static inline void device_unlock(struct device *dev)
{
	mutex_unlock(&dev->mutex);
}

static inline void device_lock_assert(struct device *dev)
{
	lockdep_assert_held(&dev->mutex);
}

static inline struct device_node *dev_of_node(struct device *dev)
{
	if (!IS_ENABLED(CONFIG_OF))
		return NULL;
	return dev->of_node;
}

void driver_init(void);

/*
 * High level routines for use by the bus drivers
 */
extern int __must_check device_register(struct device *dev);
extern void device_unregister(struct device *dev);
extern void device_initialize(struct device *dev);
extern int __must_check device_add(struct device *dev);
extern void device_del(struct device *dev);
extern int device_for_each_child(struct device *dev, void *data,
		     int (*fn)(struct device *dev, void *data));
extern int device_for_each_child_reverse(struct device *dev, void *data,
		     int (*fn)(struct device *dev, void *data));
extern struct device *device_find_child(struct device *dev, void *data,
				int (*match)(struct device *dev, void *data));
extern int device_rename(struct device *dev, const char *new_name);
extern int device_move(struct device *dev, struct device *new_parent,
		       enum dpm_order dpm_order);
extern const char *device_get_devnode(struct device *dev,
				      umode_t *mode, kuid_t *uid, kgid_t *gid,
				      const char **tmp);

static inline bool device_supports_offline(struct device *dev)
{
	return dev->bus && dev->bus->offline && dev->bus->online;
}

extern void lock_device_hotplug(void);
extern void unlock_device_hotplug(void);
extern int lock_device_hotplug_sysfs(void);
extern int device_offline(struct device *dev);
extern int device_online(struct device *dev);
extern void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
extern void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);

/*
 * Root device objects for grouping under /sys/devices
 */
extern struct device *__root_device_register(const char *name,
					     struct module *owner);

/* This is a macro to avoid include problems with THIS_MODULE */
#define root_device_register(name) \
	__root_device_register(name, THIS_MODULE)

extern void root_device_unregister(struct device *root);

static inline void *dev_get_platdata(const struct device *dev)
{
	return dev->platform_data;
}

/*
 * Manual binding of a device to driver. See drivers/base/bus.c
 * for information on use.
 */
extern int __must_check device_bind_driver(struct device *dev);
extern void device_release_driver(struct device *dev);
extern int  __must_check device_attach(struct device *dev);
extern int __must_check driver_attach(struct device_driver *drv);
extern void device_initial_probe(struct device *dev);
extern int __must_check device_reprobe(struct device *dev);

extern bool device_is_bound(struct device *dev);

/*
 * Easy functions for dynamically creating devices on the fly
 */
extern __printf(5, 0)
struct device *device_create_vargs(struct class *cls, struct device *parent,
				   dev_t devt, void *drvdata,
				   const char *fmt, va_list vargs);
extern __printf(5, 6)
struct device *device_create(struct class *cls, struct device *parent,
			     dev_t devt, void *drvdata,
			     const char *fmt, ...);
extern __printf(6, 7)
struct device *device_create_with_groups(struct class *cls,
			     struct device *parent, dev_t devt, void *drvdata,
			     const struct attribute_group **groups,
			     const char *fmt, ...);
extern void device_destroy(struct class *cls, dev_t devt);

/*
 * Platform "fixup" functions - allow the platform to have their say
 * about devices and actions that the general device layer doesn't
 * know about.
 */
/* Notify platform of device discovery */
extern int (*platform_notify)(struct device *dev);

extern int (*platform_notify_remove)(struct device *dev);


/*
 * get_device - atomically increment the reference count for the device.
 *
 */
extern struct device *get_device(struct device *dev);
extern void put_device(struct device *dev);

#ifdef CONFIG_DEVTMPFS
extern int devtmpfs_create_node(struct device *dev);
extern int devtmpfs_delete_node(struct device *dev);
extern int devtmpfs_mount(const char *mntdir);
#else
static inline int devtmpfs_create_node(struct device *dev) { return 0; }
static inline int devtmpfs_delete_node(struct device *dev) { return 0; }
static inline int devtmpfs_mount(const char *mountpoint) { return 0; }
#endif

/* drivers/base/power/shutdown.c */
extern void device_shutdown(void);

/* debugging and troubleshooting/diagnostic helpers. */
extern const char *dev_driver_string(const struct device *dev);


#ifdef CONFIG_PRINTK

extern __printf(3, 0)
int dev_vprintk_emit(int level, const struct device *dev,
		     const char *fmt, va_list args);
extern __printf(3, 4)
int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...);

extern __printf(3, 4)
void dev_printk(const char *level, const struct device *dev,
		const char *fmt, ...);
extern __printf(2, 3)
void dev_emerg(const struct device *dev, const char *fmt, ...);
extern __printf(2, 3)
void dev_alert(const struct device *dev, const char *fmt, ...);
extern __printf(2, 3)
void dev_crit(const struct device *dev, const char *fmt, ...);
extern __printf(2, 3)
void dev_err(const struct device *dev, const char *fmt, ...);
extern __printf(2, 3)
void dev_warn(const struct device *dev, const char *fmt, ...);
extern __printf(2, 3)
void dev_notice(const struct device *dev, const char *fmt, ...);
extern __printf(2, 3)
void _dev_info(const struct device *dev, const char *fmt, ...);

#else

static inline __printf(3, 0)
int dev_vprintk_emit(int level, const struct device *dev,
		     const char *fmt, va_list args)
{ return 0; }
static inline __printf(3, 4)
int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
{ return 0; }

static inline void __dev_printk(const char *level, const struct device *dev,
				struct va_format *vaf)
{}
static inline __printf(3, 4)
void dev_printk(const char *level, const struct device *dev,
		const char *fmt, ...)
{}

static inline __printf(2, 3)
void dev_emerg(const struct device *dev, const char *fmt, ...)
{}
static inline __printf(2, 3)
void dev_crit(const struct device *dev, const char *fmt, ...)
{}
static inline __printf(2, 3)
void dev_alert(const struct device *dev, const char *fmt, ...)
{}
static inline __printf(2, 3)
void dev_err(const struct device *dev, const char *fmt, ...)
{}
static inline __printf(2, 3)
void dev_warn(const struct device *dev, const char *fmt, ...)
{}
static inline __printf(2, 3)
void dev_notice(const struct device *dev, const char *fmt, ...)
{}
static inline __printf(2, 3)
void _dev_info(const struct device *dev, const char *fmt, ...)
{}

#endif

/*
 * Stupid hackaround for existing uses of non-printk uses dev_info
 *
 * Note that the definition of dev_info below is actually _dev_info
 * and a macro is used to avoid redefining dev_info
 */

#define dev_info(dev, fmt, arg...) _dev_info(dev, fmt, ##arg)

#if defined(CONFIG_DYNAMIC_DEBUG)
#define dev_dbg(dev, format, ...)		     \
do {						     \
	dynamic_dev_dbg(dev, format, ##__VA_ARGS__); \
} while (0)
#elif defined(DEBUG)
#define dev_dbg(dev, format, arg...)		\
	dev_printk(KERN_DEBUG, dev, format, ##arg)
#else
#define dev_dbg(dev, format, arg...)				\
({								\
	if (0)							\
		dev_printk(KERN_DEBUG, dev, format, ##arg);	\
})
#endif

#ifdef CONFIG_PRINTK
#define dev_level_once(dev_level, dev, fmt, ...)			\
do {									\
	static bool __print_once __read_mostly;				\
									\
	if (!__print_once) {						\
		__print_once = true;					\
		dev_level(dev, fmt, ##__VA_ARGS__);			\
	}								\
} while (0)
#else
#define dev_level_once(dev_level, dev, fmt, ...)			\
do {									\
	if (0)								\
		dev_level(dev, fmt, ##__VA_ARGS__);			\
} while (0)
#endif

#define dev_emerg_once(dev, fmt, ...)					\
	dev_level_once(dev_emerg, dev, fmt, ##__VA_ARGS__)
#define dev_alert_once(dev, fmt, ...)					\
	dev_level_once(dev_alert, dev, fmt, ##__VA_ARGS__)
#define dev_crit_once(dev, fmt, ...)					\
	dev_level_once(dev_crit, dev, fmt, ##__VA_ARGS__)
#define dev_err_once(dev, fmt, ...)					\
	dev_level_once(dev_err, dev, fmt, ##__VA_ARGS__)
#define dev_warn_once(dev, fmt, ...)					\
	dev_level_once(dev_warn, dev, fmt, ##__VA_ARGS__)
#define dev_notice_once(dev, fmt, ...)					\
	dev_level_once(dev_notice, dev, fmt, ##__VA_ARGS__)
#define dev_info_once(dev, fmt, ...)					\
	dev_level_once(dev_info, dev, fmt, ##__VA_ARGS__)
#define dev_dbg_once(dev, fmt, ...)					\
	dev_level_once(dev_dbg, dev, fmt, ##__VA_ARGS__)

#define dev_level_ratelimited(dev_level, dev, fmt, ...)			\
do {									\
	static DEFINE_RATELIMIT_STATE(_rs,				\
				      DEFAULT_RATELIMIT_INTERVAL,	\
				      DEFAULT_RATELIMIT_BURST);		\
	if (__ratelimit(&_rs))						\
		dev_level(dev, fmt, ##__VA_ARGS__);			\
} while (0)

#define dev_emerg_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_emerg, dev, fmt, ##__VA_ARGS__)
#define dev_alert_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_alert, dev, fmt, ##__VA_ARGS__)
#define dev_crit_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_crit, dev, fmt, ##__VA_ARGS__)
#define dev_err_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_err, dev, fmt, ##__VA_ARGS__)
#define dev_warn_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_warn, dev, fmt, ##__VA_ARGS__)
#define dev_notice_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_notice, dev, fmt, ##__VA_ARGS__)
#define dev_info_ratelimited(dev, fmt, ...)				\
	dev_level_ratelimited(dev_info, dev, fmt, ##__VA_ARGS__)
#if defined(CONFIG_DYNAMIC_DEBUG)
/* descriptor check is first to prevent flooding with "callbacks suppressed" */
#define dev_dbg_ratelimited(dev, fmt, ...)				\
do {									\
	static DEFINE_RATELIMIT_STATE(_rs,				\
				      DEFAULT_RATELIMIT_INTERVAL,	\
				      DEFAULT_RATELIMIT_BURST);		\
	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\
	if (unlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT) &&	\
	    __ratelimit(&_rs))						\
		__dynamic_dev_dbg(&descriptor, dev, fmt,		\
				  ##__VA_ARGS__);			\
} while (0)
#elif defined(DEBUG)
#define dev_dbg_ratelimited(dev, fmt, ...)				\
do {									\
	static DEFINE_RATELIMIT_STATE(_rs,				\
				      DEFAULT_RATELIMIT_INTERVAL,	\
				      DEFAULT_RATELIMIT_BURST);		\
	if (__ratelimit(&_rs))						\
		dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);	\
} while (0)
#else
#define dev_dbg_ratelimited(dev, fmt, ...)				\
do {									\
	if (0)								\
		dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);	\
} while (0)
#endif

#ifdef VERBOSE_DEBUG
#define dev_vdbg	dev_dbg
#else
#define dev_vdbg(dev, format, arg...)				\
({								\
	if (0)							\
		dev_printk(KERN_DEBUG, dev, format, ##arg);	\
})
#endif

/*
 * dev_WARN*() acts like dev_printk(), but with the key difference of
 * using WARN/WARN_ONCE to include file/line information and a backtrace.
 */
#define dev_WARN(dev, format, arg...) \
	WARN(1, "%s %s: " format, dev_driver_string(dev), dev_name(dev), ## arg);

#define dev_WARN_ONCE(dev, condition, format, arg...) \
	WARN_ONCE(condition, "%s %s: " format, \
			dev_driver_string(dev), dev_name(dev), ## arg)

/* Create alias, so I can be autoloaded. */
#define MODULE_ALIAS_CHARDEV(major,minor) \
	MODULE_ALIAS("char-major-" __stringify(major) "-" __stringify(minor))
#define MODULE_ALIAS_CHARDEV_MAJOR(major) \
	MODULE_ALIAS("char-major-" __stringify(major) "-*")

#ifdef CONFIG_SYSFS_DEPRECATED
extern long sysfs_deprecated;
#else
#define sysfs_deprecated 0
#endif

/**
 * module_driver() - Helper macro for drivers that don't do anything
 * special in module init/exit. This eliminates a lot of boilerplate.
 * Each module may only use this macro once, and calling it replaces
 * module_init() and module_exit().
 *
 * @__driver: driver name
 * @__register: register function for this driver type
 * @__unregister: unregister function for this driver type
 * @...: Additional arguments to be passed to __register and __unregister.
 *
 * Use this macro to construct bus specific macros for registering
 * drivers, and do not use it on its own.
 */
#define module_driver(__driver, __register, __unregister, ...) \
static int __init __driver##_init(void) \
{ \
	return __register(&(__driver) , ##__VA_ARGS__); \
} \
module_init(__driver##_init); \
static void __exit __driver##_exit(void) \
{ \
	__unregister(&(__driver) , ##__VA_ARGS__); \
} \
module_exit(__driver##_exit);

/**
 * builtin_driver() - Helper macro for drivers that don't do anything
 * special in init and have no exit. This eliminates some boilerplate.
 * Each driver may only use this macro once, and calling it replaces
 * device_initcall (or in some cases, the legacy __initcall).  This is
 * meant to be a direct parallel of module_driver() above but without
 * the __exit stuff that is not used for builtin cases.
 *
 * @__driver: driver name
 * @__register: register function for this driver type
 * @...: Additional arguments to be passed to __register
 *
 * Use this macro to construct bus specific macros for registering
 * drivers, and do not use it on its own.
 */
#define builtin_driver(__driver, __register, ...) \
static int __init __driver##_init(void) \
{ \
	return __register(&(__driver) , ##__VA_ARGS__); \
} \
device_initcall(__driver##_init);

#endif /* _DEVICE_H_ */
                                                                                                                                                                                                                                                                                                                       /*
 * i2c-ocores.h - definitions for the i2c-ocores interface
 *
 * Peter Korsgaard <jacmet@sunsite.dk>
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2.  This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#ifndef _LINUX_I2C_OCORES_H
#define _LINUX_I2C_OCORES_H

struct ocores_i2c_platform_data {
	u32 reg_shift; /* register offset shift value */
	u32 reg_io_width; /* register io read/write width */
	u32 clock_khz; /* input clock in kHz */
	bool big_endian; /* registers are big endian */
	u8 num_devices; /* number of devices in the devices list */
	struct i2c_board_info const *devices; /* devices connected to the bus */
};

#endif /* _LINUX_I2C_OCORES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * nl802154.h
 *
 * Copyright (C) 2007, 2008, 2009 Siemens AG
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#ifndef NL802154_H
#define NL802154_H

#define IEEE802154_NL_NAME "802.15.4 MAC"
#define IEEE802154_MCAST_COORD_NAME "coordinator"
#define IEEE802154_MCAST_BEACON_NAME "beacon"

enum {
	__IEEE802154_ATTR_INVALID,

	IEEE802154_ATTR_DEV_NAME,
	IEEE802154_ATTR_DEV_INDEX,

	IEEE802154_ATTR_STATUS,

	IEEE802154_ATTR_SHORT_ADDR,
	IEEE802154_ATTR_HW_ADDR,
	IEEE802154_ATTR_PAN_ID,

	IEEE802154_ATTR_CHANNEL,

	IEEE802154_ATTR_COORD_SHORT_ADDR,
	IEEE802154_ATTR_COORD_HW_ADDR,
	IEEE802154_ATTR_COORD_PAN_ID,

	IEEE802154_ATTR_SRC_SHORT_ADDR,
	IEEE802154_ATTR_SRC_HW_ADDR,
	IEEE802154_ATTR_SRC_PAN_ID,

	IEEE802154_ATTR_DEST_SHORT_ADDR,
	IEEE802154_ATTR_DEST_HW_ADDR,
	IEEE802154_ATTR_DEST_PAN_ID,

	IEEE802154_ATTR_CAPABILITY,
	IEEE802154_ATTR_REASON,
	IEEE802154_ATTR_SCAN_TYPE,
	IEEE802154_ATTR_CHANNELS,
	IEEE802154_ATTR_DURATION,
	IEEE802154_ATTR_ED_LIST,
	IEEE802154_ATTR_BCN_ORD,
	IEEE802154_ATTR_SF_ORD,
	IEEE802154_ATTR_PAN_COORD,
	IEEE802154_ATTR_BAT_EXT,
	IEEE802154_ATTR_COORD_REALIGN,
	IEEE802154_ATTR_SEC,

	IEEE802154_ATTR_PAGE,
	IEEE802154_ATTR_CHANNEL_PAGE_LIST,

	IEEE802154_ATTR_PHY_NAME,
	IEEE802154_ATTR_DEV_TYPE,

	IEEE802154_ATTR_TXPOWER,
	IEEE802154_ATTR_LBT_ENABLED,
	IEEE802154_ATTR_CCA_MODE,
	IEEE802154_ATTR_CCA_ED_LEVEL,
	IEEE802154_ATTR_CSMA_RETRIES,
	IEEE802154_ATTR_CSMA_MIN_BE,
	IEEE802154_ATTR_CSMA_MAX_BE,

	IEEE802154_ATTR_FRAME_RETRIES,

	IEEE802154_ATTR_LLSEC_ENABLED,
	IEEE802154_ATTR_LLSEC_SECLEVEL,
	IEEE802154_ATTR_LLSEC_KEY_MODE,
	IEEE802154_ATTR_LLSEC_KEY_SOURCE_SHORT,
	IEEE802154_ATTR_LLSEC_KEY_SOURCE_EXTENDED,
	IEEE802154_ATTR_LLSEC_KEY_ID,
	IEEE802154_ATTR_LLSEC_FRAME_COUNTER,
	IEEE802154_ATTR_LLSEC_KEY_BYTES,
	IEEE802154_ATTR_LLSEC_KEY_USAGE_FRAME_TYPES,
	IEEE802154_ATTR_LLSEC_KEY_USAGE_COMMANDS,
	IEEE802154_ATTR_LLSEC_FRAME_TYPE,
	IEEE802154_ATTR_LLSEC_CMD_FRAME_ID,
	IEEE802154_ATTR_LLSEC_SECLEVELS,
	IEEE802154_ATTR_LLSEC_DEV_OVERRIDE,
	IEEE802154_ATTR_LLSEC_DEV_KEY_MODE,

	IEEE802154_ATTR_PAD,

	__IEEE802154_ATTR_MAX,
};

#define IEEE802154_ATTR_MAX (__IEEE802154_ATTR_MAX - 1)

extern const struct nla_policy ieee802154_policy[];

/* commands */
/* REQ should be responded with CONF
 * and INDIC with RESP
 */
enum {
	__IEEE802154_COMMAND_INVALID,

	IEEE802154_ASSOCIATE_REQ,
	IEEE802154_ASSOCIATE_CONF,
	IEEE802154_DISASSOCIATE_REQ,
	IEEE802154_DISASSOCIATE_CONF,
	IEEE802154_GET_REQ,
	IEEE802154_GET_CONF,
	IEEE802154_RESET_REQ,
	IEEE802154_RESET_CONF,
	IEEE802154_SCAN_REQ,
	IEEE802154_SCAN_CONF,
	IEEE802154_SET_REQ,
	IEEE802154_SET_CONF,
	IEEE802154_START_REQ,
	IEEE802154_START_CONF,
	IEEE802154_SYNC_REQ,
	IEEE802154_POLL_REQ,
	IEEE802154_POLL_CONF,

	IEEE802154_ASSOCIATE_INDIC,
	IEEE802154_ASSOCIATE_RESP,
	IEEE802154_DISASSOCIATE_INDIC,
	IEEE802154_BEACON_NOTIFY_INDIC,
	IEEE802154_ORPHAN_INDIC,
	IEEE802154_ORPHAN_RESP,
	IEEE802154_COMM_STATUS_INDIC,
	IEEE802154_SYNC_LOSS_INDIC,

	IEEE802154_GTS_REQ, /* Not supported yet */
	IEEE802154_GTS_INDIC, /* Not supported yet */
	IEEE802154_GTS_CONF, /* Not supported yet */
	IEEE802154_RX_ENABLE_REQ, /* Not supported yet */
	IEEE802154_RX_ENABLE_CONF, /* Not supported yet */

	IEEE802154_LIST_IFACE,
	IEEE802154_LIST_PHY,
	IEEE802154_ADD_IFACE,
	IEEE802154_DEL_IFACE,

	IEEE802154_SET_MACPARAMS,

	IEEE802154_LLSEC_GETPARAMS,
	IEEE802154_LLSEC_SETPARAMS,
	IEEE802154_LLSEC_LIST_KEY,
	IEEE802154_LLSEC_ADD_KEY,
	IEEE802154_LLSEC_DEL_KEY,
	IEEE802154_LLSEC_LIST_DEV,
	IEEE802154_LLSEC_ADD_DEV,
	IEEE802154_LLSEC_DEL_DEV,
	IEEE802154_LLSEC_LIST_DEVKEY,
	IEEE802154_LLSEC_ADD_DEVKEY,
	IEEE802154_LLSEC_DEL_DEVKEY,
	IEEE802154_LLSEC_LIST_SECLEVEL,
	IEEE802154_LLSEC_ADD_SECLEVEL,
	IEEE802154_LLSEC_DEL_SECLEVEL,

	__IEEE802154_CMD_MAX,
};

#define IEEE802154_CMD_MAX (__IEEE802154_CMD_MAX - 1)

enum {
	__IEEE802154_DEV_INVALID = -1,

	IEEE802154_DEV_WPAN,
	IEEE802154_DEV_MONITOR,

	__IEEE802154_DEV_MAX,
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef _LINUX_Z2_BATTERY_H
#define _LINUX_Z2_BATTERY_H

struct z2_battery_info {
	int	 batt_I2C_bus;
	int	 batt_I2C_addr;
	int	 batt_I2C_reg;
	int	 charge_gpio;
	int	 min_voltage;
	int	 max_voltage;
	int	 batt_div;
	int	 batt_mult;
	int	 batt_tech;
	char	*batt_name;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 *  linux/drivers/char/serial_core.h
 *
 *  Copyright (C) 2000 Deep Blue Solutions Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#ifndef LINUX_SERIAL_CORE_H
#define LINUX_SERIAL_CORE_H


#include <linux/compiler.h>
#include <linux/interrupt.h>
#include <linux/circ_buf.h>
#include <linux/spinlock.h>
#include <linux/sched.h>
#include <linux/tty.h>
#include <linux/mutex.h>
#include <linux/sysrq.h>
#include <uapi/linux/serial_core.h>

#ifdef CONFIG_SERIAL_CORE_CONSOLE
#define uart_console(port) \
	((port)->cons && (port)->cons->index == (port)->line)
#else
#define uart_console(port)      ({ (void)port; 0; })
#endif

struct uart_port;
struct serial_struct;
struct device;

/*
 * This structure describes all the operations that can be done on the
 * physical hardware.  See Documentation/serial/driver for details.
 */
struct uart_ops {
	unsigned int	(*tx_empty)(struct uart_port *);
	void		(*set_mctrl)(struct uart_port *, unsigned int mctrl);
	unsigned int	(*get_mctrl)(struct uart_port *);
	void		(*stop_tx)(struct uart_port *);
	void		(*start_tx)(struct uart_port *);
	void		(*throttle)(struct uart_port *);
	void		(*unthrottle)(struct uart_port *);
	void		(*send_xchar)(struct uart_port *, char ch);
	void		(*stop_rx)(struct uart_port *);
	void		(*enable_ms)(struct uart_port *);
	void		(*break_ctl)(struct uart_port *, int ctl);
	int		(*startup)(struct uart_port *);
	void		(*shutdown)(struct uart_port *);
	void		(*flush_buffer)(struct uart_port *);
	void		(*set_termios)(struct uart_port *, struct ktermios *new,
				       struct ktermios *old);
	void		(*set_ldisc)(struct uart_port *, struct ktermios *);
	void		(*pm)(struct uart_port *, unsigned int state,
			      unsigned int oldstate);

	/*
	 * Return a string describing the type of the port
	 */
	const char	*(*type)(struct uart_port *);

	/*
	 * Release IO and memory resources used by the port.
	 * This includes iounmap if necessary.
	 */
	void		(*release_port)(struct uart_port *);

	/*
	 * Request IO and memory resources used by the port.
	 * This includes iomapping the port if necessary.
	 */
	int		(*request_port)(struct uart_port *);
	void		(*config_port)(struct uart_port *, int);
	int		(*verify_port)(struct uart_port *, struct serial_struct *);
	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
#ifdef CONFIG_CONSOLE_POLL
	int		(*poll_init)(struct uart_port *);
	void		(*poll_put_char)(struct uart_port *, unsigned char);
	int		(*poll_get_char)(struct uart_port *);
#endif
};

#define NO_POLL_CHAR		0x00ff0000
#define UART_CONFIG_TYPE	(1 << 0)
#define UART_CONFIG_IRQ		(1 << 1)

struct uart_icount {
	__u32	cts;
	__u32	dsr;
	__u32	rng;
	__u32	dcd;
	__u32	rx;
	__u32	tx;
	__u32	frame;
	__u32	overrun;
	__u32	parity;
	__u32	brk;
	__u32	buf_overrun;
};

typedef unsigned int __bitwise__ upf_t;
typedef unsigned int __bitwise__ upstat_t;

struct uart_port {
	spinlock_t		lock;			/* port lock */
	unsigned long		iobase;			/* in/out[bwl] */
	unsigned char __iomem	*membase;		/* read/write[bwl] */
	unsigned int		(*serial_in)(struct uart_port *, int);
	void			(*serial_out)(struct uart_port *, int, int);
	void			(*set_termios)(struct uart_port *,
				               struct ktermios *new,
				               struct ktermios *old);
	unsigned int		(*get_mctrl)(struct uart_port *);
	void			(*set_mctrl)(struct uart_port *, unsigned int);
	int			(*startup)(struct uart_port *port);
	void			(*shutdown)(struct uart_port *port);
	void			(*throttle)(struct uart_port *port);
	void			(*unthrottle)(struct uart_port *port);
	int			(*handle_irq)(struct uart_port *);
	void			(*pm)(struct uart_port *, unsigned int state,
				      unsigned int old);
	void			(*handle_break)(struct uart_port *);
	int			(*rs485_config)(struct uart_port *,
						struct serial_rs485 *rs485);
	unsigned int		irq;			/* irq number */
	unsigned long		irqflags;		/* irq flags  */
	unsigned int		uartclk;		/* base uart clock */
	unsigned int		fifosize;		/* tx fifo size */
	unsigned char		x_char;			/* xon/xoff char */
	unsigned char		regshift;		/* reg offset shift */
	unsigned char		iotype;			/* io access style */
	unsigned char		unused1;

#define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
#define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
#define UPIO_MEM		(SERIAL_IO_MEM)		/* driver-specific */
#define UPIO_MEM32		(SERIAL_IO_MEM32)	/* 32b little endian */
#define UPIO_AU			(SERIAL_IO_AU)		/* Au1x00 and RT288x type IO */
#define UPIO_TSI		(SERIAL_IO_TSI)		/* Tsi108/109 type IO */
#define UPIO_MEM32BE		(SERIAL_IO_MEM32BE)	/* 32b big endian */
#define UPIO_MEM16		(SERIAL_IO_MEM16)	/* 16b little endian */

	unsigned int		read_status_mask;	/* driver specific */
	unsigned int		ignore_status_mask;	/* driver specific */
	struct uart_state	*state;			/* pointer to parent state */
	struct uart_icount	icount;			/* statistics */

	struct console		*cons;			/* struct console, if any */
#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
	unsigned long		sysrq;			/* sysrq timeout */
#endif

	/* flags must be updated while holding port mutex */
	upf_t			flags;

	/*
	 * These flags must be equivalent to the flags defined in
	 * include/uapi/linux/tty_flags.h which are the userspace definitions
	 * assigned from the serial_struct flags in uart_set_info()
	 * [for bit definitions in the UPF_CHANGE_MASK]
	 *
	 * Bits [0..UPF_LAST_USER] are userspace defined/visible/changeable
	 * except bit 15 (UPF_NO_TXEN_TEST) which is masked off.
	 * The remaining bits are serial-core specific and not modifiable by
	 * userspace.
	 */
#define UPF_FOURPORT		((__force upf_t) ASYNC_FOURPORT       /* 1  */ )
#define UPF_SAK			((__force upf_t) ASYNC_SAK            /* 2  */ )
#define UPF_SPD_HI		((__force upf_t) ASYNC_SPD_HI         /* 4  */ )
#define UPF_SPD_VHI		((__force upf_t) ASYNC_SPD_VHI        /* 5  */ )
#define UPF_SPD_CUST		((__force upf_t) ASYNC_SPD_CUST   /* 0x0030 */ )
#define UPF_SPD_WARP		((__force upf_t) ASYNC_SPD_WARP   /* 0x1010 */ )
#define UPF_SPD_MASK		((__force upf_t) ASYNC_SPD_MASK   /* 0x1030 */ )
#define UPF_SKIP_TEST		((__force upf_t) ASYNC_SKIP_TEST      /* 6  */ )
#define UPF_AUTO_IRQ		((__force upf_t) ASYNC_AUTO_IRQ       /* 7  */ )
#define UPF_HARDPPS_CD		((__force upf_t) ASYNC_HARDPPS_CD     /* 11 */ )
#define UPF_SPD_SHI		((__force upf_t) ASYNC_SPD_SHI        /* 12 */ )
#define UPF_LOW_LATENCY		((__force upf_t) ASYNC_LOW_LATENCY    /* 13 */ )
#define UPF_BUGGY_UART		((__force upf_t) ASYNC_BUGGY_UART     /* 14 */ )
#define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
#define UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER /* 16 */ )

/* Port has hardware-assisted h/w flow control */
#define UPF_AUTO_CTS		((__force upf_t) (1 << 20))
#define UPF_AUTO_RTS		((__force upf_t) (1 << 21))
#define UPF_HARD_FLOW		((__force upf_t) (UPF_AUTO_CTS | UPF_AUTO_RTS))
/* Port has hardware-assisted s/w flow control */
#define UPF_SOFT_FLOW		((__force upf_t) (1 << 22))
#define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
#define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
#define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
#define UPF_BUG_THRE		((__force upf_t) (1 << 26))
/* The exact UART type is known and should not be probed.  */
#define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
#define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
#define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
#define UPF_DEAD		((__force upf_t) (1 << 30))
#define UPF_IOREMAP		((__force upf_t) (1 << 31))

#define __UPF_CHANGE_MASK	0x17fff
#define UPF_CHANGE_MASK		((__force upf_t) __UPF_CHANGE_MASK)
#define UPF_USR_MASK		((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))

#if __UPF_CHANGE_MASK > ASYNC_FLAGS
#error Change mask not equivalent to userspace-visible bit defines
#endif

	/*
	 * Must hold termios_rwsem, port mutex and port lock to change;
	 * can hold any one lock to read.
	 */
	upstat_t		status;

#define UPSTAT_CTS_ENABLE	((__force upstat_t) (1 << 0))
#define UPSTAT_DCD_ENABLE	((__force upstat_t) (1 << 1))
#define UPSTAT_AUTORTS		((__force upstat_t) (1 << 2))
#define UPSTAT_AUTOCTS		((__force upstat_t) (1 << 3))
#define UPSTAT_AUTOXOFF		((__force upstat_t) (1 << 4))

	int			hw_stopped;		/* sw-assisted CTS flow state */
	unsigned int		mctrl;			/* current modem ctrl settings */
	unsigned int		timeout;		/* character-based timeout */
	unsigned int		type;			/* port type */
	const struct uart_ops	*ops;
	unsigned int		custom_divisor;
	unsigned int		line;			/* port index */
	unsigned int		minor;
	resource_size_t		mapbase;		/* for ioremap */
	resource_size_t		mapsize;
	struct device		*dev;			/* parent device */
	unsigned char		hub6;			/* this should be in the 8250 driver */
	unsigned char		suspended;
	unsigned char		irq_wake;
	unsigned char		unused[2];
	struct attribute_group	*attr_group;		/* port specific attributes */
	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
	struct serial_rs485     rs485;
	void			*private_data;		/* generic platform data pointer */
};

static inline int serial_port_in(struct uart_port *up, int offset)
{
	return up->serial_in(up, offset);
}

static inline void serial_port_out(struct uart_port *up, int offset, int value)
{
	up->serial_out(up, offset, value);
}

/**
 * enum uart_pm_state - power states for UARTs
 * @UART_PM_STATE_ON: UART is powered, up and operational
 * @UART_PM_STATE_OFF: UART is powered off
 * @UART_PM_STATE_UNDEFINED: sentinel
 */
enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3, /* number taken from ACPI */
	UART_PM_STATE_UNDEFINED,
};

/*
 * This is the state information which is persistent across opens.
 */
struct uart_state {
	struct tty_port		port;

	enum uart_pm_state	pm_state;
	struct circ_buf		xmit;

	atomic_t		refcount;
	wait_queue_head_t	remove_wait;
	struct uart_port	*uart_port;
};

#define UART_XMIT_SIZE	PAGE_SIZE


/* number of characters left in xmit buffer before we ask for more */
#define WAKEUP_CHARS		256

struct module;
struct tty_driver;

struct uart_driver {
	struct module		*owner;
	const char		*driver_name;
	const char		*dev_name;
	int			 major;
	int			 minor;
	int			 nr;
	struct console		*cons;

	/*
	 * these are private; the low level driver should not
	 * touch these; they should be initialised to NULL
	 */
	struct uart_state	*state;
	struct tty_driver	*tty_driver;
};

void uart_write_wakeup(struct uart_port *port);

/*
 * Baud rate helpers.
 */
void uart_update_timeout(struct uart_port *port, unsigned int cflag,
			 unsigned int baud);
unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios,
				struct ktermios *old, unsigned int min,
				unsigned int max);
unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);

/* Base timer interval for polling */
static inline int uart_poll_timeout(struct uart_port *port)
{
	int timeout = port->timeout;

	return timeout > 6 ? (timeout / 2 - 2) : 1;
}

/*
 * Console helpers.
 */
struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];		/* e.g., 115200n8 */
	unsigned int baud;
};

struct earlycon_id {
	char	name[16];
	char	compatible[128];
	int	(*setup)(struct earlycon_device *, const char *options);
} __aligned(32);

extern const struct earlycon_id __earlycon_table[];
extern const struct earlycon_id __earlycon_table_end[];

#if defined(CONFIG_SERIAL_EARLYCON) && !defined(MODULE)
#define EARLYCON_USED_OR_UNUSED	__used
#else
#define EARLYCON_USED_OR_UNUSED	__maybe_unused
#endif

#define OF_EARLYCON_DECLARE(_name, compat, fn)				\
	static const struct earlycon_id __UNIQUE_ID(__earlycon_##_name)	\
	     EARLYCON_USED_OR_UNUSED __section(__earlycon_table)	\
		= { .name = __stringify(_name),				\
		    .compatible = compat,				\
		    .setup = fn  }

#define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)

extern int of_setup_earlycon(const struct earlycon_id *match,
			     unsigned long node,
			     const char *options);

#ifdef CONFIG_SERIAL_EARLYCON
extern bool earlycon_init_is_deferred __initdata;
int setup_earlycon(char *buf);
#else
static const bool earlycon_init_is_deferred;
static inline int setup_earlycon(char *buf) { return 0; }
#endif

struct uart_port *uart_get_console(struct uart_port *ports, int nr,
				   struct console *c);
int uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,
			char **options);
void uart_parse_options(char *options, int *baud, int *parity, int *bits,
			int *flow);
int uart_set_options(struct uart_port *port, struct console *co, int baud,
		     int parity, int bits, int flow);
struct tty_driver *uart_console_device(struct console *co, int *index);
void uart_console_write(struct uart_port *port, const char *s,
			unsigned int count,
			void (*putchar)(struct uart_port *, int));

/*
 * Port/driver registration/removal
 */
int uart_register_driver(struct uart_driver *uart);
void uart_unregister_driver(struct uart_driver *uart);
int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
int uart_match_port(struct uart_port *port1, struct uart_port *port2);

/*
 * Power Management
 */
int uart_suspend_port(struct uart_driver *reg, struct uart_port *port);
int uart_resume_port(struct uart_driver *reg, struct uart_port *port);

#define uart_circ_empty(circ)		((circ)->head == (circ)->tail)
#define uart_circ_clear(circ)		((circ)->head = (circ)->tail = 0)

#define uart_circ_chars_pending(circ)	\
	(CIRC_CNT((circ)->head, (circ)->tail, UART_XMIT_SIZE))

#define uart_circ_chars_free(circ)	\
	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))

static inline int uart_tx_stopped(struct uart_port *port)
{
	struct tty_struct *tty = port->state->port.tty;
	if ((tty && tty->stopped) || port->hw_stopped)
		return 1;
	return 0;
}

static inline bool uart_cts_enabled(struct uart_port *uport)
{
	return !!(uport->status & UPSTAT_CTS_ENABLE);
}

static inline bool uart_softcts_mode(struct uart_port *uport)
{
	upstat_t mask = UPSTAT_CTS_ENABLE | UPSTAT_AUTOCTS;

	return ((uport->status & mask) == UPSTAT_CTS_ENABLE);
}

/*
 * The following are helper functions for the low level drivers.
 */

extern void uart_handle_dcd_change(struct uart_port *uport,
		unsigned int status);
extern void uart_handle_cts_change(struct uart_port *uport,
		unsigned int status);

extern void uart_insert_char(struct uart_port *port, unsigned int status,
		 unsigned int overrun, unsigned int ch, unsigned int flag);

#ifdef SUPPORT_SYSRQ
static inline int
uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
{
	if (port->sysrq) {
		if (ch && time_before(jiffies, port->sysrq)) {
			handle_sysrq(ch);
			port->sysrq = 0;
			return 1;
		}
		port->sysrq = 0;
	}
	return 0;
}
#else
#define uart_handle_sysrq_char(port,ch) ({ (void)port; 0; })
#endif

/*
 * We do the SysRQ and SAK checking like this...
 */
static inline int uart_handle_break(struct uart_port *port)
{
	struct uart_state *state = port->state;

	if (port->handle_break)
		port->handle_break(port);

#ifdef SUPPORT_SYSRQ
	if (port->cons && port->cons->index == port->line) {
		if (!port->sysrq) {
			port->sysrq = jiffies + HZ*5;
			return 1;
		}
		port->sysrq = 0;
	}
#endif
	if (port->flags & UPF_SAK)
		do_SAK(state->port.tty);
	return 0;
}

/*
 *	UART_ENABLE_MS - determine if port should enable modem status irqs
 */
#define UART_ENABLE_MS(port,cflag)	((port)->flags & UPF_HARDPPS_CD || \
					 (cflag) & CRTSCTS || \
					 !((cflag) & CLOCAL))

#endif /* LINUX_SERIAL_CORE_H */
                                                                                                                                                                                                                                                              #ifndef __LINUX_GOLDFISH_H
#define __LINUX_GOLDFISH_H

/* Helpers for Goldfish virtual platform */

static inline void gf_write_ptr(const void *ptr, void __iomem *portl,
				void __iomem *porth)
{
	writel((u32)(unsigned long)ptr, portl);
#ifdef CONFIG_64BIT
	writel((unsigned long)ptr >> 32, porth);
#endif
}

static inline void gf_write_dma_addr(const dma_addr_t addr,
				     void __iomem *portl,
				     void __iomem *porth)
{
	writel((u32)addr, portl);
#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
	writel(addr >> 32, porth);
#endif
}


#endif /* __LINUX_GOLDFISH_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *  BSG helper library
 *
 *  Copyright (C) 2008   James Smart, Emulex Corporation
 *  Copyright (C) 2011   Red Hat, Inc.  All rights reserved.
 *  Copyright (C) 2011   Mike Christie
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
#ifndef _BLK_BSG_
#define _BLK_BSG_

#include <linux/blkdev.h>

struct request;
struct device;
struct scatterlist;
struct request_queue;

struct bsg_buffer {
	unsigned int payload_len;
	int sg_cnt;
	struct scatterlist *sg_list;
};

struct bsg_job {
	struct device *dev;
	struct request *req;

	/* Transport/driver specific request/reply structs */
	void *request;
	void *reply;

	unsigned int request_len;
	unsigned int reply_len;
	/*
	 * On entry : reply_len indicates the buffer size allocated for
	 * the reply.
	 *
	 * Upon completion : the message handler must set reply_len
	 *  to indicates the size of the reply to be returned to the
	 *  caller.
	 */

	/* DMA payloads for the request/response */
	struct bsg_buffer request_payload;
	struct bsg_buffer reply_payload;

	void *dd_data;		/* Used for driver-specific storage */
};

void bsg_job_done(struct bsg_job *job, int result,
		  unsigned int reply_payload_rcv_len);
int bsg_setup_queue(struct device *dev, struct request_queue *q, char *name,
		    bsg_job_fn *job_fn, int dd_job_size);
void bsg_request_fn(struct request_queue *q);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /* linux/include/linux/scx200.h

   Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>

   Defines for the National Semiconductor SCx200 Processors
*/

/* Interesting stuff for the National Semiconductor SCx200 CPU */

extern unsigned scx200_cb_base;

#define scx200_cb_present() (scx200_cb_base!=0)

/* F0 PCI Header/Bridge Configuration Registers */
#define SCx200_DOCCS_BASE 0x78	/* DOCCS Base Address Register */
#define SCx200_DOCCS_CTRL 0x7c	/* DOCCS Control Register */

/* GPIO Register Block */
#define SCx200_GPIO_SIZE 0x2c	/* Size of GPIO register block */

/* General Configuration Block */
#define SCx200_CB_BASE_FIXED 0x9000	/* Base fixed at 0x9000 according to errata? */

/* Watchdog Timer */
#define SCx200_WDT_OFFSET 0x00	/* offset within configuration block */
#define SCx200_WDT_SIZE 0x05	/* size */

#define SCx200_WDT_WDTO 0x00	/* Time-Out Register */
#define SCx200_WDT_WDCNFG 0x02	/* Configuration Register */
#define SCx200_WDT_WDSTS 0x04	/* Status Register */
#define SCx200_WDT_WDSTS_WDOVF (1<<0) /* Overflow bit */

/* High Resolution Timer */
#define SCx200_TIMER_OFFSET 0x08
#define SCx200_TIMER_SIZE 0x06

/* Clock Generators */
#define SCx200_CLOCKGEN_OFFSET 0x10
#define SCx200_CLOCKGEN_SIZE 0x10

/* Pin Multiplexing and Miscellaneous Configuration Registers */
#define SCx200_MISC_OFFSET 0x30
#define SCx200_MISC_SIZE 0x10

#define SCx200_PMR 0x30		/* Pin Multiplexing Register */
#define SCx200_MCR 0x34		/* Miscellaneous Configuration Register */
#define SCx200_INTSEL 0x38	/* Interrupt Selection Register */
#define SCx200_IID 0x3c		/* IA On a Chip Identification Number Reg */
#define SCx200_REV 0x3d		/* Revision Register */
#define SCx200_CBA 0x3e		/* Configuration Base Address Register */
#define SCx200_CBA_SCRATCH 0x64	/* Configuration Base Address Scratchpad */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * NUMA memory policies for Linux.
 * Copyright 2003,2004 Andi Kleen SuSE Labs
 */
#ifndef _LINUX_MEMPOLICY_H
#define _LINUX_MEMPOLICY_H 1


#include <linux/mmzone.h>
#include <linux/slab.h>
#include <linux/rbtree.h>
#include <linux/spinlock.h>
#include <linux/nodemask.h>
#include <linux/pagemap.h>
#include <uapi/linux/mempolicy.h>

struct mm_struct;

#ifdef CONFIG_NUMA

/*
 * Describe a memory policy.
 *
 * A mempolicy can be either associated with a process or with a VMA.
 * For VMA related allocations the VMA policy is preferred, otherwise
 * the process policy is used. Interrupts ignore the memory policy
 * of the current process.
 *
 * Locking policy for interlave:
 * In process context there is no locking because only the process accesses
 * its own state. All vma manipulation is somewhat protected by a down_read on
 * mmap_sem.
 *
 * Freeing policy:
 * Mempolicy objects are reference counted.  A mempolicy will be freed when
 * mpol_put() decrements the reference count to zero.
 *
 * Duplicating policy objects:
 * mpol_dup() allocates a new mempolicy and copies the specified mempolicy
 * to the new storage.  The reference count of the new object is initialized
 * to 1, representing the caller of mpol_dup().
 */
struct mempolicy {
	atomic_t refcnt;
	unsigned short mode; 	/* See MPOL_* above */
	unsigned short flags;	/* See set_mempolicy() MPOL_F_* above */
	union {
		short 		 preferred_node; /* preferred */
		nodemask_t	 nodes;		/* interleave/bind */
		/* undefined for default */
	} v;
	union {
		nodemask_t cpuset_mems_allowed;	/* relative to these nodes */
		nodemask_t user_nodemask;	/* nodemask passed by user */
	} w;
};

/*
 * Support for managing mempolicy data objects (clone, copy, destroy)
 * The default fast path of a NULL MPOL_DEFAULT policy is always inlined.
 */

extern void __mpol_put(struct mempolicy *pol);
static inline void mpol_put(struct mempolicy *pol)
{
	if (pol)
		__mpol_put(pol);
}

/*
 * Does mempolicy pol need explicit unref after use?
 * Currently only needed for shared policies.
 */
static inline int mpol_needs_cond_ref(struct mempolicy *pol)
{
	return (pol && (pol->flags & MPOL_F_SHARED));
}

static inline void mpol_cond_put(struct mempolicy *pol)
{
	if (mpol_needs_cond_ref(pol))
		__mpol_put(pol);
}

extern struct mempolicy *__mpol_dup(struct mempolicy *pol);
static inline struct mempolicy *mpol_dup(struct mempolicy *pol)
{
	if (pol)
		pol = __mpol_dup(pol);
	return pol;
}

#define vma_policy(vma) ((vma)->vm_policy)

static inline void mpol_get(struct mempolicy *pol)
{
	if (pol)
		atomic_inc(&pol->refcnt);
}

extern bool __mpol_equal(struct mempolicy *a, struct mempolicy *b);
static inline bool mpol_equal(struct mempolicy *a, struct mempolicy *b)
{
	if (a == b)
		return true;
	return __mpol_equal(a, b);
}

/*
 * Tree of shared policies for a shared memory region.
 * Maintain the policies in a pseudo mm that contains vmas. The vmas
 * carry the policy. As a special twist the pseudo mm is indexed in pages, not
 * bytes, so that we can work with shared memory segments bigger than
 * unsigned long.
 */

struct sp_node {
	struct rb_node nd;
	unsigned long start, end;
	struct mempolicy *policy;
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

int vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst);
void mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol);
int mpol_set_shared_policy(struct shared_policy *info,
				struct vm_area_struct *vma,
				struct mempolicy *new);
void mpol_free_shared_policy(struct shared_policy *p);
struct mempolicy *mpol_shared_policy_lookup(struct shared_policy *sp,
					    unsigned long idx);

struct mempolicy *get_task_policy(struct task_struct *p);
struct mempolicy *__get_vma_policy(struct vm_area_struct *vma,
		unsigned long addr);
bool vma_policy_mof(struct vm_area_struct *vma);

extern void numa_default_policy(void);
extern void numa_policy_init(void);
extern void mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new,
				enum mpol_rebind_step step);
extern void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new);

extern struct zonelist *huge_zonelist(struct vm_area_struct *vma,
				unsigned long addr, gfp_t gfp_flags,
				struct mempolicy **mpol, nodemask_t **nodemask);
extern bool init_nodemask_of_mempolicy(nodemask_t *mask);
extern bool mempolicy_nodemask_intersects(struct task_struct *tsk,
				const nodemask_t *mask);
extern unsigned int mempolicy_slab_node(void);

extern enum zone_type policy_zone;

static inline void check_highest_zone(enum zone_type k)
{
	if (k > policy_zone && k != ZONE_MOVABLE)
		policy_zone = k;
}

int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,
		     const nodemask_t *to, int flags);


#ifdef CONFIG_TMPFS
extern int mpol_parse_str(char *str, struct mempolicy **mpol);
#endif

extern void mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol);

/* Check if a vma is migratable */
static inline bool vma_migratable(struct vm_area_struct *vma)
{
	if (vma->vm_flags & (VM_IO | VM_PFNMAP))
		return false;

#ifndef CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION
	if (vma->vm_flags & VM_HUGETLB)
		return false;
#endif

	/*
	 * Migration allocates pages in the highest zone. If we cannot
	 * do so then migration (at least from node to node) is not
	 * possible.
	 */
	if (vma->vm_file &&
		gfp_zone(mapping_gfp_mask(vma->vm_file->f_mapping))
								< policy_zone)
			return false;
	return true;
}

extern int mpol_misplaced(struct page *, struct vm_area_struct *, unsigned long);
extern void mpol_put_task_policy(struct task_struct *);

#else

struct mempolicy {};

static inline bool mpol_equal(struct mempolicy *a, struct mempolicy *b)
{
	return true;
}

static inline void mpol_put(struct mempolicy *p)
{
}

static inline void mpol_cond_put(struct mempolicy *pol)
{
}

static inline void mpol_get(struct mempolicy *pol)
{
}

struct shared_policy {};

static inline void mpol_shared_policy_init(struct shared_policy *sp,
						struct mempolicy *mpol)
{
}

static inline void mpol_free_shared_policy(struct shared_policy *p)
{
}

static inline struct mempolicy *
mpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)
{
	return NULL;
}

#define vma_policy(vma) NULL

static inline int
vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)
{
	return 0;
}

static inline void numa_policy_init(void)
{
}

static inline void numa_default_policy(void)
{
}

static inline void mpol_rebind_task(struct task_struct *tsk,
				const nodemask_t *new,
				enum mpol_rebind_step step)
{
}

static inline void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)
{
}

static inline struct zonelist *huge_zonelist(struct vm_area_struct *vma,
				unsigned long addr, gfp_t gfp_flags,
				struct mempolicy **mpol, nodemask_t **nodemask)
{
	*mpol = NULL;
	*nodemask = NULL;
	return node_zonelist(0, gfp_flags);
}

static inline bool init_nodemask_of_mempolicy(nodemask_t *m)
{
	return false;
}

static inline int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,
				   const nodemask_t *to, int flags)
{
	return 0;
}

static inline void check_highest_zone(int k)
{
}

#ifdef CONFIG_TMPFS
static inline int mpol_parse_str(char *str, struct mempolicy **mpol)
{
	return 1;	/* error */
}
#endif

static inline int mpol_misplaced(struct page *page, struct vm_area_struct *vma,
				 unsigned long address)
{
	return -1; /* no node preference */
}

static inline void mpol_put_task_policy(struct task_struct *task)
{
}
#endif /* CONFIG_NUMA */
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * include/linux/buffer_head.h
 *
 * Everything to do with buffer_heads.
 */

#ifndef _LINUX_BUFFER_HEAD_H
#define _LINUX_BUFFER_HEAD_H

#include <linux/types.h>
#include <linux/fs.h>
#include <linux/linkage.h>
#include <linux/pagemap.h>
#include <linux/wait.h>
#include <linux/atomic.h>

#ifdef CONFIG_BLOCK

enum bh_state_bits {
	BH_Uptodate,	/* Contains valid data */
	BH_Dirty,	/* Is dirty */
	BH_Lock,	/* Is locked */
	BH_Req,		/* Has been submitted for I/O */
	BH_Uptodate_Lock,/* Used by the first bh in a page, to serialise
			  * IO completion of other buffers in the page
			  */

	BH_Mapped,	/* Has a disk mapping */
	BH_New,		/* Disk mapping was newly created by get_block */
	BH_Async_Read,	/* Is under end_buffer_async_read I/O */
	BH_Async_Write,	/* Is under end_buffer_async_write I/O */
	BH_Delay,	/* Buffer is not yet allocated on disk */
	BH_Boundary,	/* Block is followed by a discontiguity */
	BH_Write_EIO,	/* I/O error on write */
	BH_Unwritten,	/* Buffer is allocated on disk but not written */
	BH_Quiet,	/* Buffer Error Prinks to be quiet */
	BH_Meta,	/* Buffer contains metadata */
	BH_Prio,	/* Buffer should be submitted with REQ_PRIO */
	BH_Defer_Completion, /* Defer AIO completion to workqueue */

	BH_PrivateStart,/* not a state bit, but the first bit available
			 * for private allocation by other entities
			 */
};

#define MAX_BUF_PER_PAGE (PAGE_SIZE / 512)

struct page;
struct buffer_head;
struct address_space;
typedef void (bh_end_io_t)(struct buffer_head *bh, int uptodate);

/*
 * Historically, a buffer_head was used to map a single block
 * within a page, and of course as the unit of I/O through the
 * filesystem and block layers.  Nowadays the basic I/O unit
 * is the bio, and buffer_heads are used for extracting block
 * mappings (via a get_block_t call), for tracking state within
 * a page (via a page_mapping) and for wrapping bio submission
 * for backward compatibility reasons (e.g. submit_bh).
 */
struct buffer_head {
	unsigned long b_state;		/* buffer state bitmap (see above) */
	struct buffer_head *b_this_page;/* circular list of page's buffers */
	struct page *b_page;		/* the page this bh is mapped to */

	sector_t b_blocknr;		/* start block number */
	size_t b_size;			/* size of mapping */
	char *b_data;			/* pointer to data within the page */

	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;		/* I/O completion */
 	void *b_private;		/* reserved for b_end_io */
	struct list_head b_assoc_buffers; /* associated with another mapping */
	struct address_space *b_assoc_map;	/* mapping this buffer is
						   associated with */
	atomic_t b_count;		/* users using this buffer_head */
};

/*
 * macro tricks to expand the set_buffer_foo(), clear_buffer_foo()
 * and buffer_foo() functions.
 */
#define BUFFER_FNS(bit, name)						\
static __always_inline void set_buffer_##name(struct buffer_head *bh)	\
{									\
	set_bit(BH_##bit, &(bh)->b_state);				\
}									\
static __always_inline void clear_buffer_##name(struct buffer_head *bh)	\
{									\
	clear_bit(BH_##bit, &(bh)->b_state);				\
}									\
static __always_inline int buffer_##name(const struct buffer_head *bh)	\
{									\
	return test_bit(BH_##bit, &(bh)->b_state);			\
}

/*
 * test_set_buffer_foo() and test_clear_buffer_foo()
 */
#define TAS_BUFFER_FNS(bit, name)					\
static __always_inline int test_set_buffer_##name(struct buffer_head *bh) \
{									\
	return test_and_set_bit(BH_##bit, &(bh)->b_state);		\
}									\
static __always_inline int test_clear_buffer_##name(struct buffer_head *bh) \
{									\
	return test_and_clear_bit(BH_##bit, &(bh)->b_state);		\
}									\

/*
 * Emit the buffer bitops functions.   Note that there are also functions
 * of the form "mark_buffer_foo()".  These are higher-level functions which
 * do something in addition to setting a b_state bit.
 */
BUFFER_FNS(Uptodate, uptodate)
BUFFER_FNS(Dirty, dirty)
TAS_BUFFER_FNS(Dirty, dirty)
BUFFER_FNS(Lock, locked)
BUFFER_FNS(Req, req)
TAS_BUFFER_FNS(Req, req)
BUFFER_FNS(Mapped, mapped)
BUFFER_FNS(New, new)
BUFFER_FNS(Async_Read, async_read)
BUFFER_FNS(Async_Write, async_write)
BUFFER_FNS(Delay, delay)
BUFFER_FNS(Boundary, boundary)
BUFFER_FNS(Write_EIO, write_io_error)
BUFFER_FNS(Unwritten, unwritten)
BUFFER_FNS(Meta, meta)
BUFFER_FNS(Prio, prio)
BUFFER_FNS(Defer_Completion, defer_completion)

#define bh_offset(bh)		((unsigned long)(bh)->b_data & ~PAGE_MASK)

/* If we *know* page->private refers to buffer_heads */
#define page_buffers(page)					\
	({							\
		BUG_ON(!PagePrivate(page));			\
		((struct buffer_head *)page_private(page));	\
	})
#define page_has_buffers(page)	PagePrivate(page)

void buffer_check_dirty_writeback(struct page *page,
				     bool *dirty, bool *writeback);

/*
 * Declarations
 */

void mark_buffer_dirty(struct buffer_head *bh);
void init_buffer(struct buffer_head *, bh_end_io_t *, void *);
void touch_buffer(struct buffer_head *bh);
void set_bh_page(struct buffer_head *bh,
		struct page *page, unsigned long offset);
int try_to_free_buffers(struct page *);
struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,
		int retry);
void create_empty_buffers(struct page *, unsigned long,
			unsigned long b_state);
void end_buffer_read_sync(struct buffer_head *bh, int uptodate);
void end_buffer_write_sync(struct buffer_head *bh, int uptodate);
void end_buffer_async_write(struct buffer_head *bh, int uptodate);

/* Things to do with buffers at mapping->private_list */
void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode);
int inode_has_buffers(struct inode *);
void invalidate_inode_buffers(struct inode *);
int remove_inode_buffers(struct inode *inode);
int sync_mapping_buffers(struct address_space *mapping);
void unmap_underlying_metadata(struct block_device *bdev, sector_t block);

void mark_buffer_async_write(struct buffer_head *bh);
void __wait_on_buffer(struct buffer_head *);
wait_queue_head_t *bh_waitq_head(struct buffer_head *bh);
struct buffer_head *__find_get_block(struct block_device *bdev, sector_t block,
			unsigned size);
struct buffer_head *__getblk_gfp(struct block_device *bdev, sector_t block,
				  unsigned size, gfp_t gfp);
void __brelse(struct buffer_head *);
void __bforget(struct buffer_head *);
void __breadahead(struct block_device *, sector_t block, unsigned int size);
struct buffer_head *__bread_gfp(struct block_device *,
				sector_t block, unsigned size, gfp_t gfp);
void invalidate_bh_lrus(void);
struct buffer_head *alloc_buffer_head(gfp_t gfp_flags);
void free_buffer_head(struct buffer_head * bh);
void unlock_buffer(struct buffer_head *bh);
void __lock_buffer(struct buffer_head *bh);
void ll_rw_block(int, int, int, struct buffer_head * bh[]);
int sync_dirty_buffer(struct buffer_head *bh);
int __sync_dirty_buffer(struct buffer_head *bh, int op_flags);
void write_dirty_buffer(struct buffer_head *bh, int op_flags);
int _submit_bh(int op, int op_flags, struct buffer_head *bh,
	       unsigned long bio_flags);
int submit_bh(int, int, struct buffer_head *);
void write_boundary_block(struct block_device *bdev,
			sector_t bblock, unsigned blocksize);
int bh_uptodate_or_lock(struct buffer_head *bh);
int bh_submit_read(struct buffer_head *bh);

extern int buffer_heads_over_limit;

/*
 * Generic address_space_operations implementations for buffer_head-backed
 * address_spaces.
 */
void block_invalidatepage(struct page *page, unsigned int offset,
			  unsigned int length);
int block_write_full_page(struct page *page, get_block_t *get_block,
				struct writeback_control *wbc);
int __block_write_full_page(struct inode *inode, struct page *page,
			get_block_t *get_block, struct writeback_control *wbc,
			bh_end_io_t *handler);
int block_read_full_page(struct page*, get_block_t*);
int block_is_partially_uptodate(struct page *page, unsigned long from,
				unsigned long count);
int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,
		unsigned flags, struct page **pagep, get_block_t *get_block);
int __block_write_begin(struct page *page, loff_t pos, unsigned len,
		get_block_t *get_block);
int block_write_end(struct file *, struct address_space *,
				loff_t, unsigned, unsigned,
				struct page *, void *);
int generic_write_end(struct file *, struct address_space *,
				loff_t, unsigned, unsigned,
				struct page *, void *);
void page_zero_new_buffers(struct page *page, unsigned from, unsigned to);
void clean_page_buffers(struct page *page);
int cont_write_begin(struct file *, struct address_space *, loff_t,
			unsigned, unsigned, struct page **, void **,
			get_block_t *, loff_t *);
int generic_cont_expand_simple(struct inode *inode, loff_t size);
int block_commit_write(struct page *page, unsigned from, unsigned to);
int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
				get_block_t get_block);
/* Convert errno to return value from ->page_mkwrite() call */
static inline int block_page_mkwrite_return(int err)
{
	if (err == 0)
		return VM_FAULT_LOCKED;
	if (err == -EFAULT || err == -EAGAIN)
		return VM_FAULT_NOPAGE;
	if (err == -ENOMEM)
		return VM_FAULT_OOM;
	/* -ENOSPC, -EDQUOT, -EIO ... */
	return VM_FAULT_SIGBUS;
}
sector_t generic_block_bmap(struct address_space *, sector_t, get_block_t *);
int block_truncate_page(struct address_space *, loff_t, get_block_t *);
int nobh_write_begin(struct address_space *, loff_t, unsigned, unsigned,
				struct page **, void **, get_block_t*);
int nobh_write_end(struct file *, struct address_space *,
				loff_t, unsigned, unsigned,
				struct page *, void *);
int nobh_truncate_page(struct address_space *, loff_t, get_block_t *);
int nobh_writepage(struct page *page, get_block_t *get_block,
                        struct writeback_control *wbc);

void buffer_init(void);

/*
 * inline definitions
 */

static inline void attach_page_buffers(struct page *page,
		struct buffer_head *head)
{
	get_page(page);
	SetPagePrivate(page);
	set_page_private(page, (unsigned long)head);
}

static inline void get_bh(struct buffer_head *bh)
{
        atomic_inc(&bh->b_count);
}

static inline void put_bh(struct buffer_head *bh)
{
        smp_mb__before_atomic();
        atomic_dec(&bh->b_count);
}

static inline void brelse(struct buffer_head *bh)
{
	if (bh)
		__brelse(bh);
}

static inline void bforget(struct buffer_head *bh)
{
	if (bh)
		__bforget(bh);
}

static inline struct buffer_head *
sb_bread(struct super_block *sb, sector_t block)
{
	return __bread_gfp(sb->s_bdev, block, sb->s_blocksize, __GFP_MOVABLE);
}

static inline struct buffer_head *
sb_bread_unmovable(struct super_block *sb, sector_t block)
{
	return __bread_gfp(sb->s_bdev, block, sb->s_blocksize, 0);
}

static inline void
sb_breadahead(struct super_block *sb, sector_t block)
{
	__breadahead(sb->s_bdev, block, sb->s_blocksize);
}

static inline struct buffer_head *
sb_getblk(struct super_block *sb, sector_t block)
{
	return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, __GFP_MOVABLE);
}


static inline struct buffer_head *
sb_getblk_gfp(struct super_block *sb, sector_t block, gfp_t gfp)
{
	return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);
}

static inline struct buffer_head *
sb_find_get_block(struct super_block *sb, sector_t block)
{
	return __find_get_block(sb->s_bdev, block, sb->s_blocksize);
}

static inline void
map_bh(struct buffer_head *bh, struct super_block *sb, sector_t block)
{
	set_buffer_mapped(bh);
	bh->b_bdev = sb->s_bdev;
	bh->b_blocknr = block;
	bh->b_size = sb->s_blocksize;
}

static inline void wait_on_buffer(struct buffer_head *bh)
{
	might_sleep();
	if (buffer_locked(bh))
		__wait_on_buffer(bh);
}

static inline int trylock_buffer(struct buffer_head *bh)
{
	return likely(!test_and_set_bit_lock(BH_Lock, &bh->b_state));
}

static inline void lock_buffer(struct buffer_head *bh)
{
	might_sleep();
	if (!trylock_buffer(bh))
		__lock_buffer(bh);
}

static inline struct buffer_head *getblk_unmovable(struct block_device *bdev,
						   sector_t block,
						   unsigned size)
{
	return __getblk_gfp(bdev, block, size, 0);
}

static inline struct buffer_head *__getblk(struct block_device *bdev,
					   sector_t block,
					   unsigned size)
{
	return __getblk_gfp(bdev, block, size, __GFP_MOVABLE);
}

/**
 *  __bread() - reads a specified block and returns the bh
 *  @bdev: the block_device to read from
 *  @block: number of block
 *  @size: size (in bytes) to read
 *
 *  Reads a specified block, and returns buffer head that contains it.
 *  The page cache is allocated from movable area so that it can be migrated.
 *  It returns NULL if the block was unreadable.
 */
static inline struct buffer_head *
__bread(struct block_device *bdev, sector_t block, unsigned size)
{
	return __bread_gfp(bdev, block, size, __GFP_MOVABLE);
}

extern int __set_page_dirty_buffers(struct page *page);

#else /* CONFIG_BLOCK */

static inline void buffer_init(void) {}
static inline int try_to_free_buffers(struct page *page) { return 1; }
static inline int inode_has_buffers(struct inode *inode) { return 0; }
static inline void invalidate_inode_buffers(struct inode *inode) {}
static inline int remove_inode_buffers(struct inode *inode) { return 1; }
static inline int sync_mapping_buffers(struct address_space *mapping) { return 0; }

#endif /* CONFIG_BLOCK */
#endif /* _LINUX_BUFFER_HEAD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * ks8842.h KS8842 platform data struct definition
 * Copyright (c) 2010 Intel Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef _LINUX_KS8842_H
#define _LINUX_KS8842_H

#include <linux/if_ether.h>

/**
 * struct ks8842_platform_data - Platform data of the KS8842 network driver
 * @macaddr:	The MAC address of the device, set to all 0:s to use the on in
 *		the chip.
 * @rx_dma_channel:	The DMA channel to use for RX, -1 for none.
 * @tx_dma_channel:	The DMA channel to use for TX, -1 for none.
 *
 */
struct ks8842_platform_data {
	u8 macaddr[ETH_ALEN];
	int rx_dma_channel;
	int tx_dma_channel;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _IF_TUNNEL_H_
#define _IF_TUNNEL_H_

#include <linux/ip.h>
#include <linux/in6.h>
#include <uapi/linux/if_tunnel.h>
#include <linux/u64_stats_sync.h>

/*
 * Locking : hash tables are protected by RCU and RTNL
 */

#define for_each_ip_tunnel_rcu(pos, start) \
	for (pos = rcu_dereference(start); pos; pos = rcu_dereference(pos->next))

#endif /* _IF_TUNNEL_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * include/linux/serial.h
 *
 * Copyright (C) 1992 by Theodore Ts'o.
 * 
 * Redistribution of this file is permitted under the terms of the GNU 
 * Public License (GPL)
 */
#ifndef _LINUX_SERIAL_H
#define _LINUX_SERIAL_H

#include <asm/page.h>
#include <uapi/linux/serial.h>


/*
 * Counters of the input lines (CTS, DSR, RI, CD) interrupts
 */

struct async_icount {
	__u32	cts, dsr, rng, dcd, tx, rx;
	__u32	frame, parity, overrun, brk;
	__u32	buf_overrun;
};

/*
 * The size of the serial xmit buffer is 1 page, or 4096 bytes
 */
#define SERIAL_XMIT_SIZE PAGE_SIZE

#include <linux/compiler.h>

#endif /* _LINUX_SERIAL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef GENL_MAGIC_FUNC_H
#define GENL_MAGIC_FUNC_H

#include <linux/genl_magic_struct.h>

/*
 * Magic: declare tla policy						{{{1
 * Magic: declare nested policies
 *									{{{2
 */
#undef GENL_mc_group
#define GENL_mc_group(group)

#undef GENL_notification
#define GENL_notification(op_name, op_num, mcast_group, tla_list)

#undef GENL_op
#define GENL_op(op_name, op_num, handler, tla_list)

#undef GENL_struct
#define GENL_struct(tag_name, tag_number, s_name, s_fields)		\
	[tag_name] = { .type = NLA_NESTED },

static struct nla_policy CONCAT_(GENL_MAGIC_FAMILY, _tla_nl_policy)[] = {
#include GENL_MAGIC_INCLUDE_FILE
};

#undef GENL_struct
#define GENL_struct(tag_name, tag_number, s_name, s_fields)		\
static struct nla_policy s_name ## _nl_policy[] __read_mostly =		\
{ s_fields };

#undef __field
#define __field(attr_nr, attr_flag, name, nla_type, _type, __get,	\
		 __put, __is_signed)					\
	[attr_nr] = { .type = nla_type },

#undef __array
#define __array(attr_nr, attr_flag, name, nla_type, _type, maxlen,	\
		__get, __put, __is_signed)				\
	[attr_nr] = { .type = nla_type,					\
		      .len = maxlen - (nla_type == NLA_NUL_STRING) },

#include GENL_MAGIC_INCLUDE_FILE

#ifndef __KERNEL__
#ifndef pr_info
#define pr_info(args...)	fprintf(stderr, args);
#endif
#endif

#ifdef GENL_MAGIC_DEBUG
static void dprint_field(const char *dir, int nla_type,
		const char *name, void *valp)
{
	__u64 val = valp ? *(__u32 *)valp : 1;
	switch (nla_type) {
	case NLA_U8:  val = (__u8)val;
	case NLA_U16: val = (__u16)val;
	case NLA_U32: val = (__u32)val;
		pr_info("%s attr %s: %d 0x%08x\n", dir,
			name, (int)val, (unsigned)val);
		break;
	case NLA_U64:
		val = *(__u64*)valp;
		pr_info("%s attr %s: %lld 0x%08llx\n", dir,
			name, (long long)val, (unsigned long long)val);
		break;
	case NLA_FLAG:
		if (val)
			pr_info("%s attr %s: set\n", dir, name);
		break;
	}
}

static void dprint_array(const char *dir, int nla_type,
		const char *name, const char *val, unsigned len)
{
	switch (nla_type) {
	case NLA_NUL_STRING:
		if (len && val[len-1] == '\0')
			len--;
		pr_info("%s attr %s: [len:%u] '%s'\n", dir, name, len, val);
		break;
	default:
		/* we can always show 4 byte,
		 * thats what nlattr are aligned to. */
		pr_info("%s attr %s: [len:%u] %02x%02x%02x%02x ...\n",
			dir, name, len, val[0], val[1], val[2], val[3]);
	}
}

#define DPRINT_TLA(a, op, b) pr_info("%s %s %s\n", a, op, b);

/* Name is a member field name of the struct s.
 * If s is NULL (only parsing, no copy requested in *_from_attrs()),
 * nla is supposed to point to the attribute containing the information
 * corresponding to that struct member. */
#define DPRINT_FIELD(dir, nla_type, name, s, nla)			\
	do {								\
		if (s)							\
			dprint_field(dir, nla_type, #name, &s->name);	\
		else if (nla)						\
			dprint_field(dir, nla_type, #name,		\
				(nla_type == NLA_FLAG) ? NULL		\
						: nla_data(nla));	\
	} while (0)

#define	DPRINT_ARRAY(dir, nla_type, name, s, nla)			\
	do {								\
		if (s)							\
			dprint_array(dir, nla_type, #name,		\
					s->name, s->name ## _len);	\
		else if (nla)						\
			dprint_array(dir, nla_type, #name,		\
					nla_data(nla), nla_len(nla));	\
	} while (0)
#else
#define DPRINT_TLA(a, op, b) do {} while (0)
#define DPRINT_FIELD(dir, nla_type, name, s, nla) do {} while (0)
#define	DPRINT_ARRAY(dir, nla_type, name, s, nla) do {} while (0)
#endif

/*
 * Magic: provide conversion functions					{{{1
 * populate struct from attribute table:
 *									{{{2
 */

/* processing of generic netlink messages is serialized.
 * use one static buffer for parsing of nested attributes */
static struct nlattr *nested_attr_tb[128];

#ifndef BUILD_BUG_ON
/* Force a compilation error if condition is true */
#define BUILD_BUG_ON(condition) ((void)BUILD_BUG_ON_ZERO(condition))
/* Force a compilation error if condition is true, but also produce a
   result (of value 0 and type size_t), so the expression can be used
   e.g. in a structure initializer (or where-ever else comma expressions
   aren't permitted). */
#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
#endif

#undef GENL_struct
#define GENL_struct(tag_name, tag_number, s_name, s_fields)		\
/* *_from_attrs functions are static, but potentially unused */		\
static int __ ## s_name ## _from_attrs(struct s_name *s,		\
		struct genl_info *info, bool exclude_invariants)	\
{									\
	const int maxtype = ARRAY_SIZE(s_name ## _nl_policy)-1;		\
	struct nlattr *tla = info->attrs[tag_number];			\
	struct nlattr **ntb = nested_attr_tb;				\
	struct nlattr *nla;						\
	int err;							\
	BUILD_BUG_ON(ARRAY_SIZE(s_name ## _nl_policy) > ARRAY_SIZE(nested_attr_tb));	\
	if (!tla)							\
		return -ENOMSG;						\
	DPRINT_TLA(#s_name, "<=-", #tag_name);				\
	err = drbd_nla_parse_nested(ntb, maxtype, tla, s_name ## _nl_policy);	\
	if (err)							\
		return err;						\
									\
	s_fields							\
	return 0;							\
}					__attribute__((unused))		\
static int s_name ## _from_attrs(struct s_name *s,			\
						struct genl_info *info)	\
{									\
	return __ ## s_name ## _from_attrs(s, info, false);		\
}					__attribute__((unused))		\
static int s_name ## _from_attrs_for_change(struct s_name *s,		\
						struct genl_info *info)	\
{									\
	return __ ## s_name ## _from_attrs(s, info, true);		\
}					__attribute__((unused))		\

#define __assign(attr_nr, attr_flag, name, nla_type, type, assignment...)	\
		nla = ntb[attr_nr];						\
		if (nla) {						\
			if (exclude_invariants && !!((attr_flag) & DRBD_F_INVARIANT)) {		\
				pr_info("<< must not change invariant attr: %s\n", #name);	\
				return -EEXIST;				\
			}						\
			assignment;					\
		} else if (exclude_invariants && !!((attr_flag) & DRBD_F_INVARIANT)) {		\
			/* attribute missing from payload, */		\
			/* which was expected */			\
		} else if ((attr_flag) & DRBD_F_REQUIRED) {		\
			pr_info("<< missing attr: %s\n", #name);	\
			return -ENOMSG;					\
		}

#undef __field
#define __field(attr_nr, attr_flag, name, nla_type, type, __get, __put,	\
		__is_signed)						\
	__assign(attr_nr, attr_flag, name, nla_type, type,		\
			if (s)						\
				s->name = __get(nla);			\
			DPRINT_FIELD("<<", nla_type, name, s, nla))

/* validate_nla() already checked nla_len <= maxlen appropriately. */
#undef __array
#define __array(attr_nr, attr_flag, name, nla_type, type, maxlen,	\
		__get, __put, __is_signed)				\
	__assign(attr_nr, attr_flag, name, nla_type, type,		\
			if (s)						\
				s->name ## _len =			\
					__get(s->name, nla, maxlen);	\
			DPRINT_ARRAY("<<", nla_type, name, s, nla))

#include GENL_MAGIC_INCLUDE_FILE

#undef GENL_struct
#define GENL_struct(tag_name, tag_number, s_name, s_fields)

/*
 * Magic: define op number to op name mapping				{{{1
 *									{{{2
 */
const char *CONCAT_(GENL_MAGIC_FAMILY, _genl_cmd_to_str)(__u8 cmd)
{
	switch (cmd) {
#undef GENL_op
#define GENL_op(op_name, op_num, handler, tla_list)		\
	case op_num: return #op_name;
#include GENL_MAGIC_INCLUDE_FILE
	default:
		     return "unknown";
	}
}

#ifdef __KERNEL__
#include <linux/stringify.h>
/*
 * Magic: define genl_ops						{{{1
 *									{{{2
 */

#undef GENL_op
#define GENL_op(op_name, op_num, handler, tla_list)		\
{								\
	handler							\
	.cmd = op_name,						\
	.policy	= CONCAT_(GENL_MAGIC_FAMILY, _tla_nl_policy),	\
},

#define ZZZ_genl_ops		CONCAT_(GENL_MAGIC_FAMILY, _genl_ops)
static struct genl_ops ZZZ_genl_ops[] __read_mostly = {
#include GENL_MAGIC_INCLUDE_FILE
};

#undef GENL_op
#define GENL_op(op_name, op_num, handler, tla_list)

/*
 * Define the genl_family, multicast groups,				{{{1
 * and provide register/unregister functions.
 *									{{{2
 */
#define ZZZ_genl_family		CONCAT_(GENL_MAGIC_FAMILY, _genl_family)
static struct genl_family ZZZ_genl_family __read_mostly = {
	.id = GENL_ID_GENERATE,
	.name = __stringify(GENL_MAGIC_FAMILY),
	.version = GENL_MAGIC_VERSION,
#ifdef GENL_MAGIC_FAMILY_HDRSZ
	.hdrsize = NLA_ALIGN(GENL_MAGIC_FAMILY_HDRSZ),
#endif
	.maxattr = ARRAY_SIZE(drbd_tla_nl_policy)-1,
};

/*
 * Magic: define multicast groups
 * Magic: define multicast group registration helper
 */
#define ZZZ_genl_mcgrps		CONCAT_(GENL_MAGIC_FAMILY, _genl_mcgrps)
static const struct genl_multicast_group ZZZ_genl_mcgrps[] = {
#undef GENL_mc_group
#define GENL_mc_group(group) { .name = #group, },
#include GENL_MAGIC_INCLUDE_FILE
};

enum CONCAT_(GENL_MAGIC_FAMILY, group_ids) {
#undef GENL_mc_group
#define GENL_mc_group(group) CONCAT_(GENL_MAGIC_FAMILY, _group_ ## group),
#include GENL_MAGIC_INCLUDE_FILE
};

#undef GENL_mc_group
#define GENL_mc_group(group)						\
static int CONCAT_(GENL_MAGIC_FAMILY, _genl_multicast_ ## group)(	\
	struct sk_buff *skb, gfp_t flags)				\
{									\
	unsigned int group_id =						\
		CONCAT_(GENL_MAGIC_FAMILY, _group_ ## group);		\
	return genlmsg_multicast(&ZZZ_genl_family, skb, 0,		\
				 group_id, flags);			\
}

#include GENL_MAGIC_INCLUDE_FILE

#undef GENL_mc_group
#define GENL_mc_group(group)

int CONCAT_(GENL_MAGIC_FAMILY, _genl_register)(void)
{
	return genl_register_family_with_ops_groups(&ZZZ_genl_family,	\
						    ZZZ_genl_ops,	\
						    ZZZ_genl_mcgrps);
}

void CONCAT_(GENL_MAGIC_FAMILY, _genl_unregister)(void)
{
	genl_unregister_family(&ZZZ_genl_family);
}

/*
 * Magic: provide conversion functions					{{{1
 * populate skb from struct.
 *									{{{2
 */

#undef GENL_op
#define GENL_op(op_name, op_num, handler, tla_list)

#undef GENL_struct
#define GENL_struct(tag_name, tag_number, s_name, s_fields)		\
static int s_name ## _to_skb(struct sk_buff *skb, struct s_name *s,	\
		const bool exclude_sensitive)				\
{									\
	struct nlattr *tla = nla_nest_start(skb, tag_number);		\
	if (!tla)							\
		goto nla_put_failure;					\
	DPRINT_TLA(#s_name, "-=>", #tag_name);				\
	s_fields							\
	nla_nest_end(skb, tla);						\
	return 0;							\
									\
nla_put_failure:							\
	if (tla)							\
		nla_nest_cancel(skb, tla);				\
        return -EMSGSIZE;						\
}									\
static inline int s_name ## _to_priv_skb(struct sk_buff *skb,		\
		struct s_name *s)					\
{									\
	return s_name ## _to_skb(skb, s, 0);				\
}									\
static inline int s_name ## _to_unpriv_skb(struct sk_buff *skb,		\
		struct s_name *s)					\
{									\
	return s_name ## _to_skb(skb, s, 1);				\
}


#undef __field
#define __field(attr_nr, attr_flag, name, nla_type, type, __get, __put,	\
		__is_signed)						\
	if (!exclude_sensitive || !((attr_flag) & DRBD_F_SENSITIVE)) {	\
		DPRINT_FIELD(">>", nla_type, name, s, NULL);		\
		if (__put(skb, attr_nr, s->name))			\
			goto nla_put_failure;				\
	}

#undef __array
#define __array(attr_nr, attr_flag, name, nla_type, type, maxlen,	\
		__get, __put, __is_signed)				\
	if (!exclude_sensitive || !((attr_flag) & DRBD_F_SENSITIVE)) {	\
		DPRINT_ARRAY(">>",nla_type, name, s, NULL);		\
		if (__put(skb, attr_nr, min_t(int, maxlen,		\
			s->name ## _len + (nla_type == NLA_NUL_STRING)),\
						s->name))		\
			goto nla_put_failure;				\
	}

#include GENL_MAGIC_INCLUDE_FILE


/* Functions for initializing structs to default values.  */

#undef __field
#define __field(attr_nr, attr_flag, name, nla_type, type, __get, __put,	\
		__is_signed)
#undef __array
#define __array(attr_nr, attr_flag, name, nla_type, type, maxlen,	\
		__get, __put, __is_signed)
#undef __u32_field_def
#define __u32_field_def(attr_nr, attr_flag, name, default)		\
	x->name = default;
#undef __s32_field_def
#define __s32_field_def(attr_nr, attr_flag, name, default)		\
	x->name = default;
#undef __flg_field_def
#define __flg_field_def(attr_nr, attr_flag, name, default)		\
	x->name = default;
#undef __str_field_def
#define __str_field_def(attr_nr, attr_flag, name, maxlen)		\
	memset(x->name, 0, sizeof(x->name));				\
	x->name ## _len = 0;
#undef GENL_struct
#define GENL_struct(tag_name, tag_number, s_name, s_fields)		\
static void set_ ## s_name ## _defaults(struct s_name *x) __attribute__((unused)); \
static void set_ ## s_name ## _defaults(struct s_name *x) {	\
s_fields								\
}

#include GENL_MAGIC_INCLUDE_FILE

#endif /* __KERNEL__ */

/* }}}1 */
#endif /* GENL_MAGIC_FUNC_H */
/* vim: set foldmethod=marker foldlevel=1 nofoldenable : */
                                                                                         /*
 * include/linux/sync_file.h
 *
 * Copyright (C) 2012 Google, Inc.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#ifndef _LINUX_SYNC_FILE_H
#define _LINUX_SYNC_FILE_H

#include <linux/types.h>
#include <linux/kref.h>
#include <linux/ktime.h>
#include <linux/list.h>
#include <linux/spinlock.h>
#include <linux/fence.h>
#include <linux/fence-array.h>

/**
 * struct sync_file - sync file to export to the userspace
 * @file:		file representing this fence
 * @kref:		reference count on fence.
 * @name:		name of sync_file.  Useful for debugging
 * @sync_file_list:	membership in global file list
 * @wq:			wait queue for fence signaling
 * @fence:		fence with the fences in the sync_file
 * @cb:			fence callback information
 */
struct sync_file {
	struct file		*file;
	struct kref		kref;
	char			name[32];
#ifdef CONFIG_DEBUG_FS
	struct list_head	sync_file_list;
#endif

	wait_queue_head_t	wq;

	struct fence		*fence;
	struct fence_cb cb;
};

#define POLL_ENABLED FENCE_FLAG_USER_BITS

struct sync_file *sync_file_create(struct fence *fence);
struct fence *sync_file_get_fence(int fd);

#endif /* _LINUX_SYNC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * zpool memory storage api
 *
 * Copyright (C) 2014 Dan Streetman
 *
 * This is a common frontend for the zbud and zsmalloc memory
 * storage pool implementations.  Typically, this is used to
 * store compressed memory.
 */

#ifndef _ZPOOL_H_
#define _ZPOOL_H_

struct zpool;

struct zpool_ops {
	int (*evict)(struct zpool *pool, unsigned long handle);
};

/*
 * Control how a handle is mapped.  It will be ignored if the
 * implementation does not support it.  Its use is optional.
 * Note that this does not refer to memory protection, it
 * refers to how the memory will be copied in/out if copying
 * is necessary during mapping; read-write is the safest as
 * it copies the existing memory in on map, and copies the
 * changed memory back out on unmap.  Write-only does not copy
 * in the memory and should only be used for initialization.
 * If in doubt, use ZPOOL_MM_DEFAULT which is read-write.
 */
enum zpool_mapmode {
	ZPOOL_MM_RW, /* normal read-write mapping */
	ZPOOL_MM_RO, /* read-only (no copy-out at unmap time) */
	ZPOOL_MM_WO, /* write-only (no copy-in at map time) */

	ZPOOL_MM_DEFAULT = ZPOOL_MM_RW
};

bool zpool_has_pool(char *type);

struct zpool *zpool_create_pool(const char *type, const char *name,
			gfp_t gfp, const struct zpool_ops *ops);

const char *zpool_get_type(struct zpool *pool);

void zpool_destroy_pool(struct zpool *pool);

int zpool_malloc(struct zpool *pool, size_t size, gfp_t gfp,
			unsigned long *handle);

void zpool_free(struct zpool *pool, unsigned long handle);

int zpool_shrink(struct zpool *pool, unsigned int pages,
			unsigned int *reclaimed);

void *zpool_map_handle(struct zpool *pool, unsigned long handle,
			enum zpool_mapmode mm);

void zpool_unmap_handle(struct zpool *pool, unsigned long handle);

u64 zpool_get_total_size(struct zpool *pool);


/**
 * struct zpool_driver - driver implementation for zpool
 * @type:	name of the driver.
 * @list:	entry in the list of zpool drivers.
 * @create:	create a new pool.
 * @destroy:	destroy a pool.
 * @malloc:	allocate mem from a pool.
 * @free:	free mem from a pool.
 * @shrink:	shrink the pool.
 * @map:	map a handle.
 * @unmap:	unmap a handle.
 * @total_size:	get total size of a pool.
 *
 * This is created by a zpool implementation and registered
 * with zpool.
 */
struct zpool_driver {
	char *type;
	struct module *owner;
	atomic_t refcount;
	struct list_head list;

	void *(*create)(const char *name,
			gfp_t gfp,
			const struct zpool_ops *ops,
			struct zpool *zpool);
	void (*destroy)(void *pool);

	int (*malloc)(void *pool, size_t size, gfp_t gfp,
				unsigned long *handle);
	void (*free)(void *pool, unsigned long handle);

	int (*shrink)(void *pool, unsigned int pages,
				unsigned int *reclaimed);

	void *(*map)(void *pool, unsigned long handle,
				enum zpool_mapmode mm);
	void (*unmap)(void *pool, unsigned long handle);

	u64 (*total_size)(void *pool);
};

void zpool_register_driver(struct zpool_driver *driver);

int zpool_unregister_driver(struct zpool_driver *driver);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *  User-space visible declarations for NFS client per-mount
 *  point statistics
 *
 *  Copyright (C) 2005, 2006 Chuck Lever <cel@netapp.com>
 *
 *  NFS client per-mount statistics provide information about the
 *  health of the NFS client and the health of each NFS mount point.
 *  Generally these are not for detailed problem diagnosis, but
 *  simply to indicate that there is a problem.
 *
 *  These counters are not meant to be human-readable, but are meant
 *  to be integrated into system monitoring tools such as "sar" and
 *  "iostat".  As such, the counters are sampled by the tools over
 *  time, and are never zeroed after a file system is mounted.
 *  Moving averages can be computed by the tools by taking the
 *  difference between two instantaneous samples  and dividing that
 *  by the time between the samples.
 */

#ifndef _LINUX_NFS_IOSTAT
#define _LINUX_NFS_IOSTAT

#define NFS_IOSTAT_VERS		"1.1"

/*
 * NFS byte counters
 *
 * 1.  SERVER - the number of payload bytes read from or written
 *     to the server by the NFS client via an NFS READ or WRITE
 *     request.
 *
 * 2.  NORMAL - the number of bytes read or written by applications
 *     via the read(2) and write(2) system call interfaces.
 *
 * 3.  DIRECT - the number of bytes read or written from files
 *     opened with the O_DIRECT flag.
 *
 * These counters give a view of the data throughput into and out
 * of the NFS client.  Comparing the number of bytes requested by
 * an application with the number of bytes the client requests from
 * the server can provide an indication of client efficiency
 * (per-op, cache hits, etc).
 *
 * These counters can also help characterize which access methods
 * are in use.  DIRECT by itself shows whether there is any O_DIRECT
 * traffic.  NORMAL + DIRECT shows how much data is going through
 * the system call interface.  A large amount of SERVER traffic
 * without much NORMAL or DIRECT traffic shows that applications
 * are using mapped files.
 *
 * NFS page counters
 *
 * These count the number of pages read or written via nfs_readpage(),
 * nfs_readpages(), or their write equivalents.
 *
 * NB: When adding new byte counters, please include the measured
 * units in the name of each byte counter to help users of this
 * interface determine what exactly is being counted.
 */
enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES,
	NFSIOS_DIRECTREADBYTES,
	NFSIOS_DIRECTWRITTENBYTES,
	NFSIOS_SERVERREADBYTES,
	NFSIOS_SERVERWRITTENBYTES,
	NFSIOS_READPAGES,
	NFSIOS_WRITEPAGES,
	__NFSIOS_BYTESMAX,
};

/*
 * NFS event counters
 *
 * These counters provide a low-overhead way of monitoring client
 * activity without enabling NFS trace debugging.  The counters
 * show the rate at which VFS requests are made, and how often the
 * client invalidates its data and attribute caches.  This allows
 * system administrators to monitor such things as how close-to-open
 * is working, and answer questions such as "why are there so many
 * GETATTR requests on the wire?"
 *
 * They also count anamolous events such as short reads and writes,
 * silly renames due to close-after-delete, and operations that
 * change the size of a file (such operations can often be the
 * source of data corruption if applications aren't using file
 * locking properly).
 */
enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE,
	NFSIOS_DATAINVALIDATE,
	NFSIOS_ATTRINVALIDATE,
	NFSIOS_VFSOPEN,
	NFSIOS_VFSLOOKUP,
	NFSIOS_VFSACCESS,
	NFSIOS_VFSUPDATEPAGE,
	NFSIOS_VFSREADPAGE,
	NFSIOS_VFSREADPAGES,
	NFSIOS_VFSWRITEPAGE,
	NFSIOS_VFSWRITEPAGES,
	NFSIOS_VFSGETDENTS,
	NFSIOS_VFSSETATTR,
	NFSIOS_VFSFLUSH,
	NFSIOS_VFSFSYNC,
	NFSIOS_VFSLOCK,
	NFSIOS_VFSRELEASE,
	NFSIOS_CONGESTIONWAIT,
	NFSIOS_SETATTRTRUNC,
	NFSIOS_EXTENDWRITE,
	NFSIOS_SILLYRENAME,
	NFSIOS_SHORTREAD,
	NFSIOS_SHORTWRITE,
	NFSIOS_DELAY,
	NFSIOS_PNFS_READ,
	NFSIOS_PNFS_WRITE,
	__NFSIOS_COUNTSMAX,
};

/*
 * NFS local caching servicing counters
 */
enum nfs_stat_fscachecounters {
	NFSIOS_FSCACHE_PAGES_READ_OK,
	NFSIOS_FSCACHE_PAGES_READ_FAIL,
	NFSIOS_FSCACHE_PAGES_WRITTEN_OK,
	NFSIOS_FSCACHE_PAGES_WRITTEN_FAIL,
	NFSIOS_FSCACHE_PAGES_UNCACHED,
	__NFSIOS_FSCACHEMAX,
};

#endif	/* _LINUX_NFS_IOSTAT */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright © 2006-2015, Intel Corporation.
 *
 * Authors: Ashok Raj <ashok.raj@intel.com>
 *          Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
 *          David Woodhouse <David.Woodhouse@intel.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place - Suite 330, Boston, MA 02111-1307 USA.
 */

#ifndef _INTEL_IOMMU_H_
#define _INTEL_IOMMU_H_

#include <linux/types.h>
#include <linux/iova.h>
#include <linux/io.h>
#include <linux/idr.h>
#include <linux/dma_remapping.h>
#include <linux/mmu_notifier.h>
#include <linux/list.h>
#include <asm/cacheflush.h>
#include <asm/iommu.h>

/*
 * Intel IOMMU register specification per version 1.0 public spec.
 */

#define	DMAR_VER_REG	0x0	/* Arch version supported by this IOMMU */
#define	DMAR_CAP_REG	0x8	/* Hardware supported capabilities */
#define	DMAR_ECAP_REG	0x10	/* Extended capabilities supported */
#define	DMAR_GCMD_REG	0x18	/* Global command register */
#define	DMAR_GSTS_REG	0x1c	/* Global status register */
#define	DMAR_RTADDR_REG	0x20	/* Root entry table */
#define	DMAR_CCMD_REG	0x28	/* Context command reg */
#define	DMAR_FSTS_REG	0x34	/* Fault Status register */
#define	DMAR_FECTL_REG	0x38	/* Fault control register */
#define	DMAR_FEDATA_REG	0x3c	/* Fault event interrupt data register */
#define	DMAR_FEADDR_REG	0x40	/* Fault event interrupt addr register */
#define	DMAR_FEUADDR_REG 0x44	/* Upper address register */
#define	DMAR_AFLOG_REG	0x58	/* Advanced Fault control */
#define	DMAR_PMEN_REG	0x64	/* Enable Protected Memory Region */
#define	DMAR_PLMBASE_REG 0x68	/* PMRR Low addr */
#define	DMAR_PLMLIMIT_REG 0x6c	/* PMRR low limit */
#define	DMAR_PHMBASE_REG 0x70	/* pmrr high base addr */
#define	DMAR_PHMLIMIT_REG 0x78	/* pmrr high limit */
#define DMAR_IQH_REG	0x80	/* Invalidation queue head register */
#define DMAR_IQT_REG	0x88	/* Invalidation queue tail register */
#define DMAR_IQ_SHIFT	4	/* Invalidation queue head/tail shift */
#define DMAR_IQA_REG	0x90	/* Invalidation queue addr register */
#define DMAR_ICS_REG	0x9c	/* Invalidation complete status register */
#define DMAR_IRTA_REG	0xb8    /* Interrupt remapping table addr register */
#define DMAR_PQH_REG	0xc0	/* Page request queue head register */
#define DMAR_PQT_REG	0xc8	/* Page request queue tail register */
#define DMAR_PQA_REG	0xd0	/* Page request queue address register */
#define DMAR_PRS_REG	0xdc	/* Page request status register */
#define DMAR_PECTL_REG	0xe0	/* Page request event control register */
#define	DMAR_PEDATA_REG	0xe4	/* Page request event interrupt data register */
#define	DMAR_PEADDR_REG	0xe8	/* Page request event interrupt addr register */
#define	DMAR_PEUADDR_REG 0xec	/* Page request event Upper address register */

#define OFFSET_STRIDE		(9)

#ifdef CONFIG_64BIT
#define dmar_readq(a) readq(a)
#define dmar_writeq(a,v) writeq(v,a)
#else
static inline u64 dmar_readq(void __iomem *addr)
{
	u32 lo, hi;
	lo = readl(addr);
	hi = readl(addr + 4);
	return (((u64) hi) << 32) + lo;
}

static inline void dmar_writeq(void __iomem *addr, u64 val)
{
	writel((u32)val, addr);
	writel((u32)(val >> 32), addr + 4);
}
#endif

#define DMAR_VER_MAJOR(v)		(((v) & 0xf0) >> 4)
#define DMAR_VER_MINOR(v)		((v) & 0x0f)

/*
 * Decoding Capability Register
 */
#define cap_pi_support(c)	(((c) >> 59) & 1)
#define cap_read_drain(c)	(((c) >> 55) & 1)
#define cap_write_drain(c)	(((c) >> 54) & 1)
#define cap_max_amask_val(c)	(((c) >> 48) & 0x3f)
#define cap_num_fault_regs(c)	((((c) >> 40) & 0xff) + 1)
#define cap_pgsel_inv(c)	(((c) >> 39) & 1)

#define cap_super_page_val(c)	(((c) >> 34) & 0xf)
#define cap_super_offset(c)	(((find_first_bit(&cap_super_page_val(c), 4)) \
					* OFFSET_STRIDE) + 21)

#define cap_fault_reg_offset(c)	((((c) >> 24) & 0x3ff) * 16)
#define cap_max_fault_reg_offset(c) \
	(cap_fault_reg_offset(c) + cap_num_fault_regs(c) * 16)

#define cap_zlr(c)		(((c) >> 22) & 1)
#define cap_isoch(c)		(((c) >> 23) & 1)
#define cap_mgaw(c)		((((c) >> 16) & 0x3f) + 1)
#define cap_sagaw(c)		(((c) >> 8) & 0x1f)
#define cap_caching_mode(c)	(((c) >> 7) & 1)
#define cap_phmr(c)		(((c) >> 6) & 1)
#define cap_plmr(c)		(((c) >> 5) & 1)
#define cap_rwbf(c)		(((c) >> 4) & 1)
#define cap_afl(c)		(((c) >> 3) & 1)
#define cap_ndoms(c)		(((unsigned long)1) << (4 + 2 * ((c) & 0x7)))
/*
 * Extended Capability Register
 */

#define ecap_pasid(e)		((e >> 40) & 0x1)
#define ecap_pss(e)		((e >> 35) & 0x1f)
#define ecap_eafs(e)		((e >> 34) & 0x1)
#define ecap_nwfs(e)		((e >> 33) & 0x1)
#define ecap_srs(e)		((e >> 31) & 0x1)
#define ecap_ers(e)		((e >> 30) & 0x1)
#define ecap_prs(e)		((e >> 29) & 0x1)
#define ecap_broken_pasid(e)	((e >> 28) & 0x1)
#define ecap_dis(e)		((e >> 27) & 0x1)
#define ecap_nest(e)		((e >> 26) & 0x1)
#define ecap_mts(e)		((e >> 25) & 0x1)
#define ecap_ecs(e)		((e >> 24) & 0x1)
#define ecap_iotlb_offset(e) 	((((e) >> 8) & 0x3ff) * 16)
#define ecap_max_iotlb_offset(e) (ecap_iotlb_offset(e) + 16)
#define ecap_coherent(e)	((e) & 0x1)
#define ecap_qis(e)		((e) & 0x2)
#define ecap_pass_through(e)	((e >> 6) & 0x1)
#define ecap_eim_support(e)	((e >> 4) & 0x1)
#define ecap_ir_support(e)	((e >> 3) & 0x1)
#define ecap_dev_iotlb_support(e)	(((e) >> 2) & 0x1)
#define ecap_max_handle_mask(e) ((e >> 20) & 0xf)
#define ecap_sc_support(e)	((e >> 7) & 0x1) /* Snooping Control */

/* IOTLB_REG */
#define DMA_TLB_FLUSH_GRANU_OFFSET  60
#define DMA_TLB_GLOBAL_FLUSH (((u64)1) << 60)
#define DMA_TLB_DSI_FLUSH (((u64)2) << 60)
#define DMA_TLB_PSI_FLUSH (((u64)3) << 60)
#define DMA_TLB_IIRG(type) ((type >> 60) & 3)
#define DMA_TLB_IAIG(val) (((val) >> 57) & 3)
#define DMA_TLB_READ_DRAIN (((u64)1) << 49)
#define DMA_TLB_WRITE_DRAIN (((u64)1) << 48)
#define DMA_TLB_DID(id)	(((u64)((id) & 0xffff)) << 32)
#define DMA_TLB_IVT (((u64)1) << 63)
#define DMA_TLB_IH_NONLEAF (((u64)1) << 6)
#define DMA_TLB_MAX_SIZE (0x3f)

/* INVALID_DESC */
#define DMA_CCMD_INVL_GRANU_OFFSET  61
#define DMA_ID_TLB_GLOBAL_FLUSH	(((u64)1) << 4)
#define DMA_ID_TLB_DSI_FLUSH	(((u64)2) << 4)
#define DMA_ID_TLB_PSI_FLUSH	(((u64)3) << 4)
#define DMA_ID_TLB_READ_DRAIN	(((u64)1) << 7)
#define DMA_ID_TLB_WRITE_DRAIN	(((u64)1) << 6)
#define DMA_ID_TLB_DID(id)	(((u64)((id & 0xffff) << 16)))
#define DMA_ID_TLB_IH_NONLEAF	(((u64)1) << 6)
#define DMA_ID_TLB_ADDR(addr)	(addr)
#define DMA_ID_TLB_ADDR_MASK(mask)	(mask)

/* PMEN_REG */
#define DMA_PMEN_EPM (((u32)1)<<31)
#define DMA_PMEN_PRS (((u32)1)<<0)

/* GCMD_REG */
#define DMA_GCMD_TE (((u32)1) << 31)
#define DMA_GCMD_SRTP (((u32)1) << 30)
#define DMA_GCMD_SFL (((u32)1) << 29)
#define DMA_GCMD_EAFL (((u32)1) << 28)
#define DMA_GCMD_WBF (((u32)1) << 27)
#define DMA_GCMD_QIE (((u32)1) << 26)
#define DMA_GCMD_SIRTP (((u32)1) << 24)
#define DMA_GCMD_IRE (((u32) 1) << 25)
#define DMA_GCMD_CFI (((u32) 1) << 23)

/* GSTS_REG */
#define DMA_GSTS_TES (((u32)1) << 31)
#define DMA_GSTS_RTPS (((u32)1) << 30)
#define DMA_GSTS_FLS (((u32)1) << 29)
#define DMA_GSTS_AFLS (((u32)1) << 28)
#define DMA_GSTS_WBFS (((u32)1) << 27)
#define DMA_GSTS_QIES (((u32)1) << 26)
#define DMA_GSTS_IRTPS (((u32)1) << 24)
#define DMA_GSTS_IRES (((u32)1) << 25)
#define DMA_GSTS_CFIS (((u32)1) << 23)

/* DMA_RTADDR_REG */
#define DMA_RTADDR_RTT (((u64)1) << 11)

/* CCMD_REG */
#define DMA_CCMD_ICC (((u64)1) << 63)
#define DMA_CCMD_GLOBAL_INVL (((u64)1) << 61)
#define DMA_CCMD_DOMAIN_INVL (((u64)2) << 61)
#define DMA_CCMD_DEVICE_INVL (((u64)3) << 61)
#define DMA_CCMD_FM(m) (((u64)((m) & 0x3)) << 32)
#define DMA_CCMD_MASK_NOBIT 0
#define DMA_CCMD_MASK_1BIT 1
#define DMA_CCMD_MASK_2BIT 2
#define DMA_CCMD_MASK_3BIT 3
#define DMA_CCMD_SID(s) (((u64)((s) & 0xffff)) << 16)
#define DMA_CCMD_DID(d) ((u64)((d) & 0xffff))

/* FECTL_REG */
#define DMA_FECTL_IM (((u32)1) << 31)

/* FSTS_REG */
#define DMA_FSTS_PPF ((u32)2)
#define DMA_FSTS_PFO ((u32)1)
#define DMA_FSTS_IQE (1 << 4)
#define DMA_FSTS_ICE (1 << 5)
#define DMA_FSTS_ITE (1 << 6)
#define dma_fsts_fault_record_index(s) (((s) >> 8) & 0xff)

/* FRCD_REG, 32 bits access */
#define DMA_FRCD_F (((u32)1) << 31)
#define dma_frcd_type(d) ((d >> 30) & 1)
#define dma_frcd_fault_reason(c) (c & 0xff)
#define dma_frcd_source_id(c) (c & 0xffff)
/* low 64 bit */
#define dma_frcd_page_addr(d) (d & (((u64)-1) << PAGE_SHIFT))

/* PRS_REG */
#define DMA_PRS_PPR	((u32)1)

#define IOMMU_WAIT_OP(iommu, offset, op, cond, sts)			\
do {									\
	cycles_t start_time = get_cycles();				\
	while (1) {							\
		sts = op(iommu->reg + offset);				\
		if (cond)						\
			break;						\
		if (DMAR_OPERATION_TIMEOUT < (get_cycles() - start_time))\
			panic("DMAR hardware is malfunctioning\n");	\
		cpu_relax();						\
	}								\
} while (0)

#define QI_LENGTH	256	/* queue length */

enum {
	QI_FREE,
	QI_IN_USE,
	QI_DONE,
	QI_ABORT
};

#define QI_CC_TYPE		0x1
#define QI_IOTLB_TYPE		0x2
#define QI_DIOTLB_TYPE		0x3
#define QI_IEC_TYPE		0x4
#define QI_IWD_TYPE		0x5
#define QI_EIOTLB_TYPE		0x6
#define QI_PC_TYPE		0x7
#define QI_DEIOTLB_TYPE		0x8
#define QI_PGRP_RESP_TYPE	0x9
#define QI_PSTRM_RESP_TYPE	0xa

#define QI_IEC_SELECTIVE	(((u64)1) << 4)
#define QI_IEC_IIDEX(idx)	(((u64)(idx & 0xffff) << 32))
#define QI_IEC_IM(m)		(((u64)(m & 0x1f) << 27))

#define QI_IWD_STATUS_DATA(d)	(((u64)d) << 32)
#define QI_IWD_STATUS_WRITE	(((u64)1) << 5)

#define QI_IOTLB_DID(did) 	(((u64)did) << 16)
#define QI_IOTLB_DR(dr) 	(((u64)dr) << 7)
#define QI_IOTLB_DW(dw) 	(((u64)dw) << 6)
#define QI_IOTLB_GRAN(gran) 	(((u64)gran) >> (DMA_TLB_FLUSH_GRANU_OFFSET-4))
#define QI_IOTLB_ADDR(addr)	(((u64)addr) & VTD_PAGE_MASK)
#define QI_IOTLB_IH(ih)		(((u64)ih) << 6)
#define QI_IOTLB_AM(am)		(((u8)am))

#define QI_CC_FM(fm)		(((u64)fm) << 48)
#define QI_CC_SID(sid)		(((u64)sid) << 32)
#define QI_CC_DID(did)		(((u64)did) << 16)
#define QI_CC_GRAN(gran)	(((u64)gran) >> (DMA_CCMD_INVL_GRANU_OFFSET-4))

#define QI_DEV_IOTLB_SID(sid)	((u64)((sid) & 0xffff) << 32)
#define QI_DEV_IOTLB_QDEP(qdep)	(((qdep) & 0x1f) << 16)
#define QI_DEV_IOTLB_ADDR(addr)	((u64)(addr) & VTD_PAGE_MASK)
#define QI_DEV_IOTLB_SIZE	1
#define QI_DEV_IOTLB_MAX_INVS	32

#define QI_PC_PASID(pasid)	(((u64)pasid) << 32)
#define QI_PC_DID(did)		(((u64)did) << 16)
#define QI_PC_GRAN(gran)	(((u64)gran) << 4)

#define QI_PC_ALL_PASIDS	(QI_PC_TYPE | QI_PC_GRAN(0))
#define QI_PC_PASID_SEL		(QI_PC_TYPE | QI_PC_GRAN(1))

#define QI_EIOTLB_ADDR(addr)	((u64)(addr) & VTD_PAGE_MASK)
#define QI_EIOTLB_GL(gl)	(((u64)gl) << 7)
#define QI_EIOTLB_IH(ih)	(((u64)ih) << 6)
#define QI_EIOTLB_AM(am)	(((u64)am))
#define QI_EIOTLB_PASID(pasid) 	(((u64)pasid) << 32)
#define QI_EIOTLB_DID(did)	(((u64)did) << 16)
#define QI_EIOTLB_GRAN(gran) 	(((u64)gran) << 4)

#define QI_DEV_EIOTLB_ADDR(a)	((u64)(a) & VTD_PAGE_MASK)
#define QI_DEV_EIOTLB_SIZE	(((u64)1) << 11)
#define QI_DEV_EIOTLB_GLOB(g)	((u64)g)
#define QI_DEV_EIOTLB_PASID(p)	(((u64)p) << 32)
#define QI_DEV_EIOTLB_SID(sid)	((u64)((sid) & 0xffff) << 16)
#define QI_DEV_EIOTLB_QDEP(qd)	((u64)((qd) & 0x1f) << 4)
#define QI_DEV_EIOTLB_MAX_INVS	32

#define QI_PGRP_IDX(idx)	(((u64)(idx)) << 55)
#define QI_PGRP_PRIV(priv)	(((u64)(priv)) << 32)
#define QI_PGRP_RESP_CODE(res)	((u64)(res))
#define QI_PGRP_PASID(pasid)	(((u64)(pasid)) << 32)
#define QI_PGRP_DID(did)	(((u64)(did)) << 16)
#define QI_PGRP_PASID_P(p)	(((u64)(p)) << 4)

#define QI_PSTRM_ADDR(addr)	(((u64)(addr)) & VTD_PAGE_MASK)
#define QI_PSTRM_DEVFN(devfn)	(((u64)(devfn)) << 4)
#define QI_PSTRM_RESP_CODE(res)	((u64)(res))
#define QI_PSTRM_IDX(idx)	(((u64)(idx)) << 55)
#define QI_PSTRM_PRIV(priv)	(((u64)(priv)) << 32)
#define QI_PSTRM_BUS(bus)	(((u64)(bus)) << 24)
#define QI_PSTRM_PASID(pasid)	(((u64)(pasid)) << 4)

#define QI_RESP_SUCCESS		0x0
#define QI_RESP_INVALID		0x1
#define QI_RESP_FAILURE		0xf

#define QI_GRAN_ALL_ALL			0
#define QI_GRAN_NONG_ALL		1
#define QI_GRAN_NONG_PASID		2
#define QI_GRAN_PSI_PASID		3

struct qi_desc {
	u64 low, high;
};

struct q_inval {
	raw_spinlock_t  q_lock;
	struct qi_desc  *desc;          /* invalidation queue */
	int             *desc_status;   /* desc status */
	int             free_head;      /* first free entry */
	int             free_tail;      /* last free entry */
	int             free_cnt;
};

#ifdef CONFIG_IRQ_REMAP
/* 1MB - maximum possible interrupt remapping table size */
#define INTR_REMAP_PAGE_ORDER	8
#define INTR_REMAP_TABLE_REG_SIZE	0xf
#define INTR_REMAP_TABLE_REG_SIZE_MASK  0xf

#define INTR_REMAP_TABLE_ENTRIES	65536

struct irq_domain;

struct ir_table {
	struct irte *base;
	unsigned long *bitmap;
};
#endif

struct iommu_flush {
	void (*flush_context)(struct intel_iommu *iommu, u16 did, u16 sid,
			      u8 fm, u64 type);
	void (*flush_iotlb)(struct intel_iommu *iommu, u16 did, u64 addr,
			    unsigned int size_order, u64 type);
};

enum {
	SR_DMAR_FECTL_REG,
	SR_DMAR_FEDATA_REG,
	SR_DMAR_FEADDR_REG,
	SR_DMAR_FEUADDR_REG,
	MAX_SR_DMAR_REGS
};

#define VTD_FLAG_TRANS_PRE_ENABLED	(1 << 0)
#define VTD_FLAG_IRQ_REMAP_PRE_ENABLED	(1 << 1)

struct pasid_entry;
struct pasid_state_entry;
struct page_req_dsc;

struct intel_iommu {
	void __iomem	*reg; /* Pointer to hardware regs, virtual addr */
	u64 		reg_phys; /* physical address of hw register set */
	u64		reg_size; /* size of hw register set */
	u64		cap;
	u64		ecap;
	u32		gcmd; /* Holds TE, EAFL. Don't need SRTP, SFL, WBF */
	raw_spinlock_t	register_lock; /* protect register handling */
	int		seq_id;	/* sequence id of the iommu */
	int		agaw; /* agaw of this iommu */
	int		msagaw; /* max sagaw of this iommu */
	unsigned int 	irq, pr_irq;
	u16		segment;     /* PCI segment# */
	unsigned char 	name[13];    /* Device Name */

#ifdef CONFIG_INTEL_IOMMU
	unsigned long 	*domain_ids; /* bitmap of domains */
	struct dmar_domain ***domains; /* ptr to domains */
	spinlock_t	lock; /* protect context, domain ids */
	struct root_entry *root_entry; /* virtual address */

	struct iommu_flush flush;
#endif
#ifdef CONFIG_INTEL_IOMMU_SVM
	/* These are large and need to be contiguous, so we allocate just
	 * one for now. We'll maybe want to rethink that if we truly give
	 * devices away to userspace processes (e.g. for DPDK) and don't
	 * want to trust that userspace will use *only* the PASID it was
	 * told to. But while it's all driver-arbitrated, we're fine. */
	struct pasid_entry *pasid_table;
	struct pasid_state_entry *pasid_state_table;
	struct page_req_dsc *prq;
	unsigned char prq_name[16];    /* Name for PRQ interrupt */
	struct idr pasid_idr;
	u32 pasid_max;
#endif
	struct q_inval  *qi;            /* Queued invalidation info */
	u32 *iommu_state; /* Store iommu states between suspend and resume.*/

#ifdef CONFIG_IRQ_REMAP
	struct ir_table *ir_table;	/* Interrupt remapping info */
	struct irq_domain *ir_domain;
	struct irq_domain *ir_msi_domain;
#endif
	struct device	*iommu_dev; /* IOMMU-sysfs device */
	int		node;
	u32		flags;      /* Software defined flags */
};

static inline void __iommu_flush_cache(
	struct intel_iommu *iommu, void *addr, int size)
{
	if (!ecap_coherent(iommu->ecap))
		clflush_cache_range(addr, size);
}

extern struct dmar_drhd_unit * dmar_find_matched_drhd_unit(struct pci_dev *dev);
extern int dmar_find_matched_atsr_unit(struct pci_dev *dev);

extern int dmar_enable_qi(struct intel_iommu *iommu);
extern void dmar_disable_qi(struct intel_iommu *iommu);
extern int dmar_reenable_qi(struct intel_iommu *iommu);
extern void qi_global_iec(struct intel_iommu *iommu);

extern void qi_flush_context(struct intel_iommu *iommu, u16 did, u16 sid,
			     u8 fm, u64 type);
extern void qi_flush_iotlb(struct intel_iommu *iommu, u16 did, u64 addr,
			  unsigned int size_order, u64 type);
extern void qi_flush_dev_iotlb(struct intel_iommu *iommu, u16 sid, u16 qdep,
			       u64 addr, unsigned mask);

extern int qi_submit_sync(struct qi_desc *desc, struct intel_iommu *iommu);

extern int dmar_ir_support(void);

#ifdef CONFIG_INTEL_IOMMU_SVM
extern int intel_svm_alloc_pasid_tables(struct intel_iommu *iommu);
extern int intel_svm_free_pasid_tables(struct intel_iommu *iommu);
extern int intel_svm_enable_prq(struct intel_iommu *iommu);
extern int intel_svm_finish_prq(struct intel_iommu *iommu);

struct svm_dev_ops;

struct intel_svm_dev {
	struct list_head list;
	struct rcu_head rcu;
	struct device *dev;
	struct svm_dev_ops *ops;
	int users;
	u16 did;
	u16 dev_iotlb:1;
	u16 sid, qdep;
};

struct intel_svm {
	struct mmu_notifier notifier;
	struct mm_struct *mm;
	struct intel_iommu *iommu;
	int flags;
	int pasid;
	struct list_head devs;
};

extern int intel_iommu_enable_pasid(struct intel_iommu *iommu, struct intel_svm_dev *sdev);
extern struct intel_iommu *intel_svm_device_to_iommu(struct device *dev);
#endif

extern const struct attribute_group *intel_iommu_groups[];

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _LINUX_INIT_H
#define _LINUX_INIT_H

#include <linux/compiler.h>
#include <linux/types.h>

/* These macros are used to mark some functions or 
 * initialized data (doesn't apply to uninitialized data)
 * as `initialization' functions. The kernel can take this
 * as hint that the function is used only during the initialization
 * phase and free up used memory resources after
 *
 * Usage:
 * For functions:
 * 
 * You should add __init immediately before the function name, like:
 *
 * static void __init initme(int x, int y)
 * {
 *    extern int z; z = x * y;
 * }
 *
 * If the function has a prototype somewhere, you can also add
 * __init between closing brace of the prototype and semicolon:
 *
 * extern int initialize_foobar_device(int, int, int) __init;
 *
 * For initialized data:
 * You should insert __initdata or __initconst between the variable name
 * and equal sign followed by value, e.g.:
 *
 * static int init_variable __initdata = 0;
 * static const char linux_logo[] __initconst = { 0x32, 0x36, ... };
 *
 * Don't forget to initialize data not at file scope, i.e. within a function,
 * as gcc otherwise puts the data into the bss section and not into the init
 * section.
 */

/* These are for everybody (although not all archs will actually
   discard it in modules) */
#define __init		__section(.init.text) __cold notrace __latent_entropy
#define __initdata	__section(.init.data)
#define __initconst	__section(.init.rodata)
#define __exitdata	__section(.exit.data)
#define __exit_call	__used __section(.exitcall.exit)

/*
 * modpost check for section mismatches during the kernel build.
 * A section mismatch happens when there are references from a
 * code or data section to an init section (both code or data).
 * The init sections are (for most archs) discarded by the kernel
 * when early init has completed so all such references are potential bugs.
 * For exit sections the same issue exists.
 *
 * The following markers are used for the cases where the reference to
 * the *init / *exit section (code or data) is valid and will teach
 * modpost not to issue a warning.  Intended semantics is that a code or
 * data tagged __ref* can reference code or data from init section without
 * producing a warning (of course, no warning does not mean code is
 * correct, so optimally document why the __ref is needed and why it's OK).
 *
 * The markers follow same syntax rules as __init / __initdata.
 */
#define __ref            __section(.ref.text) noinline
#define __refdata        __section(.ref.data)
#define __refconst       __section(.ref.rodata)

#ifdef MODULE
#define __exitused
#else
#define __exitused  __used
#endif

#define __exit          __section(.exit.text) __exitused __cold notrace

/* Used for MEMORY_HOTPLUG */
#define __meminit        __section(.meminit.text) __cold notrace \
						  __latent_entropy
#define __meminitdata    __section(.meminit.data)
#define __meminitconst   __section(.meminit.rodata)
#define __memexit        __section(.memexit.text) __exitused __cold notrace
#define __memexitdata    __section(.memexit.data)
#define __memexitconst   __section(.memexit.rodata)

/* For assembly routines */
#define __HEAD		.section	".head.text","ax"
#define __INIT		.section	".init.text","ax"
#define __FINIT		.previous

#define __INITDATA	.section	".init.data","aw",%progbits
#define __INITRODATA	.section	".init.rodata","a",%progbits
#define __FINITDATA	.previous

#define __MEMINIT        .section	".meminit.text", "ax"
#define __MEMINITDATA    .section	".meminit.data", "aw"
#define __MEMINITRODATA  .section	".meminit.rodata", "a"

/* silence warnings when references are OK */
#define __REF            .section       ".ref.text", "ax"
#define __REFDATA        .section       ".ref.data", "aw"
#define __REFCONST       .section       ".ref.rodata", "a"

#ifndef __ASSEMBLY__
/*
 * Used for initialization calls..
 */
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);

extern initcall_t __con_initcall_start[], __con_initcall_end[];
extern initcall_t __security_initcall_start[], __security_initcall_end[];

/* Used for contructor calls. */
typedef void (*ctor_fn_t)(void);

/* Defined in init/main.c */
extern int do_one_initcall(initcall_t fn);
extern char __initdata boot_command_line[];
extern char *saved_command_line;
extern unsigned int reset_devices;

/* used by init/main.c */
void setup_arch(char **);
void prepare_namespace(void);
void __init load_default_modules(void);
int __init init_rootfs(void);

#ifdef CONFIG_DEBUG_RODATA
void mark_rodata_ro(void);
#endif

extern void (*late_time_init)(void);

extern bool initcall_debug;

#endif
  
#ifndef MODULE

#ifndef __ASSEMBLY__

/*
 * initcalls are now grouped by functionality into separate
 * subsections. Ordering inside the subsections is determined
 * by link order. 
 * For backwards compatibility, initcall() puts the call in 
 * the device init subsection.
 *
 * The `id' arg to __define_initcall() is needed so that multiple initcalls
 * can point at the same handler without causing duplicate-symbol build errors.
 *
 * Initcalls are run by placing pointers in initcall sections that the
 * kernel iterates at runtime. The linker can do dead code / data elimination
 * and remove that completely, so the initcall sections have to be marked
 * as KEEP() in the linker script.
 */

#define __define_initcall(fn, id) \
	static initcall_t __initcall_##fn##id __used \
	__attribute__((__section__(".initcall" #id ".init"))) = fn;

/*
 * Early initcalls run before initializing SMP.
 *
 * Only for built-in code, not modules.
 */
#define early_initcall(fn)		__define_initcall(fn, early)

/*
 * A "pure" initcall has no dependencies on anything else, and purely
 * initializes variables that couldn't be statically initialized.
 *
 * This only exists for built-in code, not for modules.
 * Keep main.c:initcall_level_names[] in sync.
 */
#define pure_initcall(fn)		__define_initcall(fn, 0)

#define core_initcall(fn)		__define_initcall(fn, 1)
#define core_initcall_sync(fn)		__define_initcall(fn, 1s)
#define postcore_initcall(fn)		__define_initcall(fn, 2)
#define postcore_initcall_sync(fn)	__define_initcall(fn, 2s)
#define arch_initcall(fn)		__define_initcall(fn, 3)
#define arch_initcall_sync(fn)		__define_initcall(fn, 3s)
#define subsys_initcall(fn)		__define_initcall(fn, 4)
#define subsys_initcall_sync(fn)	__define_initcall(fn, 4s)
#define fs_initcall(fn)			__define_initcall(fn, 5)
#define fs_initcall_sync(fn)		__define_initcall(fn, 5s)
#define rootfs_initcall(fn)		__define_initcall(fn, rootfs)
#define device_initcall(fn)		__define_initcall(fn, 6)
#define device_initcall_sync(fn)	__define_initcall(fn, 6s)
#define late_initcall(fn)		__define_initcall(fn, 7)
#define late_initcall_sync(fn)		__define_initcall(fn, 7s)

#define __initcall(fn) device_initcall(fn)

#define __exitcall(fn)						\
	static exitcall_t __exitcall_##fn __exit_call = fn

#define console_initcall(fn)					\
	static initcall_t __initcall_##fn			\
	__used __section(.con_initcall.init) = fn

#define security_initcall(fn)					\
	static initcall_t __initcall_##fn			\
	__used __section(.security_initcall.init) = fn

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

/*
 * Only for really core code.  See moduleparam.h for the normal way.
 *
 * Force the alignment so the compiler doesn't space elements of the
 * obs_kernel_param "array" too far apart in .init.setup.
 */
#define __setup_param(str, unique_id, fn, early)			\
	static const char __setup_str_##unique_id[] __initconst		\
		__aligned(1) = str; 					\
	static struct obs_kernel_param __setup_##unique_id		\
		__used __section(.init.setup)				\
		__attribute__((aligned((sizeof(long)))))		\
		= { __setup_str_##unique_id, fn, early }

#define __setup(str, fn)						\
	__setup_param(str, fn, fn, 0)

/*
 * NOTE: fn is as per module_param, not __setup!
 * Emits warning if fn returns non-zero.
 */
#define early_param(str, fn)						\
	__setup_param(str, fn, fn, 1)

#define early_param_on_off(str_on, str_off, var, config)		\
									\
	int var = IS_ENABLED(config);					\
									\
	static int __init parse_##var##_on(char *arg)			\
	{								\
		var = 1;						\
		return 0;						\
	}								\
	__setup_param(str_on, parse_##var##_on, parse_##var##_on, 1);	\
									\
	static int __init parse_##var##_off(char *arg)			\
	{								\
		var = 0;						\
		return 0;						\
	}								\
	__setup_param(str_off, parse_##var##_off, parse_##var##_off, 1)

/* Relies on boot_command_line being set */
void __init parse_early_param(void);
void __init parse_early_options(char *cmdline);
#endif /* __ASSEMBLY__ */

#else /* MODULE */

#define __setup_param(str, unique_id, fn)	/* nothing */
#define __setup(str, func) 			/* nothing */
#endif

/* Data marked not to be saved by software suspend */
#define __nosavedata __section(.data..nosave)

#ifdef MODULE
#define __exit_p(x) x
#else
#define __exit_p(x) NULL
#endif

#endif /* _LINUX_INIT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _LINUX_START_KERNEL_H
#define _LINUX_START_KERNEL_H

#include <linux/linkage.h>
#include <linux/init.h>

/* Define the prototype for start_kernel here, rather than cluttering
   up something else. */

extern asmlinkage void __init start_kernel(void);

#endif /* _LINUX_START_KERNEL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef __LINUX_PWM_H
#define __LINUX_PWM_H

#include <linux/err.h>
#include <linux/mutex.h>
#include <linux/of.h>

struct pwm_capture;
struct seq_file;

struct pwm_chip;

/**
 * enum pwm_polarity - polarity of a PWM signal
 * @PWM_POLARITY_NORMAL: a high signal for the duration of the duty-
 * cycle, followed by a low signal for the remainder of the pulse
 * period
 * @PWM_POLARITY_INVERSED: a low signal for the duration of the duty-
 * cycle, followed by a high signal for the remainder of the pulse
 * period
 */
enum pwm_polarity {
	PWM_POLARITY_NORMAL,
	PWM_POLARITY_INVERSED,
};

/**
 * struct pwm_args - board-dependent PWM arguments
 * @period: reference period
 * @polarity: reference polarity
 *
 * This structure describes board-dependent arguments attached to a PWM
 * device. These arguments are usually retrieved from the PWM lookup table or
 * device tree.
 *
 * Do not confuse this with the PWM state: PWM arguments represent the initial
 * configuration that users want to use on this PWM device rather than the
 * current PWM hardware state.
 */
struct pwm_args {
	unsigned int period;
	enum pwm_polarity polarity;
};

enum {
	PWMF_REQUESTED = 1 << 0,
	PWMF_EXPORTED = 1 << 1,
};

/*
 * struct pwm_state - state of a PWM channel
 * @period: PWM period (in nanoseconds)
 * @duty_cycle: PWM duty cycle (in nanoseconds)
 * @polarity: PWM polarity
 * @enabled: PWM enabled status
 */
struct pwm_state {
	unsigned int period;
	unsigned int duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
};

/**
 * struct pwm_device - PWM channel object
 * @label: name of the PWM device
 * @flags: flags associated with the PWM device
 * @hwpwm: per-chip relative index of the PWM device
 * @pwm: global index of the PWM device
 * @chip: PWM chip providing this PWM device
 * @chip_data: chip-private data associated with the PWM device
 * @args: PWM arguments
 * @state: curent PWM channel state
 */
struct pwm_device {
	const char *label;
	unsigned long flags;
	unsigned int hwpwm;
	unsigned int pwm;
	struct pwm_chip *chip;
	void *chip_data;

	struct pwm_args args;
	struct pwm_state state;
};

/**
 * pwm_get_state() - retrieve the current PWM state
 * @pwm: PWM device
 * @state: state to fill with the current PWM state
 */
static inline void pwm_get_state(const struct pwm_device *pwm,
				 struct pwm_state *state)
{
	*state = pwm->state;
}

static inline bool pwm_is_enabled(const struct pwm_device *pwm)
{
	struct pwm_state state;

	pwm_get_state(pwm, &state);

	return state.enabled;
}

static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
{
	if (pwm)
		pwm->state.period = period;
}

static inline unsigned int pwm_get_period(const struct pwm_device *pwm)
{
	struct pwm_state state;

	pwm_get_state(pwm, &state);

	return state.period;
}

static inline void pwm_set_duty_cycle(struct pwm_device *pwm, unsigned int duty)
{
	if (pwm)
		pwm->state.duty_cycle = duty;
}

static inline unsigned int pwm_get_duty_cycle(const struct pwm_device *pwm)
{
	struct pwm_state state;

	pwm_get_state(pwm, &state);

	return state.duty_cycle;
}

static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
{
	struct pwm_state state;

	pwm_get_state(pwm, &state);

	return state.polarity;
}

static inline void pwm_get_args(const struct pwm_device *pwm,
				struct pwm_args *args)
{
	*args = pwm->args;
}

/**
 * pwm_init_state() - prepare a new state to be applied with pwm_apply_state()
 * @pwm: PWM device
 * @state: state to fill with the prepared PWM state
 *
 * This functions prepares a state that can later be tweaked and applied
 * to the PWM device with pwm_apply_state(). This is a convenient function
 * that first retrieves the current PWM state and the replaces the period
 * and polarity fields with the reference values defined in pwm->args.
 * Once the function returns, you can adjust the ->enabled and ->duty_cycle
 * fields according to your needs before calling pwm_apply_state().
 *
 * ->duty_cycle is initially set to zero to avoid cases where the current
 * ->duty_cycle value exceed the pwm_args->period one, which would trigger
 * an error if the user calls pwm_apply_state() without adjusting ->duty_cycle
 * first.
 */
static inline void pwm_init_state(const struct pwm_device *pwm,
				  struct pwm_state *state)
{
	struct pwm_args args;

	/* First get the current state. */
	pwm_get_state(pwm, state);

	/* Then fill it with the reference config */
	pwm_get_args(pwm, &args);

	state->period = args.period;
	state->polarity = args.polarity;
	state->duty_cycle = 0;
}

/**
 * pwm_get_relative_duty_cycle() - Get a relative duty cycle value
 * @state: PWM state to extract the duty cycle from
 * @scale: target scale of the relative duty cycle
 *
 * This functions converts the absolute duty cycle stored in @state (expressed
 * in nanosecond) into a value relative to the period.
 *
 * For example if you want to get the duty_cycle expressed in percent, call:
 *
 * pwm_get_state(pwm, &state);
 * duty = pwm_get_relative_duty_cycle(&state, 100);
 */
static inline unsigned int
pwm_get_relative_duty_cycle(const struct pwm_state *state, unsigned int scale)
{
	if (!state->period)
		return 0;

	return DIV_ROUND_CLOSEST_ULL((u64)state->duty_cycle * scale,
				     state->period);
}

/**
 * pwm_set_relative_duty_cycle() - Set a relative duty cycle value
 * @state: PWM state to fill
 * @duty_cycle: relative duty cycle value
 * @scale: scale in which @duty_cycle is expressed
 *
 * This functions converts a relative into an absolute duty cycle (expressed
 * in nanoseconds), and puts the result in state->duty_cycle.
 *
 * For example if you want to configure a 50% duty cycle, call:
 *
 * pwm_init_state(pwm, &state);
 * pwm_set_relative_duty_cycle(&state, 50, 100);
 * pwm_apply_state(pwm, &state);
 *
 * This functions returns -EINVAL if @duty_cycle and/or @scale are
 * inconsistent (@scale == 0 or @duty_cycle > @scale).
 */
static inline int
pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
			    unsigned int scale)
{
	if (!scale || duty_cycle > scale)
		return -EINVAL;

	state->duty_cycle = DIV_ROUND_CLOSEST_ULL((u64)duty_cycle *
						  state->period,
						  scale);

	return 0;
}

/**
 * struct pwm_ops - PWM controller operations
 * @request: optional hook for requesting a PWM
 * @free: optional hook for freeing a PWM
 * @config: configure duty cycles and period length for this PWM
 * @set_polarity: configure the polarity of this PWM
 * @capture: capture and report PWM signal
 * @enable: enable PWM output toggling
 * @disable: disable PWM output toggling
 * @apply: atomically apply a new PWM config. The state argument
 *	   should be adjusted with the real hardware config (if the
 *	   approximate the period or duty_cycle value, state should
 *	   reflect it)
 * @get_state: get the current PWM state. This function is only
 *	       called once per PWM device when the PWM chip is
 *	       registered.
 * @dbg_show: optional routine to show contents in debugfs
 * @owner: helps prevent removal of modules exporting active PWMs
 */
struct pwm_ops {
	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
	void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
		      int duty_ns, int period_ns);
	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
			    enum pwm_polarity polarity);
	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,
		       struct pwm_capture *result, unsigned long timeout);
	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,
		     struct pwm_state *state);
	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
			  struct pwm_state *state);
#ifdef CONFIG_DEBUG_FS
	void (*dbg_show)(struct pwm_chip *chip, struct seq_file *s);
#endif
	struct module *owner;
};

/**
 * struct pwm_chip - abstract a PWM controller
 * @dev: device providing the PWMs
 * @list: list node for internal use
 * @ops: callbacks for this PWM controller
 * @base: number of first PWM controlled by this chip
 * @npwm: number of PWMs controlled by this chip
 * @pwms: array of PWM devices allocated by the framework
 * @of_xlate: request a PWM device given a device tree PWM specifier
 * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier
 * @can_sleep: must be true if the .config(), .enable() or .disable()
 *             operations may sleep
 */
struct pwm_chip {
	struct device *dev;
	struct list_head list;
	const struct pwm_ops *ops;
	int base;
	unsigned int npwm;

	struct pwm_device *pwms;

	struct pwm_device * (*of_xlate)(struct pwm_chip *pc,
					const struct of_phandle_args *args);
	unsigned int of_pwm_n_cells;
	bool can_sleep;
};

/**
 * struct pwm_capture - PWM capture data
 * @period: period of the PWM signal (in nanoseconds)
 * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
 */
struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

#if IS_ENABLED(CONFIG_PWM)
/* PWM user APIs */
struct pwm_device *pwm_request(int pwm_id, const char *label);
void pwm_free(struct pwm_device *pwm);
int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state);
int pwm_adjust_config(struct pwm_device *pwm);

/**
 * pwm_config() - change a PWM device configuration
 * @pwm: PWM device
 * @duty_ns: "on" time (in nanoseconds)
 * @period_ns: duration (in nanoseconds) of one cycle
 *
 * Returns: 0 on success or a negative error code on failure.
 */
static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
			     int period_ns)
{
	struct pwm_state state;

	if (!pwm)
		return -EINVAL;

	if (duty_ns < 0 || period_ns < 0)
		return -EINVAL;

	pwm_get_state(pwm, &state);
	if (state.duty_cycle == duty_ns && state.period == period_ns)
		return 0;

	state.duty_cycle = duty_ns;
	state.period = period_ns;
	return pwm_apply_state(pwm, &state);
}

/**
 * pwm_set_polarity() - configure the polarity of a PWM signal
 * @pwm: PWM device
 * @polarity: new polarity of the PWM signal
 *
 * Note that the polarity cannot be configured while the PWM device is
 * enabled.
 *
 * Returns: 0 on success or a negative error code on failure.
 */
static inline int pwm_set_polarity(struct pwm_device *pwm,
				   enum pwm_polarity polarity)
{
	struct pwm_state state;

	if (!pwm)
		return -EINVAL;

	pwm_get_state(pwm, &state);
	if (state.polarity == polarity)
		return 0;

	/*
	 * Changing the polarity of a running PWM without adjusting the
	 * dutycycle/period value is a bit risky (can introduce glitches).
	 * Return -EBUSY in this case.
	 * Note that this is allowed when using pwm_apply_state() because
	 * the user specifies all the parameters.
	 */
	if (state.enabled)
		return -EBUSY;

	state.polarity = polarity;
	return pwm_apply_state(pwm, &state);
}

/**
 * pwm_enable() - start a PWM output toggling
 * @pwm: PWM device
 *
 * Returns: 0 on success or a negative error code on failure.
 */
static inline int pwm_enable(struct pwm_device *pwm)
{
	struct pwm_state state;

	if (!pwm)
		return -EINVAL;

	pwm_get_state(pwm, &state);
	if (state.enabled)
		return 0;

	state.enabled = true;
	return pwm_apply_state(pwm, &state);
}

/**
 * pwm_disable() - stop a PWM output toggling
 * @pwm: PWM device
 */
static inline void pwm_disable(struct pwm_device *pwm)
{
	struct pwm_state state;

	if (!pwm)
		return;

	pwm_get_state(pwm, &state);
	if (!state.enabled)
		return;

	state.enabled = false;
	pwm_apply_state(pwm, &state);
}

/* PWM provider APIs */
int pwm_capture(struct pwm_device *pwm, struct pwm_capture *result,
		unsigned long timeout);
int pwm_set_chip_data(struct pwm_device *pwm, void *data);
void *pwm_get_chip_data(struct pwm_device *pwm);

int pwmchip_add_with_polarity(struct pwm_chip *chip,
			      enum pwm_polarity polarity);
int pwmchip_add(struct pwm_chip *chip);
int pwmchip_remove(struct pwm_chip *chip);
struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
					 unsigned int index,
					 const char *label);

struct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *pc,
		const struct of_phandle_args *args);

struct pwm_device *pwm_get(struct device *dev, const char *con_id);
struct pwm_device *of_pwm_get(struct device_node *np, const char *con_id);
void pwm_put(struct pwm_device *pwm);

struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np,
				   const char *con_id);
void devm_pwm_put(struct device *dev, struct pwm_device *pwm);

bool pwm_can_sleep(struct pwm_device *pwm);
#else
static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
{
	return ERR_PTR(-ENODEV);
}

static inline void pwm_free(struct pwm_device *pwm)
{
}

static inline int pwm_apply_state(struct pwm_device *pwm,
				  const struct pwm_state *state)
{
	return -ENOTSUPP;
}

static inline int pwm_adjust_config(struct pwm_device *pwm)
{
	return -ENOTSUPP;
}

static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
			     int period_ns)
{
	return -EINVAL;
}

static inline int pwm_capture(struct pwm_device *pwm,
			      struct pwm_capture *result,
			      unsigned long timeout)
{
	return -EINVAL;
}

static inline int pwm_set_polarity(struct pwm_device *pwm,
				   enum pwm_polarity polarity)
{
	return -ENOTSUPP;
}

static inline int pwm_enable(struct pwm_device *pwm)
{
	return -EINVAL;
}

static inline void pwm_disable(struct pwm_device *pwm)
{
}

static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)
{
	return -EINVAL;
}

static inline void *pwm_get_chip_data(struct pwm_device *pwm)
{
	return NULL;
}

static inline int pwmchip_add(struct pwm_chip *chip)
{
	return -EINVAL;
}

static inline int pwmchip_add_inversed(struct pwm_chip *chip)
{
	return -EINVAL;
}

static inline int pwmchip_remove(struct pwm_chip *chip)
{
	return -EINVAL;
}

static inline struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
						       unsigned int index,
						       const char *label)
{
	return ERR_PTR(-ENODEV);
}

static inline struct pwm_device *pwm_get(struct device *dev,
					 const char *consumer)
{
	return ERR_PTR(-ENODEV);
}

static inline struct pwm_device *of_pwm_get(struct device_node *np,
					    const char *con_id)
{
	return ERR_PTR(-ENODEV);
}

static inline void pwm_put(struct pwm_device *pwm)
{
}

static inline struct pwm_device *devm_pwm_get(struct device *dev,
					      const char *consumer)
{
	return ERR_PTR(-ENODEV);
}

static inline struct pwm_device *devm_of_pwm_get(struct device *dev,
						 struct device_node *np,
						 const char *con_id)
{
	return ERR_PTR(-ENODEV);
}

static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
{
}

static inline bool pwm_can_sleep(struct pwm_device *pwm)
{
	return false;
}
#endif

static inline void pwm_apply_args(struct pwm_device *pwm)
{
	struct pwm_state state = { };

	/*
	 * PWM users calling pwm_apply_args() expect to have a fresh config
	 * where the polarity and period are set according to pwm_args info.
	 * The problem is, polarity can only be changed when the PWM is
	 * disabled.
	 *
	 * PWM drivers supporting hardware readout may declare the PWM device
	 * as enabled, and prevent polarity setting, which changes from the
	 * existing behavior, where all PWM devices are declared as disabled
	 * at startup (even if they are actually enabled), thus authorizing
	 * polarity setting.
	 *
	 * To fulfill this requirement, we apply a new state which disables
	 * the PWM device and set the reference period and polarity config.
	 *
	 * Note that PWM users requiring a smooth handover between the
	 * bootloader and the kernel (like critical regulators controlled by
	 * PWM devices) will have to switch to the atomic API and avoid calling
	 * pwm_apply_args().
	 */

	state.enabled = false;
	state.polarity = pwm->args.polarity;
	state.period = pwm->args.period;

	pwm_apply_state(pwm, &state);
}

struct pwm_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
	unsigned int period;
	enum pwm_polarity polarity;
};

#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id, _period, _polarity) \
	{						\
		.provider = _provider,			\
		.index = _index,			\
		.dev_id = _dev_id,			\
		.con_id = _con_id,			\
		.period = _period,			\
		.polarity = _polarity			\
	}

#if IS_ENABLED(CONFIG_PWM)
void pwm_add_table(struct pwm_lookup *table, size_t num);
void pwm_remove_table(struct pwm_lookup *table, size_t num);
#else
static inline void pwm_add_table(struct pwm_lookup *table, size_t num)
{
}

static inline void pwm_remove_table(struct pwm_lookup *table, size_t num)
{
}
#endif

#ifdef CONFIG_PWM_SYSFS
void pwmchip_sysfs_export(struct pwm_chip *chip);
void pwmchip_sysfs_unexport(struct pwm_chip *chip);
void pwmchip_sysfs_unexport_children(struct pwm_chip *chip);
#else
static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
{
}

static inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)
{
}

static inline void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
{
}
#endif /* CONFIG_PWM_SYSFS */

#endif /* __LINUX_PWM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #ifndef _LINUX_LIST_NULLS_H
#define _LINUX_LIST_NULLS_H

#include <linux/poison.h>
#include <linux/const.h>

/*
 * Special version of lists, where end of list is not a NULL pointer,
 * but a 'nulls' marker, which can have many different values.
 * (up to 2^31 different values guaranteed on all platforms)
 *
 * In the standard hlist, termination of a list is the NULL pointer.
 * In this special 'nulls' variant, we use the fact that objects stored in
 * a list are aligned on a word (4 or 8 bytes alignment).
 * We therefore use the last significant bit of 'ptr' :
 * Set to 1 : This is a 'nulls' end-of-list marker (ptr >> 1)
 * Set to 0 : This is a pointer to some object (ptr)
 */

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next, **pprev;
};
#define NULLS_MARKER(value) (1UL | (((long)value) << 1))
#define INIT_HLIST_NULLS_HEAD(ptr, nulls) \
	((ptr)->first = (struct hlist_nulls_node *) NULLS_MARKER(nulls))

#define hlist_nulls_entry(ptr, type, member) container_of(ptr,type,member)
/**
 * ptr_is_a_nulls - Test if a ptr is a nulls
 * @ptr: ptr to be tested
 *
 */
static inline int is_a_nulls(const struct hlist_nulls_node *ptr)
{
	return ((unsigned long)ptr & 1);
}

/**
 * get_nulls_value - Get the 'nulls' value of the end of chain
 * @ptr: end of chain
 *
 * Should be called only if is_a_nulls(ptr);
 */
static inline unsigned long get_nulls_value(const struct hlist_nulls_node *ptr)
{
	return ((unsigned long)ptr) >> 1;
}

static inline int hlist_nulls_unhashed(const struct hlist_nulls_node *h)
{
	return !h->pprev;
}

static inline int hlist_nulls_empty(const struct hlist_nulls_head *h)
{
	return is_a_nulls(READ_ONCE(h->first));
}

static inline void hlist_nulls_add_head(struct hlist_nulls_node *n,
					struct hlist_nulls_head *h)
{
	struct hlist_nulls_node *first = h->first;

	n->next = first;
	n->pprev = &h->first;
	h->first = n;
	if (!is_a_nulls(first))
		first->pprev = &n->next;
}

static inline void __hlist_nulls_del(struct hlist_nulls_node *n)
{
	struct hlist_nulls_node *next = n->next;
	struct hlist_nulls_node **pprev = n->pprev;

	WRITE_ONCE(*pprev, next);
	if (!is_a_nulls(next))
		next->pprev = pprev;
}

static inline void hlist_nulls_del(struct hlist_nulls_node *n)
{
	__hlist_nulls_del(n);
	n->pprev = LIST_POISON2;
}

/**
 * hlist_nulls_for_each_entry	- iterate over list of given type
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct hlist_node to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 *
 */
#define hlist_nulls_for_each_entry(tpos, pos, head, member)		       \
	for (pos = (head)->first;					       \
	     (!is_a_nulls(pos)) &&					       \
		({ tpos = hlist_nulls_entry(pos, typeof(*tpos), member); 1;}); \
	     pos = pos->next)

/**
 * hlist_nulls_for_each_entry_from - iterate over a hlist continuing from current point
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct hlist_node to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 *
 */
#define hlist_nulls_for_each_entry_from(tpos, pos, member)	\
	for (; (!is_a_nulls(pos)) && 				\
		({ tpos = hlist_nulls_entry(pos, typeof(*tpos), member); 1;}); \
	     pos = pos->next)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef COMPONENT_H
#define COMPONENT_H

#include <linux/stddef.h>

struct device;

struct component_ops {
	int (*bind)(struct device *comp, struct device *master,
		    void *master_data);
	void (*unbind)(struct device *comp, struct device *master,
		       void *master_data);
};

int component_add(struct device *, const struct component_ops *);
void component_del(struct device *, const struct component_ops *);

int component_bind_all(struct device *master, void *master_data);
void component_unbind_all(struct device *master, void *master_data);

struct master;

struct component_master_ops {
	int (*bind)(struct device *master);
	void (*unbind)(struct device *master);
};

void component_master_del(struct device *,
	const struct component_master_ops *);

struct component_match;

int component_master_add_with_match(struct device *,
	const struct component_master_ops *, struct component_match *);
void component_match_add_release(struct device *master,
	struct component_match **matchptr,
	void (*release)(struct device *, void *),
	int (*compare)(struct device *, void *), void *compare_data);

static inline void component_match_add(struct device *master,
	struct component_match **matchptr,
	int (*compare)(struct device *, void *), void *compare_data)
{
	component_match_add_release(master, matchptr, NULL, compare,
				    compare_data);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __LINUX_COMPILER_H
#error "Please don't include <linux/compiler-gcc.h> directly, include <linux/compiler.h> instead."
#endif

/*
 * Common definitions for all gcc versions go here.
 */
#define GCC_VERSION (__GNUC__ * 10000		\
		     + __GNUC_MINOR__ * 100	\
		     + __GNUC_PATCHLEVEL__)

/* Optimization barrier */

/* The "volatile" is due to gcc bugs */
#define barrier() __asm__ __volatile__("": : :"memory")
/*
 * This version is i.e. to prevent dead stores elimination on @ptr
 * where gcc and llvm may behave differently when otherwise using
 * normal barrier(): while gcc behavior gets along with a normal
 * barrier(), llvm needs an explicit input variable to be assumed
 * clobbered. The issue is as follows: while the inline asm might
 * access any memory it wants, the compiler could have fit all of
 * @ptr into memory registers instead, and since @ptr never escaped
 * from that, it proofed that the inline asm wasn't touching any of
 * it. This version works well with both compilers, i.e. we're telling
 * the compiler that the inline asm absolutely may see the contents
 * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495
 */
#define barrier_data(ptr) __asm__ __volatile__("": :"r"(ptr) :"memory")

/*
 * This macro obfuscates arithmetic on a variable address so that gcc
 * shouldn't recognize the original var, and make assumptions about it.
 *
 * This is needed because the C standard makes it undefined to do
 * pointer arithmetic on "objects" outside their boundaries and the
 * gcc optimizers assume this is the case. In particular they
 * assume such arithmetic does not wrap.
 *
 * A miscompilation has been observed because of this on PPC.
 * To work around it we hide the relationship of the pointer and the object
 * using this macro.
 *
 * Versions of the ppc64 compiler before 4.1 had a bug where use of
 * RELOC_HIDE could trash r30. The bug can be worked around by changing
 * the inline assembly constraint from =g to =r, in this particular
 * case either is valid.
 */
#define RELOC_HIDE(ptr, off)						\
({									\
	unsigned long __ptr;						\
	__asm__ ("" : "=r"(__ptr) : "0"(ptr));				\
	(typeof(ptr)) (__ptr + (off));					\
})

/* Make the optimizer believe the variable can be manipulated arbitrarily. */
#define OPTIMIZER_HIDE_VAR(var)						\
	__asm__ ("" : "=r" (var) : "0" (var))

#ifdef __CHECKER__
#define __must_be_array(a)	0
#else
/* &a[0] degrades to a pointer: a different type from an array */
#define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
#endif

/*
 * Force always-inline if the user requests it so via the .config,
 * or if gcc is too old:
 */
#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||		\
    !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ < 4)
#define inline		inline		__attribute__((always_inline)) notrace
#define __inline__	__inline__	__attribute__((always_inline)) notrace
#define __inline	__inline	__attribute__((always_inline)) notrace
#else
/* A lot of inline functions can cause havoc with function tracing */
#define inline		inline		notrace
#define __inline__	__inline__	notrace
#define __inline	__inline	notrace
#endif

#define __always_inline	inline __attribute__((always_inline))
#define  noinline	__attribute__((noinline))

#define __deprecated	__attribute__((deprecated))
#define __packed	__attribute__((packed))
#define __weak		__attribute__((weak))
#define __alias(symbol)	__attribute__((alias(#symbol)))

/*
 * it doesn't make sense on ARM (currently the only user of __naked)
 * to trace naked functions because then mcount is called without
 * stack and frame pointer being set up and there is no chance to
 * restore the lr register to the value before mcount was called.
 *
 * The asm() bodies of naked functions often depend on standard calling
 * conventions, therefore they must be noinline and noclone.
 *
 * GCC 4.[56] currently fail to enforce this, so we must do so ourselves.
 * See GCC PR44290.
 */
#define __naked		__attribute__((naked)) noinline __noclone notrace

#define __noreturn	__attribute__((noreturn))

/*
 * From the GCC manual:
 *
 * Many functions have no effects except the return value and their
 * return value depends only on the parameters and/or global
 * variables.  Such a function can be subject to common subexpression
 * elimination and loop optimization just as an arithmetic operator
 * would be.
 * [...]
 */
#define __pure			__attribute__((pure))
#define __aligned(x)		__attribute__((aligned(x)))
#define __printf(a, b)		__attribute__((format(printf, a, b)))
#define __scanf(a, b)		__attribute__((format(scanf, a, b)))
#define __attribute_const__	__attribute__((__const__))
#define __maybe_unused		__attribute__((unused))
#define __always_unused		__attribute__((unused))

/* gcc version specific checks */

#if GCC_VERSION < 30200
# error Sorry, your compiler is too old - please upgrade it.
#endif

#if GCC_VERSION < 30300
# define __used			__attribute__((__unused__))
#else
# define __used			__attribute__((__used__))
#endif

#ifdef CONFIG_GCOV_KERNEL
# if GCC_VERSION < 30400
#   error "GCOV profiling support for gcc versions below 3.4 not included"
# endif /* __GNUC_MINOR__ */
#endif /* CONFIG_GCOV_KERNEL */

#if GCC_VERSION >= 30400
#define __must_check		__attribute__((warn_unused_result))
#define __malloc		__attribute__((__malloc__))
#endif

#if GCC_VERSION >= 40000

/* GCC 4.1.[01] miscompiles __weak */
#ifdef __KERNEL__
# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
#  error Your version of gcc miscompiles the __weak directive
# endif
#endif

#define __used			__attribute__((__used__))
#define __compiler_offsetof(a, b)					\
	__builtin_offsetof(a, b)

#if GCC_VERSION >= 40100
# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
#endif

#if GCC_VERSION >= 40300
/* Mark functions as cold. gcc will assume any path leading to a call
 * to them will be unlikely.  This means a lot of manual unlikely()s
 * are unnecessary now for any paths leading to the usual suspects
 * like BUG(), printk(), panic() etc. [but let's keep them for now for
 * older compilers]
 *
 * Early snapshots of gcc 4.3 don't support this and we can't detect this
 * in the preprocessor, but we can live with this because they're unreleased.
 * Maketime probing would be overkill here.
 *
 * gcc also has a __attribute__((__hot__)) to move hot functions into
 * a special section, but I don't see any sense in this right now in
 * the kernel context
 */
#define __cold			__attribute__((__cold__))

#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)

#ifndef __CHECKER__
# define __compiletime_warning(message) __attribute__((warning(message)))
# define __compiletime_error(message) __attribute__((error(message)))
#endif /* __CHECKER__ */
#endif /* GCC_VERSION >= 40300 */

#if GCC_VERSION >= 40500

#ifndef __CHECKER__
#ifdef LATENT_ENTROPY_PLUGIN
#define __latent_entropy __attribute__((latent_entropy))
#endif
#endif

/*
 * Mark a position in code as unreachable.  This can be used to
 * suppress control flow warnings after asm blocks that transfer
 * control elsewhere.
 *
 * Early snapshots of gcc 4.5 don't support this and we can't detect
 * this in the preprocessor, but we can live with this because they're
 * unreleased.  Really, we need to have autoconf for the kernel.
 */
#define unreachable() __builtin_unreachable()

/* Mark a function definition as prohibited from being cloned. */
#define __noclone	__attribute__((__noclone__, __optimize__("no-tracer")))

#endif /* GCC_VERSION >= 40500 */

#if GCC_VERSION >= 40600
/*
 * When used with Link Time Optimization, gcc can optimize away C functions or
 * variables which are referenced only from assembly code.  __visible tells the
 * optimizer that something else uses this function or variable, thus preventing
 * this.
 */
#define __visible	__attribute__((externally_visible))
#endif


#if GCC_VERSION >= 40900 && !defined(__CHECKER__)
/*
 * __assume_aligned(n, k): Tell the optimizer that the returned
 * pointer can be assumed to be k modulo n. The second argument is
 * optional (default 0), so we use a variadic macro to make the
 * shorthand.
 *
 * Beware: Do not apply this to functions which may return
 * ERR_PTRs. Also, it is probably unwise to apply it to functions
 * returning extra information in the low bits (but in that case the
 * compiler should see some alignment anyway, when the return value is
 * massaged by 'flags = ptr & 3; ptr &= ~3;').
 */
#define __assume_aligned(a, ...) __attribute__((__assume_aligned__(a, ## __VA_ARGS__)))
#endif

/*
 * GCC 'asm goto' miscompiles certain code sequences:
 *
 *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
 *
 * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
 *
 * (asm goto is automatically volatile - the naming reflects this.)
 */
#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)

/*
 * sparse (__CHECKER__) pretends to be gcc, but can't do constant
 * folding in __builtin_bswap*() (yet), so don't set these for it.
 */
#if defined(CONFIG_ARCH_USE_BUILTIN_BSWAP) && !defined(__CHECKER__)
#if GCC_VERSION >= 40400
#define __HAVE_BUILTIN_BSWAP32__
#define __HAVE_BUILTIN_BSWAP64__
#endif
#if GCC_VERSION >= 40800
#define __HAVE_BUILTIN_BSWAP16__
#endif
#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP && !__CHECKER__ */

#if GCC_VERSION >= 70000
#define KASAN_ABI_VERSION 5
#elif GCC_VERSION >= 50000
#define KASAN_ABI_VERSION 4
#elif GCC_VERSION >= 40902
#define KASAN_ABI_VERSION 3
#endif

#if GCC_VERSION >= 40902
/*
 * Tell the compiler that address safety instrumentation (KASAN)
 * should not be applied to that function.
 * Conflicts with inlining: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368
 */
#define __no_sanitize_address __attribute__((no_sanitize_address))
#endif

#endif	/* gcc version >= 40000 specific checks */

#if !defined(__noclone)
#define __noclone	/* not needed */
#endif

#if !defined(__no_sanitize_address)
#define __no_sanitize_address
#endif

/*
 * A trick to suppress uninitialized variable warning without generating any
 * code
 */
#define uninitialized_var(x) x = x
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * pm_domain.h - Definitions and headers related to device power domains.
 *
 * Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
 *
 * This file is released under the GPLv2.
 */

#ifndef _LINUX_PM_DOMAIN_H
#define _LINUX_PM_DOMAIN_H

#include <linux/device.h>
#include <linux/mutex.h>
#include <linux/pm.h>
#include <linux/err.h>
#include <linux/of.h>
#include <linux/notifier.h>

/* Defines used for the flags field in the struct generic_pm_domain */
#define GENPD_FLAG_PM_CLK	(1U << 0) /* PM domain uses PM clk */

#define GENPD_MAX_NUM_STATES	8 /* Number of possible low power states */

enum gpd_status {
	GPD_STATE_ACTIVE = 0,	/* PM domain is active */
	GPD_STATE_POWER_OFF,	/* PM domain is off */
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *domain);
	bool (*suspend_ok)(struct device *dev);
};

struct gpd_dev_ops {
	int (*start)(struct device *dev);
	int (*stop)(struct device *dev);
	bool (*active_wakeup)(struct device *dev);
};

struct genpd_power_state {
	s64 power_off_latency_ns;
	s64 power_on_latency_ns;
};

struct generic_pm_domain {
	struct dev_pm_domain domain;	/* PM domain operations */
	struct list_head gpd_list_node;	/* Node in the global PM domains list */
	struct list_head master_links;	/* Links with PM domain as a master */
	struct list_head slave_links;	/* Links with PM domain as a slave */
	struct list_head dev_list;	/* List of devices */
	struct mutex lock;
	struct dev_power_governor *gov;
	struct work_struct power_off_work;
	struct fwnode_handle *provider;	/* Identity of the domain provider */
	bool has_provider;
	const char *name;
	atomic_t sd_count;	/* Number of subdomains with power "on" */
	enum gpd_status status;	/* Current state of the domain */
	unsigned int device_count;	/* Number of devices */
	unsigned int suspended_count;	/* System suspend device counter */
	unsigned int prepared_count;	/* Suspend counter of prepared devices */
	int (*power_off)(struct generic_pm_domain *domain);
	int (*power_on)(struct generic_pm_domain *domain);
	struct gpd_dev_ops dev_ops;
	s64 max_off_time_ns;	/* Maximum allowed "suspended" time. */
	bool max_off_time_changed;
	bool cached_power_down_ok;
	int (*attach_dev)(struct generic_pm_domain *domain,
			  struct device *dev);
	void (*detach_dev)(struct generic_pm_domain *domain,
			   struct device *dev);
	unsigned int flags;		/* Bit field of configs for genpd */
	struct genpd_power_state states[GENPD_MAX_NUM_STATES];
	unsigned int state_count; /* number of states */
	unsigned int state_idx; /* state that genpd will go to when off */

};

static inline struct generic_pm_domain *pd_to_genpd(struct dev_pm_domain *pd)
{
	return container_of(pd, struct generic_pm_domain, domain);
}

struct gpd_link {
	struct generic_pm_domain *master;
	struct list_head master_node;
	struct generic_pm_domain *slave;
	struct list_head slave_node;
};

struct gpd_timing_data {
	s64 suspend_latency_ns;
	s64 resume_latency_ns;
	s64 effective_constraint_ns;
	bool constraint_changed;
	bool cached_suspend_ok;
};

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

struct generic_pm_domain_data {
	struct pm_domain_data base;
	struct gpd_timing_data td;
	struct notifier_block nb;
};

#ifdef CONFIG_PM_GENERIC_DOMAINS
static inline struct generic_pm_domain_data *to_gpd_data(struct pm_domain_data *pdd)
{
	return container_of(pdd, struct generic_pm_domain_data, base);
}

static inline struct generic_pm_domain_data *dev_gpd_data(struct device *dev)
{
	return to_gpd_data(dev->power.subsys_data->domain_data);
}

extern int __pm_genpd_add_device(struct generic_pm_domain *genpd,
				 struct device *dev,
				 struct gpd_timing_data *td);

extern int pm_genpd_remove_device(struct generic_pm_domain *genpd,
				  struct device *dev);
extern int pm_genpd_add_subdomain(struct generic_pm_domain *genpd,
				  struct generic_pm_domain *new_subdomain);
extern int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,
				     struct generic_pm_domain *target);
extern int pm_genpd_init(struct generic_pm_domain *genpd,
			 struct dev_power_governor *gov, bool is_off);
extern int pm_genpd_remove(struct generic_pm_domain *genpd);

extern struct dev_power_governor simple_qos_governor;
extern struct dev_power_governor pm_domain_always_on_gov;
#else

static inline struct generic_pm_domain_data *dev_gpd_data(struct device *dev)
{
	return ERR_PTR(-ENOSYS);
}
static inline int __pm_genpd_add_device(struct generic_pm_domain *genpd,
					struct device *dev,
					struct gpd_timing_data *td)
{
	return -ENOSYS;
}
static inline int pm_genpd_remove_device(struct generic_pm_domain *genpd,
					 struct device *dev)
{
	return -ENOSYS;
}
static inline int pm_genpd_add_subdomain(struct generic_pm_domain *genpd,
					 struct generic_pm_domain *new_sd)
{
	return -ENOSYS;
}
static inline int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,
					    struct generic_pm_domain *target)
{
	return -ENOSYS;
}
static inline int pm_genpd_init(struct generic_pm_domain *genpd,
				struct dev_power_governor *gov, bool is_off)
{
	return -ENOSYS;
}
static inline int pm_genpd_remove(struct generic_pm_domain *genpd)
{
	return -ENOTSUPP;
}
#endif

static inline int pm_genpd_add_device(struct generic_pm_domain *genpd,
				      struct device *dev)
{
	return __pm_genpd_add_device(genpd, dev, NULL);
}

#ifdef CONFIG_PM_GENERIC_DOMAINS_SLEEP
extern void pm_genpd_syscore_poweroff(struct device *dev);
extern void pm_genpd_syscore_poweron(struct device *dev);
#else
static inline void pm_genpd_syscore_poweroff(struct device *dev) {}
static inline void pm_genpd_syscore_poweron(struct device *dev) {}
#endif

/* OF PM domain providers */
struct of_device_id;

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
};

#ifdef CONFIG_PM_GENERIC_DOMAINS_OF
int of_genpd_add_provider_simple(struct device_node *np,
				 struct generic_pm_domain *genpd);
int of_genpd_add_provider_onecell(struct device_node *np,
				  struct genpd_onecell_data *data);
void of_genpd_del_provider(struct device_node *np);
extern int of_genpd_add_device(struct of_phandle_args *args,
			       struct device *dev);
extern int of_genpd_add_subdomain(struct of_phandle_args *parent,
				  struct of_phandle_args *new_subdomain);
extern struct generic_pm_domain *of_genpd_remove_last(struct device_node *np);

int genpd_dev_pm_attach(struct device *dev);
#else /* !CONFIG_PM_GENERIC_DOMAINS_OF */
static inline int of_genpd_add_provider_simple(struct device_node *np,
					struct generic_pm_domain *genpd)
{
	return -ENOTSUPP;
}

static inline int of_genpd_add_provider_onecell(struct device_node *np,
					struct genpd_onecell_data *data)
{
	return -ENOTSUPP;
}

static inline void of_genpd_del_provider(struct device_node *np) {}

static inline int of_genpd_add_device(struct of_phandle_args *args,
				      struct device *dev)
{
	return -ENODEV;
}

static inline int of_genpd_add_subdomain(struct of_phandle_args *parent,
					 struct of_phandle_args *new_subdomain)
{
	return -ENODEV;
}

static inline int genpd_dev_pm_attach(struct device *dev)
{
	return -ENODEV;
}

static inline
struct generic_pm_domain *of_genpd_remove_last(struct device_node *np)
{
	return ERR_PTR(-ENOTSUPP);
}
#endif /* CONFIG_PM_GENERIC_DOMAINS_OF */

#ifdef CONFIG_PM
extern int dev_pm_domain_attach(struct device *dev, bool power_on);
extern void dev_pm_domain_detach(struct device *dev, bool power_off);
extern void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd);
#else
static inline int dev_pm_domain_attach(struct device *dev, bool power_on)
{
	return -ENODEV;
}
static inline void dev_pm_domain_detach(struct device *dev, bool power_off) {}
static inline void dev_pm_domain_set(struct device *dev,
				     struct dev_pm_domain *pd) {}
#endif

#endif /* _LINUX_PM_DOMAIN_H */
                                                                                                                                                                                                                                                                                                                                                       /*
 *	Definitions of structures and functions for quota formats using trie
 */

#ifndef _LINUX_DQBLK_QTREE_H
#define _LINUX_DQBLK_QTREE_H

#include <linux/types.h>

/* Numbers of blocks needed for updates - we count with the smallest
 * possible block size (1024) */
#define QTREE_INIT_ALLOC 4
#define QTREE_INIT_REWRITE 2
#define QTREE_DEL_ALLOC 0
#define QTREE_DEL_REWRITE 6

struct dquot;
struct kqid;

/* Operations */
struct qtree_fmt_operations {
	void (*mem2disk_dqblk)(void *disk, struct dquot *dquot);	/* Convert given entry from in memory format to disk one */
	void (*disk2mem_dqblk)(struct dquot *dquot, void *disk);	/* Convert given entry from disk format to in memory one */
	int (*is_id)(void *disk, struct dquot *dquot);	/* Is this structure for given id? */
};

/* Inmemory copy of version specific information */
struct qtree_mem_dqinfo {
	struct super_block *dqi_sb;	/* Sb quota is on */
	int dqi_type;			/* Quota type */
	unsigned int dqi_blocks;	/* # of blocks in quota file */
	unsigned int dqi_free_blk;	/* First block in list of free blocks */
	unsigned int dqi_free_entry;	/* First block with free entry */
	unsigned int dqi_blocksize_bits;	/* Block size of quota file */
	unsigned int dqi_entry_size;	/* Size of quota entry in quota file */
	unsigned int dqi_usable_bs;	/* Space usable in block for quota data */
	unsigned int dqi_qtree_depth;	/* Precomputed depth of quota tree */
	const struct qtree_fmt_operations *dqi_ops; /* Operations for entry manipulation */
};

int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk);
static inline int qtree_depth(struct qtree_mem_dqinfo *info)
{
	unsigned int epb = info->dqi_usable_bs >> 2;
	unsigned long long entries = epb;
	int i;

	for (i = 1; entries < (1ULL << 32); i++)
		entries *= epb;
	return i;
}
int qtree_get_next_id(struct qtree_mem_dqinfo *info, struct kqid *qid);

#endif /* _LINUX_DQBLK_QTREE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_RANGE_H
#define _LINUX_RANGE_H

struct range {
	u64   start;
	u64   end;
};

int add_range(struct range *range, int az, int nr_range,
		u64 start, u64 end);


int add_range_with_merge(struct range *range, int az, int nr_range,
				u64 start, u64 end);

void subtract_range(struct range *range, int az, u64 start, u64 end);

int clean_sort_range(struct range *range, int az);

void sort_range(struct range *range, int nr_range);

#define MAX_RESOURCE ((resource_size_t)~0)
static inline resource_size_t cap_resource(u64 val)
{
	if (val > MAX_RESOURCE)
		return MAX_RESOURCE;

	return val;
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* -*- linux-c -*-
 * include/linux/ipipe.h
 *
 * Copyright (C) 2002-2014 Philippe Gerum.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
 * USA; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#ifndef __LINUX_IPIPE_H
#define __LINUX_IPIPE_H

#include <linux/spinlock.h>
#include <linux/cache.h>
#include <linux/percpu.h>
#include <linux/irq.h>
#include <linux/thread_info.h>
#include <linux/ipipe_base.h>
#include <linux/ipipe_debug.h>
#include <asm/ptrace.h>
#include <asm/ipipe.h>

#ifdef CONFIG_IPIPE

#include <linux/ipipe_domain.h>

/* ipipe_set_hooks(..., enables) */
#define IPIPE_SYSCALL	__IPIPE_SYSCALL_E
#define IPIPE_TRAP	__IPIPE_TRAP_E
#define IPIPE_KEVENT	__IPIPE_KEVENT_E

struct ipipe_sysinfo {
	int sys_nr_cpus;	/* Number of CPUs on board */
	int sys_hrtimer_irq;	/* hrtimer device IRQ */
	u64 sys_hrtimer_freq;	/* hrtimer device frequency */
	u64 sys_hrclock_freq;	/* hrclock device frequency */
	u64 sys_cpu_freq;	/* CPU frequency (Hz) */
	struct ipipe_arch_sysinfo arch;
};

struct ipipe_work_header {
	size_t size;
	void (*handler)(struct ipipe_work_header *work);
};

extern unsigned int __ipipe_printk_virq;

void __ipipe_set_irq_pending(struct ipipe_domain *ipd, unsigned int irq);

void __ipipe_complete_domain_migration(void);

int __ipipe_switch_tail(void);

void __ipipe_share_current(int flags);

void __ipipe_arch_share_current(int flags);

int __ipipe_migrate_head(void);

void __ipipe_reenter_root(void);

int __ipipe_disable_ondemand_mappings(struct task_struct *p);

int __ipipe_pin_vma(struct mm_struct *mm, struct vm_area_struct *vma);

#ifdef CONFIG_IPIPE_WANT_PREEMPTIBLE_SWITCH

#define prepare_arch_switch(next)			\
	do {						\
		hard_local_irq_enable();		\
		__ipipe_report_schedule(current, next);	\
	} while(0)

#ifndef ipipe_get_active_mm
static inline struct mm_struct *ipipe_get_active_mm(void)
{
	return __this_cpu_read(ipipe_percpu.active_mm);
}
#define ipipe_get_active_mm ipipe_get_active_mm
#endif

#else /* !CONFIG_IPIPE_WANT_PREEMPTIBLE_SWITCH */

#define prepare_arch_switch(next)			\
	do {						\
		__ipipe_report_schedule(current, next);	\
		hard_local_irq_disable();		\
	} while(0)

#ifndef ipipe_get_active_mm
#define ipipe_get_active_mm()	(current->active_mm)
#endif

#endif /* !CONFIG_IPIPE_WANT_PREEMPTIBLE_SWITCH */

#ifdef CONFIG_IPIPE_WANT_CLOCKSOURCE

extern unsigned long long __ipipe_cs_freq;

extern struct clocksource *__ipipe_cs;

#endif /* CONFIG_IPIPE_WANT_CLOCKSOURCE */

static inline bool __ipipe_hrclock_ok(void)
{
	return __ipipe_hrclock_freq != 0;
}

static inline void __ipipe_nmi_enter(void)
{
	__this_cpu_write(ipipe_percpu.nmi_state, __ipipe_root_status);
	__set_bit(IPIPE_STALL_FLAG, &__ipipe_root_status);
	ipipe_save_context_nmi();
}

static inline void __ipipe_nmi_exit(void)
{
	ipipe_restore_context_nmi();
	if (!test_bit(IPIPE_STALL_FLAG, raw_cpu_ptr(&ipipe_percpu.nmi_state)))
		__clear_bit(IPIPE_STALL_FLAG, &__ipipe_root_status);
}

/* KVM-side calls, hw IRQs off. */
static inline void __ipipe_enter_vm(struct ipipe_vm_notifier *vmf)
{
	struct ipipe_percpu_data *p;

	p = raw_cpu_ptr(&ipipe_percpu);
	p->vm_notifier = vmf;
	barrier();
}

static inline void __ipipe_exit_vm(void)
{
	struct ipipe_percpu_data *p;

	p = raw_cpu_ptr(&ipipe_percpu);
	p->vm_notifier = NULL;
	barrier();
}

/* Client-side call, hw IRQs off. */
void __ipipe_notify_vm_preemption(void);

static inline void __ipipe_sync_pipeline(struct ipipe_domain *top)
{
	if (__ipipe_current_domain != top) {
		__ipipe_do_sync_pipeline(top);
		return;
	}
	if (!test_bit(IPIPE_STALL_FLAG, &ipipe_this_cpu_context(top)->status))
		__ipipe_sync_stage();
}

void ipipe_register_head(struct ipipe_domain *ipd,
			 const char *name);

void ipipe_unregister_head(struct ipipe_domain *ipd);

int ipipe_request_irq(struct ipipe_domain *ipd,
		      unsigned int irq,
		      ipipe_irq_handler_t handler,
		      void *cookie,
		      ipipe_irq_ackfn_t ackfn);

void ipipe_free_irq(struct ipipe_domain *ipd,
		    unsigned int irq);

void ipipe_raise_irq(unsigned int irq);

int ipipe_handle_syscall(struct thread_info *ti,
			 unsigned long nr, struct pt_regs *regs);

void ipipe_set_hooks(struct ipipe_domain *ipd,
		     int enables);

unsigned int ipipe_alloc_virq(void);

void ipipe_free_virq(unsigned int virq);

static inline void ipipe_post_irq_head(unsigned int irq)
{
	__ipipe_set_irq_pending(ipipe_head_domain, irq);
}

static inline void ipipe_post_irq_root(unsigned int irq)
{
	__ipipe_set_irq_pending(&ipipe_root, irq);
}

static inline void ipipe_stall_head(void)
{
	hard_local_irq_disable();
	__set_bit(IPIPE_STALL_FLAG, &__ipipe_head_status);
}

static inline unsigned long ipipe_test_and_stall_head(void)
{
	hard_local_irq_disable();
	return __test_and_set_bit(IPIPE_STALL_FLAG, &__ipipe_head_status);
}

static inline unsigned long ipipe_test_head(void)
{
	unsigned long flags, ret;

	flags = hard_smp_local_irq_save();
	ret = test_bit(IPIPE_STALL_FLAG, &__ipipe_head_status);
	hard_smp_local_irq_restore(flags);

	return ret;
}

void ipipe_unstall_head(void);

void __ipipe_restore_head(unsigned long x);

static inline void ipipe_restore_head(unsigned long x)
{
	ipipe_check_irqoff();
	if ((x ^ test_bit(IPIPE_STALL_FLAG, &__ipipe_head_status)) & 1)
		__ipipe_restore_head(x);
}

void __ipipe_post_work_root(struct ipipe_work_header *work);

#define ipipe_post_work_root(p, header)			\
	do {						\
		void header_not_at_start(void);		\
		if (offsetof(typeof(*(p)), header)) {	\
			header_not_at_start();		\
		}					\
		__ipipe_post_work_root(&(p)->header);	\
	} while (0)

int ipipe_get_sysinfo(struct ipipe_sysinfo *sysinfo);

unsigned long ipipe_critical_enter(void (*syncfn)(void));

void ipipe_critical_exit(unsigned long flags);

void ipipe_prepare_panic(void);

#ifdef CONFIG_SMP
#ifndef ipipe_smp_p
#define ipipe_smp_p (1)
#endif
void ipipe_set_irq_affinity(unsigned int irq, cpumask_t cpumask);
void ipipe_send_ipi(unsigned int ipi, cpumask_t cpumask);
#else  /* !CONFIG_SMP */
#define ipipe_smp_p (0)
static inline
void ipipe_set_irq_affinity(unsigned int irq, cpumask_t cpumask) { }
static inline void ipipe_send_ipi(unsigned int ipi, cpumask_t cpumask) { }
static inline void ipipe_disable_smp(void) { }
#endif	/* CONFIG_SMP */

static inline void ipipe_restore_root_nosync(unsigned long x)
{
	unsigned long flags;

	flags = hard_smp_local_irq_save();
	__ipipe_restore_root_nosync(x);
	hard_smp_local_irq_restore(flags);
}

/* Must be called hw IRQs off. */
static inline void ipipe_lock_irq(unsigned int irq)
{
	struct ipipe_domain *ipd = __ipipe_current_domain;
	if (ipd == ipipe_root_domain)
		__ipipe_lock_irq(irq);
}

/* Must be called hw IRQs off. */
static inline void ipipe_unlock_irq(unsigned int irq)
{
	struct ipipe_domain *ipd = __ipipe_current_domain;
	if (ipd == ipipe_root_domain)
		__ipipe_unlock_irq(irq);
}

static inline struct ipipe_threadinfo *ipipe_current_threadinfo(void)
{
	return &current_thread_info()->ipipe_data;
}

#define ipipe_task_threadinfo(p) (&task_thread_info(p)->ipipe_data)

void ipipe_enable_irq(unsigned int irq);

static inline void ipipe_disable_irq(unsigned int irq)
{
	struct irq_desc *desc;
	struct irq_chip *chip;

	desc = irq_to_desc(irq);
	if (desc == NULL)
		return;

	chip = irq_desc_get_chip(desc);

	if (WARN_ON_ONCE(chip->irq_disable == NULL && chip->irq_mask == NULL))
		return;

	if (chip->irq_disable)
		chip->irq_disable(&desc->irq_data);
	else
		chip->irq_mask(&desc->irq_data);
}

static inline void ipipe_end_irq(unsigned int irq)
{
	struct irq_desc *desc = irq_to_desc(irq);

	if (desc)
		desc->ipipe_end(desc);
}

static inline int ipipe_chained_irq_p(struct irq_desc *desc)
{
	void __ipipe_chained_irq(struct irq_desc *desc);

	return desc->handle_irq == __ipipe_chained_irq;
}

static inline void ipipe_handle_demuxed_irq(unsigned int cascade_irq)
{
	ipipe_trace_irq_entry(cascade_irq);
	__ipipe_dispatch_irq(cascade_irq, IPIPE_IRQF_NOSYNC);
	ipipe_trace_irq_exit(cascade_irq);
}

static inline void __ipipe_init_threadflags(struct thread_info *ti)
{
	ti->ipipe_flags = 0;
}

static inline
void ipipe_set_ti_thread_flag(struct thread_info *ti, int flag)
{
	set_bit(flag, &ti->ipipe_flags);
}

static inline
void ipipe_clear_ti_thread_flag(struct thread_info *ti, int flag)
{
	clear_bit(flag, &ti->ipipe_flags);
}

static inline
void ipipe_test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
{
	test_and_clear_bit(flag, &ti->ipipe_flags);
}

static inline
int ipipe_test_ti_thread_flag(struct thread_info *ti, int flag)
{
	return test_bit(flag, &ti->ipipe_flags);
}

#define ipipe_set_thread_flag(flag) \
	ipipe_set_ti_thread_flag(current_thread_info(), flag)

#define ipipe_clear_thread_flag(flag) \
	ipipe_clear_ti_thread_flag(current_thread_info(), flag)

#define ipipe_test_and_clear_thread_flag(flag) \
	ipipe_test_and_clear_ti_thread_flag(current_thread_info(), flag)

#define ipipe_test_thread_flag(flag) \
	ipipe_test_ti_thread_flag(current_thread_info(), flag)

#define ipipe_enable_notifier(p)					\
	ipipe_set_ti_thread_flag(task_thread_info(p), TIP_NOTIFY)

#define ipipe_disable_notifier(p)					\
	do {								\
		struct thread_info *ti = task_thread_info(p);		\
		ipipe_clear_ti_thread_flag(ti, TIP_NOTIFY);		\
		ipipe_clear_ti_thread_flag(ti, TIP_MAYDAY);		\
	} while (0)

#define ipipe_notifier_enabled_p(p)					\
	ipipe_test_ti_thread_flag(task_thread_info(p), TIP_NOTIFY)

#define ipipe_raise_mayday(p)						\
	do {								\
		struct thread_info *ti = task_thread_info(p);		\
		ipipe_check_irqoff();					\
		if (ipipe_test_ti_thread_flag(ti, TIP_NOTIFY))		\
			ipipe_set_ti_thread_flag(ti, TIP_MAYDAY);	\
	} while (0)

extern bool __ipipe_probe_access;

long ipipe_probe_kernel_read(void *dst, void *src, size_t size);
long ipipe_probe_kernel_write(void *dst, void *src, size_t size);

#if defined(CONFIG_DEBUG_ATOMIC_SLEEP) || defined(CONFIG_PROVE_LOCKING) || \
	defined(CONFIG_PREEMPT_VOLUNTARY) || defined(CONFIG_IPIPE_DEBUG_CONTEXT)
extern void __ipipe_uaccess_might_fault(void);
#else
#define __ipipe_uaccess_might_fault() might_fault()
#endif

#ifdef CONFIG_IPIPE_TRACE
void __ipipe_tracer_hrclock_initialized(void);
#else /* !CONFIG_IPIPE_TRACE */
#define __ipipe_tracer_hrclock_initialized()	do { } while(0)
#endif /* !CONFIG_IPIPE_TRACE */

#include <linux/ipipe_compat.h>

#else	/* !CONFIG_IPIPE */

#define __ipipe_root_p		1
#define ipipe_root_p		1

static inline void __ipipe_init_threadflags(struct thread_info *ti) { }

static inline void __ipipe_complete_domain_migration(void) { }

static inline int __ipipe_switch_tail(void)
{
	return 0;
}

static inline void __ipipe_nmi_enter(void) { }

static inline void __ipipe_nmi_exit(void) { }

#define ipipe_safe_current()	current
#define ipipe_processor_id()	smp_processor_id()

static inline int ipipe_test_foreign_stack(void)
{
	return 0;
}

static inline void ipipe_lock_irq(unsigned int irq) { }

static inline void ipipe_unlock_irq(unsigned int irq) { }

#define ipipe_probe_kernel_read(d, s, sz)	probe_kernel_read(d, s, sz)
#define ipipe_probe_kernel_write(d, s, sz)	probe_kernel_write(d, s, sz)
#define __ipipe_uaccess_might_fault()		might_fault()

static inline int ipipe_handle_syscall(struct thread_info *ti,
				       unsigned long nr, struct pt_regs *regs)
{
	return 0;
}

#endif	/* !CONFIG_IPIPE */

#endif	/* !__LINUX_IPIPE_H */
                                                                                                                                                                                                                                                                                                                                                             /*
 * Dynamic queue limits (dql) - Definitions
 *
 * Copyright (c) 2011, Tom Herbert <therbert@google.com>
 *
 * This header file contains the definitions for dynamic queue limits (dql).
 * dql would be used in conjunction with a producer/consumer type queue
 * (possibly a HW queue).  Such a queue would have these general properties:
 *
 *   1) Objects are queued up to some limit specified as number of objects.
 *   2) Periodically a completion process executes which retires consumed
 *      objects.
 *   3) Starvation occurs when limit has been reached, all queued data has
 *      actually been consumed, but completion processing has not yet run
 *      so queuing new data is blocked.
 *   4) Minimizing the amount of queued data is desirable.
 *
 * The goal of dql is to calculate the limit as the minimum number of objects
 * needed to prevent starvation.
 *
 * The primary functions of dql are:
 *    dql_queued - called when objects are enqueued to record number of objects
 *    dql_avail - returns how many objects are available to be queued based
 *      on the object limit and how many objects are already enqueued
 *    dql_completed - called at completion time to indicate how many objects
 *      were retired from the queue
 *
 * The dql implementation does not implement any locking for the dql data
 * structures, the higher layer should provide this.  dql_queued should
 * be serialized to prevent concurrent execution of the function; this
 * is also true for  dql_completed.  However, dql_queued and dlq_completed  can
 * be executed concurrently (i.e. they can be protected by different locks).
 */

#ifndef _LINUX_DQL_H
#define _LINUX_DQL_H

#ifdef __KERNEL__

struct dql {
	/* Fields accessed in enqueue path (dql_queued) */
	unsigned int	num_queued;		/* Total ever queued */
	unsigned int	adj_limit;		/* limit + num_completed */
	unsigned int	last_obj_cnt;		/* Count at last queuing */

	/* Fields accessed only by completion path (dql_completed) */

	unsigned int	limit ____cacheline_aligned_in_smp; /* Current limit */
	unsigned int	num_completed;		/* Total ever completed */

	unsigned int	prev_ovlimit;		/* Previous over limit */
	unsigned int	prev_num_queued;	/* Previous queue total */
	unsigned int	prev_last_obj_cnt;	/* Previous queuing cnt */

	unsigned int	lowest_slack;		/* Lowest slack found */
	unsigned long	slack_start_time;	/* Time slacks seen */

	/* Configuration */
	unsigned int	max_limit;		/* Max limit */
	unsigned int	min_limit;		/* Minimum limit */
	unsigned int	slack_hold_time;	/* Time to measure slack */
};

/* Set some static maximums */
#define DQL_MAX_OBJECT (UINT_MAX / 16)
#define DQL_MAX_LIMIT ((UINT_MAX / 2) - DQL_MAX_OBJECT)

/*
 * Record number of objects queued. Assumes that caller has already checked
 * availability in the queue with dql_avail.
 */
static inline void dql_queued(struct dql *dql, unsigned int count)
{
	BUG_ON(count > DQL_MAX_OBJECT);

	dql->last_obj_cnt = count;

	/* We want to force a write first, so that cpu do not attempt
	 * to get cache line containing last_obj_cnt, num_queued, adj_limit
	 * in Shared state, but directly does a Request For Ownership
	 * It is only a hint, we use barrier() only.
	 */
	barrier();

	dql->num_queued += count;
}

/* Returns how many objects can be queued, < 0 indicates over limit. */
static inline int dql_avail(const struct dql *dql)
{
	return ACCESS_ONCE(dql->adj_limit) - ACCESS_ONCE(dql->num_queued);
}

/* Record number of completed objects and recalculate the limit. */
void dql_completed(struct dql *dql, unsigned int count);

/* Reset dql state */
void dql_reset(struct dql *dql);

/* Initialize dql state */
int dql_init(struct dql *dql, unsigned hold_time);

#endif /* _KERNEL_ */

#endif /* _LINUX_DQL_H */
                                                                                                                                                                                                                                                                                                                                                          #ifndef _LINUX_U64_STATS_SYNC_H
#define _LINUX_U64_STATS_SYNC_H

/*
 * To properly implement 64bits network statistics on 32bit and 64bit hosts,
 * we provide a synchronization point, that is a noop on 64bit or UP kernels.
 *
 * Key points :
 * 1) Use a seqcount on SMP 32bits, with low overhead.
 * 2) Whole thing is a noop on 64bit arches or UP kernels.
 * 3) Write side must ensure mutual exclusion or one seqcount update could
 *    be lost, thus blocking readers forever.
 *    If this synchronization point is not a mutex, but a spinlock or
 *    spinlock_bh() or disable_bh() :
 * 3.1) Write side should not sleep.
 * 3.2) Write side should not allow preemption.
 * 3.3) If applicable, interrupts should be disabled.
 *
 * 4) If reader fetches several counters, there is no guarantee the whole values
 *    are consistent (remember point 1) : this is a noop on 64bit arches anyway)
 *
 * 5) readers are allowed to sleep or be preempted/interrupted : They perform
 *    pure reads. But if they have to fetch many values, it's better to not allow
 *    preemptions/interruptions to avoid many retries.
 *
 * 6) If counter might be written by an interrupt, readers should block interrupts.
 *    (On UP, there is no seqcount_t protection, a reader allowing interrupts could
 *     read partial values)
 *
 * 7) For irq and softirq uses, readers can use u64_stats_fetch_begin_irq() and
 *    u64_stats_fetch_retry_irq() helpers
 *
 * Usage :
 *
 * Stats producer (writer) should use following template granted it already got
 * an exclusive access to counters (a lock is already taken, or per cpu
 * data is used [in a non preemptable context])
 *
 *   spin_lock_bh(...) or other synchronization to get exclusive access
 *   ...
 *   u64_stats_update_begin(&stats->syncp);
 *   stats->bytes64 += len; // non atomic operation
 *   stats->packets64++;    // non atomic operation
 *   u64_stats_update_end(&stats->syncp);
 *
 * While a consumer (reader) should use following template to get consistent
 * snapshot for each variable (but no guarantee on several ones)
 *
 * u64 tbytes, tpackets;
 * unsigned int start;
 *
 * do {
 *         start = u64_stats_fetch_begin(&stats->syncp);
 *         tbytes = stats->bytes64; // non atomic operation
 *         tpackets = stats->packets64; // non atomic operation
 * } while (u64_stats_fetch_retry(&stats->syncp, start));
 *
 *
 * Example of use in drivers/net/loopback.c, using per_cpu containers,
 * in BH disabled context.
 */
#include <linux/seqlock.h>

struct u64_stats_sync {
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	seqcount_t	seq;
#endif
};


static inline void u64_stats_init(struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
	seqcount_init(&syncp->seq);
#endif
}

static inline void u64_stats_update_begin(struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	write_seqcount_begin(&syncp->seq);
#endif
}

static inline void u64_stats_update_end(struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	write_seqcount_end(&syncp->seq);
#endif
}

static inline void u64_stats_update_begin_raw(struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	raw_write_seqcount_begin(&syncp->seq);
#endif
}

static inline void u64_stats_update_end_raw(struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	raw_write_seqcount_end(&syncp->seq);
#endif
}

static inline unsigned int __u64_stats_fetch_begin(const struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	return read_seqcount_begin(&syncp->seq);
#else
	return 0;
#endif
}

static inline unsigned int u64_stats_fetch_begin(const struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
	preempt_disable();
#endif
	return __u64_stats_fetch_begin(syncp);
}

static inline bool __u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
					 unsigned int start)
{
#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
	return read_seqcount_retry(&syncp->seq, start);
#else
	return false;
#endif
}

static inline bool u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
					 unsigned int start)
{
#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
	preempt_enable();
#endif
	return __u64_stats_fetch_retry(syncp, start);
}

/*
 * In case irq handlers can update u64 counters, readers can use following helpers
 * - SMP 32bit arches use seqcount protection, irq safe.
 * - UP 32bit must disable irqs.
 * - 64bit have no problem atomically reading u64 values, irq safe.
 */
static inline unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync *syncp)
{
#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
	local_irq_disable();
#endif
	return __u64_stats_fetch_begin(syncp);
}

static inline bool u64_stats_fetch_retry_irq(const struct u64_stats_sync *syncp,
					     unsigned int start)
{
#if BITS_PER_LONG==32 && !defined(CONFIG_SMP)
	local_irq_enable();
#endif
	return __u64_stats_fetch_retry(syncp, start);
}

#endif /* _LINUX_U64_STATS_SYNC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #ifndef _LINUX_IOMMU_HELPER_H
#define _LINUX_IOMMU_HELPER_H

#include <linux/kernel.h>

static inline unsigned long iommu_device_max_index(unsigned long size,
						   unsigned long offset,
						   u64 dma_mask)
{
	if (size + offset > dma_mask)
		return dma_mask - offset + 1;
	else
		return size;
}

extern int iommu_is_span_boundary(unsigned int index, unsigned int nr,
				  unsigned long shift,
				  unsigned long boundary_size);
extern unsigned long iommu_area_alloc(unsigned long *map, unsigned long size,
				      unsigned long start, unsigned int nr,
				      unsigned long shift,
				      unsigned long boundary_size,
				      unsigned long align_mask);

static inline unsigned long iommu_num_pages(unsigned long addr,
					    unsigned long len,
					    unsigned long io_page_size)
{
	unsigned long size = (addr & (io_page_size - 1)) + len;

	return DIV_ROUND_UP(size, io_page_size);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * PCI HotPlug Core Functions
 *
 * Copyright (C) 1995,2001 Compaq Computer Corporation
 * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
 * Copyright (C) 2001 IBM Corp.
 *
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
 * NON INFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Send feedback to <kristen.c.accardi@intel.com>
 *
 */
#ifndef _PCI_HOTPLUG_H
#define _PCI_HOTPLUG_H

/**
 * struct hotplug_slot_ops -the callbacks that the hotplug pci core can use
 * @owner: The module owner of this structure
 * @mod_name: The module name (KBUILD_MODNAME) of this structure
 * @enable_slot: Called when the user wants to enable a specific pci slot
 * @disable_slot: Called when the user wants to disable a specific pci slot
 * @set_attention_status: Called to set the specific slot's attention LED to
 * the specified value
 * @hardware_test: Called to run a specified hardware test on the specified
 * slot.
 * @get_power_status: Called to get the current power status of a slot.
 *	If this field is NULL, the value passed in the struct hotplug_slot_info
 *	will be used when this value is requested by a user.
 * @get_attention_status: Called to get the current attention status of a slot.
 *	If this field is NULL, the value passed in the struct hotplug_slot_info
 *	will be used when this value is requested by a user.
 * @get_latch_status: Called to get the current latch status of a slot.
 *	If this field is NULL, the value passed in the struct hotplug_slot_info
 *	will be used when this value is requested by a user.
 * @get_adapter_status: Called to get see if an adapter is present in the slot or not.
 *	If this field is NULL, the value passed in the struct hotplug_slot_info
 *	will be used when this value is requested by a user.
 * @reset_slot: Optional interface to allow override of a bus reset for the
 *	slot for cases where a secondary bus reset can result in spurious
 *	hotplug events or where a slot can be reset independent of the bus.
 *
 * The table of function pointers that is passed to the hotplug pci core by a
 * hotplug pci driver.  These functions are called by the hotplug pci core when
 * the user wants to do something to a specific slot (query it for information,
 * set an LED, enable / disable power, etc.)
 */
struct hotplug_slot_ops {
	struct module *owner;
	const char *mod_name;
	int (*enable_slot)		(struct hotplug_slot *slot);
	int (*disable_slot)		(struct hotplug_slot *slot);
	int (*set_attention_status)	(struct hotplug_slot *slot, u8 value);
	int (*hardware_test)		(struct hotplug_slot *slot, u32 value);
	int (*get_power_status)		(struct hotplug_slot *slot, u8 *value);
	int (*get_attention_status)	(struct hotplug_slot *slot, u8 *value);
	int (*get_latch_status)		(struct hotplug_slot *slot, u8 *value);
	int (*get_adapter_status)	(struct hotplug_slot *slot, u8 *value);
	int (*reset_slot)		(struct hotplug_slot *slot, int probe);
};

/**
 * struct hotplug_slot_info - used to notify the hotplug pci core of the state of the slot
 * @power_status: if power is enabled or not (1/0)
 * @attention_status: if the attention light is enabled or not (1/0)
 * @latch_status: if the latch (if any) is open or closed (1/0)
 * @adapter_status: if there is a pci board present in the slot or not (1/0)
 *
 * Used to notify the hotplug pci core of the status of a specific slot.
 */
struct hotplug_slot_info {
	u8	power_status;
	u8	attention_status;
	u8	latch_status;
	u8	adapter_status;
};

/**
 * struct hotplug_slot - used to register a physical slot with the hotplug pci core
 * @ops: pointer to the &struct hotplug_slot_ops to be used for this slot
 * @info: pointer to the &struct hotplug_slot_info for the initial values for
 * this slot.
 * @release: called during pci_hp_deregister to free memory allocated in a
 * hotplug_slot structure.
 * @private: used by the hotplug pci controller driver to store whatever it
 * needs.
 */
struct hotplug_slot {
	struct hotplug_slot_ops		*ops;
	struct hotplug_slot_info	*info;
	void (*release) (struct hotplug_slot *slot);
	void				*private;

	/* Variables below this are for use only by the hotplug pci core. */
	struct list_head		slot_list;
	struct pci_slot			*pci_slot;
};

static inline const char *hotplug_slot_name(const struct hotplug_slot *slot)
{
	return pci_slot_name(slot->pci_slot);
}

int __pci_hp_register(struct hotplug_slot *slot, struct pci_bus *pbus, int nr,
		      const char *name, struct module *owner,
		      const char *mod_name);
int pci_hp_deregister(struct hotplug_slot *slot);
int __must_check pci_hp_change_slot_info(struct hotplug_slot *slot,
					 struct hotplug_slot_info *info);

/* use a define to avoid include chaining to get THIS_MODULE & friends */
#define pci_hp_register(slot, pbus, devnr, name) \
	__pci_hp_register(slot, pbus, devnr, name, THIS_MODULE, KBUILD_MODNAME)

/* PCI Setting Record (Type 0) */
struct hpp_type0 {
	u32 revision;
	u8  cache_line_size;
	u8  latency_timer;
	u8  enable_serr;
	u8  enable_perr;
};

/* PCI-X Setting Record (Type 1) */
struct hpp_type1 {
	u32 revision;
	u8  max_mem_read;
	u8  avg_max_split;
	u16 tot_max_split;
};

/* PCI Express Setting Record (Type 2) */
struct hpp_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hotplug_params {
	struct hpp_type0 *t0;		/* Type0: NULL if not available */
	struct hpp_type1 *t1;		/* Type1: NULL if not available */
	struct hpp_type2 *t2;		/* Type2: NULL if not available */
	struct hpp_type0 type0_data;
	struct hpp_type1 type1_data;
	struct hpp_type2 type2_data;
};

#ifdef CONFIG_ACPI
#include <linux/acpi.h>
int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp);
int acpi_get_hp_hw_control_from_firmware(struct pci_dev *dev, u32 flags);
int acpi_pci_check_ejectable(struct pci_bus *pbus, acpi_handle handle);
int acpi_pci_detect_ejectable(acpi_handle handle);
#else
static inline int pci_get_hp_params(struct pci_dev *dev,
				    struct hotplug_params *hpp)
{
	return -ENODEV;
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (C) 2011 ST-Ericsson SA.
 * Copyright (C) 2009 Motorola, Inc.
 *
 * License Terms: GNU General Public License v2
 *
 * Simple driver for National Semiconductor LM35330 Backlight driver chip
 *
 * Author: Shreshtha Kumar SAHU <shreshthakumar.sahu@stericsson.com>
 * based on leds-lm3530.c by Dan Murphy <D.Murphy@motorola.com>
 */

#ifndef _LINUX_LED_LM3530_H__
#define _LINUX_LED_LM3530_H__

#define LM3530_FS_CURR_5mA		(0) /* Full Scale Current */
#define LM3530_FS_CURR_8mA		(1)
#define LM3530_FS_CURR_12mA		(2)
#define LM3530_FS_CURR_15mA		(3)
#define LM3530_FS_CURR_19mA		(4)
#define LM3530_FS_CURR_22mA		(5)
#define LM3530_FS_CURR_26mA		(6)
#define LM3530_FS_CURR_29mA		(7)

#define LM3530_ALS_AVRG_TIME_32ms	(0) /* ALS Averaging Time */
#define LM3530_ALS_AVRG_TIME_64ms	(1)
#define LM3530_ALS_AVRG_TIME_128ms	(2)
#define LM3530_ALS_AVRG_TIME_256ms	(3)
#define LM3530_ALS_AVRG_TIME_512ms	(4)
#define LM3530_ALS_AVRG_TIME_1024ms	(5)
#define LM3530_ALS_AVRG_TIME_2048ms	(6)
#define LM3530_ALS_AVRG_TIME_4096ms	(7)

#define LM3530_RAMP_TIME_1ms		(0) /* Brigtness Ramp Time */
#define LM3530_RAMP_TIME_130ms		(1) /* Max to 0 and vice versa */
#define LM3530_RAMP_TIME_260ms		(2)
#define LM3530_RAMP_TIME_520ms		(3)
#define LM3530_RAMP_TIME_1s		(4)
#define LM3530_RAMP_TIME_2s		(5)
#define LM3530_RAMP_TIME_4s		(6)
#define LM3530_RAMP_TIME_8s		(7)

/* ALS Resistor Select */
#define LM3530_ALS_IMPD_Z		(0x00) /* ALS Impedance */
#define LM3530_ALS_IMPD_13_53kOhm	(0x01)
#define LM3530_ALS_IMPD_9_01kOhm	(0x02)
#define LM3530_ALS_IMPD_5_41kOhm	(0x03)
#define LM3530_ALS_IMPD_2_27kOhm	(0x04)
#define LM3530_ALS_IMPD_1_94kOhm	(0x05)
#define LM3530_ALS_IMPD_1_81kOhm	(0x06)
#define LM3530_ALS_IMPD_1_6kOhm		(0x07)
#define LM3530_ALS_IMPD_1_138kOhm	(0x08)
#define LM3530_ALS_IMPD_1_05kOhm	(0x09)
#define LM3530_ALS_IMPD_1_011kOhm	(0x0A)
#define LM3530_ALS_IMPD_941Ohm		(0x0B)
#define LM3530_ALS_IMPD_759Ohm		(0x0C)
#define LM3530_ALS_IMPD_719Ohm		(0x0D)
#define LM3530_ALS_IMPD_700Ohm		(0x0E)
#define LM3530_ALS_IMPD_667Ohm		(0x0F)

enum lm3530_mode {
	LM3530_BL_MODE_MANUAL = 0,	/* "man" */
	LM3530_BL_MODE_ALS,		/* "als" */
	LM3530_BL_MODE_PWM,		/* "pwm" */
};

/* ALS input select */
enum lm3530_als_mode {
	LM3530_INPUT_AVRG = 0,	/* ALS1 and ALS2 input average */
	LM3530_INPUT_ALS1,	/* ALS1 Input */
	LM3530_INPUT_ALS2,	/* ALS2 Input */
	LM3530_INPUT_CEIL,	/* Max of ALS1 and ALS2 */
};

/* PWM Platform Specific Data */
struct lm3530_pwm_data {
	void (*pwm_set_intensity) (int brightness, int max_brightness);
	int (*pwm_get_intensity) (int max_brightness);
};

/**
 * struct lm3530_platform_data
 * @mode: mode of operation i.e. Manual, ALS or PWM
 * @als_input_mode: select source of ALS input - ALS1/2 or average
 * @max_current: full scale LED current
 * @pwm_pol_hi: PWM input polarity - active high/active low
 * @als_avrg_time: ALS input averaging time
 * @brt_ramp_law: brightness mapping mode - exponential/linear
 * @brt_ramp_fall: rate of fall of led current
 * @brt_ramp_rise: rate of rise of led current
 * @als1_resistor_sel: internal resistance from ALS1 input to ground
 * @als2_resistor_sel: internal resistance from ALS2 input to ground
 * @als_vmin: als input voltage calibrated for max brightness in mV
 * @als_vmax: als input voltage calibrated for min brightness in mV
 * @brt_val: brightness value (0-127)
 * @pwm_data: PWM control functions (only valid when the mode is PWM)
 */
struct lm3530_platform_data {
	enum lm3530_mode mode;
	enum lm3530_als_mode als_input_mode;

	u8 max_current;
	bool pwm_pol_hi;
	u8 als_avrg_time;

	bool brt_ramp_law;
	u8 brt_ramp_fall;
	u8 brt_ramp_rise;

	u8 als1_resistor_sel;
	u8 als2_resistor_sel;

	u32 als_vmin;
	u32 als_vmax;

	u8 brt_val;

	struct lm3530_pwm_data pwm_data;
};

#endif	/* _LINUX_LED_LM3530_H__ */
                                                                                                                                                                                                                                                                                                               /*
 * Copyright (c) 2015 Mellanox Technologies. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */

#ifndef _LINUX_NVME_RDMA_H
#define _LINUX_NVME_RDMA_H

enum nvme_rdma_cm_fmt {
	NVME_RDMA_CM_FMT_1_0 = 0x0,
};

enum nvme_rdma_cm_status {
	NVME_RDMA_CM_INVALID_LEN	= 0x01,
	NVME_RDMA_CM_INVALID_RECFMT	= 0x02,
	NVME_RDMA_CM_INVALID_QID	= 0x03,
	NVME_RDMA_CM_INVALID_HSQSIZE	= 0x04,
	NVME_RDMA_CM_INVALID_HRQSIZE	= 0x05,
	NVME_RDMA_CM_NO_RSC		= 0x06,
	NVME_RDMA_CM_INVALID_IRD	= 0x07,
	NVME_RDMA_CM_INVALID_ORD	= 0x08,
};

/**
 * struct nvme_rdma_cm_req - rdma connect request
 *
 * @recfmt:        format of the RDMA Private Data
 * @qid:           queue Identifier for the Admin or I/O Queue
 * @hrqsize:       host receive queue size to be created
 * @hsqsize:       host send queue size to be created
 */
struct nvme_rdma_cm_req {
	__le16		recfmt;
	__le16		qid;
	__le16		hrqsize;
	__le16		hsqsize;
	u8		rsvd[24];
};

/**
 * struct nvme_rdma_cm_rep - rdma connect reply
 *
 * @recfmt:        format of the RDMA Private Data
 * @crqsize:       controller receive queue size
 */
struct nvme_rdma_cm_rep {
	__le16		recfmt;
	__le16		crqsize;
	u8		rsvd[28];
};

/**
 * struct nvme_rdma_cm_rej - rdma connect reject
 *
 * @recfmt:        format of the RDMA Private Data
 * @fsts:          error status for the associated connect request
 */
struct nvme_rdma_cm_rej {
	__le16		recfmt;
	__le16		sts;
};

#endif /* _LINUX_NVME_RDMA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * This file is separate from sdb.h, because I want that one to remain
 * unchanged (as far as possible) from the official sdb distribution
 *
 * This file and associated functionality are a playground for me to
 * understand stuff which will later be implemented in more generic places.
 */
#include <linux/sdb.h>

/* This is the union of all currently defined types */
union sdb_record {
	struct sdb_interconnect ic;
	struct sdb_device dev;
	struct sdb_bridge bridge;
	struct sdb_integration integr;
	struct sdb_empty empty;
	struct sdb_synthesis synthesis;
	struct sdb_repo_url repo_url;
};

struct fmc_device;

/* Every sdb table is turned into this structure */
struct sdb_array {
	int len;
	int level;
	unsigned long baseaddr;
	struct fmc_device *fmc;		/* the device that hosts it */
	struct sdb_array *parent;	/* NULL at root */
	union sdb_record *record;	/* copies of the struct */
	struct sdb_array **subtree;	/* only valid for bridge items */
};

extern int fmc_scan_sdb_tree(struct fmc_device *fmc, unsigned long address);
extern void fmc_show_sdb_tree(const struct fmc_device *fmc);
extern signed long fmc_find_sdb_device(struct sdb_array *tree, uint64_t vendor,
				       uint32_t device, unsigned long *sz);
extern int fmc_free_sdb_tree(struct fmc_device *fmc);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * RT Mutexes: blocking mutual exclusion locks with PI support
 *
 * started by Ingo Molnar and Thomas Gleixner:
 *
 *  Copyright (C) 2004-2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>
 *  Copyright (C) 2006, Timesys Corp., Thomas Gleixner <tglx@timesys.com>
 *
 * This file contains the public data structure and API definitions.
 */

#ifndef __LINUX_RT_MUTEX_H
#define __LINUX_RT_MUTEX_H

#include <linux/linkage.h>
#include <linux/rbtree.h>
#include <linux/spinlock_types.h>

extern int max_lock_depth; /* for sysctl */

/**
 * The rt_mutex structure
 *
 * @wait_lock:	spinlock to protect the structure
 * @waiters:	rbtree root to enqueue waiters in priority order
 * @waiters_leftmost: top waiter
 * @owner:	the mutex owner
 */
struct rt_mutex {
	raw_spinlock_t		wait_lock;
	struct rb_root          waiters;
	struct rb_node          *waiters_leftmost;
	struct task_struct	*owner;
#ifdef CONFIG_DEBUG_RT_MUTEXES
	int			save_state;
	const char 		*name, *file;
	int			line;
	void			*magic;
#endif
};

struct rt_mutex_waiter;
struct hrtimer_sleeper;

#ifdef CONFIG_DEBUG_RT_MUTEXES
 extern int rt_mutex_debug_check_no_locks_freed(const void *from,
						unsigned long len);
 extern void rt_mutex_debug_check_no_locks_held(struct task_struct *task);
#else
 static inline int rt_mutex_debug_check_no_locks_freed(const void *from,
						       unsigned long len)
 {
	return 0;
 }
# define rt_mutex_debug_check_no_locks_held(task)	do { } while (0)
#endif

#ifdef CONFIG_DEBUG_RT_MUTEXES
# define __DEBUG_RT_MUTEX_INITIALIZER(mutexname) \
	, .name = #mutexname, .file = __FILE__, .line = __LINE__
# define rt_mutex_init(mutex)			__rt_mutex_init(mutex, __func__)
 extern void rt_mutex_debug_task_free(struct task_struct *tsk);
#else
# define __DEBUG_RT_MUTEX_INITIALIZER(mutexname)
# define rt_mutex_init(mutex)			__rt_mutex_init(mutex, NULL)
# define rt_mutex_debug_task_free(t)			do { } while (0)
#endif

#define __RT_MUTEX_INITIALIZER(mutexname) \
	{ .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(mutexname.wait_lock) \
	, .waiters = RB_ROOT \
	, .owner = NULL \
	__DEBUG_RT_MUTEX_INITIALIZER(mutexname)}

#define DEFINE_RT_MUTEX(mutexname) \
	struct rt_mutex mutexname = __RT_MUTEX_INITIALIZER(mutexname)

/**
 * rt_mutex_is_locked - is the mutex locked
 * @lock: the mutex to be queried
 *
 * Returns 1 if the mutex is locked, 0 if unlocked.
 */
static inline int rt_mutex_is_locked(struct rt_mutex *lock)
{
	return lock->owner != NULL;
}

extern void __rt_mutex_init(struct rt_mutex *lock, const char *name);
extern void rt_mutex_destroy(struct rt_mutex *lock);

extern void rt_mutex_lock(struct rt_mutex *lock);
extern int rt_mutex_lock_interruptible(struct rt_mutex *lock);
extern int rt_mutex_timed_lock(struct rt_mutex *lock,
			       struct hrtimer_sleeper *timeout);

extern int rt_mutex_trylock(struct rt_mutex *lock);

extern void rt_mutex_unlock(struct rt_mutex *lock);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef __LINUX_CPUMASK_H
#define __LINUX_CPUMASK_H

/*
 * Cpumasks provide a bitmap suitable for representing the
 * set of CPU's in a system, one bit position per CPU number.  In general,
 * only nr_cpu_ids (<= NR_CPUS) bits are valid.
 */
#include <linux/kernel.h>
#include <linux/threads.h>
#include <linux/bitmap.h>
#include <linux/bug.h>

/* Don't assign or return these: may not be this big! */
typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;

/**
 * cpumask_bits - get the bits in a cpumask
 * @maskp: the struct cpumask *
 *
 * You should only assume nr_cpu_ids bits of this mask are valid.  This is
 * a macro so it's const-correct.
 */
#define cpumask_bits(maskp) ((maskp)->bits)

/**
 * cpumask_pr_args - printf args to output a cpumask
 * @maskp: cpumask to be printed
 *
 * Can be used to provide arguments for '%*pb[l]' when printing a cpumask.
 */
#define cpumask_pr_args(maskp)		nr_cpu_ids, cpumask_bits(maskp)

#if NR_CPUS == 1
#define nr_cpu_ids		1
#else
extern int nr_cpu_ids;
#endif

#ifdef CONFIG_CPUMASK_OFFSTACK
/* Assuming NR_CPUS is huge, a runtime limit is more efficient.  Also,
 * not all bits may be allocated. */
#define nr_cpumask_bits	nr_cpu_ids
#else
#define nr_cpumask_bits	NR_CPUS
#endif

/*
 * The following particular system cpumasks and operations manage
 * possible, present, active and online cpus.
 *
 *     cpu_possible_mask- has bit 'cpu' set iff cpu is populatable
 *     cpu_present_mask - has bit 'cpu' set iff cpu is populated
 *     cpu_online_mask  - has bit 'cpu' set iff cpu available to scheduler
 *     cpu_active_mask  - has bit 'cpu' set iff cpu available to migration
 *
 *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.
 *
 *  The cpu_possible_mask is fixed at boot time, as the set of CPU id's
 *  that it is possible might ever be plugged in at anytime during the
 *  life of that system boot.  The cpu_present_mask is dynamic(*),
 *  representing which CPUs are currently plugged in.  And
 *  cpu_online_mask is the dynamic subset of cpu_present_mask,
 *  indicating those CPUs available for scheduling.
 *
 *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have
 *  all NR_CPUS bits set, otherwise it is just the set of CPUs that
 *  ACPI reports present at boot.
 *
 *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,
 *  depending on what ACPI reports as currently plugged in, otherwise
 *  cpu_present_mask is just a copy of cpu_possible_mask.
 *
 *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not
 *      hotplug, it's a copy of cpu_possible_mask, hence fixed at boot.
 *
 * Subtleties:
 * 1) UP arch's (NR_CPUS == 1, CONFIG_SMP not defined) hardcode
 *    assumption that their single CPU is online.  The UP
 *    cpu_{online,possible,present}_masks are placebos.  Changing them
 *    will have no useful affect on the following num_*_cpus()
 *    and cpu_*() macros in the UP case.  This ugliness is a UP
 *    optimization - don't waste any instructions or memory references
 *    asking if you're online or how many CPUs there are if there is
 *    only one CPU.
 */

extern struct cpumask __cpu_possible_mask;
extern struct cpumask __cpu_online_mask;
extern struct cpumask __cpu_present_mask;
extern struct cpumask __cpu_active_mask;
#define cpu_possible_mask ((const struct cpumask *)&__cpu_possible_mask)
#define cpu_online_mask   ((const struct cpumask *)&__cpu_online_mask)
#define cpu_present_mask  ((const struct cpumask *)&__cpu_present_mask)
#define cpu_active_mask   ((const struct cpumask *)&__cpu_active_mask)

#if NR_CPUS > 1
#define num_online_cpus()	cpumask_weight(cpu_online_mask)
#define num_possible_cpus()	cpumask_weight(cpu_possible_mask)
#define num_present_cpus()	cpumask_weight(cpu_present_mask)
#define num_active_cpus()	cpumask_weight(cpu_active_mask)
#define cpu_online(cpu)		cpumask_test_cpu((cpu), cpu_online_mask)
#define cpu_possible(cpu)	cpumask_test_cpu((cpu), cpu_possible_mask)
#define cpu_present(cpu)	cpumask_test_cpu((cpu), cpu_present_mask)
#define cpu_active(cpu)		cpumask_test_cpu((cpu), cpu_active_mask)
#else
#define num_online_cpus()	1U
#define num_possible_cpus()	1U
#define num_present_cpus()	1U
#define num_active_cpus()	1U
#define cpu_online(cpu)		((cpu) == 0)
#define cpu_possible(cpu)	((cpu) == 0)
#define cpu_present(cpu)	((cpu) == 0)
#define cpu_active(cpu)		((cpu) == 0)
#endif

/* verify cpu argument to cpumask_* operators */
static inline unsigned int cpumask_check(unsigned int cpu)
{
#ifdef CONFIG_DEBUG_PER_CPU_MAPS
	WARN_ON_ONCE(cpu >= nr_cpumask_bits);
#endif /* CONFIG_DEBUG_PER_CPU_MAPS */
	return cpu;
}

#if NR_CPUS == 1
/* Uniprocessor.  Assume all masks are "1". */
static inline unsigned int cpumask_first(const struct cpumask *srcp)
{
	return 0;
}

/* Valid inputs for n are -1 and 0. */
static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
{
	return n+1;
}

static inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
{
	return n+1;
}

static inline unsigned int cpumask_next_and(int n,
					    const struct cpumask *srcp,
					    const struct cpumask *andp)
{
	return n+1;
}

/* cpu must be a valid cpu, ie 0, so there's no other choice. */
static inline unsigned int cpumask_any_but(const struct cpumask *mask,
					   unsigned int cpu)
{
	return 1;
}

static inline unsigned int cpumask_local_spread(unsigned int i, int node)
{
	return 0;
}

#define for_each_cpu(cpu, mask)			\
	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
#define for_each_cpu_not(cpu, mask)		\
	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
#define for_each_cpu_and(cpu, mask, and)	\
	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask, (void)and)
#else
/**
 * cpumask_first - get the first cpu in a cpumask
 * @srcp: the cpumask pointer
 *
 * Returns >= nr_cpu_ids if no cpus set.
 */
static inline unsigned int cpumask_first(const struct cpumask *srcp)
{
	return find_first_bit(cpumask_bits(srcp), nr_cpumask_bits);
}

/**
 * cpumask_next - get the next cpu in a cpumask
 * @n: the cpu prior to the place to search (ie. return will be > @n)
 * @srcp: the cpumask pointer
 *
 * Returns >= nr_cpu_ids if no further cpus set.
 */
static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
{
	/* -1 is a legal arg here. */
	if (n != -1)
		cpumask_check(n);
	return find_next_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
}

/**
 * cpumask_next_zero - get the next unset cpu in a cpumask
 * @n: the cpu prior to the place to search (ie. return will be > @n)
 * @srcp: the cpumask pointer
 *
 * Returns >= nr_cpu_ids if no further cpus unset.
 */
static inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
{
	/* -1 is a legal arg here. */
	if (n != -1)
		cpumask_check(n);
	return find_next_zero_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
}

int cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);
int cpumask_any_but(const struct cpumask *mask, unsigned int cpu);
unsigned int cpumask_local_spread(unsigned int i, int node);

/**
 * for_each_cpu - iterate over every cpu in a mask
 * @cpu: the (optionally unsigned) integer iterator
 * @mask: the cpumask pointer
 *
 * After the loop, cpu is >= nr_cpu_ids.
 */
#define for_each_cpu(cpu, mask)				\
	for ((cpu) = -1;				\
		(cpu) = cpumask_next((cpu), (mask)),	\
		(cpu) < nr_cpu_ids;)

/**
 * for_each_cpu_not - iterate over every cpu in a complemented mask
 * @cpu: the (optionally unsigned) integer iterator
 * @mask: the cpumask pointer
 *
 * After the loop, cpu is >= nr_cpu_ids.
 */
#define for_each_cpu_not(cpu, mask)				\
	for ((cpu) = -1;					\
		(cpu) = cpumask_next_zero((cpu), (mask)),	\
		(cpu) < nr_cpu_ids;)

extern int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap);

/**
 * for_each_cpu_wrap - iterate over every cpu in a mask, starting at a specified location
 * @cpu: the (optionally unsigned) integer iterator
 * @mask: the cpumask poiter
 * @start: the start location
 *
 * The implementation does not assume any bit in @mask is set (including @start).
 *
 * After the loop, cpu is >= nr_cpu_ids.
 */
#define for_each_cpu_wrap(cpu, mask, start)					\
	for ((cpu) = cpumask_next_wrap((start)-1, (mask), (start), false);	\
	     (cpu) < nr_cpumask_bits;						\
	     (cpu) = cpumask_next_wrap((cpu), (mask), (start), true))

/**
 * for_each_cpu_and - iterate over every cpu in both masks
 * @cpu: the (optionally unsigned) integer iterator
 * @mask: the first cpumask pointer
 * @and: the second cpumask pointer
 *
 * This saves a temporary CPU mask in many places.  It is equivalent to:
 *	struct cpumask tmp;
 *	cpumask_and(&tmp, &mask, &and);
 *	for_each_cpu(cpu, &tmp)
 *		...
 *
 * After the loop, cpu is >= nr_cpu_ids.
 */
#define for_each_cpu_and(cpu, mask, and)				\
	for ((cpu) = -1;						\
		(cpu) = cpumask_next_and((cpu), (mask), (and)),		\
		(cpu) < nr_cpu_ids;)
#endif /* SMP */

#define CPU_BITS_NONE						\
{								\
	[0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL			\
}

#define CPU_BITS_CPU0						\
{								\
	[0] =  1UL						\
}

/**
 * cpumask_set_cpu - set a cpu in a cpumask
 * @cpu: cpu number (< nr_cpu_ids)
 * @dstp: the cpumask pointer
 */
static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
	set_bit(cpumask_check(cpu), cpumask_bits(dstp));
}

/**
 * cpumask_clear_cpu - clear a cpu in a cpumask
 * @cpu: cpu number (< nr_cpu_ids)
 * @dstp: the cpumask pointer
 */
static inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
	clear_bit(cpumask_check(cpu), cpumask_bits(dstp));
}

/**
 * cpumask_test_cpu - test for a cpu in a cpumask
 * @cpu: cpu number (< nr_cpu_ids)
 * @cpumask: the cpumask pointer
 *
 * Returns 1 if @cpu is set in @cpumask, else returns 0
 */
static inline int cpumask_test_cpu(int cpu, const struct cpumask *cpumask)
{
	return test_bit(cpumask_check(cpu), cpumask_bits((cpumask)));
}

/**
 * cpumask_test_and_set_cpu - atomically test and set a cpu in a cpumask
 * @cpu: cpu number (< nr_cpu_ids)
 * @cpumask: the cpumask pointer
 *
 * Returns 1 if @cpu is set in old bitmap of @cpumask, else returns 0
 *
 * test_and_set_bit wrapper for cpumasks.
 */
static inline int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
{
	return test_and_set_bit(cpumask_check(cpu), cpumask_bits(cpumask));
}

/**
 * cpumask_test_and_clear_cpu - atomically test and clear a cpu in a cpumask
 * @cpu: cpu number (< nr_cpu_ids)
 * @cpumask: the cpumask pointer
 *
 * Returns 1 if @cpu is set in old bitmap of @cpumask, else returns 0
 *
 * test_and_clear_bit wrapper for cpumasks.
 */
static inline int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
{
	return test_and_clear_bit(cpumask_check(cpu), cpumask_bits(cpumask));
}

/**
 * cpumask_setall - set all cpus (< nr_cpu_ids) in a cpumask
 * @dstp: the cpumask pointer
 */
static inline void cpumask_setall(struct cpumask *dstp)
{
	bitmap_fill(cpumask_bits(dstp), nr_cpumask_bits);
}

/**
 * cpumask_clear - clear all cpus (< nr_cpu_ids) in a cpumask
 * @dstp: the cpumask pointer
 */
static inline void cpumask_clear(struct cpumask *dstp)
{
	bitmap_zero(cpumask_bits(dstp), nr_cpumask_bits);
}

/**
 * cpumask_and - *dstp = *src1p & *src2p
 * @dstp: the cpumask result
 * @src1p: the first input
 * @src2p: the second input
 *
 * If *@dstp is empty, returns 0, else returns 1
 */
static inline int cpumask_and(struct cpumask *dstp,
			       const struct cpumask *src1p,
			       const struct cpumask *src2p)
{
	return bitmap_and(cpumask_bits(dstp), cpumask_bits(src1p),
				       cpumask_bits(src2p), nr_cpumask_bits);
}

/**
 * cpumask_or - *dstp = *src1p | *src2p
 * @dstp: the cpumask result
 * @src1p: the first input
 * @src2p: the second input
 */
static inline void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,
			      const struct cpumask *src2p)
{
	bitmap_or(cpumask_bits(dstp), cpumask_bits(src1p),
				      cpumask_bits(src2p), nr_cpumask_bits);
}

/**
 * cpumask_xor - *dstp = *src1p ^ *src2p
 * @dstp: the cpumask result
 * @src1p: the first input
 * @src2p: the second input
 */
static inline void cpumask_xor(struct cpumask *dstp,
			       const struct cpumask *src1p,
			       const struct cpumask *src2p)
{
	bitmap_xor(cpumask_bits(dstp), cpumask_bits(src1p),
				       cpumask_bits(src2p), nr_cpumask_bits);
}

/**
 * cpumask_andnot - *dstp = *src1p & ~*src2p
 * @dstp: the cpumask result
 * @src1p: the first input
 * @src2p: the second input
 *
 * If *@dstp is empty, returns 0, else returns 1
 */
static inline int cpumask_andnot(struct cpumask *dstp,
				  const struct cpumask *src1p,
				  const struct cpumask *src2p)
{
	return bitmap_andnot(cpumask_bits(dstp), cpumask_bits(src1p),
					  cpumask_bits(src2p), nr_cpumask_bits);
}

/**
 * cpumask_complement - *dstp = ~*srcp
 * @dstp: the cpumask result
 * @srcp: the input to invert
 */
static inline void cpumask_complement(struct cpumask *dstp,
				      const struct cpumask *srcp)
{
	bitmap_complement(cpumask_bits(dstp), cpumask_bits(srcp),
					      nr_cpumask_bits);
}

/**
 * cpumask_equal - *src1p == *src2p
 * @src1p: the first input
 * @src2p: the second input
 */
static inline bool cpumask_equal(const struct cpumask *src1p,
				const struct cpumask *src2p)
{
	return bitmap_equal(cpumask_bits(src1p), cpumask_bits(src2p),
						 nr_cpumask_bits);
}

/**
 * cpumask_intersects - (*src1p & *src2p) != 0
 * @src1p: the first input
 * @src2p: the second input
 */
static inline bool cpumask_intersects(const struct cpumask *src1p,
				     const struct cpumask *src2p)
{
	return bitmap_intersects(cpumask_bits(src1p), cpumask_bits(src2p),
						      nr_cpumask_bits);
}

/**
 * cpumask_subset - (*src1p & ~*src2p) == 0
 * @src1p: the first input
 * @src2p: the second input
 *
 * Returns 1 if *@src1p is a subset of *@src2p, else returns 0
 */
static inline int cpumask_subset(const struct cpumask *src1p,
				 const struct cpumask *src2p)
{
	return bitmap_subset(cpumask_bits(src1p), cpumask_bits(src2p),
						  nr_cpumask_bits);
}

/**
 * cpumask_empty - *srcp == 0
 * @srcp: the cpumask to that all cpus < nr_cpu_ids are clear.
 */
static inline bool cpumask_empty(const struct cpumask *srcp)
{
	return bitmap_empty(cpumask_bits(srcp), nr_cpumask_bits);
}

/**
 * cpumask_full - *srcp == 0xFFFFFFFF...
 * @srcp: the cpumask to that all cpus < nr_cpu_ids are set.
 */
static inline bool cpumask_full(const struct cpumask *srcp)
{
	return bitmap_full(cpumask_bits(srcp), nr_cpumask_bits);
}

/**
 * cpumask_weight - Count of bits in *srcp
 * @srcp: the cpumask to count bits (< nr_cpu_ids) in.
 */
static inline unsigned int cpumask_weight(const struct cpumask *srcp)
{
	return bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);
}

/**
 * cpumask_shift_right - *dstp = *srcp >> n
 * @dstp: the cpumask result
 * @srcp: the input to shift
 * @n: the number of bits to shift by
 */
static inline void cpumask_shift_right(struct cpumask *dstp,
				       const struct cpumask *srcp, int n)
{
	bitmap_shift_right(cpumask_bits(dstp), cpumask_bits(srcp), n,
					       nr_cpumask_bits);
}

/**
 * cpumask_shift_left - *dstp = *srcp << n
 * @dstp: the cpumask result
 * @srcp: the input to shift
 * @n: the number of bits to shift by
 */
static inline void cpumask_shift_left(struct cpumask *dstp,
				      const struct cpumask *srcp, int n)
{
	bitmap_shift_left(cpumask_bits(dstp), cpumask_bits(srcp), n,
					      nr_cpumask_bits);
}

/**
 * cpumask_copy - *dstp = *srcp
 * @dstp: the result
 * @srcp: the input cpumask
 */
static inline void cpumask_copy(struct cpumask *dstp,
				const struct cpumask *srcp)
{
	bitmap_copy(cpumask_bits(dstp), cpumask_bits(srcp), nr_cpumask_bits);
}

/**
 * cpumask_any - pick a "random" cpu from *srcp
 * @srcp: the input cpumask
 *
 * Returns >= nr_cpu_ids if no cpus set.
 */
#define cpumask_any(srcp) cpumask_first(srcp)

/**
 * cpumask_first_and - return the first cpu from *srcp1 & *srcp2
 * @src1p: the first input
 * @src2p: the second input
 *
 * Returns >= nr_cpu_ids if no cpus set in both.  See also cpumask_next_and().
 */
#define cpumask_first_and(src1p, src2p) cpumask_next_and(-1, (src1p), (src2p))

/**
 * cpumask_any_and - pick a "random" cpu from *mask1 & *mask2
 * @mask1: the first input cpumask
 * @mask2: the second input cpumask
 *
 * Returns >= nr_cpu_ids if no cpus set.
 */
#define cpumask_any_and(mask1, mask2) cpumask_first_and((mask1), (mask2))

/**
 * cpumask_of - the cpumask containing just a given cpu
 * @cpu: the cpu (<= nr_cpu_ids)
 */
#define cpumask_of(cpu) (get_cpu_mask(cpu))

/**
 * cpumask_parse_user - extract a cpumask from a user string
 * @buf: the buffer to extract from
 * @len: the length of the buffer
 * @dstp: the cpumask to set.
 *
 * Returns -errno, or 0 for success.
 */
static inline int cpumask_parse_user(const char __user *buf, int len,
				     struct cpumask *dstp)
{
	return bitmap_parse_user(buf, len, cpumask_bits(dstp), nr_cpumask_bits);
}

/**
 * cpumask_parselist_user - extract a cpumask from a user string
 * @buf: the buffer to extract from
 * @len: the length of the buffer
 * @dstp: the cpumask to set.
 *
 * Returns -errno, or 0 for success.
 */
static inline int cpumask_parselist_user(const char __user *buf, int len,
				     struct cpumask *dstp)
{
	return bitmap_parselist_user(buf, len, cpumask_bits(dstp),
				     nr_cpumask_bits);
}

/**
 * cpumask_parse - extract a cpumask from a string
 * @buf: the buffer to extract from
 * @dstp: the cpumask to set.
 *
 * Returns -errno, or 0 for success.
 */
static inline int cpumask_parse(const char *buf, struct cpumask *dstp)
{
	char *nl = strchr(buf, '\n');
	unsigned int len = nl ? (unsigned int)(nl - buf) : strlen(buf);

	return bitmap_parse(buf, len, cpumask_bits(dstp), nr_cpumask_bits);
}

/**
 * cpulist_parse - extract a cpumask from a user string of ranges
 * @buf: the buffer to extract from
 * @dstp: the cpumask to set.
 *
 * Returns -errno, or 0 for success.
 */
static inline int cpulist_parse(const char *buf, struct cpumask *dstp)
{
	return bitmap_parselist(buf, cpumask_bits(dstp), nr_cpumask_bits);
}

/**
 * cpumask_size - size to allocate for a 'struct cpumask' in bytes
 */
static inline size_t cpumask_size(void)
{
	return BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long);
}

/*
 * cpumask_var_t: struct cpumask for stack usage.
 *
 * Oh, the wicked games we play!  In order to make kernel coding a
 * little more difficult, we typedef cpumask_var_t to an array or a
 * pointer: doing &mask on an array is a noop, so it still works.
 *
 * ie.
 *	cpumask_var_t tmpmask;
 *	if (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))
 *		return -ENOMEM;
 *
 *	  ... use 'tmpmask' like a normal struct cpumask * ...
 *
 *	free_cpumask_var(tmpmask);
 *
 *
 * However, one notable exception is there. alloc_cpumask_var() allocates
 * only nr_cpumask_bits bits (in the other hand, real cpumask_t always has
 * NR_CPUS bits). Therefore you don't have to dereference cpumask_var_t.
 *
 *	cpumask_var_t tmpmask;
 *	if (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))
 *		return -ENOMEM;
 *
 *	var = *tmpmask;
 *
 * This code makes NR_CPUS length memcopy and brings to a memory corruption.
 * cpumask_copy() provide safe copy functionality.
 *
 * Note that there is another evil here: If you define a cpumask_var_t
 * as a percpu variable then the way to obtain the address of the cpumask
 * structure differently influences what this_cpu_* operation needs to be
 * used. Please use this_cpu_cpumask_var_t in those cases. The direct use
 * of this_cpu_ptr() or this_cpu_read() will lead to failures when the
 * other type of cpumask_var_t implementation is configured.
 */
#ifdef CONFIG_CPUMASK_OFFSTACK
typedef struct cpumask *cpumask_var_t;

#define this_cpu_cpumask_var_ptr(x) this_cpu_read(x)

bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);
bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);
bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);
bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);
void alloc_bootmem_cpumask_var(cpumask_var_t *mask);
void free_cpumask_var(cpumask_var_t mask);
void free_bootmem_cpumask_var(cpumask_var_t mask);

#else
typedef struct cpumask cpumask_var_t[1];

#define this_cpu_cpumask_var_ptr(x) this_cpu_ptr(x)

static inline bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
	return true;
}

static inline bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
					  int node)
{
	return true;
}

static inline bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
	cpumask_clear(*mask);
	return true;
}

static inline bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
					  int node)
{
	cpumask_clear(*mask);
	return true;
}

static inline void alloc_bootmem_cpumask_var(cpumask_var_t *mask)
{
}

static inline void free_cpumask_var(cpumask_var_t mask)
{
}

static inline void free_bootmem_cpumask_var(cpumask_var_t mask)
{
}
#endif /* CONFIG_CPUMASK_OFFSTACK */

/* It's common to want to use cpu_all_mask in struct member initializers,
 * so it has to refer to an address rather than a pointer. */
extern const DECLARE_BITMAP(cpu_all_bits, NR_CPUS);
#define cpu_all_mask to_cpumask(cpu_all_bits)

/* First bits of cpu_bit_bitmap are in fact unset. */
#define cpu_none_mask to_cpumask(cpu_bit_bitmap[0])

#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)
#define for_each_online_cpu(cpu)   for_each_cpu((cpu), cpu_online_mask)
#define for_each_present_cpu(cpu)  for_each_cpu((cpu), cpu_present_mask)

/* Wrappers for arch boot code to manipulate normally-constant masks */
void init_cpu_present(const struct cpumask *src);
void init_cpu_possible(const struct cpumask *src);
void init_cpu_online(const struct cpumask *src);

static inline void
set_cpu_possible(unsigned int cpu, bool possible)
{
	if (possible)
		cpumask_set_cpu(cpu, &__cpu_possible_mask);
	else
		cpumask_clear_cpu(cpu, &__cpu_possible_mask);
}

static inline void
set_cpu_present(unsigned int cpu, bool present)
{
	if (present)
		cpumask_set_cpu(cpu, &__cpu_present_mask);
	else
		cpumask_clear_cpu(cpu, &__cpu_present_mask);
}

static inline void
set_cpu_online(unsigned int cpu, bool online)
{
	if (online)
		cpumask_set_cpu(cpu, &__cpu_online_mask);
	else
		cpumask_clear_cpu(cpu, &__cpu_online_mask);
}

static inline void
set_cpu_active(unsigned int cpu, bool active)
{
	if (active)
		cpumask_set_cpu(cpu, &__cpu_active_mask);
	else
		cpumask_clear_cpu(cpu, &__cpu_active_mask);
}


/**
 * to_cpumask - convert an NR_CPUS bitmap to a struct cpumask *
 * @bitmap: the bitmap
 *
 * There are a few places where cpumask_var_t isn't appropriate and
 * static cpumasks must be used (eg. very early boot), yet we don't
 * expose the definition of 'struct cpumask'.
 *
 * This does the conversion, and can be used as a constant initializer.
 */
#define to_cpumask(bitmap)						\
	((struct cpumask *)(1 ? (bitmap)				\
			    : (void *)sizeof(__check_is_bitmap(bitmap))))

static inline int __check_is_bitmap(const unsigned long *bitmap)
{
	return 1;
}

/*
 * Special-case data structure for "single bit set only" constant CPU masks.
 *
 * We pre-generate all the 64 (or 32) possible bit positions, with enough
 * padding to the left and the right, and return the constant pointer
 * appropriately offset.
 */
extern const unsigned long
	cpu_bit_bitmap[BITS_PER_LONG+1][BITS_TO_LONGS(NR_CPUS)];

static inline const struct cpumask *get_cpu_mask(unsigned int cpu)
{
	const unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];
	p -= cpu / BITS_PER_LONG;
	return to_cpumask(p);
}

#define cpu_is_offline(cpu)	unlikely(!cpu_online(cpu))

#if NR_CPUS <= BITS_PER_LONG
#define CPU_BITS_ALL						\
{								\
	[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)	\
}

#else /* NR_CPUS > BITS_PER_LONG */

#define CPU_BITS_ALL						\
{								\
	[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,		\
	[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)	\
}
#endif /* NR_CPUS > BITS_PER_LONG */

/**
 * cpumap_print_to_pagebuf  - copies the cpumask into the buffer either
 *	as comma-separated list of cpus or hex values of cpumask
 * @list: indicates whether the cpumap must be list
 * @mask: the cpumask to copy
 * @buf: the buffer to copy into
 *
 * Returns the length of the (null-terminated) @buf string, zero if
 * nothing is copied.
 */
static inline ssize_t
cpumap_print_to_pagebuf(bool list, char *buf, const struct cpumask *mask)
{
	return bitmap_print_to_pagebuf(list, buf, cpumask_bits(mask),
				      nr_cpu_ids);
}

#if NR_CPUS <= BITS_PER_LONG
#define CPU_MASK_ALL							\
(cpumask_t) { {								\
	[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)	\
} }
#else
#define CPU_MASK_ALL							\
(cpumask_t) { {								\
	[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,			\
	[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)	\
} }
#endif /* NR_CPUS > BITS_PER_LONG */

#define CPU_MASK_NONE							\
(cpumask_t) { {								\
	[0 ... BITS_TO_LONGS(NR_CPUS)-1] =  0UL				\
} }

#define CPU_MASK_CPU0							\
(cpumask_t) { {								\
	[0] =  1UL							\
} }

#endif /* __LINUX_CPUMASK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*   -*- linux-c -*-
 *   include/linux/ipipe_domain.h
 *
 *   Copyright (C) 2007-2012 Philippe Gerum.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
 *   USA; either version 2 of the License, or (at your option) any later
 *   version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#ifndef __LINUX_IPIPE_DOMAIN_H
#define __LINUX_IPIPE_DOMAIN_H

#ifdef CONFIG_IPIPE

#include <linux/mutex.h>
#include <linux/percpu.h>
#include <asm/ptrace.h>

struct task_struct;
struct mm_struct;
struct irq_desc;
struct ipipe_vm_notifier;

#define __IPIPE_SYSCALL_P  0
#define __IPIPE_TRAP_P     1
#define __IPIPE_KEVENT_P   2
#define __IPIPE_SYSCALL_E (1 << __IPIPE_SYSCALL_P)
#define __IPIPE_TRAP_E	  (1 << __IPIPE_TRAP_P)
#define __IPIPE_KEVENT_E  (1 << __IPIPE_KEVENT_P)
#define __IPIPE_ALL_E	   0x7
#define __IPIPE_SYSCALL_R (8 << __IPIPE_SYSCALL_P)
#define __IPIPE_TRAP_R	  (8 << __IPIPE_TRAP_P)
#define __IPIPE_KEVENT_R  (8 << __IPIPE_KEVENT_P)
#define __IPIPE_SHIFT_R	   3
#define __IPIPE_ALL_R	  (__IPIPE_ALL_E << __IPIPE_SHIFT_R)

typedef void (*ipipe_irq_ackfn_t)(struct irq_desc *desc);

struct ipipe_domain {
	int context_offset;
	struct ipipe_irqdesc {
		unsigned long control;
		ipipe_irq_ackfn_t ackfn;
		ipipe_irq_handler_t handler;
		void *cookie;
	} ____cacheline_aligned irqs[IPIPE_NR_IRQS];
	const char *name;
	struct mutex mutex;
	struct ipipe_legacy_context legacy;
};

static inline void *
__ipipe_irq_cookie(struct ipipe_domain *ipd, unsigned int irq)
{
	return ipd->irqs[irq].cookie;
}

static inline ipipe_irq_handler_t
__ipipe_irq_handler(struct ipipe_domain *ipd, unsigned int irq)
{
	return ipd->irqs[irq].handler;
}

extern struct ipipe_domain ipipe_root;

#define ipipe_root_domain (&ipipe_root)

extern struct ipipe_domain *ipipe_head_domain;

struct ipipe_percpu_domain_data {
	unsigned long status;	/* <= Must be first in struct. */
	unsigned long irqpend_himap;
#ifdef __IPIPE_3LEVEL_IRQMAP
	unsigned long irqpend_mdmap[IPIPE_IRQ_MDMAPSZ];
#endif
	unsigned long irqpend_lomap[IPIPE_IRQ_LOMAPSZ];
	unsigned long irqheld_map[IPIPE_IRQ_LOMAPSZ];
	unsigned long irqall[IPIPE_NR_IRQS];
	struct ipipe_domain *domain;
	int coflags;
};

struct ipipe_percpu_data {
	struct ipipe_percpu_domain_data root;
	struct ipipe_percpu_domain_data head;
	struct ipipe_percpu_domain_data *curr;
	struct pt_regs tick_regs;
	int hrtimer_irq;
	struct task_struct *task_hijacked;
	struct task_struct *rqlock_owner;
	struct ipipe_vm_notifier *vm_notifier;
	unsigned long nmi_state;
	struct mm_struct *active_mm;
#ifdef CONFIG_IPIPE_DEBUG_CONTEXT
	int context_check;
	int context_check_saved;
#endif
};

/*
 * CAREFUL: all accessors based on __ipipe_raw_cpu_ptr() you may find
 * in this file should be used only while hw interrupts are off, to
 * prevent from CPU migration regardless of the running domain.
 */
DECLARE_PER_CPU(struct ipipe_percpu_data, ipipe_percpu);

static inline struct ipipe_percpu_domain_data *
__context_of(struct ipipe_percpu_data *p, struct ipipe_domain *ipd)
{
	return (void *)p + ipd->context_offset;
}

/**
 * ipipe_percpu_context - return the address of the pipeline context
 * data for a domain on a given CPU.
 *
 * NOTE: this is the slowest accessor, use it carefully. Prefer
 * ipipe_this_cpu_context() for requests targeted at the current
 * CPU. Additionally, if the target domain is known at build time,
 * consider ipipe_this_cpu_{root, head}_context().
 */
static inline struct ipipe_percpu_domain_data *
ipipe_percpu_context(struct ipipe_domain *ipd, int cpu)
{
	return __context_of(&per_cpu(ipipe_percpu, cpu), ipd);
}

/**
 * ipipe_this_cpu_context - return the address of the pipeline context
 * data for a domain on the current CPU. hw IRQs must be off.
 *
 * NOTE: this accessor is a bit faster, but since we don't know which
 * one of "root" or "head" ipd refers to, we still need to compute the
 * context address from its offset.
 */
static inline struct ipipe_percpu_domain_data *
ipipe_this_cpu_context(struct ipipe_domain *ipd)
{
	return __context_of(__ipipe_raw_cpu_ptr(&ipipe_percpu), ipd);
}

/**
 * ipipe_this_cpu_root_context - return the address of the pipeline
 * context data for the root domain on the current CPU. hw IRQs must
 * be off.
 *
 * NOTE: this accessor is recommended when the domain we refer to is
 * known at build time to be the root one.
 */
static inline struct ipipe_percpu_domain_data *
ipipe_this_cpu_root_context(void)
{
	return __ipipe_raw_cpu_ptr(&ipipe_percpu.root);
}

/**
 * ipipe_this_cpu_head_context - return the address of the pipeline
 * context data for the registered head domain on the current CPU. hw
 * IRQs must be off.
 *
 * NOTE: this accessor is recommended when the domain we refer to is
 * known at build time to be the registered head domain. This address
 * is always different from the context data of the root domain in
 * absence of registered head domain. To get the address of the
 * context data for the domain leading the pipeline at the time of the
 * call (which may be root in absence of registered head domain), use
 * ipipe_this_cpu_leading_context() instead.
 */
static inline struct ipipe_percpu_domain_data *
ipipe_this_cpu_head_context(void)
{
	return __ipipe_raw_cpu_ptr(&ipipe_percpu.head);
}

/**
 * ipipe_this_cpu_leading_context - return the address of the pipeline
 * context data for the domain leading the pipeline on the current
 * CPU. hw IRQs must be off.
 *
 * NOTE: this accessor is required when either root or a registered
 * head domain may be the final target of this call, depending on
 * whether the high priority domain was installed via
 * ipipe_register_head().
 */
static inline struct ipipe_percpu_domain_data *
ipipe_this_cpu_leading_context(void)
{
	return ipipe_this_cpu_context(ipipe_head_domain);
}

/**
 * __ipipe_get_current_context() - return the address of the pipeline
 * context data of the domain running on the current CPU. hw IRQs must
 * be off.
 */
static inline struct ipipe_percpu_domain_data *__ipipe_get_current_context(void)
{
	return __ipipe_raw_cpu_read(ipipe_percpu.curr);
}

#define __ipipe_current_context __ipipe_get_current_context()

/**
 * __ipipe_set_current_context() - switch the current CPU to the
 * specified domain context.  hw IRQs must be off.
 *
 * NOTE: this is the only way to change the current domain for the
 * current CPU. Don't bypass.
 */
static inline
void __ipipe_set_current_context(struct ipipe_percpu_domain_data *pd)
{
	struct ipipe_percpu_data *p;
	p = __ipipe_raw_cpu_ptr(&ipipe_percpu);
	p->curr = pd;
}

/**
 * __ipipe_set_current_domain() - switch the current CPU to the
 * specified domain. This is equivalent to calling
 * __ipipe_set_current_context() with the context data of that
 * domain. hw IRQs must be off.
 */
static inline void __ipipe_set_current_domain(struct ipipe_domain *ipd)
{
	struct ipipe_percpu_data *p;
	p = __ipipe_raw_cpu_ptr(&ipipe_percpu);
	p->curr = __context_of(p, ipd);
}

static inline struct ipipe_percpu_domain_data *ipipe_current_context(void)
{
	struct ipipe_percpu_domain_data *pd;
	unsigned long flags;

	flags = hard_smp_local_irq_save();
	pd = __ipipe_get_current_context();
	hard_smp_local_irq_restore(flags);

	return pd;
}

static inline struct ipipe_domain *__ipipe_get_current_domain(void)
{
	return __ipipe_get_current_context()->domain;
}

#define __ipipe_current_domain	__ipipe_get_current_domain()

/**
 * __ipipe_get_current_domain() - return the address of the pipeline
 * domain running on the current CPU. hw IRQs must be off.
 */
static inline struct ipipe_domain *ipipe_get_current_domain(void)
{
	struct ipipe_domain *ipd;
	unsigned long flags;

	flags = hard_smp_local_irq_save();
	ipd = __ipipe_get_current_domain();
	hard_smp_local_irq_restore(flags);

	return ipd;
}

#define ipipe_current_domain	ipipe_get_current_domain()

#define __ipipe_root_p	(__ipipe_current_domain == ipipe_root_domain)
#define ipipe_root_p	(ipipe_current_domain == ipipe_root_domain)

#ifdef CONFIG_SMP
#define __ipipe_root_status	(ipipe_this_cpu_root_context()->status)
#else
extern unsigned long __ipipe_root_status;
#endif

#define __ipipe_head_status	(ipipe_this_cpu_head_context()->status)

/**
 * __ipipe_ipending_p() - Whether we have interrupts pending
 * (i.e. logged) for the given domain context on the current CPU. hw
 * IRQs must be off.
 */
static inline int __ipipe_ipending_p(struct ipipe_percpu_domain_data *pd)
{
	return pd->irqpend_himap != 0;
}

static inline unsigned long
__ipipe_cpudata_irq_hits(struct ipipe_domain *ipd, int cpu, unsigned int irq)
{
	return ipipe_percpu_context(ipd, cpu)->irqall[irq];
}

#endif /* CONFIG_IPIPE */

#endif	/* !__LINUX_IPIPE_DOMAIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _XT_HASHLIMIT_H
#define _XT_HASHLIMIT_H

#include <uapi/linux/netfilter/xt_hashlimit.h>

#define XT_HASHLIMIT_ALL (XT_HASHLIMIT_HASH_DIP | XT_HASHLIMIT_HASH_DPT | \
			  XT_HASHLIMIT_HASH_SIP | XT_HASHLIMIT_HASH_SPT | \
			  XT_HASHLIMIT_INVERT | XT_HASHLIMIT_BYTES)
#endif /*_XT_HASHLIMIT_H*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef _NF_CONNTRACK_SCTP_H
#define _NF_CONNTRACK_SCTP_H
/* SCTP tracking. */

#include <uapi/linux/netfilter/nf_conntrack_sctp.h>

struct ip_ct_sctp {
	enum sctp_conntrack state;

	__be32 vtag[IP_CT_DIR_MAX];
};

#endif /* _NF_CONNTRACK_SCTP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _NF_CONNTRACK_SNMP_H
#define _NF_CONNTRACK_SNMP_H

extern int (*nf_nat_snmp_hook)(struct sk_buff *skb,
				unsigned int protoff,
				struct nf_conn *ct,
				enum ip_conntrack_info ctinfo);

#endif /* _NF_CONNTRACK_SNMP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef __NF_CONNTRACK_SIP_H__
#define __NF_CONNTRACK_SIP_H__
#ifdef __KERNEL__

#include <net/netfilter/nf_conntrack_expect.h>

#include <linux/types.h>

#define SIP_PORT	5060
#define SIP_TIMEOUT	3600

struct nf_ct_sip_master {
	unsigned int	register_cseq;
	unsigned int	invite_cseq;
	__be16		forced_dport;
};

enum sip_expectation_classes {
	SIP_EXPECT_SIGNALLING,
	SIP_EXPECT_AUDIO,
	SIP_EXPECT_VIDEO,
	SIP_EXPECT_IMAGE,
	__SIP_EXPECT_MAX
};
#define SIP_EXPECT_MAX	(__SIP_EXPECT_MAX - 1)

struct sdp_media_type {
	const char			*name;
	unsigned int			len;
	enum sip_expectation_classes	class;
};

#define SDP_MEDIA_TYPE(__name, __class)					\
{									\
	.name	= (__name),						\
	.len	= sizeof(__name) - 1,					\
	.class	= (__class),						\
}

struct sip_handler {
	const char	*method;
	unsigned int	len;
	int		(*request)(struct sk_buff *skb, unsigned int protoff,
				   unsigned int dataoff,
				   const char **dptr, unsigned int *datalen,
				   unsigned int cseq);
	int		(*response)(struct sk_buff *skb, unsigned int protoff,
				    unsigned int dataoff,
				    const char **dptr, unsigned int *datalen,
				    unsigned int cseq, unsigned int code);
};

#define SIP_HANDLER(__method, __request, __response)			\
{									\
	.method		= (__method),					\
	.len		= sizeof(__method) - 1,				\
	.request	= (__request),					\
	.response	= (__response),					\
}

struct sip_header {
	const char	*name;
	const char	*cname;
	const char	*search;
	unsigned int	len;
	unsigned int	clen;
	unsigned int	slen;
	int		(*match_len)(const struct nf_conn *ct,
				     const char *dptr, const char *limit,
				     int *shift);
};

#define __SIP_HDR(__name, __cname, __search, __match)			\
{									\
	.name		= (__name),					\
	.len		= sizeof(__name) - 1,				\
	.cname		= (__cname),					\
	.clen		= (__cname) ? sizeof(__cname) - 1 : 0,		\
	.search		= (__search),					\
	.slen		= (__search) ? sizeof(__search) - 1 : 0,	\
	.match_len	= (__match),					\
}

#define SIP_HDR(__name, __cname, __search, __match) \
	__SIP_HDR(__name, __cname, __search, __match)

#define SDP_HDR(__name, __search, __match) \
	__SIP_HDR(__name, NULL, __search, __match)

enum sip_header_types {
	SIP_HDR_CSEQ,
	SIP_HDR_FROM,
	SIP_HDR_TO,
	SIP_HDR_CONTACT,
	SIP_HDR_VIA_UDP,
	SIP_HDR_VIA_TCP,
	SIP_HDR_EXPIRES,
	SIP_HDR_CONTENT_LENGTH,
	SIP_HDR_CALL_ID,
};

enum sdp_header_types {
	SDP_HDR_UNSPEC,
	SDP_HDR_VERSION,
	SDP_HDR_OWNER,
	SDP_HDR_CONNECTION,
	SDP_HDR_MEDIA,
};

struct nf_nat_sip_hooks {
	unsigned int (*msg)(struct sk_buff *skb,
			    unsigned int protoff,
			    unsigned int dataoff,
			    const char **dptr,
			    unsigned int *datalen);

	void (*seq_adjust)(struct sk_buff *skb,
			   unsigned int protoff, s16 off);

	unsigned int (*expect)(struct sk_buff *skb,
			       unsigned int protoff,
			       unsigned int dataoff,
			       const char **dptr,
			       unsigned int *datalen,
			       struct nf_conntrack_expect *exp,
			       unsigned int matchoff,
			       unsigned int matchlen);

	unsigned int (*sdp_addr)(struct sk_buff *skb,
				 unsigned int protoff,
				 unsigned int dataoff,
				 const char **dptr,
				 unsigned int *datalen,
				 unsigned int sdpoff,
				 enum sdp_header_types type,
				 enum sdp_header_types term,
				 const union nf_inet_addr *addr);

	unsigned int (*sdp_port)(struct sk_buff *skb,
				 unsigned int protoff,
				 unsigned int dataoff,
				 const char **dptr,
				 unsigned int *datalen,
				 unsigned int matchoff,
				 unsigned int matchlen,
				 u_int16_t port);

	unsigned int (*sdp_session)(struct sk_buff *skb,
				    unsigned int protoff,
				    unsigned int dataoff,
				    const char **dptr,
				    unsigned int *datalen,
				    unsigned int sdpoff,
				    const union nf_inet_addr *addr);

	unsigned int (*sdp_media)(struct sk_buff *skb,
				  unsigned int protoff,
				  unsigned int dataoff,
				  const char **dptr,
				  unsigned int *datalen,
				  struct nf_conntrack_expect *rtp_exp,
				  struct nf_conntrack_expect *rtcp_exp,
				  unsigned int mediaoff,
				  unsigned int medialen,
				  union nf_inet_addr *rtp_addr);
};
extern const struct nf_nat_sip_hooks *nf_nat_sip_hooks;

int ct_sip_parse_request(const struct nf_conn *ct, const char *dptr,
			 unsigned int datalen, unsigned int *matchoff,
			 unsigned int *matchlen, union nf_inet_addr *addr,
			 __be16 *port);
int ct_sip_get_header(const struct nf_conn *ct, const char *dptr,
		      unsigned int dataoff, unsigned int datalen,
		      enum sip_header_types type, unsigned int *matchoff,
		      unsigned int *matchlen);
int ct_sip_parse_header_uri(const struct nf_conn *ct, const char *dptr,
			    unsigned int *dataoff, unsigned int datalen,
			    enum sip_header_types type, int *in_header,
			    unsigned int *matchoff, unsigned int *matchlen,
			    union nf_inet_addr *addr, __be16 *port);
int ct_sip_parse_address_param(const struct nf_conn *ct, const char *dptr,
			       unsigned int dataoff, unsigned int datalen,
			       const char *name, unsigned int *matchoff,
			       unsigned int *matchlen, union nf_inet_addr *addr,
			       bool delim);
int ct_sip_parse_numerical_param(const struct nf_conn *ct, const char *dptr,
				 unsigned int off, unsigned int datalen,
				 const char *name, unsigned int *matchoff,
				 unsigned int *matchen, unsigned int *val);

int ct_sip_get_sdp_header(const struct nf_conn *ct, const char *dptr,
			  unsigned int dataoff, unsigned int datalen,
			  enum sdp_header_types type,
			  enum sdp_header_types term,
			  unsigned int *matchoff, unsigned int *matchlen);

#endif /* __KERNEL__ */
#endif /* __NF_CONNTRACK_SIP_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* PPTP constants and structs */
#ifndef _NF_CONNTRACK_PPTP_H
#define _NF_CONNTRACK_PPTP_H

#include <linux/netfilter/nf_conntrack_common.h>

extern const char *const pptp_msg_name[];

/* state of the control session */
enum pptp_ctrlsess_state {
	PPTP_SESSION_NONE,			/* no session present */
	PPTP_SESSION_ERROR,			/* some session error */
	PPTP_SESSION_STOPREQ,			/* stop_sess request seen */
	PPTP_SESSION_REQUESTED,			/* start_sess request seen */
	PPTP_SESSION_CONFIRMED,			/* session established */
};

/* state of the call inside the control session */
enum pptp_ctrlcall_state {
	PPTP_CALL_NONE,
	PPTP_CALL_ERROR,
	PPTP_CALL_OUT_REQ,
	PPTP_CALL_OUT_CONF,
	PPTP_CALL_IN_REQ,
	PPTP_CALL_IN_REP,
	PPTP_CALL_IN_CONF,
	PPTP_CALL_CLEAR_REQ,
};

/* conntrack private data */
struct nf_ct_pptp_master {
	enum pptp_ctrlsess_state sstate;	/* session state */
	enum pptp_ctrlcall_state cstate;	/* call state */
	__be16 pac_call_id;			/* call id of PAC */
	__be16 pns_call_id;			/* call id of PNS */

	/* in pre-2.6.11 this used to be per-expect. Now it is per-conntrack
	 * and therefore imposes a fixed limit on the number of maps */
	struct nf_ct_gre_keymap *keymap[IP_CT_DIR_MAX];
};

struct nf_nat_pptp {
	__be16 pns_call_id;			/* NAT'ed PNS call id */
	__be16 pac_call_id;			/* NAT'ed PAC call id */
};

#ifdef __KERNEL__

#define PPTP_CONTROL_PORT	1723

#define PPTP_PACKET_CONTROL	1
#define PPTP_PACKET_MGMT	2

#define PPTP_MAGIC_COOKIE	0x1a2b3c4d

struct pptp_pkt_hdr {
	__u16	packetLength;
	__be16	packetType;
	__be32	magicCookie;
};

/* PptpControlMessageType values */
#define PPTP_START_SESSION_REQUEST	1
#define PPTP_START_SESSION_REPLY	2
#define PPTP_STOP_SESSION_REQUEST	3
#define PPTP_STOP_SESSION_REPLY		4
#define PPTP_ECHO_REQUEST		5
#define PPTP_ECHO_REPLY			6
#define PPTP_OUT_CALL_REQUEST		7
#define PPTP_OUT_CALL_REPLY		8
#define PPTP_IN_CALL_REQUEST		9
#define PPTP_IN_CALL_REPLY		10
#define PPTP_IN_CALL_CONNECT		11
#define PPTP_CALL_CLEAR_REQUEST		12
#define PPTP_CALL_DISCONNECT_NOTIFY	13
#define PPTP_WAN_ERROR_NOTIFY		14
#define PPTP_SET_LINK_INFO		15

#define PPTP_MSG_MAX			15

/* PptpGeneralError values */
#define PPTP_ERROR_CODE_NONE		0
#define PPTP_NOT_CONNECTED		1
#define PPTP_BAD_FORMAT			2
#define PPTP_BAD_VALUE			3
#define PPTP_NO_RESOURCE		4
#define PPTP_BAD_CALLID			5
#define PPTP_REMOVE_DEVICE_ERROR	6

struct PptpControlHeader {
	__be16	messageType;
	__u16	reserved;
};

/* FramingCapability Bitmap Values */
#define PPTP_FRAME_CAP_ASYNC		0x1
#define PPTP_FRAME_CAP_SYNC		0x2

/* BearerCapability Bitmap Values */
#define PPTP_BEARER_CAP_ANALOG		0x1
#define PPTP_BEARER_CAP_DIGITAL		0x2

struct PptpStartSessionRequest {
	__be16	protocolVersion;
	__u16	reserved1;
	__be32	framingCapability;
	__be32	bearerCapability;
	__be16	maxChannels;
	__be16	firmwareRevision;
	__u8	hostName[64];
	__u8	vendorString[64];
};

/* PptpStartSessionResultCode Values */
#define PPTP_START_OK			1
#define PPTP_START_GENERAL_ERROR	2
#define PPTP_START_ALREADY_CONNECTED	3
#define PPTP_START_NOT_AUTHORIZED	4
#define PPTP_START_UNKNOWN_PROTOCOL	5

struct PptpStartSessionReply {
	__be16	protocolVersion;
	__u8	resultCode;
	__u8	generalErrorCode;
	__be32	framingCapability;
	__be32	bearerCapability;
	__be16	maxChannels;
	__be16	firmwareRevision;
	__u8	hostName[64];
	__u8	vendorString[64];
};

/* PptpStopReasons */
#define PPTP_STOP_NONE			1
#define PPTP_STOP_PROTOCOL		2
#define PPTP_STOP_LOCAL_SHUTDOWN	3

struct PptpStopSessionRequest {
	__u8	reason;
	__u8	reserved1;
	__u16	reserved2;
};

/* PptpStopSessionResultCode */
#define PPTP_STOP_OK			1
#define PPTP_STOP_GENERAL_ERROR		2

struct PptpStopSessionReply {
	__u8	resultCode;
	__u8	generalErrorCode;
	__u16	reserved1;
};

struct PptpEchoRequest {
	__be32 identNumber;
};

/* PptpEchoReplyResultCode */
#define PPTP_ECHO_OK			1
#define PPTP_ECHO_GENERAL_ERROR		2

struct PptpEchoReply {
	__be32	identNumber;
	__u8	resultCode;
	__u8	generalErrorCode;
	__u16	reserved;
};

/* PptpFramingType */
#define PPTP_ASYNC_FRAMING		1
#define PPTP_SYNC_FRAMING		2
#define PPTP_DONT_CARE_FRAMING		3

/* PptpCallBearerType */
#define PPTP_ANALOG_TYPE		1
#define PPTP_DIGITAL_TYPE		2
#define PPTP_DONT_CARE_BEARER_TYPE	3

struct PptpOutCallRequest {
	__be16	callID;
	__be16	callSerialNumber;
	__be32	minBPS;
	__be32	maxBPS;
	__be32	bearerType;
	__be32	framingType;
	__be16	packetWindow;
	__be16	packetProcDelay;
	__be16	phoneNumberLength;
	__u16	reserved1;
	__u8	phoneNumber[64];
	__u8	subAddress[64];
};

/* PptpCallResultCode */
#define PPTP_OUTCALL_CONNECT		1
#define PPTP_OUTCALL_GENERAL_ERROR	2
#define PPTP_OUTCALL_NO_CARRIER		3
#define PPTP_OUTCALL_BUSY		4
#define PPTP_OUTCALL_NO_DIAL_TONE	5
#define PPTP_OUTCALL_TIMEOUT		6
#define PPTP_OUTCALL_DONT_ACCEPT	7

struct PptpOutCallReply {
	__be16	callID;
	__be16	peersCallID;
	__u8	resultCode;
	__u8	generalErrorCode;
	__be16	causeCode;
	__be32	connectSpeed;
	__be16	packetWindow;
	__be16	packetProcDelay;
	__be32	physChannelID;
};

struct PptpInCallRequest {
	__be16	callID;
	__be16	callSerialNumber;
	__be32	callBearerType;
	__be32	physChannelID;
	__be16	dialedNumberLength;
	__be16	dialingNumberLength;
	__u8	dialedNumber[64];
	__u8	dialingNumber[64];
	__u8	subAddress[64];
};

/* PptpInCallResultCode */
#define PPTP_INCALL_ACCEPT		1
#define PPTP_INCALL_GENERAL_ERROR	2
#define PPTP_INCALL_DONT_ACCEPT		3

struct PptpInCallReply {
	__be16	callID;
	__be16	peersCallID;
	__u8	resultCode;
	__u8	generalErrorCode;
	__be16	packetWindow;
	__be16	packetProcDelay;
	__u16	reserved;
};

struct PptpInCallConnected {
	__be16	peersCallID;
	__u16	reserved;
	__be32	connectSpeed;
	__be16	packetWindow;
	__be16	packetProcDelay;
	__be32	callFramingType;
};

struct PptpClearCallRequest {
	__be16	callID;
	__u16	reserved;
};

struct PptpCallDisconnectNotify {
	__be16	callID;
	__u8	resultCode;
	__u8	generalErrorCode;
	__be16	causeCode;
	__u16	reserved;
	__u8	callStatistics[128];
};

struct PptpWanErrorNotify {
	__be16	peersCallID;
	__u16	reserved;
	__be32	crcErrors;
	__be32	framingErrors;
	__be32	hardwareOverRuns;
	__be32	bufferOverRuns;
	__be32	timeoutErrors;
	__be32	alignmentErrors;
};

struct PptpSetLinkInfo {
	__be16	peersCallID;
	__u16	reserved;
	__be32	sendAccm;
	__be32	recvAccm;
};

union pptp_ctrl_union {
	struct PptpStartSessionRequest	sreq;
	struct PptpStartSessionReply	srep;
	struct PptpStopSessionRequest	streq;
	struct PptpStopSessionReply	strep;
	struct PptpOutCallRequest	ocreq;
	struct PptpOutCallReply		ocack;
	struct PptpInCallRequest	icreq;
	struct PptpInCallReply		icack;
	struct PptpInCallConnected	iccon;
	struct PptpClearCallRequest	clrreq;
	struct PptpCallDisconnectNotify disc;
	struct PptpWanErrorNotify	wanerr;
	struct PptpSetLinkInfo		setlink;
};

/* crap needed for nf_conntrack_compat.h */
struct nf_conn;
struct nf_conntrack_expect;

extern int
(*nf_nat_pptp_hook_outbound)(struct sk_buff *skb,
			     struct nf_conn *ct, enum ip_conntrack_info ctinfo,
			     unsigned int protoff,
			     struct PptpControlHeader *ctlh,
			     union pptp_ctrl_union *pptpReq);

extern int
(*nf_nat_pptp_hook_inbound)(struct sk_buff *skb,
			    struct nf_conn *ct, enum ip_conntrack_info ctinfo,
			    unsigned int protoff,
			    struct PptpControlHeader *ctlh,
			    union pptp_ctrl_union *pptpReq);

extern void
(*nf_nat_pptp_hook_exp_gre)(struct nf_conntrack_expect *exp_orig,
			    struct nf_conntrack_expect *exp_reply);

extern void
(*nf_nat_pptp_hook_expectfn)(struct nf_conn *ct,
			     struct nf_conntrack_expect *exp);

#endif /* __KERNEL__ */
#endif /* _NF_CONNTRACK_PPTP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /****************************************************************************
 * ip_conntrack_h323_asn1.h - BER and PER decoding library for H.323
 * 			      conntrack/NAT module.
 *
 * Copyright (c) 2006 by Jing Min Zhao <zhaojingmin@users.sourceforge.net>
 *
 * This source code is licensed under General Public License version 2.
 *
 *
 * This library is based on H.225 version 4, H.235 version 2 and H.245
 * version 7. It is extremely optimized to decode only the absolutely
 * necessary objects in a signal for Linux kernel NAT module use, so don't
 * expect it to be a full ASN.1 library.
 *
 * Features:
 *
 * 1. Small. The total size of code plus data is less than 20 KB (IA32).
 * 2. Fast. Decoding Netmeeting's Setup signal 1 million times on a PIII 866
 *    takes only 3.9 seconds.
 * 3. No memory allocation. It uses a static object. No need to initialize or
 *    cleanup.
 * 4. Thread safe.
 * 5. Support embedded architectures that has no misaligned memory access
 *    support.
 *
 * Limitations:
 *
 * 1. At most 30 faststart entries. Actually this is limited by ethernet's MTU.
 *    If a Setup signal contains more than 30 faststart, the packet size will
 *    very likely exceed the MTU size, then the TPKT will be fragmented. I
 *    don't know how to handle this in a Netfilter module. Anybody can help?
 *    Although I think 30 is enough for most of the cases.
 * 2. IPv4 addresses only.
 *
 ****************************************************************************/

#ifndef _NF_CONNTRACK_HELPER_H323_ASN1_H_
#define _NF_CONNTRACK_HELPER_H323_ASN1_H_

/*****************************************************************************
 * H.323 Types
 ****************************************************************************/
#include <linux/netfilter/nf_conntrack_h323_types.h>

typedef struct {
	enum {
		Q931_NationalEscape = 0x00,
		Q931_Alerting = 0x01,
		Q931_CallProceeding = 0x02,
		Q931_Connect = 0x07,
		Q931_ConnectAck = 0x0F,
		Q931_Progress = 0x03,
		Q931_Setup = 0x05,
		Q931_SetupAck = 0x0D,
		Q931_Resume = 0x26,
		Q931_ResumeAck = 0x2E,
		Q931_ResumeReject = 0x22,
		Q931_Suspend = 0x25,
		Q931_SuspendAck = 0x2D,
		Q931_SuspendReject = 0x21,
		Q931_UserInformation = 0x20,
		Q931_Disconnect = 0x45,
		Q931_Release = 0x4D,
		Q931_ReleaseComplete = 0x5A,
		Q931_Restart = 0x46,
		Q931_RestartAck = 0x4E,
		Q931_Segment = 0x60,
		Q931_CongestionCtrl = 0x79,
		Q931_Information = 0x7B,
		Q931_Notify = 0x6E,
		Q931_Status = 0x7D,
		Q931_StatusEnquiry = 0x75,
		Q931_Facility = 0x62
	} MessageType;
	H323_UserInformation UUIE;
} Q931;

/*****************************************************************************
 * Decode Functions Return Codes
 ****************************************************************************/

#define H323_ERROR_NONE 0	/* Decoded successfully */
#define H323_ERROR_STOP 1	/* Decoding stopped, not really an error */
#define H323_ERROR_BOUND -1
#define H323_ERROR_RANGE -2


/*****************************************************************************
 * Decode Functions
 ****************************************************************************/

int DecodeRasMessage(unsigned char *buf, size_t sz, RasMessage * ras);
int DecodeQ931(unsigned char *buf, size_t sz, Q931 * q931);
int DecodeMultimediaSystemControlMessage(unsigned char *buf, size_t sz,
					 MultimediaSystemControlMessage *
					 mscm);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _NFNETLINK_H
#define _NFNETLINK_H


#include <linux/netlink.h>
#include <linux/capability.h>
#include <net/netlink.h>
#include <uapi/linux/netfilter/nfnetlink.h>

struct nfnl_callback {
	int (*call)(struct net *net, struct sock *nl, struct sk_buff *skb,
		    const struct nlmsghdr *nlh,
		    const struct nlattr * const cda[]);
	int (*call_rcu)(struct net *net, struct sock *nl, struct sk_buff *skb,
			const struct nlmsghdr *nlh,
			const struct nlattr * const cda[]);
	int (*call_batch)(struct net *net, struct sock *nl, struct sk_buff *skb,
			  const struct nlmsghdr *nlh,
			  const struct nlattr * const cda[]);
	const struct nla_policy *policy;	/* netlink attribute policy */
	const u_int16_t attr_count;		/* number of nlattr's */
};

struct nfnetlink_subsystem {
	const char *name;
	__u8 subsys_id;			/* nfnetlink subsystem ID */
	__u8 cb_count;			/* number of callbacks */
	const struct nfnl_callback *cb;	/* callback for individual types */
	int (*commit)(struct net *net, struct sk_buff *skb);
	int (*abort)(struct net *net, struct sk_buff *skb);
};

int nfnetlink_subsys_register(const struct nfnetlink_subsystem *n);
int nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n);

int nfnetlink_has_listeners(struct net *net, unsigned int group);
int nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,
		   unsigned int group, int echo, gfp_t flags);
int nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error);
int nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,
		      int flags);

void nfnl_lock(__u8 subsys_id);
void nfnl_unlock(__u8 subsys_id);
#ifdef CONFIG_PROVE_LOCKING
bool lockdep_nfnl_is_held(__u8 subsys_id);
#else
static inline bool lockdep_nfnl_is_held(__u8 subsys_id)
{
	return true;
}
#endif /* CONFIG_PROVE_LOCKING */

/*
 * nfnl_dereference - fetch RCU pointer when updates are prevented by subsys mutex
 *
 * @p: The pointer to read, prior to dereferencing
 * @ss: The nfnetlink subsystem ID
 *
 * Return the value of the specified RCU-protected pointer, but omit
 * both the smp_read_barrier_depends() and the ACCESS_ONCE(), because
 * caller holds the NFNL subsystem mutex.
 */
#define nfnl_dereference(p, ss)					\
	rcu_dereference_protected(p, lockdep_nfnl_is_held(ss))

#define MODULE_ALIAS_NFNL_SUBSYS(subsys) \
	MODULE_ALIAS("nfnetlink-subsys-" __stringify(subsys))

#endif	/* _NFNETLINK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef _NF_CONNTRACK_DCCP_H
#define _NF_CONNTRACK_DCCP_H

/* Exposed to userspace over nfnetlink */
enum ct_dccp_states {
	CT_DCCP_NONE,
	CT_DCCP_REQUEST,
	CT_DCCP_RESPOND,
	CT_DCCP_PARTOPEN,
	CT_DCCP_OPEN,
	CT_DCCP_CLOSEREQ,
	CT_DCCP_CLOSING,
	CT_DCCP_TIMEWAIT,
	CT_DCCP_IGNORE,
	CT_DCCP_INVALID,
	__CT_DCCP_MAX
};
#define CT_DCCP_MAX		(__CT_DCCP_MAX - 1)

enum ct_dccp_roles {
	CT_DCCP_ROLE_CLIENT,
	CT_DCCP_ROLE_SERVER,
	__CT_DCCP_ROLE_MAX
};
#define CT_DCCP_ROLE_MAX	(__CT_DCCP_ROLE_MAX - 1)

#ifdef __KERNEL__
#include <net/netfilter/nf_conntrack_tuple.h>

struct nf_ct_dccp {
	u_int8_t	role[IP_CT_DIR_MAX];
	u_int8_t	state;
	u_int8_t	last_pkt;
	u_int8_t	last_dir;
	u_int64_t	handshake_seq;
};

#endif /* __KERNEL__ */

#endif /* _NF_CONNTRACK_DCCP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef _NF_CONNTRACK_H323_H
#define _NF_CONNTRACK_H323_H

#ifdef __KERNEL__

#include <linux/netfilter/nf_conntrack_h323_asn1.h>

#define RAS_PORT 1719
#define Q931_PORT 1720
#define H323_RTP_CHANNEL_MAX 4	/* Audio, video, FAX and other */

/* This structure exists only once per master */
struct nf_ct_h323_master {

	/* Original and NATed Q.931 or H.245 signal ports */
	__be16 sig_port[IP_CT_DIR_MAX];

	/* Original and NATed RTP ports */
	__be16 rtp_port[H323_RTP_CHANNEL_MAX][IP_CT_DIR_MAX];

	union {
		/* RAS connection timeout */
		u_int32_t timeout;

		/* Next TPKT length (for separate TPKT header and data) */
		u_int16_t tpkt_len[IP_CT_DIR_MAX];
	};
};

struct nf_conn;

int get_h225_addr(struct nf_conn *ct, unsigned char *data,
		  TransportAddress *taddr, union nf_inet_addr *addr,
		  __be16 *port);
void nf_conntrack_h245_expect(struct nf_conn *new,
			      struct nf_conntrack_expect *this);
void nf_conntrack_q931_expect(struct nf_conn *new,
			      struct nf_conntrack_expect *this);
extern int (*set_h245_addr_hook) (struct sk_buff *skb, unsigned int protoff,
				  unsigned char **data, int dataoff,
				  H245_TransportAddress *taddr,
				  union nf_inet_addr *addr,
				  __be16 port);
extern int (*set_h225_addr_hook) (struct sk_buff *skb, unsigned int protoff,
				  unsigned char **data, int dataoff,
				  TransportAddress *taddr,
				  union nf_inet_addr *addr,
				  __be16 port);
extern int (*set_sig_addr_hook) (struct sk_buff *skb,
				 struct nf_conn *ct,
				 enum ip_conntrack_info ctinfo,
				 unsigned int protoff, unsigned char **data,
				 TransportAddress *taddr, int count);
extern int (*set_ras_addr_hook) (struct sk_buff *skb,
				 struct nf_conn *ct,
				 enum ip_conntrack_info ctinfo,
				 unsigned int protoff, unsigned char **data,
				 TransportAddress *taddr, int count);
extern int (*nat_rtp_rtcp_hook) (struct sk_buff *skb,
				 struct nf_conn *ct,
				 enum ip_conntrack_info ctinfo,
				 unsigned int protoff, unsigned char **data,
				 int dataoff,
				 H245_TransportAddress *taddr,
				 __be16 port, __be16 rtp_port,
				 struct nf_conntrack_expect *rtp_exp,
				 struct nf_conntrack_expect *rtcp_exp);
extern int (*nat_t120_hook) (struct sk_buff *skb, struct nf_conn *ct,
			     enum ip_conntrack_info ctinfo,
			     unsigned int protoff,
			     unsigned char **data, int dataoff,
			     H245_TransportAddress *taddr, __be16 port,
			     struct nf_conntrack_expect *exp);
extern int (*nat_h245_hook) (struct sk_buff *skb, struct nf_conn *ct,
			     enum ip_conntrack_info ctinfo,
			     unsigned int protoff,
			     unsigned char **data, int dataoff,
			     TransportAddress *taddr, __be16 port,
			     struct nf_conntrack_expect *exp);
extern int (*nat_callforwarding_hook) (struct sk_buff *skb,
				       struct nf_conn *ct,
				       enum ip_conntrack_info ctinfo,
				       unsigned int protoff,
				       unsigned char **data, int dataoff,
				       TransportAddress *taddr,
				       __be16 port,
				       struct nf_conntrack_expect *exp);
extern int (*nat_q931_hook) (struct sk_buff *skb, struct nf_conn *ct,
			     enum ip_conntrack_info ctinfo,
			     unsigned int protoff,
			     unsigned char **data, TransportAddress *taddr,
			     int idx, __be16 port,
			     struct nf_conntrack_expect *exp);

#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _NF_CONNTRACK_TCP_H
#define _NF_CONNTRACK_TCP_H

#include <uapi/linux/netfilter/nf_conntrack_tcp.h>


struct ip_ct_tcp_state {
	u_int32_t	td_end;		/* max of seq + len */
	u_int32_t	td_maxend;	/* max of ack + max(win, 1) */
	u_int32_t	td_maxwin;	/* max(win) */
	u_int32_t	td_maxack;	/* max of ack */
	u_int8_t	td_scale;	/* window scale factor */
	u_int8_t	flags;		/* per direction options */
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];	/* connection parameters per direction */
	u_int8_t	state;		/* state of the connection (enum tcp_conntrack) */
	/* For detecting stale connections */
	u_int8_t	last_dir;	/* Direction of the last packet (enum ip_conntrack_dir) */
	u_int8_t	retrans;	/* Number of retransmitted packets */
	u_int8_t	last_index;	/* Index of the last packet */
	u_int32_t	last_seq;	/* Last sequence number seen in dir */
	u_int32_t	last_ack;	/* Last sequence number seen in opposite dir */
	u_int32_t	last_end;	/* Last seq + len */
	u_int16_t	last_win;	/* Last window advertisement seen in dir */
	/* For SYN packets while we may be out-of-sync */
	u_int8_t	last_wscale;	/* Last window scaling factor seen */
	u_int8_t	last_flags;	/* Last flags set */
};

#endif /* _NF_CONNTRACK_TCP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* Generated by Jing Min Zhao's ASN.1 parser, May 16 2007
 *
 * Copyright (c) 2006 Jing Min Zhao <zhaojingmin@users.sourceforge.net>
 *
 * This source code is licensed under General Public License version 2.
 */

typedef struct TransportAddress_ipAddress {	/* SEQUENCE */
	int options;		/* No use */
	unsigned int ip;
} TransportAddress_ipAddress;

typedef struct TransportAddress_ip6Address {	/* SEQUENCE */
	int options;		/* No use */
	unsigned int ip;
} TransportAddress_ip6Address;

typedef struct TransportAddress {	/* CHOICE */
	enum {
		eTransportAddress_ipAddress,
		eTransportAddress_ipSourceRoute,
		eTransportAddress_ipxAddress,
		eTransportAddress_ip6Address,
		eTransportAddress_netBios,
		eTransportAddress_nsap,
		eTransportAddress_nonStandardAddress,
	} choice;
	union {
		TransportAddress_ipAddress ipAddress;
		TransportAddress_ip6Address ip6Address;
	};
} TransportAddress;

typedef struct DataProtocolCapability {	/* CHOICE */
	enum {
		eDataProtocolCapability_nonStandard,
		eDataProtocolCapability_v14buffered,
		eDataProtocolCapability_v42lapm,
		eDataProtocolCapability_hdlcFrameTunnelling,
		eDataProtocolCapability_h310SeparateVCStack,
		eDataProtocolCapability_h310SingleVCStack,
		eDataProtocolCapability_transparent,
		eDataProtocolCapability_segmentationAndReassembly,
		eDataProtocolCapability_hdlcFrameTunnelingwSAR,
		eDataProtocolCapability_v120,
		eDataProtocolCapability_separateLANStack,
		eDataProtocolCapability_v76wCompression,
		eDataProtocolCapability_tcp,
		eDataProtocolCapability_udp,
	} choice;
} DataProtocolCapability;

typedef struct DataApplicationCapability_application {	/* CHOICE */
	enum {
		eDataApplicationCapability_application_nonStandard,
		eDataApplicationCapability_application_t120,
		eDataApplicationCapability_application_dsm_cc,
		eDataApplicationCapability_application_userData,
		eDataApplicationCapability_application_t84,
		eDataApplicationCapability_application_t434,
		eDataApplicationCapability_application_h224,
		eDataApplicationCapability_application_nlpid,
		eDataApplicationCapability_application_dsvdControl,
		eDataApplicationCapability_application_h222DataPartitioning,
		eDataApplicationCapability_application_t30fax,
		eDataApplicationCapability_application_t140,
		eDataApplicationCapability_application_t38fax,
		eDataApplicationCapability_application_genericDataCapability,
	} choice;
	union {
		DataProtocolCapability t120;
	};
} DataApplicationCapability_application;

typedef struct DataApplicationCapability {	/* SEQUENCE */
	int options;		/* No use */
	DataApplicationCapability_application application;
} DataApplicationCapability;

typedef struct DataType {	/* CHOICE */
	enum {
		eDataType_nonStandard,
		eDataType_nullData,
		eDataType_videoData,
		eDataType_audioData,
		eDataType_data,
		eDataType_encryptionData,
		eDataType_h235Control,
		eDataType_h235Media,
		eDataType_multiplexedStream,
	} choice;
	union {
		DataApplicationCapability data;
	};
} DataType;

typedef struct UnicastAddress_iPAddress {	/* SEQUENCE */
	int options;		/* No use */
	unsigned int network;
} UnicastAddress_iPAddress;

typedef struct UnicastAddress_iP6Address {	/* SEQUENCE */
	int options;		/* No use */
	unsigned int network;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress {	/* CHOICE */
	enum {
		eUnicastAddress_iPAddress,
		eUnicastAddress_iPXAddress,
		eUnicastAddress_iP6Address,
		eUnicastAddress_netBios,
		eUnicastAddress_iPSourceRouteAddress,
		eUnicastAddress_nsap,
		eUnicastAddress_nonStandardAddress,
	} choice;
	union {
		UnicastAddress_iPAddress iPAddress;
		UnicastAddress_iP6Address iP6Address;
	};
} UnicastAddress;

typedef struct H245_TransportAddress {	/* CHOICE */
	enum {
		eH245_TransportAddress_unicastAddress,
		eH245_TransportAddress_multicastAddress,
	} choice;
	union {
		UnicastAddress unicastAddress;
	};
} H245_TransportAddress;

typedef struct H2250LogicalChannelParameters {	/* SEQUENCE */
	enum {
		eH2250LogicalChannelParameters_nonStandard = (1 << 31),
		eH2250LogicalChannelParameters_associatedSessionID =
		    (1 << 30),
		eH2250LogicalChannelParameters_mediaChannel = (1 << 29),
		eH2250LogicalChannelParameters_mediaGuaranteedDelivery =
		    (1 << 28),
		eH2250LogicalChannelParameters_mediaControlChannel =
		    (1 << 27),
		eH2250LogicalChannelParameters_mediaControlGuaranteedDelivery
		    = (1 << 26),
		eH2250LogicalChannelParameters_silenceSuppression = (1 << 25),
		eH2250LogicalChannelParameters_destination = (1 << 24),
		eH2250LogicalChannelParameters_dynamicRTPPayloadType =
		    (1 << 23),
		eH2250LogicalChannelParameters_mediaPacketization = (1 << 22),
		eH2250LogicalChannelParameters_transportCapability =
		    (1 << 21),
		eH2250LogicalChannelParameters_redundancyEncoding = (1 << 20),
		eH2250LogicalChannelParameters_source = (1 << 19),
	} options;
	H245_TransportAddress mediaChannel;
	H245_TransportAddress mediaControlChannel;
} H2250LogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {	/* CHOICE */
	enum {
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none,
	} choice;
	union {
		H2250LogicalChannelParameters h2250LogicalChannelParameters;
	};
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {	/* SEQUENCE */
	enum {
		eOpenLogicalChannel_forwardLogicalChannelParameters_portNumber
		    = (1 << 31),
		eOpenLogicalChannel_forwardLogicalChannelParameters_forwardLogicalChannelDependency
		    = (1 << 30),
		eOpenLogicalChannel_forwardLogicalChannelParameters_replacementFor
		    = (1 << 29),
	} options;
	DataType dataType;
	OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
	    multiplexParameters;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {	/* CHOICE */
	enum {
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters,
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters,
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters,
	} choice;
	union {
		H2250LogicalChannelParameters h2250LogicalChannelParameters;
	};
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {	/* SEQUENCE */
	enum {
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
		    = (1 << 31),
		eOpenLogicalChannel_reverseLogicalChannelParameters_reverseLogicalChannelDependency
		    = (1 << 30),
		eOpenLogicalChannel_reverseLogicalChannelParameters_replacementFor
		    = (1 << 29),
	} options;
	OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
	    multiplexParameters;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct NetworkAccessParameters_networkAddress {	/* CHOICE */
	enum {
		eNetworkAccessParameters_networkAddress_q2931Address,
		eNetworkAccessParameters_networkAddress_e164Address,
		eNetworkAccessParameters_networkAddress_localAreaAddress,
	} choice;
	union {
		H245_TransportAddress localAreaAddress;
	};
} NetworkAccessParameters_networkAddress;

typedef struct NetworkAccessParameters {	/* SEQUENCE */
	enum {
		eNetworkAccessParameters_distribution = (1 << 31),
		eNetworkAccessParameters_externalReference = (1 << 30),
		eNetworkAccessParameters_t120SetupProcedure = (1 << 29),
	} options;
	NetworkAccessParameters_networkAddress networkAddress;
} NetworkAccessParameters;

typedef struct OpenLogicalChannel {	/* SEQUENCE */
	enum {
		eOpenLogicalChannel_reverseLogicalChannelParameters =
		    (1 << 31),
		eOpenLogicalChannel_separateStack = (1 << 30),
		eOpenLogicalChannel_encryptionSync = (1 << 29),
	} options;
	OpenLogicalChannel_forwardLogicalChannelParameters
	    forwardLogicalChannelParameters;
	OpenLogicalChannel_reverseLogicalChannelParameters
	    reverseLogicalChannelParameters;
	NetworkAccessParameters separateStack;
} OpenLogicalChannel;

typedef struct Setup_UUIE_fastStart {	/* SEQUENCE OF */
	int count;
	OpenLogicalChannel item[30];
} Setup_UUIE_fastStart;

typedef struct Setup_UUIE {	/* SEQUENCE */
	enum {
		eSetup_UUIE_h245Address = (1 << 31),
		eSetup_UUIE_sourceAddress = (1 << 30),
		eSetup_UUIE_destinationAddress = (1 << 29),
		eSetup_UUIE_destCallSignalAddress = (1 << 28),
		eSetup_UUIE_destExtraCallInfo = (1 << 27),
		eSetup_UUIE_destExtraCRV = (1 << 26),
		eSetup_UUIE_callServices = (1 << 25),
		eSetup_UUIE_sourceCallSignalAddress = (1 << 24),
		eSetup_UUIE_remoteExtensionAddress = (1 << 23),
		eSetup_UUIE_callIdentifier = (1 << 22),
		eSetup_UUIE_h245SecurityCapability = (1 << 21),
		eSetup_UUIE_tokens = (1 << 20),
		eSetup_UUIE_cryptoTokens = (1 << 19),
		eSetup_UUIE_fastStart = (1 << 18),
		eSetup_UUIE_mediaWaitForConnect = (1 << 17),
		eSetup_UUIE_canOverlapSend = (1 << 16),
		eSetup_UUIE_endpointIdentifier = (1 << 15),
		eSetup_UUIE_multipleCalls = (1 << 14),
		eSetup_UUIE_maintainConnection = (1 << 13),
		eSetup_UUIE_connectionParameters = (1 << 12),
		eSetup_UUIE_language = (1 << 11),
		eSetup_UUIE_presentationIndicator = (1 << 10),
		eSetup_UUIE_screeningIndicator = (1 << 9),
		eSetup_UUIE_serviceControl = (1 << 8),
		eSetup_UUIE_symmetricOperationRequired = (1 << 7),
		eSetup_UUIE_capacity = (1 << 6),
		eSetup_UUIE_circuitInfo = (1 << 5),
		eSetup_UUIE_desiredProtocols = (1 << 4),
		eSetup_UUIE_neededFeatures = (1 << 3),
		eSetup_UUIE_desiredFeatures = (1 << 2),
		eSetup_UUIE_supportedFeatures = (1 << 1),
		eSetup_UUIE_parallelH245Control = (1 << 0),
	} options;
	TransportAddress h245Address;
	TransportAddress destCallSignalAddress;
	TransportAddress sourceCallSignalAddress;
	Setup_UUIE_fastStart fastStart;
} Setup_UUIE;

typedef struct CallProceeding_UUIE_fastStart {	/* SEQUENCE OF */
	int count;
	OpenLogicalChannel item[30];
} CallProceeding_UUIE_fastStart;

typedef struct CallProceeding_UUIE {	/* SEQUENCE */
	enum {
		eCallProceeding_UUIE_h245Address = (1 << 31),
		eCallProceeding_UUIE_callIdentifier = (1 << 30),
		eCallProceeding_UUIE_h245SecurityMode = (1 << 29),
		eCallProceeding_UUIE_tokens = (1 << 28),
		eCallProceeding_UUIE_cryptoTokens = (1 << 27),
		eCallProceeding_UUIE_fastStart = (1 << 26),
		eCallProceeding_UUIE_multipleCalls = (1 << 25),
		eCallProceeding_UUIE_maintainConnection = (1 << 24),
		eCallProceeding_UUIE_fastConnectRefused = (1 << 23),
		eCallProceeding_UUIE_featureSet = (1 << 22),
	} options;
	TransportAddress h245Address;
	CallProceeding_UUIE_fastStart fastStart;
} CallProceeding_UUIE;

typedef struct Connect_UUIE_fastStart {	/* SEQUENCE OF */
	int count;
	OpenLogicalChannel item[30];
} Connect_UUIE_fastStart;

typedef struct Connect_UUIE {	/* SEQUENCE */
	enum {
		eConnect_UUIE_h245Address = (1 << 31),
		eConnect_UUIE_callIdentifier = (1 << 30),
		eConnect_UUIE_h245SecurityMode = (1 << 29),
		eConnect_UUIE_tokens = (1 << 28),
		eConnect_UUIE_cryptoTokens = (1 << 27),
		eConnect_UUIE_fastStart = (1 << 26),
		eConnect_UUIE_multipleCalls = (1 << 25),
		eConnect_UUIE_maintainConnection = (1 << 24),
		eConnect_UUIE_language = (1 << 23),
		eConnect_UUIE_connectedAddress = (1 << 22),
		eConnect_UUIE_presentationIndicator = (1 << 21),
		eConnect_UUIE_screeningIndicator = (1 << 20),
		eConnect_UUIE_fastConnectRefused = (1 << 19),
		eConnect_UUIE_serviceControl = (1 << 18),
		eConnect_UUIE_capacity = (1 << 17),
		eConnect_UUIE_featureSet = (1 << 16),
	} options;
	TransportAddress h245Address;
	Connect_UUIE_fastStart fastStart;
} Connect_UUIE;

typedef struct Alerting_UUIE_fastStart {	/* SEQUENCE OF */
	int count;
	OpenLogicalChannel item[30];
} Alerting_UUIE_fastStart;

typedef struct Alerting_UUIE {	/* SEQUENCE */
	enum {
		eAlerting_UUIE_h245Address = (1 << 31),
		eAlerting_UUIE_callIdentifier = (1 << 30),
		eAlerting_UUIE_h245SecurityMode = (1 << 29),
		eAlerting_UUIE_tokens = (1 << 28),
		eAlerting_UUIE_cryptoTokens = (1 << 27),
		eAlerting_UUIE_fastStart = (1 << 26),
		eAlerting_UUIE_multipleCalls = (1 << 25),
		eAlerting_UUIE_maintainConnection = (1 << 24),
		eAlerting_UUIE_alertingAddress = (1 << 23),
		eAlerting_UUIE_presentationIndicator = (1 << 22),
		eAlerting_UUIE_screeningIndicator = (1 << 21),
		eAlerting_UUIE_fastConnectRefused = (1 << 20),
		eAlerting_UUIE_serviceControl = (1 << 19),
		eAlerting_UUIE_capacity = (1 << 18),
		eAlerting_UUIE_featureSet = (1 << 17),
	} options;
	TransportAddress h245Address;
	Alerting_UUIE_fastStart fastStart;
} Alerting_UUIE;

typedef struct FacilityReason {	/* CHOICE */
	enum {
		eFacilityReason_routeCallToGatekeeper,
		eFacilityReason_callForwarded,
		eFacilityReason_routeCallToMC,
		eFacilityReason_undefinedReason,
		eFacilityReason_conferenceListChoice,
		eFacilityReason_startH245,
		eFacilityReason_noH245,
		eFacilityReason_newTokens,
		eFacilityReason_featureSetUpdate,
		eFacilityReason_forwardedElements,
		eFacilityReason_transportedInformation,
	} choice;
} FacilityReason;

typedef struct Facility_UUIE_fastStart {	/* SEQUENCE OF */
	int count;
	OpenLogicalChannel item[30];
} Facility_UUIE_fastStart;

typedef struct Facility_UUIE {	/* SEQUENCE */
	enum {
		eFacility_UUIE_alternativeAddress = (1 << 31),
		eFacility_UUIE_alternativeAliasAddress = (1 << 30),
		eFacility_UUIE_conferenceID = (1 << 29),
		eFacility_UUIE_callIdentifier = (1 << 28),
		eFacility_UUIE_destExtraCallInfo = (1 << 27),
		eFacility_UUIE_remoteExtensionAddress = (1 << 26),
		eFacility_UUIE_tokens = (1 << 25),
		eFacility_UUIE_cryptoTokens = (1 << 24),
		eFacility_UUIE_conferences = (1 << 23),
		eFacility_UUIE_h245Address = (1 << 22),
		eFacility_UUIE_fastStart = (1 << 21),
		eFacility_UUIE_multipleCalls = (1 << 20),
		eFacility_UUIE_maintainConnection = (1 << 19),
		eFacility_UUIE_fastConnectRefused = (1 << 18),
		eFacility_UUIE_serviceControl = (1 << 17),
		eFacility_UUIE_circuitInfo = (1 << 16),
		eFacility_UUIE_featureSet = (1 << 15),
		eFacility_UUIE_destinationInfo = (1 << 14),
		eFacility_UUIE_h245SecurityMode = (1 << 13),
	} options;
	TransportAddress alternativeAddress;
	FacilityReason reason;
	TransportAddress h245Address;
	Facility_UUIE_fastStart fastStart;
} Facility_UUIE;

typedef struct Progress_UUIE_fastStart {	/* SEQUENCE OF */
	int count;
	OpenLogicalChannel item[30];
} Progress_UUIE_fastStart;

typedef struct Progress_UUIE {	/* SEQUENCE */
	enum {
		eProgress_UUIE_h245Address = (1 << 31),
		eProgress_UUIE_h245SecurityMode = (1 << 30),
		eProgress_UUIE_tokens = (1 << 29),
		eProgress_UUIE_cryptoTokens = (1 << 28),
		eProgress_UUIE_fastStart = (1 << 27),
		eProgress_UUIE_multipleCalls = (1 << 26),
		eProgress_UUIE_maintainConnection = (1 << 25),
		eProgress_UUIE_fastConnectRefused = (1 << 24),
	} options;
	TransportAddress h245Address;
	Progress_UUIE_fastStart fastStart;
} Progress_UUIE;

typedef struct H323_UU_PDU_h323_message_body {	/* CHOICE */
	enum {
		eH323_UU_PDU_h323_message_body_setup,
		eH323_UU_PDU_h323_message_body_callProceeding,
		eH323_UU_PDU_h323_message_body_connect,
		eH323_UU_PDU_h323_message_body_alerting,
		eH323_UU_PDU_h323_message_body_information,
		eH323_UU_PDU_h323_message_body_releaseComplete,
		eH323_UU_PDU_h323_message_body_facility,
		eH323_UU_PDU_h323_message_body_progress,
		eH323_UU_PDU_h323_message_body_empty,
		eH323_UU_PDU_h323_message_body_status,
		eH323_UU_PDU_h323_message_body_statusInquiry,
		eH323_UU_PDU_h323_message_body_setupAcknowledge,
		eH323_UU_PDU_h323_message_body_notify,
	} choice;
	union {
		Setup_UUIE setup;
		CallProceeding_UUIE callProceeding;
		Connect_UUIE connect;
		Alerting_UUIE alerting;
		Facility_UUIE facility;
		Progress_UUIE progress;
	};
} H323_UU_PDU_h323_message_body;

typedef struct RequestMessage {	/* CHOICE */
	enum {
		eRequestMessage_nonStandard,
		eRequestMessage_masterSlaveDetermination,
		eRequestMessage_terminalCapabilitySet,
		eRequestMessage_openLogicalChannel,
		eRequestMessage_closeLogicalChannel,
		eRequestMessage_requestChannelClose,
		eRequestMessage_multiplexEntrySend,
		eRequestMessage_requestMultiplexEntry,
		eRequestMessage_requestMode,
		eRequestMessage_roundTripDelayRequest,
		eRequestMessage_maintenanceLoopRequest,
		eRequestMessage_communicationModeRequest,
		eRequestMessage_conferenceRequest,
		eRequestMessage_multilinkRequest,
		eRequestMessage_logicalChannelRateRequest,
	} choice;
	union {
		OpenLogicalChannel openLogicalChannel;
	};
} RequestMessage;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {	/* CHOICE */
	enum {
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters,
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters,
	} choice;
	union {
		H2250LogicalChannelParameters h2250LogicalChannelParameters;
	};
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {	/* SEQUENCE */
	enum {
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber
		    = (1 << 31),
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
		    = (1 << 30),
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor
		    = (1 << 29),
	} options;
	OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
	    multiplexParameters;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct H2250LogicalChannelAckParameters {	/* SEQUENCE */
	enum {
		eH2250LogicalChannelAckParameters_nonStandard = (1 << 31),
		eH2250LogicalChannelAckParameters_sessionID = (1 << 30),
		eH2250LogicalChannelAckParameters_mediaChannel = (1 << 29),
		eH2250LogicalChannelAckParameters_mediaControlChannel =
		    (1 << 28),
		eH2250LogicalChannelAckParameters_dynamicRTPPayloadType =
		    (1 << 27),
		eH2250LogicalChannelAckParameters_flowControlToZero =
		    (1 << 26),
		eH2250LogicalChannelAckParameters_portNumber = (1 << 25),
	} options;
	H245_TransportAddress mediaChannel;
	H245_TransportAddress mediaControlChannel;
} H2250LogicalChannelAckParameters;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {	/* CHOICE */
	enum {
		eOpenLogicalChannelAck_forwardMultiplexAckParameters_h2250LogicalChannelAckParameters,
	} choice;
	union {
		H2250LogicalChannelAckParameters
		    h2250LogicalChannelAckParameters;
	};
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct OpenLogicalChannelAck {	/* SEQUENCE */
	enum {
		eOpenLogicalChannelAck_reverseLogicalChannelParameters =
		    (1 << 31),
		eOpenLogicalChannelAck_separateStack = (1 << 30),
		eOpenLogicalChannelAck_forwardMultiplexAckParameters =
		    (1 << 29),
		eOpenLogicalChannelAck_encryptionSync = (1 << 28),
	} options;
	OpenLogicalChannelAck_reverseLogicalChannelParameters
	    reverseLogicalChannelParameters;
	NetworkAccessParameters separateStack;
	OpenLogicalChannelAck_forwardMultiplexAckParameters
	    forwardMultiplexAckParameters;
} OpenLogicalChannelAck;

typedef struct ResponseMessage {	/* CHOICE */
	enum {
		eResponseMessage_nonStandard,
		eResponseMessage_masterSlaveDeterminationAck,
		eResponseMessage_masterSlaveDeterminationReject,
		eResponseMessage_terminalCapabilitySetAck,
		eResponseMessage_terminalCapabilitySetReject,
		eResponseMessage_openLogicalChannelAck,
		eResponseMessage_openLogicalChannelReject,
		eResponseMessage_closeLogicalChannelAck,
		eResponseMessage_requestChannelCloseAck,
		eResponseMessage_requestChannelCloseReject,
		eResponseMessage_multiplexEntrySendAck,
		eResponseMessage_multiplexEntrySendReject,
		eResponseMessage_requestMultiplexEntryAck,
		eResponseMessage_requestMultiplexEntryReject,
		eResponseMessage_requestModeAck,
		eResponseMessage_requestModeReject,
		eResponseMessage_roundTripDelayResponse,
		eResponseMessage_maintenanceLoopAck,
		eResponseMessage_maintenanceLoopReject,
		eResponseMessage_communicationModeResponse,
		eResponseMessage_conferenceResponse,
		eResponseMessage_multilinkResponse,
		eResponseMessage_logicalChannelRateAcknowledge,
		eResponseMessage_logicalChannelRateReject,
	} choice;
	union {
		OpenLogicalChannelAck openLogicalChannelAck;
	};
} ResponseMessage;

typedef struct MultimediaSystemControlMessage {	/* CHOICE */
	enum {
		eMultimediaSystemControlMessage_request,
		eMultimediaSystemControlMessage_response,
		eMultimediaSystemControlMessage_command,
		eMultimediaSystemControlMessage_indication,
	} choice;
	union {
		RequestMessage request;
		ResponseMessage response;
	};
} MultimediaSystemControlMessage;

typedef struct H323_UU_PDU_h245Control {	/* SEQUENCE OF */
	int count;
	MultimediaSystemControlMessage item[4];
} H323_UU_PDU_h245Control;

typedef struct H323_UU_PDU {	/* SEQUENCE */
	enum {
		eH323_UU_PDU_nonStandardData = (1 << 31),
		eH323_UU_PDU_h4501SupplementaryService = (1 << 30),
		eH323_UU_PDU_h245Tunneling = (1 << 29),
		eH323_UU_PDU_h245Control = (1 << 28),
		eH323_UU_PDU_nonStandardControl = (1 << 27),
		eH323_UU_PDU_callLinkage = (1 << 26),
		eH323_UU_PDU_tunnelledSignallingMessage = (1 << 25),
		eH323_UU_PDU_provisionalRespToH245Tunneling = (1 << 24),
		eH323_UU_PDU_stimulusControl = (1 << 23),
		eH323_UU_PDU_genericData = (1 << 22),
	} options;
	H323_UU_PDU_h323_message_body h323_message_body;
	H323_UU_PDU_h245Control h245Control;
} H323_UU_PDU;

typedef struct H323_UserInformation {	/* SEQUENCE */
	enum {
		eH323_UserInformation_user_data = (1 << 31),
	} options;
	H323_UU_PDU h323_uu_pdu;
} H323_UserInformation;

typedef struct GatekeeperRequest {	/* SEQUENCE */
	enum {
		eGatekeeperRequest_nonStandardData = (1 << 31),
		eGatekeeperRequest_gatekeeperIdentifier = (1 << 30),
		eGatekeeperRequest_callServices = (1 << 29),
		eGatekeeperRequest_endpointAlias = (1 << 28),
		eGatekeeperRequest_alternateEndpoints = (1 << 27),
		eGatekeeperRequest_tokens = (1 << 26),
		eGatekeeperRequest_cryptoTokens = (1 << 25),
		eGatekeeperRequest_authenticationCapability = (1 << 24),
		eGatekeeperRequest_algorithmOIDs = (1 << 23),
		eGatekeeperRequest_integrity = (1 << 22),
		eGatekeeperRequest_integrityCheckValue = (1 << 21),
		eGatekeeperRequest_supportsAltGK = (1 << 20),
		eGatekeeperRequest_featureSet = (1 << 19),
		eGatekeeperRequest_genericData = (1 << 18),
	} options;
	TransportAddress rasAddress;
} GatekeeperRequest;

typedef struct GatekeeperConfirm {	/* SEQUENCE */
	enum {
		eGatekeeperConfirm_nonStandardData = (1 << 31),
		eGatekeeperConfirm_gatekeeperIdentifier = (1 << 30),
		eGatekeeperConfirm_alternateGatekeeper = (1 << 29),
		eGatekeeperConfirm_authenticationMode = (1 << 28),
		eGatekeeperConfirm_tokens = (1 << 27),
		eGatekeeperConfirm_cryptoTokens = (1 << 26),
		eGatekeeperConfirm_algorithmOID = (1 << 25),
		eGatekeeperConfirm_integrity = (1 << 24),
		eGatekeeperConfirm_integrityCheckValue = (1 << 23),
		eGatekeeperConfirm_featureSet = (1 << 22),
		eGatekeeperConfirm_genericData = (1 << 21),
	} options;
	TransportAddress rasAddress;
} GatekeeperConfirm;

typedef struct RegistrationRequest_callSignalAddress {	/* SEQUENCE OF */
	int count;
	TransportAddress item[10];
} RegistrationRequest_callSignalAddress;

typedef struct RegistrationRequest_rasAddress {	/* SEQUENCE OF */
	int count;
	TransportAddress item[10];
} RegistrationRequest_rasAddress;

typedef struct RegistrationRequest {	/* SEQUENCE */
	enum {
		eRegistrationRequest_nonStandardData = (1 << 31),
		eRegistrationRequest_terminalAlias = (1 << 30),
		eRegistrationRequest_gatekeeperIdentifier = (1 << 29),
		eRegistrationRequest_alternateEndpoints = (1 << 28),
		eRegistrationRequest_timeToLive = (1 << 27),
		eRegistrationRequest_tokens = (1 << 26),
		eRegistrationRequest_cryptoTokens = (1 << 25),
		eRegistrationRequest_integrityCheckValue = (1 << 24),
		eRegistrationRequest_keepAlive = (1 << 23),
		eRegistrationRequest_endpointIdentifier = (1 << 22),
		eRegistrationRequest_willSupplyUUIEs = (1 << 21),
		eRegistrationRequest_maintainConnection = (1 << 20),
		eRegistrationRequest_alternateTransportAddresses = (1 << 19),
		eRegistrationRequest_additiveRegistration = (1 << 18),
		eRegistrationRequest_terminalAliasPattern = (1 << 17),
		eRegistrationRequest_supportsAltGK = (1 << 16),
		eRegistrationRequest_usageReportingCapability = (1 << 15),
		eRegistrationRequest_multipleCalls = (1 << 14),
		eRegistrationRequest_supportedH248Packages = (1 << 13),
		eRegistrationRequest_callCreditCapability = (1 << 12),
		eRegistrationRequest_capacityReportingCapability = (1 << 11),
		eRegistrationRequest_capacity = (1 << 10),
		eRegistrationRequest_featureSet = (1 << 9),
		eRegistrationRequest_genericData = (1 << 8),
	} options;
	RegistrationRequest_callSignalAddress callSignalAddress;
	RegistrationRequest_rasAddress rasAddress;
	unsigned int timeToLive;
} RegistrationRequest;

typedef struct RegistrationConfirm_callSignalAddress {	/* SEQUENCE OF */
	int count;
	TransportAddress item[10];
} RegistrationConfirm_callSignalAddress;

typedef struct RegistrationConfirm {	/* SEQUENCE */
	enum {
		eRegistrationConfirm_nonStandardData = (1 << 31),
		eRegistrationConfirm_terminalAlias = (1 << 30),
		eRegistrationConfirm_gatekeeperIdentifier = (1 << 29),
		eRegistrationConfirm_alternateGatekeeper = (1 << 28),
		eRegistrationConfirm_timeToLive = (1 << 27),
		eRegistrationConfirm_tokens = (1 << 26),
		eRegistrationConfirm_cryptoTokens = (1 << 25),
		eRegistrationConfirm_integrityCheckValue = (1 << 24),
		eRegistrationConfirm_willRespondToIRR = (1 << 23),
		eRegistrationConfirm_preGrantedARQ = (1 << 22),
		eRegistrationConfirm_maintainConnection = (1 << 21),
		eRegistrationConfirm_serviceControl = (1 << 20),
		eRegistrationConfirm_supportsAdditiveRegistration = (1 << 19),
		eRegistrationConfirm_terminalAliasPattern = (1 << 18),
		eRegistrationConfirm_supportedPrefixes = (1 << 17),
		eRegistrationConfirm_usageSpec = (1 << 16),
		eRegistrationConfirm_featureServerAlias = (1 << 15),
		eRegistrationConfirm_capacityReportingSpec = (1 << 14),
		eRegistrationConfirm_featureSet = (1 << 13),
		eRegistrationConfirm_genericData = (1 << 12),
	} options;
	RegistrationConfirm_callSignalAddress callSignalAddress;
	unsigned int timeToLive;
} RegistrationConfirm;

typedef struct UnregistrationRequest_callSignalAddress {	/* SEQUENCE OF */
	int count;
	TransportAddress item[10];
} UnregistrationRequest_callSignalAddress;

typedef struct UnregistrationRequest {	/* SEQUENCE */
	enum {
		eUnregistrationRequest_endpointAlias = (1 << 31),
		eUnregistrationRequest_nonStandardData = (1 << 30),
		eUnregistrationRequest_endpointIdentifier = (1 << 29),
		eUnregistrationRequest_alternateEndpoints = (1 << 28),
		eUnregistrationRequest_gatekeeperIdentifier = (1 << 27),
		eUnregistrationRequest_tokens = (1 << 26),
		eUnregistrationRequest_cryptoTokens = (1 << 25),
		eUnregistrationRequest_integrityCheckValue = (1 << 24),
		eUnregistrationRequest_reason = (1 << 23),
		eUnregistrationRequest_endpointAliasPattern = (1 << 22),
		eUnregistrationRequest_supportedPrefixes = (1 << 21),
		eUnregistrationRequest_alternateGatekeeper = (1 << 20),
		eUnregistrationRequest_genericData = (1 << 19),
	} options;
	UnregistrationRequest_callSignalAddress callSignalAddress;
} UnregistrationRequest;

typedef struct AdmissionRequest {	/* SEQUENCE */
	enum {
		eAdmissionRequest_callModel = (1 << 31),
		eAdmissionRequest_destinationInfo = (1 << 30),
		eAdmissionRequest_destCallSignalAddress = (1 << 29),
		eAdmissionRequest_destExtraCallInfo = (1 << 28),
		eAdmissionRequest_srcCallSignalAddress = (1 << 27),
		eAdmissionRequest_nonStandardData = (1 << 26),
		eAdmissionRequest_callServices = (1 << 25),
		eAdmissionRequest_canMapAlias = (1 << 24),
		eAdmissionRequest_callIdentifier = (1 << 23),
		eAdmissionRequest_srcAlternatives = (1 << 22),
		eAdmissionRequest_destAlternatives = (1 << 21),
		eAdmissionRequest_gatekeeperIdentifier = (1 << 20),
		eAdmissionRequest_tokens = (1 << 19),
		eAdmissionRequest_cryptoTokens = (1 << 18),
		eAdmissionRequest_integrityCheckValue = (1 << 17),
		eAdmissionRequest_transportQOS = (1 << 16),
		eAdmissionRequest_willSupplyUUIEs = (1 << 15),
		eAdmissionRequest_callLinkage = (1 << 14),
		eAdmissionRequest_gatewayDataRate = (1 << 13),
		eAdmissionRequest_capacity = (1 << 12),
		eAdmissionRequest_circuitInfo = (1 << 11),
		eAdmissionRequest_desiredProtocols = (1 << 10),
		eAdmissionRequest_desiredTunnelledProtocol = (1 << 9),
		eAdmissionRequest_featureSet = (1 << 8),
		eAdmissionRequest_genericData = (1 << 7),
	} options;
	TransportAddress destCallSignalAddress;
	TransportAddress srcCallSignalAddress;
} AdmissionRequest;

typedef struct AdmissionConfirm {	/* SEQUENCE */
	enum {
		eAdmissionConfirm_irrFrequency = (1 << 31),
		eAdmissionConfirm_nonStandardData = (1 << 30),
		eAdmissionConfirm_destinationInfo = (1 << 29),
		eAdmissionConfirm_destExtraCallInfo = (1 << 28),
		eAdmissionConfirm_destinationType = (1 << 27),
		eAdmissionConfirm_remoteExtensionAddress = (1 << 26),
		eAdmissionConfirm_alternateEndpoints = (1 << 25),
		eAdmissionConfirm_tokens = (1 << 24),
		eAdmissionConfirm_cryptoTokens = (1 << 23),
		eAdmissionConfirm_integrityCheckValue = (1 << 22),
		eAdmissionConfirm_transportQOS = (1 << 21),
		eAdmissionConfirm_willRespondToIRR = (1 << 20),
		eAdmissionConfirm_uuiesRequested = (1 << 19),
		eAdmissionConfirm_language = (1 << 18),
		eAdmissionConfirm_alternateTransportAddresses = (1 << 17),
		eAdmissionConfirm_useSpecifiedTransport = (1 << 16),
		eAdmissionConfirm_circuitInfo = (1 << 15),
		eAdmissionConfirm_usageSpec = (1 << 14),
		eAdmissionConfirm_supportedProtocols = (1 << 13),
		eAdmissionConfirm_serviceControl = (1 << 12),
		eAdmissionConfirm_multipleCalls = (1 << 11),
		eAdmissionConfirm_featureSet = (1 << 10),
		eAdmissionConfirm_genericData = (1 << 9),
	} options;
	TransportAddress destCallSignalAddress;
} AdmissionConfirm;

typedef struct LocationRequest {	/* SEQUENCE */
	enum {
		eLocationRequest_endpointIdentifier = (1 << 31),
		eLocationRequest_nonStandardData = (1 << 30),
		eLocationRequest_sourceInfo = (1 << 29),
		eLocationRequest_canMapAlias = (1 << 28),
		eLocationRequest_gatekeeperIdentifier = (1 << 27),
		eLocationRequest_tokens = (1 << 26),
		eLocationRequest_cryptoTokens = (1 << 25),
		eLocationRequest_integrityCheckValue = (1 << 24),
		eLocationRequest_desiredProtocols = (1 << 23),
		eLocationRequest_desiredTunnelledProtocol = (1 << 22),
		eLocationRequest_featureSet = (1 << 21),
		eLocationRequest_genericData = (1 << 20),
		eLocationRequest_hopCount = (1 << 19),
		eLocationRequest_circuitInfo = (1 << 18),
	} options;
	TransportAddress replyAddress;
} LocationRequest;

typedef struct LocationConfirm {	/* SEQUENCE */
	enum {
		eLocationConfirm_nonStandardData = (1 << 31),
		eLocationConfirm_destinationInfo = (1 << 30),
		eLocationConfirm_destExtraCallInfo = (1 << 29),
		eLocationConfirm_destinationType = (1 << 28),
		eLocationConfirm_remoteExtensionAddress = (1 << 27),
		eLocationConfirm_alternateEndpoints = (1 << 26),
		eLocationConfirm_tokens = (1 << 25),
		eLocationConfirm_cryptoTokens = (1 << 24),
		eLocationConfirm_integrityCheckValue = (1 << 23),
		eLocationConfirm_alternateTransportAddresses = (1 << 22),
		eLocationConfirm_supportedProtocols = (1 << 21),
		eLocationConfirm_multipleCalls = (1 << 20),
		eLocationConfirm_featureSet = (1 << 19),
		eLocationConfirm_genericData = (1 << 18),
		eLocationConfirm_circuitInfo = (1 << 17),
		eLocationConfirm_serviceControl = (1 << 16),
	} options;
	TransportAddress callSignalAddress;
	TransportAddress rasAddress;
} LocationConfirm;

typedef struct InfoRequestResponse_callSignalAddress {	/* SEQUENCE OF */
	int count;
	TransportAddress item[10];
} InfoRequestResponse_callSignalAddress;

typedef struct InfoRequestResponse {	/* SEQUENCE */
	enum {
		eInfoRequestResponse_nonStandardData = (1 << 31),
		eInfoRequestResponse_endpointAlias = (1 << 30),
		eInfoRequestResponse_perCallInfo = (1 << 29),
		eInfoRequestResponse_tokens = (1 << 28),
		eInfoRequestResponse_cryptoTokens = (1 << 27),
		eInfoRequestResponse_integrityCheckValue = (1 << 26),
		eInfoRequestResponse_needResponse = (1 << 25),
		eInfoRequestResponse_capacity = (1 << 24),
		eInfoRequestResponse_irrStatus = (1 << 23),
		eInfoRequestResponse_unsolicited = (1 << 22),
		eInfoRequestResponse_genericData = (1 << 21),
	} options;
	TransportAddress rasAddress;
	InfoRequestResponse_callSignalAddress callSignalAddress;
} InfoRequestResponse;

typedef struct RasMessage {	/* CHOICE */
	enum {
		eRasMessage_gatekeeperRequest,
		eRasMessage_gatekeeperConfirm,
		eRasMessage_gatekeeperReject,
		eRasMessage_registrationRequest,
		eRasMessage_registrationConfirm,
		eRasMessage_registrationReject,
		eRasMessage_unregistrationRequest,
		eRasMessage_unregistrationConfirm,
		eRasMessage_unregistrationReject,
		eRasMessage_admissionRequest,
		eRasMessage_admissionConfirm,
		eRasMessage_admissionReject,
		eRasMessage_bandwidthRequest,
		eRasMessage_bandwidthConfirm,
		eRasMessage_bandwidthReject,
		eRasMessage_disengageRequest,
		eRasMessage_disengageConfirm,
		eRasMessage_disengageReject,
		eRasMessage_locationRequest,
		eRasMessage_locationConfirm,
		eRasMessage_locationReject,
		eRasMessage_infoRequest,
		eRasMessage_infoRequestResponse,
		eRasMessage_nonStandardMessage,
		eRasMessage_unknownMessageResponse,
		eRasMessage_requestInProgress,
		eRasMessage_resourcesAvailableIndicate,
		eRasMessage_resourcesAvailableConfirm,
		eRasMessage_infoRequestAck,
		eRasMessage_infoRequestNak,
		eRasMessage_serviceControlIndication,
		eRasMessage_serviceControlResponse,
	} choice;
	union {
		GatekeeperRequest gatekeeperRequest;
		GatekeeperConfirm gatekeeperConfirm;
		RegistrationRequest registrationRequest;
		RegistrationConfirm registrationConfirm;
		UnregistrationRequest unregistrationRequest;
		AdmissionRequest admissionRequest;
		AdmissionConfirm admissionConfirm;
		LocationRequest locationRequest;
		LocationConfirm locationConfirm;
		InfoRequestResponse infoRequestResponse;
	};
} RasMessage;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _NF_CONNTRACK_FTP_H
#define _NF_CONNTRACK_FTP_H

#include <uapi/linux/netfilter/nf_conntrack_ftp.h>


#define FTP_PORT	21

#define NF_CT_FTP_SEQ_PICKUP	(1 << 0)

#define NUM_SEQ_TO_REMEMBER 2
/* This structure exists only once per master */
struct nf_ct_ftp_master {
	/* Valid seq positions for cmd matching after newline */
	u_int32_t seq_aft_nl[IP_CT_DIR_MAX][NUM_SEQ_TO_REMEMBER];
	/* 0 means seq_match_aft_nl not set */
	u_int16_t seq_aft_nl_num[IP_CT_DIR_MAX];
	/* pickup sequence tracking, useful for conntrackd */
	u_int16_t flags[IP_CT_DIR_MAX];
};

struct nf_conntrack_expect;

/* For NAT to hook in when we find a packet which describes what other
 * connection we should expect. */
extern unsigned int (*nf_nat_ftp_hook)(struct sk_buff *skb,
				       enum ip_conntrack_info ctinfo,
				       enum nf_ct_ftp_type type,
				       unsigned int protoff,
				       unsigned int matchoff,
				       unsigned int matchlen,
				       struct nf_conntrack_expect *exp);
#endif /* _NF_CONNTRACK_FTP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef __IP_SET_BITMAP_H
#define __IP_SET_BITMAP_H

#include <uapi/linux/netfilter/ipset/ip_set_bitmap.h>

#define IPSET_BITMAP_MAX_RANGE	0x0000FFFF

enum {
	IPSET_ADD_FAILED = 1,
	IPSET_ADD_STORE_PLAIN_TIMEOUT,
	IPSET_ADD_START_STORED_TIMEOUT,
};

/* Common functions */

static inline u32
range_to_mask(u32 from, u32 to, u8 *bits)
{
	u32 mask = 0xFFFFFFFE;

	*bits = 32;
	while (--(*bits) > 0 && mask && (to & mask) != from)
		mask <<= 1;

	return mask;
}

#endif /* __IP_SET_BITMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _IP_SET_COMMENT_H
#define _IP_SET_COMMENT_H

/* Copyright (C) 2013 Oliver Smith <oliver@8.c.9.b.0.7.4.0.1.0.0.2.ip6.arpa>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifdef __KERNEL__

static inline char*
ip_set_comment_uget(struct nlattr *tb)
{
	return nla_data(tb);
}

/* Called from uadd only, protected by the set spinlock.
 * The kadt functions don't use the comment extensions in any way.
 */
static inline void
ip_set_init_comment(struct ip_set_comment *comment,
		    const struct ip_set_ext *ext)
{
	struct ip_set_comment_rcu *c = rcu_dereference_protected(comment->c, 1);
	size_t len = ext->comment ? strlen(ext->comment) : 0;

	if (unlikely(c)) {
		kfree_rcu(c, rcu);
		rcu_assign_pointer(comment->c, NULL);
	}
	if (!len)
		return;
	if (unlikely(len > IPSET_MAX_COMMENT_SIZE))
		len = IPSET_MAX_COMMENT_SIZE;
	c = kzalloc(sizeof(*c) + len + 1, GFP_ATOMIC);
	if (unlikely(!c))
		return;
	strlcpy(c->str, ext->comment, len + 1);
	rcu_assign_pointer(comment->c, c);
}

/* Used only when dumping a set, protected by rcu_read_lock_bh() */
static inline int
ip_set_put_comment(struct sk_buff *skb, struct ip_set_comment *comment)
{
	struct ip_set_comment_rcu *c = rcu_dereference_bh(comment->c);

	if (!c)
		return 0;
	return nla_put_string(skb, IPSET_ATTR_COMMENT, c->str);
}

/* Called from uadd/udel, flush or the garbage collectors protected
 * by the set spinlock.
 * Called when the set is destroyed and when there can't be any user
 * of the set data anymore.
 */
static inline void
ip_set_comment_free(struct ip_set_comment *comment)
{
	struct ip_set_comment_rcu *c;

	c = rcu_dereference_protected(comment->c, 1);
	if (unlikely(!c))
		return;
	kfree_rcu(c, rcu);
	rcu_assign_pointer(comment->c, NULL);
}

#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef __IP_SET_HASH_H
#define __IP_SET_HASH_H

#include <uapi/linux/netfilter/ipset/ip_set_hash.h>


#define IPSET_DEFAULT_HASHSIZE		1024
#define IPSET_MIMINAL_HASHSIZE		64
#define IPSET_DEFAULT_MAXELEM		65536
#define IPSET_DEFAULT_PROBES		4
#define IPSET_DEFAULT_RESIZE		100

#endif /* __IP_SET_HASH_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef __IP_SET_LIST_H
#define __IP_SET_LIST_H

#include <uapi/linux/netfilter/ipset/ip_set_list.h>


#define IP_SET_LIST_DEFAULT_SIZE	8
#define IP_SET_LIST_MIN_SIZE		4
#define IP_SET_LIST_MAX_SIZE		65536

#endif /* __IP_SET_LIST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _PFXLEN_H
#define _PFXLEN_H

#include <asm/byteorder.h>
#include <linux/netfilter.h>
#include <net/tcp.h>

/* Prefixlen maps, by Jan Engelhardt  */
extern const union nf_inet_addr ip_set_netmask_map[];
extern const union nf_inet_addr ip_set_hostmask_map[];

static inline __be32
ip_set_netmask(u8 pfxlen)
{
	return ip_set_netmask_map[pfxlen].ip;
}

static inline const __be32 *
ip_set_netmask6(u8 pfxlen)
{
	return &ip_set_netmask_map[pfxlen].ip6[0];
}

static inline u32
ip_set_hostmask(u8 pfxlen)
{
	return (__force u32) ip_set_hostmask_map[pfxlen].ip;
}

static inline const __be32 *
ip_set_hostmask6(u8 pfxlen)
{
	return &ip_set_hostmask_map[pfxlen].ip6[0];
}

extern u32 ip_set_range_to_cidr(u32 from, u32 to, u8 *cidr);

#define ip_set_mask_from_to(from, to, cidr)	\
do {						\
	from &= ip_set_hostmask(cidr);		\
	to = from | ~ip_set_hostmask(cidr);	\
} while (0)

static inline void
ip6_netmask(union nf_inet_addr *ip, u8 prefix)
{
	ip->ip6[0] &= ip_set_netmask6(prefix)[0];
	ip->ip6[1] &= ip_set_netmask6(prefix)[1];
	ip->ip6[2] &= ip_set_netmask6(prefix)[2];
	ip->ip6[3] &= ip_set_netmask6(prefix)[3];
}

#endif /*_PFXLEN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
 *                         Patrick Schaaf <bof@bof.de>
 *                         Martin Josefsson <gandalf@wlug.westbo.se>
 * Copyright (C) 2003-2013 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef _IP_SET_H
#define _IP_SET_H

#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/x_tables.h>
#include <linux/stringify.h>
#include <linux/vmalloc.h>
#include <net/netlink.h>
#include <uapi/linux/netfilter/ipset/ip_set.h>

#define _IP_SET_MODULE_DESC(a, b, c)		\
	MODULE_DESCRIPTION(a " type of IP sets, revisions " b "-" c)
#define IP_SET_MODULE_DESC(a, b, c)		\
	_IP_SET_MODULE_DESC(a, __stringify(b), __stringify(c))

/* Set features */
enum ip_set_feature {
	IPSET_TYPE_IP_FLAG = 0,
	IPSET_TYPE_IP = (1 << IPSET_TYPE_IP_FLAG),
	IPSET_TYPE_PORT_FLAG = 1,
	IPSET_TYPE_PORT = (1 << IPSET_TYPE_PORT_FLAG),
	IPSET_TYPE_MAC_FLAG = 2,
	IPSET_TYPE_MAC = (1 << IPSET_TYPE_MAC_FLAG),
	IPSET_TYPE_IP2_FLAG = 3,
	IPSET_TYPE_IP2 = (1 << IPSET_TYPE_IP2_FLAG),
	IPSET_TYPE_NAME_FLAG = 4,
	IPSET_TYPE_NAME = (1 << IPSET_TYPE_NAME_FLAG),
	IPSET_TYPE_IFACE_FLAG = 5,
	IPSET_TYPE_IFACE = (1 << IPSET_TYPE_IFACE_FLAG),
	IPSET_TYPE_MARK_FLAG = 6,
	IPSET_TYPE_MARK = (1 << IPSET_TYPE_MARK_FLAG),
	IPSET_TYPE_NOMATCH_FLAG = 7,
	IPSET_TYPE_NOMATCH = (1 << IPSET_TYPE_NOMATCH_FLAG),
	/* Strictly speaking not a feature, but a flag for dumping:
	 * this settype must be dumped last */
	IPSET_DUMP_LAST_FLAG = 8,
	IPSET_DUMP_LAST = (1 << IPSET_DUMP_LAST_FLAG),
};

/* Set extensions */
enum ip_set_extension {
	IPSET_EXT_BIT_TIMEOUT = 0,
	IPSET_EXT_TIMEOUT = (1 << IPSET_EXT_BIT_TIMEOUT),
	IPSET_EXT_BIT_COUNTER = 1,
	IPSET_EXT_COUNTER = (1 << IPSET_EXT_BIT_COUNTER),
	IPSET_EXT_BIT_COMMENT = 2,
	IPSET_EXT_COMMENT = (1 << IPSET_EXT_BIT_COMMENT),
	IPSET_EXT_BIT_SKBINFO = 3,
	IPSET_EXT_SKBINFO = (1 << IPSET_EXT_BIT_SKBINFO),
	/* Mark set with an extension which needs to call destroy */
	IPSET_EXT_BIT_DESTROY = 7,
	IPSET_EXT_DESTROY = (1 << IPSET_EXT_BIT_DESTROY),
};

#define SET_WITH_TIMEOUT(s)	((s)->extensions & IPSET_EXT_TIMEOUT)
#define SET_WITH_COUNTER(s)	((s)->extensions & IPSET_EXT_COUNTER)
#define SET_WITH_COMMENT(s)	((s)->extensions & IPSET_EXT_COMMENT)
#define SET_WITH_SKBINFO(s)	((s)->extensions & IPSET_EXT_SKBINFO)
#define SET_WITH_FORCEADD(s)	((s)->flags & IPSET_CREATE_FLAG_FORCEADD)

/* Extension id, in size order */
enum ip_set_ext_id {
	IPSET_EXT_ID_COUNTER = 0,
	IPSET_EXT_ID_TIMEOUT,
	IPSET_EXT_ID_SKBINFO,
	IPSET_EXT_ID_COMMENT,
	IPSET_EXT_ID_MAX,
};

/* Extension type */
struct ip_set_ext_type {
	/* Destroy extension private data (can be NULL) */
	void (*destroy)(void *ext);
	enum ip_set_extension type;
	enum ipset_cadt_flags flag;
	/* Size and minimal alignment */
	u8 len;
	u8 align;
};

extern const struct ip_set_ext_type ip_set_extensions[];

struct ip_set_ext {
	u64 packets;
	u64 bytes;
	u32 timeout;
	u32 skbmark;
	u32 skbmarkmask;
	u32 skbprio;
	u16 skbqueue;
	char *comment;
};

struct ip_set_counter {
	atomic64_t bytes;
	atomic64_t packets;
};

struct ip_set_comment_rcu {
	struct rcu_head rcu;
	char str[0];
};

struct ip_set_comment {
	struct ip_set_comment_rcu __rcu *c;
};

struct ip_set_skbinfo {
	u32 skbmark;
	u32 skbmarkmask;
	u32 skbprio;
	u16 skbqueue;
};

struct ip_set;

#define ext_timeout(e, s)	\
((unsigned long *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_TIMEOUT]))
#define ext_counter(e, s)	\
((struct ip_set_counter *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COUNTER]))
#define ext_comment(e, s)	\
((struct ip_set_comment *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COMMENT]))
#define ext_skbinfo(e, s)	\
((struct ip_set_skbinfo *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_SKBINFO]))

typedef int (*ipset_adtfn)(struct ip_set *set, void *value,
			   const struct ip_set_ext *ext,
			   struct ip_set_ext *mext, u32 cmdflags);

/* Kernel API function options */
struct ip_set_adt_opt {
	u8 family;		/* Actual protocol family */
	u8 dim;			/* Dimension of match/target */
	u8 flags;		/* Direction and negation flags */
	u32 cmdflags;		/* Command-like flags */
	struct ip_set_ext ext;	/* Extensions */
};

/* Set type, variant-specific part */
struct ip_set_type_variant {
	/* Kernelspace: test/add/del entries
	 *		returns negative error code,
	 *			zero for no match/success to add/delete
	 *			positive for matching element */
	int (*kadt)(struct ip_set *set, const struct sk_buff *skb,
		    const struct xt_action_param *par,
		    enum ipset_adt adt, struct ip_set_adt_opt *opt);

	/* Userspace: test/add/del entries
	 *		returns negative error code,
	 *			zero for no match/success to add/delete
	 *			positive for matching element */
	int (*uadt)(struct ip_set *set, struct nlattr *tb[],
		    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried);

	/* Low level add/del/test functions */
	ipset_adtfn adt[IPSET_ADT_MAX];

	/* When adding entries and set is full, try to resize the set */
	int (*resize)(struct ip_set *set, bool retried);
	/* Destroy the set */
	void (*destroy)(struct ip_set *set);
	/* Flush the elements */
	void (*flush)(struct ip_set *set);
	/* Expire entries before listing */
	void (*expire)(struct ip_set *set);
	/* List set header data */
	int (*head)(struct ip_set *set, struct sk_buff *skb);
	/* List elements */
	int (*list)(const struct ip_set *set, struct sk_buff *skb,
		    struct netlink_callback *cb);
	/* Keep listing private when resizing runs parallel */
	void (*uref)(struct ip_set *set, struct netlink_callback *cb,
		     bool start);

	/* Return true if "b" set is the same as "a"
	 * according to the create set parameters */
	bool (*same_set)(const struct ip_set *a, const struct ip_set *b);
};

/* The core set type structure */
struct ip_set_type {
	struct list_head list;

	/* Typename */
	char name[IPSET_MAXNAMELEN];
	/* Protocol version */
	u8 protocol;
	/* Set type dimension */
	u8 dimension;
	/*
	 * Supported family: may be NFPROTO_UNSPEC for both
	 * NFPROTO_IPV4/NFPROTO_IPV6.
	 */
	u8 family;
	/* Type revisions */
	u8 revision_min, revision_max;
	/* Set features to control swapping */
	u16 features;

	/* Create set */
	int (*create)(struct net *net, struct ip_set *set,
		      struct nlattr *tb[], u32 flags);

	/* Attribute policies */
	const struct nla_policy create_policy[IPSET_ATTR_CREATE_MAX + 1];
	const struct nla_policy adt_policy[IPSET_ATTR_ADT_MAX + 1];

	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
	struct module *me;
};

/* register and unregister set type */
extern int ip_set_type_register(struct ip_set_type *set_type);
extern void ip_set_type_unregister(struct ip_set_type *set_type);

/* A generic IP set */
struct ip_set {
	/* The name of the set */
	char name[IPSET_MAXNAMELEN];
	/* Lock protecting the set data */
	spinlock_t lock;
	/* References to the set */
	u32 ref;
	/* References to the set for netlink events like dump,
	 * ref can be swapped out by ip_set_swap
	 */
	u32 ref_netlink;
	/* The core set type */
	struct ip_set_type *type;
	/* The type variant doing the real job */
	const struct ip_set_type_variant *variant;
	/* The actual INET family of the set */
	u8 family;
	/* The type revision */
	u8 revision;
	/* Extensions */
	u8 extensions;
	/* Create flags */
	u8 flags;
	/* Default timeout value, if enabled */
	u32 timeout;
	/* Element data size */
	size_t dsize;
	/* Offsets to extensions in elements */
	size_t offset[IPSET_EXT_ID_MAX];
	/* The type specific data */
	void *data;
};

static inline void
ip_set_ext_destroy(struct ip_set *set, void *data)
{
	/* Check that the extension is enabled for the set and
	 * call it's destroy function for its extension part in data.
	 */
	if (SET_WITH_COMMENT(set))
		ip_set_extensions[IPSET_EXT_ID_COMMENT].destroy(
			ext_comment(data, set));
}

static inline int
ip_set_put_flags(struct sk_buff *skb, struct ip_set *set)
{
	u32 cadt_flags = 0;

	if (SET_WITH_TIMEOUT(set))
		if (unlikely(nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
					   htonl(set->timeout))))
			return -EMSGSIZE;
	if (SET_WITH_COUNTER(set))
		cadt_flags |= IPSET_FLAG_WITH_COUNTERS;
	if (SET_WITH_COMMENT(set))
		cadt_flags |= IPSET_FLAG_WITH_COMMENT;
	if (SET_WITH_SKBINFO(set))
		cadt_flags |= IPSET_FLAG_WITH_SKBINFO;
	if (SET_WITH_FORCEADD(set))
		cadt_flags |= IPSET_FLAG_WITH_FORCEADD;

	if (!cadt_flags)
		return 0;
	return nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(cadt_flags));
}

static inline void
ip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)
{
	atomic64_add((long long)bytes, &(counter)->bytes);
}

static inline void
ip_set_add_packets(u64 packets, struct ip_set_counter *counter)
{
	atomic64_add((long long)packets, &(counter)->packets);
}

static inline u64
ip_set_get_bytes(const struct ip_set_counter *counter)
{
	return (u64)atomic64_read(&(counter)->bytes);
}

static inline u64
ip_set_get_packets(const struct ip_set_counter *counter)
{
	return (u64)atomic64_read(&(counter)->packets);
}

static inline void
ip_set_update_counter(struct ip_set_counter *counter,
		      const struct ip_set_ext *ext,
		      struct ip_set_ext *mext, u32 flags)
{
	if (ext->packets != ULLONG_MAX &&
	    !(flags & IPSET_FLAG_SKIP_COUNTER_UPDATE)) {
		ip_set_add_bytes(ext->bytes, counter);
		ip_set_add_packets(ext->packets, counter);
	}
	if (flags & IPSET_FLAG_MATCH_COUNTERS) {
		mext->packets = ip_set_get_packets(counter);
		mext->bytes = ip_set_get_bytes(counter);
	}
}

static inline void
ip_set_get_skbinfo(struct ip_set_skbinfo *skbinfo,
		      const struct ip_set_ext *ext,
		      struct ip_set_ext *mext, u32 flags)
{
		mext->skbmark = skbinfo->skbmark;
		mext->skbmarkmask = skbinfo->skbmarkmask;
		mext->skbprio = skbinfo->skbprio;
		mext->skbqueue = skbinfo->skbqueue;
}
static inline bool
ip_set_put_skbinfo(struct sk_buff *skb, struct ip_set_skbinfo *skbinfo)
{
	/* Send nonzero parameters only */
	return ((skbinfo->skbmark || skbinfo->skbmarkmask) &&
		nla_put_net64(skb, IPSET_ATTR_SKBMARK,
			      cpu_to_be64((u64)skbinfo->skbmark << 32 |
					  skbinfo->skbmarkmask),
			      IPSET_ATTR_PAD)) ||
	       (skbinfo->skbprio &&
		nla_put_net32(skb, IPSET_ATTR_SKBPRIO,
			      cpu_to_be32(skbinfo->skbprio))) ||
	       (skbinfo->skbqueue &&
		nla_put_net16(skb, IPSET_ATTR_SKBQUEUE,
			     cpu_to_be16(skbinfo->skbqueue)));
}

static inline void
ip_set_init_skbinfo(struct ip_set_skbinfo *skbinfo,
		    const struct ip_set_ext *ext)
{
	skbinfo->skbmark = ext->skbmark;
	skbinfo->skbmarkmask = ext->skbmarkmask;
	skbinfo->skbprio = ext->skbprio;
	skbinfo->skbqueue = ext->skbqueue;
}

static inline bool
ip_set_put_counter(struct sk_buff *skb, struct ip_set_counter *counter)
{
	return nla_put_net64(skb, IPSET_ATTR_BYTES,
			     cpu_to_be64(ip_set_get_bytes(counter)),
			     IPSET_ATTR_PAD) ||
	       nla_put_net64(skb, IPSET_ATTR_PACKETS,
			     cpu_to_be64(ip_set_get_packets(counter)),
			     IPSET_ATTR_PAD);
}

static inline void
ip_set_init_counter(struct ip_set_counter *counter,
		    const struct ip_set_ext *ext)
{
	if (ext->bytes != ULLONG_MAX)
		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
	if (ext->packets != ULLONG_MAX)
		atomic64_set(&(counter)->packets, (long long)(ext->packets));
}

/* Netlink CB args */
enum {
	IPSET_CB_NET = 0,	/* net namespace */
	IPSET_CB_DUMP,		/* dump single set/all sets */
	IPSET_CB_INDEX,		/* set index */
	IPSET_CB_PRIVATE,	/* set private data */
	IPSET_CB_ARG0,		/* type specific */
	IPSET_CB_ARG1,
};

/* register and unregister set references */
extern ip_set_id_t ip_set_get_byname(struct net *net,
				     const char *name, struct ip_set **set);
extern void ip_set_put_byindex(struct net *net, ip_set_id_t index);
extern const char *ip_set_name_byindex(struct net *net, ip_set_id_t index);
extern ip_set_id_t ip_set_nfnl_get_byindex(struct net *net, ip_set_id_t index);
extern void ip_set_nfnl_put(struct net *net, ip_set_id_t index);

/* API for iptables set match, and SET target */

extern int ip_set_add(ip_set_id_t id, const struct sk_buff *skb,
		      const struct xt_action_param *par,
		      struct ip_set_adt_opt *opt);
extern int ip_set_del(ip_set_id_t id, const struct sk_buff *skb,
		      const struct xt_action_param *par,
		      struct ip_set_adt_opt *opt);
extern int ip_set_test(ip_set_id_t id, const struct sk_buff *skb,
		       const struct xt_action_param *par,
		       struct ip_set_adt_opt *opt);

/* Utility functions */
extern void *ip_set_alloc(size_t size);
extern void ip_set_free(void *members);
extern int ip_set_get_ipaddr4(struct nlattr *nla,  __be32 *ipaddr);
extern int ip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr);
extern size_t ip_set_elem_len(struct ip_set *set, struct nlattr *tb[],
			      size_t len, size_t align);
extern int ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
				 struct ip_set_ext *ext);

static inline int
ip_set_get_hostipaddr4(struct nlattr *nla, u32 *ipaddr)
{
	__be32 ip;
	int ret = ip_set_get_ipaddr4(nla, &ip);

	if (ret)
		return ret;
	*ipaddr = ntohl(ip);
	return 0;
}

/* Ignore IPSET_ERR_EXIST errors if asked to do so? */
static inline bool
ip_set_eexist(int ret, u32 flags)
{
	return ret == -IPSET_ERR_EXIST && (flags & IPSET_FLAG_EXIST);
}

/* Match elements marked with nomatch */
static inline bool
ip_set_enomatch(int ret, u32 flags, enum ipset_adt adt, struct ip_set *set)
{
	return adt == IPSET_TEST &&
	       (set->type->features & IPSET_TYPE_NOMATCH) &&
	       ((flags >> 16) & IPSET_FLAG_NOMATCH) &&
	       (ret > 0 || ret == -ENOTEMPTY);
}

/* Check the NLA_F_NET_BYTEORDER flag */
static inline bool
ip_set_attr_netorder(struct nlattr *tb[], int type)
{
	return tb[type] && (tb[type]->nla_type & NLA_F_NET_BYTEORDER);
}

static inline bool
ip_set_optattr_netorder(struct nlattr *tb[], int type)
{
	return !tb[type] || (tb[type]->nla_type & NLA_F_NET_BYTEORDER);
}

/* Useful converters */
static inline u32
ip_set_get_h32(const struct nlattr *attr)
{
	return ntohl(nla_get_be32(attr));
}

static inline u16
ip_set_get_h16(const struct nlattr *attr)
{
	return ntohs(nla_get_be16(attr));
}

#define ipset_nest_start(skb, attr) nla_nest_start(skb, attr | NLA_F_NESTED)
#define ipset_nest_end(skb, start)  nla_nest_end(skb, start)

static inline int nla_put_ipaddr4(struct sk_buff *skb, int type, __be32 ipaddr)
{
	struct nlattr *__nested = ipset_nest_start(skb, type);
	int ret;

	if (!__nested)
		return -EMSGSIZE;
	ret = nla_put_in_addr(skb, IPSET_ATTR_IPADDR_IPV4, ipaddr);
	if (!ret)
		ipset_nest_end(skb, __nested);
	return ret;
}

static inline int nla_put_ipaddr6(struct sk_buff *skb, int type,
				  const struct in6_addr *ipaddrptr)
{
	struct nlattr *__nested = ipset_nest_start(skb, type);
	int ret;

	if (!__nested)
		return -EMSGSIZE;
	ret = nla_put_in6_addr(skb, IPSET_ATTR_IPADDR_IPV6, ipaddrptr);
	if (!ret)
		ipset_nest_end(skb, __nested);
	return ret;
}

/* Get address from skbuff */
static inline __be32
ip4addr(const struct sk_buff *skb, bool src)
{
	return src ? ip_hdr(skb)->saddr : ip_hdr(skb)->daddr;
}

static inline void
ip4addrptr(const struct sk_buff *skb, bool src, __be32 *addr)
{
	*addr = src ? ip_hdr(skb)->saddr : ip_hdr(skb)->daddr;
}

static inline void
ip6addrptr(const struct sk_buff *skb, bool src, struct in6_addr *addr)
{
	memcpy(addr, src ? &ipv6_hdr(skb)->saddr : &ipv6_hdr(skb)->daddr,
	       sizeof(*addr));
}

/* Calculate the bytes required to store the inclusive range of a-b */
static inline int
bitmap_bytes(u32 a, u32 b)
{
	return 4 * ((((b - a + 8) / 8) + 3) / 4);
}

#include <linux/netfilter/ipset/ip_set_timeout.h>
#include <linux/netfilter/ipset/ip_set_comment.h>

int
ip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,
		      const void *e, bool active);

#define IP_SET_INIT_KEXT(skb, opt, set)			\
	{ .bytes = (skb)->len, .packets = 1,		\
	  .timeout = ip_set_adt_opt_timeout(opt, set) }

#define IP_SET_INIT_UEXT(set)				\
	{ .bytes = ULLONG_MAX, .packets = ULLONG_MAX,	\
	  .timeout = (set)->timeout }

#define IPSET_CONCAT(a, b)		a##b
#define IPSET_TOKEN(a, b)		IPSET_CONCAT(a, b)

#endif /*_IP_SET_H */
                                                                                                                                     #ifndef _IP_SET_GETPORT_H
#define _IP_SET_GETPORT_H

extern bool ip_set_get_ip4_port(const struct sk_buff *skb, bool src,
				__be16 *port, u8 *proto);

#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
extern bool ip_set_get_ip6_port(const struct sk_buff *skb, bool src,
				__be16 *port, u8 *proto);
#else
static inline bool ip_set_get_ip6_port(const struct sk_buff *skb, bool src,
				       __be16 *port, u8 *proto)
{
	return false;
}
#endif

extern bool ip_set_get_ip_port(const struct sk_buff *skb, u8 pf, bool src,
				__be16 *port);

static inline bool ip_set_proto_with_ports(u8 proto)
{
	switch (proto) {
	case IPPROTO_TCP:
	case IPPROTO_SCTP:
	case IPPROTO_UDP:
	case IPPROTO_UDPLITE:
		return true;
	}
	return false;
}

#endif /*_IP_SET_GETPORT_H*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _IP_SET_TIMEOUT_H
#define _IP_SET_TIMEOUT_H

/* Copyright (C) 2003-2013 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifdef __KERNEL__

/* How often should the gc be run by default */
#define IPSET_GC_TIME			(3 * 60)

/* Timeout period depending on the timeout value of the given set */
#define IPSET_GC_PERIOD(timeout) \
	((timeout/3) ? min_t(u32, (timeout)/3, IPSET_GC_TIME) : 1)

/* Entry is set with no timeout value */
#define IPSET_ELEM_PERMANENT	0

/* Set is defined with timeout support: timeout value may be 0 */
#define IPSET_NO_TIMEOUT	UINT_MAX

#define ip_set_adt_opt_timeout(opt, set)	\
((opt)->ext.timeout != IPSET_NO_TIMEOUT ? (opt)->ext.timeout : (set)->timeout)

static inline unsigned int
ip_set_timeout_uget(struct nlattr *tb)
{
	unsigned int timeout = ip_set_get_h32(tb);

	/* Normalize to fit into jiffies */
	if (timeout > UINT_MAX/MSEC_PER_SEC)
		timeout = UINT_MAX/MSEC_PER_SEC;

	/* Userspace supplied TIMEOUT parameter: adjust crazy size */
	return timeout == IPSET_NO_TIMEOUT ? IPSET_NO_TIMEOUT - 1 : timeout;
}

static inline bool
ip_set_timeout_expired(unsigned long *t)
{
	return *t != IPSET_ELEM_PERMANENT && time_is_before_jiffies(*t);
}

static inline void
ip_set_timeout_set(unsigned long *timeout, u32 value)
{
	unsigned long t;

	if (!value) {
		*timeout = IPSET_ELEM_PERMANENT;
		return;
	}

	t = msecs_to_jiffies(value * MSEC_PER_SEC) + jiffies;
	if (t == IPSET_ELEM_PERMANENT)
		/* Bingo! :-) */
		t--;
	*timeout = t;
}

static inline u32
ip_set_timeout_get(unsigned long *timeout)
{
	return *timeout == IPSET_ELEM_PERMANENT ? 0 :
		jiffies_to_msecs(*timeout - jiffies)/MSEC_PER_SEC;
}

#endif	/* __KERNEL__ */
#endif /* _IP_SET_TIMEOUT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _CONNTRACK_PROTO_GRE_H
#define _CONNTRACK_PROTO_GRE_H
#include <asm/byteorder.h>
#include <net/gre.h>
#include <net/pptp.h>

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

#ifdef __KERNEL__
#include <net/netfilter/nf_conntrack_tuple.h>

struct nf_conn;

/* structure for original <-> reply keymap */
struct nf_ct_gre_keymap {
	struct list_head list;
	struct nf_conntrack_tuple tuple;
};

/* add new tuple->key_reply pair to keymap */
int nf_ct_gre_keymap_add(struct nf_conn *ct, enum ip_conntrack_dir dir,
			 struct nf_conntrack_tuple *t);

/* delete keymap entries */
void nf_ct_gre_keymap_destroy(struct nf_conn *ct);

void nf_nat_need_gre(void);

#endif /* __KERNEL__ */
#endif /* _CONNTRACK_PROTO_GRE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _NF_CONNTRACK_TFTP_H
#define _NF_CONNTRACK_TFTP_H

#define TFTP_PORT 69

struct tftphdr {
	__be16 opcode;
};

#define TFTP_OPCODE_READ	1
#define TFTP_OPCODE_WRITE	2
#define TFTP_OPCODE_DATA	3
#define TFTP_OPCODE_ACK		4
#define TFTP_OPCODE_ERROR	5

extern unsigned int (*nf_nat_tftp_hook)(struct sk_buff *skb,
				        enum ip_conntrack_info ctinfo,
				        struct nf_conntrack_expect *exp);

#endif /* _NF_CONNTRACK_TFTP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _NFNL_ACCT_H_
#define _NFNL_ACCT_H_

#include <uapi/linux/netfilter/nfnetlink_acct.h>
#include <net/net_namespace.h>

enum {
	NFACCT_NO_QUOTA		= -1,
	NFACCT_UNDERQUOTA,
	NFACCT_OVERQUOTA,
};

struct nf_acct;

struct nf_acct *nfnl_acct_find_get(struct net *net, const char *filter_name);
void nfnl_acct_put(struct nf_acct *acct);
void nfnl_acct_update(const struct sk_buff *skb, struct nf_acct *nfacct);
int nfnl_acct_overquota(struct net *net, const struct sk_buff *skb,
			struct nf_acct *nfacct);
#endif /* _NFNL_ACCT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _NF_CONNTRACK_ZONES_COMMON_H
#define _NF_CONNTRACK_ZONES_COMMON_H

#include <uapi/linux/netfilter/nf_conntrack_tuple_common.h>

#define NF_CT_DEFAULT_ZONE_ID	0

#define NF_CT_ZONE_DIR_ORIG	(1 << IP_CT_DIR_ORIGINAL)
#define NF_CT_ZONE_DIR_REPL	(1 << IP_CT_DIR_REPLY)

#define NF_CT_DEFAULT_ZONE_DIR	(NF_CT_ZONE_DIR_ORIG | NF_CT_ZONE_DIR_REPL)

#define NF_CT_FLAG_MARK		1

struct nf_conntrack_zone {
	u16	id;
	u8	flags;
	u8	dir;
};

extern const struct nf_conntrack_zone nf_ct_zone_dflt;

#endif /* _NF_CONNTRACK_ZONES_COMMON_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _NF_CONNTRACK_IRC_H
#define _NF_CONNTRACK_IRC_H

#ifdef __KERNEL__

#define IRC_PORT	6667

extern unsigned int (*nf_nat_irc_hook)(struct sk_buff *skb,
				       enum ip_conntrack_info ctinfo,
				       unsigned int protoff,
				       unsigned int matchoff,
				       unsigned int matchlen,
				       struct nf_conntrack_expect *exp);

#endif /* __KERNEL__ */
#endif /* _NF_CONNTRACK_IRC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _XT_PHYSDEV_H
#define _XT_PHYSDEV_H

#include <linux/if.h>
#include <uapi/linux/netfilter/xt_physdev.h>

#endif /*_XT_PHYSDEV_H*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #ifndef _X_TABLES_H
#define _X_TABLES_H


#include <linux/netdevice.h>
#include <linux/static_key.h>
#include <uapi/linux/netfilter/x_tables.h>

/* Test a struct->invflags and a boolean for inequality */
#define NF_INVF(ptr, flag, boolean)					\
	((boolean) ^ !!((ptr)->invflags & (flag)))

/**
 * struct xt_action_param - parameters for matches/targets
 *
 * @match:	the match extension
 * @target:	the target extension
 * @matchinfo:	per-match data
 * @targetinfo:	per-target data
 * @net		network namespace through which the action was invoked
 * @in:		input netdevice
 * @out:	output netdevice
 * @fragoff:	packet is a fragment, this is the data offset
 * @thoff:	position of transport header relative to skb->data
 * @hook:	hook number given packet came from
 * @family:	Actual NFPROTO_* through which the function is invoked
 * 		(helpful when match->family == NFPROTO_UNSPEC)
 *
 * Fields written to by extensions:
 *
 * @hotdrop:	drop packet if we had inspection problems
 */
struct xt_action_param {
	union {
		const struct xt_match *match;
		const struct xt_target *target;
	};
	union {
		const void *matchinfo, *targinfo;
	};
	struct net *net;
	const struct net_device *in, *out;
	int fragoff;
	unsigned int thoff;
	unsigned int hooknum;
	u_int8_t family;
	bool hotdrop;
};

/**
 * struct xt_mtchk_param - parameters for match extensions'
 * checkentry functions
 *
 * @net:	network namespace through which the check was invoked
 * @table:	table the rule is tried to be inserted into
 * @entryinfo:	the family-specific rule data
 * 		(struct ipt_ip, ip6t_ip, arpt_arp or (note) ebt_entry)
 * @match:	struct xt_match through which this function was invoked
 * @matchinfo:	per-match data
 * @hook_mask:	via which hooks the new rule is reachable
 * Other fields as above.
 */
struct xt_mtchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_match *match;
	void *matchinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

/**
 * struct xt_mdtor_param - match destructor parameters
 * Fields as above.
 */
struct xt_mtdtor_param {
	struct net *net;
	const struct xt_match *match;
	void *matchinfo;
	u_int8_t family;
};

/**
 * struct xt_tgchk_param - parameters for target extensions'
 * checkentry functions
 *
 * @entryinfo:	the family-specific rule data
 * 		(struct ipt_entry, ip6t_entry, arpt_entry, ebt_entry)
 *
 * Other fields see above.
 */
struct xt_tgchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_target *target;
	void *targinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

/* Target destructor parameters */
struct xt_tgdtor_param {
	struct net *net;
	const struct xt_target *target;
	void *targinfo;
	u_int8_t family;
};

struct xt_match {
	struct list_head list;

	const char name[XT_EXTENSION_MAXNAMELEN];
	u_int8_t revision;

	/* Return true or false: return FALSE and set *hotdrop = 1 to
           force immediate packet drop. */
	/* Arguments changed since 2.6.9, as this must now handle
	   non-linear skb, using skb_header_pointer and
	   skb_ip_make_writable. */
	bool (*match)(const struct sk_buff *skb,
		      struct xt_action_param *);

	/* Called when user tries to insert an entry of this type. */
	int (*checkentry)(const struct xt_mtchk_param *);

	/* Called when entry of this type deleted. */
	void (*destroy)(const struct xt_mtdtor_param *);
#ifdef CONFIG_COMPAT
	/* Called when userspace align differs from kernel space one */
	void (*compat_from_user)(void *dst, const void *src);
	int (*compat_to_user)(void __user *dst, const void *src);
#endif
	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
	struct module *me;

	const char *table;
	unsigned int matchsize;
#ifdef CONFIG_COMPAT
	unsigned int compatsize;
#endif
	unsigned int hooks;
	unsigned short proto;

	unsigned short family;
};

/* Registration hooks for targets. */
struct xt_target {
	struct list_head list;

	const char name[XT_EXTENSION_MAXNAMELEN];
	u_int8_t revision;

	/* Returns verdict. Argument order changed since 2.6.9, as this
	   must now handle non-linear skbs, using skb_copy_bits and
	   skb_ip_make_writable. */
	unsigned int (*target)(struct sk_buff *skb,
			       const struct xt_action_param *);

	/* Called when user tries to insert an entry of this type:
           hook_mask is a bitmask of hooks from which it can be
           called. */
	/* Should return 0 on success or an error code otherwise (-Exxxx). */
	int (*checkentry)(const struct xt_tgchk_param *);

	/* Called when entry of this type deleted. */
	void (*destroy)(const struct xt_tgdtor_param *);
#ifdef CONFIG_COMPAT
	/* Called when userspace align differs from kernel space one */
	void (*compat_from_user)(void *dst, const void *src);
	int (*compat_to_user)(void __user *dst, const void *src);
#endif
	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
	struct module *me;

	const char *table;
	unsigned int targetsize;
#ifdef CONFIG_COMPAT
	unsigned int compatsize;
#endif
	unsigned int hooks;
	unsigned short proto;

	unsigned short family;
};

/* Furniture shopping... */
struct xt_table {
	struct list_head list;

	/* What hooks you will enter on */
	unsigned int valid_hooks;

	/* Man behind the curtain... */
	struct xt_table_info *private;

	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
	struct module *me;

	u_int8_t af;		/* address/protocol family */
	int priority;		/* hook order */

	/* called when table is needed in the given netns */
	int (*table_init)(struct net *net);

	/* A unique name... */
	const char name[XT_TABLE_MAXNAMELEN];
};

#include <linux/netfilter_ipv4.h>

/* The table itself */
struct xt_table_info {
	/* Size per table */
	unsigned int size;
	/* Number of entries: FIXME. --RR */
	unsigned int number;
	/* Initial number of entries. Needed for module usage count */
	unsigned int initial_entries;

	/* Entry points and underflows */
	unsigned int hook_entry[NF_INET_NUMHOOKS];
	unsigned int underflow[NF_INET_NUMHOOKS];

	/*
	 * Number of user chains. Since tables cannot have loops, at most
	 * @stacksize jumps (number of user chains) can possibly be made.
	 */
	unsigned int stacksize;
	void ***jumpstack;

	unsigned char entries[0] __aligned(8);
};

int xt_register_target(struct xt_target *target);
void xt_unregister_target(struct xt_target *target);
int xt_register_targets(struct xt_target *target, unsigned int n);
void xt_unregister_targets(struct xt_target *target, unsigned int n);

int xt_register_match(struct xt_match *target);
void xt_unregister_match(struct xt_match *target);
int xt_register_matches(struct xt_match *match, unsigned int n);
void xt_unregister_matches(struct xt_match *match, unsigned int n);

int xt_check_entry_offsets(const void *base, const char *elems,
			   unsigned int target_offset,
			   unsigned int next_offset);

unsigned int *xt_alloc_entry_offsets(unsigned int size);
bool xt_find_jump_offset(const unsigned int *offsets,
			 unsigned int target, unsigned int size);

int xt_check_match(struct xt_mtchk_param *, unsigned int size, u_int8_t proto,
		   bool inv_proto);
int xt_check_target(struct xt_tgchk_param *, unsigned int size, u_int8_t proto,
		    bool inv_proto);

void *xt_copy_counters_from_user(const void __user *user, unsigned int len,
				 struct xt_counters_info *info, bool compat);

struct xt_table *xt_register_table(struct net *net,
				   const struct xt_table *table,
				   struct xt_table_info *bootstrap,
				   struct xt_table_info *newinfo);
void *xt_unregister_table(struct xt_table *table);

struct xt_table_info *xt_replace_table(struct xt_table *table,
				       unsigned int num_counters,
				       struct xt_table_info *newinfo,
				       int *error);

struct xt_match *xt_find_match(u8 af, const char *name, u8 revision);
struct xt_target *xt_find_target(u8 af, const char *name, u8 revision);
struct xt_match *xt_request_find_match(u8 af, const char *name, u8 revision);
struct xt_target *xt_request_find_target(u8 af, const char *name, u8 revision);
int xt_find_revision(u8 af, const char *name, u8 revision, int target,
		     int *err);

struct xt_table *xt_find_table_lock(struct net *net, u_int8_t af,
				    const char *name);
void xt_table_unlock(struct xt_table *t);

int xt_proto_init(struct net *net, u_int8_t af);
void xt_proto_fini(struct net *net, u_int8_t af);

struct xt_table_info *xt_alloc_table_info(unsigned int size);
void xt_free_table_info(struct xt_table_info *info);

/**
 * xt_recseq - recursive seqcount for netfilter use
 * 
 * Packet processing changes the seqcount only if no recursion happened
 * get_counters() can use read_seqcount_begin()/read_seqcount_retry(),
 * because we use the normal seqcount convention :
 * Low order bit set to 1 if a writer is active.
 */
DECLARE_PER_CPU(seqcount_t, xt_recseq);

/* xt_tee_enabled - true if x_tables needs to handle reentrancy
 *
 * Enabled if current ip(6)tables ruleset has at least one -j TEE rule.
 */
extern struct static_key xt_tee_enabled;

/**
 * xt_write_recseq_begin - start of a write section
 *
 * Begin packet processing : all readers must wait the end
 * 1) Must be called with preemption disabled
 * 2) softirqs must be disabled too (or we should use this_cpu_add())
 * Returns :
 *  1 if no recursion on this cpu
 *  0 if recursion detected
 */
static inline unsigned int xt_write_recseq_begin(void)
{
	unsigned int addend;

	/*
	 * Low order bit of sequence is set if we already
	 * called xt_write_recseq_begin().
	 */
	addend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1;

	/*
	 * This is kind of a write_seqcount_begin(), but addend is 0 or 1
	 * We dont check addend value to avoid a test and conditional jump,
	 * since addend is most likely 1
	 */
	__this_cpu_add(xt_recseq.sequence, addend);
	smp_wmb();

	return addend;
}

/**
 * xt_write_recseq_end - end of a write section
 * @addend: return value from previous xt_write_recseq_begin()
 *
 * End packet processing : all readers can proceed
 * 1) Must be called with preemption disabled
 * 2) softirqs must be disabled too (or we should use this_cpu_add())
 */
static inline void xt_write_recseq_end(unsigned int addend)
{
	/* this is kind of a write_seqcount_end(), but addend is 0 or 1 */
	smp_wmb();
	__this_cpu_add(xt_recseq.sequence, addend);
}

/*
 * This helper is performance critical and must be inlined
 */
static inline unsigned long ifname_compare_aligned(const char *_a,
						   const char *_b,
						   const char *_mask)
{
	const unsigned long *a = (const unsigned long *)_a;
	const unsigned long *b = (const unsigned long *)_b;
	const unsigned long *mask = (const unsigned long *)_mask;
	unsigned long ret;

	ret = (a[0] ^ b[0]) & mask[0];
	if (IFNAMSIZ > sizeof(unsigned long))
		ret |= (a[1] ^ b[1]) & mask[1];
	if (IFNAMSIZ > 2 * sizeof(unsigned long))
		ret |= (a[2] ^ b[2]) & mask[2];
	if (IFNAMSIZ > 3 * sizeof(unsigned long))
		ret |= (a[3] ^ b[3]) & mask[3];
	BUILD_BUG_ON(IFNAMSIZ > 4 * sizeof(unsigned long));
	return ret;
}


/* On SMP, ip(6)t_entry->counters.pcnt holds address of the
 * real (percpu) counter.  On !SMP, its just the packet count,
 * so nothing needs to be done there.
 *
 * xt_percpu_counter_alloc returns the address of the percpu
 * counter, or 0 on !SMP. We force an alignment of 16 bytes
 * so that bytes/packets share a common cache line.
 *
 * Hence caller must use IS_ERR_VALUE to check for error, this
 * allows us to return 0 for single core systems without forcing
 * callers to deal with SMP vs. NONSMP issues.
 */
static inline unsigned long xt_percpu_counter_alloc(void)
{
	if (nr_cpu_ids > 1) {
		void __percpu *res = __alloc_percpu(sizeof(struct xt_counters),
						    sizeof(struct xt_counters));

		if (res == NULL)
			return -ENOMEM;

		return (__force unsigned long) res;
	}

	return 0;
}
static inline void xt_percpu_counter_free(u64 pcnt)
{
	if (nr_cpu_ids > 1)
		free_percpu((void __percpu *) (unsigned long) pcnt);
}

static inline struct xt_counters *
xt_get_this_cpu_counter(struct xt_counters *cnt)
{
	if (nr_cpu_ids > 1)
		return this_cpu_ptr((void __percpu *) (unsigned long) cnt->pcnt);

	return cnt;
}

static inline struct xt_counters *
xt_get_per_cpu_counter(struct xt_counters *cnt, unsigned int cpu)
{
	if (nr_cpu_ids > 1)
		return per_cpu_ptr((void __percpu *) (unsigned long) cnt->pcnt, cpu);

	return cnt;
}

struct nf_hook_ops *xt_hook_ops_alloc(const struct xt_table *, nf_hookfn *);

#ifdef CONFIG_COMPAT
#include <net/compat.h>

struct compat_xt_entry_match {
	union {
		struct {
			u_int16_t match_size;
			char name[XT_FUNCTION_MAXNAMELEN - 1];
			u_int8_t revision;
		} user;
		struct {
			u_int16_t match_size;
			compat_uptr_t match;
		} kernel;
		u_int16_t match_size;
	} u;
	unsigned char data[0];
};

struct compat_xt_entry_target {
	union {
		struct {
			u_int16_t target_size;
			char name[XT_FUNCTION_MAXNAMELEN - 1];
			u_int8_t revision;
		} user;
		struct {
			u_int16_t target_size;
			compat_uptr_t target;
		} kernel;
		u_int16_t target_size;
	} u;
	unsigned char data[0];
};

/* FIXME: this works only on 32 bit tasks
 * need to change whole approach in order to calculate align as function of
 * current task alignment */

struct compat_xt_counters {
	compat_u64 pcnt, bcnt;			/* Packet and byte counters */
};

struct compat_xt_counters_info {
	char name[XT_TABLE_MAXNAMELEN];
	compat_uint_t num_counters;
	struct compat_xt_counters counters[0];
};

struct _compat_xt_align {
	__u8 u8;
	__u16 u16;
	__u32 u32;
	compat_u64 u64;
};

#define COMPAT_XT_ALIGN(s) __ALIGN_KERNEL((s), __alignof__(struct _compat_xt_align))

void xt_compat_lock(u_int8_t af);
void xt_compat_unlock(u_int8_t af);

int xt_compat_add_offset(u_int8_t af, unsigned int offset, int delta);
void xt_compat_flush_offsets(u_int8_t af);
void xt_compat_init_offsets(u_int8_t af, unsigned int number);
int xt_compat_calc_jump(u_int8_t af, unsigned int offset);

int xt_compat_match_offset(const struct xt_match *match);
void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
			      unsigned int *size);
int xt_compat_match_to_user(const struct xt_entry_match *m,
			    void __user **dstptr, unsigned int *size);

int xt_compat_target_offset(const struct xt_target *target);
void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
				unsigned int *size);
int xt_compat_target_to_user(const struct xt_entry_target *t,
			     void __user **dstptr, unsigned int *size);
int xt_compat_check_entry_offsets(const void *base, const char *elems,
				  unsigned int target_offset,
				  unsigned int next_offset);

#endif /* CONFIG_COMPAT */
#endif /* _X_TABLES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _NF_CONNTRACK_AMANDA_H
#define _NF_CONNTRACK_AMANDA_H
/* AMANDA tracking. */

extern unsigned int (*nf_nat_amanda_hook)(struct sk_buff *skb,
					  enum ip_conntrack_info ctinfo,
					  unsigned int protoff,
					  unsigned int matchoff,
					  unsigned int matchlen,
					  struct nf_conntrack_expect *exp);
#endif /* _NF_CONNTRACK_AMANDA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef _NF_CONNTRACK_SANE_H
#define _NF_CONNTRACK_SANE_H
/* SANE tracking. */

#ifdef __KERNEL__

#define SANE_PORT	6566

enum sane_state {
	SANE_STATE_NORMAL,
	SANE_STATE_START_REQUESTED,
};

/* This structure exists only once per master */
struct nf_ct_sane_master {
	enum sane_state state;
};

#endif /* __KERNEL__ */

#endif /* _NF_CONNTRACK_SANE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _NF_CONNTRACK_COMMON_H
#define _NF_CONNTRACK_COMMON_H

#include <uapi/linux/netfilter/nf_conntrack_common.h>

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int ignore;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
};

/* call to create an explicit dependency on nf_conntrack. */
void need_conntrack(void);

#endif /* _NF_CONNTRACK_COMMON_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef LINUX_MM_DEBUG_H
#define LINUX_MM_DEBUG_H 1

#include <linux/bug.h>
#include <linux/stringify.h>

struct page;
struct vm_area_struct;
struct mm_struct;

extern void dump_page(struct page *page, const char *reason);
extern void __dump_page(struct page *page, const char *reason);
void dump_vma(const struct vm_area_struct *vma);
void dump_mm(const struct mm_struct *mm);

#ifdef CONFIG_DEBUG_VM
#define VM_BUG_ON(cond) BUG_ON(cond)
#define VM_BUG_ON_PAGE(cond, page)					\
	do {								\
		if (unlikely(cond)) {					\
			dump_page(page, "VM_BUG_ON_PAGE(" __stringify(cond)")");\
			BUG();						\
		}							\
	} while (0)
#define VM_BUG_ON_VMA(cond, vma)					\
	do {								\
		if (unlikely(cond)) {					\
			dump_vma(vma);					\
			BUG();						\
		}							\
	} while (0)
#define VM_BUG_ON_MM(cond, mm)						\
	do {								\
		if (unlikely(cond)) {					\
			dump_mm(mm);					\
			BUG();						\
		}							\
	} while (0)
#define VM_WARN_ON(cond) WARN_ON(cond)
#define VM_WARN_ON_ONCE(cond) WARN_ON_ONCE(cond)
#define VM_WARN_ONCE(cond, format...) WARN_ONCE(cond, format)
#define VM_WARN(cond, format...) WARN(cond, format)
#else
#define VM_BUG_ON(cond) BUILD_BUG_ON_INVALID(cond)
#define VM_BUG_ON_PAGE(cond, page) VM_BUG_ON(cond)
#define VM_BUG_ON_VMA(cond, vma) VM_BUG_ON(cond)
#define VM_BUG_ON_MM(cond, mm) VM_BUG_ON(cond)
#define VM_WARN_ON(cond) BUILD_BUG_ON_INVALID(cond)
#define VM_WARN_ON_ONCE(cond) BUILD_BUG_ON_INVALID(cond)
#define VM_WARN_ONCE(cond, format...) BUILD_BUG_ON_INVALID(cond)
#define VM_WARN(cond, format...) BUILD_BUG_ON_INVALID(cond)
#endif

#ifdef CONFIG_DEBUG_VIRTUAL
#define VIRTUAL_BUG_ON(cond) BUG_ON(cond)
#else
#define VIRTUAL_BUG_ON(cond) do { } while (0)
#endif

#ifdef CONFIG_DEBUG_VM_PGFLAGS
#define VM_BUG_ON_PGFLAGS(cond, page) VM_BUG_ON_PAGE(cond, page)
#else
#define VM_BUG_ON_PGFLAGS(cond, page) BUILD_BUG_ON_INVALID(cond)
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 *  include/linux/clkdev.h
 *
 *  Copyright (C) 2008 Russell King.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Helper for the clk API to assist looking up a struct clk.
 */
#ifndef __CLKDEV_H
#define __CLKDEV_H

#include <asm/clkdev.h>

struct clk;
struct clk_hw;
struct device;

struct clk_lookup {
	struct list_head	node;
	const char		*dev_id;
	const char		*con_id;
	struct clk		*clk;
	struct clk_hw		*clk_hw;
};

#define CLKDEV_INIT(d, n, c)	\
	{			\
		.dev_id = d,	\
		.con_id = n,	\
		.clk = c,	\
	}

struct clk_lookup *clkdev_alloc(struct clk *clk, const char *con_id,
	const char *dev_fmt, ...) __printf(3, 4);
struct clk_lookup *clkdev_hw_alloc(struct clk_hw *hw, const char *con_id,
	const char *dev_fmt, ...) __printf(3, 4);

void clkdev_add(struct clk_lookup *cl);
void clkdev_drop(struct clk_lookup *cl);

struct clk_lookup *clkdev_create(struct clk *clk, const char *con_id,
	const char *dev_fmt, ...) __printf(3, 4);
struct clk_lookup *clkdev_hw_create(struct clk_hw *hw, const char *con_id,
	const char *dev_fmt, ...) __printf(3, 4);

void clkdev_add_table(struct clk_lookup *, size_t);
int clk_add_alias(const char *, const char *, const char *, struct device *);

int clk_register_clkdev(struct clk *, const char *, const char *);
int clk_hw_register_clkdev(struct clk_hw *, const char *, const char *);

#ifdef CONFIG_COMMON_CLK
int __clk_get(struct clk *clk);
void __clk_put(struct clk *clk);
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /* interrupt.h */
#ifndef _LINUX_INTERRUPT_H
#define _LINUX_INTERRUPT_H

#include <linux/kernel.h>
#include <linux/linkage.h>
#include <linux/bitops.h>
#include <linux/preempt.h>
#include <linux/cpumask.h>
#include <linux/irqreturn.h>
#include <linux/irqnr.h>
#include <linux/hardirq.h>
#include <linux/irqflags.h>
#include <linux/hrtimer.h>
#include <linux/kref.h>
#include <linux/workqueue.h>

#include <linux/atomic.h>
#include <asm/ptrace.h>
#include <asm/irq.h>

/*
 * These correspond to the IORESOURCE_IRQ_* defines in
 * linux/ioport.h to select the interrupt line behaviour.  When
 * requesting an interrupt without specifying a IRQF_TRIGGER, the
 * setting should be assumed to be "as already configured", which
 * may be as per machine or firmware initialisation.
 */
#define IRQF_TRIGGER_NONE	0x00000000
#define IRQF_TRIGGER_RISING	0x00000001
#define IRQF_TRIGGER_FALLING	0x00000002
#define IRQF_TRIGGER_HIGH	0x00000004
#define IRQF_TRIGGER_LOW	0x00000008
#define IRQF_TRIGGER_MASK	(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \
				 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)
#define IRQF_TRIGGER_PROBE	0x00000010

/*
 * These flags used only by the kernel as part of the
 * irq handling routines.
 *
 * IRQF_SHARED - allow sharing the irq among several devices
 * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
 * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
 * IRQF_PERCPU - Interrupt is per cpu
 * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing
 * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is
 *                registered first in an shared interrupt is considered for
 *                performance reasons)
 * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.
 *                Used by threaded interrupts which need to keep the
 *                irq line disabled until the threaded handler has been run.
 * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee
 *                   that this interrupt will wake the system from a suspended
 *                   state.  See Documentation/power/suspend-and-interrupts.txt
 * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
 * IRQF_NO_THREAD - Interrupt cannot be threaded
 * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device
 *                resume time.
 * IRQF_COND_SUSPEND - If the IRQ is shared with a NO_SUSPEND user, execute this
 *                interrupt handler after suspending interrupts. For system
 *                wakeup devices users need to implement wakeup detection in
 *                their interrupt handlers.
 */
#define IRQF_SHARED		0x00000080
#define IRQF_PROBE_SHARED	0x00000100
#define __IRQF_TIMER		0x00000200
#define IRQF_PERCPU		0x00000400
#define IRQF_NOBALANCING	0x00000800
#define IRQF_IRQPOLL		0x00001000
#define IRQF_ONESHOT		0x00002000
#define IRQF_NO_SUSPEND		0x00004000
#define IRQF_FORCE_RESUME	0x00008000
#define IRQF_NO_THREAD		0x00010000
#define IRQF_EARLY_RESUME	0x00020000
#define IRQF_COND_SUSPEND	0x00040000

#define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)

/*
 * These values can be returned by request_any_context_irq() and
 * describe the context the interrupt will be run in.
 *
 * IRQC_IS_HARDIRQ - interrupt runs in hardirq context
 * IRQC_IS_NESTED - interrupt runs in a nested threaded context
 */
enum {
	IRQC_IS_HARDIRQ	= 0,
	IRQC_IS_NESTED,
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

/**
 * struct irqaction - per interrupt action descriptor
 * @handler:	interrupt handler function
 * @name:	name of the device
 * @dev_id:	cookie to identify the device
 * @percpu_dev_id:	cookie to identify the device
 * @next:	pointer to the next irqaction for shared interrupts
 * @irq:	interrupt number
 * @flags:	flags (see IRQF_* above)
 * @thread_fn:	interrupt handler function for threaded interrupts
 * @thread:	thread pointer for threaded interrupts
 * @secondary:	pointer to secondary irqaction (force threading)
 * @thread_flags:	flags related to @thread
 * @thread_mask:	bitmask for keeping track of @thread activity
 * @dir:	pointer to the proc/irq/NN/name entry
 */
struct irqaction {
	irq_handler_t		handler;
	void			*dev_id;
	void __percpu		*percpu_dev_id;
	struct irqaction	*next;
	irq_handler_t		thread_fn;
	struct task_struct	*thread;
	struct irqaction	*secondary;
	unsigned int		irq;
	unsigned int		flags;
	unsigned long		thread_flags;
	unsigned long		thread_mask;
	const char		*name;
	struct proc_dir_entry	*dir;
} ____cacheline_internodealigned_in_smp;

extern irqreturn_t no_action(int cpl, void *dev_id);

/*
 * If a (PCI) device interrupt is not connected we set dev->irq to
 * IRQ_NOTCONNECTED. This causes request_irq() to fail with -ENOTCONN, so we
 * can distingiush that case from other error returns.
 *
 * 0x80000000 is guaranteed to be outside the available range of interrupts
 * and easy to distinguish from other possible incorrect values.
 */
#define IRQ_NOTCONNECTED	(1U << 31)

extern int __must_check
request_threaded_irq(unsigned int irq, irq_handler_t handler,
		     irq_handler_t thread_fn,
		     unsigned long flags, const char *name, void *dev);

static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}

extern int __must_check
request_any_context_irq(unsigned int irq, irq_handler_t handler,
			unsigned long flags, const char *name, void *dev_id);

extern int __must_check
request_percpu_irq(unsigned int irq, irq_handler_t handler,
		   const char *devname, void __percpu *percpu_dev_id);

extern void free_irq(unsigned int, void *);
extern void free_percpu_irq(unsigned int, void __percpu *);

struct device;

extern int __must_check
devm_request_threaded_irq(struct device *dev, unsigned int irq,
			  irq_handler_t handler, irq_handler_t thread_fn,
			  unsigned long irqflags, const char *devname,
			  void *dev_id);

static inline int __must_check
devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
		 unsigned long irqflags, const char *devname, void *dev_id)
{
	return devm_request_threaded_irq(dev, irq, handler, NULL, irqflags,
					 devname, dev_id);
}

extern int __must_check
devm_request_any_context_irq(struct device *dev, unsigned int irq,
		 irq_handler_t handler, unsigned long irqflags,
		 const char *devname, void *dev_id);

extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);

/*
 * On lockdep we dont want to enable hardirqs in hardirq
 * context. Use local_irq_enable_in_hardirq() to annotate
 * kernel code that has to do this nevertheless (pretty much
 * the only valid case is for old/broken hardware that is
 * insanely slow).
 *
 * NOTE: in theory this might break fragile code that relies
 * on hardirq delivery - in practice we dont seem to have such
 * places left. So the only effect should be slightly increased
 * irqs-off latencies.
 */
#ifdef CONFIG_LOCKDEP
# define local_irq_enable_in_hardirq()	do { } while (0)
#else
# define local_irq_enable_in_hardirq()	local_irq_enable()
#endif

extern void disable_irq_nosync(unsigned int irq);
extern bool disable_hardirq(unsigned int irq);
extern void disable_irq(unsigned int irq);
extern void disable_percpu_irq(unsigned int irq);
extern void enable_irq(unsigned int irq);
extern void enable_percpu_irq(unsigned int irq, unsigned int type);
extern bool irq_percpu_is_enabled(unsigned int irq);
extern void irq_wake_thread(unsigned int irq, void *dev_id);

/* The following three functions are for the core kernel use only. */
extern void suspend_device_irqs(void);
extern void resume_device_irqs(void);

/**
 * struct irq_affinity_notify - context for notification of IRQ affinity changes
 * @irq:		Interrupt to which notification applies
 * @kref:		Reference count, for internal use
 * @work:		Work item, for internal use
 * @notify:		Function to be called on change.  This will be
 *			called in process context.
 * @release:		Function to be called on release.  This will be
 *			called in process context.  Once registered, the
 *			structure must only be freed when this function is
 *			called or later.
 */
struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *mask);
	void (*release)(struct kref *ref);
};

#if defined(CONFIG_SMP)

extern cpumask_var_t irq_default_affinity;

/* Internal implementation. Use the helpers below */
extern int __irq_set_affinity(unsigned int irq, const struct cpumask *cpumask,
			      bool force);

/**
 * irq_set_affinity - Set the irq affinity of a given irq
 * @irq:	Interrupt to set affinity
 * @cpumask:	cpumask
 *
 * Fails if cpumask does not contain an online CPU
 */
static inline int
irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)
{
	return __irq_set_affinity(irq, cpumask, false);
}

/**
 * irq_force_affinity - Force the irq affinity of a given irq
 * @irq:	Interrupt to set affinity
 * @cpumask:	cpumask
 *
 * Same as irq_set_affinity, but without checking the mask against
 * online cpus.
 *
 * Solely for low level cpu hotplug code, where we need to make per
 * cpu interrupts affine before the cpu becomes online.
 */
static inline int
irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)
{
	return __irq_set_affinity(irq, cpumask, true);
}

extern int irq_can_set_affinity(unsigned int irq);
extern int irq_select_affinity(unsigned int irq);

extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);

extern int
irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);

struct cpumask *irq_create_affinity_masks(const struct cpumask *affinity, int nvec);
int irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec);

#else /* CONFIG_SMP */

static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)
{
	return -EINVAL;
}

static inline int irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)
{
	return 0;
}

static inline int irq_can_set_affinity(unsigned int irq)
{
	return 0;
}

static inline int irq_select_affinity(unsigned int irq)  { return 0; }

static inline int irq_set_affinity_hint(unsigned int irq,
					const struct cpumask *m)
{
	return -EINVAL;
}

static inline int
irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
{
	return 0;
}

static inline struct cpumask *
irq_create_affinity_masks(const struct cpumask *affinity, int nvec)
{
	return NULL;
}

static inline int
irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec)
{
	return maxvec;
}

#endif /* CONFIG_SMP */

/*
 * Special lockdep variants of irq disabling/enabling.
 * These should be used for locking constructs that
 * know that a particular irq context which is disabled,
 * and which is the only irq-context user of a lock,
 * that it's safe to take the lock in the irq-disabled
 * section without disabling hardirqs.
 *
 * On !CONFIG_LOCKDEP they are equivalent to the normal
 * irq disable/enable methods.
 */
static inline void disable_irq_nosync_lockdep(unsigned int irq)
{
	disable_irq_nosync(irq);
#ifdef CONFIG_LOCKDEP
	local_irq_disable();
#endif
}

static inline void disable_irq_nosync_lockdep_irqsave(unsigned int irq, unsigned long *flags)
{
	disable_irq_nosync(irq);
#ifdef CONFIG_LOCKDEP
	local_irq_save(*flags);
#endif
}

static inline void disable_irq_lockdep(unsigned int irq)
{
	disable_irq(irq);
#ifdef CONFIG_LOCKDEP
	local_irq_disable();
#endif
}

static inline void enable_irq_lockdep(unsigned int irq)
{
#ifdef CONFIG_LOCKDEP
	local_irq_enable();
#endif
	enable_irq(irq);
}

static inline void enable_irq_lockdep_irqrestore(unsigned int irq, unsigned long *flags)
{
#ifdef CONFIG_LOCKDEP
	local_irq_restore(*flags);
#endif
	enable_irq(irq);
}

/* IRQ wakeup (PM) control: */
extern int irq_set_irq_wake(unsigned int irq, unsigned int on);

static inline int enable_irq_wake(unsigned int irq)
{
	return irq_set_irq_wake(irq, 1);
}

static inline int disable_irq_wake(unsigned int irq)
{
	return irq_set_irq_wake(irq, 0);
}

/*
 * irq_get_irqchip_state/irq_set_irqchip_state specific flags
 */
enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING,		/* Is interrupt pending? */
	IRQCHIP_STATE_ACTIVE,		/* Is interrupt in progress? */
	IRQCHIP_STATE_MASKED,		/* Is interrupt masked? */
	IRQCHIP_STATE_LINE_LEVEL,	/* Is IRQ line high? */
};

extern int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
				 bool *state);
extern int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
				 bool state);

#ifdef CONFIG_IRQ_FORCED_THREADING
extern bool force_irqthreads;
#else
#define force_irqthreads	(0)
#endif

#ifndef __ARCH_SET_SOFTIRQ_PENDING
#define set_softirq_pending(x) (local_softirq_pending() = (x))
#define or_softirq_pending(x)  (local_softirq_pending() |= (x))
#endif

/* Some architectures might implement lazy enabling/disabling of
 * interrupts. In some cases, such as stop_machine, we might want
 * to ensure that after a local_irq_disable(), interrupts have
 * really been disabled in hardware. Such architectures need to
 * implement the following hook.
 */
#ifndef hard_irq_disable
#define hard_irq_disable()	do { } while(0)
#endif

/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
   frequency threaded job scheduling. For almost all the purposes
   tasklets are more than enough. F.e. all serial device BHs et
   al. should be converted to tasklets, not to softirqs.
 */

enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	IRQ_POLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ, /* Unused, but kept as tools rely on the
			    numbering. Sigh! */
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};

#define SOFTIRQ_STOP_IDLE_MASK (~(1 << RCU_SOFTIRQ))

/* map softirq index to softirq name. update 'softirq_to_name' in
 * kernel/softirq.c when adding a new softirq.
 */
extern const char * const softirq_to_name[NR_SOFTIRQS];

/* softirq mask and active fields moved to irq_cpustat_t in
 * asm/hardirq.h to get better cache usage.  KAO
 */

struct softirq_action
{
	void	(*action)(struct softirq_action *);
};

asmlinkage void do_softirq(void);
asmlinkage void __do_softirq(void);

#ifdef __ARCH_HAS_DO_SOFTIRQ
void do_softirq_own_stack(void);
#else
static inline void do_softirq_own_stack(void)
{
	__do_softirq();
}
#endif

extern void open_softirq(int nr, void (*action)(struct softirq_action *));
extern void softirq_init(void);
extern void __raise_softirq_irqoff(unsigned int nr);

extern void raise_softirq_irqoff(unsigned int nr);
extern void raise_softirq(unsigned int nr);

DECLARE_PER_CPU(struct task_struct *, ksoftirqd);

static inline struct task_struct *this_cpu_ksoftirqd(void)
{
	return this_cpu_read(ksoftirqd);
}

/* Tasklets --- multithreaded analogue of BHs.

   Main feature differing them of generic softirqs: tasklet
   is running only on one CPU simultaneously.

   Main feature differing them of BHs: different tasklets
   may be run simultaneously on different CPUs.

   Properties:
   * If tasklet_schedule() is called, then tasklet is guaranteed
     to be executed on some cpu at least once after this.
   * If the tasklet is already scheduled, but its execution is still not
     started, it will be executed only once.
   * If this tasklet is already running on another CPU (or schedule is called
     from tasklet itself), it is rescheduled for later.
   * Tasklet is strictly serialized wrt itself, but not
     wrt another tasklets. If client needs some intertask synchronization,
     he makes it with spinlocks.
 */

struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	void (*func)(unsigned long);
	unsigned long data;
};

#define DECLARE_TASKLET(name, func, data) \
struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }

#define DECLARE_TASKLET_DISABLED(name, func, data) \
struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }


enum
{
	TASKLET_STATE_SCHED,	/* Tasklet is scheduled for execution */
	TASKLET_STATE_RUN	/* Tasklet is running (SMP only) */
};

#ifdef CONFIG_SMP
static inline int tasklet_trylock(struct tasklet_struct *t)
{
	return !test_and_set_bit(TASKLET_STATE_RUN, &(t)->state);
}

static inline void tasklet_unlock(struct tasklet_struct *t)
{
	smp_mb__before_atomic();
	clear_bit(TASKLET_STATE_RUN, &(t)->state);
}

static inline void tasklet_unlock_wait(struct tasklet_struct *t)
{
	while (test_bit(TASKLET_STATE_RUN, &(t)->state)) { barrier(); }
}
#else
#define tasklet_trylock(t) 1
#define tasklet_unlock_wait(t) do { } while (0)
#define tasklet_unlock(t) do { } while (0)
#endif

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
		__tasklet_schedule(t);
}

extern void __tasklet_hi_schedule(struct tasklet_struct *t);

static inline void tasklet_hi_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
		__tasklet_hi_schedule(t);
}

extern void __tasklet_hi_schedule_first(struct tasklet_struct *t);

/*
 * This version avoids touching any other tasklets. Needed for kmemcheck
 * in order not to take any page faults while enqueueing this tasklet;
 * consider VERY carefully whether you really need this or
 * tasklet_hi_schedule()...
 */
static inline void tasklet_hi_schedule_first(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
		__tasklet_hi_schedule_first(t);
}


static inline void tasklet_disable_nosync(struct tasklet_struct *t)
{
	atomic_inc(&t->count);
	smp_mb__after_atomic();
}

static inline void tasklet_disable(struct tasklet_struct *t)
{
	tasklet_disable_nosync(t);
	tasklet_unlock_wait(t);
	smp_mb();
}

static inline void tasklet_enable(struct tasklet_struct *t)
{
	smp_mb__before_atomic();
	atomic_dec(&t->count);
}

extern void tasklet_kill(struct tasklet_struct *t);
extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
extern void tasklet_init(struct tasklet_struct *t,
			 void (*func)(unsigned long), unsigned long data);

struct tasklet_hrtimer {
	struct hrtimer		timer;
	struct tasklet_struct	tasklet;
	enum hrtimer_restart	(*function)(struct hrtimer *);
};

extern void
tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,
		     enum hrtimer_restart (*function)(struct hrtimer *),
		     clockid_t which_clock, enum hrtimer_mode mode);

static inline
void tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer, ktime_t time,
			   const enum hrtimer_mode mode)
{
	hrtimer_start(&ttimer->timer, time, mode);
}

static inline
void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer)
{
	hrtimer_cancel(&ttimer->timer);
	tasklet_kill(&ttimer->tasklet);
}

/*
 * Autoprobing for irqs:
 *
 * probe_irq_on() and probe_irq_off() provide robust primitives
 * for accurate IRQ probing during kernel initialization.  They are
 * reasonably simple to use, are not "fooled" by spurious interrupts,
 * and, unlike other attempts at IRQ probing, they do not get hung on
 * stuck interrupts (such as unused PS2 mouse interfaces on ASUS boards).
 *
 * For reasonably foolproof probing, use them as follows:
 *
 * 1. clear and/or mask the device's internal interrupt.
 * 2. sti();
 * 3. irqs = probe_irq_on();      // "take over" all unassigned idle IRQs
 * 4. enable the device and cause it to trigger an interrupt.
 * 5. wait for the device to interrupt, using non-intrusive polling or a delay.
 * 6. irq = probe_irq_off(irqs);  // get IRQ number, 0=none, negative=multiple
 * 7. service the device to clear its pending interrupt.
 * 8. loop again if paranoia is required.
 *
 * probe_irq_on() returns a mask of allocated irq's.
 *
 * probe_irq_off() takes the mask as a parameter,
 * and returns the irq number which occurred,
 * or zero if none occurred, or a negative irq number
 * if more than one irq occurred.
 */

#if !defined(CONFIG_GENERIC_IRQ_PROBE) 
static inline unsigned long probe_irq_on(void)
{
	return 0;
}
static inline int probe_irq_off(unsigned long val)
{
	return 0;
}
static inline unsigned int probe_irq_mask(unsigned long val)
{
	return 0;
}
#else
extern unsigned long probe_irq_on(void);	/* returns 0 on failure */
extern int probe_irq_off(unsigned long);	/* returns 0 or negative on failure */
extern unsigned int probe_irq_mask(unsigned long);	/* returns mask of ISA interrupts */
#endif

#ifdef CONFIG_PROC_FS
/* Initialize /proc/irq/ */
extern void init_irq_proc(void);
#else
static inline void init_irq_proc(void)
{
}
#endif

struct seq_file;
int show_interrupts(struct seq_file *p, void *v);
int arch_show_interrupts(struct seq_file *p, int prec);

extern int early_irq_init(void);
extern int arch_probe_nr_irqs(void);
extern int arch_early_irq_init(void);

#if defined(CONFIG_FUNCTION_GRAPH_TRACER) || defined(CONFIG_KASAN)
/*
 * We want to know which function is an entrypoint of a hardirq or a softirq.
 */
#define __irq_entry		 __attribute__((__section__(".irqentry.text")))
#define __softirq_entry  \
	__attribute__((__section__(".softirqentry.text")))

/* Limits of hardirq entrypoints */
extern char __irqentry_text_start[];
extern char __irqentry_text_end[];
/* Limits of softirq entrypoints */
extern char __softirqentry_text_start[];
extern char __softirqentry_text_end[];

#else
#define __irq_entry
#define __softirq_entry
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_IO_64_NONATOMIC_LO_HI_H_
#define _LINUX_IO_64_NONATOMIC_LO_HI_H_

#include <linux/io.h>
#include <asm-generic/int-ll64.h>

static inline __u64 lo_hi_readq(const volatile void __iomem *addr)
{
	const volatile u32 __iomem *p = addr;
	u32 low, high;

	low = readl(p);
	high = readl(p + 1);

	return low + ((u64)high << 32);
}

static inline void lo_hi_writeq(__u64 val, volatile void __iomem *addr)
{
	writel(val, addr);
	writel(val >> 32, addr + 4);
}

static inline __u64 lo_hi_readq_relaxed(const volatile void __iomem *addr)
{
	const volatile u32 __iomem *p = addr;
	u32 low, high;

	low = readl_relaxed(p);
	high = readl_relaxed(p + 1);

	return low + ((u64)high << 32);
}

static inline void lo_hi_writeq_relaxed(__u64 val, volatile void __iomem *addr)
{
	writel_relaxed(val, addr);
	writel_relaxed(val >> 32, addr + 4);
}

#ifndef readq
#define readq lo_hi_readq
#endif

#ifndef writeq
#define writeq lo_hi_writeq
#endif

#ifndef readq_relaxed
#define readq_relaxed lo_hi_readq_relaxed
#endif

#ifndef writeq_relaxed
#define writeq_relaxed lo_hi_writeq_relaxed
#endif

#endif	/* _LINUX_IO_64_NONATOMIC_LO_HI_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef __LINUX_BACKING_DEV_DEFS_H
#define __LINUX_BACKING_DEV_DEFS_H

#include <linux/list.h>
#include <linux/radix-tree.h>
#include <linux/rbtree.h>
#include <linux/spinlock.h>
#include <linux/percpu_counter.h>
#include <linux/percpu-refcount.h>
#include <linux/flex_proportions.h>
#include <linux/timer.h>
#include <linux/workqueue.h>

struct page;
struct device;
struct dentry;

/*
 * Bits in bdi_writeback.state
 */
enum wb_state {
	WB_registered,		/* bdi_register() was done */
	WB_writeback_running,	/* Writeback is in progress */
	WB_has_dirty_io,	/* Dirty inodes on ->b_{dirty|io|more_io} */
};

enum wb_congested_state {
	WB_async_congested,	/* The async (write) queue is getting full */
	WB_sync_congested,	/* The sync queue is getting full */
};

typedef int (congested_fn)(void *, int);

enum wb_stat_item {
	WB_RECLAIMABLE,
	WB_WRITEBACK,
	WB_DIRTIED,
	WB_WRITTEN,
	NR_WB_STAT_ITEMS
};

#define WB_STAT_BATCH (8*(1+ilog2(nr_cpu_ids)))

/*
 * For cgroup writeback, multiple wb's may map to the same blkcg.  Those
 * wb's can operate mostly independently but should share the congested
 * state.  To facilitate such sharing, the congested state is tracked using
 * the following struct which is created on demand, indexed by blkcg ID on
 * its bdi, and refcounted.
 */
struct bdi_writeback_congested {
	unsigned long state;		/* WB_[a]sync_congested flags */
	atomic_t refcnt;		/* nr of attached wb's and blkg */

#ifdef CONFIG_CGROUP_WRITEBACK
	struct backing_dev_info *bdi;	/* the associated bdi */
	int blkcg_id;			/* ID of the associated blkcg */
	struct rb_node rb_node;		/* on bdi->cgwb_congestion_tree */
#endif
};

/*
 * Each wb (bdi_writeback) can perform writeback operations, is measured
 * and throttled, independently.  Without cgroup writeback, each bdi
 * (bdi_writeback) is served by its embedded bdi->wb.
 *
 * On the default hierarchy, blkcg implicitly enables memcg.  This allows
 * using memcg's page ownership for attributing writeback IOs, and every
 * memcg - blkcg combination can be served by its own wb by assigning a
 * dedicated wb to each memcg, which enables isolation across different
 * cgroups and propagation of IO back pressure down from the IO layer upto
 * the tasks which are generating the dirty pages to be written back.
 *
 * A cgroup wb is indexed on its bdi by the ID of the associated memcg,
 * refcounted with the number of inodes attached to it, and pins the memcg
 * and the corresponding blkcg.  As the corresponding blkcg for a memcg may
 * change as blkcg is disabled and enabled higher up in the hierarchy, a wb
 * is tested for blkcg after lookup and removed from index on mismatch so
 * that a new wb for the combination can be created.
 */
struct bdi_writeback {
	struct backing_dev_info *bdi;	/* our parent bdi */

	unsigned long state;		/* Always use atomic bitops on this */
	unsigned long last_old_flush;	/* last old data flush */

	struct list_head b_dirty;	/* dirty inodes */
	struct list_head b_io;		/* parked for writeback */
	struct list_head b_more_io;	/* parked for more writeback */
	struct list_head b_dirty_time;	/* time stamps are dirty */
	spinlock_t list_lock;		/* protects the b_* lists */

	struct percpu_counter stat[NR_WB_STAT_ITEMS];

	struct bdi_writeback_congested *congested;

	unsigned long bw_time_stamp;	/* last time write bw is updated */
	unsigned long dirtied_stamp;
	unsigned long written_stamp;	/* pages written at bw_time_stamp */
	unsigned long write_bandwidth;	/* the estimated write bandwidth */
	unsigned long avg_write_bandwidth; /* further smoothed write bw, > 0 */

	/*
	 * The base dirty throttle rate, re-calculated on every 200ms.
	 * All the bdi tasks' dirty rate will be curbed under it.
	 * @dirty_ratelimit tracks the estimated @balanced_dirty_ratelimit
	 * in small steps and is much more smooth/stable than the latter.
	 */
	unsigned long dirty_ratelimit;
	unsigned long balanced_dirty_ratelimit;

	struct fprop_local_percpu completions;
	int dirty_exceeded;

	spinlock_t work_lock;		/* protects work_list & dwork scheduling */
	struct list_head work_list;
	struct delayed_work dwork;	/* work item used for writeback */

	struct list_head bdi_node;	/* anchored at bdi->wb_list */

#ifdef CONFIG_CGROUP_WRITEBACK
	struct percpu_ref refcnt;	/* used only for !root wb's */
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css; /* the associated memcg */
	struct cgroup_subsys_state *blkcg_css; /* and blkcg */
	struct list_head memcg_node;	/* anchored at memcg->cgwb_list */
	struct list_head blkcg_node;	/* anchored at blkcg->cgwb_list */

	union {
		struct work_struct release_work;
		struct rcu_head rcu;
	};
#endif
};

struct backing_dev_info {
	struct list_head bdi_list;
	unsigned long ra_pages;	/* max readahead in PAGE_SIZE units */
	unsigned int capabilities; /* Device capabilities */
	congested_fn *congested_fn; /* Function pointer if device is md/dm */
	void *congested_data;	/* Pointer to aux data for congested func */

	char *name;

	unsigned int min_ratio;
	unsigned int max_ratio, max_prop_frac;

	/*
	 * Sum of avg_write_bw of wbs with dirty inodes.  > 0 if there are
	 * any dirty wbs, which is depended upon by bdi_has_dirty().
	 */
	atomic_long_t tot_write_bandwidth;

	struct bdi_writeback wb;  /* the root writeback info for this bdi */
	struct list_head wb_list; /* list of all wbs */
#ifdef CONFIG_CGROUP_WRITEBACK
	struct radix_tree_root cgwb_tree; /* radix tree of active cgroup wbs */
	struct rb_root cgwb_congested_tree; /* their congested states */
	atomic_t usage_cnt; /* counts both cgwbs and cgwb_contested's */
#else
	struct bdi_writeback_congested *wb_congested;
#endif
	wait_queue_head_t wb_waitq;

	struct device *dev;
	struct device *owner;

	struct timer_list laptop_mode_wb_timer;

#ifdef CONFIG_DEBUG_FS
	struct dentry *debug_dir;
	struct dentry *debug_stats;
#endif
};

enum {
	BLK_RW_ASYNC	= 0,
	BLK_RW_SYNC	= 1,
};

void clear_wb_congested(struct bdi_writeback_congested *congested, int sync);
void set_wb_congested(struct bdi_writeback_congested *congested, int sync);

static inline void clear_bdi_congested(struct backing_dev_info *bdi, int sync)
{
	clear_wb_congested(bdi->wb.congested, sync);
}

static inline void set_bdi_congested(struct backing_dev_info *bdi, int sync)
{
	set_wb_congested(bdi->wb.congested, sync);
}

#ifdef CONFIG_CGROUP_WRITEBACK

/**
 * wb_tryget - try to increment a wb's refcount
 * @wb: bdi_writeback to get
 */
static inline bool wb_tryget(struct bdi_writeback *wb)
{
	if (wb != &wb->bdi->wb)
		return percpu_ref_tryget(&wb->refcnt);
	return true;
}

/**
 * wb_get - increment a wb's refcount
 * @wb: bdi_writeback to get
 */
static inline void wb_get(struct bdi_writeback *wb)
{
	if (wb != &wb->bdi->wb)
		percpu_ref_get(&wb->refcnt);
}

/**
 * wb_put - decrement a wb's refcount
 * @wb: bdi_writeback to put
 */
static inline void wb_put(struct bdi_writeback *wb)
{
	if (wb != &wb->bdi->wb)
		percpu_ref_put(&wb->refcnt);
}

/**
 * wb_dying - is a wb dying?
 * @wb: bdi_writeback of interest
 *
 * Returns whether @wb is unlinked and being drained.
 */
static inline bool wb_dying(struct bdi_writeback *wb)
{
	return percpu_ref_is_dying(&wb->refcnt);
}

#else	/* CONFIG_CGROUP_WRITEBACK */

static inline bool wb_tryget(struct bdi_writeback *wb)
{
	return true;
}

static inline void wb_get(struct bdi_writeback *wb)
{
}

static inline void wb_put(struct bdi_writeback *wb)
{
}

static inline bool wb_dying(struct bdi_writeback *wb)
{
	return false;
}

#endif	/* CONFIG_CGROUP_WRITEBACK */

#endif	/* __LINUX_BACKING_DEV_DEFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef _LINUX_ERRQUEUE_H
#define _LINUX_ERRQUEUE_H 1


#include <net/ip.h>
#if IS_ENABLED(CONFIG_IPV6)
#include <linux/ipv6.h>
#endif
#include <uapi/linux/errqueue.h>

#define SKB_EXT_ERR(skb) ((struct sock_exterr_skb *) ((skb)->cb))

struct sock_exterr_skb {
	union {
		struct inet_skb_parm	h4;
#if IS_ENABLED(CONFIG_IPV6)
		struct inet6_skb_parm	h6;
#endif
	} header;
	struct sock_extended_err	ee;
	u16				addr_offset;
	__be16				port;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * General per-file encryption definition
 *
 * Copyright (C) 2015, Google, Inc.
 *
 * Written by Michael Halcrow, 2015.
 * Modified by Jaegeuk Kim, 2015.
 */

#ifndef _LINUX_FSCRYPTO_H
#define _LINUX_FSCRYPTO_H

#include <linux/key.h>
#include <linux/fs.h>
#include <linux/mm.h>
#include <linux/bio.h>
#include <linux/dcache.h>
#include <crypto/skcipher.h>
#include <uapi/linux/fs.h>

#define FS_KEY_DERIVATION_NONCE_SIZE		16
#define FS_ENCRYPTION_CONTEXT_FORMAT_V1		1

#define FS_POLICY_FLAGS_PAD_4		0x00
#define FS_POLICY_FLAGS_PAD_8		0x01
#define FS_POLICY_FLAGS_PAD_16		0x02
#define FS_POLICY_FLAGS_PAD_32		0x03
#define FS_POLICY_FLAGS_PAD_MASK	0x03
#define FS_POLICY_FLAGS_VALID		0x03

/* Encryption algorithms */
#define FS_ENCRYPTION_MODE_INVALID		0
#define FS_ENCRYPTION_MODE_AES_256_XTS		1
#define FS_ENCRYPTION_MODE_AES_256_GCM		2
#define FS_ENCRYPTION_MODE_AES_256_CBC		3
#define FS_ENCRYPTION_MODE_AES_256_CTS		4

/**
 * Encryption context for inode
 *
 * Protector format:
 *  1 byte: Protector format (1 = this version)
 *  1 byte: File contents encryption mode
 *  1 byte: File names encryption mode
 *  1 byte: Flags
 *  8 bytes: Master Key descriptor
 *  16 bytes: Encryption Key derivation nonce
 */
struct fscrypt_context {
	u8 format;
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
	u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
} __packed;

/* Encryption parameters */
#define FS_XTS_TWEAK_SIZE		16
#define FS_AES_128_ECB_KEY_SIZE		16
#define FS_AES_256_GCM_KEY_SIZE		32
#define FS_AES_256_CBC_KEY_SIZE		32
#define FS_AES_256_CTS_KEY_SIZE		32
#define FS_AES_256_XTS_KEY_SIZE		64
#define FS_MAX_KEY_SIZE			64

#define FS_KEY_DESC_PREFIX		"fscrypt:"
#define FS_KEY_DESC_PREFIX_SIZE		8

/* This is passed in from userspace into the kernel keyring */
struct fscrypt_key {
	u32 mode;
	u8 raw[FS_MAX_KEY_SIZE];
	u32 size;
} __packed;

struct fscrypt_info {
	u8 ci_data_mode;
	u8 ci_filename_mode;
	u8 ci_flags;
	struct crypto_skcipher *ci_ctfm;
	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
};

#define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
#define FS_WRITE_PATH_FL			0x00000002

struct fscrypt_ctx {
	union {
		struct {
			struct page *bounce_page;	/* Ciphertext page */
			struct page *control_page;	/* Original page  */
		} w;
		struct {
			struct bio *bio;
			struct work_struct work;
		} r;
		struct list_head free_list;	/* Free list */
	};
	u8 flags;				/* Flags */
	u8 mode;				/* Encryption mode for tfm */
};

struct fscrypt_completion_result {
	struct completion completion;
	int res;
};

#define DECLARE_FS_COMPLETION_RESULT(ecr) \
	struct fscrypt_completion_result ecr = { \
		COMPLETION_INITIALIZER((ecr).completion), 0 }

#define FS_FNAME_NUM_SCATTER_ENTRIES	4
#define FS_CRYPTO_BLOCK_SIZE		16
#define FS_FNAME_CRYPTO_DIGEST_SIZE	32

/**
 * For encrypted symlinks, the ciphertext length is stored at the beginning
 * of the string in little-endian format.
 */
struct fscrypt_symlink_data {
	__le16 len;
	char encrypted_path[1];
} __packed;

/**
 * This function is used to calculate the disk space required to
 * store a filename of length l in encrypted symlink format.
 */
static inline u32 fscrypt_symlink_data_len(u32 l)
{
	if (l < FS_CRYPTO_BLOCK_SIZE)
		l = FS_CRYPTO_BLOCK_SIZE;
	return (l + sizeof(struct fscrypt_symlink_data) - 1);
}

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
};

#define FSTR_INIT(n, l)		{ .name = n, .len = l }
#define FSTR_TO_QSTR(f)		QSTR_INIT((f)->name, (f)->len)
#define fname_name(p)		((p)->disk_name.name)
#define fname_len(p)		((p)->disk_name.len)

/*
 * crypto opertions for filesystems
 */
struct fscrypt_operations {
	int (*get_context)(struct inode *, void *, size_t);
	int (*key_prefix)(struct inode *, u8 **);
	int (*prepare_context)(struct inode *);
	int (*set_context)(struct inode *, const void *, size_t, void *);
	int (*dummy_context)(struct inode *);
	bool (*is_encrypted)(struct inode *);
	bool (*empty_dir)(struct inode *);
	unsigned (*max_namelen)(struct inode *);
};

static inline bool fscrypt_dummy_context_enabled(struct inode *inode)
{
	if (inode->i_sb->s_cop->dummy_context &&
				inode->i_sb->s_cop->dummy_context(inode))
		return true;
	return false;
}

static inline bool fscrypt_valid_contents_enc_mode(u32 mode)
{
	return (mode == FS_ENCRYPTION_MODE_AES_256_XTS);
}

static inline bool fscrypt_valid_filenames_enc_mode(u32 mode)
{
	return (mode == FS_ENCRYPTION_MODE_AES_256_CTS);
}

static inline bool fscrypt_is_dot_dotdot(const struct qstr *str)
{
	if (str->len == 1 && str->name[0] == '.')
		return true;

	if (str->len == 2 && str->name[0] == '.' && str->name[1] == '.')
		return true;

	return false;
}

static inline struct page *fscrypt_control_page(struct page *page)
{
#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	return ((struct fscrypt_ctx *)page_private(page))->w.control_page;
#else
	WARN_ON_ONCE(1);
	return ERR_PTR(-EINVAL);
#endif
}

static inline int fscrypt_has_encryption_key(struct inode *inode)
{
#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	return (inode->i_crypt_info != NULL);
#else
	return 0;
#endif
}

static inline void fscrypt_set_encrypted_dentry(struct dentry *dentry)
{
#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	spin_lock(&dentry->d_lock);
	dentry->d_flags |= DCACHE_ENCRYPTED_WITH_KEY;
	spin_unlock(&dentry->d_lock);
#endif
}

#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
extern const struct dentry_operations fscrypt_d_ops;
#endif

static inline void fscrypt_set_d_op(struct dentry *dentry)
{
#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	d_set_d_op(dentry, &fscrypt_d_ops);
#endif
}

#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
/* crypto.c */
extern struct kmem_cache *fscrypt_info_cachep;
int fscrypt_initialize(void);

extern struct fscrypt_ctx *fscrypt_get_ctx(struct inode *, gfp_t);
extern void fscrypt_release_ctx(struct fscrypt_ctx *);
extern struct page *fscrypt_encrypt_page(struct inode *, struct page *, gfp_t);
extern int fscrypt_decrypt_page(struct page *);
extern void fscrypt_decrypt_bio_pages(struct fscrypt_ctx *, struct bio *);
extern void fscrypt_pullback_bio_page(struct page **, bool);
extern void fscrypt_restore_control_page(struct page *);
extern int fscrypt_zeroout_range(struct inode *, pgoff_t, sector_t,
						unsigned int);
/* policy.c */
extern int fscrypt_process_policy(struct file *, const struct fscrypt_policy *);
extern int fscrypt_get_policy(struct inode *, struct fscrypt_policy *);
extern int fscrypt_has_permitted_context(struct inode *, struct inode *);
extern int fscrypt_inherit_context(struct inode *, struct inode *,
					void *, bool);
/* keyinfo.c */
extern int fscrypt_get_encryption_info(struct inode *);
extern void fscrypt_put_encryption_info(struct inode *, struct fscrypt_info *);

/* fname.c */
extern int fscrypt_setup_filename(struct inode *, const struct qstr *,
				int lookup, struct fscrypt_name *);
extern void fscrypt_free_filename(struct fscrypt_name *);
extern u32 fscrypt_fname_encrypted_size(struct inode *, u32);
extern int fscrypt_fname_alloc_buffer(struct inode *, u32,
				struct fscrypt_str *);
extern void fscrypt_fname_free_buffer(struct fscrypt_str *);
extern int fscrypt_fname_disk_to_usr(struct inode *, u32, u32,
			const struct fscrypt_str *, struct fscrypt_str *);
extern int fscrypt_fname_usr_to_disk(struct inode *, const struct qstr *,
			struct fscrypt_str *);
#endif

/* crypto.c */
static inline struct fscrypt_ctx *fscrypt_notsupp_get_ctx(struct inode *i,
							gfp_t f)
{
	return ERR_PTR(-EOPNOTSUPP);
}

static inline void fscrypt_notsupp_release_ctx(struct fscrypt_ctx *c)
{
	return;
}

static inline struct page *fscrypt_notsupp_encrypt_page(struct inode *i,
						struct page *p, gfp_t f)
{
	return ERR_PTR(-EOPNOTSUPP);
}

static inline int fscrypt_notsupp_decrypt_page(struct page *p)
{
	return -EOPNOTSUPP;
}

static inline void fscrypt_notsupp_decrypt_bio_pages(struct fscrypt_ctx *c,
						struct bio *b)
{
	return;
}

static inline void fscrypt_notsupp_pullback_bio_page(struct page **p, bool b)
{
	return;
}

static inline void fscrypt_notsupp_restore_control_page(struct page *p)
{
	return;
}

static inline int fscrypt_notsupp_zeroout_range(struct inode *i, pgoff_t p,
					sector_t s, unsigned int f)
{
	return -EOPNOTSUPP;
}

/* policy.c */
static inline int fscrypt_notsupp_process_policy(struct file *f,
				const struct fscrypt_policy *p)
{
	return -EOPNOTSUPP;
}

static inline int fscrypt_notsupp_get_policy(struct inode *i,
				struct fscrypt_policy *p)
{
	return -EOPNOTSUPP;
}

static inline int fscrypt_notsupp_has_permitted_context(struct inode *p,
				struct inode *i)
{
	return 0;
}

static inline int fscrypt_notsupp_inherit_context(struct inode *p,
				struct inode *i, void *v, bool b)
{
	return -EOPNOTSUPP;
}

/* keyinfo.c */
static inline int fscrypt_notsupp_get_encryption_info(struct inode *i)
{
	return -EOPNOTSUPP;
}

static inline void fscrypt_notsupp_put_encryption_info(struct inode *i,
					struct fscrypt_info *f)
{
	return;
}

 /* fname.c */
static inline int fscrypt_notsupp_setup_filename(struct inode *dir,
			const struct qstr *iname,
			int lookup, struct fscrypt_name *fname)
{
	if (dir->i_sb->s_cop->is_encrypted(dir))
		return -EOPNOTSUPP;

	memset(fname, 0, sizeof(struct fscrypt_name));
	fname->usr_fname = iname;
	fname->disk_name.name = (unsigned char *)iname->name;
	fname->disk_name.len = iname->len;
	return 0;
}

static inline void fscrypt_notsupp_free_filename(struct fscrypt_name *fname)
{
	return;
}

static inline u32 fscrypt_notsupp_fname_encrypted_size(struct inode *i, u32 s)
{
	/* never happens */
	WARN_ON(1);
	return 0;
}

static inline int fscrypt_notsupp_fname_alloc_buffer(struct inode *inode,
				u32 ilen, struct fscrypt_str *crypto_str)
{
	return -EOPNOTSUPP;
}

static inline void fscrypt_notsupp_fname_free_buffer(struct fscrypt_str *c)
{
	return;
}

static inline int fscrypt_notsupp_fname_disk_to_usr(struct inode *inode,
			u32 hash, u32 minor_hash,
			const struct fscrypt_str *iname,
			struct fscrypt_str *oname)
{
	return -EOPNOTSUPP;
}

static inline int fscrypt_notsupp_fname_usr_to_disk(struct inode *inode,
			const struct qstr *iname,
			struct fscrypt_str *oname)
{
	return -EOPNOTSUPP;
}
#endif	/* _LINUX_FSCRYPTO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef __SH_CLOCK_H
#define __SH_CLOCK_H

#include <linux/list.h>
#include <linux/seq_file.h>
#include <linux/cpufreq.h>
#include <linux/types.h>
#include <linux/kref.h>
#include <linux/clk.h>
#include <linux/err.h>

struct clk;

struct clk_mapping {
	phys_addr_t		phys;
	void __iomem		*base;
	unsigned long		len;
	struct kref		ref;
};

struct sh_clk_ops {
#ifdef CONFIG_SH_CLK_CPG_LEGACY
	void (*init)(struct clk *clk);
#endif
	int (*enable)(struct clk *clk);
	void (*disable)(struct clk *clk);
	unsigned long (*recalc)(struct clk *clk);
	int (*set_rate)(struct clk *clk, unsigned long rate);
	int (*set_parent)(struct clk *clk, struct clk *parent);
	long (*round_rate)(struct clk *clk, unsigned long rate);
};

#define SH_CLK_DIV_MSK(div)	((1 << (div)) - 1)
#define SH_CLK_DIV4_MSK		SH_CLK_DIV_MSK(4)
#define SH_CLK_DIV6_MSK		SH_CLK_DIV_MSK(6)

struct clk {
	struct list_head	node;
	struct clk		*parent;
	struct clk		**parent_table;	/* list of parents to */
	unsigned short		parent_num;	/* choose between */
	unsigned char		src_shift;	/* source clock field in the */
	unsigned char		src_width;	/* configuration register */
	struct sh_clk_ops	*ops;

	struct list_head	children;
	struct list_head	sibling;	/* node for children */

	int			usecount;

	unsigned long		rate;
	unsigned long		flags;

	void __iomem		*enable_reg;
	void __iomem		*status_reg;
	unsigned int		enable_bit;
	void __iomem		*mapped_reg;

	unsigned int		div_mask;
	unsigned long		arch_flags;
	void			*priv;
	struct clk_mapping	*mapping;
	struct cpufreq_frequency_table *freq_table;
	unsigned int		nr_freqs;
};

#define CLK_ENABLE_ON_INIT	BIT(0)

#define CLK_ENABLE_REG_32BIT	BIT(1)	/* default access size */
#define CLK_ENABLE_REG_16BIT	BIT(2)
#define CLK_ENABLE_REG_8BIT	BIT(3)

#define CLK_MASK_DIV_ON_DISABLE	BIT(4)

#define CLK_ENABLE_REG_MASK	(CLK_ENABLE_REG_32BIT | \
				 CLK_ENABLE_REG_16BIT | \
				 CLK_ENABLE_REG_8BIT)

/* drivers/sh/clk.c */
unsigned long followparent_recalc(struct clk *);
void recalculate_root_clocks(void);
void propagate_rate(struct clk *);
int clk_reparent(struct clk *child, struct clk *parent);
int clk_register(struct clk *);
void clk_unregister(struct clk *);
void clk_enable_init_clocks(void);

struct clk_div_mult_table {
	unsigned int *divisors;
	unsigned int nr_divisors;
	unsigned int *multipliers;
	unsigned int nr_multipliers;
};

struct cpufreq_frequency_table;
void clk_rate_table_build(struct clk *clk,
			  struct cpufreq_frequency_table *freq_table,
			  int nr_freqs,
			  struct clk_div_mult_table *src_table,
			  unsigned long *bitmap);

long clk_rate_table_round(struct clk *clk,
			  struct cpufreq_frequency_table *freq_table,
			  unsigned long rate);

int clk_rate_table_find(struct clk *clk,
			struct cpufreq_frequency_table *freq_table,
			unsigned long rate);

long clk_rate_div_range_round(struct clk *clk, unsigned int div_min,
			      unsigned int div_max, unsigned long rate);

long clk_rate_mult_range_round(struct clk *clk, unsigned int mult_min,
			       unsigned int mult_max, unsigned long rate);

#define SH_CLK_MSTP(_parent, _enable_reg, _enable_bit, _status_reg, _flags) \
{									\
	.parent		= _parent,					\
	.enable_reg	= (void __iomem *)_enable_reg,			\
	.enable_bit	= _enable_bit,					\
	.status_reg	= _status_reg,					\
	.flags		= _flags,					\
}

#define SH_CLK_MSTP32(_p, _r, _b, _f)				\
	SH_CLK_MSTP(_p, _r, _b, 0, _f | CLK_ENABLE_REG_32BIT)

#define SH_CLK_MSTP32_STS(_p, _r, _b, _s, _f)			\
	SH_CLK_MSTP(_p, _r, _b, _s, _f | CLK_ENABLE_REG_32BIT)

#define SH_CLK_MSTP16(_p, _r, _b, _f)				\
	SH_CLK_MSTP(_p, _r, _b, 0, _f | CLK_ENABLE_REG_16BIT)

#define SH_CLK_MSTP8(_p, _r, _b, _f)				\
	SH_CLK_MSTP(_p, _r, _b, 0, _f | CLK_ENABLE_REG_8BIT)

int sh_clk_mstp_register(struct clk *clks, int nr);

/*
 * MSTP registration never really cared about access size, despite the
 * original enable/disable pairs assuming a 32-bit access. Clocks are
 * responsible for defining their access sizes either directly or via the
 * clock definition wrappers.
 */
static inline int __deprecated sh_clk_mstp32_register(struct clk *clks, int nr)
{
	return sh_clk_mstp_register(clks, nr);
}

#define SH_CLK_DIV4(_parent, _reg, _shift, _div_bitmap, _flags)	\
{								\
	.parent = _parent,					\
	.enable_reg = (void __iomem *)_reg,			\
	.enable_bit = _shift,					\
	.arch_flags = _div_bitmap,				\
	.div_mask = SH_CLK_DIV4_MSK,				\
	.flags = _flags,					\
}

struct clk_div_table {
	struct clk_div_mult_table *div_mult_table;
	void (*kick)(struct clk *clk);
};

#define clk_div4_table clk_div_table

int sh_clk_div4_register(struct clk *clks, int nr,
			 struct clk_div4_table *table);
int sh_clk_div4_enable_register(struct clk *clks, int nr,
			 struct clk_div4_table *table);
int sh_clk_div4_reparent_register(struct clk *clks, int nr,
			 struct clk_div4_table *table);

#define SH_CLK_DIV6_EXT(_reg, _flags, _parents,			\
			_num_parents, _src_shift, _src_width)	\
{								\
	.enable_reg = (void __iomem *)_reg,			\
	.enable_bit = 0, /* unused */				\
	.flags = _flags | CLK_MASK_DIV_ON_DISABLE,		\
	.div_mask = SH_CLK_DIV6_MSK,				\
	.parent_table = _parents,				\
	.parent_num = _num_parents,				\
	.src_shift = _src_shift,				\
	.src_width = _src_width,				\
}

#define SH_CLK_DIV6(_parent, _reg, _flags)			\
{								\
	.parent		= _parent,				\
	.enable_reg	= (void __iomem *)_reg,			\
	.enable_bit	= 0,	/* unused */			\
	.div_mask	= SH_CLK_DIV6_MSK,			\
	.flags		= _flags | CLK_MASK_DIV_ON_DISABLE,	\
}

int sh_clk_div6_register(struct clk *clks, int nr);
int sh_clk_div6_reparent_register(struct clk *clks, int nr);

#define CLKDEV_CON_ID(_id, _clk) { .con_id = _id, .clk = _clk }
#define CLKDEV_DEV_ID(_id, _clk) { .dev_id = _id, .clk = _clk }
#define CLKDEV_ICK_ID(_cid, _did, _clk) { .con_id = _cid, .dev_id = _did, .clk = _clk }

/* .enable_reg will be updated to .mapping on sh_clk_fsidiv_register() */
#define SH_CLK_FSIDIV(_reg, _parent)		\
{						\
	.enable_reg = (void __iomem *)_reg,	\
	.parent		= _parent,		\
}

int sh_clk_fsidiv_register(struct clk *clks, int nr);

#endif /* __SH_CLOCK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _LINUX_SYSV_FS_H
#define _LINUX_SYSV_FS_H

#define __packed2__	__attribute__((packed, aligned(2)))


#ifndef __KERNEL__
typedef u16 __fs16;
typedef u32 __fs16;
#endif

/* inode numbers are 16 bit */
typedef __fs16 sysv_ino_t;

/* Block numbers are 24 bit, sometimes stored in 32 bit.
   On Coherent FS, they are always stored in PDP-11 manner: the least
   significant 16 bits come last. */
typedef __fs32 sysv_zone_t;

/* 0 is non-existent */
#define SYSV_BADBL_INO	1	/* inode of bad blocks file */
#define SYSV_ROOT_INO	2	/* inode of root directory */


/* Xenix super-block data on disk */
#define XENIX_NICINOD	100	/* number of inode cache entries */
#define XENIX_NICFREE	100	/* number of free block list chunk entries */
struct xenix_super_block {
	__fs16		s_isize; /* index of first data zone */
	__fs32		s_fsize __packed2__; /* total number of zones of this fs */
	/* the start of the free block list: */
	__fs16		s_nfree;	/* number of free blocks in s_free, <= XENIX_NICFREE */
	sysv_zone_t	s_free[XENIX_NICFREE]; /* first free block list chunk */
	/* the cache of free inodes: */
	__fs16		s_ninode; /* number of free inodes in s_inode, <= XENIX_NICINOD */
	sysv_ino_t	s_inode[XENIX_NICINOD]; /* some free inodes */
	/* locks, not used by Linux: */
	char		s_flock;	/* lock during free block list manipulation */
	char		s_ilock;	/* lock during inode cache manipulation */
	char		s_fmod;		/* super-block modified flag */
	char		s_ronly;	/* flag whether fs is mounted read-only */
	__fs32		s_time __packed2__; /* time of last super block update */
	__fs32		s_tfree __packed2__; /* total number of free zones */
	__fs16		s_tinode;	/* total number of free inodes */
	__fs16		s_dinfo[4];	/* device information ?? */
	char		s_fname[6];	/* file system volume name */
	char		s_fpack[6];	/* file system pack name */
	char		s_clean;	/* set to 0x46 when filesystem is properly unmounted */
	char		s_fill[371];
	s32		s_magic;	/* version of file system */
	__fs32		s_type;		/* type of file system: 1 for 512 byte blocks
								2 for 1024 byte blocks
								3 for 2048 byte blocks */
								
};

/*
 * SystemV FS comes in two variants:
 * sysv2: System V Release 2 (e.g. Microport), structure elements aligned(2).
 * sysv4: System V Release 4 (e.g. Consensys), structure elements aligned(4).
 */
#define SYSV_NICINOD	100	/* number of inode cache entries */
#define SYSV_NICFREE	50	/* number of free block list chunk entries */

/* SystemV4 super-block data on disk */
struct sysv4_super_block {
	__fs16	s_isize;	/* index of first data zone */
	u16	s_pad0;
	__fs32	s_fsize;	/* total number of zones of this fs */
	/* the start of the free block list: */
	__fs16	s_nfree;	/* number of free blocks in s_free, <= SYSV_NICFREE */
	u16	s_pad1;
	sysv_zone_t	s_free[SYSV_NICFREE]; /* first free block list chunk */
	/* the cache of free inodes: */
	__fs16	s_ninode;	/* number of free inodes in s_inode, <= SYSV_NICINOD */
	u16	s_pad2;
	sysv_ino_t     s_inode[SYSV_NICINOD]; /* some free inodes */
	/* locks, not used by Linux: */
	char	s_flock;	/* lock during free block list manipulation */
	char	s_ilock;	/* lock during inode cache manipulation */
	char	s_fmod;		/* super-block modified flag */
	char	s_ronly;	/* flag whether fs is mounted read-only */
	__fs32	s_time;		/* time of last super block update */
	__fs16	s_dinfo[4];	/* device information ?? */
	__fs32	s_tfree;	/* total number of free zones */
	__fs16	s_tinode;	/* total number of free inodes */
	u16	s_pad3;
	char	s_fname[6];	/* file system volume name */
	char	s_fpack[6];	/* file system pack name */
	s32	s_fill[12];
	__fs32	s_state;	/* file system state: 0x7c269d38-s_time means clean */
	s32	s_magic;	/* version of file system */
	__fs32	s_type;		/* type of file system: 1 for 512 byte blocks
								2 for 1024 byte blocks */
};

/* SystemV2 super-block data on disk */
struct sysv2_super_block {
	__fs16	s_isize; 		/* index of first data zone */
	__fs32	s_fsize __packed2__;	/* total number of zones of this fs */
	/* the start of the free block list: */
	__fs16	s_nfree;		/* number of free blocks in s_free, <= SYSV_NICFREE */
	sysv_zone_t s_free[SYSV_NICFREE];	/* first free block list chunk */
	/* the cache of free inodes: */
	__fs16	s_ninode;		/* number of free inodes in s_inode, <= SYSV_NICINOD */
	sysv_ino_t     s_inode[SYSV_NICINOD]; /* some free inodes */
	/* locks, not used by Linux: */
	char	s_flock;		/* lock during free block list manipulation */
	char	s_ilock;		/* lock during inode cache manipulation */
	char	s_fmod;			/* super-block modified flag */
	char	s_ronly;		/* flag whether fs is mounted read-only */
	__fs32	s_time __packed2__;	/* time of last super block update */
	__fs16	s_dinfo[4];		/* device information ?? */
	__fs32	s_tfree __packed2__;	/* total number of free zones */
	__fs16	s_tinode;		/* total number of free inodes */
	char	s_fname[6];		/* file system volume name */
	char	s_fpack[6];		/* file system pack name */
	s32	s_fill[14];
	__fs32	s_state;		/* file system state: 0xcb096f43 means clean */
	s32	s_magic;		/* version of file system */
	__fs32	s_type;			/* type of file system: 1 for 512 byte blocks
								2 for 1024 byte blocks */
};

/* V7 super-block data on disk */
#define V7_NICINOD     100     /* number of inode cache entries */
#define V7_NICFREE     50      /* number of free block list chunk entries */
struct v7_super_block {
	__fs16 s_isize;        /* index of first data zone */
	__fs32 s_fsize __packed2__; /* total number of zones of this fs */
	/* the start of the free block list: */
	__fs16 s_nfree;        /* number of free blocks in s_free, <= V7_NICFREE */
	sysv_zone_t s_free[V7_NICFREE]; /* first free block list chunk */
	/* the cache of free inodes: */
	__fs16 s_ninode;       /* number of free inodes in s_inode, <= V7_NICINOD */
	sysv_ino_t      s_inode[V7_NICINOD]; /* some free inodes */
	/* locks, not used by Linux or V7: */
	char    s_flock;        /* lock during free block list manipulation */
	char    s_ilock;        /* lock during inode cache manipulation */
	char    s_fmod;         /* super-block modified flag */
	char    s_ronly;        /* flag whether fs is mounted read-only */
	__fs32  s_time __packed2__; /* time of last super block update */
	/* the following fields are not maintained by V7: */
	__fs32  s_tfree __packed2__; /* total number of free zones */
	__fs16  s_tinode;       /* total number of free inodes */
	__fs16  s_m;            /* interleave factor */
	__fs16  s_n;            /* interleave factor */
	char    s_fname[6];     /* file system name */
	char    s_fpack[6];     /* file system pack name */
};
/* Constants to aid sanity checking */
/* This is not a hard limit, nor enforced by v7 kernel. It's actually just
 * the limit used by Seventh Edition's ls, though is high enough to assume
 * that no reasonable file system would have that much entries in root
 * directory. Thus, if we see anything higher, we just probably got the
 * endiannes wrong. */
#define V7_NFILES	1024
/* The disk addresses are three-byte (despite direct block addresses being
 * aligned word-wise in inode). If the most significant byte is non-zero,
 * something is most likely wrong (not a filesystem, bad bytesex). */
#define V7_MAXSIZE	0x00ffffff

/* Coherent super-block data on disk */
#define COH_NICINOD	100	/* number of inode cache entries */
#define COH_NICFREE	64	/* number of free block list chunk entries */
struct coh_super_block {
	__fs16		s_isize;	/* index of first data zone */
	__fs32		s_fsize __packed2__; /* total number of zones of this fs */
	/* the start of the free block list: */
	__fs16 s_nfree;	/* number of free blocks in s_free, <= COH_NICFREE */
	sysv_zone_t	s_free[COH_NICFREE] __packed2__; /* first free block list chunk */
	/* the cache of free inodes: */
	__fs16		s_ninode;	/* number of free inodes in s_inode, <= COH_NICINOD */
	sysv_ino_t	s_inode[COH_NICINOD]; /* some free inodes */
	/* locks, not used by Linux: */
	char		s_flock;	/* lock during free block list manipulation */
	char		s_ilock;	/* lock during inode cache manipulation */
	char		s_fmod;		/* super-block modified flag */
	char		s_ronly;	/* flag whether fs is mounted read-only */
	__fs32		s_time __packed2__; /* time of last super block update */
	__fs32		s_tfree __packed2__; /* total number of free zones */
	__fs16		s_tinode;	/* total number of free inodes */
	__fs16		s_interleave_m;	/* interleave factor */
	__fs16		s_interleave_n;
	char		s_fname[6];	/* file system volume name */
	char		s_fpack[6];	/* file system pack name */
	__fs32		s_unique;	/* zero, not used */
};

/* SystemV/Coherent inode data on disk */
struct sysv_inode {
	__fs16 i_mode;
	__fs16 i_nlink;
	__fs16 i_uid;
	__fs16 i_gid;
	__fs32 i_size;
	u8  i_data[3*(10+1+1+1)];
	u8  i_gen;
	__fs32 i_atime;	/* time of last access */
	__fs32 i_mtime;	/* time of last modification */
	__fs32 i_ctime;	/* time of creation */
};

/* SystemV/Coherent directory entry on disk */
#define SYSV_NAMELEN	14	/* max size of name in struct sysv_dir_entry */
struct sysv_dir_entry {
	sysv_ino_t inode;
	char name[SYSV_NAMELEN]; /* up to 14 characters, the rest are zeroes */
};

#define SYSV_DIRSIZE	sizeof(struct sysv_dir_entry)	/* size of every directory entry */

#endif /* _LINUX_SYSV_FS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _ACPI_PMTMR_H_
#define _ACPI_PMTMR_H_

#include <linux/clocksource.h>

/* Number of PMTMR ticks expected during calibration run */
#define PMTMR_TICKS_PER_SEC 3579545

/* limit it to 24 bits */
#define ACPI_PM_MASK CLOCKSOURCE_MASK(24)

/* Overrun value */
#define ACPI_PM_OVRRUN	(1<<24)

#ifdef CONFIG_X86_PM_TIMER

extern u32 acpi_pm_read_verified(void);
extern u32 pmtmr_ioport;

static inline u32 acpi_pm_read_early(void)
{
	if (!pmtmr_ioport)
		return 0;
	/* mask the output to 24 bits */
	return acpi_pm_read_verified() & ACPI_PM_MASK;
}

#else

static inline u32 acpi_pm_read_early(void)
{
	return 0;
}

#endif

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 *  linux/drivers/video/pm3fb.h -- 3DLabs Permedia3 frame buffer device
 *
 *  Copyright (C) 2001 Romain Dolbeau <dolbeau@irisa.fr>
 *  Copyright (C) 2001 Sven Luther, <luther@dpt-info.u-strasbg.fr>
 *
 *  This file is subject to the terms and conditions of the GNU General Public
 *  License. See the file COPYING in the main directory of this archive for
 *  more details.
 */

#ifndef PM3FB_H
#define PM3FB_H

/**********************************************
*  GLINT Permedia3 Control Status registers   *
***********************************************/
/* Control Status Registers */
#define PM3ResetStatus						0x0000
#define PM3IntEnable						0x0008
#define PM3IntFlags						0x0010
#define PM3InFIFOSpace						0x0018
#define PM3OutFIFOWords						0x0020
#define PM3DMAAddress						0x0028
#define PM3DMACount						0x0030
#define PM3ErrorFlags						0x0038
#define PM3VClkCtl						0x0040
#define PM3TestRegister						0x0048
#define PM3Aperture0						0x0050
#define PM3Aperture1						0x0058
#define PM3DMAControl						0x0060
#define PM3FIFODis						0x0068
#define PM3ChipConfig						0x0070
#define PM3AGPControl						0x0078

#define PM3GPOutDMAAddress					0x0080
#define PM3PCIFeedbackCount					0x0088
#define PM3PCIAbortStatus					0x0090
#define PM3PCIAbortAddress					0x0098

#define PM3PCIPLLStatus						0x00f0

#define PM3HostTextureAddress					0x0100
#define PM3TextureDownloadControl				0x0108
#define PM3TextureOperation					0x0110
#define PM3LogicalTexturePage					0x0118
#define PM3TexDMAAddress					0x0120
#define PM3TexFIFOSpace						0x0128

/**********************************************
*  GLINT Permedia3 Region 0 Bypass Controls   *
***********************************************/
#define PM3ByAperture1Mode					0x0300
	#define PM3ByApertureMode_BYTESWAP_ABCD			(0 << 0)
	#define PM3ByApertureMode_BYTESWAP_BADC			(1 << 0)
	#define PM3ByApertureMode_BYTESWAP_CDAB			(2 << 0)
	#define PM3ByApertureMode_BYTESWAP_DCBA			(3 << 0)
	#define PM3ByApertureMode_PATCH_ENABLE			(1 << 2)
	#define PM3ByApertureMode_FORMAT_RAW			(0 << 3)
	#define PM3ByApertureMode_FORMAT_YUYV			(1 << 3)
	#define PM3ByApertureMode_FORMAT_UYVY			(2 << 3)
	#define PM3ByApertureMode_PIXELSIZE_8BIT		(0 << 5)
	#define PM3ByApertureMode_PIXELSIZE_16BIT		(1 << 5)
	#define PM3ByApertureMode_PIXELSIZE_32BIT		(2 << 5)
		#define PM3ByApertureMode_PIXELSIZE_MASK	(3 << 5)
	#define PM3ByApertureMode_EFFECTIVE_STRIDE_1024		(0 << 7)
	#define PM3ByApertureMode_EFFECTIVE_STRIDE_2048		(1 << 7)
	#define PM3ByApertureMode_EFFECTIVE_STRIDE_4096		(2 << 7)
	#define PM3ByApertureMode_EFFECTIVE_STRIDE_8192		(3 << 7)
	#define PM3ByApertureMode_PATCH_OFFSET_X(off)	(((off) & 0x7f) << 9)
	#define PM3ByApertureMode_PATCH_OFFSET_Y(off)	(((off) & 0x7f) << 16)
	#define PM3ByApertureMode_FRAMEBUFFER			(0 << 21)
	#define PM3ByApertureMode_LOCALBUFFER			(1 << 21)
	#define PM3ByApertureMode_DOUBLE_WRITE_OFF		(0 << 22)
	#define PM3ByApertureMode_DOUBLE_WRITE_1MB		(1 << 22)
	#define PM3ByApertureMode_DOUBLE_WRITE_2MB		(2 << 22)
	#define PM3ByApertureMode_DOUBLE_WRITE_4MB		(3 << 22)
	#define PM3ByApertureMode_DOUBLE_WRITE_8MB		(4 << 22)
	#define PM3ByApertureMode_DOUBLE_WRITE_16MB		(5 << 22)
	#define PM3ByApertureMode_DOUBLE_WRITE_32MB		(6 << 22)

#define PM3ByAperture2Mode					0x0328

/**********************************************
*  GLINT Permedia3 Memory Control (0x1000)    *
***********************************************/
#define PM3MemCounter						0x1000
#define PM3MemBypassWriteMask					0x1008
#define PM3MemScratch						0x1010
#define PM3LocalMemCaps						0x1018
	#define PM3LocalMemCaps_NoWriteMask			(1 << 28)
#define PM3LocalMemTimings					0x1020
#define PM3LocalMemControl					0x1028
#define PM3LocalMemRefresh					0x1030
#define PM3LocalMemPowerDown					0x1038
#define PM3RemoteMemControl					0x1100

/**********************************************
*  GLINT Permedia3 Video Control (0x3000)     *
***********************************************/

#define PM3ScreenBase						0x3000
#define PM3ScreenStride						0x3008
#define PM3HTotal						0x3010
#define PM3HgEnd						0x3018
#define PM3HbEnd						0x3020
#define PM3HsStart						0x3028
#define PM3HsEnd						0x3030
#define PM3VTotal						0x3038
#define PM3VbEnd						0x3040
#define PM3VsStart						0x3048
#define PM3VsEnd						0x3050
#define PM3VideoControl						0x3058
	#define PM3VideoControl_ENABLE				(1 << 0)
	#define PM3VideoControl_BLANK_ACTIVE_HIGH		(0 << 1)
	#define PM3VideoControl_BLANK_ACTIVE_LOW		(1 << 1)
	#define PM3VideoControl_LINE_DOUBLE_OFF			(0 << 2)
	#define PM3VideoControl_LINE_DOUBLE_ON			(1 << 2)
	#define PM3VideoControl_HSYNC_FORCE_HIGH		(0 << 3)
	#define PM3VideoControl_HSYNC_ACTIVE_HIGH		(1 << 3)
	#define PM3VideoControl_HSYNC_FORCE_LOW			(2 << 3)
	#define PM3VideoControl_HSYNC_ACTIVE_LOW		(3 << 3)
	#define PM3VideoControl_HSYNC_MASK			(3 << 3)
	#define PM3VideoControl_VSYNC_FORCE_HIGH		(0 << 5)
	#define PM3VideoControl_VSYNC_ACTIVE_HIGH		(1 << 5)
	#define PM3VideoControl_VSYNC_FORCE_LOW			(2 << 5)
	#define PM3VideoControl_VSYNC_ACTIVE_LOW		(3 << 5)
	#define PM3VideoControl_VSYNC_MASK			(3 << 5)
	#define PM3VideoControl_BYTE_DOUBLE_OFF			(0 << 7)
	#define PM3VideoControl_BYTE_DOUBLE_ON			(1 << 7)
	#define PM3VideoControl_BUFFER_SWAP_SYNCON_FRAMEBLANK	(0 << 9)
	#define PM3VideoControl_BUFFER_SWAP_FREE_RUNNING	(1 << 9)
	#define PM3VideoControl_BUFFER_SWAP_LIMITETO_FRAMERATE	(2 << 9)
	#define PM3VideoControl_STEREO_ENABLE			(1 << 11)
	#define PM3VideoControl_RIGHT_EYE_ACTIVE_HIGH		(0 << 12)
	#define PM3VideoControl_RIGHT_EYE_ACTIVE_LOW		(1 << 12)
	#define PM3VideoControl_VIDEO_EXT_LOW			(0 << 14)
	#define PM3VideoControl_VIDEO_EXT_HIGH			(1 << 14)
	#define PM3VideoControl_SYNC_MODE_INDEPENDENT		(0 << 16)
	#define PM3VideoControl_SYNC_MODE_SYNCTO_VSA		(1 << 16)
	#define PM3VideoControl_SYNC_MODE_SYNCTO_VSB		(2 << 16)
	#define PM3VideoControl_PATCH_ENABLE			(1 << 18)
	#define PM3VideoControl_PIXELSIZE_8BIT			(0 << 19)
	#define PM3VideoControl_PIXELSIZE_16BIT			(1 << 19)
	#define PM3VideoControl_PIXELSIZE_32BIT			(2 << 19)
	#define PM3VideoControl_DISPLAY_ENABLE			(1 << 21)
	#define PM3VideoControl_PATCH_OFFSET_X(off)	(((off) & 0x3f) << 22)
	#define PM3VideoControl_PATCH_OFFSET_Y(off)	(((off) & 0x3f) << 28)
#define PM3InterruptLine					0x3060
#define PM3DisplayData						0x3068
#define PM3VerticalLineCount					0x3070
#define PM3FifoControl						0x3078
#define PM3ScreenBaseRight					0x3080
#define PM3MiscControl						0x3088

#define PM3VideoOverlayUpdate					0x3100
	#define PM3VideoOverlayUpdate_ENABLE			(1 << 0)
#define PM3VideoOverlayMode					0x3108
	#define PM3VideoOverlayMode_ENABLE			(1 << 0)
	#define PM3VideoOverlayMode_BUFFERSYNC_MANUAL		(0 << 1)
	#define PM3VideoOverlayMode_BUFFERSYNC_VIDEOSTREAMA	(1 << 1)
	#define PM3VideoOverlayMode_BUFFERSYNC_VIDEOSTREAMB	(2 << 1)
	#define PM3VideoOverlayMode_FIELDPOLARITY_NORMAL	(0 << 4)
	#define PM3VideoOverlayMode_FIELDPOLARITY_INVERT	(1 << 4)
	#define PM3VideoOverlayMode_PIXELSIZE_8BIT		(0 << 5)
	#define PM3VideoOverlayMode_PIXELSIZE_16BIT		(1 << 5)
	#define PM3VideoOverlayMode_PIXELSIZE_32BIT		(2 << 5)
	#define PM3VideoOverlayMode_COLORFORMAT_RGB8888		\
					((0 << 7)|(1 << 12)|(2 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_RGB4444		\
					((1 << 7)|(1 << 12)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_RGB5551		\
					((2 << 7)|(1 << 12)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_RGB565		\
					((3 << 7)|(1 << 12)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_RGB332		\
					((4 << 7)|(1 << 12)|(0 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_BGR8888		\
					((0 << 7)|(2 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_BGR4444		\
					((1 << 7)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_BGR5551		\
					((2 << 7)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_BGR565		\
					((3 << 7)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_BGR332		\
					((4 << 7)|(0 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_CI8		\
					((5 << 7)|(1 << 12)|(0 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_VUY444		\
					((2 << 10)|(1 << 12)|(2 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_YUV444		\
					((2 << 10)|(2 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_VUY422		\
					((1 << 10)|(1 << 12)|(1 << 5))
	#define PM3VideoOverlayMode_COLORFORMAT_YUV422		\
					((1 << 10)|(1 << 5))
	#define PM3VideoOverlayMode_COLORORDER_BGR		(0 << 12)
	#define PM3VideoOverlayMode_COLORORDER_RGB		(1 << 12)
	#define PM3VideoOverlayMode_LINEARCOLOREXT_OFF		(0 << 13)
	#define PM3VideoOverlayMode_LINEARCOLOREXT_ON		(1 << 13)
	#define PM3VideoOverlayMode_FILTER_MASK			(3 << 14)
	#define PM3VideoOverlayMode_FILTER_OFF			(0 << 14)
	#define PM3VideoOverlayMode_FILTER_FULL			(1 << 14)
	#define PM3VideoOverlayMode_FILTER_PARTIAL		(2 << 14)
	#define PM3VideoOverlayMode_DEINTERLACE_OFF		(0 << 16)
	#define PM3VideoOverlayMode_DEINTERLACE_BOB		(1 << 16)
	#define PM3VideoOverlayMode_PATCHMODE_OFF		(0 << 18)
	#define PM3VideoOverlayMode_PATCHMODE_ON		(1 << 18)
	#define PM3VideoOverlayMode_FLIP_VIDEO			(0 << 20)
	#define PM3VideoOverlayMode_FLIP_VIDEOSTREAMA		(1 << 20)
	#define PM3VideoOverlayMode_FLIP_VIDEOSTREAMB		(2 << 20)
	#define PM3VideoOverlayMode_MIRROR_MASK			(3 << 23)
	#define PM3VideoOverlayMode_MIRRORX_OFF			(0 << 23)
	#define PM3VideoOverlayMode_MIRRORX_ON			(1 << 23)
	#define PM3VideoOverlayMode_MIRRORY_OFF			(0 << 24)
	#define PM3VideoOverlayMode_MIRRORY_ON			(1 << 24)
#define PM3VideoOverlayFifoControl				0x3110
#define PM3VideoOverlayIndex					0x3118
#define PM3VideoOverlayBase0					0x3120
#define PM3VideoOverlayBase1					0x3128
#define PM3VideoOverlayBase2					0x3130
#define PM3VideoOverlayStride					0x3138
	#define PM3VideoOverlayStride_STRIDE(s)		(((s) & 0xfff) << 0)
#define PM3VideoOverlayWidth					0x3140
	#define PM3VideoOverlayWidth_WIDTH(w)		(((w) & 0xfff) << 0)
#define PM3VideoOverlayHeight					0x3148
	#define PM3VideoOverlayHeight_HEIGHT(h)		(((h) & 0xfff) << 0)
#define PM3VideoOverlayOrigin					0x3150
	#define PM3VideoOverlayOrigin_XORIGIN(x)	(((x) & 0xfff) << 0)
	#define PM3VideoOverlayOrigin_YORIGIN(y)	(((y) & 0xfff) << 16)
#define PM3VideoOverlayShrinkXDelta				0x3158
	#define PM3VideoOverlayShrinkXDelta_NONE		(1 << 16)
	#define PM3VideoOverlayShrinkXDelta_DELTA(s,d)	\
		((((s) << 16)/(d)) & 0x0ffffff0)
#define PM3VideoOverlayZoomXDelta				0x3160
	#define PM3VideoOverlayZoomXDelta_NONE			(1 << 16)
	#define PM3VideoOverlayZoomXDelta_DELTA(s,d)	\
		((((s) << 16)/(d)) & 0x0001fff0)
#define PM3VideoOverlayYDelta					0x3168
	#define PM3VideoOverlayYDelta_NONE			(1 << 16)
	#define PM3VideoOverlayYDelta_DELTA(s,d)	\
		((((s) << 16)/(d)) & 0x0ffffff0)
#define PM3VideoOverlayFieldOffset				0x3170
#define PM3VideoOverlayStatus					0x3178

/**********************************************
*  GLINT Permedia3 RAMDAC Registers (0x4000)  *
***********************************************/
/* Direct Registers */
#define PM3RD_PaletteWriteAddress				0x4000
#define PM3RD_PaletteData					0x4008
#define PM3RD_PixelMask						0x4010
#define PM3RD_PaletteReadAddress				0x4018

#define PM3RD_IndexLow						0x4020
#define PM3RD_IndexHigh						0x4028
#define PM3RD_IndexedData					0x4030
#define PM3RD_IndexControl					0x4038
	#define PM3RD_IndexControl_AUTOINCREMENT_ENABLE		(1 << 0)

/* Indirect Registers */
#define PM3RD_MiscControl					0x000
	#define PM3RD_MiscControl_HIGHCOLOR_RES_ENABLE		(1 << 0)
	#define PM3RD_MiscControl_PIXELDOUBLE_ENABLE		(1 << 1)
	#define PM3RD_MiscControl_LASTREAD_ADDR_ENABLE		(1 << 2)
	#define PM3RD_MiscControl_DIRECTCOLOR_ENABLE		(1 << 3)
	#define PM3RD_MiscControl_OVERLAY_ENABLE		(1 << 4)
	#define PM3RD_MiscControl_PIXELDOUBLE_BUFFER_ENABLE	(1 << 5)
	#define PM3RD_MiscControl_VSB_OUTPUT_ENABLE		(1 << 6)
	#define PM3RD_MiscControl_STEREODOUBLE_BUFFER_ENABLE	(1 << 7)
#define PM3RD_SyncControl					0x001
	#define PM3RD_SyncControl_HSYNC_ACTIVE_LOW		(0 << 0)
	#define PM3RD_SyncControl_HSYNC_ACTIVE_HIGH		(1 << 0)
	#define PM3RD_SyncControl_HSYNC_FORCE_ACTIVE		(3 << 0)
	#define PM3RD_SyncControl_HSYNC_FORCE_INACTIVE		(4 << 0)
	#define PM3RD_SyncControl_HSYNC_TRI_STATE		(2 << 0)
	#define PM3RD_SyncControl_VSYNC_ACTIVE_LOW		(0 << 3)
	#define PM3RD_SyncControl_VSYNC_ACTIVE_HIGH		(1 << 3)
	#define PM3RD_SyncControl_VSYNC_TRI_STATE		(2 << 3)
	#define PM3RD_SyncControl_VSYNC_FORCE_ACTIVE		(3 << 3)
	#define PM3RD_SyncControl_VSYNC_FORCE_INACTIVE		(4 << 3)
	#define PM3RD_SyncControl_HSYNC_OVERRIDE_SETBY_HSYNC	(0 << 6)
	#define PM3RD_SyncControl_HSYNC_OVERRIDE_FORCE_HIGH	(1 << 6)
	#define PM3RD_SyncControl_VSYNC_OVERRIDE_SETBY_VSYNC	(0 << 7)
	#define PM3RD_SyncControl_VSYNC_OVERRIDE_FORCE_HIGH	(1 << 7)
#define PM3RD_DACControl					0x002
	#define PM3RD_DACControl_DAC_POWER_ON			(0 << 0)
	#define PM3RD_DACControl_DAC_POWER_OFF			(1 << 0)
	#define PM3RD_DACControl_SYNC_ON_GREEN_ENABLE		(1 << 3)
	#define PM3RD_DACControl_BLANK_RED_DAC_ENABLE		(1 << 4)
	#define PM3RD_DACControl_BLANK_GREEN_DAC_ENABLE		(1 << 5)
	#define PM3RD_DACControl_BLANK_BLUE_DAC_ENABLE		(1 << 6)
	#define PM3RD_DACControl_BLANK_PEDESTAL_ENABLE		(1 << 7)
#define PM3RD_PixelSize						0x003
	#define PM3RD_PixelSize_24_BIT_PIXELS			(4 << 0)
	#define PM3RD_PixelSize_32_BIT_PIXELS			(2 << 0)
	#define PM3RD_PixelSize_16_BIT_PIXELS			(1 << 0)
	#define PM3RD_PixelSize_8_BIT_PIXELS			(0 << 0)
#define PM3RD_ColorFormat					0x004
	#define PM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE	(1 << 6)
	#define PM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW		(1 << 5)
	#define PM3RD_ColorFormat_COLOR_ORDER_RED_LOW		(0 << 5)
	#define PM3RD_ColorFormat_COLOR_FORMAT_MASK		(0x1f << 0)
	#define PM3RD_ColorFormat_8888_COLOR			(0 << 0)
	#define PM3RD_ColorFormat_5551_FRONT_COLOR		(1 << 0)
	#define PM3RD_ColorFormat_4444_COLOR			(2 << 0)
	#define PM3RD_ColorFormat_332_FRONT_COLOR		(5 << 0)
	#define PM3RD_ColorFormat_332_BACK_COLOR		(6 << 0)
	#define PM3RD_ColorFormat_2321_FRONT_COLOR		(9 << 0)
	#define PM3RD_ColorFormat_2321_BACK_COLOR		(10 << 0)
	#define PM3RD_ColorFormat_232_FRONTOFF_COLOR		(11 << 0)
	#define PM3RD_ColorFormat_232_BACKOFF_COLOR		(12 << 0)
	#define PM3RD_ColorFormat_5551_BACK_COLOR		(13 << 0)
	#define PM3RD_ColorFormat_CI8_COLOR			(14 << 0)
	#define PM3RD_ColorFormat_565_FRONT_COLOR		(16 << 0)
	#define PM3RD_ColorFormat_565_BACK_COLOR		(17 << 0)
#define PM3RD_CursorMode					0x005
	#define PM3RD_CursorMode_CURSOR_ENABLE			(1 << 0)
	#define PM3RD_CursorMode_FORMAT_64x64_2BPE_P0123	(0 << 2)
	#define PM3RD_CursorMode_FORMAT_32x32_2BPE_P0		(1 << 2)
	#define PM3RD_CursorMode_FORMAT_32x32_2BPE_P1		(2 << 2)
	#define PM3RD_CursorMode_FORMAT_32x32_2BPE_P2		(3 << 2)
	#define PM3RD_CursorMode_FORMAT_32x32_2BPE_P3		(4 << 2)
	#define PM3RD_CursorMode_FORMAT_32x32_4BPE_P01		(5 << 2)
	#define PM3RD_CursorMode_FORMAT_32x32_4BPE_P23		(6 << 2)
	#define PM3RD_CursorMode_TYPE_MS			(0 << 4)
	#define PM3RD_CursorMode_TYPE_X				(1 << 4)
	#define PM3RD_CursorMode_REVERSE_PIXEL_ORDER_ENABLE	(1 << 6)
	#define PM3RD_CursorMode_REVERSE_PIXEL_ORDER_3_COLOR	(2 << 6)
	#define PM3RD_CursorMode_REVERSE_PIXEL_ORDER_15_COLOR	(3 << 6)
#define PM3RD_CursorControl					0x006
	#define PM3RD_CursorControl_DOUBLE_X_ENABLED		(1 << 0)
	#define PM3RD_CursorControl_DOUBLE_Y_ENABLED		(1 << 1)
	#define PM3RD_CursorControl_READBACK_POS_ENABLED	(1 << 2)

#define PM3RD_CursorXLow					0x007
#define PM3RD_CursorXHigh					0x008
#define PM3RD_CursorYLow					0x009
#define PM3RD_CursorYHigh					0x00a
#define PM3RD_CursorHotSpotX					0x00b
#define PM3RD_CursorHotSpotY					0x00c
#define PM3RD_OverlayKey					0x00d
#define PM3RD_Pan						0x00e
	#define PM3RD_Pan_ENABLE				(1 << 0)
	#define PM3RD_Pan_GATE_ENABLE				(1 << 1)
#define PM3RD_Sense						0x00f

#define PM3RD_CheckControl					0x018
	#define PM3RD_CheckControl_PIXEL_ENABLED		(1 << 0)
	#define PM3RD_CheckControl_LUT_ENABLED			(1 << 1)
#define PM3RD_CheckPixelRed					0x019
#define PM3RD_CheckPixelGreen					0x01a
#define PM3RD_CheckPixelBlue					0x01b
#define PM3RD_CheckLUTRed					0x01c
#define PM3RD_CheckLUTGreen					0x01d
#define PM3RD_CheckLUTBlue					0x01e
#define PM3RD_Scratch						0x01f

#define PM3RD_VideoOverlayControl				0x020
	#define PM3RD_VideoOverlayControl_ENABLE		(1 << 0)
	#define PM3RD_VideoOverlayControl_MODE_MASK		(3 << 1)
	#define PM3RD_VideoOverlayControl_MODE_MAINKEY		(0 << 1)
	#define PM3RD_VideoOverlayControl_MODE_OVERLAYKEY	(1 << 1)
	#define PM3RD_VideoOverlayControl_MODE_ALWAYS		(2 << 1)
	#define PM3RD_VideoOverlayControl_MODE_BLEND		(3 << 1)
	#define PM3RD_VideoOverlayControl_DIRECTCOLOR_ENABLED	(1 << 3)
	#define PM3RD_VideoOverlayControl_BLENDSRC_MAIN		(0 << 4)
	#define PM3RD_VideoOverlayControl_BLENDSRC_REGISTER	(1 << 4)
	#define PM3RD_VideoOverlayControl_KEY_COLOR		(0 << 5)
	#define PM3RD_VideoOverlayControl_KEY_ALPHA		(1 << 5)
#define PM3RD_VideoOverlayXStartLow				0x021
#define PM3RD_VideoOverlayXStartHigh				0x022
#define PM3RD_VideoOverlayYStartLow				0x023
#define PM3RD_VideoOverlayYStartHigh				0x024
#define PM3RD_VideoOverlayXEndLow				0x025
#define PM3RD_VideoOverlayXEndHigh				0x026
#define PM3RD_VideoOverlayYEndLow				0x027
#define PM3RD_VideoOverlayYEndHigh				0x028
#define PM3RD_VideoOverlayKeyR					0x029
#define PM3RD_VideoOverlayKeyG					0x02a
#define PM3RD_VideoOverlayKeyB					0x02b
#define PM3RD_VideoOverlayBlend					0x02c
	#define PM3RD_VideoOverlayBlend_FACTOR_0_PERCENT	(0 << 6)
	#define PM3RD_VideoOverlayBlend_FACTOR_25_PERCENT	(1 << 6)
	#define PM3RD_VideoOverlayBlend_FACTOR_75_PERCENT	(2 << 6)
	#define PM3RD_VideoOverlayBlend_FACTOR_100_PERCENT	(3 << 6)

#define PM3RD_DClkSetup1					0x1f0
#define PM3RD_DClkSetup2					0x1f1
#define PM3RD_KClkSetup1					0x1f2
#define PM3RD_KClkSetup2					0x1f3

#define PM3RD_DClkControl					0x200
	#define PM3RD_DClkControl_SOURCE_PLL			(0 << 4)
	#define PM3RD_DClkControl_SOURCE_VSA			(1 << 4)
	#define PM3RD_DClkControl_SOURCE_VSB			(2 << 4)
	#define PM3RD_DClkControl_SOURCE_EXT			(3 << 4)
	#define PM3RD_DClkControl_STATE_RUN			(2 << 2)
	#define PM3RD_DClkControl_STATE_HIGH			(1 << 2)
	#define PM3RD_DClkControl_STATE_LOW			(0 << 2)
	#define PM3RD_DClkControl_LOCKED			(1 << 1)
	#define PM3RD_DClkControl_NOT_LOCKED			(0 << 1)
	#define PM3RD_DClkControl_ENABLE			(1 << 0)
#define PM3RD_DClk0PreScale					0x201
#define PM3RD_DClk0FeedbackScale				0x202
#define PM3RD_DClk0PostScale					0x203
	#define PM3_REF_CLOCK					14318
#define PM3RD_DClk1PreScale					0x204
#define PM3RD_DClk1FeedbackScale				0x205
#define PM3RD_DClk1PostScale					0x206
#define PM3RD_DClk2PreScale					0x207
#define PM3RD_DClk2FeedbackScale				0x208
#define PM3RD_DClk2PostScale					0x209
#define PM3RD_DClk3PreScale					0x20a
#define PM3RD_DClk3FeedbackScale				0x20b
#define PM3RD_DClk3PostScale					0x20c
#define PM3RD_KClkControl					0x20d
	#define PM3RD_KClkControl_ENABLE			(1 << 0)
	#define PM3RD_KClkControl_NOT_LOCKED			(0 << 1)
	#define PM3RD_KClkControl_LOCKED			(1 << 1)
	#define PM3RD_KClkControl_STATE_LOW			(0 << 2)
	#define PM3RD_KClkControl_STATE_HIGH			(1 << 2)
	#define PM3RD_KClkControl_STATE_RUN			(2 << 2)
	#define PM3RD_KClkControl_STATE_LOW_POWER		(3 << 2)
	#define PM3RD_KClkControl_SOURCE_PCLK			(0 << 4)
	#define PM3RD_KClkControl_SOURCE_HALF_PCLK		(1 << 4)
	#define PM3RD_KClkControl_SOURCE_PLL			(2 << 4)
#define PM3RD_KClkPreScale					0x20e
#define PM3RD_KClkFeedbackScale					0x20f
#define PM3RD_KClkPostScale					0x210
#define PM3RD_MClkControl					0x211
	#define PM3RD_MClkControl_ENABLE			(1 << 0)
	#define PM3RD_MClkControl_NOT_LOCKED			(0 << 1)
	#define PM3RD_MClkControl_LOCKED			(1 << 1)
	#define PM3RD_MClkControl_STATE_LOW			(0 << 2)
	#define PM3RD_MClkControl_STATE_HIGH			(1 << 2)
	#define PM3RD_MClkControl_STATE_RUN			(2 << 2)
	#define PM3RD_MClkControl_STATE_LOW_POWER		(3 << 2)
	#define PM3RD_MClkControl_SOURCE_PCLK			(0 << 4)
	#define PM3RD_MClkControl_SOURCE_HALF_PCLK		(1 << 4)
	#define PM3RD_MClkControl_SOURCE_HALF_EXT		(3 << 4)
	#define PM3RD_MClkControl_SOURCE_EXT			(4 << 4)
	#define PM3RD_MClkControl_SOURCE_HALF_KCLK		(5 << 4)
	#define PM3RD_MClkControl_SOURCE_KCLK			(6 << 4)
#define PM3RD_MClkPreScale					0x212
#define PM3RD_MClkFeedbackScale					0x213
#define PM3RD_MClkPostScale					0x214
#define PM3RD_SClkControl					0x215
	#define PM3RD_SClkControl_ENABLE			(1 << 0)
	#define PM3RD_SClkControl_NOT_LOCKED			(0 << 1)
	#define PM3RD_SClkControl_LOCKED			(1 << 1)
	#define PM3RD_SClkControl_STATE_LOW			(0 << 2)
	#define PM3RD_SClkControl_STATE_HIGH			(1 << 2)
	#define PM3RD_SClkControl_STATE_RUN			(2 << 2)
	#define PM3RD_SClkControl_STATE_LOW_POWER		(3 << 2)
	#define PM3RD_SClkControl_SOURCE_PCLK			(0 << 4)
	#define PM3RD_SClkControl_SOURCE_HALF_PCLK		(1 << 4)
	#define PM3RD_SClkControl_SOURCE_HALF_EXT		(3 << 4)
	#define PM3RD_SClkControl_SOURCE_EXT			(4 << 4)
	#define PM3RD_SClkControl_SOURCE_HALF_KCLK		(5 << 4)
	#define PM3RD_SClkControl_SOURCE_KCLK			(6 << 4)
#define PM3RD_SClkPreScale					0x216
#define PM3RD_SClkFeedbackScale					0x217
#define PM3RD_SClkPostScale					0x218

#define PM3RD_CursorPalette(p)				(0x303 + (p))
#define PM3RD_CursorPattern(p)				(0x400 + (p))
/******************************************************
*  GLINT Permedia3 Video Streaming Registers (0x5000) *
*******************************************************/

#define PM3VSConfiguration					0x5800

/**********************************************
*  GLINT Permedia3 Core Registers (0x8000+)   *
***********************************************/
#define PM3AALineWidth						0x94c0
#define PM3AAPointsize						0x94a0
#define PM3AlphaBlendAlphaMode					0xafa8
#define PM3AlphaBlendAlphaModeAnd				0xad30
#define PM3AlphaBlendAlphaModeOr				0xad38
#define PM3AlphaBlendColorMode					0xafa0
#define PM3AlphaBlendColorModeAnd				0xacb0
#define PM3AlphaBlendColorModeOr				0xacb8
#define PM3AlphaDestColor					0xaf88
#define PM3AlphaSourceColor					0xaf80
#define PM3AlphaTestMode					0x8800
#define PM3AlphaTestModeAnd					0xabf0
#define PM3AlphaTestModeOr					0xabf8
#define PM3AntialiasMode					0x8808
#define PM3AntialiasModeAnd					0xac00
#define PM3AntialiasModeOr					0xac08
/* ... */
#define PM3BackgroundColor					0xb0c8
/* ... */
#define PM3ColorDDAMode						0x87e0
#define PM3ColorDDAModeAnd					0xabe0
#define PM3ColorDDAModeOr					0xabe8
#define PM3CommandInterrupt					0xa990
#define PM3ConstantColorDDA					0xafb0
	#define PM3ConstantColorDDA_R(r)		((r) & 0xff)
	#define PM3ConstantColorDDA_G(g)		(((g) & 0xff) << 8)
	#define PM3ConstantColorDDA_B(b)		(((b) & 0xff) << 16)
	#define PM3ConstantColorDDA_A(a)		(((a) & 0xff) << 24)
#define PM3ContextData						0x8dd0
#define PM3ContextDump						0x8dc0
#define PM3ContextRestore					0x8dc8
#define PM3Continue						0x8058
#define PM3ContinueNewDom					0x8048
#define PM3ContinueNewLine					0x8040
#define PM3ContinueNewSub					0x8050
#define PM3Count						0x8030
/* ... */
#define PM3DeltaControl						0x9350
#define PM3DeltaControlAnd					0xab20
#define PM3DeltaControlOr					0xab28
#define PM3DeltaMode						0x9300
#define PM3DeltaModeAnd						0xaad0
#define PM3DeltaModeOr						0xaad8
/* ... */
#define PM3DitherMode						0x8818
#define PM3DitherModeAnd					0xacd0
#define PM3DitherModeOr						0xacd8
/* ... */
#define PM3dXDom						0x8008
#define PM3dXSub						0x8018
#define PM3dY							0x8028
/* ... */
#define PM3FBBlockColor						0x8ac8
#define PM3FBBlockColor0					0xb060
#define PM3FBBlockColor1					0xb068
#define PM3FBBlockColor2					0xb070
#define PM3FBBlockColor3					0xb078
#define PM3FBBlockColorBack					0xb0a0
#define PM3FBBlockColorBack0					0xb080
#define PM3FBBlockColorBack1					0xb088
#define PM3FBBlockColorBack2					0xb090
#define PM3FBBlockColorBack3					0xb098
#define PM3FBColor						0x8a98
#define PM3FBDestReadBufferAddr0				0xae80
#define PM3FBDestReadBufferAddr1				0xae88
#define PM3FBDestReadBufferAddr2				0xae90
#define PM3FBDestReadBufferAddr3				0xae98
#define PM3FBDestReadBufferOffset0				0xaea0
#define PM3FBDestReadBufferOffset1				0xaea8
#define PM3FBDestReadBufferOffset2				0xaeb0
#define PM3FBDestReadBufferOffset3				0xaeb8
	#define PM3FBDestReadBufferOffset_XOffset(x)	((x) & 0xffff)
	#define PM3FBDestReadBufferOffset_YOffset(y)	(((y) & 0xffff) << 16)
#define PM3FBDestReadBufferWidth0				0xaec0
#define PM3FBDestReadBufferWidth1				0xaec8
#define PM3FBDestReadBufferWidth2				0xaed0
#define PM3FBDestReadBufferWidth3				0xaed8
	#define PM3FBDestReadBufferWidth_Width(w)	((w) & 0x0fff)

#define PM3FBDestReadEnables					0xaee8
#define PM3FBDestReadEnablesAnd					0xad20
#define PM3FBDestReadEnablesOr					0xad28
	#define PM3FBDestReadEnables_E(e)		((e) & 0xff)
	#define PM3FBDestReadEnables_E0				(1 << 0)
	#define PM3FBDestReadEnables_E1				(1 << 1)
	#define PM3FBDestReadEnables_E2				(1 << 2)
	#define PM3FBDestReadEnables_E3				(1 << 3)
	#define PM3FBDestReadEnables_E4				(1 << 4)
	#define PM3FBDestReadEnables_E5				(1 << 5)
	#define PM3FBDestReadEnables_E6				(1 << 6)
	#define PM3FBDestReadEnables_E7				(1 << 7)
	#define PM3FBDestReadEnables_R(r)		(((r) & 0xff) << 8)
	#define PM3FBDestReadEnables_R0				(1 << 8)
	#define PM3FBDestReadEnables_R1				(1 << 9)
	#define PM3FBDestReadEnables_R2				(1 << 10)
	#define PM3FBDestReadEnables_R3				(1 << 11)
	#define PM3FBDestReadEnables_R4				(1 << 12)
	#define PM3FBDestReadEnables_R5				(1 << 13)
	#define PM3FBDestReadEnables_R6				(1 << 14)
	#define PM3FBDestReadEnables_R7				(1 << 15)
	#define PM3FBDestReadEnables_ReferenceAlpha(a)	(((a) & 0xff) << 24)

#define PM3FBDestReadMode					0xaee0
#define PM3FBDestReadModeAnd					0xac90
#define PM3FBDestReadModeOr					0xac98
	#define PM3FBDestReadMode_ReadDisable			(0 << 0)
	#define PM3FBDestReadMode_ReadEnable			(1 << 0)
	#define PM3FBDestReadMode_StripePitch(sp)	(((sp) & 0x7) << 2)
	#define PM3FBDestReadMode_StripeHeight(sh)	(((sh) & 0x7) << 7)
	#define PM3FBDestReadMode_Enable0			(1 << 8)
	#define PM3FBDestReadMode_Enable1			(1 << 9)
	#define PM3FBDestReadMode_Enable2			(1 << 10)
	#define PM3FBDestReadMode_Enable3			(1 << 11)
	#define PM3FBDestReadMode_Layout0(l)		(((l) & 0x3) << 12)
	#define PM3FBDestReadMode_Layout1(l)		(((l) & 0x3) << 14)
	#define PM3FBDestReadMode_Layout2(l)		(((l) & 0x3) << 16)
	#define PM3FBDestReadMode_Layout3(l)		(((l) & 0x3) << 18)
	#define PM3FBDestReadMode_Origin0			(1 << 20)
	#define PM3FBDestReadMode_Origin1			(1 << 21)
	#define PM3FBDestReadMode_Origin2			(1 << 22)
	#define PM3FBDestReadMode_Origin3			(1 << 23)
	#define PM3FBDestReadMode_Blocking			(1 << 24)
	#define PM3FBDestReadMode_UseReadEnabled		(1 << 26)
	#define PM3FBDestReadMode_AlphaFiltering		(1 << 27)

#define PM3FBHardwareWriteMask					0x8ac0
#define PM3FBSoftwareWriteMask					0x8820
#define PM3FBData						0x8aa0
#define PM3FBSourceData						0x8aa8
#define PM3FBSourceReadBufferAddr				0xaf08
#define PM3FBSourceReadBufferOffset				0xaf10
	#define PM3FBSourceReadBufferOffset_XOffset(x)	((x) & 0xffff)
	#define PM3FBSourceReadBufferOffset_YOffset(y)	(((y) & 0xffff) << 16)
#define PM3FBSourceReadBufferWidth				0xaf18
	#define PM3FBSourceReadBufferWidth_Width(w)	((w) & 0x0fff)
#define PM3FBSourceReadMode					0xaf00
#define PM3FBSourceReadModeAnd					0xaca0
#define PM3FBSourceReadModeOr					0xaca8
	#define PM3FBSourceReadMode_ReadDisable			(0 << 0)
	#define PM3FBSourceReadMode_ReadEnable			(1 << 0)
	#define PM3FBSourceReadMode_StripePitch(sp)	(((sp) & 0x7) << 2)
	#define PM3FBSourceReadMode_StripeHeight(sh)	(((sh) & 0x7) << 7)
	#define PM3FBSourceReadMode_Layout(l)		(((l) & 0x3) << 8)
	#define PM3FBSourceReadMode_Origin			(1 << 10)
	#define PM3FBSourceReadMode_Blocking			(1 << 11)
	#define PM3FBSourceReadMode_UserTexelCoord		(1 << 13)
	#define PM3FBSourceReadMode_WrapXEnable			(1 << 14)
	#define PM3FBSourceReadMode_WrapYEnable			(1 << 15)
	#define PM3FBSourceReadMode_WrapX(w)		(((w) & 0xf) << 16)
	#define PM3FBSourceReadMode_WrapY(w)		(((w) & 0xf) << 20)
	#define PM3FBSourceReadMode_ExternalSourceData		(1 << 24)
#define PM3FBWriteBufferAddr0					0xb000
#define PM3FBWriteBufferAddr1					0xb008
#define PM3FBWriteBufferAddr2					0xb010
#define PM3FBWriteBufferAddr3					0xb018

#define PM3FBWriteBufferOffset0					0xb020
#define PM3FBWriteBufferOffset1					0xb028
#define PM3FBWriteBufferOffset2					0xb030
#define PM3FBWriteBufferOffset3					0xb038
	#define PM3FBWriteBufferOffset_XOffset(x)	((x) & 0xffff)
	#define PM3FBWriteBufferOffset_YOffset(y)	(((y) & 0xffff) << 16)

#define PM3FBWriteBufferWidth0					0xb040
#define PM3FBWriteBufferWidth1					0xb048
#define PM3FBWriteBufferWidth2					0xb050
#define PM3FBWriteBufferWidth3					0xb058
	#define PM3FBWriteBufferWidth_Width(w)		((w) & 0x0fff)

#define PM3FBWriteMode						0x8ab8
#define PM3FBWriteModeAnd					0xacf0
#define PM3FBWriteModeOr					0xacf8
	#define PM3FBWriteMode_WriteDisable			(0 << 0)
	#define PM3FBWriteMode_WriteEnable			(1 << 0)
	#define PM3FBWriteMode_Replicate			(1 << 4)
	#define PM3FBWriteMode_OpaqueSpan			(1 << 5)
	#define PM3FBWriteMode_StripePitch(p)		(((p) & 0x7) << 6)
	#define PM3FBWriteMode_StripeHeight(h)		(((h) & 0x7) << 9)
	#define PM3FBWriteMode_Enable0				(1 << 12)
	#define PM3FBWriteMode_Enable1				(1 << 13)
	#define PM3FBWriteMode_Enable2				(1 << 14)
	#define PM3FBWriteMode_Enable3				(1 << 15)
	#define PM3FBWriteMode_Layout0(l)		(((l) & 0x3) << 16)
	#define PM3FBWriteMode_Layout1(l)		(((l) & 0x3) << 18)
	#define PM3FBWriteMode_Layout2(l)		(((l) & 0x3) << 20)
	#define PM3FBWriteMode_Layout3(l)		(((l) & 0x3) << 22)
	#define PM3FBWriteMode_Origin0				(1 << 24)
	#define PM3FBWriteMode_Origin1				(1 << 25)
	#define PM3FBWriteMode_Origin2				(1 << 26)
	#define PM3FBWriteMode_Origin3				(1 << 27)
#define PM3ForegroundColor					0xb0c0
/* ... */
#define PM3GIDMode						0xb538
#define PM3GIDModeAnd						0xb5b0
#define PM3GIDModeOr						0xb5b8
/* ... */
#define PM3LBDestReadBufferAddr					0xb510
#define PM3LBDestReadBufferOffset				0xb518
#define PM3LBDestReadEnables					0xb508
#define PM3LBDestReadEnablesAnd					0xb590
#define PM3LBDestReadEnablesOr					0xb598
#define PM3LBDestReadMode					0xb500
#define PM3LBDestReadModeAnd					0xb580
#define PM3LBDestReadModeOr					0xb588
	#define PM3LBDestReadMode_Disable			(0 << 0)
	#define PM3LBDestReadMode_Enable			(1 << 0)
	#define PM3LBDestReadMode_StripePitch(p)	(((p) & 0x7) << 2)
	#define PM3LBDestReadMode_StripeHeight(h)	(((h) & 0x7) << 5)
	#define PM3LBDestReadMode_Layout			(1 << 8)
	#define PM3LBDestReadMode_Origin			(1 << 9)
	#define PM3LBDestReadMode_UserReadEnables		(1 << 10)
	#define PM3LBDestReadMode_Packed16			(1 << 11)
	#define PM3LBDestReadMode_Width(w)		(((w) & 0xfff) << 12)
#define PM3LBReadFormat						0x8888
	#define PM3LBReadFormat_DepthWidth(w)		(((w) & 0x3) << 0)
	#define PM3LBReadFormat_StencilWidth(w)		(((w) & 0xf) << 2)
	#define PM3LBReadFormat_StencilPosition(p)	(((p) & 0x1f) << 6)
	#define PM3LBReadFormat_FCPWidth(w)		(((w) & 0xf) << 11)
	#define PM3LBReadFormat_FCPPosition(p)		(((p) & 0x1f) << 15)
	#define PM3LBReadFormat_GIDWidth(w)		(((w) & 0x7) << 20)
	#define PM3LBReadFormat_GIDPosition(p)		(((p) & 0x1f) << 23)
#define PM3LBSourceReadBufferAddr				0xb528
#define PM3LBSourceReadBufferOffset				0xb530
#define PM3LBSourceReadMode					0xb520
#define PM3LBSourceReadModeAnd					0xb5a0
#define PM3LBSourceReadModeOr					0xb5a8
	#define PM3LBSourceReadMode_Enable			(1 << 0)
	#define PM3LBSourceReadMode_StripePitch(p)	(((p) & 0x7) << 2)
	#define PM3LBSourceReadMode_StripeHeight(h)	(((h) & 0x7) << 5)
	#define PM3LBSourceReadMode_Layout			(1 << 8)
	#define PM3LBSourceReadMode_Origin			(1 << 9)
	#define PM3LBSourceReadMode_Packed16			(1 << 10)
	#define PM3LBSourceReadMode_Width(w)		(((w) & 0xfff) << 11)
#define PM3LBStencil						0x88a8
#define PM3LBWriteBufferAddr					0xb540
#define PM3LBWriteBufferOffset					0xb548
#define PM3LBWriteFormat					0x88c8
	#define PM3LBWriteFormat_DepthWidth(w)		(((w) & 0x3) << 0)
	#define PM3LBWriteFormat_StencilWidth(w)	(((w) & 0xf) << 2)
	#define PM3LBWriteFormat_StencilPosition(p)	(((p) & 0x1f) << 6)
	#define PM3LBWriteFormat_GIDWidth(w)		(((w) & 0x7) << 20)
	#define PM3LBWriteFormat_GIDPosition(p)		(((p) & 0x1f) << 23)
#define PM3LBWriteMode						0x88c0
#define PM3LBWriteModeAnd					0xac80
#define PM3LBWriteModeOr					0xac88
	#define PM3LBWriteMode_WriteDisable			(0 << 0)
	#define PM3LBWriteMode_WriteEnable			(1 << 0)
	#define PM3LBWriteMode_StripePitch(p)		(((p) & 0x7) << 3)
	#define PM3LBWriteMode_StripeHeight(h)		(((h) & 0x7) << 6)
	#define PM3LBWriteMode_Layout				(1 << 9)
	#define PM3LBWriteMode_Origin				(1 << 10)
	#define PM3LBWriteMode_Packed16				(1 << 11)
	#define PM3LBWriteMode_Width(w)			(((w) & 0xfff) << 12)
/* ... */
#define PM3LineStippleMode					0x81a8
#define PM3LineStippleModeAnd					0xabc0
#define PM3LineStippleModeOr					0xabc8
#define PM3LoadLineStippleCounters				0x81b0
/* ... */
#define PM3LogicalOpMode					0x8828
#define PM3LogicalOpModeAnd					0xace0
#define PM3LogicalOpModeOr					0xace8
	#define PM3LogicalOpMode_Disable			(0 << 0)
	#define PM3LogicalOpMode_Enable				(1 << 0)
	#define PM3LogicalOpMode_LogicOp(op)		(((op) & 0xf) << 1)
	#define PM3LogicalOpMode_UseConstantWriteData_Disable	(0 << 5)
	#define PM3LogicalOpMode_UseConstantWriteData_Enable	(1 << 5)
	#define PM3LogicalOpMode_Background_Disable		(0 << 6)
	#define PM3LogicalOpMode_Background_Enable		(1 << 6)
	#define PM3LogicalOpMode_Background_LogicOp(op)	(((op) & 0xf) << 7)
	#define PM3LogicalOpMode_UseConstantSource_Disable	(0 << 11)
	#define PM3LogicalOpMode_UseConstantSource_Enable	(1 << 11)
/* ... */
#define PM3LUT							0x8e80
#define PM3LUTAddress						0x84d0
#define PM3LUTData						0x84c8
#define PM3LUTIndex						0x84c0
#define PM3LUTMode						0xb378
#define PM3LUTModeAnd						0xad70
#define PM3LUTModeOr						0xad78
#define PM3LUTTransfer						0x84d8
/* ... */
#define PM3PixelSize						0x80c0
	#define PM3PixelSize_GLOBAL_32BIT			(0 << 0)
	#define PM3PixelSize_GLOBAL_16BIT			(1 << 0)
	#define PM3PixelSize_GLOBAL_8BIT			(2 << 0)
	#define PM3PixelSize_RASTERIZER_32BIT			(0 << 2)
	#define PM3PixelSize_RASTERIZER_16BIT			(1 << 2)
	#define PM3PixelSize_RASTERIZER_8BIT			(2 << 2)
	#define PM3PixelSize_SCISSOR_AND_STIPPLE_32BIT		(0 << 4)
	#define PM3PixelSize_SCISSOR_AND_STIPPLE_16BIT		(1 << 4)
	#define PM3PixelSize_SCISSOR_AND_STIPPLE_8BIT		(2 << 4)
	#define PM3PixelSize_TEXTURE_32BIT			(0 << 6)
	#define PM3PixelSize_TEXTURE_16BIT			(1 << 6)
	#define PM3PixelSize_TEXTURE_8BIT			(2 << 6)
	#define PM3PixelSize_LUT_32BIT				(0 << 8)
	#define PM3PixelSize_LUT_16BIT				(1 << 8)
	#define PM3PixelSize_LUT_8BIT				(2 << 8)
	#define PM3PixelSize_FRAMEBUFFER_32BIT			(0 << 10)
	#define PM3PixelSize_FRAMEBUFFER_16BIT			(1 << 10)
	#define PM3PixelSize_FRAMEBUFFER_8BIT			(2 << 10)
	#define PM3PixelSize_LOGICAL_OP_32BIT			(0 << 12)
	#define PM3PixelSize_LOGICAL_OP_16BIT			(1 << 12)
	#define PM3PixelSize_LOGICAL_OP_8BIT			(2 << 12)
	#define PM3PixelSize_LOCALBUFFER_32BIT			(0 << 14)
	#define PM3PixelSize_LOCALBUFFER_16BIT			(1 << 14)
	#define PM3PixelSize_LOCALBUFFER_8BIT			(2 << 14)
	#define PM3PixelSize_SETUP_32BIT			(0 << 16)
	#define PM3PixelSize_SETUP_16BIT			(1 << 16)
	#define PM3PixelSize_SETUP_8BIT				(2 << 16)
	#define PM3PixelSize_GLOBAL				(0 << 31)
	#define PM3PixelSize_INDIVIDUAL				(1 << 31)
/* ... */
#define PM3Render						0x8038
	#define PM3Render_AreaStipple_Disable			(0 << 0)
	#define PM3Render_AreaStipple_Enable			(1 << 0)
	#define PM3Render_LineStipple_Disable			(0 << 1)
	#define PM3Render_LineStipple_Enable			(1 << 1)
	#define PM3Render_ResetLine_Disable			(0 << 2)
	#define PM3Render_ResetLine_Enable			(1 << 2)
	#define PM3Render_FastFill_Disable			(0 << 3)
	#define PM3Render_FastFill_Enable			(1 << 3)
	#define PM3Render_Primitive_Line			(0 << 6)
	#define PM3Render_Primitive_Trapezoid			(1 << 6)
	#define PM3Render_Primitive_Point			(2 << 6)
	#define PM3Render_Antialias_Disable			(0 << 8)
	#define PM3Render_Antialias_Enable			(1 << 8)
	#define PM3Render_Antialias_SubPixelRes_4x4		(0 << 9)
	#define PM3Render_Antialias_SubPixelRes_8x8		(1 << 9)
	#define PM3Render_UsePointTable_Disable			(0 << 10)
	#define PM3Render_UsePointTable_Enable			(1 << 10)
	#define PM3Render_SyncOnbitMask_Disable			(0 << 11)
	#define PM3Render_SyncOnBitMask_Enable			(1 << 11)
	#define PM3Render_SyncOnHostData_Disable		(0 << 12)
	#define PM3Render_SyncOnHostData_Enable			(1 << 12)
	#define PM3Render_Texture_Disable			(0 << 13)
	#define PM3Render_Texture_Enable			(1 << 13)
	#define PM3Render_Fog_Disable				(0 << 14)
	#define PM3Render_Fog_Enable				(1 << 14)
	#define PM3Render_Coverage_Disable			(0 << 15)
	#define PM3Render_Coverage_Enable			(1 << 15)
	#define PM3Render_SubPixelCorrection_Disable		(0 << 16)
	#define PM3Render_SubPixelCorrection_Enable		(1 << 16)
	#define PM3Render_SpanOperation_Disable			(0 << 18)
	#define PM3Render_SpanOperation_Enable			(1 << 18)
	#define PM3Render_FBSourceRead_Disable			(0 << 27)
	#define PM3Render_FBSourceRead_Enable			(1 << 27)
#define PM3RasterizerMode					0x80a0
#define PM3RasterizerModeAnd					0xaba0
#define PM3RasterizerModeOr					0xaba8
#define PM3RectangleHeight					0x94e0
#define PM3RepeatLine						0x9328
#define PM3ResetPickResult					0x8c20
#define PM3RLEMask						0x8c48
#define PM3RouterMode						0x8840
#define PM3RStart						0x8780
#define PM3S1Start						0x8400
#define PM3aveLineStippleCounters				0x81c0
#define PM3ScissorMaxXY						0x8190
#define PM3ScissorMinXY						0x8188
#define PM3ScissorMode						0x8180
#define PM3ScissorModeAnd					0xabb0
#define PM3ScissorModeOr					0xabb8
#define PM3ScreenSize						0x8198
#define PM3Security						0x8908
#define PM3SetLogicalTexturePage				0xb360
#define PM3SizeOfFramebuffer					0xb0a8
#define PM3SStart						0x8388
#define PM3StartXDom						0x8000
#define PM3StartXSub						0x8010
#define PM3StartY						0x8020
/* ... */
#define PM3SpanColorMask					0x8168
/* ... */
#define PM3TextureApplicationMode				0x8680
#define PM3TextureApplicationModeAnd				0xac50
#define PM3TextureApplicationModeOr				0xac58
#define PM3TextureBaseAddr					0x8500
#define PM3TextureCacheControl					0x8490
#define PM3TextureChromaLower0					0x84f0
#define PM3TextureChromaLower1					0x8608
#define PM3TextureChromaUpper0					0x84e8
#define PM3TextureChromaUpper1					0x8600
#define PM3TextureCompositeAlphaMode0				0xb310
#define PM3TextureCompositeAlphaMode0And			0xb390
#define PM3TextureCompositeAlphaMode0Or				0xb398
#define PM3TextureCompositeAlphaMode1				0xb320
#define PM3TextureCompositeAlphaMode1And			0xb3b0
#define PM3TextureCompositeAlphaMode1Or				0xb3b8
#define PM3TextureCompositeColorMode0				0xb308
#define PM3TextureCompositeColorMode0And			0xb380
#define PM3TextureCompositeColorMode0Or				0xb388
#define PM3TextureCompositeColorMode1				0xb318
#define PM3TextureCompositeColorMode1And			0xb3a0
#define PM3TextureCompositeColorMode1Or				0xb3a8
#define PM3TextureCompositeFactor0				0xb328
#define PM3TextureCompositeFactor1				0xb330
#define PM3TextureCompositeMode					0xb300
#define PM3TextureCoordMode					0x8380
#define PM3TextureCoordModeAnd					0xac20
#define PM3TextureCoordModeOr					0xac28
#define PM3TextureData						0x88e8
/*
#define PM3TextureDownloadControl				0x0108
*/
#define PM3TextureDownloadOffset				0x88f0
#define PM3TextureEnvColor					0x8688
#define PM3TextureFilterMode					0x84e0
#define PM3TextureFilterModeAnd					0xad50
#define PM3TextureFilterModeOr					0xad58
#define PM3TextureIndexMode0					0xb338
#define PM3TextureIndexMode0And					0xb3c0
#define PM3TextureIndexMode0Or					0xb3c8
#define PM3TextureIndexMode1					0xb340
#define PM3TextureIndexMode1And					0xb3d0
#define PM3TextureIndexMode1Or					0xb3d8
/* ... */
#define PM3TextureMapSize					0xb428
#define PM3TextureMapWidth0					0x8580
#define PM3TextureMapWidth1					0x8588
	#define PM3TextureMapWidth_Width(w)		(((w) & 0xfff) << 0)
	#define PM3TextureMapWidth_BorderLayout			(1 << 12)
	#define PM3TextureMapWidth_Layout_Linear		(0 << 13)
	#define PM3TextureMapWidth_Layout_Patch64		(1 << 13)
	#define PM3TextureMapWidth_Layout_Patch32_2		(2 << 13)
	#define PM3TextureMapWidth_Layout_Patch2		(3 << 13)
	#define PM3TextureMapWidth_HostTexture			(1 << 15)
#define PM3TextureReadMode0					0xb400
#define PM3TextureReadMode0And					0xac30
#define PM3TextureReadMode0Or					0xac38
#define PM3TextureReadMode1					0xb408
#define PM3TextureReadMode1And					0xad40
#define PM3TextureReadMode1Or					0xad48
/* ... */
#define PM3WaitForCompletion					0x80b8
#define PM3Window						0x8980
	#define PM3Window_ForceLBUpdate				(1 << 3)
	#define PM3Window_LBUpdateSource			(1 << 4)
	#define PM3Window_FrameCount(c)			(((c) & 0xff) << 9)
	#define PM3Window_StencilFCP				(1 << 17)
	#define PM3Window_DepthFCP				(1 << 18)
	#define PM3Window_OverrideWriteFiltering		(1 << 19)
#define PM3WindowAnd						0xab80
#define PM3WindowOr						0xab88
#define PM3WindowOrigin						0x81c8
#define PM3XBias						0x9480
#define PM3YBias						0x9488
#define PM3YLimits						0x80a8
#define PM3UVMode						0x8f00
#define PM3ZFogBias						0x86b8
#define PM3ZStart						0xadd8
#define PM3ZStartL						0x89b8
#define PM3ZStartU						0x89b0


/**********************************************
*  GLINT Permedia3 2D setup Unit	      *
***********************************************/
#define PM3Config2D						0xb618
	#define PM3Config2D_OpaqueSpan				(1 << 0)
	#define PM3Config2D_MultiRXBlit				(1 << 1)
	#define PM3Config2D_UserScissorEnable			(1 << 2)
	#define PM3Config2D_FBDestReadEnable			(1 << 3)
	#define PM3Config2D_AlphaBlendEnable			(1 << 4)
	#define PM3Config2D_DitherEnable			(1 << 5)
	#define PM3Config2D_ForegroundROPEnable			(1 << 6)
	#define PM3Config2D_ForegroundROP(rop)		(((rop) & 0xf) << 7)
	#define PM3Config2D_BackgroundROPEnable			(1 << 11)
	#define PM3Config2D_BackgroundROP(rop)		(((rop) & 0xf) << 12)
	#define PM3Config2D_UseConstantSource			(1 << 16)
	#define PM3Config2D_FBWriteEnable			(1 << 17)
	#define PM3Config2D_Blocking				(1 << 18)
	#define PM3Config2D_ExternalSourceData			(1 << 19)
	#define PM3Config2D_LUTModeEnable			(1 << 20)
#define PM3DownloadGlyphwidth					0xb658
	#define PM3DownloadGlyphwidth_GlyphWidth(gw)	((gw) & 0xffff)
#define PM3DownloadTarget					0xb650
	#define PM3DownloadTarget_TagName(tag)		((tag) & 0x1fff)
#define PM3GlyphData						0xb660
#define PM3GlyphPosition					0xb608
	#define PM3GlyphPosition_XOffset(x)		((x) & 0xffff)
	#define PM3GlyphPosition_YOffset(y)		(((y) & 0xffff) << 16)
#define PM3Packed4Pixels					0xb668
#define PM3Packed8Pixels					0xb630
#define PM3Packed16Pixels					0xb638
#define PM3RectanglePosition					0xb600
	#define PM3RectanglePosition_XOffset(x)		((x) & 0xffff)
	#define PM3RectanglePosition_YOffset(y)		(((y) & 0xffff) << 16)
#define PM3Render2D						0xb640
	#define PM3Render2D_Width(w)			((w) & 0x0fff)
	#define PM3Render2D_Operation_Normal			(0 << 12)
	#define PM3Render2D_Operation_SyncOnHostData		(1 << 12)
	#define PM3Render2D_Operation_SyncOnBitMask		(2 << 12)
	#define PM3Render2D_Operation_PatchOrderRendering	(3 << 12)
	#define PM3Render2D_FBSourceReadEnable			(1 << 14)
	#define PM3Render2D_SpanOperation			(1 << 15)
	#define PM3Render2D_Height(h)			(((h) & 0x0fff) << 16)
	#define PM3Render2D_XPositive				(1 << 28)
	#define PM3Render2D_YPositive				(1 << 29)
	#define PM3Render2D_AreaStippleEnable			(1 << 30)
	#define PM3Render2D_TextureEnable			(1 << 31)
#define PM3Render2DGlyph					0xb648
	#define PM3Render2DGlyph_Width(w)		((w) & 0x7f)
	#define PM3Render2DGlyph_Height(h)		(((h) & 0x7f) << 7)
	#define PM3Render2DGlyph_XOffset(x)		(((x) & 0x1ff) << 14)
	#define PM3Render2DGlyph_YOffset(y)		(((y) & 0x1ff) << 23)
#define PM3RenderPatchOffset					0xb610
	#define PM3RenderPatchOffset_XOffset(x)		((x) & 0xffff)
	#define PM3RenderPatchOffset_YOffset(y)		(((y) & 0xffff) << 16)
#define PM3RLCount						0xb678
	#define PM3RLCount_Count(c)			((c) & 0x0fff)
#define PM3RLData						0xb670

/**********************************************
*  GLINT Permedia3 Alias Register	     *
***********************************************/
#define PM3FillBackgroundColor					0x8330
#define PM3FillConfig2D0					0x8338
#define PM3FillConfig2D1					0x8360
	#define PM3FillConfig2D_OpaqueSpan			(1 << 0)
	#define PM3FillConfig2D_MultiRXBlit			(1 << 1)
	#define PM3FillConfig2D_UserScissorEnable		(1 << 2)
	#define PM3FillConfig2D_FBDestReadEnable		(1 << 3)
	#define PM3FillConfig2D_AlphaBlendEnable		(1 << 4)
	#define PM3FillConfig2D_DitherEnable			(1 << 5)
	#define PM3FillConfig2D_ForegroundROPEnable		(1 << 6)
	#define PM3FillConfig2D_ForegroundROP(rop)	(((rop) & 0xf) << 7)
	#define PM3FillConfig2D_BackgroundROPEnable		(1 << 11)
	#define PM3FillConfig2D_BackgroundROP(rop)	(((rop) & 0xf) << 12)
	#define PM3FillConfig2D_UseConstantSource		(1 << 16)
	#define PM3FillConfig2D_FBWriteEnable			(1 << 17)
	#define PM3FillConfig2D_Blocking			(1 << 18)
	#define PM3FillConfig2D_ExternalSourceData		(1 << 19)
	#define PM3FillConfig2D_LUTModeEnable			(1 << 20)
#define PM3FillFBDestReadBufferAddr				0x8310
#define PM3FillFBSourceReadBufferAddr				0x8308
#define PM3FillFBSourceReadBufferOffset				0x8340
	#define PM3FillFBSourceReadBufferOffset_XOffset(x) ((x) & 0xffff)
	#define PM3FillFBSourceReadBufferOffset_YOffset(y)	\
						(((y) & 0xffff) << 16)
#define PM3FillFBWriteBufferAddr				0x8300
#define PM3FillForegroundColor0					0x8328
#define PM3FillForegroundColor1					0x8358
#define PM3FillGlyphPosition					0x8368
	#define PM3FillGlyphPosition_XOffset(x)		((x) & 0xffff)
	#define PM3FillGlyphPosition_YOffset(y)		(((y) & 0xffff) << 16)
#define PM3FillRectanglePosition				0x8348
	#define PM3FillRectanglePosition_XOffset(x)	((x) & 0xffff)
	#define PM3FillRectanglePosition_YOffset(y)	(((y) & 0xffff) << 16)

/* a few more useful registers & regs value... */
#define PM3Sync							0x8c40
	#define PM3Sync_Tag					0x188
#define PM3FilterMode						0x8c00
	#define PM3FilterModeSync				0x400
#define PM3OutputFifo						0x2000
#define PM3StatisticMode					0x8c08
#define PM3AreaStippleMode					0x81a0
#define AreaStipplePattern_indexed(i)		(0x8200 + ((i) * 0x8))

#define PM3DepthMode						0x89a0
#define PM3StencilMode						0x8988
#define PM3StencilData						0x8990
#define PM3TextureReadMode					0x8670
#define PM3FogMode						0x8690
#define PM3ChromaTestMode					0x8f18
#define PM3YUVMode						0x8f00
#define PM3BitMaskPattern					0x8068

/* ***************************** */
/* ***** pm3fb IOCTL const ***** */
/* ***************************** */
#define PM3FBIO_RESETCHIP		0x504D33FF /* 'PM3\377' */

/* ***************************************** */
/* ***** pm3fb useful define and macro ***** */
/* ***************************************** */

/* fifo size in chip */
#define PM3_FIFO_SIZE						120
#define PM3_REGS_SIZE						0x10000
#define PM3_MAX_PIXCLOCK					300000

#endif /* PM3FB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * drivers/video/clgenfb.h - Cirrus Logic chipset constants
 *
 * Copyright 1999 Jeff Garzik <jgarzik@pobox.com>
 *
 * Original clgenfb author:  Frank Neumann
 *
 * Based on retz3fb.c and clgen.c:
 *      Copyright (C) 1997 Jes Sorensen
 *      Copyright (C) 1996 Frank Neumann
 *
 ***************************************************************
 *
 * Format this code with GNU indent '-kr -i8 -pcs' options.
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 *
 */

#ifndef __CLGENFB_H__
#define __CLGENFB_H__

/* OLD COMMENT: definitions for Piccolo/SD64 VGA controller chip   */
/* OLD COMMENT: these definitions might most of the time also work */
/* OLD COMMENT: for other CL-GD542x/543x based boards..            */

/*** External/General Registers ***/
#define CL_POS102	0x102  	/* POS102 register */
#define CL_VSSM		0x46e8 	/* Adapter Sleep */
#define CL_VSSM2	0x3c3	/* Motherboard Sleep */

/*** VGA Sequencer Registers ***/
/* the following are from the "extension registers" group */
#define CL_SEQR6	0x6	/* Unlock ALL Extensions */
#define CL_SEQR7	0x7	/* Extended Sequencer Mode */
#define CL_SEQR8	0x8	/* EEPROM Control */
#define CL_SEQR9	0x9	/* Scratch Pad 0 (do not access!) */
#define CL_SEQRA	0xa	/* Scratch Pad 1 (do not access!) */
#define CL_SEQRB	0xb	/* VCLK0 Numerator */
#define CL_SEQRC	0xc	/* VCLK1 Numerator */
#define CL_SEQRD	0xd	/* VCLK2 Numerator */
#define CL_SEQRE	0xe	/* VCLK3 Numerator */
#define CL_SEQRF	0xf	/* DRAM Control */
#define CL_SEQR10	0x10	/* Graphics Cursor X Position */
#define CL_SEQR11	0x11	/* Graphics Cursor Y Position */
#define CL_SEQR12	0x12	/* Graphics Cursor Attributes */
#define CL_SEQR13	0x13	/* Graphics Cursor Pattern Address Offset */
#define CL_SEQR14	0x14	/* Scratch Pad 2 (CL-GD5426/'28 Only) (do not access!) */
#define CL_SEQR15	0x15	/* Scratch Pad 3 (CL-GD5426/'28 Only) (do not access!) */
#define CL_SEQR16	0x16	/* Performance Tuning (CL-GD5424/'26/'28 Only) */
#define CL_SEQR17	0x17	/* Configuration ReadBack and Extended Control (CL-GF5428 Only) */
#define CL_SEQR18	0x18	/* Signature Generator Control (Not CL-GD5420) */
#define CL_SEQR19	0x19	/* Signature Generator Result Low Byte (Not CL-GD5420) */
#define CL_SEQR1A	0x1a	/* Signature Generator Result High Byte (Not CL-GD5420) */
#define CL_SEQR1B	0x1b	/* VCLK0 Denominator and Post-Scalar Value */
#define CL_SEQR1C	0x1c	/* VCLK1 Denominator and Post-Scalar Value */
#define CL_SEQR1D	0x1d	/* VCLK2 Denominator and Post-Scalar Value */
#define CL_SEQR1E	0x1e	/* VCLK3 Denominator and Post-Scalar Value */
#define CL_SEQR1F	0x1f	/* BIOS ROM write enable and MCLK Select */

/*** CRT Controller Registers ***/
#define CL_CRT22	0x22	/* Graphics Data Latches ReadBack */
#define CL_CRT24	0x24	/* Attribute Controller Toggle ReadBack */
#define CL_CRT26	0x26	/* Attribute Controller Index ReadBack */
/* the following are from the "extension registers" group */
#define CL_CRT19	0x19	/* Interlace End */
#define CL_CRT1A	0x1a	/* Interlace Control */
#define CL_CRT1B	0x1b	/* Extended Display Controls */
#define CL_CRT1C	0x1c	/* Sync adjust and genlock register */
#define CL_CRT1D	0x1d	/* Overlay Extended Control register */
#define CL_CRT1E	0x1e	/* Another overflow register */
#define CL_CRT25	0x25	/* Part Status Register */
#define CL_CRT27	0x27	/* ID Register */
#define CL_CRT51	0x51	/* P4 disable "flicker fixer" */

/*** Graphics Controller Registers ***/
/* the following are from the "extension registers" group */
#define CL_GR9		0x9	/* Offset Register 0 */
#define CL_GRA		0xa	/* Offset Register 1 */
#define CL_GRB		0xb	/* Graphics Controller Mode Extensions */
#define CL_GRC		0xc	/* Color Key (CL-GD5424/'26/'28 Only) */
#define CL_GRD		0xd	/* Color Key Mask (CL-GD5424/'26/'28 Only) */
#define CL_GRE		0xe	/* Miscellaneous Control (Cl-GD5428 Only) */
#define CL_GRF		0xf	/* Display Compression Control register */
#define CL_GR10		0x10	/* 16-bit Pixel BG Color High Byte (Not CL-GD5420) */
#define CL_GR11		0x11	/* 16-bit Pixel FG Color High Byte (Not CL-GD5420) */
#define CL_GR12		0x12	/* Background Color Byte 2 Register */
#define CL_GR13		0x13	/* Foreground Color Byte 2 Register */
#define CL_GR14		0x14	/* Background Color Byte 3 Register */
#define CL_GR15		0x15	/* Foreground Color Byte 3 Register */
/* the following are CL-GD5426/'28 specific blitter registers */
#define CL_GR20		0x20	/* BLT Width Low */
#define CL_GR21		0x21	/* BLT Width High */
#define CL_GR22		0x22	/* BLT Height Low */
#define CL_GR23		0x23	/* BLT Height High */
#define CL_GR24		0x24	/* BLT Destination Pitch Low */
#define CL_GR25		0x25	/* BLT Destination Pitch High */
#define CL_GR26		0x26	/* BLT Source Pitch Low */
#define CL_GR27		0x27	/* BLT Source Pitch High */
#define CL_GR28		0x28	/* BLT Destination Start Low */
#define CL_GR29		0x29	/* BLT Destination Start Mid */
#define CL_GR2A		0x2a	/* BLT Destination Start High */
#define CL_GR2C		0x2c	/* BLT Source Start Low */
#define CL_GR2D		0x2d	/* BLT Source Start Mid */
#define CL_GR2E		0x2e	/* BLT Source Start High */
#define CL_GR2F		0x2f	/* Picasso IV Blitter compat mode..? */
#define CL_GR30		0x30	/* BLT Mode */
#define CL_GR31		0x31	/* BLT Start/Status */
#define CL_GR32		0x32	/* BLT Raster Operation */
#define CL_GR33		0x33	/* another P4 "compat" register.. */
#define CL_GR34		0x34	/* Transparent Color Select Low */
#define CL_GR35		0x35	/* Transparent Color Select High */
#define CL_GR38		0x38	/* Source Transparent Color Mask Low */
#define CL_GR39		0x39	/* Source Transparent Color Mask High */

/*** Attribute Controller Registers ***/
#define CL_AR33		0x33	/* The "real" Pixel Panning register (?) */
#define CL_AR34		0x34	/* TEST */

#endif /* __CLGENFB_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * Copyright 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>
 *
 * videomode of-helpers
 *
 * This file is released under the GPLv2
 */

#ifndef __LINUX_OF_VIDEOMODE_H
#define __LINUX_OF_VIDEOMODE_H

struct device_node;
struct videomode;

int of_get_videomode(struct device_node *np, struct videomode *vm,
		     int index);

#endif /* __LINUX_OF_VIDEOMODE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Phase5 CybervisionPPC (TVP4020) definitions for the Permedia2 framebuffer
 * driver.
 *
 * Copyright (c) 1998-1999 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
 * --------------------------------------------------------------------------
 * $Id: cvisionppc.h,v 1.8 1999/01/28 13:18:07 illo Exp $
 * --------------------------------------------------------------------------
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */

#ifndef CVISIONPPC_H
#define CVISIONPPC_H

#ifndef PM2FB_H
#include "pm2fb.h"
#endif

struct cvppc_par {
	unsigned char* pci_config;
	unsigned char* pci_bridge;
	u32 user_flags;
};

#define CSPPC_PCI_BRIDGE		0xfffe0000
#define CSPPC_BRIDGE_ENDIAN		0x0000
#define CSPPC_BRIDGE_INT		0x0010

#define	CVPPC_PCI_CONFIG		0xfffc0000
#define CVPPC_ROM_ADDRESS		0xe2000001
#define CVPPC_REGS_REGION		0xef000000
#define CVPPC_FB_APERTURE_ONE		0xe0000000
#define CVPPC_FB_APERTURE_TWO		0xe1000000
#define CVPPC_FB_SIZE			0x00800000
#define CVPPC_MEM_CONFIG_OLD		0xed61fcaa	/* FIXME Fujitsu?? */
#define CVPPC_MEM_CONFIG_NEW		0xed41c532	/* FIXME USA?? */
#define CVPPC_MEMCLOCK			83000		/* in KHz */

/* CVPPC_BRIDGE_ENDIAN */
#define CSPPCF_BRIDGE_BIG_ENDIAN	0x02

/* CVPPC_BRIDGE_INT */
#define CSPPCF_BRIDGE_ACTIVE_INT2	0x01

#endif	/* CVISIONPPC_H */

/*****************************************************************************
 * That's all folks!
 *****************************************************************************/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * linux/include/video/vga.h -- standard VGA chipset interaction
 *
 * Copyright 1999 Jeff Garzik <jgarzik@pobox.com>
 * 
 * Copyright history from vga16fb.c:
 *	Copyright 1999 Ben Pfaff and Petr Vandrovec
 *	Based on VGA info at http://www.osdever.net/FreeVGA/home.htm 
 *	Based on VESA framebuffer (c) 1998 Gerd Knorr
 *
 * This file is subject to the terms and conditions of the GNU General
 * Public License.  See the file COPYING in the main directory of this
 * archive for more details.  
 *
 */

#ifndef __linux_video_vga_h__
#define __linux_video_vga_h__

#include <linux/types.h>
#include <linux/io.h>
#include <asm/vga.h>
#include <asm/byteorder.h>


/* Some of the code below is taken from SVGAlib.  The original,
   unmodified copyright notice for that code is below. */
/* VGAlib version 1.2 - (c) 1993 Tommy Frandsen                    */
/*                                                                 */
/* This library is free software; you can redistribute it and/or   */
/* modify it without any restrictions. This library is distributed */
/* in the hope that it will be useful, but without any warranty.   */

/* Multi-chipset support Copyright 1993 Harm Hanemaayer */
/* partially copyrighted (C) 1993 by Hartmut Schirmer */

/* VGA data register ports */
#define VGA_CRT_DC  	0x3D5	/* CRT Controller Data Register - color emulation */
#define VGA_CRT_DM  	0x3B5	/* CRT Controller Data Register - mono emulation */
#define VGA_ATT_R   	0x3C1	/* Attribute Controller Data Read Register */
#define VGA_ATT_W   	0x3C0	/* Attribute Controller Data Write Register */
#define VGA_GFX_D   	0x3CF	/* Graphics Controller Data Register */
#define VGA_SEQ_D   	0x3C5	/* Sequencer Data Register */
#define VGA_MIS_R   	0x3CC	/* Misc Output Read Register */
#define VGA_MIS_W   	0x3C2	/* Misc Output Write Register */
#define VGA_FTC_R	0x3CA	/* Feature Control Read Register */
#define VGA_IS1_RC  	0x3DA	/* Input Status Register 1 - color emulation */
#define VGA_IS1_RM  	0x3BA	/* Input Status Register 1 - mono emulation */
#define VGA_PEL_D   	0x3C9	/* PEL Data Register */
#define VGA_PEL_MSK 	0x3C6	/* PEL mask register */

/* EGA-specific registers */
#define EGA_GFX_E0	0x3CC	/* Graphics enable processor 0 */
#define EGA_GFX_E1	0x3CA	/* Graphics enable processor 1 */

/* VGA index register ports */
#define VGA_CRT_IC  	0x3D4	/* CRT Controller Index - color emulation */
#define VGA_CRT_IM  	0x3B4	/* CRT Controller Index - mono emulation */
#define VGA_ATT_IW  	0x3C0	/* Attribute Controller Index & Data Write Register */
#define VGA_GFX_I   	0x3CE	/* Graphics Controller Index */
#define VGA_SEQ_I   	0x3C4	/* Sequencer Index */
#define VGA_PEL_IW  	0x3C8	/* PEL Write Index */
#define VGA_PEL_IR  	0x3C7	/* PEL Read Index */

/* standard VGA indexes max counts */
#define VGA_CRT_C   	0x19	/* Number of CRT Controller Registers */
#define VGA_ATT_C   	0x15	/* Number of Attribute Controller Registers */
#define VGA_GFX_C   	0x09	/* Number of Graphics Controller Registers */
#define VGA_SEQ_C   	0x05	/* Number of Sequencer Registers */
#define VGA_MIS_C   	0x01	/* Number of Misc Output Register */

/* VGA misc register bit masks */
#define VGA_MIS_COLOR		0x01
#define VGA_MIS_ENB_MEM_ACCESS	0x02
#define VGA_MIS_DCLK_28322_720	0x04
#define VGA_MIS_ENB_PLL_LOAD	(0x04 | 0x08)
#define VGA_MIS_SEL_HIGH_PAGE	0x20

/* VGA CRT controller register indices */
#define VGA_CRTC_H_TOTAL	0
#define VGA_CRTC_H_DISP		1
#define VGA_CRTC_H_BLANK_START	2
#define VGA_CRTC_H_BLANK_END	3
#define VGA_CRTC_H_SYNC_START	4
#define VGA_CRTC_H_SYNC_END	5
#define VGA_CRTC_V_TOTAL	6
#define VGA_CRTC_OVERFLOW	7
#define VGA_CRTC_PRESET_ROW	8
#define VGA_CRTC_MAX_SCAN	9
#define VGA_CRTC_CURSOR_START	0x0A
#define VGA_CRTC_CURSOR_END	0x0B
#define VGA_CRTC_START_HI	0x0C
#define VGA_CRTC_START_LO	0x0D
#define VGA_CRTC_CURSOR_HI	0x0E
#define VGA_CRTC_CURSOR_LO	0x0F
#define VGA_CRTC_V_SYNC_START	0x10
#define VGA_CRTC_V_SYNC_END	0x11
#define VGA_CRTC_V_DISP_END	0x12
#define VGA_CRTC_OFFSET		0x13
#define VGA_CRTC_UNDERLINE	0x14
#define VGA_CRTC_V_BLANK_START	0x15
#define VGA_CRTC_V_BLANK_END	0x16
#define VGA_CRTC_MODE		0x17
#define VGA_CRTC_LINE_COMPARE	0x18
#define VGA_CRTC_REGS		VGA_CRT_C

/* VGA CRT controller bit masks */
#define VGA_CR11_LOCK_CR0_CR7	0x80 /* lock writes to CR0 - CR7 */
#define VGA_CR17_H_V_SIGNALS_ENABLED 0x80

/* VGA attribute controller register indices */
#define VGA_ATC_PALETTE0	0x00
#define VGA_ATC_PALETTE1	0x01
#define VGA_ATC_PALETTE2	0x02
#define VGA_ATC_PALETTE3	0x03
#define VGA_ATC_PALETTE4	0x04
#define VGA_ATC_PALETTE5	0x05
#define VGA_ATC_PALETTE6	0x06
#define VGA_ATC_PALETTE7	0x07
#define VGA_ATC_PALETTE8	0x08
#define VGA_ATC_PALETTE9	0x09
#define VGA_ATC_PALETTEA	0x0A
#define VGA_ATC_PALETTEB	0x0B
#define VGA_ATC_PALETTEC	0x0C
#define VGA_ATC_PALETTED	0x0D
#define VGA_ATC_PALETTEE	0x0E
#define VGA_ATC_PALETTEF	0x0F
#define VGA_ATC_MODE		0x10
#define VGA_ATC_OVERSCAN	0x11
#define VGA_ATC_PLANE_ENABLE	0x12
#define VGA_ATC_PEL		0x13
#define VGA_ATC_COLOR_PAGE	0x14

#define VGA_AR_ENABLE_DISPLAY	0x20

/* VGA sequencer register indices */
#define VGA_SEQ_RESET		0x00
#define VGA_SEQ_CLOCK_MODE	0x01
#define VGA_SEQ_PLANE_WRITE	0x02
#define VGA_SEQ_CHARACTER_MAP	0x03
#define VGA_SEQ_MEMORY_MODE	0x04

/* VGA sequencer register bit masks */
#define VGA_SR01_CHAR_CLK_8DOTS	0x01 /* bit 0: character clocks 8 dots wide are generated */
#define VGA_SR01_SCREEN_OFF	0x20 /* bit 5: Screen is off */
#define VGA_SR02_ALL_PLANES	0x0F /* bits 3-0: enable access to all planes */
#define VGA_SR04_EXT_MEM	0x02 /* bit 1: allows complete mem access to 256K */
#define VGA_SR04_SEQ_MODE	0x04 /* bit 2: directs system to use a sequential addressing mode */
#define VGA_SR04_CHN_4M		0x08 /* bit 3: selects modulo 4 addressing for CPU access to display memory */

/* VGA graphics controller register indices */
#define VGA_GFX_SR_VALUE	0x00
#define VGA_GFX_SR_ENABLE	0x01
#define VGA_GFX_COMPARE_VALUE	0x02
#define VGA_GFX_DATA_ROTATE	0x03
#define VGA_GFX_PLANE_READ	0x04
#define VGA_GFX_MODE		0x05
#define VGA_GFX_MISC		0x06
#define VGA_GFX_COMPARE_MASK	0x07
#define VGA_GFX_BIT_MASK	0x08

/* VGA graphics controller bit masks */
#define VGA_GR06_GRAPHICS_MODE	0x01

/* macro for composing an 8-bit VGA register index and value
 * into a single 16-bit quantity */
#define VGA_OUT16VAL(v, r)       (((v) << 8) | (r))

/* decide whether we should enable the faster 16-bit VGA register writes */
#ifdef __LITTLE_ENDIAN
#define VGA_OUTW_WRITE
#endif

/* VGA State Save and Restore */
#define VGA_SAVE_FONT0 1  /* save/restore plane 2 fonts	  */
#define VGA_SAVE_FONT1 2  /* save/restore plane 3 fonts   */
#define VGA_SAVE_TEXT  4  /* save/restore plane 0/1 fonts */
#define VGA_SAVE_FONTS 7  /* save/restore all fonts	  */
#define VGA_SAVE_MODE  8  /* save/restore video mode 	  */
#define VGA_SAVE_CMAP  16 /* save/restore color map/DAC   */

struct vgastate {
	void __iomem *vgabase;	/* mmio base, if supported 		   */
	unsigned long membase;	/* VGA window base, 0 for default - 0xA000 */
	__u32 memsize;		/* VGA window size, 0 for default 64K	   */
	__u32 flags;		/* what state[s] to save (see VGA_SAVE_*)  */
	__u32 depth;		/* current fb depth, not important	   */
	__u32 num_attr;		/* number of att registers, 0 for default  */
	__u32 num_crtc;		/* number of crt registers, 0 for default  */
	__u32 num_gfx;		/* number of gfx registers, 0 for default  */
	__u32 num_seq;		/* number of seq registers, 0 for default  */
	void *vidstate;
};	

extern int save_vga(struct vgastate *state);
extern int restore_vga(struct vgastate *state);

/*
 * generic VGA port read/write
 */
 
static inline unsigned char vga_io_r (unsigned short port)
{
	return inb_p(port);
}

static inline void vga_io_w (unsigned short port, unsigned char val)
{
	outb_p(val, port);
}

static inline void vga_io_w_fast (unsigned short port, unsigned char reg,
				  unsigned char val)
{
	outw(VGA_OUT16VAL (val, reg), port);
}

static inline unsigned char vga_mm_r (void __iomem *regbase, unsigned short port)
{
	return readb (regbase + port);
}

static inline void vga_mm_w (void __iomem *regbase, unsigned short port, unsigned char val)
{
	writeb (val, regbase + port);
}

static inline void vga_mm_w_fast (void __iomem *regbase, unsigned short port,
				  unsigned char reg, unsigned char val)
{
	writew (VGA_OUT16VAL (val, reg), regbase + port);
}

static inline unsigned char vga_r (void __iomem *regbase, unsigned short port)
{
	if (regbase)
		return vga_mm_r (regbase, port);
	else
		return vga_io_r (port);
}

static inline void vga_w (void __iomem *regbase, unsigned short port, unsigned char val)
{
	if (regbase)
		vga_mm_w (regbase, port, val);
	else
		vga_io_w (port, val);
}


static inline void vga_w_fast (void __iomem *regbase, unsigned short port,
			       unsigned char reg, unsigned char val)
{
	if (regbase)
		vga_mm_w_fast (regbase, port, reg, val);
	else
		vga_io_w_fast (port, reg, val);
}


/*
 * VGA CRTC register read/write
 */
 
static inline unsigned char vga_rcrt (void __iomem *regbase, unsigned char reg)
{
        vga_w (regbase, VGA_CRT_IC, reg);
        return vga_r (regbase, VGA_CRT_DC);
}

static inline void vga_wcrt (void __iomem *regbase, unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_w_fast (regbase, VGA_CRT_IC, reg, val);
#else
        vga_w (regbase, VGA_CRT_IC, reg);
        vga_w (regbase, VGA_CRT_DC, val);
#endif /* VGA_OUTW_WRITE */
}

static inline unsigned char vga_io_rcrt (unsigned char reg)
{
        vga_io_w (VGA_CRT_IC, reg);
        return vga_io_r (VGA_CRT_DC);
}

static inline void vga_io_wcrt (unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_io_w_fast (VGA_CRT_IC, reg, val);
#else
        vga_io_w (VGA_CRT_IC, reg);
        vga_io_w (VGA_CRT_DC, val);
#endif /* VGA_OUTW_WRITE */
}

static inline unsigned char vga_mm_rcrt (void __iomem *regbase, unsigned char reg)
{
        vga_mm_w (regbase, VGA_CRT_IC, reg);
        return vga_mm_r (regbase, VGA_CRT_DC);
}

static inline void vga_mm_wcrt (void __iomem *regbase, unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_mm_w_fast (regbase, VGA_CRT_IC, reg, val);
#else
        vga_mm_w (regbase, VGA_CRT_IC, reg);
        vga_mm_w (regbase, VGA_CRT_DC, val);
#endif /* VGA_OUTW_WRITE */
}


/*
 * VGA sequencer register read/write
 */
 
static inline unsigned char vga_rseq (void __iomem *regbase, unsigned char reg)
{
        vga_w (regbase, VGA_SEQ_I, reg);
        return vga_r (regbase, VGA_SEQ_D);
}

static inline void vga_wseq (void __iomem *regbase, unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_w_fast (regbase, VGA_SEQ_I, reg, val);
#else
        vga_w (regbase, VGA_SEQ_I, reg);
        vga_w (regbase, VGA_SEQ_D, val);
#endif /* VGA_OUTW_WRITE */
}

static inline unsigned char vga_io_rseq (unsigned char reg)
{
        vga_io_w (VGA_SEQ_I, reg);
        return vga_io_r (VGA_SEQ_D);
}

static inline void vga_io_wseq (unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_io_w_fast (VGA_SEQ_I, reg, val);
#else
        vga_io_w (VGA_SEQ_I, reg);
        vga_io_w (VGA_SEQ_D, val);
#endif /* VGA_OUTW_WRITE */
}

static inline unsigned char vga_mm_rseq (void __iomem *regbase, unsigned char reg)
{
        vga_mm_w (regbase, VGA_SEQ_I, reg);
        return vga_mm_r (regbase, VGA_SEQ_D);
}

static inline void vga_mm_wseq (void __iomem *regbase, unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_mm_w_fast (regbase, VGA_SEQ_I, reg, val);
#else
        vga_mm_w (regbase, VGA_SEQ_I, reg);
        vga_mm_w (regbase, VGA_SEQ_D, val);
#endif /* VGA_OUTW_WRITE */
}

/*
 * VGA graphics controller register read/write
 */
 
static inline unsigned char vga_rgfx (void __iomem *regbase, unsigned char reg)
{
        vga_w (regbase, VGA_GFX_I, reg);
        return vga_r (regbase, VGA_GFX_D);
}

static inline void vga_wgfx (void __iomem *regbase, unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_w_fast (regbase, VGA_GFX_I, reg, val);
#else
        vga_w (regbase, VGA_GFX_I, reg);
        vga_w (regbase, VGA_GFX_D, val);
#endif /* VGA_OUTW_WRITE */
}

static inline unsigned char vga_io_rgfx (unsigned char reg)
{
        vga_io_w (VGA_GFX_I, reg);
        return vga_io_r (VGA_GFX_D);
}

static inline void vga_io_wgfx (unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_io_w_fast (VGA_GFX_I, reg, val);
#else
        vga_io_w (VGA_GFX_I, reg);
        vga_io_w (VGA_GFX_D, val);
#endif /* VGA_OUTW_WRITE */
}

static inline unsigned char vga_mm_rgfx (void __iomem *regbase, unsigned char reg)
{
        vga_mm_w (regbase, VGA_GFX_I, reg);
        return vga_mm_r (regbase, VGA_GFX_D);
}

static inline void vga_mm_wgfx (void __iomem *regbase, unsigned char reg, unsigned char val)
{
#ifdef VGA_OUTW_WRITE
	vga_mm_w_fast (regbase, VGA_GFX_I, reg, val);
#else
        vga_mm_w (regbase, VGA_GFX_I, reg);
        vga_mm_w (regbase, VGA_GFX_D, val);
#endif /* VGA_OUTW_WRITE */
}


/*
 * VGA attribute controller register read/write
 */
 
static inline unsigned char vga_rattr (void __iomem *regbase, unsigned char reg)
{
        vga_w (regbase, VGA_ATT_IW, reg);
        return vga_r (regbase, VGA_ATT_R);
}

static inline void vga_wattr (void __iomem *regbase, unsigned char reg, unsigned char val)
{
        vga_w (regbase, VGA_ATT_IW, reg);
        vga_w (regbase, VGA_ATT_W, val);
}

static inline unsigned char vga_io_rattr (unsigned char reg)
{
        vga_io_w (VGA_ATT_IW, reg);
        return vga_io_r (VGA_ATT_R);
}

static inline void vga_io_wattr (unsigned char reg, unsigned char val)
{
        vga_io_w (VGA_ATT_IW, reg);
        vga_io_w (VGA_ATT_W, val);
}

static inline unsigned char vga_mm_rattr (void __iomem *regbase, unsigned char reg)
{
        vga_mm_w (regbase, VGA_ATT_IW, reg);
        return vga_mm_r (regbase, VGA_ATT_R);
}

static inline void vga_mm_wattr (void __iomem *regbase, unsigned char reg, unsigned char val)
{
        vga_mm_w (regbase, VGA_ATT_IW, reg);
        vga_mm_w (regbase, VGA_ATT_W, val);
}

#endif /* __linux_video_vga_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
#ifndef TRIDENTFB_DEBUG
#define TRIDENTFB_DEBUG 0
#endif

#if TRIDENTFB_DEBUG
#define debug(f, a...)	printk("%s:" f,  __func__ , ## a);
#else
#define debug(f, a...)
#endif

#define output(f, a...) pr_info("tridentfb: " f, ## a)

#define Kb	(1024)
#define Mb	(Kb*Kb)

/* PCI IDS of supported cards temporarily here */

#define CYBER9320	0x9320
#define CYBER9388	0x9388
#define CYBER9382	0x9382		/* the real PCI id for this is 9660 */
#define CYBER9385	0x9385		/* ditto */		
#define CYBER9397	0x9397
#define CYBER9397DVD	0x939A
#define CYBER9520	0x9520
#define CYBER9525DVD	0x9525
#define TGUI9440	0x9440
#define TGUI9660	0x9660
#define PROVIDIA9685	0x9685
#define IMAGE975	0x9750
#define IMAGE985	0x9850
#define BLADE3D		0x9880
#define CYBERBLADEE4	0x9540
#define CYBERBLADEi7	0x8400
#define CYBERBLADEi7D	0x8420
#define CYBERBLADEi1	0x8500
#define CYBERBLADEi1D	0x8520
#define CYBERBLADEAi1	0x8600
#define CYBERBLADEAi1D	0x8620
#define CYBERBLADEXPAi1 0x8820
#define CYBERBLADEXPm8  0x9910
#define CYBERBLADEXPm16 0x9930

/* these defines are for 'lcd' variable */
#define LCD_STRETCH	0
#define LCD_CENTER	1
#define LCD_BIOS	2

/* General Registers */
#define SPR	0x1F		/* Software Programming Register (videoram) */

/* 3C4 */
#define RevisionID 0x09
#define OldOrNew 0x0B	
#define ConfPort1 0x0C
#define ConfPort2 0x0C
#define NewMode2 0x0D
#define NewMode1 0x0E
#define Protection 0x11
#define MCLKLow 0x16
#define MCLKHigh 0x17
#define ClockLow 0x18
#define ClockHigh 0x19
#define SSetup 0x20
#define SKey 0x37
#define SPKey 0x57

/* 3x4 */
#define CRTCModuleTest 0x1E
#define FIFOControl 0x20
#define LinearAddReg 0x21
#define DRAMTiming 0x23
#define New32 0x23
#define RAMDACTiming 0x25
#define CRTHiOrd 0x27
#define AddColReg 0x29
#define InterfaceSel 0x2A
#define HorizOverflow 0x2B
#define GETest 0x2D
#define Performance 0x2F
#define GraphEngReg 0x36
#define I2C 0x37
#define PixelBusReg 0x38
#define PCIReg 0x39
#define DRAMControl 0x3A
#define MiscContReg 0x3C
#define CursorXLow 0x40
#define CursorXHigh 0x41
#define CursorYLow 0x42
#define CursorYHigh 0x43
#define CursorLocLow 0x44
#define CursorLocHigh 0x45
#define CursorXOffset 0x46
#define CursorYOffset 0x47
#define CursorFG1 0x48
#define CursorFG2 0x49
#define CursorFG3 0x4A
#define CursorFG4 0x4B
#define CursorBG1 0x4C
#define CursorBG2 0x4D
#define CursorBG3 0x4E
#define CursorBG4 0x4F
#define CursorControl 0x50
#define PCIRetry 0x55
#define PreEndControl 0x56
#define PreEndFetch 0x57
#define PCIMaster 0x60
#define Enhancement0 0x62
#define NewEDO 0x64
#define TVinterface 0xC0
#define TVMode 0xC1
#define ClockControl 0xCF


/* 3CE */
#define MiscExtFunc 0x0F
#define PowerStatus 0x23
#define MiscIntContReg 0x2F
#define CyberControl 0x30
#define CyberEnhance 0x31
#define FPConfig     0x33
#define VertStretch  0x52
#define HorStretch   0x53
#define BiosMode     0x5c
#define BiosReg      0x5d

/* Graphics Engine */
#define STATUS	0x2120
#define OLDCMD	0x2124
#define DRAWFL	0x2128
#define OLDCLR	0x212C
#define OLDDST	0x2138
#define OLDSRC	0x213C
#define OLDDIM	0x2140
#define CMD	0x2144
#define ROP	0x2148
#define COLOR	0x2160
#define BGCOLOR	0x2164
#define SRC1	0x2100
#define SRC2	0x2104
#define DST1	0x2108
#define DST2	0x210C

#define ROP_S	0xCC
#define ROP_P	0xF0
#define ROP_X	0x66
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * StrongARM 1100 LCD Controller Frame Buffer Device
 *
 * Copyright (C) 1999 Eric A. Thomas
 *  Based on acornfb.c Copyright (C) Russell King.
 *  
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */
#ifndef _VIDEO_SA1100FB_H
#define _VIDEO_SA1100FB_H

#include <linux/fb.h>
#include <linux/types.h>

#define RGB_4	0
#define RGB_8	1
#define RGB_16	2
#define NR_RGB	3

/* These are the bitfields for each display depth that we support. */
struct sa1100fb_rgb {
	struct fb_bitfield	red;
	struct fb_bitfield	green;
	struct fb_bitfield	blue;
	struct fb_bitfield	transp;
};

/* This structure describes the machine which we are running on. */
struct sa1100fb_mach_info {
	u_long		pixclock;

	u_short		xres;
	u_short		yres;

	u_char		bpp;
	u_char		hsync_len;
	u_char		left_margin;
	u_char		right_margin;

	u_char		vsync_len;
	u_char		upper_margin;
	u_char		lower_margin;
	u_char		sync;

	u_int		cmap_greyscale:1,
			cmap_inverse:1,
			cmap_static:1,
			unused:29;

	u_int		lccr0;
	u_int		lccr3;

	/* Overrides for the default RGB maps */
	const struct sa1100fb_rgb *rgb[NR_RGB];

	void (*backlight_power)(int);
	void (*lcd_power)(int);
	void (*set_visual)(u32);
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef __VIDEO_SH_MOBILE_MERAM_H__
#define __VIDEO_SH_MOBILE_MERAM_H__

/* For sh_mobile_meram_info.addr_mode */
enum {
	SH_MOBILE_MERAM_MODE0 = 0,
	SH_MOBILE_MERAM_MODE1
};

enum {
	SH_MOBILE_MERAM_PF_NV = 0,
	SH_MOBILE_MERAM_PF_RGB,
	SH_MOBILE_MERAM_PF_NV24
};


struct sh_mobile_meram_priv;

/*
 * struct sh_mobile_meram_info - MERAM platform data
 * @reserved_icbs: Bitmask of reserved ICBs (for instance used through UIO)
 */
struct sh_mobile_meram_info {
	int				addr_mode;
	u32				reserved_icbs;
	struct sh_mobile_meram_priv	*priv;
	struct platform_device		*pdev;
};

/* icb config */
struct sh_mobile_meram_icb_cfg {
	unsigned int meram_size;	/* MERAM Buffer Size to use */
};

struct sh_mobile_meram_cfg {
	struct sh_mobile_meram_icb_cfg icb[2];
};

#if defined(CONFIG_FB_SH_MOBILE_MERAM) || \
    defined(CONFIG_FB_SH_MOBILE_MERAM_MODULE)
unsigned long sh_mobile_meram_alloc(struct sh_mobile_meram_info *meram_dev,
				    size_t size);
void sh_mobile_meram_free(struct sh_mobile_meram_info *meram_dev,
			  unsigned long mem, size_t size);
void *sh_mobile_meram_cache_alloc(struct sh_mobile_meram_info *dev,
				  const struct sh_mobile_meram_cfg *cfg,
				  unsigned int xres, unsigned int yres,
				  unsigned int pixelformat,
				  unsigned int *pitch);
void sh_mobile_meram_cache_free(struct sh_mobile_meram_info *dev, void *data);
void sh_mobile_meram_cache_update(struct sh_mobile_meram_info *dev, void *data,
				  unsigned long base_addr_y,
				  unsigned long base_addr_c,
				  unsigned long *icb_addr_y,
				  unsigned long *icb_addr_c);
#else
static inline unsigned long
sh_mobile_meram_alloc(struct sh_mobile_meram_info *meram_dev, size_t size)
{
	return 0;
}

static inline void
sh_mobile_meram_free(struct sh_mobile_meram_info *meram_dev,
		     unsigned long mem, size_t size)
{
}

static inline void *
sh_mobile_meram_cache_alloc(struct sh_mobile_meram_info *dev,
			    const struct sh_mobile_meram_cfg *cfg,
			    unsigned int xres, unsigned int yres,
			    unsigned int pixelformat,
			    unsigned int *pitch)
{
	return ERR_PTR(-ENODEV);
}

static inline void
sh_mobile_meram_cache_free(struct sh_mobile_meram_info *dev, void *data)
{
}

static inline void
sh_mobile_meram_cache_update(struct sh_mobile_meram_info *dev, void *data,
			     unsigned long base_addr_y,
			     unsigned long base_addr_c,
			     unsigned long *icb_addr_y,
			     unsigned long *icb_addr_c)
{
}
#endif

#endif /* __VIDEO_SH_MOBILE_MERAM_H__  */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /* include/video/platform_lcd.h
 *
 * Copyright 2008 Simtec Electronics
 *	Ben Dooks <ben@simtec.co.uk>
 *
 * Generic platform-device LCD power control interface.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
*/

struct plat_lcd_data;
struct fb_info;

struct plat_lcd_data {
	int	(*probe)(struct plat_lcd_data *);
	void	(*set_power)(struct plat_lcd_data *, unsigned int power);
	int	(*match_fb)(struct plat_lcd_data *, struct fb_info *);
};

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 *  linux/drivers/video/kyro/kryo.h
 *
 *  Copyright (C) 2002 STMicroelectronics
 *  Copyright (C) 2004 Paul Mundt
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */

#ifndef _KYRO_H
#define _KYRO_H

struct kyrofb_info {
	void __iomem *regbase;

	u32 palette[16];
	u32 HTot;	/* Hor Total Time    */
	u32 HFP;	/* Hor Front Porch   */
	u32 HST;	/* Hor Sync Time     */
	u32 HBP;	/* Hor Back Porch    */
	s32 HSP;		/* Hor Sync Polarity */
	u32 VTot;	/* Ver Total Time    */
	u32 VFP;	/* Ver Front Porch   */
	u32 VST;	/* Ver Sync Time     */
	u32 VBP;	/* Ver Back Porch    */
	s32 VSP;		/* Ver Sync Polarity */
	u32 XRES;	/* X Resolution      */
	u32 YRES;	/* Y Resolution      */
	u32 VFREQ;	/* Ver Frequency     */
	u32 PIXCLK;	/* Pixel Clock       */
	u32 HCLK;	/* Hor Clock         */

	/* Useful to hold depth here for Linux */
	u8 PIXDEPTH;

	int wc_cookie;
};

extern int kyro_dev_init(void);
extern void kyro_dev_reset(void);

extern unsigned char *kyro_dev_physical_fb_ptr(void);
extern unsigned char *kyro_dev_virtual_fb_ptr(void);
extern void *kyro_dev_physical_regs_ptr(void);
extern void *kyro_dev_virtual_regs_ptr(void);
extern unsigned int kyro_dev_fb_size(void);
extern unsigned int kyro_dev_regs_size(void);

extern u32 kyro_dev_overlay_offset(void);

/*
 * benedict.gaster@superh.com
 * Added the follow IOCTLS for the creation of overlay services...
 */
#define KYRO_IOC_MAGIC 'k'

#define KYRO_IOCTL_OVERLAY_CREATE       _IO(KYRO_IOC_MAGIC, 0)
#define KYRO_IOCTL_OVERLAY_VIEWPORT_SET _IO(KYRO_IOC_MAGIC, 1)
#define KYRO_IOCTL_SET_VIDEO_MODE       _IO(KYRO_IOC_MAGIC, 2)
#define KYRO_IOCTL_UVSTRIDE             _IO(KYRO_IOC_MAGIC, 3)
#define KYRO_IOCTL_OVERLAY_OFFSET       _IO(KYRO_IOC_MAGIC, 4)
#define KYRO_IOCTL_STRIDE               _IO(KYRO_IOC_MAGIC, 5)

/*
 * The follow 3 structures are used to pass data from user space into the kernel
 * for the creation of overlay surfaces and setting the video mode.
 */
typedef struct _OVERLAY_CREATE {
	u32 ulWidth;
	u32 ulHeight;
	int bLinear;
} overlay_create;

typedef struct _OVERLAY_VIEWPORT_SET {
	u32 xOrgin;
	u32 yOrgin;
	u32 xSize;
	u32 ySize;
} overlay_viewport_set;

typedef struct _SET_VIDEO_MODE {
	u32 ulWidth;
	u32 ulHeight;
	u32 ulScan;
	u8 displayDepth;
	int bLinear;
} set_video_mode;

#endif /* _KYRO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * linux/include/video/mmp_disp.h
 * Header file for Marvell MMP Display Controller
 *
 * Copyright (C) 2012 Marvell Technology Group Ltd.
 * Authors: Zhou Zhu <zzhu3@marvell.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef _MMP_DISP_H_
#define _MMP_DISP_H_
#include <linux/kthread.h>

enum {
	PIXFMT_UYVY = 0,
	PIXFMT_VYUY,
	PIXFMT_YUYV,
	PIXFMT_YUV422P,
	PIXFMT_YVU422P,
	PIXFMT_YUV420P,
	PIXFMT_YVU420P,
	PIXFMT_RGB565 = 0x100,
	PIXFMT_BGR565,
	PIXFMT_RGB1555,
	PIXFMT_BGR1555,
	PIXFMT_RGB888PACK,
	PIXFMT_BGR888PACK,
	PIXFMT_RGB888UNPACK,
	PIXFMT_BGR888UNPACK,
	PIXFMT_RGBA888,
	PIXFMT_BGRA888,
	PIXFMT_RGB666, /* for output usage */
	PIXFMT_PSEUDOCOLOR = 0x200,
};

static inline int pixfmt_to_stride(int pix_fmt)
{
	switch (pix_fmt) {
	case PIXFMT_RGB565:
	case PIXFMT_BGR565:
	case PIXFMT_RGB1555:
	case PIXFMT_BGR1555:
	case PIXFMT_UYVY:
	case PIXFMT_VYUY:
	case PIXFMT_YUYV:
		return 2;
	case PIXFMT_RGB888UNPACK:
	case PIXFMT_BGR888UNPACK:
	case PIXFMT_RGBA888:
	case PIXFMT_BGRA888:
		return 4;
	case PIXFMT_RGB888PACK:
	case PIXFMT_BGR888PACK:
		return 3;
	case PIXFMT_YUV422P:
	case PIXFMT_YVU422P:
	case PIXFMT_YUV420P:
	case PIXFMT_YVU420P:
	case PIXFMT_PSEUDOCOLOR:
		return 1;
	default:
		return 0;
	}
}

/* parameters used by path/overlay */
/* overlay related para: win/addr */
struct mmp_win {
	/* position/size of window */
	u16	xsrc;
	u16	ysrc;
	u16	xdst;
	u16	ydst;
	u16	xpos;
	u16	ypos;
	u16	left_crop;
	u16	right_crop;
	u16	up_crop;
	u16	bottom_crop;
	int	pix_fmt;
	/*
	 * pitch[0]: graphics/video layer line length or y pitch
	 * pitch[1]/pitch[2]: video u/v pitch if non-zero
	 */
	u32	pitch[3];
};

struct mmp_addr {
	/* phys address */
	u32	phys[6];
};

/* path related para: mode */
struct mmp_mode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 hsync_invert;
	u32 vsync_invert;
	u32 invert_pixclock;
	u32 pixclock_freq;
	int pix_fmt_out;
};

/* main structures */
struct mmp_path;
struct mmp_overlay;
struct mmp_panel;

/* status types */
enum {
	MMP_OFF = 0,
	MMP_ON,
};

static inline const char *stat_name(int stat)
{
	switch (stat) {
	case MMP_OFF:
		return "OFF";
	case MMP_ON:
		return "ON";
	default:
		return "UNKNOWNSTAT";
	}
}

struct mmp_overlay_ops {
	/* should be provided by driver */
	void (*set_fetch)(struct mmp_overlay *overlay, int fetch_id);
	void (*set_onoff)(struct mmp_overlay *overlay, int status);
	void (*set_win)(struct mmp_overlay *overlay, struct mmp_win *win);
	int (*set_addr)(struct mmp_overlay *overlay, struct mmp_addr *addr);
};

/* overlay describes a z-order indexed slot in each path. */
struct mmp_overlay {
	int id;
	const char *name;
	struct mmp_path *path;

	/* overlay info: private data */
	int dmafetch_id;
	struct mmp_addr addr;
	struct mmp_win win;

	/* state */
	int open_count;
	int status;
	struct mutex access_ok;

	struct mmp_overlay_ops *ops;
};

/* panel type */
enum {
	PANELTYPE_ACTIVE = 0,
	PANELTYPE_SMART,
	PANELTYPE_TV,
	PANELTYPE_DSI_CMD,
	PANELTYPE_DSI_VIDEO,
};

struct mmp_panel {
	/* use node to register to list */
	struct list_head node;
	const char *name;
	/* path name used to connect to proper path configed */
	const char *plat_path_name;
	struct device *dev;
	int panel_type;
	void *plat_data;
	int (*get_modelist)(struct mmp_panel *panel,
			struct mmp_mode **modelist);
	void (*set_mode)(struct mmp_panel *panel,
			struct mmp_mode *mode);
	void (*set_onoff)(struct mmp_panel *panel,
			int status);
};

struct mmp_path_ops {
	int (*check_status)(struct mmp_path *path);
	struct mmp_overlay *(*get_overlay)(struct mmp_path *path,
			int overlay_id);
	int (*get_modelist)(struct mmp_path *path,
			struct mmp_mode **modelist);

	/* follow ops should be provided by driver */
	void (*set_mode)(struct mmp_path *path, struct mmp_mode *mode);
	void (*set_onoff)(struct mmp_path *path, int status);
	/* todo: add query */
};

/* path output types */
enum {
	PATH_OUT_PARALLEL,
	PATH_OUT_DSI,
	PATH_OUT_HDMI,
};

/* path is main part of mmp-disp */
struct mmp_path {
	/* use node to register to list */
	struct list_head node;

	/* init data */
	struct device *dev;

	int id;
	const char *name;
	int output_type;
	struct mmp_panel *panel;
	void *plat_data;

	/* dynamic use */
	struct mmp_mode mode;

	/* state */
	int open_count;
	int status;
	struct mutex access_ok;

	struct mmp_path_ops ops;

	/* layers */
	int overlay_num;
	struct mmp_overlay overlays[0];
};

extern struct mmp_path *mmp_get_path(const char *name);
static inline void mmp_path_set_mode(struct mmp_path *path,
		struct mmp_mode *mode)
{
	if (path)
		path->ops.set_mode(path, mode);
}
static inline void mmp_path_set_onoff(struct mmp_path *path, int status)
{
	if (path)
		path->ops.set_onoff(path, status);
}
static inline int mmp_path_get_modelist(struct mmp_path *path,
		struct mmp_mode **modelist)
{
	if (path)
		return path->ops.get_modelist(path, modelist);
	return 0;
}
static inline struct mmp_overlay *mmp_path_get_overlay(
		struct mmp_path *path, int overlay_id)
{
	if (path)
		return path->ops.get_overlay(path, overlay_id);
	return NULL;
}
static inline void mmp_overlay_set_fetch(struct mmp_overlay *overlay,
		int fetch_id)
{
	if (overlay)
		overlay->ops->set_fetch(overlay, fetch_id);
}
static inline void mmp_overlay_set_onoff(struct mmp_overlay *overlay,
		int status)
{
	if (overlay)
		overlay->ops->set_onoff(overlay, status);
}
static inline void mmp_overlay_set_win(struct mmp_overlay *overlay,
		struct mmp_win *win)
{
	if (overlay)
		overlay->ops->set_win(overlay, win);
}
static inline int mmp_overlay_set_addr(struct mmp_overlay *overlay,
		struct mmp_addr *addr)
{
	if (overlay)
		return overlay->ops->set_addr(overlay, addr);
	return 0;
}

/*
 * driver data is set from each detailed ctrl driver for path usage
 * it defined a common interface that plat driver need to implement
 */
struct mmp_path_info {
	/* driver data, set when registed*/
	const char *name;
	struct device *dev;
	int id;
	int output_type;
	int overlay_num;
	void (*set_mode)(struct mmp_path *path, struct mmp_mode *mode);
	void (*set_onoff)(struct mmp_path *path, int status);
	struct mmp_overlay_ops *overlay_ops;
	void *plat_data;
};

extern struct mmp_path *mmp_register_path(
		struct mmp_path_info *info);
extern void mmp_unregister_path(struct mmp_path *path);
extern void mmp_register_panel(struct mmp_panel *panel);
extern void mmp_unregister_panel(struct mmp_panel *panel);

/* defintions for platform data */
/* interface for buffer driver */
struct mmp_buffer_driver_mach_info {
	const char	*name;
	const char	*path_name;
	int	overlay_id;
	int	dmafetch_id;
	int	default_pixfmt;
};

/* interface for controllers driver */
struct mmp_mach_path_config {
	const char *name;
	int overlay_num;
	int output_type;
	u32 path_config;
	u32 link_config;
	u32 dsi_rbswap;
};

struct mmp_mach_plat_info {
	const char *name;
	const char *clk_name;
	int path_num;
	struct mmp_mach_path_config *paths;
};

/* interface for panel drivers */
struct mmp_mach_panel_info {
	const char *name;
	void (*plat_set_onoff)(int status);
	const char *plat_path_name;
};
#endif	/* _MMP_DISP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef __linux_video_edid_h__
#define __linux_video_edid_h__

#include <uapi/video/edid.h>

#ifdef CONFIG_X86
extern struct edid_info edid_info;
#endif
#endif /* __linux_video_edid_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (C) 2016 Texas Instruments, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef __OMAPFB_DSS_H
#define __OMAPFB_DSS_H

#include <linux/list.h>
#include <linux/kobject.h>
#include <linux/device.h>
#include <linux/interrupt.h>
#include <linux/platform_data/omapdss.h>

#include <video/videomode.h>

#define DISPC_IRQ_FRAMEDONE		(1 << 0)
#define DISPC_IRQ_VSYNC			(1 << 1)
#define DISPC_IRQ_EVSYNC_EVEN		(1 << 2)
#define DISPC_IRQ_EVSYNC_ODD		(1 << 3)
#define DISPC_IRQ_ACBIAS_COUNT_STAT	(1 << 4)
#define DISPC_IRQ_PROG_LINE_NUM		(1 << 5)
#define DISPC_IRQ_GFX_FIFO_UNDERFLOW	(1 << 6)
#define DISPC_IRQ_GFX_END_WIN		(1 << 7)
#define DISPC_IRQ_PAL_GAMMA_MASK	(1 << 8)
#define DISPC_IRQ_OCP_ERR		(1 << 9)
#define DISPC_IRQ_VID1_FIFO_UNDERFLOW	(1 << 10)
#define DISPC_IRQ_VID1_END_WIN		(1 << 11)
#define DISPC_IRQ_VID2_FIFO_UNDERFLOW	(1 << 12)
#define DISPC_IRQ_VID2_END_WIN		(1 << 13)
#define DISPC_IRQ_SYNC_LOST		(1 << 14)
#define DISPC_IRQ_SYNC_LOST_DIGIT	(1 << 15)
#define DISPC_IRQ_WAKEUP		(1 << 16)
#define DISPC_IRQ_SYNC_LOST2		(1 << 17)
#define DISPC_IRQ_VSYNC2		(1 << 18)
#define DISPC_IRQ_VID3_END_WIN		(1 << 19)
#define DISPC_IRQ_VID3_FIFO_UNDERFLOW	(1 << 20)
#define DISPC_IRQ_ACBIAS_COUNT_STAT2	(1 << 21)
#define DISPC_IRQ_FRAMEDONE2		(1 << 22)
#define DISPC_IRQ_FRAMEDONEWB		(1 << 23)
#define DISPC_IRQ_FRAMEDONETV		(1 << 24)
#define DISPC_IRQ_WBBUFFEROVERFLOW	(1 << 25)
#define DISPC_IRQ_WBUNCOMPLETEERROR	(1 << 26)
#define DISPC_IRQ_SYNC_LOST3		(1 << 27)
#define DISPC_IRQ_VSYNC3		(1 << 28)
#define DISPC_IRQ_ACBIAS_COUNT_STAT3	(1 << 29)
#define DISPC_IRQ_FRAMEDONE3		(1 << 30)

struct omap_dss_device;
struct omap_overlay_manager;
struct dss_lcd_mgr_config;
struct snd_aes_iec958;
struct snd_cea_861_aud_if;
struct hdmi_avi_infoframe;

enum omap_display_type {
	OMAP_DISPLAY_TYPE_NONE		= 0,
	OMAP_DISPLAY_TYPE_DPI		= 1 << 0,
	OMAP_DISPLAY_TYPE_DBI		= 1 << 1,
	OMAP_DISPLAY_TYPE_SDI		= 1 << 2,
	OMAP_DISPLAY_TYPE_DSI		= 1 << 3,
	OMAP_DISPLAY_TYPE_VENC		= 1 << 4,
	OMAP_DISPLAY_TYPE_HDMI		= 1 << 5,
	OMAP_DISPLAY_TYPE_DVI		= 1 << 6,
};

enum omap_plane {
	OMAP_DSS_GFX	= 0,
	OMAP_DSS_VIDEO1	= 1,
	OMAP_DSS_VIDEO2	= 2,
	OMAP_DSS_VIDEO3	= 3,
	OMAP_DSS_WB	= 4,
};

enum omap_channel {
	OMAP_DSS_CHANNEL_LCD	= 0,
	OMAP_DSS_CHANNEL_DIGIT	= 1,
	OMAP_DSS_CHANNEL_LCD2	= 2,
	OMAP_DSS_CHANNEL_LCD3	= 3,
	OMAP_DSS_CHANNEL_WB	= 4,
};

enum omap_color_mode {
	OMAP_DSS_COLOR_CLUT1	= 1 << 0,  /* BITMAP 1 */
	OMAP_DSS_COLOR_CLUT2	= 1 << 1,  /* BITMAP 2 */
	OMAP_DSS_COLOR_CLUT4	= 1 << 2,  /* BITMAP 4 */
	OMAP_DSS_COLOR_CLUT8	= 1 << 3,  /* BITMAP 8 */
	OMAP_DSS_COLOR_RGB12U	= 1 << 4,  /* RGB12, 16-bit container */
	OMAP_DSS_COLOR_ARGB16	= 1 << 5,  /* ARGB16 */
	OMAP_DSS_COLOR_RGB16	= 1 << 6,  /* RGB16 */
	OMAP_DSS_COLOR_RGB24U	= 1 << 7,  /* RGB24, 32-bit container */
	OMAP_DSS_COLOR_RGB24P	= 1 << 8,  /* RGB24, 24-bit container */
	OMAP_DSS_COLOR_YUV2	= 1 << 9,  /* YUV2 4:2:2 co-sited */
	OMAP_DSS_COLOR_UYVY	= 1 << 10, /* UYVY 4:2:2 co-sited */
	OMAP_DSS_COLOR_ARGB32	= 1 << 11, /* ARGB32 */
	OMAP_DSS_COLOR_RGBA32	= 1 << 12, /* RGBA32 */
	OMAP_DSS_COLOR_RGBX32	= 1 << 13, /* RGBx32 */
	OMAP_DSS_COLOR_NV12		= 1 << 14, /* NV12 format: YUV 4:2:0 */
	OMAP_DSS_COLOR_RGBA16		= 1 << 15, /* RGBA16 - 4444 */
	OMAP_DSS_COLOR_RGBX16		= 1 << 16, /* RGBx16 - 4444 */
	OMAP_DSS_COLOR_ARGB16_1555	= 1 << 17, /* ARGB16 - 1555 */
	OMAP_DSS_COLOR_XRGB16_1555	= 1 << 18, /* xRGB16 - 1555 */
};

enum omap_dss_load_mode {
	OMAP_DSS_LOAD_CLUT_AND_FRAME	= 0,
	OMAP_DSS_LOAD_CLUT_ONLY		= 1,
	OMAP_DSS_LOAD_FRAME_ONLY	= 2,
	OMAP_DSS_LOAD_CLUT_ONCE_FRAME	= 3,
};

enum omap_dss_trans_key_type {
	OMAP_DSS_COLOR_KEY_GFX_DST = 0,
	OMAP_DSS_COLOR_KEY_VID_SRC = 1,
};

enum omap_rfbi_te_mode {
	OMAP_DSS_RFBI_TE_MODE_1 = 1,
	OMAP_DSS_RFBI_TE_MODE_2 = 2,
};

enum omap_dss_signal_level {
	OMAPDSS_SIG_ACTIVE_LOW,
	OMAPDSS_SIG_ACTIVE_HIGH,
};

enum omap_dss_signal_edge {
	OMAPDSS_DRIVE_SIG_FALLING_EDGE,
	OMAPDSS_DRIVE_SIG_RISING_EDGE,
};

enum omap_dss_venc_type {
	OMAP_DSS_VENC_TYPE_COMPOSITE,
	OMAP_DSS_VENC_TYPE_SVIDEO,
};

enum omap_dss_dsi_pixel_format {
	OMAP_DSS_DSI_FMT_RGB888,
	OMAP_DSS_DSI_FMT_RGB666,
	OMAP_DSS_DSI_FMT_RGB666_PACKED,
	OMAP_DSS_DSI_FMT_RGB565,
};

enum omap_dss_dsi_mode {
	OMAP_DSS_DSI_CMD_MODE = 0,
	OMAP_DSS_DSI_VIDEO_MODE,
};

enum omap_display_caps {
	OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE	= 1 << 0,
	OMAP_DSS_DISPLAY_CAP_TEAR_ELIM		= 1 << 1,
};

enum omap_dss_display_state {
	OMAP_DSS_DISPLAY_DISABLED = 0,
	OMAP_DSS_DISPLAY_ACTIVE,
};

enum omap_dss_rotation_type {
	OMAP_DSS_ROT_DMA	= 1 << 0,
	OMAP_DSS_ROT_VRFB	= 1 << 1,
	OMAP_DSS_ROT_TILER	= 1 << 2,
};

/* clockwise rotation angle */
enum omap_dss_rotation_angle {
	OMAP_DSS_ROT_0   = 0,
	OMAP_DSS_ROT_90  = 1,
	OMAP_DSS_ROT_180 = 2,
	OMAP_DSS_ROT_270 = 3,
};

enum omap_overlay_caps {
	OMAP_DSS_OVL_CAP_SCALE = 1 << 0,
	OMAP_DSS_OVL_CAP_GLOBAL_ALPHA = 1 << 1,
	OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA = 1 << 2,
	OMAP_DSS_OVL_CAP_ZORDER = 1 << 3,
	OMAP_DSS_OVL_CAP_POS = 1 << 4,
	OMAP_DSS_OVL_CAP_REPLICATION = 1 << 5,
};

enum omap_dss_output_id {
	OMAP_DSS_OUTPUT_DPI	= 1 << 0,
	OMAP_DSS_OUTPUT_DBI	= 1 << 1,
	OMAP_DSS_OUTPUT_SDI	= 1 << 2,
	OMAP_DSS_OUTPUT_DSI1	= 1 << 3,
	OMAP_DSS_OUTPUT_DSI2	= 1 << 4,
	OMAP_DSS_OUTPUT_VENC	= 1 << 5,
	OMAP_DSS_OUTPUT_HDMI	= 1 << 6,
};

/* RFBI */

struct rfbi_timings {
	int cs_on_time;
	int cs_off_time;
	int we_on_time;
	int we_off_time;
	int re_on_time;
	int re_off_time;
	int we_cycle_time;
	int re_cycle_time;
	int cs_pulse_width;
	int access_time;

	int clk_div;

	u32 tim[5];             /* set by rfbi_convert_timings() */

	int converted;
};

/* DSI */

enum omap_dss_dsi_trans_mode {
	/* Sync Pulses: both sync start and end packets sent */
	OMAP_DSS_DSI_PULSE_MODE,
	/* Sync Events: only sync start packets sent */
	OMAP_DSS_DSI_EVENT_MODE,
	/* Burst: only sync start packets sent, pixels are time compressed */
	OMAP_DSS_DSI_BURST_MODE,
};

struct omap_dss_dsi_videomode_timings {
	unsigned long hsclk;

	unsigned ndl;
	unsigned bitspp;

	/* pixels */
	u16 hact;
	/* lines */
	u16 vact;

	/* DSI video mode blanking data */
	/* Unit: byte clock cycles */
	u16 hss;
	u16 hsa;
	u16 hse;
	u16 hfp;
	u16 hbp;
	/* Unit: line clocks */
	u16 vsa;
	u16 vfp;
	u16 vbp;

	/* DSI blanking modes */
	int blanking_mode;
	int hsa_blanking_mode;
	int hbp_blanking_mode;
	int hfp_blanking_mode;

	enum omap_dss_dsi_trans_mode trans_mode;

	bool ddr_clk_always_on;
	int window_sync;
};

struct omap_dss_dsi_config {
	enum omap_dss_dsi_mode mode;
	enum omap_dss_dsi_pixel_format pixel_format;
	const struct omap_video_timings *timings;

	unsigned long hs_clk_min, hs_clk_max;
	unsigned long lp_clk_min, lp_clk_max;

	bool ddr_clk_always_on;
	enum omap_dss_dsi_trans_mode trans_mode;
};

struct omap_video_timings {
	/* Unit: pixels */
	u16 x_res;
	/* Unit: pixels */
	u16 y_res;
	/* Unit: Hz */
	u32 pixelclock;
	/* Unit: pixel clocks */
	u16 hsw;	/* Horizontal synchronization pulse width */
	/* Unit: pixel clocks */
	u16 hfp;	/* Horizontal front porch */
	/* Unit: pixel clocks */
	u16 hbp;	/* Horizontal back porch */
	/* Unit: line clocks */
	u16 vsw;	/* Vertical synchronization pulse width */
	/* Unit: line clocks */
	u16 vfp;	/* Vertical front porch */
	/* Unit: line clocks */
	u16 vbp;	/* Vertical back porch */

	/* Vsync logic level */
	enum omap_dss_signal_level vsync_level;
	/* Hsync logic level */
	enum omap_dss_signal_level hsync_level;
	/* Interlaced or Progressive timings */
	bool interlace;
	/* Pixel clock edge to drive LCD data */
	enum omap_dss_signal_edge data_pclk_edge;
	/* Data enable logic level */
	enum omap_dss_signal_level de_level;
	/* Pixel clock edges to drive HSYNC and VSYNC signals */
	enum omap_dss_signal_edge sync_pclk_edge;

	bool double_pixel;
};

/* Hardcoded timings for tv modes. Venc only uses these to
 * identify the mode, and does not actually use the configs
 * itself. However, the configs should be something that
 * a normal monitor can also show */
extern const struct omap_video_timings omap_dss_pal_timings;
extern const struct omap_video_timings omap_dss_ntsc_timings;

struct omap_dss_cpr_coefs {
	s16 rr, rg, rb;
	s16 gr, gg, gb;
	s16 br, bg, bb;
};

struct omap_overlay_info {
	dma_addr_t paddr;
	dma_addr_t p_uv_addr;  /* for NV12 format */
	u16 screen_width;
	u16 width;
	u16 height;
	enum omap_color_mode color_mode;
	u8 rotation;
	enum omap_dss_rotation_type rotation_type;
	bool mirror;

	u16 pos_x;
	u16 pos_y;
	u16 out_width;	/* if 0, out_width == width */
	u16 out_height;	/* if 0, out_height == height */
	u8 global_alpha;
	u8 pre_mult_alpha;
	u8 zorder;
};

struct omap_overlay {
	struct kobject kobj;
	struct list_head list;

	/* static fields */
	const char *name;
	enum omap_plane id;
	enum omap_color_mode supported_modes;
	enum omap_overlay_caps caps;

	/* dynamic fields */
	struct omap_overlay_manager *manager;

	/*
	 * The following functions do not block:
	 *
	 * is_enabled
	 * set_overlay_info
	 * get_overlay_info
	 *
	 * The rest of the functions may block and cannot be called from
	 * interrupt context
	 */

	int (*enable)(struct omap_overlay *ovl);
	int (*disable)(struct omap_overlay *ovl);
	bool (*is_enabled)(struct omap_overlay *ovl);

	int (*set_manager)(struct omap_overlay *ovl,
		struct omap_overlay_manager *mgr);
	int (*unset_manager)(struct omap_overlay *ovl);

	int (*set_overlay_info)(struct omap_overlay *ovl,
			struct omap_overlay_info *info);
	void (*get_overlay_info)(struct omap_overlay *ovl,
			struct omap_overlay_info *info);

	int (*wait_for_go)(struct omap_overlay *ovl);

	struct omap_dss_device *(*get_device)(struct omap_overlay *ovl);
};

struct omap_overlay_manager_info {
	u32 default_color;

	enum omap_dss_trans_key_type trans_key_type;
	u32 trans_key;
	bool trans_enabled;

	bool partial_alpha_enabled;

	bool cpr_enable;
	struct omap_dss_cpr_coefs cpr_coefs;
};

struct omap_overlay_manager {
	struct kobject kobj;

	/* static fields */
	const char *name;
	enum omap_channel id;
	struct list_head overlays;
	enum omap_display_type supported_displays;
	enum omap_dss_output_id supported_outputs;

	/* dynamic fields */
	struct omap_dss_device *output;

	/*
	 * The following functions do not block:
	 *
	 * set_manager_info
	 * get_manager_info
	 * apply
	 *
	 * The rest of the functions may block and cannot be called from
	 * interrupt context
	 */

	int (*set_output)(struct omap_overlay_manager *mgr,
		struct omap_dss_device *output);
	int (*unset_output)(struct omap_overlay_manager *mgr);

	int (*set_manager_info)(struct omap_overlay_manager *mgr,
			struct omap_overlay_manager_info *info);
	void (*get_manager_info)(struct omap_overlay_manager *mgr,
			struct omap_overlay_manager_info *info);

	int (*apply)(struct omap_overlay_manager *mgr);
	int (*wait_for_go)(struct omap_overlay_manager *mgr);
	int (*wait_for_vsync)(struct omap_overlay_manager *mgr);

	struct omap_dss_device *(*get_device)(struct omap_overlay_manager *mgr);
};

/* 22 pins means 1 clk lane and 10 data lanes */
#define OMAP_DSS_MAX_DSI_PINS 22

struct omap_dsi_pin_config {
	int num_pins;
	/*
	 * pin numbers in the following order:
	 * clk+, clk-
	 * data1+, data1-
	 * data2+, data2-
	 * ...
	 */
	int pins[OMAP_DSS_MAX_DSI_PINS];
};

struct omap_dss_writeback_info {
	u32 paddr;
	u32 p_uv_addr;
	u16 buf_width;
	u16 width;
	u16 height;
	enum omap_color_mode color_mode;
	u8 rotation;
	enum omap_dss_rotation_type rotation_type;
	bool mirror;
	u8 pre_mult_alpha;
};

struct omapdss_dpi_ops {
	int (*connect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);
	void (*disconnect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);

	int (*enable)(struct omap_dss_device *dssdev);
	void (*disable)(struct omap_dss_device *dssdev);

	int (*check_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*set_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*get_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);

	void (*set_data_lines)(struct omap_dss_device *dssdev, int data_lines);
};

struct omapdss_sdi_ops {
	int (*connect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);
	void (*disconnect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);

	int (*enable)(struct omap_dss_device *dssdev);
	void (*disable)(struct omap_dss_device *dssdev);

	int (*check_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*set_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*get_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);

	void (*set_datapairs)(struct omap_dss_device *dssdev, int datapairs);
};

struct omapdss_dvi_ops {
	int (*connect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);
	void (*disconnect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);

	int (*enable)(struct omap_dss_device *dssdev);
	void (*disable)(struct omap_dss_device *dssdev);

	int (*check_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*set_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*get_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
};

struct omapdss_atv_ops {
	int (*connect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);
	void (*disconnect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);

	int (*enable)(struct omap_dss_device *dssdev);
	void (*disable)(struct omap_dss_device *dssdev);

	int (*check_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*set_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*get_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);

	void (*set_type)(struct omap_dss_device *dssdev,
		enum omap_dss_venc_type type);
	void (*invert_vid_out_polarity)(struct omap_dss_device *dssdev,
		bool invert_polarity);

	int (*set_wss)(struct omap_dss_device *dssdev, u32 wss);
	u32 (*get_wss)(struct omap_dss_device *dssdev);
};

struct omapdss_hdmi_ops {
	int (*connect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);
	void (*disconnect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);

	int (*enable)(struct omap_dss_device *dssdev);
	void (*disable)(struct omap_dss_device *dssdev);

	int (*check_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*set_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*get_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);

	int (*read_edid)(struct omap_dss_device *dssdev, u8 *buf, int len);
	bool (*detect)(struct omap_dss_device *dssdev);

	int (*set_hdmi_mode)(struct omap_dss_device *dssdev, bool hdmi_mode);
	int (*set_infoframe)(struct omap_dss_device *dssdev,
		const struct hdmi_avi_infoframe *avi);
};

struct omapdss_dsi_ops {
	int (*connect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);
	void (*disconnect)(struct omap_dss_device *dssdev,
			struct omap_dss_device *dst);

	int (*enable)(struct omap_dss_device *dssdev);
	void (*disable)(struct omap_dss_device *dssdev, bool disconnect_lanes,
			bool enter_ulps);

	/* bus configuration */
	int (*set_config)(struct omap_dss_device *dssdev,
			const struct omap_dss_dsi_config *cfg);
	int (*configure_pins)(struct omap_dss_device *dssdev,
			const struct omap_dsi_pin_config *pin_cfg);

	void (*enable_hs)(struct omap_dss_device *dssdev, int channel,
			bool enable);
	int (*enable_te)(struct omap_dss_device *dssdev, bool enable);

	int (*update)(struct omap_dss_device *dssdev, int channel,
			void (*callback)(int, void *), void *data);

	void (*bus_lock)(struct omap_dss_device *dssdev);
	void (*bus_unlock)(struct omap_dss_device *dssdev);

	int (*enable_video_output)(struct omap_dss_device *dssdev, int channel);
	void (*disable_video_output)(struct omap_dss_device *dssdev,
			int channel);

	int (*request_vc)(struct omap_dss_device *dssdev, int *channel);
	int (*set_vc_id)(struct omap_dss_device *dssdev, int channel,
			int vc_id);
	void (*release_vc)(struct omap_dss_device *dssdev, int channel);

	/* data transfer */
	int (*dcs_write)(struct omap_dss_device *dssdev, int channel,
			u8 *data, int len);
	int (*dcs_write_nosync)(struct omap_dss_device *dssdev, int channel,
			u8 *data, int len);
	int (*dcs_read)(struct omap_dss_device *dssdev, int channel, u8 dcs_cmd,
			u8 *data, int len);

	int (*gen_write)(struct omap_dss_device *dssdev, int channel,
			u8 *data, int len);
	int (*gen_write_nosync)(struct omap_dss_device *dssdev, int channel,
			u8 *data, int len);
	int (*gen_read)(struct omap_dss_device *dssdev, int channel,
			u8 *reqdata, int reqlen,
			u8 *data, int len);

	int (*bta_sync)(struct omap_dss_device *dssdev, int channel);

	int (*set_max_rx_packet_size)(struct omap_dss_device *dssdev,
			int channel, u16 plen);
};

struct omap_dss_device {
	struct kobject kobj;
	struct device *dev;

	struct module *owner;

	struct list_head panel_list;

	/* alias in the form of "display%d" */
	char alias[16];

	enum omap_display_type type;
	enum omap_display_type output_type;

	union {
		struct {
			u8 data_lines;
		} dpi;

		struct {
			u8 channel;
			u8 data_lines;
		} rfbi;

		struct {
			u8 datapairs;
		} sdi;

		struct {
			int module;
		} dsi;

		struct {
			enum omap_dss_venc_type type;
			bool invert_polarity;
		} venc;
	} phy;

	struct {
		struct omap_video_timings timings;

		enum omap_dss_dsi_pixel_format dsi_pix_fmt;
		enum omap_dss_dsi_mode dsi_mode;
	} panel;

	struct {
		u8 pixel_size;
		struct rfbi_timings rfbi_timings;
	} ctrl;

	const char *name;

	/* used to match device to driver */
	const char *driver_name;

	void *data;

	struct omap_dss_driver *driver;

	union {
		const struct omapdss_dpi_ops *dpi;
		const struct omapdss_sdi_ops *sdi;
		const struct omapdss_dvi_ops *dvi;
		const struct omapdss_hdmi_ops *hdmi;
		const struct omapdss_atv_ops *atv;
		const struct omapdss_dsi_ops *dsi;
	} ops;

	/* helper variable for driver suspend/resume */
	bool activate_after_resume;

	enum omap_display_caps caps;

	struct omap_dss_device *src;

	enum omap_dss_display_state state;

	/* OMAP DSS output specific fields */

	struct list_head list;

	/* DISPC channel for this output */
	enum omap_channel dispc_channel;
	bool dispc_channel_connected;

	/* output instance */
	enum omap_dss_output_id id;

	/* the port number in the DT node */
	int port_num;

	/* dynamic fields */
	struct omap_overlay_manager *manager;

	struct omap_dss_device *dst;
};

struct omap_dss_driver {
	int (*probe)(struct omap_dss_device *);
	void (*remove)(struct omap_dss_device *);

	int (*connect)(struct omap_dss_device *dssdev);
	void (*disconnect)(struct omap_dss_device *dssdev);

	int (*enable)(struct omap_dss_device *display);
	void (*disable)(struct omap_dss_device *display);
	int (*run_test)(struct omap_dss_device *display, int test);

	int (*update)(struct omap_dss_device *dssdev,
			       u16 x, u16 y, u16 w, u16 h);
	int (*sync)(struct omap_dss_device *dssdev);

	int (*enable_te)(struct omap_dss_device *dssdev, bool enable);
	int (*get_te)(struct omap_dss_device *dssdev);

	u8 (*get_rotate)(struct omap_dss_device *dssdev);
	int (*set_rotate)(struct omap_dss_device *dssdev, u8 rotate);

	bool (*get_mirror)(struct omap_dss_device *dssdev);
	int (*set_mirror)(struct omap_dss_device *dssdev, bool enable);

	int (*memory_read)(struct omap_dss_device *dssdev,
			void *buf, size_t size,
			u16 x, u16 y, u16 w, u16 h);

	void (*get_resolution)(struct omap_dss_device *dssdev,
			u16 *xres, u16 *yres);
	void (*get_dimensions)(struct omap_dss_device *dssdev,
			u32 *width, u32 *height);
	int (*get_recommended_bpp)(struct omap_dss_device *dssdev);

	int (*check_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*set_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);
	void (*get_timings)(struct omap_dss_device *dssdev,
			struct omap_video_timings *timings);

	int (*set_wss)(struct omap_dss_device *dssdev, u32 wss);
	u32 (*get_wss)(struct omap_dss_device *dssdev);

	int (*read_edid)(struct omap_dss_device *dssdev, u8 *buf, int len);
	bool (*detect)(struct omap_dss_device *dssdev);

	int (*set_hdmi_mode)(struct omap_dss_device *dssdev, bool hdmi_mode);
	int (*set_hdmi_infoframe)(struct omap_dss_device *dssdev,
		const struct hdmi_avi_infoframe *avi);
};

enum omapdss_version omapdss_get_version(void);
bool omapdss_is_initialized(void);

int omap_dss_register_driver(struct omap_dss_driver *);
void omap_dss_unregister_driver(struct omap_dss_driver *);

int omapdss_register_display(struct omap_dss_device *dssdev);
void omapdss_unregister_display(struct omap_dss_device *dssdev);

struct omap_dss_device *omap_dss_get_device(struct omap_dss_device *dssdev);
void omap_dss_put_device(struct omap_dss_device *dssdev);
#define for_each_dss_dev(d) while ((d = omap_dss_get_next_device(d)) != NULL)
struct omap_dss_device *omap_dss_get_next_device(struct omap_dss_device *from);
struct omap_dss_device *omap_dss_find_device(void *data,
		int (*match)(struct omap_dss_device *dssdev, void *data));
const char *omapdss_get_default_display_name(void);

void videomode_to_omap_video_timings(const struct videomode *vm,
		struct omap_video_timings *ovt);
void omap_video_timings_to_videomode(const struct omap_video_timings *ovt,
		struct videomode *vm);

int dss_feat_get_num_mgrs(void);
int dss_feat_get_num_ovls(void);
enum omap_color_mode dss_feat_get_supported_color_modes(enum omap_plane plane);



int omap_dss_get_num_overlay_managers(void);
struct omap_overlay_manager *omap_dss_get_overlay_manager(int num);

int omap_dss_get_num_overlays(void);
struct omap_overlay *omap_dss_get_overlay(int num);

int omapdss_register_output(struct omap_dss_device *output);
void omapdss_unregister_output(struct omap_dss_device *output);
struct omap_dss_device *omap_dss_get_output(enum omap_dss_output_id id);
struct omap_dss_device *omap_dss_find_output(const char *name);
struct omap_dss_device *omap_dss_find_output_by_port_node(struct device_node *port);
int omapdss_output_set_device(struct omap_dss_device *out,
		struct omap_dss_device *dssdev);
int omapdss_output_unset_device(struct omap_dss_device *out);

struct omap_dss_device *omapdss_find_output_from_display(struct omap_dss_device *dssdev);
struct omap_overlay_manager *omapdss_find_mgr_from_display(struct omap_dss_device *dssdev);

void omapdss_default_get_resolution(struct omap_dss_device *dssdev,
		u16 *xres, u16 *yres);
int omapdss_default_get_recommended_bpp(struct omap_dss_device *dssdev);
void omapdss_default_get_timings(struct omap_dss_device *dssdev,
		struct omap_video_timings *timings);

typedef void (*omap_dispc_isr_t) (void *arg, u32 mask);
int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask);
int omap_dispc_unregister_isr(omap_dispc_isr_t isr, void *arg, u32 mask);

int omapdss_compat_init(void);
void omapdss_compat_uninit(void);

static inline bool omapdss_device_is_connected(struct omap_dss_device *dssdev)
{
	return dssdev->src;
}

static inline bool omapdss_device_is_enabled(struct omap_dss_device *dssdev)
{
	return dssdev->state == OMAP_DSS_DISPLAY_ACTIVE;
}

struct device_node *
omapdss_of_get_next_port(const struct device_node *parent,
			 struct device_node *prev);

struct device_node *
omapdss_of_get_next_endpoint(const struct device_node *parent,
			     struct device_node *prev);

struct device_node *
omapdss_of_get_first_endpoint(const struct device_node *parent);

struct omap_dss_device *
omapdss_of_find_source_for_first_ep(struct device_node *node);

#endif /* __OMAPFB_DSS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * sisfb.h - definitions for the SiS framebuffer driver
 *
 * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the named License,
 * or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
 */
#ifndef _LINUX_SISFB_H_
#define _LINUX_SISFB_H_


#include <linux/pci.h>
#include <uapi/video/sisfb.h>

#define	UNKNOWN_VGA  0
#define	SIS_300_VGA  1
#define	SIS_315_VGA  2

#define SISFB_HAVE_MALLOC_NEW
extern void sis_malloc(struct sis_memreq *req);
extern void sis_malloc_new(struct pci_dev *pdev, struct sis_memreq *req);

extern void sis_free(u32 base);
extern void sis_free_new(struct pci_dev *pdev, u32 base);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * linux/include/video/neo_reg.h -- NeoMagic Framebuffer Driver
 *
 * Copyright (c) 2001  Denis Oliver Kropp <dok@convergence.de>
 *
 * This file is subject to the terms and conditions of the GNU General
 * Public License.  See the file COPYING in the main directory of this
 * archive for more details.
 */

#define NEO_BS0_BLT_BUSY        0x00000001
#define NEO_BS0_FIFO_AVAIL      0x00000002
#define NEO_BS0_FIFO_PEND       0x00000004

#define NEO_BC0_DST_Y_DEC       0x00000001
#define NEO_BC0_X_DEC           0x00000002
#define NEO_BC0_SRC_TRANS       0x00000004
#define NEO_BC0_SRC_IS_FG       0x00000008
#define NEO_BC0_SRC_Y_DEC       0x00000010
#define NEO_BC0_FILL_PAT        0x00000020
#define NEO_BC0_SRC_MONO        0x00000040
#define NEO_BC0_SYS_TO_VID      0x00000080

#define NEO_BC1_DEPTH8          0x00000100
#define NEO_BC1_DEPTH16         0x00000200
#define NEO_BC1_X_320           0x00000400
#define NEO_BC1_X_640           0x00000800
#define NEO_BC1_X_800           0x00000c00
#define NEO_BC1_X_1024          0x00001000
#define NEO_BC1_X_1152          0x00001400
#define NEO_BC1_X_1280          0x00001800
#define NEO_BC1_X_1600          0x00001c00
#define NEO_BC1_DST_TRANS       0x00002000
#define NEO_BC1_MSTR_BLT        0x00004000
#define NEO_BC1_FILTER_Z        0x00008000

#define NEO_BC2_WR_TR_DST       0x00800000

#define NEO_BC3_SRC_XY_ADDR     0x01000000
#define NEO_BC3_DST_XY_ADDR     0x02000000
#define NEO_BC3_CLIP_ON         0x04000000
#define NEO_BC3_FIFO_EN         0x08000000
#define NEO_BC3_BLT_ON_ADDR     0x10000000
#define NEO_BC3_SKIP_MAPPING    0x80000000

#define NEO_MODE1_DEPTH8        0x0100
#define NEO_MODE1_DEPTH16       0x0200
#define NEO_MODE1_DEPTH24       0x0300
#define NEO_MODE1_X_320         0x0400
#define NEO_MODE1_X_640         0x0800
#define NEO_MODE1_X_800         0x0c00
#define NEO_MODE1_X_1024        0x1000
#define NEO_MODE1_X_1152        0x1400
#define NEO_MODE1_X_1280        0x1800
#define NEO_MODE1_X_1600        0x1c00
#define NEO_MODE1_BLT_ON_ADDR   0x2000

/* These are offseted in MMIO space by par->CursorOff */
#define NEOREG_CURSCNTL		0x00
#define NEOREG_CURSX		0x04
#define NEOREG_CURSY		0x08
#define NEOREG_CURSBGCOLOR	0x0C
#define NEOREG_CURSFGCOLOR	0x10
#define NEOREG_CURSMEMPOS	0x14

#define NEO_CURS_DISABLE	0x00000000
#define NEO_CURS_ENABLE		0x00000001
#define NEO_ICON64_ENABLE	0x00000008
#define NEO_ICON128_ENABLE	0x0000000C
#define NEO_ICON_BLANK		0x00000010

#define NEO_GR01_SUPPRESS_VSYNC 0x10
#define NEO_GR01_SUPPRESS_HSYNC 0x20

#ifdef __KERNEL__

#ifdef NEOFB_DEBUG
# define DBG(x)		printk (KERN_DEBUG "neofb: %s\n", (x));
#else
# define DBG(x)
#endif

#define PCI_CHIP_NM2070 0x0001
#define PCI_CHIP_NM2090 0x0002
#define PCI_CHIP_NM2093 0x0003
#define PCI_CHIP_NM2097 0x0083
#define PCI_CHIP_NM2160 0x0004
#define PCI_CHIP_NM2200 0x0005
#define PCI_CHIP_NM2230 0x0025
#define PCI_CHIP_NM2360 0x0006
#define PCI_CHIP_NM2380 0x0016

/* --------------------------------------------------------------------- */

typedef volatile struct {
	__u32 bltStat;
	__u32 bltCntl;
	__u32 xpColor;
	__u32 fgColor;
	__u32 bgColor;
	__u32 pitch;
	__u32 clipLT;
	__u32 clipRB;
	__u32 srcBitOffset;
	__u32 srcStart;
	__u32 reserved0;
	__u32 dstStart;
	__u32 xyExt;

	__u32 reserved1[19];

	__u32 pageCntl;
	__u32 pageBase;
	__u32 postBase;
	__u32 postPtr;
	__u32 dataPtr;
} Neo2200;

#define MMIO_SIZE 0x200000

#define NEO_EXT_CR_MAX 0x85
#define NEO_EXT_GR_MAX 0xC7

struct neofb_par {
	struct vgastate state;
	unsigned int ref_count;

	unsigned char MiscOutReg;	/* Misc */
	unsigned char CRTC[25];		/* Crtc Controller */
	unsigned char Sequencer[5];	/* Video Sequencer */
	unsigned char Graphics[9];	/* Video Graphics */
	unsigned char Attribute[21];	/* Video Attribute */

	unsigned char GeneralLockReg;
	unsigned char ExtCRTDispAddr;
	unsigned char ExtCRTOffset;
	unsigned char SysIfaceCntl1;
	unsigned char SysIfaceCntl2;
	unsigned char ExtColorModeSelect;
	unsigned char biosMode;

	unsigned char PanelDispCntlReg1;
	unsigned char PanelDispCntlReg2;
	unsigned char PanelDispCntlReg3;
	unsigned char PanelDispCntlRegRead;
	unsigned char PanelVertCenterReg1;
	unsigned char PanelVertCenterReg2;
	unsigned char PanelVertCenterReg3;
	unsigned char PanelVertCenterReg4;
	unsigned char PanelVertCenterReg5;
	unsigned char PanelHorizCenterReg1;
	unsigned char PanelHorizCenterReg2;
	unsigned char PanelHorizCenterReg3;
	unsigned char PanelHorizCenterReg4;
	unsigned char PanelHorizCenterReg5;

	int ProgramVCLK;
	unsigned char VCLK3NumeratorLow;
	unsigned char VCLK3NumeratorHigh;
	unsigned char VCLK3Denominator;
	unsigned char VerticalExt;
	int wc_cookie;
	u8 __iomem *mmio_vbase;
	u8 cursorOff;
	u8 *cursorPad;		/* Must die !! */

	Neo2200 __iomem *neo2200;

	/* Panels size */
	int NeoPanelWidth;
	int NeoPanelHeight;

	int maxClock;

	int pci_burst;
	int lcd_stretch;
	int internal_display;
	int external_display;
	int libretto;
	u32 palette[16];
};

typedef struct {
	int x_res;
	int y_res;
	int mode;
} biosMode;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *	linux/include/video/pmag-ba-fb.h
 *
 *	TURBOchannel PMAG-BA Color Frame Buffer (CFB) card support,
 *	Copyright (C) 1999, 2000, 2001 by
 *	Michael Engel <engel@unix-ag.org>,
 *	Karsten Merker <merker@linuxtag.org>
 *	Copyright (c) 2005  Maciej W. Rozycki
 *
 *	This file is subject to the terms and conditions of the GNU General
 *	Public License.  See the file COPYING in the main directory of this
 *	archive for more details.
 */

/* IOmem resource offsets.  */
#define PMAG_BA_FBMEM		0x000000	/* frame buffer */
#define PMAG_BA_BT459		0x200000	/* Bt459 RAMDAC */
#define PMAG_BA_IRQ		0x300000	/* IRQ acknowledge */
#define PMAG_BA_ROM		0x380000	/* REX option ROM */
#define PMAG_BA_BT438		0x380000	/* Bt438 clock chip reset */
#define PMAG_BA_SIZE		0x400000	/* address space size */

/* Bt459 register offsets, byte-wide registers.  */
#define BT459_ADDR_LO		0x0		/* address low */
#define BT459_ADDR_HI		0x4		/* address high */
#define BT459_DATA		0x8		/* data window register */
#define BT459_CMAP		0xc		/* color map window register */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*  $Id: aty128.h,v 1.1 1999/10/12 11:00:40 geert Exp $
 *  linux/drivers/video/aty128.h
 *  Register definitions for ATI Rage128 boards
 *
 *  Anthony Tong <atong@uiuc.edu>, 1999
 *  Brad Douglas <brad@neruo.com>, 2000
 */

#ifndef REG_RAGE128_H
#define REG_RAGE128_H

#define CLOCK_CNTL_INDEX			0x0008
#define CLOCK_CNTL_DATA				0x000c
#define BIOS_0_SCRATCH				0x0010
#define BUS_CNTL				0x0030
#define BUS_CNTL1				0x0034
#define GEN_INT_CNTL				0x0040
#define CRTC_GEN_CNTL				0x0050
#define CRTC_EXT_CNTL				0x0054
#define DAC_CNTL				0x0058
#define I2C_CNTL_1				0x0094
#define PALETTE_INDEX				0x00b0
#define PALETTE_DATA				0x00b4
#define CNFG_CNTL				0x00e0
#define GEN_RESET_CNTL				0x00f0
#define CNFG_MEMSIZE				0x00f8
#define MEM_CNTL				0x0140
#define MEM_POWER_MISC				0x015c
#define AGP_BASE				0x0170
#define AGP_CNTL				0x0174
#define AGP_APER_OFFSET				0x0178
#define PCI_GART_PAGE				0x017c
#define PC_NGUI_MODE				0x0180
#define PC_NGUI_CTLSTAT				0x0184
#define MPP_TB_CONFIG				0x01C0
#define MPP_GP_CONFIG				0x01C8
#define VIPH_CONTROL				0x01D0
#define CRTC_H_TOTAL_DISP			0x0200
#define CRTC_H_SYNC_STRT_WID			0x0204
#define CRTC_V_TOTAL_DISP			0x0208
#define CRTC_V_SYNC_STRT_WID			0x020c
#define CRTC_VLINE_CRNT_VLINE			0x0210
#define CRTC_CRNT_FRAME				0x0214
#define CRTC_GUI_TRIG_VLINE			0x0218
#define CRTC_OFFSET				0x0224
#define CRTC_OFFSET_CNTL			0x0228
#define CRTC_PITCH				0x022c
#define OVR_CLR					0x0230
#define OVR_WID_LEFT_RIGHT			0x0234
#define OVR_WID_TOP_BOTTOM			0x0238
#define LVDS_GEN_CNTL				0x02d0
#define DDA_CONFIG				0x02e0
#define DDA_ON_OFF				0x02e4
#define VGA_DDA_CONFIG				0x02e8
#define VGA_DDA_ON_OFF				0x02ec
#define CRTC2_H_TOTAL_DISP			0x0300
#define CRTC2_H_SYNC_STRT_WID			0x0304
#define CRTC2_V_TOTAL_DISP			0x0308
#define CRTC2_V_SYNC_STRT_WID			0x030c
#define CRTC2_VLINE_CRNT_VLINE			0x0310
#define CRTC2_CRNT_FRAME			0x0314
#define CRTC2_GUI_TRIG_VLINE			0x0318
#define CRTC2_OFFSET				0x0324
#define CRTC2_OFFSET_CNTL			0x0328
#define CRTC2_PITCH				0x032c
#define DDA2_CONFIG				0x03e0
#define DDA2_ON_OFF				0x03e4
#define CRTC2_GEN_CNTL				0x03f8
#define CRTC2_STATUS				0x03fc
#define OV0_SCALE_CNTL				0x0420
#define SUBPIC_CNTL				0x0540
#define PM4_BUFFER_OFFSET			0x0700
#define PM4_BUFFER_CNTL				0x0704
#define PM4_BUFFER_WM_CNTL			0x0708
#define PM4_BUFFER_DL_RPTR_ADDR			0x070c
#define PM4_BUFFER_DL_RPTR			0x0710
#define PM4_BUFFER_DL_WPTR			0x0714
#define PM4_VC_FPU_SETUP			0x071c
#define PM4_FPU_CNTL				0x0720
#define PM4_VC_FORMAT				0x0724
#define PM4_VC_CNTL				0x0728
#define PM4_VC_I01				0x072c
#define PM4_VC_VLOFF				0x0730
#define PM4_VC_VLSIZE				0x0734
#define PM4_IW_INDOFF				0x0738
#define PM4_IW_INDSIZE				0x073c
#define PM4_FPU_FPX0				0x0740
#define PM4_FPU_FPY0				0x0744
#define PM4_FPU_FPX1				0x0748
#define PM4_FPU_FPY1				0x074c
#define PM4_FPU_FPX2				0x0750
#define PM4_FPU_FPY2				0x0754
#define PM4_FPU_FPY3				0x0758
#define PM4_FPU_FPY4				0x075c
#define PM4_FPU_FPY5				0x0760
#define PM4_FPU_FPY6				0x0764
#define PM4_FPU_FPR				0x0768
#define PM4_FPU_FPG				0x076c
#define PM4_FPU_FPB				0x0770
#define PM4_FPU_FPA				0x0774
#define PM4_FPU_INTXY0				0x0780
#define PM4_FPU_INTXY1				0x0784
#define PM4_FPU_INTXY2				0x0788
#define PM4_FPU_INTARGB				0x078c
#define PM4_FPU_FPTWICEAREA			0x0790
#define PM4_FPU_DMAJOR01			0x0794
#define PM4_FPU_DMAJOR12			0x0798
#define PM4_FPU_DMAJOR02			0x079c
#define PM4_FPU_STAT				0x07a0
#define PM4_STAT				0x07b8
#define PM4_TEST_CNTL				0x07d0
#define PM4_MICROCODE_ADDR			0x07d4
#define PM4_MICROCODE_RADDR			0x07d8
#define PM4_MICROCODE_DATAH			0x07dc
#define PM4_MICROCODE_DATAL			0x07e0
#define PM4_CMDFIFO_ADDR			0x07e4
#define PM4_CMDFIFO_DATAH			0x07e8
#define PM4_CMDFIFO_DATAL			0x07ec
#define PM4_BUFFER_ADDR				0x07f0
#define PM4_BUFFER_DATAH			0x07f4
#define PM4_BUFFER_DATAL			0x07f8
#define PM4_MICRO_CNTL				0x07fc
#define CAP0_TRIG_CNTL				0x0950
#define CAP1_TRIG_CNTL				0x09c0

/******************************************************************************
 *                  GUI Block Memory Mapped Registers                         *
 *                     These registers are FIFOed.                            *
 *****************************************************************************/
#define PM4_FIFO_DATA_EVEN			0x1000
#define PM4_FIFO_DATA_ODD			0x1004

#define DST_OFFSET				0x1404
#define DST_PITCH				0x1408
#define DST_WIDTH				0x140c
#define DST_HEIGHT				0x1410
#define SRC_X					0x1414
#define SRC_Y					0x1418
#define DST_X					0x141c
#define DST_Y					0x1420
#define SRC_PITCH_OFFSET			0x1428
#define DST_PITCH_OFFSET			0x142c
#define SRC_Y_X					0x1434
#define DST_Y_X					0x1438
#define DST_HEIGHT_WIDTH			0x143c
#define DP_GUI_MASTER_CNTL			0x146c
#define BRUSH_SCALE				0x1470
#define BRUSH_Y_X				0x1474
#define DP_BRUSH_BKGD_CLR			0x1478
#define DP_BRUSH_FRGD_CLR			0x147c
#define DST_WIDTH_X				0x1588
#define DST_HEIGHT_WIDTH_8			0x158c
#define SRC_X_Y					0x1590
#define DST_X_Y					0x1594
#define DST_WIDTH_HEIGHT			0x1598
#define DST_WIDTH_X_INCY			0x159c
#define DST_HEIGHT_Y				0x15a0
#define DST_X_SUB				0x15a4
#define DST_Y_SUB				0x15a8
#define SRC_OFFSET				0x15ac
#define SRC_PITCH				0x15b0
#define DST_HEIGHT_WIDTH_BW			0x15b4
#define CLR_CMP_CNTL				0x15c0
#define CLR_CMP_CLR_SRC				0x15c4
#define CLR_CMP_CLR_DST				0x15c8
#define CLR_CMP_MASK				0x15cc
#define DP_SRC_FRGD_CLR				0x15d8
#define DP_SRC_BKGD_CLR				0x15dc
#define DST_BRES_ERR				0x1628
#define DST_BRES_INC				0x162c
#define DST_BRES_DEC				0x1630
#define DST_BRES_LNTH				0x1634
#define DST_BRES_LNTH_SUB			0x1638
#define SC_LEFT					0x1640
#define SC_RIGHT				0x1644
#define SC_TOP					0x1648
#define SC_BOTTOM				0x164c
#define SRC_SC_RIGHT				0x1654
#define SRC_SC_BOTTOM				0x165c
#define GUI_DEBUG0				0x16a0
#define GUI_DEBUG1				0x16a4
#define GUI_TIMEOUT				0x16b0
#define GUI_TIMEOUT0				0x16b4
#define GUI_TIMEOUT1				0x16b8
#define GUI_PROBE				0x16bc
#define DP_CNTL					0x16c0
#define DP_DATATYPE				0x16c4
#define DP_MIX					0x16c8
#define DP_WRITE_MASK				0x16cc
#define DP_CNTL_XDIR_YDIR_YMAJOR		0x16d0
#define DEFAULT_OFFSET				0x16e0
#define DEFAULT_PITCH				0x16e4
#define DEFAULT_SC_BOTTOM_RIGHT			0x16e8
#define SC_TOP_LEFT				0x16ec
#define SC_BOTTOM_RIGHT				0x16f0
#define SRC_SC_BOTTOM_RIGHT			0x16f4
#define WAIT_UNTIL				0x1720
#define CACHE_CNTL				0x1724
#define GUI_STAT				0x1740
#define PC_GUI_MODE				0x1744
#define PC_GUI_CTLSTAT				0x1748
#define PC_DEBUG_MODE				0x1760
#define BRES_DST_ERR_DEC			0x1780
#define TRAIL_BRES_T12_ERR_DEC			0x1784
#define TRAIL_BRES_T12_INC			0x1788
#define DP_T12_CNTL				0x178c
#define DST_BRES_T1_LNTH			0x1790
#define DST_BRES_T2_LNTH			0x1794
#define SCALE_SRC_HEIGHT_WIDTH			0x1994
#define SCALE_OFFSET_0				0x1998
#define SCALE_PITCH				0x199c
#define SCALE_X_INC				0x19a0
#define SCALE_Y_INC				0x19a4
#define SCALE_HACC				0x19a8
#define SCALE_VACC				0x19ac
#define SCALE_DST_X_Y				0x19b0
#define SCALE_DST_HEIGHT_WIDTH			0x19b4
#define SCALE_3D_CNTL				0x1a00
#define SCALE_3D_DATATYPE			0x1a20
#define SETUP_CNTL				0x1bc4
#define SOLID_COLOR				0x1bc8
#define WINDOW_XY_OFFSET			0x1bcc
#define DRAW_LINE_POINT				0x1bd0
#define SETUP_CNTL_PM4				0x1bd4
#define DST_PITCH_OFFSET_C			0x1c80
#define DP_GUI_MASTER_CNTL_C			0x1c84
#define SC_TOP_LEFT_C				0x1c88
#define SC_BOTTOM_RIGHT_C			0x1c8c

#define CLR_CMP_MASK_3D				0x1A28
#define MISC_3D_STATE_CNTL_REG			0x1CA0
#define MC_SRC1_CNTL				0x19D8
#define TEX_CNTL				0x1800

/* CONSTANTS */
#define GUI_ACTIVE				0x80000000
#define ENGINE_IDLE				0x0

#define PLL_WR_EN				0x00000080

#define CLK_PIN_CNTL				0x0001
#define PPLL_CNTL				0x0002
#define PPLL_REF_DIV				0x0003
#define PPLL_DIV_0				0x0004
#define PPLL_DIV_1				0x0005
#define PPLL_DIV_2				0x0006
#define PPLL_DIV_3				0x0007
#define VCLK_ECP_CNTL				0x0008
#define HTOTAL_CNTL				0x0009
#define X_MPLL_REF_FB_DIV			0x000a
#define XPLL_CNTL				0x000b
#define XDLL_CNTL				0x000c
#define XCLK_CNTL				0x000d
#define MPLL_CNTL				0x000e
#define MCLK_CNTL				0x000f
#define AGP_PLL_CNTL				0x0010
#define FCP_CNTL				0x0012
#define PLL_TEST_CNTL				0x0013
#define P2PLL_CNTL				0x002a
#define P2PLL_REF_DIV				0x002b
#define P2PLL_DIV_0				0x002b
#define POWER_MANAGEMENT			0x002f

#define PPLL_RESET				0x01
#define PPLL_ATOMIC_UPDATE_EN			0x10000
#define PPLL_VGA_ATOMIC_UPDATE_EN		0x20000
#define PPLL_REF_DIV_MASK			0x3FF
#define PPLL_FB3_DIV_MASK			0x7FF
#define PPLL_POST3_DIV_MASK			0x70000
#define PPLL_ATOMIC_UPDATE_R			0x8000
#define PPLL_ATOMIC_UPDATE_W			0x8000
#define MEM_CFG_TYPE_MASK			0x3
#define XCLK_SRC_SEL_MASK			0x7
#define XPLL_FB_DIV_MASK			0xFF00
#define X_MPLL_REF_DIV_MASK			0xFF

/* CRTC control values (CRTC_GEN_CNTL) */
#define CRTC_CSYNC_EN				0x00000010

#define CRTC2_DBL_SCAN_EN			0x00000001
#define CRTC2_DISPLAY_DIS			0x00800000
#define CRTC2_FIFO_EXTSENSE			0x00200000
#define CRTC2_ICON_EN				0x00100000
#define CRTC2_CUR_EN				0x00010000
#define CRTC2_EN				0x02000000
#define CRTC2_DISP_REQ_EN_B			0x04000000

#define CRTC_PIX_WIDTH_MASK			0x00000700
#define CRTC_PIX_WIDTH_4BPP			0x00000100
#define CRTC_PIX_WIDTH_8BPP			0x00000200
#define CRTC_PIX_WIDTH_15BPP			0x00000300
#define CRTC_PIX_WIDTH_16BPP			0x00000400
#define CRTC_PIX_WIDTH_24BPP			0x00000500
#define CRTC_PIX_WIDTH_32BPP			0x00000600

/* DAC_CNTL bit constants */
#define DAC_8BIT_EN				0x00000100
#define DAC_MASK				0xFF000000
#define DAC_BLANKING				0x00000004
#define DAC_RANGE_CNTL				0x00000003
#define DAC_CLK_SEL				0x00000010
#define DAC_PALETTE_ACCESS_CNTL			0x00000020
#define DAC_PALETTE2_SNOOP_EN			0x00000040
#define DAC_PDWN				0x00008000

/* CRTC_EXT_CNTL */
#define CRT_CRTC_ON				0x00008000

/* GEN_RESET_CNTL bit constants */
#define SOFT_RESET_GUI				0x00000001
#define SOFT_RESET_VCLK				0x00000100
#define SOFT_RESET_PCLK				0x00000200
#define SOFT_RESET_ECP				0x00000400
#define SOFT_RESET_DISPENG_XCLK			0x00000800

/* PC_GUI_CTLSTAT bit constants */
#define PC_BUSY_INIT				0x10000000
#define PC_BUSY_GUI				0x20000000
#define PC_BUSY_NGUI				0x40000000
#define PC_BUSY					0x80000000

#define BUS_MASTER_DIS				0x00000040
#define PM4_BUFFER_CNTL_NONPM4			0x00000000

/* DP_DATATYPE bit constants */
#define DST_8BPP				0x00000002
#define DST_15BPP				0x00000003
#define DST_16BPP				0x00000004
#define DST_24BPP				0x00000005
#define DST_32BPP				0x00000006

#define BRUSH_SOLIDCOLOR			0x00000d00

/* DP_GUI_MASTER_CNTL bit constants */
#define	GMC_SRC_PITCH_OFFSET_DEFAULT		0x00000000
#define GMC_DST_PITCH_OFFSET_DEFAULT		0x00000000
#define GMC_SRC_CLIP_DEFAULT			0x00000000
#define GMC_DST_CLIP_DEFAULT			0x00000000
#define GMC_BRUSH_SOLIDCOLOR			0x000000d0
#define GMC_SRC_DSTCOLOR			0x00003000
#define GMC_BYTE_ORDER_MSB_TO_LSB		0x00000000
#define GMC_DP_SRC_RECT				0x02000000
#define GMC_3D_FCN_EN_CLR			0x00000000
#define GMC_AUX_CLIP_CLEAR			0x20000000
#define GMC_DST_CLR_CMP_FCN_CLEAR		0x10000000
#define GMC_WRITE_MASK_SET			0x40000000
#define GMC_DP_CONVERSION_TEMP_6500		0x00000000

/* DP_GUI_MASTER_CNTL ROP3 named constants */
#define	ROP3_PATCOPY				0x00f00000
#define ROP3_SRCCOPY				0x00cc0000

#define SRC_DSTCOLOR				0x00030000

/* DP_CNTL bit constants */
#define DST_X_RIGHT_TO_LEFT			0x00000000
#define DST_X_LEFT_TO_RIGHT			0x00000001
#define DST_Y_BOTTOM_TO_TOP			0x00000000
#define DST_Y_TOP_TO_BOTTOM			0x00000002
#define DST_X_MAJOR				0x00000000
#define DST_Y_MAJOR				0x00000004
#define DST_X_TILE				0x00000008
#define DST_Y_TILE				0x00000010
#define DST_LAST_PEL				0x00000020
#define DST_TRAIL_X_RIGHT_TO_LEFT		0x00000000
#define DST_TRAIL_X_LEFT_TO_RIGHT		0x00000040
#define DST_TRAP_FILL_RIGHT_TO_LEFT		0x00000000
#define DST_TRAP_FILL_LEFT_TO_RIGHT		0x00000080
#define DST_BRES_SIGN				0x00000100
#define DST_HOST_BIG_ENDIAN_EN			0x00000200
#define DST_POLYLINE_NONLAST			0x00008000
#define DST_RASTER_STALL			0x00010000
#define DST_POLY_EDGE				0x00040000

/* DP_MIX bit constants */
#define DP_SRC_RECT				0x00000200
#define DP_SRC_HOST				0x00000300
#define DP_SRC_HOST_BYTEALIGN			0x00000400

/* LVDS_GEN_CNTL constants */
#define LVDS_BL_MOD_LEVEL_MASK			0x0000ff00
#define LVDS_BL_MOD_LEVEL_SHIFT			8
#define LVDS_BL_MOD_EN				0x00010000
#define LVDS_DIGION				0x00040000
#define LVDS_BLON				0x00080000
#define LVDS_ON					0x00000001
#define LVDS_DISPLAY_DIS			0x00000002
#define LVDS_PANEL_TYPE_2PIX_PER_CLK		0x00000004
#define LVDS_PANEL_24BITS_TFT			0x00000008
#define LVDS_FRAME_MOD_NO			0x00000000
#define LVDS_FRAME_MOD_2_LEVELS			0x00000010
#define LVDS_FRAME_MOD_4_LEVELS			0x00000020
#define LVDS_RST_FM				0x00000040
#define LVDS_EN					0x00000080

/* CRTC2_GEN_CNTL constants */
#define CRTC2_EN				0x02000000

/* POWER_MANAGEMENT constants */
#define PWR_MGT_ON				0x00000001
#define PWR_MGT_MODE_MASK			0x00000006
#define PWR_MGT_MODE_PIN			0x00000000
#define PWR_MGT_MODE_REGISTER			0x00000002
#define PWR_MGT_MODE_TIMER			0x00000004
#define PWR_MGT_MODE_PCI			0x00000006
#define PWR_MGT_AUTO_PWR_UP_EN			0x00000008
#define PWR_MGT_ACTIVITY_PIN_ON			0x00000010
#define PWR_MGT_STANDBY_POL			0x00000020
#define PWR_MGT_SUSPEND_POL			0x00000040
#define PWR_MGT_SELF_REFRESH			0x00000080
#define PWR_MGT_ACTIVITY_PIN_EN			0x00000100
#define PWR_MGT_KEYBD_SNOOP			0x00000200
#define PWR_MGT_TRISTATE_MEM_EN			0x00000800
#define PWR_MGT_SELW4MS				0x00001000
#define PWR_MGT_SLOWDOWN_MCLK			0x00002000

#define PMI_PMSCR_REG				0x60

/* used by ATI bug fix for hardware ROM */
#define RAGE128_MPP_TB_CONFIG                   0x01c0

#endif				/* REG_RAGE128_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Permedia2 framebuffer driver definitions.
 * Copyright (c) 1998-2000 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
 * --------------------------------------------------------------------------
 * $Id: pm2fb.h,v 1.26 2000/09/19 00:11:53 illo Exp $
 * --------------------------------------------------------------------------
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */

#ifndef PM2FB_H
#define PM2FB_H

#define PM2_REFERENCE_CLOCK	14318			/* in KHz */
#define PM2_MAX_PIXCLOCK	230000			/* in KHz */
#define PM2_REGS_SIZE		0x10000

#define PM2TAG(r) (u32 )(((r)-0x8000)>>3)

/*****************************************************************************
 * Permedia2 registers used in the framebuffer
 *****************************************************************************/
 
#define PM2R_RESET_STATUS				0x0000
#define PM2R_IN_FIFO_SPACE				0x0018
#define PM2R_OUT_FIFO_WORDS				0x0020
#define PM2R_APERTURE_ONE				0x0050
#define PM2R_APERTURE_TWO				0x0058
#define PM2R_FIFO_DISCON				0x0068
#define PM2R_CHIP_CONFIG				0x0070

#define PM2R_REBOOT					0x1000
#define PM2R_MEM_CONTROL				0x1040
#define PM2R_BOOT_ADDRESS				0x1080
#define PM2R_MEM_CONFIG					0x10c0
#define PM2R_BYPASS_WRITE_MASK				0x1100
#define PM2R_FRAMEBUFFER_WRITE_MASK			0x1140

#define PM2R_OUT_FIFO					0x2000

#define PM2R_SCREEN_BASE				0x3000
#define PM2R_SCREEN_STRIDE				0x3008
#define PM2R_H_TOTAL					0x3010
#define PM2R_HG_END					0x3018
#define PM2R_HB_END					0x3020
#define PM2R_HS_START					0x3028
#define PM2R_HS_END					0x3030
#define PM2R_V_TOTAL					0x3038
#define PM2R_VB_END					0x3040
#define PM2R_VS_START					0x3048
#define PM2R_VS_END					0x3050
#define PM2R_VIDEO_CONTROL				0x3058
#define PM2R_LINE_COUNT					0x3070
#define PM2R_FIFO_CONTROL				0x3078

#define PM2R_RD_PALETTE_WRITE_ADDRESS			0x4000
#define PM2R_RD_PALETTE_DATA				0x4008
#define PM2R_RD_PIXEL_MASK				0x4010
#define PM2R_RD_PALETTE_READ_ADDRESS			0x4018
#define PM2R_RD_CURSOR_COLOR_ADDRESS		        0x4020
#define PM2R_RD_CURSOR_COLOR_DATA		        0x4028
#define PM2R_RD_INDEXED_DATA				0x4050
#define PM2R_RD_CURSOR_DATA				0x4058
#define PM2R_RD_CURSOR_X_LSB				0x4060
#define PM2R_RD_CURSOR_X_MSB				0x4068
#define PM2R_RD_CURSOR_Y_LSB				0x4070
#define PM2R_RD_CURSOR_Y_MSB				0x4078

#define PM2R_START_X_DOM				0x8000
#define PM2R_D_X_DOM					0x8008
#define PM2R_START_X_SUB				0x8010
#define PM2R_D_X_SUB					0x8018
#define PM2R_START_Y					0x8020
#define PM2R_D_Y					0x8028
#define PM2R_COUNT					0x8030
#define PM2R_RENDER					0x8038
#define PM2R_BIT_MASK_PATTERN				0x8068
#define PM2R_RASTERIZER_MODE				0x80a0
#define PM2R_RECTANGLE_ORIGIN				0x80d0
#define PM2R_RECTANGLE_SIZE				0x80d8
#define PM2R_PACKED_DATA_LIMITS				0x8150
#define PM2R_SCISSOR_MODE				0x8180
#define PM2R_SCISSOR_MIN_XY				0x8188
#define PM2R_SCISSOR_MAX_XY				0x8190
#define PM2R_SCREEN_SIZE				0x8198
#define PM2R_AREA_STIPPLE_MODE				0x81a0
#define PM2R_WINDOW_ORIGIN				0x81c8
#define PM2R_TEXTURE_ADDRESS_MODE			0x8380
#define PM2R_TEXTURE_MAP_FORMAT				0x8588
#define PM2R_TEXTURE_DATA_FORMAT			0x8590
#define PM2R_TEXTURE_READ_MODE				0x8670
#define PM2R_TEXEL_LUT_MODE				0x8678
#define PM2R_TEXTURE_COLOR_MODE				0x8680
#define PM2R_FOG_MODE					0x8690
#define PM2R_TEXEL0					0x8760
#define PM2R_COLOR_DDA_MODE				0x87e0
#define PM2R_CONSTANT_COLOR				0x87e8
#define PM2R_ALPHA_BLEND_MODE				0x8810
#define PM2R_DITHER_MODE				0x8818
#define PM2R_FB_SOFT_WRITE_MASK				0x8820
#define PM2R_LOGICAL_OP_MODE				0x8828
#define PM2R_LB_READ_MODE				0x8880
#define PM2R_LB_READ_FORMAT				0x8888
#define PM2R_LB_SOURCE_OFFSET				0x8890
#define PM2R_LB_WINDOW_BASE				0x88b8
#define PM2R_LB_WRITE_FORMAT				0x88c8
#define PM2R_STENCIL_MODE				0x8988
#define PM2R_DEPTH_MODE					0x89a0
#define PM2R_FB_READ_MODE				0x8a80
#define PM2R_FB_SOURCE_OFFSET				0x8a88
#define PM2R_FB_PIXEL_OFFSET				0x8a90
#define PM2R_FB_WINDOW_BASE				0x8ab0
#define PM2R_FB_WRITE_MODE				0x8ab8
#define PM2R_FB_HARD_WRITE_MASK				0x8ac0
#define PM2R_FB_BLOCK_COLOR				0x8ac8
#define PM2R_FB_READ_PIXEL				0x8ad0
#define PM2R_FILTER_MODE				0x8c00
#define PM2R_SYNC					0x8c40
#define PM2R_YUV_MODE					0x8f00
#define PM2R_STATISTICS_MODE				0x8c08
#define PM2R_FB_SOURCE_DELTA				0x8d88
#define PM2R_CONFIG					0x8d90
#define PM2R_DELTA_MODE					0x9300

/* Permedia2v */
#define PM2VR_RD_INDEX_LOW				0x4020
#define PM2VR_RD_INDEX_HIGH				0x4028
#define PM2VR_RD_INDEXED_DATA				0x4030

/* Permedia2 RAMDAC indexed registers */
#define PM2I_RD_CURSOR_CONTROL				0x06
#define PM2I_RD_COLOR_MODE				0x18
#define PM2I_RD_MODE_CONTROL				0x19
#define PM2I_RD_MISC_CONTROL				0x1e
#define PM2I_RD_PIXEL_CLOCK_A1				0x20
#define PM2I_RD_PIXEL_CLOCK_A2				0x21
#define PM2I_RD_PIXEL_CLOCK_A3				0x22
#define PM2I_RD_PIXEL_CLOCK_STATUS			0x29
#define PM2I_RD_MEMORY_CLOCK_1				0x30
#define PM2I_RD_MEMORY_CLOCK_2				0x31
#define PM2I_RD_MEMORY_CLOCK_3				0x32
#define PM2I_RD_MEMORY_CLOCK_STATUS			0x33
#define PM2I_RD_COLOR_KEY_CONTROL			0x40
#define PM2I_RD_OVERLAY_KEY				0x41
#define PM2I_RD_RED_KEY					0x42
#define PM2I_RD_GREEN_KEY				0x43
#define PM2I_RD_BLUE_KEY				0x44

/* Permedia2v extensions */
#define PM2VI_RD_MISC_CONTROL				0x000
#define PM2VI_RD_SYNC_CONTROL				0x001
#define PM2VI_RD_DAC_CONTROL				0x002
#define PM2VI_RD_PIXEL_SIZE				0x003
#define PM2VI_RD_COLOR_FORMAT				0x004
#define PM2VI_RD_CURSOR_MODE				0x005
#define PM2VI_RD_CURSOR_X_LOW				0x007
#define PM2VI_RD_CURSOR_X_HIGH				0x008
#define PM2VI_RD_CURSOR_Y_LOW				0x009
#define PM2VI_RD_CURSOR_Y_HIGH				0x00A
#define PM2VI_RD_CURSOR_X_HOT				0x00B
#define PM2VI_RD_CURSOR_Y_HOT				0x00C
#define PM2VI_RD_OVERLAY_KEY				0x00D
#define PM2VI_RD_CLK0_PRESCALE				0x201
#define PM2VI_RD_CLK0_FEEDBACK				0x202
#define PM2VI_RD_CLK0_POSTSCALE				0x203
#define PM2VI_RD_CLK1_PRESCALE				0x204
#define PM2VI_RD_CLK1_FEEDBACK				0x205
#define PM2VI_RD_CLK1_POSTSCALE				0x206
#define PM2VI_RD_MCLK_CONTROL				0x20D
#define PM2VI_RD_MCLK_PRESCALE				0x20E
#define PM2VI_RD_MCLK_FEEDBACK				0x20F
#define PM2VI_RD_MCLK_POSTSCALE				0x210
#define PM2VI_RD_CURSOR_PALETTE				0x303
#define PM2VI_RD_CURSOR_PATTERN				0x400

/* Fields and flags */
#define PM2F_RENDER_AREASTIPPLE				(1L<<0)
#define PM2F_RENDER_FASTFILL				(1L<<3)
#define PM2F_RENDER_PRIMITIVE_MASK			(3L<<6)
#define PM2F_RENDER_LINE				0
#define PM2F_RENDER_TRAPEZOID				(1L<<6)
#define PM2F_RENDER_POINT				(2L<<6)
#define PM2F_RENDER_RECTANGLE				(3L<<6)
#define PM2F_RENDER_SYNC_ON_BIT_MASK			(1L<<11)
#define PM2F_RENDER_TEXTURE_ENABLE			(1L<<13)
#define PM2F_SYNCHRONIZATION				(1L<<10)
#define PM2F_PLL_LOCKED					0x10
#define PM2F_BEING_RESET				(1L<<31)
#define PM2F_DATATYPE_COLOR				0x8000
#define PM2F_VGA_ENABLE					0x02
#define PM2F_VGA_FIXED					0x04
#define PM2F_FB_WRITE_ENABLE				0x01
#define PM2F_FB_READ_SOURCE_ENABLE			0x0200
#define PM2F_RD_PALETTE_WIDTH_8				0x02
#define PM2F_PART_PROD_MASK				0x01ff
#define PM2F_SCREEN_SCISSOR_ENABLE			0x02
#define PM2F_DATA_64_ENABLE				0x00010000
#define PM2F_BLANK_LOW					0x02
#define PM2F_HSYNC_MASK					0x18
#define PM2F_VSYNC_MASK					0x60
#define PM2F_HSYNC_ACT_HIGH				0x08
#define PM2F_HSYNC_FORCED_LOW				0x10
#define PM2F_HSYNC_ACT_LOW				0x18
#define PM2F_VSYNC_ACT_HIGH				0x20
#define PM2F_VSYNC_FORCED_LOW				0x40
#define PM2F_VSYNC_ACT_LOW				0x60
#define PM2F_LINE_DOUBLE				0x04
#define PM2F_VIDEO_ENABLE				0x01
#define PM2F_RD_PIXELFORMAT_SVGA			0x01
#define PM2F_RD_PIXELFORMAT_RGB232OFFSET		0x02
#define PM2F_RD_PIXELFORMAT_RGBA2321			0x03
#define PM2F_RD_PIXELFORMAT_RGBA5551			0x04
#define PM2F_RD_PIXELFORMAT_RGBA4444			0x05
#define PM2F_RD_PIXELFORMAT_RGB565			0x06
#define PM2F_RD_PIXELFORMAT_RGBA8888			0x08
#define PM2F_RD_PIXELFORMAT_RGB888			0x09
#define PM2F_RD_GUI_ACTIVE				0x10
#define PM2F_RD_COLOR_MODE_RGB				0x20
#define PM2F_DELTA_ORDER_RGB				(1L<<18)
#define PM2F_RD_TRUECOLOR				0x80
#define PM2F_NO_ALPHA_BUFFER				0x10
#define PM2F_TEXTEL_SIZE_16				0x00080000
#define PM2F_TEXTEL_SIZE_32				0x00100000
#define PM2F_TEXTEL_SIZE_4				0x00180000
#define PM2F_TEXTEL_SIZE_24				0x00200000
#define PM2F_INCREASE_X					(1L<<21)
#define PM2F_INCREASE_Y					(1L<<22)
#define PM2F_CONFIG_FB_WRITE_ENABLE			(1L<<3)
#define PM2F_CONFIG_FB_PACKED_DATA			(1L<<2)
#define PM2F_CONFIG_FB_READ_DEST_ENABLE			(1L<<1)
#define PM2F_CONFIG_FB_READ_SOURCE_ENABLE		(1L<<0)
#define PM2F_COLOR_KEY_TEST_OFF				(1L<<4)
#define PM2F_MEM_CONFIG_RAM_MASK			(3L<<29)
#define PM2F_MEM_BANKS_1				0L
#define PM2F_MEM_BANKS_2				(1L<<29)
#define PM2F_MEM_BANKS_3				(2L<<29)
#define PM2F_MEM_BANKS_4				(3L<<29)
#define PM2F_APERTURE_STANDARD				0
#define PM2F_APERTURE_BYTESWAP				1
#define PM2F_APERTURE_HALFWORDSWAP			2
#define PM2F_CURSORMODE_CURSOR_ENABLE			(1 << 0)
#define PM2F_CURSORMODE_TYPE_X				(1 << 4)

typedef enum {
	PM2_TYPE_PERMEDIA2,
	PM2_TYPE_PERMEDIA2V
} pm2type_t;

#endif /* PM2FB_H */

/*****************************************************************************
 * That's all folks!
 *****************************************************************************/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * Copyright 2005-2009 Freescale Semiconductor, Inc.
 *
 * The code contained herein is licensed under the GNU Lesser General
 * Public License.  You may obtain a copy of the GNU Lesser General
 * Public License Version 2.1 or later at the following locations:
 *
 * http://www.opensource.org/licenses/lgpl-license.html
 * http://www.gnu.org/copyleft/lgpl.html
 */

#ifndef __DRM_IPU_H__
#define __DRM_IPU_H__

#include <linux/types.h>
#include <linux/videodev2.h>
#include <linux/bitmap.h>
#include <linux/fb.h>
#include <linux/of.h>
#include <media/v4l2-mediabus.h>
#include <video/videomode.h>

struct ipu_soc;

enum ipuv3_type {
	IPUV3EX,
	IPUV3M,
	IPUV3H,
};

#define IPU_PIX_FMT_GBR24	v4l2_fourcc('G', 'B', 'R', '3')

/*
 * Bitfield of Display Interface signal polarities.
 */
struct ipu_di_signal_cfg {
	unsigned data_pol:1;	/* true = inverted */
	unsigned clk_pol:1;	/* true = rising edge */
	unsigned enable_pol:1;

	struct videomode mode;

	u32 bus_format;
	u32 v_to_h_sync;

#define IPU_DI_CLKMODE_SYNC	(1 << 0)
#define IPU_DI_CLKMODE_EXT	(1 << 1)
	unsigned long clkflags;

	u8 hsync_pin;
	u8 vsync_pin;
};

/*
 * Enumeration of CSI destinations
 */
enum ipu_csi_dest {
	IPU_CSI_DEST_IDMAC, /* to memory via SMFC */
	IPU_CSI_DEST_IC,	/* to Image Converter */
	IPU_CSI_DEST_VDIC,  /* to VDIC */
};

/*
 * Enumeration of IPU rotation modes
 */
#define IPU_ROT_BIT_VFLIP (1 << 0)
#define IPU_ROT_BIT_HFLIP (1 << 1)
#define IPU_ROT_BIT_90    (1 << 2)

enum ipu_rotate_mode {
	IPU_ROTATE_NONE = 0,
	IPU_ROTATE_VERT_FLIP = IPU_ROT_BIT_VFLIP,
	IPU_ROTATE_HORIZ_FLIP = IPU_ROT_BIT_HFLIP,
	IPU_ROTATE_180 = (IPU_ROT_BIT_VFLIP | IPU_ROT_BIT_HFLIP),
	IPU_ROTATE_90_RIGHT = IPU_ROT_BIT_90,
	IPU_ROTATE_90_RIGHT_VFLIP = (IPU_ROT_BIT_90 | IPU_ROT_BIT_VFLIP),
	IPU_ROTATE_90_RIGHT_HFLIP = (IPU_ROT_BIT_90 | IPU_ROT_BIT_HFLIP),
	IPU_ROTATE_90_LEFT = (IPU_ROT_BIT_90 |
			      IPU_ROT_BIT_VFLIP | IPU_ROT_BIT_HFLIP),
};

/* 90-degree rotations require the IRT unit */
#define ipu_rot_mode_is_irt(m) (((m) & IPU_ROT_BIT_90) != 0)

enum ipu_color_space {
	IPUV3_COLORSPACE_RGB,
	IPUV3_COLORSPACE_YUV,
	IPUV3_COLORSPACE_UNKNOWN,
};

/*
 * Enumeration of VDI MOTION select
 */
enum ipu_motion_sel {
	MOTION_NONE = 0,
	LOW_MOTION,
	MED_MOTION,
	HIGH_MOTION,
};

struct ipuv3_channel;

enum ipu_channel_irq {
	IPU_IRQ_EOF = 0,
	IPU_IRQ_NFACK = 64,
	IPU_IRQ_NFB4EOF = 128,
	IPU_IRQ_EOS = 192,
};

/*
 * Enumeration of IDMAC channels
 */
#define IPUV3_CHANNEL_CSI0			 0
#define IPUV3_CHANNEL_CSI1			 1
#define IPUV3_CHANNEL_CSI2			 2
#define IPUV3_CHANNEL_CSI3			 3
#define IPUV3_CHANNEL_VDI_MEM_IC_VF		 5
/*
 * NOTE: channels 6,7 are unused in the IPU and are not IDMAC channels,
 * but the direct CSI->VDI linking is handled the same way as IDMAC
 * channel linking in the FSU via the IPU_FS_PROC_FLOW registers, so
 * these channel names are used to support the direct CSI->VDI link.
 */
#define IPUV3_CHANNEL_CSI_DIRECT		 6
#define IPUV3_CHANNEL_CSI_VDI_PREV		 7
#define IPUV3_CHANNEL_MEM_VDI_PREV		 8
#define IPUV3_CHANNEL_MEM_VDI_CUR		 9
#define IPUV3_CHANNEL_MEM_VDI_NEXT		10
#define IPUV3_CHANNEL_MEM_IC_PP			11
#define IPUV3_CHANNEL_MEM_IC_PRP_VF		12
#define IPUV3_CHANNEL_VDI_MEM_RECENT		13
#define IPUV3_CHANNEL_G_MEM_IC_PRP_VF		14
#define IPUV3_CHANNEL_G_MEM_IC_PP		15
#define IPUV3_CHANNEL_G_MEM_IC_PRP_VF_ALPHA	17
#define IPUV3_CHANNEL_G_MEM_IC_PP_ALPHA		18
#define IPUV3_CHANNEL_MEM_VDI_PLANE1_COMB_ALPHA	19
#define IPUV3_CHANNEL_IC_PRP_ENC_MEM		20
#define IPUV3_CHANNEL_IC_PRP_VF_MEM		21
#define IPUV3_CHANNEL_IC_PP_MEM			22
#define IPUV3_CHANNEL_MEM_BG_SYNC		23
#define IPUV3_CHANNEL_MEM_BG_ASYNC		24
#define IPUV3_CHANNEL_MEM_VDI_PLANE1_COMB	25
#define IPUV3_CHANNEL_MEM_VDI_PLANE3_COMB	26
#define IPUV3_CHANNEL_MEM_FG_SYNC		27
#define IPUV3_CHANNEL_MEM_DC_SYNC		28
#define IPUV3_CHANNEL_MEM_FG_ASYNC		29
#define IPUV3_CHANNEL_MEM_FG_SYNC_ALPHA		31
#define IPUV3_CHANNEL_MEM_FG_ASYNC_ALPHA	33
#define IPUV3_CHANNEL_DC_MEM_READ		40
#define IPUV3_CHANNEL_MEM_DC_ASYNC		41
#define IPUV3_CHANNEL_MEM_DC_COMMAND		42
#define IPUV3_CHANNEL_MEM_DC_COMMAND2		43
#define IPUV3_CHANNEL_MEM_DC_OUTPUT_MASK	44
#define IPUV3_CHANNEL_MEM_ROT_ENC		45
#define IPUV3_CHANNEL_MEM_ROT_VF		46
#define IPUV3_CHANNEL_MEM_ROT_PP		47
#define IPUV3_CHANNEL_ROT_ENC_MEM		48
#define IPUV3_CHANNEL_ROT_VF_MEM		49
#define IPUV3_CHANNEL_ROT_PP_MEM		50
#define IPUV3_CHANNEL_MEM_BG_SYNC_ALPHA		51
#define IPUV3_CHANNEL_MEM_BG_ASYNC_ALPHA	52
#define IPUV3_NUM_CHANNELS			64

int ipu_map_irq(struct ipu_soc *ipu, int irq);
int ipu_idmac_channel_irq(struct ipu_soc *ipu, struct ipuv3_channel *channel,
		enum ipu_channel_irq irq);

#define IPU_IRQ_DP_SF_START		(448 + 2)
#define IPU_IRQ_DP_SF_END		(448 + 3)
#define IPU_IRQ_BG_SF_END		IPU_IRQ_DP_SF_END,
#define IPU_IRQ_DC_FC_0			(448 + 8)
#define IPU_IRQ_DC_FC_1			(448 + 9)
#define IPU_IRQ_DC_FC_2			(448 + 10)
#define IPU_IRQ_DC_FC_3			(448 + 11)
#define IPU_IRQ_DC_FC_4			(448 + 12)
#define IPU_IRQ_DC_FC_6			(448 + 13)
#define IPU_IRQ_VSYNC_PRE_0		(448 + 14)
#define IPU_IRQ_VSYNC_PRE_1		(448 + 15)

/*
 * IPU Common functions
 */
int ipu_get_num(struct ipu_soc *ipu);
void ipu_set_csi_src_mux(struct ipu_soc *ipu, int csi_id, bool mipi_csi2);
void ipu_set_ic_src_mux(struct ipu_soc *ipu, int csi_id, bool vdi);
void ipu_dump(struct ipu_soc *ipu);

/*
 * IPU Image DMA Controller (idmac) functions
 */
struct ipuv3_channel *ipu_idmac_get(struct ipu_soc *ipu, unsigned channel);
void ipu_idmac_put(struct ipuv3_channel *);

int ipu_idmac_enable_channel(struct ipuv3_channel *channel);
int ipu_idmac_disable_channel(struct ipuv3_channel *channel);
void ipu_idmac_enable_watermark(struct ipuv3_channel *channel, bool enable);
int ipu_idmac_lock_enable(struct ipuv3_channel *channel, int num_bursts);
int ipu_idmac_wait_busy(struct ipuv3_channel *channel, int ms);

void ipu_idmac_set_double_buffer(struct ipuv3_channel *channel,
		bool doublebuffer);
int ipu_idmac_get_current_buffer(struct ipuv3_channel *channel);
bool ipu_idmac_buffer_is_ready(struct ipuv3_channel *channel, u32 buf_num);
void ipu_idmac_select_buffer(struct ipuv3_channel *channel, u32 buf_num);
void ipu_idmac_clear_buffer(struct ipuv3_channel *channel, u32 buf_num);
int ipu_fsu_link(struct ipu_soc *ipu, int src_ch, int sink_ch);
int ipu_fsu_unlink(struct ipu_soc *ipu, int src_ch, int sink_ch);
int ipu_idmac_link(struct ipuv3_channel *src, struct ipuv3_channel *sink);
int ipu_idmac_unlink(struct ipuv3_channel *src, struct ipuv3_channel *sink);

/*
 * IPU Channel Parameter Memory (cpmem) functions
 */
struct ipu_rgb {
	struct fb_bitfield      red;
	struct fb_bitfield      green;
	struct fb_bitfield      blue;
	struct fb_bitfield      transp;
	int                     bits_per_pixel;
};

struct ipu_image {
	struct v4l2_pix_format pix;
	struct v4l2_rect rect;
	dma_addr_t phys0;
	dma_addr_t phys1;
};

void ipu_cpmem_zero(struct ipuv3_channel *ch);
void ipu_cpmem_set_resolution(struct ipuv3_channel *ch, int xres, int yres);
void ipu_cpmem_set_stride(struct ipuv3_channel *ch, int stride);
void ipu_cpmem_set_high_priority(struct ipuv3_channel *ch);
void ipu_cpmem_set_buffer(struct ipuv3_channel *ch, int bufnum, dma_addr_t buf);
void ipu_cpmem_set_uv_offset(struct ipuv3_channel *ch, u32 u_off, u32 v_off);
void ipu_cpmem_interlaced_scan(struct ipuv3_channel *ch, int stride);
void ipu_cpmem_set_axi_id(struct ipuv3_channel *ch, u32 id);
int ipu_cpmem_get_burstsize(struct ipuv3_channel *ch);
void ipu_cpmem_set_burstsize(struct ipuv3_channel *ch, int burstsize);
void ipu_cpmem_set_block_mode(struct ipuv3_channel *ch);
void ipu_cpmem_set_rotation(struct ipuv3_channel *ch,
			    enum ipu_rotate_mode rot);
int ipu_cpmem_set_format_rgb(struct ipuv3_channel *ch,
			     const struct ipu_rgb *rgb);
int ipu_cpmem_set_format_passthrough(struct ipuv3_channel *ch, int width);
void ipu_cpmem_set_yuv_interleaved(struct ipuv3_channel *ch, u32 pixel_format);
void ipu_cpmem_set_yuv_planar_full(struct ipuv3_channel *ch,
				   unsigned int uv_stride,
				   unsigned int u_offset,
				   unsigned int v_offset);
void ipu_cpmem_set_yuv_planar(struct ipuv3_channel *ch,
			      u32 pixel_format, int stride, int height);
int ipu_cpmem_set_fmt(struct ipuv3_channel *ch, u32 drm_fourcc);
int ipu_cpmem_set_image(struct ipuv3_channel *ch, struct ipu_image *image);
void ipu_cpmem_dump(struct ipuv3_channel *ch);

/*
 * IPU Display Controller (dc) functions
 */
struct ipu_dc;
struct ipu_di;
struct ipu_dc *ipu_dc_get(struct ipu_soc *ipu, int channel);
void ipu_dc_put(struct ipu_dc *dc);
int ipu_dc_init_sync(struct ipu_dc *dc, struct ipu_di *di, bool interlaced,
		u32 pixel_fmt, u32 width);
void ipu_dc_enable(struct ipu_soc *ipu);
void ipu_dc_enable_channel(struct ipu_dc *dc);
void ipu_dc_disable_channel(struct ipu_dc *dc);
void ipu_dc_disable(struct ipu_soc *ipu);

/*
 * IPU Display Interface (di) functions
 */
struct ipu_di *ipu_di_get(struct ipu_soc *ipu, int disp);
void ipu_di_put(struct ipu_di *);
int ipu_di_disable(struct ipu_di *);
int ipu_di_enable(struct ipu_di *);
int ipu_di_get_num(struct ipu_di *);
int ipu_di_adjust_videomode(struct ipu_di *di, struct videomode *mode);
int ipu_di_init_sync_panel(struct ipu_di *, struct ipu_di_signal_cfg *sig);

/*
 * IPU Display Multi FIFO Controller (dmfc) functions
 */
struct dmfc_channel;
int ipu_dmfc_enable_channel(struct dmfc_channel *dmfc);
void ipu_dmfc_disable_channel(struct dmfc_channel *dmfc);
void ipu_dmfc_config_wait4eot(struct dmfc_channel *dmfc, int width);
struct dmfc_channel *ipu_dmfc_get(struct ipu_soc *ipu, int ipuv3_channel);
void ipu_dmfc_put(struct dmfc_channel *dmfc);

/*
 * IPU Display Processor (dp) functions
 */
#define IPU_DP_FLOW_SYNC_BG	0
#define IPU_DP_FLOW_SYNC_FG	1
#define IPU_DP_FLOW_ASYNC0_BG	2
#define IPU_DP_FLOW_ASYNC0_FG	3
#define IPU_DP_FLOW_ASYNC1_BG	4
#define IPU_DP_FLOW_ASYNC1_FG	5

struct ipu_dp *ipu_dp_get(struct ipu_soc *ipu, unsigned int flow);
void ipu_dp_put(struct ipu_dp *);
int ipu_dp_enable(struct ipu_soc *ipu);
int ipu_dp_enable_channel(struct ipu_dp *dp);
void ipu_dp_disable_channel(struct ipu_dp *dp);
void ipu_dp_disable(struct ipu_soc *ipu);
int ipu_dp_setup_channel(struct ipu_dp *dp,
		enum ipu_color_space in, enum ipu_color_space out);
int ipu_dp_set_window_pos(struct ipu_dp *, u16 x_pos, u16 y_pos);
int ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable, u8 alpha,
		bool bg_chan);

/*
 * IPU CMOS Sensor Interface (csi) functions
 */
struct ipu_csi;
int ipu_csi_init_interface(struct ipu_csi *csi,
			   struct v4l2_mbus_config *mbus_cfg,
			   struct v4l2_mbus_framefmt *mbus_fmt);
bool ipu_csi_is_interlaced(struct ipu_csi *csi);
void ipu_csi_get_window(struct ipu_csi *csi, struct v4l2_rect *w);
void ipu_csi_set_window(struct ipu_csi *csi, struct v4l2_rect *w);
void ipu_csi_set_test_generator(struct ipu_csi *csi, bool active,
				u32 r_value, u32 g_value, u32 b_value,
				u32 pix_clk);
int ipu_csi_set_mipi_datatype(struct ipu_csi *csi, u32 vc,
			      struct v4l2_mbus_framefmt *mbus_fmt);
int ipu_csi_set_skip_smfc(struct ipu_csi *csi, u32 skip,
			  u32 max_ratio, u32 id);
int ipu_csi_set_dest(struct ipu_csi *csi, enum ipu_csi_dest csi_dest);
int ipu_csi_enable(struct ipu_csi *csi);
int ipu_csi_disable(struct ipu_csi *csi);
struct ipu_csi *ipu_csi_get(struct ipu_soc *ipu, int id);
void ipu_csi_put(struct ipu_csi *csi);
void ipu_csi_dump(struct ipu_csi *csi);

/*
 * IPU Image Converter (ic) functions
 */
enum ipu_ic_task {
	IC_TASK_ENCODER,
	IC_TASK_VIEWFINDER,
	IC_TASK_POST_PROCESSOR,
	IC_NUM_TASKS,
};

struct ipu_ic;
int ipu_ic_task_init(struct ipu_ic *ic,
		     int in_width, int in_height,
		     int out_width, int out_height,
		     enum ipu_color_space in_cs,
		     enum ipu_color_space out_cs);
int ipu_ic_task_graphics_init(struct ipu_ic *ic,
			      enum ipu_color_space in_g_cs,
			      bool galpha_en, u32 galpha,
			      bool colorkey_en, u32 colorkey);
void ipu_ic_task_enable(struct ipu_ic *ic);
void ipu_ic_task_disable(struct ipu_ic *ic);
int ipu_ic_task_idma_init(struct ipu_ic *ic, struct ipuv3_channel *channel,
			  u32 width, u32 height, int burst_size,
			  enum ipu_rotate_mode rot);
int ipu_ic_enable(struct ipu_ic *ic);
int ipu_ic_disable(struct ipu_ic *ic);
struct ipu_ic *ipu_ic_get(struct ipu_soc *ipu, enum ipu_ic_task task);
void ipu_ic_put(struct ipu_ic *ic);
void ipu_ic_dump(struct ipu_ic *