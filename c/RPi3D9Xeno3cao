config MMU
	def_bool y

config ZONE_DMA
	def_bool y

config CPU_BIG_ENDIAN
	def_bool y

config LOCKDEP_SUPPORT
	def_bool y

config STACKTRACE_SUPPORT
	def_bool y

config RWSEM_GENERIC_SPINLOCK
	bool

config RWSEM_XCHGADD_ALGORITHM
	def_bool y

config ARCH_HAS_ILOG2_U32
	def_bool n

config ARCH_HAS_ILOG2_U64
	def_bool n

config GENERIC_HWEIGHT
	def_bool y

config GENERIC_BUG
	def_bool y if BUG

config GENERIC_BUG_RELATIVE_POINTERS
	def_bool y

config ARCH_DMA_ADDR_T_64BIT
	def_bool y

config GENERIC_LOCKBREAK
	def_bool y if SMP && PREEMPT

config PGSTE
	def_bool y if KVM

config ARCH_SUPPORTS_DEBUG_PAGEALLOC
	def_bool y

config KEXEC
	def_bool y
	select KEXEC_CORE

config AUDIT_ARCH
	def_bool y

config NO_IOPORT_MAP
	def_bool y

config PCI_QUIRKS
	def_bool n

config ARCH_SUPPORTS_UPROBES
	def_bool y

config DEBUG_RODATA
	def_bool y

config S390
	def_bool y
	select ARCH_HAS_DEVMEM_IS_ALLOWED
	select ARCH_HAS_ELF_RANDOMIZE
	select ARCH_HAS_GCOV_PROFILE_ALL
	select ARCH_HAS_GIGANTIC_PAGE
	select ARCH_HAS_KCOV
	select ARCH_HAS_SG_CHAIN
	select ARCH_HAS_UBSAN_SANITIZE_ALL
	select ARCH_HAVE_NMI_SAFE_CMPXCHG
	select ARCH_INLINE_READ_LOCK
	select ARCH_INLINE_READ_LOCK_BH
	select ARCH_INLINE_READ_LOCK_IRQ
	select ARCH_INLINE_READ_LOCK_IRQSAVE
	select ARCH_INLINE_READ_TRYLOCK
	select ARCH_INLINE_READ_UNLOCK
	select ARCH_INLINE_READ_UNLOCK_BH
	select ARCH_INLINE_READ_UNLOCK_IRQ
	select ARCH_INLINE_READ_UNLOCK_IRQRESTORE
	select ARCH_INLINE_SPIN_LOCK
	select ARCH_INLINE_SPIN_LOCK_BH
	select ARCH_INLINE_SPIN_LOCK_IRQ
	select ARCH_INLINE_SPIN_LOCK_IRQSAVE
	select ARCH_INLINE_SPIN_TRYLOCK
	select ARCH_INLINE_SPIN_TRYLOCK_BH
	select ARCH_INLINE_SPIN_UNLOCK
	select ARCH_INLINE_SPIN_UNLOCK_BH
	select ARCH_INLINE_SPIN_UNLOCK_IRQ
	select ARCH_INLINE_SPIN_UNLOCK_IRQRESTORE
	select ARCH_INLINE_WRITE_LOCK
	select ARCH_INLINE_WRITE_LOCK_BH
	select ARCH_INLINE_WRITE_LOCK_IRQ
	select ARCH_INLINE_WRITE_LOCK_IRQSAVE
	select ARCH_INLINE_WRITE_TRYLOCK
	select ARCH_INLINE_WRITE_UNLOCK
	select ARCH_INLINE_WRITE_UNLOCK_BH
	select ARCH_INLINE_WRITE_UNLOCK_IRQ
	select ARCH_INLINE_WRITE_UNLOCK_IRQRESTORE
	select ARCH_SAVE_PAGE_KEYS if HIBERNATION
	select ARCH_SUPPORTS_ATOMIC_RMW
	select ARCH_SUPPORTS_NUMA_BALANCING
	select ARCH_USE_BUILTIN_BSWAP
	select ARCH_USE_CMPXCHG_LOCKREF
	select ARCH_WANTS_DYNAMIC_TASK_STRUCT
	select ARCH_WANTS_PROT_NUMA_PROT_NONE
	select ARCH_WANTS_UBSAN_NO_NULL
	select ARCH_WANT_IPC_PARSE_VERSION
	select BUILDTIME_EXTABLE_SORT
	select CLONE_BACKWARDS2
	select DYNAMIC_FTRACE if FUNCTION_TRACER
	select GENERIC_CLOCKEVENTS
	select GENERIC_CPU_AUTOPROBE
	select GENERIC_CPU_DEVICES if !SMP
	select GENERIC_FIND_FIRST_BIT
	select GENERIC_SMP_IDLE_THREAD
	select GENERIC_TIME_VSYSCALL
	select HAVE_ALIGNED_STRUCT_PAGE if SLUB
	select HAVE_ARCH_AUDITSYSCALL
	select HAVE_ARCH_EARLY_PFN_TO_NID
	select HAVE_ARCH_HARDENED_USERCOPY
	select HAVE_ARCH_JUMP_LABEL
	select CPU_NO_EFFICIENT_FFS if !HAVE_MARCH_Z9_109_FEATURES
	select HAVE_ARCH_SECCOMP_FILTER
	select HAVE_ARCH_SOFT_DIRTY
	select HAVE_ARCH_TRACEHOOK
	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
	select HAVE_EBPF_JIT if PACK_STACK && HAVE_MARCH_Z196_FEATURES
	select HAVE_CMPXCHG_DOUBLE
	select HAVE_CMPXCHG_LOCAL
	select HAVE_DEBUG_KMEMLEAK
	select HAVE_DMA_API_DEBUG
	select HAVE_DYNAMIC_FTRACE
	select HAVE_DYNAMIC_FTRACE_WITH_REGS
	select HAVE_EFFICIENT_UNALIGNED_ACCESS
	select HAVE_EXIT_THREAD
	select HAVE_FTRACE_MCOUNT_RECORD
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_FUNCTION_TRACER
	select HAVE_FUTEX_CMPXCHG if FUTEX
	select HAVE_KERNEL_BZIP2
	select HAVE_KERNEL_GZIP
	select HAVE_KERNEL_LZ4
	select HAVE_KERNEL_LZMA
	select HAVE_KERNEL_LZO
	select HAVE_KERNEL_XZ
	select HAVE_KPROBES
	select HAVE_KRETPROBES
	select HAVE_KVM
	select HAVE_LIVEPATCH
	select HAVE_MEMBLOCK
	select HAVE_MEMBLOCK_NODE_MAP
	select HAVE_MEMBLOCK_PHYS_MAP
	select HAVE_MOD_ARCH_SPECIFIC
	select HAVE_OPROFILE
	select HAVE_PERF_EVENTS
	select HAVE_REGS_AND_STACK_ACCESS_API
	select HAVE_SYSCALL_TRACEPOINTS
	select HAVE_VIRT_CPU_ACCOUNTING
	select MODULES_USE_ELF_RELA
	select NO_BOOTMEM
	select OLD_SIGACTION
	select OLD_SIGSUSPEND3
	select SPARSE_IRQ
	select SYSCTL_EXCEPTION_TRACE
	select TTY
	select VIRT_CPU_ACCOUNTING
	select VIRT_TO_BUS
	select HAVE_NMI


config SCHED_OMIT_FRAME_POINTER
	def_bool y

config PGTABLE_LEVELS
	int
	default 4

source "init/Kconfig"

source "kernel/Kconfig.freezer"

source "kernel/livepatch/Kconfig"

menu "Processor type and features"

config HAVE_MARCH_Z900_FEATURES
	def_bool n

config HAVE_MARCH_Z990_FEATURES
	def_bool n
	select HAVE_MARCH_Z900_FEATURES

config HAVE_MARCH_Z9_109_FEATURES
	def_bool n
	select HAVE_MARCH_Z990_FEATURES

config HAVE_MARCH_Z10_FEATURES
	def_bool n
	select HAVE_MARCH_Z9_109_FEATURES

config HAVE_MARCH_Z196_FEATURES
	def_bool n
	select HAVE_MARCH_Z10_FEATURES

config HAVE_MARCH_ZEC12_FEATURES
	def_bool n
	select HAVE_MARCH_Z196_FEATURES

config HAVE_MARCH_Z13_FEATURES
	def_bool n
	select HAVE_MARCH_ZEC12_FEATURES

choice
	prompt "Processor type"
	default MARCH_Z196

config MARCH_Z900
	bool "IBM zSeries model z800 and z900"
	select HAVE_MARCH_Z900_FEATURES
	help
	  Select this to enable optimizations for model z800/z900 (2064 and
	  2066 series). This will enable some optimizations that are not
	  available on older ESA/390 (31 Bit) only CPUs.

config MARCH_Z990
	bool "IBM zSeries model z890 and z990"
	select HAVE_MARCH_Z990_FEATURES
	help
	  Select this to enable optimizations for model z890/z990 (2084 and
	  2086 series). The kernel will be slightly faster but will not work
	  on older machines.

config MARCH_Z9_109
	bool "IBM System z9"
	select HAVE_MARCH_Z9_109_FEATURES
	help
	  Select this to enable optimizations for IBM System z9 (2094 and
	  2096 series). The kernel will be slightly faster but will not work
	  on older machines.

config MARCH_Z10
	bool "IBM System z10"
	select HAVE_MARCH_Z10_FEATURES
	help
	  Select this to enable optimizations for IBM System z10 (2097 and
	  2098 series). The kernel will be slightly faster but will not work
	  on older machines.

config MARCH_Z196
	bool "IBM zEnterprise 114 and 196"
	select HAVE_MARCH_Z196_FEATURES
	help
	  Select this to enable optimizations for IBM zEnterprise 114 and 196
	  (2818 and 2817 series). The kernel will be slightly faster but will
	  not work on older machines.

config MARCH_ZEC12
	bool "IBM zBC12 and zEC12"
	select HAVE_MARCH_ZEC12_FEATURES
	help
	  Select this to enable optimizations for IBM zBC12 and zEC12 (2828 and
	  2827 series). The kernel will be slightly faster but will not work on
	  older machines.

config MARCH_Z13
	bool "IBM z13s and z13"
	select HAVE_MARCH_Z13_FEATURES
	help
	  Select this to enable optimizations for IBM z13s and z13 (2965 and
	  2964 series). The kernel will be slightly faster but will not work on
	  older machines.

endchoice

config MARCH_Z900_TUNE
	def_bool TUNE_Z900 || MARCH_Z900 && TUNE_DEFAULT

config MARCH_Z990_TUNE
	def_bool TUNE_Z990 || MARCH_Z990 && TUNE_DEFAULT

config MARCH_Z9_109_TUNE
	def_bool TUNE_Z9_109 || MARCH_Z9_109 && TUNE_DEFAULT

config MARCH_Z10_TUNE
	def_bool TUNE_Z10 || MARCH_Z10 && TUNE_DEFAULT

config MARCH_Z196_TUNE
	def_bool TUNE_Z196 || MARCH_Z196 && TUNE_DEFAULT

config MARCH_ZEC12_TUNE
	def_bool TUNE_ZEC12 || MARCH_ZEC12 && TUNE_DEFAULT

config MARCH_Z13_TUNE
	def_bool TUNE_Z13 || MARCH_Z13 && TUNE_DEFAULT

choice
	prompt "Tune code generation"
	default TUNE_DEFAULT
	help
	  Cause the compiler to tune (-mtune) the generated code for a machine.
	  This will make the code run faster on the selected machine but
	  somewhat slower on other machines.
	  This option only changes how the compiler emits instructions, not the
	  selection of instructions itself, so the resulting kernel will run on
	  all other machines.

config TUNE_DEFAULT
	bool "Default"
	help
	  Tune the generated code for the target processor for which the kernel
	  will be compiled.

config TUNE_Z900
	bool "IBM zSeries model z800 and z900"

config TUNE_Z990
	bool "IBM zSeries model z890 and z990"

config TUNE_Z9_109
	bool "IBM System z9"

config TUNE_Z10
	bool "IBM System z10"

config TUNE_Z196
	bool "IBM zEnterprise 114 and 196"

config TUNE_ZEC12
	bool "IBM zBC12 and zEC12"

config TUNE_Z13
	bool "IBM z13"

endchoice

config 64BIT
	def_bool y

config COMPAT
	def_bool y
	prompt "Kernel support for 31 bit emulation"
	select COMPAT_BINFMT_ELF if BINFMT_ELF
	select ARCH_WANT_OLD_COMPAT_IPC
	select COMPAT_OLD_SIGACTION
	depends on MULTIUSER
	help
	  Select this option if you want to enable your system kernel to
	  handle system-calls from ELF binaries for 31 bit ESA.  This option
	  (and some other stuff like libraries and such) is needed for
	  executing 31 bit applications.  It is safe to say "Y".

config SYSVIPC_COMPAT
	def_bool y if COMPAT && SYSVIPC

config SMP
	def_bool y
	prompt "Symmetric multi-processing support"
	---help---
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, like most personal computers, say N. If
	  you have a system with more than one CPU, say Y.

	  If you say N here, the kernel will run on uni- and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  uniprocessor machines. On a uniprocessor machine, the kernel
	  will run faster if you say N here.

	  See also the SMP-HOWTO available at
	  <http://www.tldp.org/docs.html#howto>.

	  Even if you don't know what to do here, say Y.

config NR_CPUS
	int "Maximum number of CPUs (2-512)"
	range 2 512
	depends on SMP
	default "64"
	help
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support. The maximum supported value is 512 and the
	  minimum value which makes sense is 2.

	  This is purely to save memory - each supported CPU adds
	  approximately sixteen kilobytes to the kernel image.

config HOTPLUG_CPU
	def_bool y
	prompt "Support for hot-pluggable CPUs"
	depends on SMP
	help
	  Say Y here to be able to turn CPUs off and on. CPUs
	  can be controlled through /sys/devices/system/cpu/cpu#.
	  Say N if you want to disable CPU hotplug.

# Some NUMA nodes have memory ranges that span
# other nodes.	Even though a pfn is valid and
# between a node's start and end pfns, it may not
# reside on that node.	See memmap_init_zone()
# for details. <- They meant memory holes!
config NODES_SPAN_OTHER_NODES
	def_bool NUMA

config NUMA
	bool "NUMA support"
	depends on SMP && SCHED_TOPOLOGY
	default n
	help
	  Enable NUMA support

	  This option adds NUMA support to the kernel.

	  An operation mode can be selected by appending
	  numa=<method> to the kernel command line.

	  The default behaviour is identical to appending numa=plain to
	  the command line. This will create just one node with all
	  available memory and all CPUs in it.

config NODES_SHIFT
	int "Maximum NUMA nodes (as a power of 2)"
	range 1 10
	depends on NUMA
	default "4"
	help
	  Specify the maximum number of NUMA nodes available on the target
	  system. Increases memory reserved to accommodate various tables.

menu "Select NUMA modes"
	depends on NUMA

config NUMA_EMU
	bool "NUMA emulation"
	default y
	help
	  Numa emulation mode will split the available system memory into
	  equal chunks which then are distributed over the configured number
	  of nodes in a round-robin manner.

	  The number of fake nodes is limited by the number of available memory
	  chunks (i.e. memory size / fake size) and the number of supported
	  nodes in the kernel.

	  The CPUs are assigned to the nodes in a way that partially respects
	  the original machine topology (if supported by the machine).
	  Fair distribution of the CPUs is not guaranteed.

config EMU_SIZE
	hex "NUMA emulation memory chunk size"
	default 0x10000000
	range 0x400000 0x100000000
	depends on NUMA_EMU
	help
	  Select the default size by which the memory is chopped and then
	  assigned to emulated NUMA nodes.

	  This can be overridden by specifying

	  emu_size=<n>

	  on the kernel command line where also suffixes K, M, G, and T are
	  supported.

endmenu

config SCHED_SMT
	def_bool n

config SCHED_MC
	def_bool n

config SCHED_BOOK
	def_bool n

config SCHED_DRAWER
	def_bool n

config SCHED_TOPOLOGY
	def_bool y
	prompt "Topology scheduler support"
	depends on SMP
	select SCHED_SMT
	select SCHED_MC
	select SCHED_BOOK
	select SCHED_DRAWER
	help
	  Topology scheduler support improves the CPU scheduler's decision
	  making when dealing with machines that have multi-threading,
	  multiple cores or multiple books.

source kernel/Kconfig.preempt

source kernel/Kconfig.hz

endmenu

menu "Memory setup"

config ARCH_SPARSEMEM_ENABLE
	def_bool y
	select SPARSEMEM_VMEMMAP_ENABLE
	select SPARSEMEM_VMEMMAP

config ARCH_SPARSEMEM_DEFAULT
	def_bool y

config ARCH_SELECT_MEMORY_MODEL
	def_bool y

config ARCH_ENABLE_MEMORY_HOTPLUG
	def_bool y if SPARSEMEM

config ARCH_ENABLE_MEMORY_HOTREMOVE
	def_bool y

config ARCH_ENABLE_SPLIT_PMD_PTLOCK
	def_bool y

config FORCE_MAX_ZONEORDER
	int
	default "9"

source "mm/Kconfig"

config PACK_STACK
	def_bool y
	prompt "Pack kernel stack"
	help
	  This option enables the compiler option -mkernel-backchain if it
	  is available. If the option is available the compiler supports
	  the new stack layout which dramatically reduces the minimum stack
	  frame size. With an old compiler a non-leaf function needs a
	  minimum of 96 bytes on 31 bit and 160 bytes on 64 bit. With
	  -mkernel-backchain the minimum size drops to 16 byte on 31 bit
	  and 24 byte on 64 bit.

	  Say Y if you are unsure.

config CHECK_STACK
	def_bool y
	prompt "Detect kernel stack overflow"
	help
	  This option enables the compiler option -mstack-guard and
	  -mstack-size if they are available. If the compiler supports them
	  it will emit additional code to each function prolog to trigger
	  an illegal operation if the kernel stack is about to overflow.

	  Say N if you are unsure.

config STACK_GUARD
	int "Size of the guard area (128-1024)"
	range 128 1024
	depends on CHECK_STACK
	default "256"
	help
	  This allows you to specify the size of the guard area at the lower
	  end of the kernel stack. If the kernel stack points into the guard
	  area on function entry an illegal operation is triggered. The size
	  needs to be a power of 2. Please keep in mind that the size of an
	  interrupt frame is 184 bytes for 31 bit and 328 bytes on 64 bit.
	  The minimum size for the stack guard should be 256 for 31 bit and
	  512 for 64 bit.

config WARN_DYNAMIC_STACK
	def_bool n
	prompt "Emit compiler warnings for function with dynamic stack usage"
	help
	  This option enables the compiler option -mwarn-dynamicstack. If the
	  compiler supports this options generates warnings for functions
	  that dynamically allocate stack space using alloca.

	  Say N if you are unsure.

endmenu

menu "I/O subsystem"

config QDIO
	def_tristate y
	prompt "QDIO support"
	---help---
	  This driver provides the Queued Direct I/O base support for
	  IBM System z.

	  To compile this driver as a module, choose M here: the
	  module will be called qdio.

	  If unsure, say Y.

menuconfig PCI
	bool "PCI support"
	select PCI_MSI
	select IOMMU_SUPPORT
	help
	  Enable PCI support.

if PCI

config PCI_NR_FUNCTIONS
	int "Maximum number of PCI functions (1-4096)"
	range 1 4096
	default "64"
	help
	  This allows you to specify the maximum number of PCI functions which
	  this kernel will support.

source "drivers/pci/Kconfig"

endif	# PCI

config PCI_DOMAINS
	def_bool PCI

config HAS_IOMEM
	def_bool PCI

config IOMMU_HELPER
	def_bool PCI

config NEED_SG_DMA_LENGTH
	def_bool PCI

config NEED_DMA_MAP_STATE
	def_bool PCI

config CHSC_SCH
	def_tristate m
	prompt "Support for CHSC subchannels"
	help
	  This driver allows usage of CHSC subchannels. A CHSC subchannel
	  is usually present on LPAR only.
	  The driver creates a device /dev/chsc, which may be used to
	  obtain I/O configuration information about the machine and
	  to issue asynchronous chsc commands (DANGEROUS).
	  You will usually only want to use this interface on a special
	  LPAR designated for system management.

	  To compile this driver as a module, choose M here: the
	  module will be called chsc_sch.

	  If unsure, say N.

config SCM_BUS
	def_bool y
	prompt "SCM bus driver"
	help
	  Bus driver for Storage Class Memory.

config EADM_SCH
	def_tristate m
	prompt "Support for EADM subchannels"
	depends on SCM_BUS
	help
	  This driver allows usage of EADM subchannels. EADM subchannels act
	  as a communication vehicle for SCM increments.

	  To compile this driver as a module, choose M here: the
	  module will be called eadm_sch.

endmenu

menu "Dump support"

config CRASH_DUMP
	bool "kernel crash dumps"
	depends on SMP
	select KEXEC
	help
	  Generate crash dump after being started by kexec.
	  Crash dump kernels are loaded in the main kernel with kexec-tools
	  into a specially reserved region and then later executed after
	  a crash by kdump/kexec.
	  Refer to <file:Documentation/s390/zfcpdump.txt> for more details on this.
	  This option also enables s390 zfcpdump.
	  See also <file:Documentation/s390/zfcpdump.txt>

endmenu

menu "Executable file formats / Emulations"

source "fs/Kconfig.binfmt"

config SECCOMP
	def_bool y
	prompt "Enable seccomp to safely compute untrusted bytecode"
	depends on PROC_FS
	help
	  This kernel feature is useful for number crunching applications
	  that may need to compute untrusted bytecode during their
	  execution. By using pipes or other transports made available to
	  the process as file descriptors supporting the read/write
	  syscalls, it's possible to isolate those applications in
	  their own address space using seccomp. Once seccomp is
	  enabled via /proc/<pid>/seccomp, it cannot be disabled
	  and the task is only allowed to execute a few safe syscalls
	  defined by each seccomp mode.

	  If unsure, say Y.

endmenu

menu "Power Management"

config ARCH_HIBERNATION_POSSIBLE
	def_bool y

source "kernel/power/Kconfig"

endmenu

source "net/Kconfig"

config PCMCIA
	def_bool n

config CCW
	def_bool y

source "drivers/Kconfig"

source "fs/Kconfig"

source "arch/s390/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"

menu "Virtualization"

config PFAULT
	def_bool y
	prompt "Pseudo page fault support"
	help
	  Select this option, if you want to use PFAULT pseudo page fault
	  handling under VM. If running native or in LPAR, this option
	  has no effect. If your VM does not support PFAULT, PAGEEX
	  pseudo page fault handling will be used.
	  Note that VM 4.2 supports PFAULT but has a bug in its
	  implementation that causes some problems.
	  Everybody who wants to run Linux under VM != VM4.2 should select
	  this option.

config SHARED_KERNEL
	bool "VM shared kernel support"
	depends on !JUMP_LABEL
	help
	  Select this option, if you want to share the text segment of the
	  Linux kernel between different VM guests. This reduces memory
	  usage with lots of guests but greatly increases kernel size.
	  Also if a kernel was IPL'ed from a shared segment the kexec system
	  call will not work.
	  You should only select this option if you know what you are
	  doing and want to exploit this feature.

config CMM
	def_tristate n
	prompt "Cooperative memory management"
	help
	  Select this option, if you want to enable the kernel interface
	  to reduce the memory size of the system. This is accomplished
	  by allocating pages of memory and put them "on hold". This only
	  makes sense for a system running under VM where the unused pages
	  will be reused by VM for other guest systems. The interface
	  allows an external monitor to balance memory of many systems.
	  Everybody who wants to run Linux under VM should select this
	  option.

config CMM_IUCV
	def_bool y
	prompt "IUCV special message interface to cooperative memory management"
	depends on CMM && (SMSGIUCV=y || CMM=SMSGIUCV)
	help
	  Select this option to enable the special message interface to
	  the cooperative memory management.

config APPLDATA_BASE
	def_bool n
	prompt "Linux - VM Monitor Stream, base infrastructure"
	depends on PROC_FS
	help
	  This provides a kernel interface for creating and updating z/VM APPLDATA
	  monitor records. The monitor records are updated at certain time
	  intervals, once the timer is started.
	  Writing 1 or 0 to /proc/appldata/timer starts(1) or stops(0) the timer,
	  i.e. enables or disables monitoring on the Linux s# ~/.bashrc: executed by bash(1) for non-login shells.

# Note: PS1 and umask are already set in /etc/profile. You should not
# need this unless you want different defaults for root.
# PS1='${debian_chroot:+($debian_chroot)}\h:\w\$ '
# umask 022

# You may uncomment the following lines if you want `ls' to be colorized:
# export LS_OPTIONS='--color=auto'
# eval "`dircolors`"
# alias ls='ls $LS_OPTIONS'
# alias ll='ls $LS_OPTIONS -l'
# alias l='ls $LS_OPTIONS -lA'
#
# Some more alias to avoid making mistakes:
# alias rm='rm -i'
# alias cp='cp -i'
# alias mv='mv -i'

export LD_LIBRARY_PATH=/usr/xenomai/lib
export PATH=$PATH:/usr/xenomai/bin
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ide.
	  A custom interval value (in seconds) can be written to
	  /proc/appldata/interval.

	  Defaults are 60 seconds interval and timer off.
	  The /proc entries can also be read from, showing the current settings.

config APPLDATA_MEM
	def_tristate m
	prompt "Monitor memory management statistics"
	depends on APPLDATA_BASE && VM_EVENT_COUNTERS
	help
	  This provides memory management related data to the Linux - VM Monitor
	  Stream, like paging/swapping rate, memory utilisation, etc.
	  Writing 1 or 0 to /proc/appldata/memory creates(1) or removes(0) a z/VM
	  APPLDATA monitor record, i.e. enables or disables monitoring this record
	  on the z/VM side.

	  Default is disabled.
	  The /proc entry can also be read from, showing the current settings.

	  This can also be compiled as a module, which will be called
	  appldata_mem.o.

config APPLDATA_OS
	def_tristate m
	prompt "Monitor OS statistics"
	depends on APPLDATA_BASE
	help
	  This provides OS related data to the Linux - VM Monitor Stream, like
	  CPU utilisation, etc.
	  Writing 1 or 0 to /proc/appldata/os creates(1) or removes(0) a z/VM
	  APPLDATA monitor record, i.e. enables or disables monitoring this record
	  on the z/VM side.

	  Default is disabled.
	  This can also be compiled as a module, which will be called
	  appldata_os.o.

config APPLDATA_NET_SUM
	def_tristate m
	prompt "Monitor overall network statistics"
	depends on APPLDATA_BASE && NET
	help
	  This provides network related data to the Linux - VM Monitor Stream,
	  currently there is only a total sum of network I/O statistics, no
	  per-interface data.
	  Writing 1 or 0 to /proc/appldata/net_sum creates(1) or removes(0) a z/VM
	  APPLDATA monitor record, i.e. enables or disables monitoring this record
	  on the z/VM side.

	  Default is disabled.
	  This can also be compiled as a module, which will be called
	  appldata_net_sum.o.

config S390_HYPFS_FS
	def_bool y
	prompt "s390 hypervisor file system support"
	select SYS_HYPERVISOR
	help
	  This is a virtual file system intended to provide accounting
	  information in an s390 hypervisor environment.

source "arch/s390/kvm/Kconfig"

config S390_GUEST
	def_bool y
	prompt "s390 support for virtio devices"
	select TTY
	select VIRTUALIZATION
	select VIRTIO
	select VIRTIO_CONSOLE
	help
	  Enabling this option adds support for virtio based paravirtual device
	  drivers on s390.

	  Select this option if you want to run the kernel as a guest under
	  the KVM hypervisor.

config S390_GUEST_OLD_TRANSPORT
	def_bool y
	prompt "Guest support for old s390 virtio transport (DEPRECATED)"
	depends on S390_GUEST
	help
	  Enable this option to add support for the old s390-virtio
	  transport (i.e. virtio devices NOT based on virtio-ccw). This
	  type of virtio devices is only available on the experimental
	  kuli userspace or with old (< 2.6) qemu. If you are running
	  with a modern version of qemu (which supports virtio-ccw since
	  1.4 and uses it by default since version 2.4), you probably won't
	  need this.

endmenu
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 *  S390 version
 *
 *  Derived from "include/asm-i386/shmparam.h"
 */
#ifndef _ASM_S390_SHMPARAM_H
#define _ASM_S390_SHMPARAM_H

#define SHMLBA PAGE_SIZE                 /* attach addr a multiple of this */

#endif /* _ASM_S390_SHMPARAM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *  Functions for incremental construction of fcx enabled I/O control blocks.
 *
 *    Copyright IBM Corp. 2008
 *    Author(s): Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
 */

#ifndef _ASM_S390_ITCW_H
#define _ASM_S390_ITCW_H

#include <linux/types.h>
#include <asm/fcx.h>

#define ITCW_OP_READ	0
#define ITCW_OP_WRITE	1

struct itcw;

struct tcw *itcw_get_tcw(struct itcw *itcw);
size_t itcw_calc_size(int intrg, int max_tidaws, int intrg_max_tidaws);
struct itcw *itcw_init(void *buffer, size_t size, int op, int intrg,
		       int max_tidaws, int intrg_max_tidaws);
struct dcw *itcw_add_dcw(struct itcw *itcw, u8 cmd, u8 flags, void *cd,
			 u8 cd_count, u32 count);
struct tidaw *itcw_add_tidaw(struct itcw *itcw, u8 flags, void *addr,
			     u32 count);
void itcw_set_data(struct itcw *itcw, void *addr, int use_tidal);
void itcw_finalize(struct itcw *itcw);

#endif /* _ASM_S390_ITCW_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef S390_CMB_H
#define S390_CMB_H

#include <uapi/asm/cmb.h>

struct ccw_device;
extern int enable_cmf(struct ccw_device *cdev);
extern int disable_cmf(struct ccw_device *cdev);
extern int __disable_cmf(struct ccw_device *cdev);
extern u64 cmf_read(struct ccw_device *cdev, int index);
extern int cmf_readall(struct ccw_device *cdev, struct cmbdata *data);

#endif /* S390_CMB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #include <asm-generic/local.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _S390_ASM_PCI_DEBUG_H
#define _S390_ASM_PCI_DEBUG_H

#include <asm/debug.h>

extern debug_info_t *pci_debug_msg_id;
extern debug_info_t *pci_debug_err_id;

#define zpci_dbg(imp, fmt, args...)				\
	debug_sprintf_event(pci_debug_msg_id, imp, fmt, ##args)

#define zpci_err(text...)							\
	do {									\
		char debug_buffer[16];						\
		snprintf(debug_buffer, 16, text);				\
		debug_text_event(pci_debug_err_id, 0, debug_buffer);		\
	} while (0)

static inline void zpci_err_hex(void *addr, int len)
{
	while (len > 0) {
		debug_event(pci_debug_err_id, 0, (void *) addr, len);
		len -= pci_debug_err_id->buf_size;
		addr += pci_debug_err_id->buf_size;
	}
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * Copyright IBM Corp. 1999, 2011
 *
 * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>,
 */

#ifndef __ASM_CMPXCHG_H
#define __ASM_CMPXCHG_H

#include <linux/mmdebug.h>
#include <linux/types.h>
#include <linux/bug.h>

#define cmpxchg(ptr, o, n)						\
({									\
	__typeof__(*(ptr)) __o = (o);					\
	__typeof__(*(ptr)) __n = (n);					\
	(__typeof__(*(ptr))) __sync_val_compare_and_swap((ptr),__o,__n);\
})

#define cmpxchg64	cmpxchg
#define cmpxchg_local	cmpxchg
#define cmpxchg64_local	cmpxchg

#define xchg(ptr, x)							\
({									\
	__typeof__(ptr) __ptr = (ptr);					\
	__typeof__(*(ptr)) __old;					\
	do {								\
		__old = *__ptr;						\
	} while (!__sync_bool_compare_and_swap(__ptr, __old, x));	\
	__old;								\
})

#define __cmpxchg_double(p1, p2, o1, o2, n1, n2)			\
({									\
	register __typeof__(*(p1)) __old1 asm("2") = (o1);		\
	register __typeof__(*(p2)) __old2 asm("3") = (o2);		\
	register __typeof__(*(p1)) __new1 asm("4") = (n1);		\
	register __typeof__(*(p2)) __new2 asm("5") = (n2);		\
	int cc;								\
	asm volatile(							\
		"	cdsg	%[old],%[new],%[ptr]\n"			\
		"	ipm	%[cc]\n"				\
		"	srl	%[cc],28"				\
		: [cc] "=d" (cc), [old] "+d" (__old1), "+d" (__old2)	\
		: [new] "d" (__new1), "d" (__new2),			\
		  [ptr] "Q" (*(p1)), "Q" (*(p2))			\
		: "memory", "cc");					\
	!cc;								\
})

#define cmpxchg_double(p1, p2, o1, o2, n1, n2)				\
({									\
	__typeof__(p1) __p1 = (p1);					\
	__typeof__(p2) __p2 = (p2);					\
	BUILD_BUG_ON(sizeof(*(p1)) != sizeof(long));			\
	BUILD_BUG_ON(sizeof(*(p2)) != sizeof(long));			\
	VM_BUG_ON((unsigned long)((__p1) + 1) != (unsigned long)(__p2));\
	__cmpxchg_double(__p1, __p2, o1, o2, n1, n2);			\
})

#define system_has_cmpxchg_double()	1

#endif /* __ASM_CMPXCHG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 *  S390 version
 *
 *  Derived from "include/asm-i386/elf.h"
 */

#ifndef __ASMS390_ELF_H
#define __ASMS390_ELF_H

/* s390 relocations defined by the ABIs */
#define R_390_NONE		0	/* No reloc.  */
#define R_390_8			1	/* Direct 8 bit.  */
#define R_390_12		2	/* Direct 12 bit.  */
#define R_390_16		3	/* Direct 16 bit.  */
#define R_390_32		4	/* Direct 32 bit.  */
#define R_390_PC32		5	/* PC relative 32 bit.	*/
#define R_390_GOT12		6	/* 12 bit GOT offset.  */
#define R_390_GOT32		7	/* 32 bit GOT offset.  */
#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
#define R_390_COPY		9	/* Copy symbol at runtime.  */
#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
#define R_390_RELATIVE		12	/* Adjust by program base.  */
#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
#define R_390_GOTPC		14	/* 32 bit PC rel. offset to GOT.  */
#define R_390_GOT16		15	/* 16 bit GOT offset.  */
#define R_390_PC16		16	/* PC relative 16 bit.	*/
#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
#define R_390_64		22	/* Direct 64 bit.  */
#define R_390_PC64		23	/* PC relative 64 bit.	*/
#define R_390_GOT64		24	/* 64 bit GOT offset.  */
#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code. */
#define R_390_TLS_GDCALL	38	/* Tag for function call in general
                                           dynamic TLS code.  */
#define R_390_TLS_LDCALL	39	/* Tag for function call in local
                                           dynamic TLS code.  */
#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
                                           thread local data.  */
#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
                                           thread local data.  */
#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
                                           block offset.  */
#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
                                           block offset.  */
#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
                                           block offset.  */
#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
                                           thread local data in LD code.  */
#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
                                           thread local data in LD code.  */
#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
                                           negated static TLS block offset.  */
#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
                                           negated static TLS block offset.  */
#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
                                           negated static TLS block offset.  */
#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
                                           static TLS block.  */
#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
                                           static TLS block.  */
#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
                                           block.  */
#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
                                           block.  */
#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.  */
#define R_390_TLS_TPOFF		56	/* Negate offset in static TLS
                                           block.  */
#define R_390_20		57	/* Direct 20 bit.  */
#define R_390_GOT20		58	/* 20 bit GOT offset.  */
#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
					   block offset.  */
/* Keep this the last entry.  */
#define R_390_NUM	61

/* Bits present in AT_HWCAP. */
#define HWCAP_S390_ESAN3	1
#define HWCAP_S390_ZARCH	2
#define HWCAP_S390_STFLE	4
#define HWCAP_S390_MSA		8
#define HWCAP_S390_LDISP	16
#define HWCAP_S390_EIMM		32
#define HWCAP_S390_DFP		64
#define HWCAP_S390_HPAGE	128
#define HWCAP_S390_ETF3EH	256
#define HWCAP_S390_HIGH_GPRS	512
#define HWCAP_S390_TE		1024
#define HWCAP_S390_VXRS		2048

/* Internal bits, not exposed via elf */
#define HWCAP_INT_SIE		1UL

/*
 * These are used to set parameters in the core dumps.
 */
#define ELF_CLASS	ELFCLASS64
#define ELF_DATA	ELFDATA2MSB
#define ELF_ARCH	EM_S390

/*
 * ELF register definitions..
 */

#include <asm/ptrace.h>
#include <asm/compat.h>
#include <asm/syscall.h>
#include <asm/user.h>

typedef s390_fp_regs elf_fpregset_t;
typedef s390_regs elf_gregset_t;

typedef s390_fp_regs compat_elf_fpregset_t;
typedef s390_compat_regs compat_elf_gregset_t;

#include <linux/compat.h>
#include <linux/sched.h>	/* for task_struct */
#include <asm/mmu_context.h>

#include <asm/vdso.h>

extern unsigned int vdso_enabled;

/*
 * This is used to ensure we don't load something for the wrong architecture.
 */
#define elf_check_arch(x) \
	(((x)->e_machine == EM_S390 || (x)->e_machine == EM_S390_OLD) \
         && (x)->e_ident[EI_CLASS] == ELF_CLASS) 
#define compat_elf_check_arch(x) \
	(((x)->e_machine == EM_S390 || (x)->e_machine == EM_S390_OLD) \
	 && (x)->e_ident[EI_CLASS] == ELF_CLASS)
#define compat_start_thread	start_thread31

/* For SVR4/S390 the function pointer to be registered with `atexit` is
   passed in R14. */
#define ELF_PLAT_INIT(_r, load_addr) \
	do { \
		_r->gprs[14] = 0; \
	} while (0)

#define CORE_DUMP_USE_REGSET
#define ELF_EXEC_PAGESIZE	4096

/*
 * This is the base location for PIE (ET_DYN with INTERP) loads. On
 * 64-bit, this is raised to 4GB to leave the entire 32-bit address
 * space open for things that want to use the area for 32-bit pointers.
 */
#define ELF_ET_DYN_BASE		(is_compat_task() ? 0x000400000UL : \
						    0x100000000UL)

/* This yields a mask that user programs can use to figure out what
   instruction set this CPU supports. */

extern unsigned long elf_hwcap;
#define ELF_HWCAP (elf_hwcap)

/* Internal hardware capabilities, not exposed via elf */

extern unsigned long int_hwcap;

/* This yields a string that ld.so will use to load implementation
   specific libraries for optimization.  This is more specific in
   intent than poking at uname or /proc/cpuinfo.

   For the moment, we have only optimizations for the Intel generations,
   but that could change... */

#define ELF_PLATFORM_SIZE 8
extern char elf_platform[];
#define ELF_PLATFORM (elf_platform)

#ifndef CONFIG_COMPAT
#define SET_PERSONALITY(ex) \
do {								\
	set_personality(PER_LINUX |				\
		(current->personality & (~PER_MASK)));		\
	current_thread_info()->sys_call_table = 		\
		(unsigned long) &sys_call_table;		\
} while (0)
#else /* CONFIG_COMPAT */
#define SET_PERSONALITY(ex)					\
do {								\
	if (personality(current->personality) != PER_LINUX32)	\
		set_personality(PER_LINUX |			\
			(current->personality & ~PER_MASK));	\
	if ((ex).e_ident[EI_CLASS] == ELFCLASS32) {		\
		set_thread_flag(TIF_31BIT);			\
		current_thread_info()->sys_call_table =		\
			(unsigned long)	&sys_call_table_emu;	\
	} else {						\
		clear_thread_flag(TIF_31BIT);			\
		current_thread_info()->sys_call_table =		\
			(unsigned long) &sys_call_table;	\
	}							\
} while (0)
#endif /* CONFIG_COMPAT */

/*
 * Cache aliasing on the latest machines calls for a mapping granularity
 * of 512KB. For 64-bit processes use a 512KB alignment and a randomization
 * of up to 1GB. For 31-bit processes the virtual address space is limited,
 * use no alignment and limit the randomization to 8MB.
 */
#define BRK_RND_MASK	(is_compat_task() ? 0x7ffUL : 0x3ffffUL)
#define MMAP_RND_MASK	(is_compat_task() ? 0x7ffUL : 0x3ff80UL)
#define MMAP_ALIGN_MASK	(is_compat_task() ? 0 : 0x7fUL)
#define STACK_RND_MASK	MMAP_RND_MASK

/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */
#define ARCH_DLINFO							    \
do {									    \
	if (vdso_enabled)						    \
		NEW_AUX_ENT(AT_SYSINFO_EHDR,				    \
			    (unsigned long)current->mm->context.vdso_base); \
} while (0)

struct linux_binprm;

#define ARCH_HAS_SETUP_ADDITIONAL_PAGES 1
int arch_setup_additional_pages(struct linux_binprm *, int);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _ASM_S390_PCI_INSN_H
#define _ASM_S390_PCI_INSN_H

/* Load/Store status codes */
#define ZPCI_PCI_ST_FUNC_NOT_ENABLED		4
#define ZPCI_PCI_ST_FUNC_IN_ERR			8
#define ZPCI_PCI_ST_BLOCKED			12
#define ZPCI_PCI_ST_INSUF_RES			16
#define ZPCI_PCI_ST_INVAL_AS			20
#define ZPCI_PCI_ST_FUNC_ALREADY_ENABLED	24
#define ZPCI_PCI_ST_DMA_AS_NOT_ENABLED		28
#define ZPCI_PCI_ST_2ND_OP_IN_INV_AS		36
#define ZPCI_PCI_ST_FUNC_NOT_AVAIL		40
#define ZPCI_PCI_ST_ALREADY_IN_RQ_STATE		44

/* Load/Store return codes */
#define ZPCI_PCI_LS_OK				0
#define ZPCI_PCI_LS_ERR				1
#define ZPCI_PCI_LS_BUSY			2
#define ZPCI_PCI_LS_INVAL_HANDLE		3

/* Load/Store address space identifiers */
#define ZPCI_PCIAS_MEMIO_0			0
#define ZPCI_PCIAS_MEMIO_1			1
#define ZPCI_PCIAS_MEMIO_2			2
#define ZPCI_PCIAS_MEMIO_3			3
#define ZPCI_PCIAS_MEMIO_4			4
#define ZPCI_PCIAS_MEMIO_5			5
#define ZPCI_PCIAS_CFGSPC			15

/* Modify PCI Function Controls */
#define ZPCI_MOD_FC_REG_INT	2
#define ZPCI_MOD_FC_DEREG_INT	3
#define ZPCI_MOD_FC_REG_IOAT	4
#define ZPCI_MOD_FC_DEREG_IOAT	5
#define ZPCI_MOD_FC_REREG_IOAT	6
#define ZPCI_MOD_FC_RESET_ERROR	7
#define ZPCI_MOD_FC_RESET_BLOCK	9
#define ZPCI_MOD_FC_SET_MEASURE	10

/* FIB function controls */
#define ZPCI_FIB_FC_ENABLED	0x80
#define ZPCI_FIB_FC_ERROR	0x40
#define ZPCI_FIB_FC_LS_BLOCKED	0x20
#define ZPCI_FIB_FC_DMAAS_REG	0x10

/* FIB function controls */
#define ZPCI_FIB_FC_ENABLED	0x80
#define ZPCI_FIB_FC_ERROR	0x40
#define ZPCI_FIB_FC_LS_BLOCKED	0x20
#define ZPCI_FIB_FC_DMAAS_REG	0x10

/* Function Information Block */
struct zpci_fib {
	u32 fmt		:  8;	/* format */
	u32		: 24;
	u32		: 32;
	u8 fc;			/* function controls */
	u64		: 56;
	u64 pba;		/* PCI base address */
	u64 pal;		/* PCI address limit */
	u64 iota;		/* I/O Translation Anchor */
	u32		:  1;
	u32 isc		:  3;	/* Interrupt subclass */
	u32 noi		: 12;	/* Number of interrupts */
	u32		:  2;
	u32 aibvo	:  6;	/* Adapter interrupt bit vector offset */
	u32 sum		:  1;	/* Adapter int summary bit enabled */
	u32		:  1;
	u32 aisbo	:  6;	/* Adapter int summary bit offset */
	u32		: 32;
	u64 aibv;		/* Adapter int bit vector address */
	u64 aisb;		/* Adapter int summary bit address */
	u64 fmb_addr;		/* Function measurement block address and key */
	u32		: 32;
	u32 gd;
} __packed __aligned(8);

int zpci_mod_fc(u64 req, struct zpci_fib *fib);
int zpci_refresh_trans(u64 fn, u64 addr, u64 range);
int zpci_load(u64 *data, u64 req, u64 offset);
int zpci_store(u64 data, u64 req, u64 offset);
int zpci_store_block(const u64 *data, u64 req, u64 offset);
int zpci_set_irq_ctrl(u16 ctl, char *unused, u8 isc);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *    Copyright IBM Corp. 1999, 2012
 *    Author(s): Hartmut Penner <hp@de.ibm.com>,
 *		 Martin Schwidefsky <schwidefsky@de.ibm.com>,
 *		 Denis Joseph Barrow,
 */

#ifndef _ASM_S390_LOWCORE_H
#define _ASM_S390_LOWCORE_H

#include <linux/types.h>
#include <asm/ptrace.h>
#include <asm/cpu.h>
#include <asm/types.h>

#define LC_ORDER 1
#define LC_PAGES 2

struct lowcore {
	__u8	pad_0x0000[0x0014-0x0000];	/* 0x0000 */
	__u32	ipl_parmblock_ptr;		/* 0x0014 */
	__u8	pad_0x0018[0x0080-0x0018];	/* 0x0018 */
	__u32	ext_params;			/* 0x0080 */
	__u16	ext_cpu_addr;			/* 0x0084 */
	__u16	ext_int_code;			/* 0x0086 */
	__u16	svc_ilc;			/* 0x0088 */
	__u16	svc_code;			/* 0x008a */
	__u16	pgm_ilc;			/* 0x008c */
	__u16	pgm_code;			/* 0x008e */
	__u32	data_exc_code;			/* 0x0090 */
	__u16	mon_class_num;			/* 0x0094 */
	__u8	per_code;			/* 0x0096 */
	__u8	per_atmid;			/* 0x0097 */
	__u64	per_address;			/* 0x0098 */
	__u8	exc_access_id;			/* 0x00a0 */
	__u8	per_access_id;			/* 0x00a1 */
	__u8	op_access_id;			/* 0x00a2 */
	__u8	ar_mode_id;			/* 0x00a3 */
	__u8	pad_0x00a4[0x00a8-0x00a4];	/* 0x00a4 */
	__u64	trans_exc_code;			/* 0x00a8 */
	__u64	monitor_code;			/* 0x00b0 */
	__u16	subchannel_id;			/* 0x00b8 */
	__u16	subchannel_nr;			/* 0x00ba */
	__u32	io_int_parm;			/* 0x00bc */
	__u32	io_int_word;			/* 0x00c0 */
	__u8	pad_0x00c4[0x00c8-0x00c4];	/* 0x00c4 */
	__u32	stfl_fac_list;			/* 0x00c8 */
	__u8	pad_0x00cc[0x00e8-0x00cc];	/* 0x00cc */
	__u64	mcck_interruption_code;		/* 0x00e8 */
	__u8	pad_0x00f0[0x00f4-0x00f0];	/* 0x00f0 */
	__u32	external_damage_code;		/* 0x00f4 */
	__u64	failing_storage_address;	/* 0x00f8 */
	__u8	pad_0x0100[0x0110-0x0100];	/* 0x0100 */
	__u64	breaking_event_addr;		/* 0x0110 */
	__u8	pad_0x0118[0x0120-0x0118];	/* 0x0118 */
	psw_t	restart_old_psw;		/* 0x0120 */
	psw_t	external_old_psw;		/* 0x0130 */
	psw_t	svc_old_psw;			/* 0x0140 */
	psw_t	program_old_psw;		/* 0x0150 */
	psw_t	mcck_old_psw;			/* 0x0160 */
	psw_t	io_old_psw;			/* 0x0170 */
	__u8	pad_0x0180[0x01a0-0x0180];	/* 0x0180 */
	psw_t	restart_psw;			/* 0x01a0 */
	psw_t	external_new_psw;		/* 0x01b0 */
	psw_t	svc_new_psw;			/* 0x01c0 */
	psw_t	program_new_psw;		/* 0x01d0 */
	psw_t	mcck_new_psw;			/* 0x01e0 */
	psw_t	io_new_psw;			/* 0x01f0 */

	/* Save areas. */
	__u64	save_area_sync[8];		/* 0x0200 */
	__u64	save_area_async[8];		/* 0x0240 */
	__u64	save_area_restart[1];		/* 0x0280 */

	/* CPU flags. */
	__u64	cpu_flags;			/* 0x0288 */

	/* Return psws. */
	psw_t	return_psw;			/* 0x0290 */
	psw_t	return_mcck_psw;		/* 0x02a0 */

	/* CPU accounting and timing values. */
	__u64	sync_enter_timer;		/* 0x02b0 */
	__u64	async_enter_timer;		/* 0x02b8 */
	__u64	mcck_enter_timer;		/* 0x02c0 */
	__u64	exit_timer;			/* 0x02c8 */
	__u64	user_timer;			/* 0x02d0 */
	__u64	system_timer;			/* 0x02d8 */
	__u64	steal_timer;			/* 0x02e0 */
	__u64	last_update_timer;		/* 0x02e8 */
	__u64	last_update_clock;		/* 0x02f0 */
	__u64	int_clock;			/* 0x02f8 */
	__u64	mcck_clock;			/* 0x0300 */
	__u64	clock_comparator;		/* 0x0308 */

	/* Current process. */
	__u64	current_task;			/* 0x0310 */
	__u64	thread_info;			/* 0x0318 */
	__u64	kernel_stack;			/* 0x0320 */

	/* Interrupt, panic and restart stack. */
	__u64	async_stack;			/* 0x0328 */
	__u64	panic_stack;			/* 0x0330 */
	__u64	restart_stack;			/* 0x0338 */

	/* Restart function and parameter. */
	__u64	restart_fn;			/* 0x0340 */
	__u64	restart_data;			/* 0x0348 */
	__u64	restart_source;			/* 0x0350 */

	/* Address space pointer. */
	__u64	kernel_asce;			/* 0x0358 */
	__u64	user_asce;			/* 0x0360 */

	/*
	 * The lpp and current_pid fields form a
	 * 64-bit value that is set as program
	 * parameter with the LPP instruction.
	 */
	__u32	lpp;				/* 0x0368 */
	__u32	current_pid;			/* 0x036c */

	/* SMP info area */
	__u32	cpu_nr;				/* 0x0370 */
	__u32	softirq_pending;		/* 0x0374 */
	__u64	percpu_offset;			/* 0x0378 */
	__u64	vdso_per_cpu_data;		/* 0x0380 */
	__u64	machine_flags;			/* 0x0388 */
	__u8	pad_0x0390[0x0398-0x0390];	/* 0x0390 */
	__u64	gmap;				/* 0x0398 */
	__u32	spinlock_lockval;		/* 0x03a0 */
	__u32	fpu_flags;			/* 0x03a4 */
	__u8	pad_0x03a8[0x0400-0x03a8];	/* 0x03a8 */

	/* Per cpu primary space access list */
	__u32	paste[16];			/* 0x0400 */

	__u8	pad_0x04c0[0x0e00-0x0440];	/* 0x0440 */

	/*
	 * 0xe00 contains the address of the IPL Parameter Information
	 * block. Dump tools need IPIB for IPL after dump.
	 * Note: do not change the position of any fields in 0x0e00-0x0f00
	 */
	__u64	ipib;				/* 0x0e00 */
	__u32	ipib_checksum;			/* 0x0e08 */
	__u64	vmcore_info;			/* 0x0e0c */
	__u8	pad_0x0e14[0x0e18-0x0e14];	/* 0x0e14 */
	__u64	os_info;			/* 0x0e18 */
	__u8	pad_0x0e20[0x0f00-0x0e20];	/* 0x0e20 */

	/* Extended facility list */
	__u64	stfle_fac_list[32];		/* 0x0f00 */
	__u8	pad_0x1000[0x11b0-0x1000];	/* 0x1000 */

	/* Pointer to vector register save area */
	__u64	vector_save_area_addr;		/* 0x11b0 */

	/* 64 bit extparam used for pfault/diag 250: defined by architecture */
	__u64	ext_params2;			/* 0x11B8 */
	__u8	pad_0x11c0[0x1200-0x11C0];	/* 0x11C0 */

	/* CPU register save area: defined by architecture */
	__u64	floating_pt_save_area[16];	/* 0x1200 */
	__u64	gpregs_save_area[16];		/* 0x1280 */
	psw_t	psw_save_area;			/* 0x1300 */
	__u8	pad_0x1310[0x1318-0x1310];	/* 0x1310 */
	__u32	prefixreg_save_area;		/* 0x1318 */
	__u32	fpt_creg_save_area;		/* 0x131c */
	__u8	pad_0x1320[0x1324-0x1320];	/* 0x1320 */
	__u32	tod_progreg_save_area;		/* 0x1324 */
	__u32	cpu_timer_save_area[2];		/* 0x1328 */
	__u32	clock_comp_save_area[2];	/* 0x1330 */
	__u8	pad_0x1338[0x1340-0x1338];	/* 0x1338 */
	__u32	access_regs_save_area[16];	/* 0x1340 */
	__u64	cregs_save_area[16];		/* 0x1380 */
	__u8	pad_0x1400[0x1800-0x1400];	/* 0x1400 */

	/* Transaction abort diagnostic block */
	__u8	pgm_tdb[256];			/* 0x1800 */
	__u8	pad_0x1900[0x1c00-0x1900];	/* 0x1900 */

	/* Software defined save area for vector registers */
	__u8	vector_save_area[1024];		/* 0x1c00 */
} __packed;

#define S390_lowcore (*((struct lowcore *) 0))

extern struct lowcore *lowcore_ptr[];

static inline void set_prefix(__u32 address)
{
	asm volatile("spx %0" : : "m" (address) : "memory");
}

static inline __u32 store_prefix(void)
{
	__u32 address;

	asm volatile("stpx %0" : "=m" (address));
	return address;
}

#endif /* _ASM_S390_LOWCORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef _ASM_S390_PCI_DMA_H
#define _ASM_S390_PCI_DMA_H

/* I/O Translation Anchor (IOTA) */
enum zpci_ioat_dtype {
	ZPCI_IOTA_STO = 0,
	ZPCI_IOTA_RTTO = 1,
	ZPCI_IOTA_RSTO = 2,
	ZPCI_IOTA_RFTO = 3,
	ZPCI_IOTA_PFAA = 4,
	ZPCI_IOTA_IOPFAA = 5,
	ZPCI_IOTA_IOPTO = 7
};

#define ZPCI_IOTA_IOT_ENABLED		0x800UL
#define ZPCI_IOTA_DT_ST			(ZPCI_IOTA_STO	<< 2)
#define ZPCI_IOTA_DT_RT			(ZPCI_IOTA_RTTO << 2)
#define ZPCI_IOTA_DT_RS			(ZPCI_IOTA_RSTO << 2)
#define ZPCI_IOTA_DT_RF			(ZPCI_IOTA_RFTO << 2)
#define ZPCI_IOTA_DT_PF			(ZPCI_IOTA_PFAA << 2)
#define ZPCI_IOTA_FS_4K			0
#define ZPCI_IOTA_FS_1M			1
#define ZPCI_IOTA_FS_2G			2
#define ZPCI_KEY			(PAGE_DEFAULT_KEY << 5)

#define ZPCI_TABLE_SIZE_RT	(1UL << 42)

#define ZPCI_IOTA_STO_FLAG	(ZPCI_IOTA_IOT_ENABLED | ZPCI_KEY | ZPCI_IOTA_DT_ST)
#define ZPCI_IOTA_RTTO_FLAG	(ZPCI_IOTA_IOT_ENABLED | ZPCI_KEY | ZPCI_IOTA_DT_RT)
#define ZPCI_IOTA_RSTO_FLAG	(ZPCI_IOTA_IOT_ENABLED | ZPCI_KEY | ZPCI_IOTA_DT_RS)
#define ZPCI_IOTA_RFTO_FLAG	(ZPCI_IOTA_IOT_ENABLED | ZPCI_KEY | ZPCI_IOTA_DT_RF)
#define ZPCI_IOTA_RFAA_FLAG	(ZPCI_IOTA_IOT_ENABLED | ZPCI_KEY | ZPCI_IOTA_DT_PF | ZPCI_IOTA_FS_2G)

/* I/O Region and segment tables */
#define ZPCI_INDEX_MASK			0x7ffUL

#define ZPCI_TABLE_TYPE_MASK		0xc
#define ZPCI_TABLE_TYPE_RFX		0xc
#define ZPCI_TABLE_TYPE_RSX		0x8
#define ZPCI_TABLE_TYPE_RTX		0x4
#define ZPCI_TABLE_TYPE_SX		0x0

#define ZPCI_TABLE_LEN_RFX		0x3
#define ZPCI_TABLE_LEN_RSX		0x3
#define ZPCI_TABLE_LEN_RTX		0x3

#define ZPCI_TABLE_OFFSET_MASK		0xc0
#define ZPCI_TABLE_SIZE			0x4000
#define ZPCI_TABLE_ALIGN		ZPCI_TABLE_SIZE
#define ZPCI_TABLE_ENTRY_SIZE		(sizeof(unsigned long))
#define ZPCI_TABLE_ENTRIES		(ZPCI_TABLE_SIZE / ZPCI_TABLE_ENTRY_SIZE)

#define ZPCI_TABLE_BITS			11
#define ZPCI_PT_BITS			8
#define ZPCI_ST_SHIFT			(ZPCI_PT_BITS + PAGE_SHIFT)
#define ZPCI_RT_SHIFT			(ZPCI_ST_SHIFT + ZPCI_TABLE_BITS)

#define ZPCI_RTE_FLAG_MASK		0x3fffUL
#define ZPCI_RTE_ADDR_MASK		(~ZPCI_RTE_FLAG_MASK)
#define ZPCI_STE_FLAG_MASK		0x7ffUL
#define ZPCI_STE_ADDR_MASK		(~ZPCI_STE_FLAG_MASK)

/* I/O Page tables */
#define ZPCI_PTE_VALID_MASK		0x400
#define ZPCI_PTE_INVALID		0x400
#define ZPCI_PTE_VALID			0x000
#define ZPCI_PT_SIZE			0x800
#define ZPCI_PT_ALIGN			ZPCI_PT_SIZE
#define ZPCI_PT_ENTRIES			(ZPCI_PT_SIZE / ZPCI_TABLE_ENTRY_SIZE)
#define ZPCI_PT_MASK			(ZPCI_PT_ENTRIES - 1)

#define ZPCI_PTE_FLAG_MASK		0xfffUL
#define ZPCI_PTE_ADDR_MASK		(~ZPCI_PTE_FLAG_MASK)

/* Shared bits */
#define ZPCI_TABLE_VALID		0x00
#define ZPCI_TABLE_INVALID		0x20
#define ZPCI_TABLE_PROTECTED		0x200
#define ZPCI_TABLE_UNPROTECTED		0x000

#define ZPCI_TABLE_VALID_MASK		0x20
#define ZPCI_TABLE_PROT_MASK		0x200

static inline unsigned int calc_rtx(dma_addr_t ptr)
{
	return ((unsigned long) ptr >> ZPCI_RT_SHIFT) & ZPCI_INDEX_MASK;
}

static inline unsigned int calc_sx(dma_addr_t ptr)
{
	return ((unsigned long) ptr >> ZPCI_ST_SHIFT) & ZPCI_INDEX_MASK;
}

static inline unsigned int calc_px(dma_addr_t ptr)
{
	return ((unsigned long) ptr >> PAGE_SHIFT) & ZPCI_PT_MASK;
}

static inline void set_pt_pfaa(unsigned long *entry, void *pfaa)
{
	*entry &= ZPCI_PTE_FLAG_MASK;
	*entry |= ((unsigned long) pfaa & ZPCI_PTE_ADDR_MASK);
}

static inline void set_rt_sto(unsigned long *entry, void *sto)
{
	*entry &= ZPCI_RTE_FLAG_MASK;
	*entry |= ((unsigned long) sto & ZPCI_RTE_ADDR_MASK);
	*entry |= ZPCI_TABLE_TYPE_RTX;
}

static inline void set_st_pto(unsigned long *entry, void *pto)
{
	*entry &= ZPCI_STE_FLAG_MASK;
	*entry |= ((unsigned long) pto & ZPCI_STE_ADDR_MASK);
	*entry |= ZPCI_TABLE_TYPE_SX;
}

static inline void validate_rt_entry(unsigned long *entry)
{
	*entry &= ~ZPCI_TABLE_VALID_MASK;
	*entry &= ~ZPCI_TABLE_OFFSET_MASK;
	*entry |= ZPCI_TABLE_VALID;
	*entry |= ZPCI_TABLE_LEN_RTX;
}

static inline void validate_st_entry(unsigned long *entry)
{
	*entry &= ~ZPCI_TABLE_VALID_MASK;
	*entry |= ZPCI_TABLE_VALID;
}

static inline void invalidate_table_entry(unsigned long *entry)
{
	*entry &= ~ZPCI_TABLE_VALID_MASK;
	*entry |= ZPCI_TABLE_INVALID;
}

static inline void invalidate_pt_entry(unsigned long *entry)
{
	WARN_ON_ONCE((*entry & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_INVALID);
	*entry &= ~ZPCI_PTE_VALID_MASK;
	*entry |= ZPCI_PTE_INVALID;
}

static inline void validate_pt_entry(unsigned long *entry)
{
	WARN_ON_ONCE((*entry & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID);
	*entry &= ~ZPCI_PTE_VALID_MASK;
	*entry |= ZPCI_PTE_VALID;
}

static inline void entry_set_protected(unsigned long *entry)
{
	*entry &= ~ZPCI_TABLE_PROT_MASK;
	*entry |= ZPCI_TABLE_PROTECTED;
}

static inline void entry_clr_protected(unsigned long *entry)
{
	*entry &= ~ZPCI_TABLE_PROT_MASK;
	*entry |= ZPCI_TABLE_UNPROTECTED;
}

static inline int reg_entry_isvalid(unsigned long entry)
{
	return (entry & ZPCI_TABLE_VALID_MASK) == ZPCI_TABLE_VALID;
}

static inline int pt_entry_isvalid(unsigned long entry)
{
	return (entry & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID;
}

static inline int entry_isprotected(unsigned long entry)
{
	return (entry & ZPCI_TABLE_PROT_MASK) == ZPCI_TABLE_PROTECTED;
}

static inline unsigned long *get_rt_sto(unsigned long entry)
{
	return ((entry & ZPCI_TABLE_TYPE_MASK) == ZPCI_TABLE_TYPE_RTX)
		? (unsigned long *) (entry & ZPCI_RTE_ADDR_MASK)
		: NULL;
}

static inline unsigned long *get_st_pto(unsigned long entry)
{
	return ((entry & ZPCI_TABLE_TYPE_MASK) == ZPCI_TABLE_TYPE_SX)
		? (unsigned long *) (entry & ZPCI_STE_ADDR_MASK)
		: NULL;
}

/* Prototypes */
int zpci_dma_init_device(struct zpci_dev *);
void zpci_dma_exit_device(struct zpci_dev *);
void dma_free_seg_table(unsigned long);
unsigned long *dma_alloc_cpu_table(void);
void dma_cleanup_tables(unsigned long *);
unsigned long *dma_walk_cpu_trans(unsigned long *rto, dma_addr_t dma_addr);
void dma_update_cpu_trans(unsigned long *entry, void *page_addr, int flags);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Access to user system call parameters and results
 *
 *  Copyright IBM Corp. 2008
 *  Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License (version 2 only)
 * as published by the Free Software Foundation.
 */

#ifndef _ASM_SYSCALL_H
#define _ASM_SYSCALL_H	1

#include <uapi/linux/audit.h>
#include <linux/sched.h>
#include <linux/err.h>
#include <asm/ptrace.h>

/*
 * The syscall table always contains 32 bit pointers since we know that the
 * address of the function to be called is (way) below 4GB.  So the "int"
 * type here is what we want [need] for both 32 bit and 64 bit systems.
 */
extern const unsigned int sys_call_table[];
extern const unsigned int sys_call_table_emu[];

static inline long syscall_get_nr(struct task_struct *task,
				  struct pt_regs *regs)
{
	return test_pt_regs_flag(regs, PIF_SYSCALL) ?
		(regs->int_code & 0xffff) : -1;
}

static inline void syscall_rollback(struct task_struct *task,
				    struct pt_regs *regs)
{
	regs->gprs[2] = regs->orig_gpr2;
}

static inline long syscall_get_error(struct task_struct *task,
				     struct pt_regs *regs)
{
	return IS_ERR_VALUE(regs->gprs[2]) ? regs->gprs[2] : 0;
}

static inline long syscall_get_return_value(struct task_struct *task,
					    struct pt_regs *regs)
{
	return regs->gprs[2];
}

static inline void syscall_set_return_value(struct task_struct *task,
					    struct pt_regs *regs,
					    int error, long val)
{
	regs->gprs[2] = error ? error : val;
}

static inline void syscall_get_arguments(struct task_struct *task,
					 struct pt_regs *regs,
					 unsigned int i, unsigned int n,
					 unsigned long *args)
{
	unsigned long mask = -1UL;

	/*
	 * No arguments for this syscall, there's nothing to do.
	 */
	if (!n)
		return;

	BUG_ON(i + n > 6);
#ifdef CONFIG_COMPAT
	if (test_tsk_thread_flag(task, TIF_31BIT))
		mask = 0xffffffff;
#endif
	while (n-- > 0)
		if (i + n > 0)
			args[n] = regs->gprs[2 + i + n] & mask;
	if (i == 0)
		args[0] = regs->orig_gpr2 & mask;
}

static inline void syscall_set_arguments(struct task_struct *task,
					 struct pt_regs *regs,
					 unsigned int i, unsigned int n,
					 const unsigned long *args)
{
	BUG_ON(i + n > 6);
	while (n-- > 0)
		if (i + n > 0)
			regs->gprs[2 + i + n] = args[n];
	if (i == 0)
		regs->orig_gpr2 = args[0];
}

static inline int syscall_get_arch(void)
{
#ifdef CONFIG_COMPAT
	if (test_tsk_thread_flag(current, TIF_31BIT))
		return AUDIT_ARCH_S390;
#endif
	return AUDIT_ARCH_S390X;
}
#endif	/* _ASM_SYSCALL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _ASM_IRQ_H
#define _ASM_IRQ_H

#define EXT_INTERRUPT	0
#define IO_INTERRUPT	1
#define THIN_INTERRUPT	2

#define NR_IRQS_BASE	3

#define NR_IRQS	NR_IRQS_BASE
#define NR_IRQS_LEGACY NR_IRQS_BASE

/* External interruption codes */
#define EXT_IRQ_INTERRUPT_KEY	0x0040
#define EXT_IRQ_CLK_COMP	0x1004
#define EXT_IRQ_CPU_TIMER	0x1005
#define EXT_IRQ_WARNING_TRACK	0x1007
#define EXT_IRQ_MALFUNC_ALERT	0x1200
#define EXT_IRQ_EMERGENCY_SIG	0x1201
#define EXT_IRQ_EXTERNAL_CALL	0x1202
#define EXT_IRQ_TIMING_ALERT	0x1406
#define EXT_IRQ_MEASURE_ALERT	0x1407
#define EXT_IRQ_SERVICE_SIG	0x2401
#define EXT_IRQ_CP_SERVICE	0x2603
#define EXT_IRQ_IUCV		0x4000

#ifndef __ASSEMBLY__

#include <linux/hardirq.h>
#include <linux/percpu.h>
#include <linux/cache.h>
#include <linux/types.h>

enum interruption_class {
	IRQEXT_CLK,
	IRQEXT_EXC,
	IRQEXT_EMS,
	IRQEXT_TMR,
	IRQEXT_TLA,
	IRQEXT_PFL,
	IRQEXT_DSD,
	IRQEXT_VRT,
	IRQEXT_SCP,
	IRQEXT_IUC,
	IRQEXT_CMS,
	IRQEXT_CMC,
	IRQEXT_FTP,
	IRQIO_CIO,
	IRQIO_QAI,
	IRQIO_DAS,
	IRQIO_C15,
	IRQIO_C70,
	IRQIO_TAP,
	IRQIO_VMR,
	IRQIO_LCS,
	IRQIO_CTC,
	IRQIO_APB,
	IRQIO_ADM,
	IRQIO_CSC,
	IRQIO_PCI,
	IRQIO_MSI,
	IRQIO_VIR,
	IRQIO_VAI,
	NMI_NMI,
	CPU_RST,
	NR_ARCH_IRQS
};

struct irq_stat {
	unsigned int irqs[NR_ARCH_IRQS];
};

DECLARE_PER_CPU_SHARED_ALIGNED(struct irq_stat, irq_stat);

static __always_inline void inc_irq_stat(enum interruption_class irq)
{
	__this_cpu_inc(irq_stat.irqs[irq]);
}

struct ext_code {
	unsigned short subcode;
	unsigned short code;
};

typedef void (*ext_int_handler_t)(struct ext_code, unsigned int, unsigned long);

int register_external_irq(u16 code, ext_int_handler_t handler);
int unregister_external_irq(u16 code, ext_int_handler_t handler);

enum irq_subclass {
	IRQ_SUBCLASS_MEASUREMENT_ALERT = 5,
	IRQ_SUBCLASS_SERVICE_SIGNAL = 9,
};

#define CR0_IRQ_SUBCLASS_MASK					  \
	((1UL << (63 - 30))  /* Warning Track */		| \
	 (1UL << (63 - 48))  /* Malfunction Alert */		| \
	 (1UL << (63 - 49))  /* Emergency Signal */		| \
	 (1UL << (63 - 50))  /* External Call */		| \
	 (1UL << (63 - 52))  /* Clock Comparator */		| \
	 (1UL << (63 - 53))  /* CPU Timer */			| \
	 (1UL << (63 - 54))  /* Service Signal */		| \
	 (1UL << (63 - 57))  /* Interrupt Key */		| \
	 (1UL << (63 - 58))  /* Measurement Alert */		| \
	 (1UL << (63 - 59))  /* Timing Alert */			| \
	 (1UL << (63 - 62))) /* IUCV */

void irq_subclass_register(enum irq_subclass subclass);
void irq_subclass_unregister(enum irq_subclass subclass);

#define irq_canonicalize(irq)  (irq)

#endif /* __ASSEMBLY__ */

#endif /* _ASM_IRQ_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _ASM_S390_VGA_H
#define _ASM_S390_VGA_H

/* Avoid compile errors due to missing asm/vga.h */

#endif /* _ASM_S390_VGA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 *  S390 version
 *    Copyright IBM Corp. 1999
 *
 *  Derived from "include/asm-i386/timex.h"
 *    Copyright (C) 1992, Linus Torvalds
 */

#ifndef _ASM_S390_TIMEX_H
#define _ASM_S390_TIMEX_H

#include <asm/lowcore.h>
#include <linux/time64.h>

/* The value of the TOD clock for 1.1.1970. */
#define TOD_UNIX_EPOCH 0x7d91048bca000000ULL

/* Inline functions for clock register access. */
static inline int set_tod_clock(__u64 time)
{
	int cc;

	asm volatile(
		"   sck   %1\n"
		"   ipm   %0\n"
		"   srl   %0,28\n"
		: "=d" (cc) : "Q" (time) : "cc");
	return cc;
}

static inline int store_tod_clock(__u64 *time)
{
	int cc;

	asm volatile(
		"   stck  %1\n"
		"   ipm   %0\n"
		"   srl   %0,28\n"
		: "=d" (cc), "=Q" (*time) : : "cc");
	return cc;
}

static inline void set_clock_comparator(__u64 time)
{
	asm volatile("sckc %0" : : "Q" (time));
}

static inline void store_clock_comparator(__u64 *time)
{
	asm volatile("stckc %0" : "=Q" (*time));
}

void clock_comparator_work(void);

void __init ptff_init(void);

extern unsigned char ptff_function_mask[16];
extern unsigned long lpar_offset;
extern unsigned long initial_leap_seconds;

/* Function codes for the ptff instruction. */
#define PTFF_QAF	0x00	/* query available functions */
#define PTFF_QTO	0x01	/* query tod offset */
#define PTFF_QSI	0x02	/* query steering information */
#define PTFF_QUI	0x04	/* query UTC information */
#define PTFF_ATO	0x40	/* adjust tod offset */
#define PTFF_STO	0x41	/* set tod offset */
#define PTFF_SFS	0x42	/* set fine steering rate */
#define PTFF_SGS	0x43	/* set gross steering rate */

/* Query TOD offset result */
struct ptff_qto {
	unsigned long long physical_clock;
	unsigned long long tod_offset;
	unsigned long long logical_tod_offset;
	unsigned long long tod_epoch_difference;
} __packed;

static inline int ptff_query(unsigned int nr)
{
	unsigned char *ptr;

	ptr = ptff_function_mask + (nr >> 3);
	return (*ptr & (0x80 >> (nr & 7))) != 0;
}

/* Query UTC information result */
struct ptff_qui {
	unsigned int tm : 2;
	unsigned int ts : 2;
	unsigned int : 28;
	unsigned int pad_0x04;
	unsigned long leap_event;
	short old_leap;
	short new_leap;
	unsigned int pad_0x14;
	unsigned long prt[5];
	unsigned long cst[3];
	unsigned int skew;
	unsigned int pad_0x5c[41];
} __packed;

static inline int ptff(void *ptff_block, size_t len, unsigned int func)
{
	typedef struct { char _[len]; } addrtype;
	register unsigned int reg0 asm("0") = func;
	register unsigned long reg1 asm("1") = (unsigned long) ptff_block;
	int rc;

	asm volatile(
		"	.word	0x0104\n"
		"	ipm	%0\n"
		"	srl	%0,28\n"
		: "=d" (rc), "+m" (*(addrtype *) ptff_block)
		: "d" (reg0), "d" (reg1) : "cc");
	return rc;
}

static inline unsigned long long local_tick_disable(void)
{
	unsigned long long old;

	old = S390_lowcore.clock_comparator;
	S390_lowcore.clock_comparator = -1ULL;
	set_clock_comparator(S390_lowcore.clock_comparator);
	return old;
}

static inline void local_tick_enable(unsigned long long comp)
{
	S390_lowcore.clock_comparator = comp;
	set_clock_comparator(S390_lowcore.clock_comparator);
}

#define CLOCK_TICK_RATE		1193180 /* Underlying HZ */
#define STORE_CLOCK_EXT_SIZE	16	/* stcke writes 16 bytes */

typedef unsigned long long cycles_t;

static inline void get_tod_clock_ext(char *clk)
{
	typedef struct { char _[STORE_CLOCK_EXT_SIZE]; } addrtype;

	asm volatile("stcke %0" : "=Q" (*(addrtype *) clk) : : "cc");
}

static inline unsigned long long get_tod_clock(void)
{
	unsigned char clk[STORE_CLOCK_EXT_SIZE];

	get_tod_clock_ext(clk);
	return *((unsigned long long *)&clk[1]);
}

static inline unsigned long long get_tod_clock_fast(void)
{
#ifdef CONFIG_HAVE_MARCH_Z9_109_FEATURES
	unsigned long long clk;

	asm volatile("stckf %0" : "=Q" (clk) : : "cc");
	return clk;
#else
	return get_tod_clock();
#endif
}

static inline cycles_t get_cycles(void)
{
	return (cycles_t) get_tod_clock() >> 2;
}

int get_phys_clock(unsigned long long *clock);
void init_cpu_timer(void);
unsigned long long monotonic_clock(void);

void tod_to_timeval(__u64 todval, struct timespec64 *xt);

static inline
void stck_to_timespec64(unsigned long long stck, struct timespec64 *ts)
{
	tod_to_timeval(stck - TOD_UNIX_EPOCH, ts);
}

extern u64 sched_clock_base_cc;

/**
 * get_clock_monotonic - returns current time in clock rate units
 *
 * The caller must ensure that preemption is disabled.
 * The clock and sched_clock_base get changed via stop_machine.
 * Therefore preemption must be disabled when calling this
 * function, otherwise the returned value is not guaranteed to
 * be monotonic.
 */
static inline unsigned long long get_tod_clock_monotonic(void)
{
	return get_tod_clock() - sched_clock_base_cc;
}

/**
 * tod_to_ns - convert a TOD format value to nanoseconds
 * @todval: to be converted TOD format value
 * Returns: number of nanoseconds that correspond to the TOD format value
 *
 * Converting a 64 Bit TOD format value to nanoseconds means that the value
 * must be divided by 4.096. In order to achieve that we multiply with 125
 * and divide by 512:
 *
 *    ns = (todval * 125) >> 9;
 *
 * In order to avoid an overflow with the multiplication we can rewrite this.
 * With a split todval == 2^32 * th + tl (th upper 32 bits, tl lower 32 bits)
 * we end up with
 *
 *    ns = ((2^32 * th + tl) * 125 ) >> 9;
 * -> ns = (2^23 * th * 125) + ((tl * 125) >> 9);
 *
 */
static inline unsigned long long tod_to_ns(unsigned long long todval)
{
	unsigned long long ns;

	ns = ((todval >> 32) << 23) * 125;
	ns += ((todval & 0xffffffff) * 125) >> 9;
	return ns;
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef _S390_VTIME_H
#define _S390_VTIME_H

#define __ARCH_HAS_VTIME_ACCOUNT
#define __ARCH_HAS_VTIME_TASK_SWITCH

#endif /* _S390_VTIME_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Optimited xor routines
 *
 * Copyright IBM Corp. 2016
 * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
 */
#ifndef _ASM_S390_XOR_H
#define _ASM_S390_XOR_H

extern struct xor_block_template xor_block_xc;

#undef XOR_TRY_TEMPLATES
#define XOR_TRY_TEMPLATES				\
do {							\
	xor_speed(&xor_block_xc);			\
} while (0)

#define XOR_SELECT_TEMPLATE(FASTEST)	(&xor_block_xc)

#endif /* _ASM_S390_XOR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *   Machine check handler definitions
 *
 *    Copyright IBM Corp. 2000, 2009
 *    Author(s): Ingo Adlung <adlung@de.ibm.com>,
 *		 Martin Schwidefsky <schwidefsky@de.ibm.com>,
 *		 Cornelia Huck <cornelia.huck@de.ibm.com>,
 *		 Heiko Carstens <heiko.carstens@de.ibm.com>,
 */

#ifndef _ASM_S390_NMI_H
#define _ASM_S390_NMI_H

#include <linux/const.h>
#include <linux/types.h>

#define MCCK_CODE_SYSTEM_DAMAGE		_BITUL(63)
#define MCCK_CODE_CPU_TIMER_VALID	_BITUL(63 - 46)
#define MCCK_CODE_PSW_MWP_VALID		_BITUL(63 - 20)
#define MCCK_CODE_PSW_IA_VALID		_BITUL(63 - 23)

#ifndef __ASSEMBLY__

union mci {
	unsigned long val;
	struct {
		u64 sd :  1; /* 00 system damage */
		u64 pd :  1; /* 01 instruction-processing damage */
		u64 sr :  1; /* 02 system recovery */
		u64    :  1; /* 03 */
		u64 cd :  1; /* 04 timing-facility damage */
		u64 ed :  1; /* 05 external damage */
		u64    :  1; /* 06 */
		u64 dg :  1; /* 07 degradation */
		u64 w  :  1; /* 08 warning pending */
		u64 cp :  1; /* 09 channel-report pending */
		u64 sp :  1; /* 10 service-processor damage */
		u64 ck :  1; /* 11 channel-subsystem damage */
		u64    :  2; /* 12-13 */
		u64 b  :  1; /* 14 backed up */
		u64    :  1; /* 15 */
		u64 se :  1; /* 16 storage error uncorrected */
		u64 sc :  1; /* 17 storage error corrected */
		u64 ke :  1; /* 18 storage-key error uncorrected */
		u64 ds :  1; /* 19 storage degradation */
		u64 wp :  1; /* 20 psw mwp validity */
		u64 ms :  1; /* 21 psw mask and key validity */
		u64 pm :  1; /* 22 psw program mask and cc validity */
		u64 ia :  1; /* 23 psw instruction address validity */
		u64 fa :  1; /* 24 failing storage address validity */
		u64 vr :  1; /* 25 vector register validity */
		u64 ec :  1; /* 26 external damage code validity */
		u64 fp :  1; /* 27 floating point register validity */
		u64 gr :  1; /* 28 general register validity */
		u64 cr :  1; /* 29 control register validity */
		u64    :  1; /* 30 */
		u64 st :  1; /* 31 storage logical validity */
		u64 ie :  1; /* 32 indirect storage error */
		u64 ar :  1; /* 33 access register validity */
		u64 da :  1; /* 34 delayed access exception */
		u64    :  7; /* 35-41 */
		u64 pr :  1; /* 42 tod programmable register validity */
		u64 fc :  1; /* 43 fp control register validity */
		u64 ap :  1; /* 44 ancillary report */
		u64    :  1; /* 45 */
		u64 ct :  1; /* 46 cpu timer validity */
		u64 cc :  1; /* 47 clock comparator validity */
		u64    : 16; /* 47-63 */
	};
};

struct pt_regs;

extern void s390_handle_mcck(void);
extern void s390_do_machine_check(struct pt_regs *regs);

#endif /* __ASSEMBLY__ */
#endif /* _ASM_S390_NMI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _ASM_S390_PCI_IO_H
#define _ASM_S390_PCI_IO_H

#ifdef CONFIG_PCI

#include <linux/kernel.h>
#include <linux/slab.h>
#include <asm/pci_insn.h>

/* I/O Map */
#define ZPCI_IOMAP_SHIFT		48
#define ZPCI_IOMAP_ADDR_BASE		0x8000000000000000UL
#define ZPCI_IOMAP_ADDR_OFF_MASK	((1UL << ZPCI_IOMAP_SHIFT) - 1)
#define ZPCI_IOMAP_MAX_ENTRIES							\
	((ULONG_MAX - ZPCI_IOMAP_ADDR_BASE + 1) / (1UL << ZPCI_IOMAP_SHIFT))
#define ZPCI_IOMAP_ADDR_IDX_MASK						\
	(~ZPCI_IOMAP_ADDR_OFF_MASK - ZPCI_IOMAP_ADDR_BASE)

struct zpci_iomap_entry {
	u32 fh;
	u8 bar;
	u16 count;
};

extern struct zpci_iomap_entry *zpci_iomap_start;

#define ZPCI_ADDR(idx) (ZPCI_IOMAP_ADDR_BASE | ((u64) idx << ZPCI_IOMAP_SHIFT))
#define ZPCI_IDX(addr)								\
	(((__force u64) addr & ZPCI_IOMAP_ADDR_IDX_MASK) >> ZPCI_IOMAP_SHIFT)
#define ZPCI_OFFSET(addr)							\
	((__force u64) addr & ZPCI_IOMAP_ADDR_OFF_MASK)

#define ZPCI_CREATE_REQ(handle, space, len)					\
	((u64) handle << 32 | space << 16 | len)

#define zpci_read(LENGTH, RETTYPE)						\
static inline RETTYPE zpci_read_##RETTYPE(const volatile void __iomem *addr)	\
{										\
	struct zpci_iomap_entry *entry = &zpci_iomap_start[ZPCI_IDX(addr)];	\
	u64 req = ZPCI_CREATE_REQ(entry->fh, entry->bar, LENGTH);		\
	u64 data;								\
	int rc;									\
										\
	rc = zpci_load(&data, req, ZPCI_OFFSET(addr));				\
	if (rc)									\
		data = -1ULL;							\
	return (RETTYPE) data;							\
}

#define zpci_write(LENGTH, VALTYPE)						\
static inline void zpci_write_##VALTYPE(VALTYPE val,				\
					const volatile void __iomem *addr)	\
{										\
	struct zpci_iomap_entry *entry = &zpci_iomap_start[ZPCI_IDX(addr)];	\
	u64 req = ZPCI_CREATE_REQ(entry->fh, entry->bar, LENGTH);		\
	u64 data = (VALTYPE) val;						\
										\
	zpci_store(data, req, ZPCI_OFFSET(addr));				\
}

zpci_read(8, u64)
zpci_read(4, u32)
zpci_read(2, u16)
zpci_read(1, u8)
zpci_write(8, u64)
zpci_write(4, u32)
zpci_write(2, u16)
zpci_write(1, u8)

static inline int zpci_write_single(u64 req, const u64 *data, u64 offset, u8 len)
{
	u64 val;

	switch (len) {
	case 1:
		val = (u64) *((u8 *) data);
		break;
	case 2:
		val = (u64) *((u16 *) data);
		break;
	case 4:
		val = (u64) *((u32 *) data);
		break;
	case 8:
		val = (u64) *((u64 *) data);
		break;
	default:
		val = 0;		/* let FW report error */
		break;
	}
	return zpci_store(val, req, offset);
}

static inline int zpci_read_single(u64 req, u64 *dst, u64 offset, u8 len)
{
	u64 data;
	int cc;

	cc = zpci_load(&data, req, offset);
	if (cc)
		goto out;

	switch (len) {
	case 1:
		*((u8 *) dst) = (u8) data;
		break;
	case 2:
		*((u16 *) dst) = (u16) data;
		break;
	case 4:
		*((u32 *) dst) = (u32) data;
		break;
	case 8:
		*((u64 *) dst) = (u64) data;
		break;
	}
out:
	return cc;
}

static inline int zpci_write_block(u64 req, const u64 *data, u64 offset)
{
	return zpci_store_block(data, req, offset);
}

static inline u8 zpci_get_max_write_size(u64 src, u64 dst, int len, int max)
{
	int count = len > max ? max : len, size = 1;

	while (!(src & 0x1) && !(dst & 0x1) && ((size << 1) <= count)) {
		dst = dst >> 1;
		src = src >> 1;
		size = size << 1;
	}
	return size;
}

static inline int zpci_memcpy_fromio(void *dst,
				     const volatile void __iomem *src,
				     unsigned long n)
{
	struct zpci_iomap_entry *entry = &zpci_iomap_start[ZPCI_IDX(src)];
	u64 req, offset = ZPCI_OFFSET(src);
	int size, rc = 0;

	while (n > 0) {
		size = zpci_get_max_write_size((u64 __force) src,
					       (u64) dst, n, 8);
		req = ZPCI_CREATE_REQ(entry->fh, entry->bar, size);
		rc = zpci_read_single(req, dst, offset, size);
		if (rc)
			break;
		offset += size;
		dst += size;
		n -= size;
	}
	return rc;
}

static inline int zpci_memcpy_toio(volatile void __iomem *dst,
				   const void *src, unsigned long n)
{
	struct zpci_iomap_entry *entry = &zpci_iomap_start[ZPCI_IDX(dst)];
	u64 req, offset = ZPCI_OFFSET(dst);
	int size, rc = 0;

	if (!src)
		return -EINVAL;

	while (n > 0) {
		size = zpci_get_max_write_size((u64 __force) dst,
					       (u64) src, n, 128);
		req = ZPCI_CREATE_REQ(entry->fh, entry->bar, size);

		if (size > 8) /* main path */
			rc = zpci_write_block(req, src, offset);
		else
			rc = zpci_write_single(req, src, offset, size);
		if (rc)
			break;
		offset += size;
		src += size;
		n -= size;
	}
	return rc;
}

static inline int zpci_memset_io(volatile void __iomem *dst,
				 unsigned char val, size_t count)
{
	u8 *src = kmalloc(count, GFP_KERNEL);
	int rc;

	if (src == NULL)
		return -ENOMEM;
	memset(src, val, count);

	rc = zpci_memcpy_toio(dst, src, count);
	kfree(src);
	return rc;
}

#endif /* CONFIG_PCI */

#endif /* _ASM_S390_PCI_IO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 *   S/390 debug facility
 *
 *    Copyright IBM Corp. 1999, 2000
 */
#ifndef DEBUG_H
#define DEBUG_H

#include <linux/string.h>
#include <linux/spinlock.h>
#include <linux/kernel.h>
#include <linux/time.h>
#include <uapi/asm/debug.h>

#define DEBUG_MAX_LEVEL            6  /* debug levels range from 0 to 6 */
#define DEBUG_OFF_LEVEL            -1 /* level where debug is switched off */
#define DEBUG_FLUSH_ALL            -1 /* parameter to flush all areas */
#define DEBUG_MAX_VIEWS            10 /* max number of views in proc fs */
#define DEBUG_MAX_NAME_LEN         64 /* max length for a debugfs file name */
#define DEBUG_DEFAULT_LEVEL        3  /* initial debug level */

#define DEBUG_DIR_ROOT "s390dbf" /* name of debug root directory in proc fs */

#define DEBUG_DATA(entry) (char*)(entry + 1) /* data is stored behind */
                                             /* the entry information */

typedef struct __debug_entry debug_entry_t;

struct debug_view;

typedef struct debug_info {	
	struct debug_info* next;
	struct debug_info* prev;
	atomic_t ref_count;
	spinlock_t lock;			
	int level;
	int nr_areas;
	int pages_per_area;
	int buf_size;
	int entry_size;	
	debug_entry_t*** areas;
	int active_area;
	int *active_pages;
	int *active_entries;
	struct dentry* debugfs_root_entry;
	struct dentry* debugfs_entries[DEBUG_MAX_VIEWS];
	struct debug_view* views[DEBUG_MAX_VIEWS];	
	char name[DEBUG_MAX_NAME_LEN];
	umode_t mode;
} debug_info_t;

typedef int (debug_header_proc_t) (debug_info_t* id,
				   struct debug_view* view,
				   int area,
				   debug_entry_t* entry,
				   char* out_buf);

typedef int (debug_format_proc_t) (debug_info_t* id,
				   struct debug_view* view, char* out_buf,
				   const char* in_buf);
typedef int (debug_prolog_proc_t) (debug_info_t* id,
				   struct debug_view* view,
				   char* out_buf);
typedef int (debug_input_proc_t) (debug_info_t* id,
				  struct debug_view* view,
				  struct file* file,
				  const char __user *user_buf,
				  size_t in_buf_size, loff_t* offset);

int debug_dflt_header_fn(debug_info_t* id, struct debug_view* view,
		         int area, debug_entry_t* entry, char* out_buf);						
				
struct debug_view {
	char name[DEBUG_MAX_NAME_LEN];
	debug_prolog_proc_t* prolog_proc;
	debug_header_proc_t* header_proc;
	debug_format_proc_t* format_proc;
	debug_input_proc_t*  input_proc;
	void*                private_data;
};

extern struct debug_view debug_hex_ascii_view;
extern struct debug_view debug_raw_view;
extern struct debug_view debug_sprintf_view;

/* do NOT use the _common functions */

debug_entry_t* debug_event_common(debug_info_t* id, int level, 
                                  const void* data, int length);

debug_entry_t* debug_exception_common(debug_info_t* id, int level, 
                                      const void* data, int length);

/* Debug Feature API: */

debug_info_t *debug_register(const char *name, int pages, int nr_areas,
                             int buf_size);

debug_info_t *debug_register_mode(const char *name, int pages, int nr_areas,
				  int buf_size, umode_t mode, uid_t uid,
				  gid_t gid);

void debug_unregister(debug_info_t* id);

void debug_set_level(debug_info_t* id, int new_level);

void debug_set_critical(void);
void debug_stop_all(void);

static inline bool debug_level_enabled(debug_info_t* id, int level)
{
	return level <= id->level;
}

static inline debug_entry_t*
debug_event(debug_info_t* id, int level, void* data, int length)
{
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_event_common(id,level,data,length);
}

static inline debug_entry_t*
debug_int_event(debug_info_t* id, int level, unsigned int tag)
{
        unsigned int t=tag;
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_event_common(id,level,&t,sizeof(unsigned int));
}

static inline debug_entry_t *
debug_long_event (debug_info_t* id, int level, unsigned long tag)
{
        unsigned long t=tag;
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		retuELF          (    -  4   <'   4    (                  $  $           t t t x                P  P                    $   $         Qtd                          Rtdt t t                    GNU xzfl!gm\|i]D   s         Fp  HDA`as   u   v   y   }                                             ,"4vT<TVJ1eqXZ\"Xy|=WCEb~,W~                    ()       	     |       {
             (             E
                                                     s             2                          	             X             P                                                                    a                                                      	             *                                                    ?             o             
                                       O             u              y                          &                                                                                 !	             8                            D                                                    B                                       m                                       f                                       3
             y                          T                                                    Z
             /             H                          ,             t             
             O             t                                        	             3                          Z                                       n                                                                  l
             0             	                          	                          P	                                                    A             	             A                                                    6                           a                          [                          /                          R           "   (
             a               /         &          P        y  %       `	    `       ()       	 K  1       8	         m  %       	  x  	       /         &         &         2  L     	    D    x	        f  %       
   8       H1  <       &       t  h2        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _tevent_req_callback_data _talloc_get_type_abort dcerpc_binding_handle_call_recv _talloc_free _tevent_req_nterror _tevent_req_done dcerpc_xattr_parse_DOSATTRIB_r_send _tevent_req_create dcerpc_binding_handle_call_send _tevent_req_nomem tevent_req_set_callback tevent_req_post ndr_table_xattr dcerpc_xattr_parse_DOSATTRIB_r_recv _tevent_req_data tevent_req_is_nterror _talloc_steal_loc tevent_req_received memset dcerpc_xattr_parse_DOSATTRIB_r dcerpc_binding_handle_call dcerpc_xattr_parse_DOSATTRIB_send memcpy dcerpc_xattr_parse_DOSATTRIB_recv dcerpc_xattr_parse_DOSATTRIB _Py_NoneStruct _talloc_zero pytalloc_steal _pytalloc_get_ptr PyInt_AsLong PyLong_AsUnsignedLongLong PyErr_Occurred PyErr_Format PyLong_Type PyExc_TypeError PyInt_Type PyExc_OverflowError PyExc_AttributeError PyInt_FromLong PyLong_FromUnsignedLongLong _pytalloc_get_mem_ctx talloc_strdup PyUnicodeUCS4_AsEncodedString PyErr_NoMemory PyString_FromStringOrNULL PyType_IsSubtype PyList_Type PyList_New PyList_SetItem pytalloc_reference_ex talloc_unlink _talloc_reference_loc ndr_print_struct_string PyString_FromString ndr_print_security_descriptor_hash_v4 ndr_print_security_descriptor_hash_v3 ndr_print_security_descriptor_hash_v2 ndr_print_xattr_DOSATTRIB ndr_print_xattr_NTACL ndr_print_xattr_DosStreams ndr_print_tdb_xattrs ndr_print_xattr_DosEAs ndr_print_xattr_DosAttrib _PyArg_ParseTupleAndKeywords_SizeT PyObject_IsTrue ndr_pull_struct_blob_all ndr_pull_struct_blob ndr_map_error2string _Py_BuildValue_SizeT PyErr_SetObject ndr_pull_security_descriptor_hash_v4 PyExc_RuntimeError ndr_pull_security_descriptor_hash_v3 ndr_pull_security_descriptor_hash_v2 ndr_pull_xattr_DOSATTRIB ndr_pull_xattr_NTACL ndr_pull_xattr_DosStreams ndr_pull_tdb_xattrs ndr_pull_xattr_DosEAs ndr_pull_xattr_DosAttrib talloc_named_const ndr_push_struct_blob PyString_FromStringAndSize ndr_push_security_descriptor_hash_v4 ndr_push_security_descriptor_hash_v3 ndr_push_security_descriptor_hash_v2 ndr_push_xattr_DOSATTRIB ndr_push_xattr_NTACL ndr_push_xattr_DosStreams ndr_push_tdb_xattrs ndr_push_xattr_DosEAs ndr_push_xattr_DosAttrib py_dcerpc_syntax_init_helper py_dcerpc_interface_init_helper _talloc_array talloc_set_name_const __vasprintf_chk __printf_chk puts data_blob_talloc_named py_import_xattr_DosInfo PyErr_SetString py_export_xattr_DosInfo py_import_xattr_NTACL_Info py_export_xattr_NTACL_Info initxattr PyImport_ImportModule PyObject_GetAttrString pytalloc_BaseObject_size PyType_Ready PyInterface_AddNdrRpcMethods PyDict_New PyCFunction_NewEx PyDict_SetItemString PyDescr_NewMethod Py_InitModule4 PyModule_AddObject py_ndr_xattr_methods libdcerpc-binding.so.0 libndr-samba.so.0 libsamba-python.so.0 libndr.so.0 libtevent-util.so.0 libsamba-util.so.0 libpython2.7.so.1.0 libtalloc.so.2 libpytalloc-util.so.2 libtevent.so.0 libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/dcerpc/xattr.so /usr/lib/arm-linux-gnueabihf/samba TEVENT_UTIL_0.0.1 SAMBA_UTIL_0.0.1 TEVENT_0.9.9 GLIBC_2.8 GLIBC_2.4 NDR_0.0.1 TALLOC_2.0.2 PYTALLOC_UTIL_2.1.6 PYTALLOC_UTIL_2.0.6 SAMBA_4.5.16_DEBIAN DCERPC_BINDING_0.0.1                                              	    
 
                  
                        
         
            
                    	     	        
           
                          
                             T           M         )  
         \     0   ii   	     ii           
         A#           (         "   '        7     0   Y  	 4     Y   H        
            \        
            p        
            \      t    x                                                 H    P    p            4    h            ,                `            $    D    x                <                     h    p            ,    4    T                    L                    x                <    D    d            (    \                 l                                                      $    (    ,    4    8    <    @    \    `    h    l    p    x    |                                                                                             $    ,    0    4    8    @    D    H    L    T    X    \    `    h    l    p    t    |                                                                                                           4     8     @     D     H     P     T     X     `     t     x     |                                                                                               !    !    !    !    ,!    0!    4!    8!    @!    D!    H!    L!    T!    X!    \!    `!    h!    l!    p!    t!    !    !    !    !    !    !    !    !    !    !    !    !    !    !    !    !    !    "    "    "    "     "    ("    ,"    0"    8"    L"    P"    T"    X"    `"    d"    h"    l"    "    "    "    "    "    "    "    "    "    "    "    "    "    "    "    "    "    #    #    #    #    #    #     #    $#    ,#    0#    4#    8#    T#    X#    `#    d#    h#    p#    t#    x#    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #     $    $    $    $    $    $     $    $$    ($    ,$    4$    8$    <$    @$    H$    L$    P$    T$    p$    t$    x$    |$    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $     %    %    %    %    %    %    %    8%    <%    @%    D%    L%    P%    T%    X%    `%    d%    h%    l%    t%    x%    |%    %    %    %    %    %    %    %    %    %    %    %    %    %             X   \   ` 	  d 
  h   l   p   t   x   |             !      &   ,   -   0   1   2   <   >   @   D   E   F   K   N   O   P   S   [   ]   `   d   g   k   l   o   p               $   (   ,   0   4   8   <   @   D   H   L   P   T   X    \ }  ` "  d #  h $  l s  p %  t '  x (  | )   *   +   .   /   2   3   4   5   6   7   8   9   :   ;   =   ?      A   B   C   z   G   H   I   J   L   M   w   Q   R   T   U    V   W   X   Y   Z   \   ^   _    a  $ b  ( c  , e  0 f  4 h  8 i  <   @ j  D m  H n  L p  P q  T r  @-  -           | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $                     | t l d \ T L D0 0   R/ l  404 0  0 0C S 00/ 0  S//     88    A,0A0/ 0  S//X T `   L0L 0  0  S/80@-0  S  
(0 0 0         8 80    0  R     0  S
@-3/@0  p  p@- @d d [ P   T `  
@ 4   4  Pp p@l          @-pM0P` 0  @P  
   0 00 p  `   `   P  H  S   @      |    @-M` P` `  p  @P	  <        l    h  A- @g   `   P   Q^  T p  
T 'H    PH H 5$ A<    L  t  l      ,-$M 0   |  0A-M0 00p0 > PP  
@ 0H `0 (@H  <0  X   @b  P  @     P H      P@-M` PW` ` a p  @P	  <   w $         M0@-LMX @ P H    L0@/0 00      /   $ @-0 @     @  $ @-@ @     @  $ @-( @     @  $ @- @     @  $ @- @     @  $ @-H @   |  @  $ @- @   p  @  $ @-H @   d  @  $ @- @   X  @  $ @- @   L  @t  $ @- @   @  @X  $ @-  @   4  @@  $ @- @   (  @(  $ @- @     @x  $ @- @     @l  $ @-H @     @`  @-PMqx  Up;  
0 `T0D    
  P   ? " M @P  P  B0   0     d p0d    0    @ PH@  4040                      @-PMq#  Up;  
0 `T0D    
  P   ? "  @P  P  B0   0   w  d p0d    0    @ PH@e  4040  ]  ,       ,          @-PMq  Up;  
0 `T0D    
 q P   ? !  @P=  P  A0   0   "  d p0d    0    @ PH@  4040               X      @-PMqy  Up;  
0 `T0D    
  P   ? ! N @P  P  A0   0     d p0d    0    @ PH@  4040                     G-`M`Q$  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `u   0    0    @ P|@c  Td0T   0  L U  8080  M  0                 <  G-`M`Q  VPL  
0 T0D	  7  
 ` P!     `p.  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080           x            G-`M`QV  VPL  
0 T0D	  7  
  P!     - `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080             l    l      @-PMq  Up;  
0 `T0D    
  P   ? #  @P^  P  C0   0   C  d p0d    0    @ PH@1  4040  )  \       \          @-PMq  Up;  
0 `T0D    
 = P   ? " o @P	  P  B0   0     d p0d    0    @ PH@  4040                   4  @-PMqE  Up;  
0 `T0D    
  P   ? "  @P  P  B0   0     d p0d    0    @ PH@  4040               4    h  @-PMq  Up;  
0 `T0D    
  P   ? !  @P_  P  A0   0   D  d p0d    0    @ PH@2  4040  *  `       `        L  @-PMq  Up;  
0 `T0D    
 > P   ? ! p @P
  P  A0   0     d p0d    0    @ PH@  4040                   ,  G-`M`QF  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L w  8080  o           ,    ,      G-`M`Q  VPL  
0 T0D	  7  
  P!     `pP  P   	 W  V`0   0   `0   0    0    @ P|@  Td0T   0  L   8080                        G-`M`Qx  VPL  
0 T0D	  7  
  P!     O `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080           d            @-PMq  Up;  
0 `T0D    
  P   ? "  @P  P  B0   0   e  d p0d    0    @ PH@S  4040  K             d      @-PMq  Up;  
0 `T0D    
 _ P   ? !  @P+  P  A0   0     d p0d    0    @ PH@  4040                   D  @-PMqg  Up;  
0 `T0D    
 
 P   ? ! < @P  P  A0   0     d p0d    0    @ PH@  4040    <       <        (  @-PMq  Up;  
0 `T0D    
  P   ?    @P  P  @0   0   f  d p0d    0    @ PH@T  4040  L             h      G-`M`Q  VPL  
0 T0D	  7  
 ` P!     `p.  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080           x            G-`M`QV  VPL  
0 T0D	  7  
  P!     - `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080           ~  l}    l}    p~  G-`M`Q  VPL  
0 T0D	  7  
  P!      `p`  P   	 W  V `0   0   `@   0    0    @ P|@.  Td0T   0  L    8080    \       @}  {    {    |  @-PMq  Up;  
0 `T0D    
 + P   ? % ] @P  P  E0   0     d p0d    0    @ PH@  4040           z    @z    H|  G-`MdQ3  VPM  
0 T0D
  8  
 P  1 1  * 	 `p  P   	 W V`0   0   `   0    @0    P@q  Xh0X   0  P c  <0<0  [  l         Lz  x    x    z  G-`MdQ  VPM  
0 T0D
  8  
 mP  1 1  *  `p:  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0             x  8w    8w    8y  G-`MdQa  VPM  
0 T0D
  8  
 P  1 1  * 7 `p  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0    $         w  u    u    w  G-`M`Q  VPL  
0 T0D	  7  
  P!     `pi  P   	 W  V`0   0   `I   0    0    @ P|@7  Td0T   0  L )  8080  !         du  s    s    \v  G-`M`Q  VPL  
0 T0D	  7  
 4 P!    h `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080           s  Xr    Xr    t  G-`M`Q*  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `{   0    0    @ P|@i  Td0T   0  L [  8080  S  H       ,r  p    p    s  G-`MdQ  VPM  
0 T0D
  8  
 fP  1 1  *  `p3  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0             p  o    o    Pq  G-`M`QZ  VPL  
0 T0D	  7  
  P!     1 `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080           n  |m    |m    tp  @-PMq  Up;  
0 `T0D    
  P   ? !  @Pb  P  A0   0   G  d p0d    0    @ PH@5  4040  -  l       ll    k    Xl  @-PMq  Up;  
0 `T0D    
 A P   ?   s @P  P  @0   0     d p0d    0    @ PH@  4040           k    j    8k  G-`M`QI  VPL  
0 T0D	  7  
  P!       `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L z  8080  r         j  8i    8i    j  G-`M`Q  VPL  
0 T0D	  7  
  P!      `pS  P   	 W  V `0   0   `3   0    0    @ P|@!  Td0T   0  L   8080    (       i  g    g    j  G-`MdQ{  VPM  
0 T0D
  8  
 P  1 1  * Q `p  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0             lg  e    e    ,i  G-`MdQ  VPM  
0 T0D
  8  
 P  1 1  *  `p  P   	 W V`0   0   `b   0    @0    P@P  Xh0X   0  P B  <0<0  :           e  Xd    Xd    f  @- 0! Q P  @A@@-@ :@-@ 5@-@ 0@-@ +@-@ &@-@ !A-@ `  T p   2  
 T0     
  @  T"  
  8@   J PP  
  00C  S 0 @0 03/T0T 0      ,0,0     f  f    Df    e  A-@ `5  T p   2  
 T0     
  @  T"  
  H@    PP  
  00C  S 0 @0 03/T0T 0    W  ,0,0  v  l he  le    e    e  A-@ `  T p   2  
 T0     
 G` @  T"  
   @    PP  
 5N 00C  S 0 @0 03/T0T 0  6    ,0,0  +  @ <d  @d    c    $d  A-@ `  T p   2  
 T0     
  @  T"  
  @   i PP  
  00C  S 0 @0 03/T0T 0      ,0,0     c  c    b    Tb  A-@ `T  T p   2  
 T0     
  @  T"  
   @    PP  
  00C  S 0 @0 03/T0T 0    v  ,0,0     a  a    a    (a  @-@8 @-@H @-@  @-@ @-@  C-`Mxr  Vp  
h2 P @ P  
  Pz  
@ \k  0 0  SXP @  8  ?  
 P     0@ S  0P1  S(  
  T 
 G  P5    Y X4   0@ S  1!   0   @ P`@!  H1H0    (1!  0   	    0   0@   P @   @0       p0  0   0dd00  00L0    \ x        [    `    t[  \  $`  L_  u  ^  C-`Mxr=  Vp  
h2 P @ P  
  Pz  
@ \k  0 0  SP @  8  ?  
 P     0@ S  0P1  S(  
  T 
   P5    Y X4   0@ S  1!   0   @ P`@o  H1H0  f  (1!  0   W    0   0@   P @B   @0     6  p0  0   0dd00(  00L0      x        X    ^    X  HY  \]  ]  r  4]  C-`Mxr  Vp  
h2 P @ P  
5  Pz  
@ \k  0 0  SP @  8  ?  
  P     0@ S  0P1  S(  
  T 
I   P5    Y X4   0@ S  1!   0   @ P`@  H1H0    (1!  0       0   0@   P @   @0       p0  0   0dd00v  00L0  n   x        V    \    U  V  Z  L[  p  lZ  C-`Mxr  Vp  
h2 P @ P  
  Pz  
 \k  0 0  SP @  8  ?  
n P     0@ S  0P1  S(  
  T 
 1  P5    Y X4   0@ S  1!   0   @ P`@  H1H0    (1!  0       0   0@   P @   0       p0  0   0dd00  00L0     x        DS    @Y    S  S  W  X  Hm  W  p@-* P@ 9 `P
  
WP @ @   "@ T pp@- P@ % `P
  
P @ @   @ T pp@- P@  `P
  
P @ @   @ T pp@- P  `P
  
P @ @    T pA- `   pP  
 0  S  
D P@  @P    0 S  A-M@ pa` P  [  T5  
00 T 0 0  
 0 0   P  
V  P  
  `     h  P  
  0   p0   0    0TT00 0 04040   0   , V    @V  0j    U  A-M@ pda` P    T5  
00 T 0 0  
 0 0   P  
  P  
  `       P  
 < 0   p0   0    0TT00 0 04040   00    V    hU  h    T  A-M@ pa` P t   T5  
00 T 0 0  
 0 0   P  
  P  
 ] ` Z      P  
  0   p0   0    0TT00T 0* 04040  I 0    @U    T  g    @S  p@- P @ #<<8 0  PI  @  p h  xT  T  p@- P @ <<8 0  P.  @  p   PT  XT  p@- P @ <<8 0  P  @  p   (T  0T  p@- Pk @ <<8 0  P  @  p< P   T  S  p@- PP @ <<8 0  P  @  p   S  S  p@- P5 @ <<8 0  P  @ o pd d  S  S  p@- P @ <<8 0 d P  @ T p X  dS  \S  p@- P @ f<<8 0 I P  @ 9 p   ,S  (S  p@- P @ K<<8 0 . Pq  @  p    R  R  @-PM!0 0 0 ``  P  
@  T.  
p p P  
e @P  
@     y @P  
 H   >  t0 0  0` 0\00  8080   Tp  R    S    TR  HR    Q  A-0M@p `p(100 , P $0       h@@  P  
 0  P 0  
  P   0 0   P  U  00      0 `0 0   PH0 0 @  0   J    X R         LQ  A-0M@p `(100 , P $0       @@  P  
 0  P 0  
Z  P   _0 0   P  U  00      0 L`0 0   PH0 0 @  0     ^   P         O  A-0M@p `(100 , P $0       @@  P  
 0  P 0  
  P   0 0  B P  U  00      0 `0 0  & PH0 0 @d  0        <O  H t      N  A-0M@p `e(100 , P $0       ]@@  P  
 0  P 0  
  P   0 0   P  U  00      0 `0 0   PH0 0 @  0   ?    , M  ~        M  A-0M@p `(100 , P $0       @@  P  
 0  P 0  
O  P   T0 0   P  U  00      0 A`0 0  t PH0 0 @  0     S   tL  } T      K  A-0M@p `(100 , P $0       @@  P  
 0  P 0  
  P   0 0  7 P  U  00      0 `0 0   PH0 0 @Y  0       d~ K  |       XJ  A-0M@p `Z(100 , P $0       R@@  P  
 0  P 0  
  P   0 0   P  U  00      0 `0 0   PH0 0 @   0   4     } I  z       H  A-0M@p `(100 , P $0       @@  P  
 0  P 0  
D  P   I0 0   P  U  00      0 6`0 0  i PH0 0 @  0     H  { HH  Ty \      G  A-0M@p `(100 , P $0       @@  P  
 0  P 0  
  P   0 0  , P  U  00      0 `0 0   PH0 0 @N  0       8z F  w       ,F  @-M @Q `    e@@ PP$  
0 0 
 pP	    `   |0  `0 @  h   F  H0 `0 @  0   7  E  v `  E  E    <E   E  @-M @ ` m   @@ PP$  
0 0  pP	   j ` 8  10  `0 @  h     hH0 `0 @  0     Y0E  u   HE  D    D  C  @-M @ ` "   @@ PP$  
0 0 t pP	    `   0  `0 @|  h     H0 `0 @m  0     D  pt   D  TD    B  B  @-M @p `    @@ PP$  
0 0 ) pP	    `   0  `0 @1  h   e  H0 `0 @"  0   V  C  Ds   C  C    A  |A  @-'@ @-M @  `    4@@ PP$  
0 0  pP	    ` R  K0  `0 @  h     H0 `0 @  0     s$C  r   <C  B    x@  <@  @-M @ ` <   @@ PP$  
0 0  pP	   9 `    0  `0 @  h     7H0 `0 @  0     (|B  p   B  HB    L?  ?  @-M @ `    @@ PP$  
0 0 C pP	    `   0  `0 @K  h     H0 `0 @<  0   p  A  o   A  A     >  =  @-M @? `    S@@ PP$  
0 0  pP	    ` q  j0  `0 @   h   4  H0 `0 @  0   %  ,A  n   DA  @    <  <  @-@ l@-M @ ` V   @@ PP$  
0 0  pP	   S ` !  0  `0 @  h     QH0 `0 @  0     Bp@  @m   @  <@    ;  x;  0000<l |  000l |  A-   PP p    ` @P  
h0h0 0T H00      ,  ?  k ?    ?  ?    \?  O-MP @bT
 p   U  
420 U   O  
 2    ` P  
  Pf  
 1 0   P Z  
0  S6  0    R5  
 @	b`  0 &@     0 S  0   R  
  R   
  P  
0 v	 `    P\    00  w  0 0!  00 e    t0  0   0dd00T  40L0  L  (k   x  x?  ?  tl $@    >    >  >  t=  G   =  O-`M P  Vx  
 2  @ P  
`  P`  
 1 0   P T  
T0  S1  0    R0  
 @	
p   P P@  0 S  0   R  
 		 R   
.  P  
0 P
 p  A0  P    00    0 0  00     p0  0   0``00  00H0    xh x  >  >  i H?    =    =  =  <  $E  l<  O-M` @<    V  
20 V   J  
2   P  P  
  P`  
 m1 0\  P T  
0  S1  0    R0  
 @	
p   P P@  0 S  0   R  
 		 R   
  P  
0 P9
 p  0  P    00  9  0 0  00 (    t0  0   0dd00  40L0    f   x  =  $<  dg >    <    <  <  ;  B  9   -@-M  P0 @   @ p  
0Hp Sp`  
 0@ S X @/8<  A-X00   R  
 ` b pP  
0  S  
h P@  @P   C0 S   0p       c d   p@-M@ `(p0  T0  
 P X0 @     0  p   0   0<b @;    :  p@-M@ `p0  T0  
 P dX0 @     0  p   0  d 0a ;    :  @-<00    R  
,00@     00 0a x   @-<00    R  
,00@     00 0` x   @-<00    R  
,00@     00 0d` 4x   A-00   R  
 P   pP  
 0  S  
d` @`bo "@    0 S   0p      ` a   @-o    P  @@@-e    P  @@@-[    P  @@@-Q   P  @@@-G   P  @@@-=   P  @@@-3    P  @@z@-)    P  @@p@-   P  @@f@-    P  @@\@-   P  @@R@-   P  @@H@-    P  @@>@-   P  @@4@-   P  @z@*@- 0! Q P  @n@@- 0! Q P  @b@@- 0! Q P  @V@@- 0! Q P  @J@@- 0! Q P  @>@@- 0! Q P  @2@@- 0! Q P  @&@@- 0! Q P  @@@-y 0! Q P  @@@-m 0! Q P  @@@-a 0!  Q P  @@@-U 0! Q P  @@@-I 0!  Q P  @@@-= 0! Q P  @@@-1 0! Q P  @@v0 Q0   
   Q  
 Q  0 0ap0 0I [ Q  T0 01TD @-0<    (0 0F8Z   \ \ [   t3  [ p@- P @ Y p@p@- P @ O p@C-@$M` @ Zt Vp Pk  
9   V  
4 VW    T  
pd ` P  
y P  
 *H$    `P 
  0  0  Tk  
d `I P  
] P  
 #   r `P  
  J   V     T[  
c `1 P  
B P  
 |#   W `P  
         0300  l   P   T8  
b ` P  
 PY  
 "   ( `P  
 Q          20  p PP2X0  H Py 200    Pm10   Pa1 X"0   010 	POd1 #0   010u 	P=1 $0   0PP10cD 	P+s0 #0   010Q 	Pa# PZ PS PL PE2  X   Z `3  dZ T6  Y 3    5  5  8Y 4    3  4  1  1  x2  2  /  0  0  0  T0  2  /  P2  2  |/  (3  \0  4/  0  0  1  2  \/  p@-P `0  U0  
 @  W P  
  @        p$ $ @0   @S    2  p@-P `\0  U0  
 @  . P  
  @        p$ $ @0   @S   \1  0A0 Q,      	      R  
   n m    R  
   be    R  
|00  ]    R  
`   U TL 0      /4 @-0,    xR LT (T i S     X+  p@- P @ W p@C-P$@M  pbD|D@ ` Q  g  D  "    U  
P40 U  
D 0n 0  P  
z P  
 +$    @Pc   ` m    Uq  
30 U 0j  
 0 b P  
Y P  
 
#   n @PB  | `L    U\  
D30 UI  
P 0U 0  P  
7 Pp  
 #   L @P     `*    UR  
20 U'  
 0 0   P  
 P  
 "   + @P  
 T   t2t0  Gd  `  0 0<2<0  , `20   `t10   `h10   `\p1 h%0   010x 	`J(1 &0   0HH10p< 	`80 ,&0   010^  	`&0   0    000K 	` `y0  Q   R 3  3  TR 82  <2  Q 0  0  ,g .    L-  P2    /  /  .  .  0  0  -  -  4.  '  t.  40  '  t0  .  h'  /  4,  '  t,  ,  p@-@ `X0  T0  
 P  E  P 0  0  p 0    pK   `*  A-  Mnh` @P  
  g PP  
  b pP  
  ] P  
 6xXP  P   
h -  P    
P &  P   
8   P   
 H0@2G03\C0T4 ?05;0(870D1300 /08 +09|'02@	#0t:05
06l0d7008;0;
 0,=?  P|  1;  Px  F@5  Pr  I 0  Pm  z +  Ph   '  Pd   #  P`     P[    PW  b  PS     PN  U   PI  ,VPb  PC  n   P>     P9     P4  1M   P/     P*  5 n  P$  
<;  S  <5eU0`P7Mn^@<`P   ;    p  W     
0 <e5%` 0 0 ] PP
D   @        @           |   { d   tT  L   l	4   e   ^     V@    O    H    A    :    3 t   , \   % D     ,   L2 0L2 3 03 3 03 40I.4  70z.7  0 00  0h0  0 l8L0.l8  09 (009 1 01 90.9  \50U.\5   6 0 6 60n.6  :x0.:  |;X0.|;  @< 0@< =,0  =A}4/  pK ,/   /   /  /  b /  .  .  L tK J   J J  J \_ +    +  +  @I +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  |+  h+  P+  8+  $+  +  *  t  *  *       T   *  *  )  @-default/librpc/gen_ndr/ndr_xattr_c.c:49 struct tevent_req   default/librpc/gen_ndr/ndr_xattr_c.c:53 default/librpc/gen_ndr/ndr_xattr_c.c:54 default/librpc/gen_ndr/ndr_xattr_c.c:58 struct dcerpc_xattr_parse_DOSATTRIB_r_state default/librpc/gen_ndr/ndr_xattr_c.c:27 default/librpc/gen_ndr/ndr_xattr_c.c:37 default/librpc/gen_ndr/ndr_xattr_c.c:65 default/librpc/gen_ndr/ndr_xattr_c.c:73 default/librpc/gen_ndr/ndr_xattr_c.c:133    default/librpc/gen_ndr/ndr_xattr_c.c:135    struct dcerpc_xattr_parse_DOSATTRIB_state   default/librpc/gen_ndr/ndr_xattr_c.c:146    default/librpc/gen_ndr/ndr_xattr_c.c:147    default/librpc/gen_ndr/ndr_xattr_c.c:156    default/librpc/gen_ndr/ndr_xattr_c.c:108    default/librpc/gen_ndr/ndr_xattr_c.c:123    default/librpc/gen_ndr/ndr_xattr_c.c:163    default/librpc/gen_ndr/ndr_xattr_c.c:172    struct xattr_DosInfo3   struct xattr_DosInfo2Old    struct xattr_DosInfo1   struct xattr_DosInfoFFFFCompat  struct security_descriptor_hash_v4  struct security_descriptor_hash_v3  struct security_descriptor_hash_v2  struct xattr_DOSATTRIB  struct xattr_sys_acl_hash_wrapper   struct xattr_NTACL  struct xattr_DosStreams struct xattr_DosStream  struct tdb_xattrs   struct xattr_DosEAs struct xattr_EA struct xattr_DosAttrib  Cannot delete NDR object: struct object->change_time    Expected type %s or %s within range 0 - %llu, got %ld   Expected type %s or %s  Cannot delete NDR object: struct object->create_time    Cannot delete NDR object: struct object->alloc_size Cannot delete NDR object: struct object->size   Cannot delete NDR object: struct object->ea_size    Expected type %s or %s within range 0 - %llu, got %llu  Cannot delete NDR object: struct object->attrib Cannot delete NDR object: struct object->valid_flags    Cannot delete NDR object: struct object->write_time Cannot delete NDR object: struct object->flags  Cannot delete NDR object: struct object->time   Cannot delete NDR object: struct object->hash_type  Cannot delete NDR object: struct object->version    Cannot delete NDR object: struct object->mode   Cannot delete NDR object: struct object->group  Cannot delete NDR object: struct object->owner  Cannot delete NDR object: struct object->num_streams    Cannot delete NDR object: struct object->num_eas    Cannot delete NDR object: struct object->name   ignore  utf-8   Expected string or unicode object, got %s   Cannot delete NDR object: struct object->description    Cannot delete NDR object: struct object->attrib_hex Cannot delete NDR object: struct object->sys_acl_hash   default/librpc/gen_ndr/py_xattr.c:3650: Expected type '%s' for '%s' of type '%s'    Cannot delete NDR object: struct object->sys_acl_hash[sys_acl_hash_cntr_0]  Expected list of type %s, length %zu, got %zd   Cannot delete NDR object: struct object->hash   default/librpc/gen_ndr/py_xattr.c:3486: Expected type '%s' for '%s' of type '%s'    Cannot delete NDR object: struct object->hash[hash_cntr_0]  default/librpc/gen_ndr/py_xattr.c:3212: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2944: Expected type '%s' for '%s' of type '%s'    Cannot delete NDR object: struct object->sd default/librpc/gen_ndr/py_xattr.c:3403: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:3404  default/librpc/gen_ndr/py_xattr.c:3129: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:3130  default/librpc/gen_ndr/py_xattr.c:2908: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2909  security_descriptor_hash_v4 default/librpc/gen_ndr/py_xattr.c:3807  security_descriptor_hash_v3 default/librpc/gen_ndr/py_xattr.c:3351  security_descriptor_hash_v2 default/librpc/gen_ndr/py_xattr.c:3077  xattr_DOSATTRIB default/librpc/gen_ndr/py_xattr.c:1885  xattr_NTACL default/librpc/gen_ndr/py_xattr.c:4140  xattr_DosStreams    default/librpc/gen_ndr/py_xattr.c:2856  tdb_xattrs  default/librpc/gen_ndr/py_xattr.c:2406  xattr_DosEAs    default/librpc/gen_ndr/py_xattr.c:2201  xattr_DosAttrib default/librpc/gen_ndr/py_xattr.c:1648  O:xattr_parse_DOSATTRIB Cannot delete NDR object: struct r->in.x    py_x    default/librpc/gen_ndr/py_xattr.c:4382: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:4383  s#|O:__ndr_unpack__ (is)    talloc_new: default/librpc/gen_ndr/py_xattr.c:3747  default/librpc/gen_ndr/py_xattr.c:3754  default/librpc/gen_ndr/py_xattr.c:3760  talloc_new: default/librpc/gen_ndr/py_xattr.c:3291  default/librpc/gen_ndr/py_xattr.c:3298  default/librpc/gen_ndr/py_xattr.c:3304  talloc_new: default/librpc/gen_ndr/py_xattr.c:3017  default/librpc/gen_ndr/py_xattr.c:3024  default/librpc/gen_ndr/py_xattr.c:3030  talloc_new: default/librpc/gen_ndr/py_xattr.c:1825  default/librpc/gen_ndr/py_xattr.c:1832  default/librpc/gen_ndr/py_xattr.c:1838  talloc_new: default/librpc/gen_ndr/py_xattr.c:4080  default/librpc/gen_ndr/py_xattr.c:4087  default/librpc/gen_ndr/py_xattr.c:4093  talloc_new: default/librpc/gen_ndr/py_xattr.c:2796  default/librpc/gen_ndr/py_xattr.c:2803  default/librpc/gen_ndr/py_xattr.c:2809  talloc_new: default/librpc/gen_ndr/py_xattr.c:2346  default/librpc/gen_ndr/py_xattr.c:2353  default/librpc/gen_ndr/py_xattr.c:2359  talloc_new: default/librpc/gen_ndr/py_xattr.c:2141  default/librpc/gen_ndr/py_xattr.c:2148  default/librpc/gen_ndr/py_xattr.c:2154  talloc_new: default/librpc/gen_ndr/py_xattr.c:1588  default/librpc/gen_ndr/py_xattr.c:1595  default/librpc/gen_ndr/py_xattr.c:1601  talloc_new: ../source4/librpc/ndr/py_xattr.c:70 struct ndr_print    ../source4/librpc/ndr/py_xattr.c:75 file    ../source4/librpc/ndr/py_xattr.c:81 Cannot delete NDR object: struct object->streams    default/librpc/gen_ndr/py_xattr.c:2746: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2749  ARRAY: object->streams  Cannot delete NDR object: struct object->streams[streams_cntr_1]    PyList_GET_ITEM(value, streams_cntr_1)  default/librpc/gen_ndr/py_xattr.c:2757: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2758  Cannot delete NDR object: struct object->eas    default/librpc/gen_ndr/py_xattr.c:2297: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2300  ARRAY: object->eas  Cannot delete NDR object: struct object->eas[eas_cntr_0]    PyList_GET_ITEM(value, eas_cntr_0)  default/librpc/gen_ndr/py_xattr.c:2308: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2309  default/librpc/gen_ndr/py_xattr.c:2091: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2094  Cannot delete NDR object: struct object->eas[eas_cntr_1]    PyList_GET_ITEM(value, eas_cntr_1)  default/librpc/gen_ndr/py_xattr.c:2102: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:2103          Cannot delete NDR object: struct object->acl_as_blob    DATA_BLOB: default/librpc/gen_ndr/py_xattr.c:4178   Cannot delete NDR object: struct object->value  DATA_BLOB: default/librpc/gen_ndr/py_xattr.c:1968   unknown union level union xattr_DosInfo Cannot delete NDR object: struct ret->compatinfoFFFF    default/librpc/gen_ndr/py_xattr.c:1426  in  default/librpc/gen_ndr/py_xattr.c:1428: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:1428  default/librpc/gen_ndr/py_xattr.c:1429  default/librpc/gen_ndr/py_xattr.c:1431  Cannot delete NDR object: struct ret->info1 default/librpc/gen_ndr/py_xattr.c:1439  default/librpc/gen_ndr/py_xattr.c:1441: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:1441  default/librpc/gen_ndr/py_xattr.c:1442  default/librpc/gen_ndr/py_xattr.c:1444  Cannot delete NDR object: struct ret->oldinfo2  default/librpc/gen_ndr/py_xattr.c:1452  default/librpc/gen_ndr/py_xattr.c:1454: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:1454  default/librpc/gen_ndr/py_xattr.c:1455  default/librpc/gen_ndr/py_xattr.c:1457  Cannot delete NDR object: struct ret->info3 default/librpc/gen_ndr/py_xattr.c:1465  default/librpc/gen_ndr/py_xattr.c:1467: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:1467  default/librpc/gen_ndr/py_xattr.c:1468  default/librpc/gen_ndr/py_xattr.c:1470  invalid union level value   default/librpc/gen_ndr/py_xattr.c:1477  Cannot delete NDR object: struct object->info   union xattr_NTACL_Info  Cannot delete NDR object: struct ret->sd    default/librpc/gen_ndr/py_xattr.c:3882  default/librpc/gen_ndr/py_xattr.c:3892: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:3892  default/librpc/gen_ndr/py_xattr.c:3893  default/librpc/gen_ndr/py_xattr.c:3895  Cannot delete NDR object: struct ret->sd_hs2    default/librpc/gen_ndr/py_xattr.c:3904  default/librpc/gen_ndr/py_xattr.c:3914: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:3914  default/librpc/gen_ndr/py_xattr.c:3915  default/librpc/gen_ndr/py_xattr.c:3917  Cannot delete NDR object: struct ret->sd_hs3    default/librpc/gen_ndr/py_xattr.c:3926  default/librpc/gen_ndr/py_xattr.c:3936: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:3936  default/librpc/gen_ndr/py_xattr.c:3937  default/librpc/gen_ndr/py_xattr.c:3939  Cannot delete NDR object: struct ret->sd_hs4    default/librpc/gen_ndr/py_xattr.c:3948  default/librpc/gen_ndr/py_xattr.c:3958: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_xattr.c:3958  default/librpc/gen_ndr/py_xattr.c:3959  default/librpc/gen_ndr/py_xattr.c:3961  default/librpc/gen_ndr/py_xattr.c:3969  samba.dcerpc.security   talloc  samba.dcerpc.base   samba.dcerpc.misc   BaseObject  descriptor  ClientConnection    ndr_syntax_id   xattr DCE/RPC   xattr   user.DosAttrib  XATTR_DOSATTRIB_NAME    user.DOSATTRIB  XATTR_DOSATTRIB_NAME_S3 XATTR_DOSATTRIB_ESTIMATED_SIZE  user.DosEAs XATTR_DOSEAS_NAME   user.DosStreams XATTR_DOSSTREAMS_NAME   XATTR_STREAM_FLAG_INTERNAL  user.DosStream. XATTR_DOSSTREAM_PREFIX  XATTR_MAX_STREAM_SIZE   XATTR_MAX_STREAM_SIZE_TDB   security.NTACL  XATTR_NTACL_NAME    XATTR_SD_HASH_SIZE  XATTR_SD_HASH_TYPE_NONE XATTR_SD_HASH_TYPE_SHA256   XATTR_DOSINFO_ATTRIB    XATTR_DOSINFO_EA_SIZE   XATTR_DOSINFO_SIZE  XATTR_DOSINFO_ALLOC_SIZE    XATTR_DOSINFO_CREATE_TIME   XATTR_DOSINFO_CHANGE_TIME   DosInfoFFFFCompat   DosInfo1    DosInfo2Old DosInfo3    DosAttrib   DOSATTRIB   EA  DosEAs  DosStream   DosStreams  NTACL   sys_acl_hash_wrapper    abstract_syntax data_blob   allow_remaining xattr.xattr abstract_syntax()
  S.parse_DOSATTRIB(x) -> None    acl_as_blob PIDL-generated element acl_as_blob  owner   PIDL-generated element owner    group   PIDL-generated element group    mode    PIDL-generated element mode __ndr_pack__    S.ndr_pack(object) -> blob
NDR pack __ndr_unpack__  S.ndr_unpack(class, blob, allow_remaining=False) -> None
NDR unpack __ndr_print__   S.ndr_print(object) -> None
NDR print   version PIDL-generated element version  info    PIDL-generated element info sd  PIDL-generated element sd   hash_type   PIDL-generated element hash_type    PIDL-generated element hash description PIDL-generated element description  PIDL-generated element time sys_acl_hash    PIDL-generated element sys_acl_hash num_streams PIDL-generated element num_streams  PIDL-generated element streams  flags   PIDL-generated element flags    PIDL-generated element size alloc_size  PIDL-generated element alloc_size   name    PIDL-generated element name num_eas PIDL-generated element num_eas  PIDL-generated element eas  PIDL-generated element value    attrib_hex  PIDL-generated element attrib_hex   valid_flags PIDL-generated element valid_flags  attrib  PIDL-generated element attrib   ea_size PIDL-generated element ea_size  create_time PIDL-generated element create_time  change_time PIDL-generated element change_time  write_time  PIDL-generated element write_time   dump    xattr(binding, lp_ctx=None, credentials=None) -> connection

binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)
lp_ctx should be a path to a smb.conf file or a param.LoadParm object
credentials should be a credentials.Credentials object.

   xattr.sys_acl_hash_wrapper  xattr.NTACL xattr.security_descriptor_hash_v4   xattr.security_descriptor_hash_v3   xattr.security_descriptor_hash_v2   xattr.DosStreams    xattr.DosStream xattr.tdb_xattrs    xattr.DosEAs    xattr.EA    xattr.DOSATTRIB xattr.DosAttrib xattr.DosInfo3  xattr.DosInfo2Old   xattr.DosInfo1  xattr.DosInfoFFFFCompat                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <.  -      0  l      ,  <3                                         
     
     
     
     
               (     7     M     \               ()     P     t          x       o     P
       
                             &     H     X               o   o  o
   o  o                                                   4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)  4)                                                                                                                                                                            0  <                                                                                                                            "                             6                                                                                                                                                    "     #                             4                                                 t                                                                                                           ,!                             x5                                                                                                                                                            %                             3                                                                                                                                                            8%                             3                                                                                                                                                            p$                             3                                                                                                                                                            #                             h3                                                 <                                                                                                   4      t                              4                                                                                                                                                                                      X4                                                                                                                                                                                      (4                                                                                                                                                    T#     #                             86                                                                                                                                                    "     L"                             5                                                                                                                                                    !     !                             5                                                 `                                                                                                                                       H5                                                                                                                                                    \                                  5                                                                                                                                                                                         4                                                 L                                                                                                                                                                                         L                                                                       X                                                                                                                                                   _          8  ^          `  h\                            0       @  d       t                             n  <a                                         0       @  d       t    `                       <    d  @      \  m  |W  h          Tw          <t  xo        h     (V            t                            0  4     @  d       t                           <      @      \  m   Y  h        L  z                            0  `     @  d  L     t    8                       <  8    @          |                            0       @  d  x     t    |                       (    b  4      ,      X                          x    $g            e             |d          dt  q                            0  $     @  d       t                               h            l  8                          0  P     @  d  @     t    T                         $n  \j              8                            xt  r          |  D  T                          0       @  d       t                           t  Pt  p          m  Z            8                             0       @  d       t                             8n   l                                           x  >            T=            ;            d:            9        $    7  0      T  P  h6  `                          x     hJ          (  H          P  0G            E            D        $    4C  0      T  @  A  `        p  @          (t  Ln                                R            TQ          0   P          `  N        $    XM  0      T  m  L  `                              T                            A,   aeabi "   6 	
"7a666cba2167a2dbefcd6d5c7ca081ab695d44.debug    TQ] .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                           $                     o                       (                           0         P
  P
                   8   o                      E   o       `     
          T   	      H  H  X               ]   	   B   &  &                f         ()  ()                    a         4)  4)                  l         -  -  <                 r         P  P                    x      2   X  X  0                                                          t t                           x x                           | |                              8                             P                                                                                 % % $                       p        % -                                & 4                                M&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       rn NULL;
        return debug_event_common(id,level,&t,sizeof(unsigned long));
}

static inline debug_entry_t*
debug_text_event(debug_info_t* id, int level, const char* txt)
{
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_event_common(id,level,txt,strlen(txt));
}

/*
 * IMPORTANT: Use "%s" in sprintf format strings with care! Only pointers are
 * stored in the s390dbf. See Documentation/s390/s390dbf.txt for more details!
 */
extern debug_entry_t *
__debug_sprintf_event(debug_info_t *id, int level, char *string, ...)
	__attribute__ ((format(printf, 3, 4)));

#define debug_sprintf_event(_id, _level, _fmt, ...)			\
({									\
	debug_entry_t *__ret;						\
	debug_info_t *__id = _id;					\
	int __level = _level;						\
	if ((!__id) || (__level > __id->level))				\
		__ret = NULL;						\
	else								\
		__ret = __debug_sprintf_event(__id, __level,		\
					      _fmt, ## __VA_ARGS__);	\
	__ret;								\
})

static inline debug_entry_t*
debug_exception(debug_info_t* id, int level, void* data, int length)
{
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_exception_common(id,level,data,length);
}

static inline debug_entry_t*
debug_int_exception(debug_info_t* id, int level, unsigned int tag)
{
        unsigned int t=tag;
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_exception_common(id,level,&t,sizeof(unsigned int));
}

static inline debug_entry_t *
debug_long_exception (debug_info_t* id, int level, unsigned long tag)
{
        unsigned long t=tag;
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_exception_common(id,level,&t,sizeof(unsigned long));
}

static inline debug_entry_t*
debug_text_exception(debug_info_t* id, int level, const char* txt)
{
	if ((!id) || (level > id->level) || (id->pages_per_area == 0))
		return NULL;
        return debug_exception_common(id,level,txt,strlen(txt));
}

/*
 * IMPORTANT: Use "%s" in sprintf format strings with care! Only pointers are
 * stored in the s390dbf. See Documentation/s390/s390dbf.txt for more details!
 */
extern debug_entry_t *
__debug_sprintf_exception(debug_info_t *id, int level, char *string, ...)
	__attribute__ ((format(printf, 3, 4)));

#define debug_sprintf_exception(_id, _level, _fmt, ...)			\
({									\
	debug_entry_t *__ret;						\
	debug_info_t *__id = _id;					\
	int __level = _level;						\
	if ((!__id) || (__level > __id->level))				\
		__ret = NULL;						\
	else								\
		__ret = __debug_sprintf_exception(__id, __level,	\
						  _fmt, ## __VA_ARGS__);\
	__ret;								\
})

int debug_register_view(debug_info_t* id, struct debug_view* view);
int debug_unregister_view(debug_info_t* id, struct debug_view* view);

/*
   define the debug levels:
   - 0 No debugging output to console or syslog
   - 1 Log internal errors to syslog, ignore check conditions 
   - 2 Log internal errors and check conditions to syslog
   - 3 Log internal errors to console, log check conditions to syslog
   - 4 Log internal errors and check conditions to console
   - 5 panic on internal errors, log check conditions to console
   - 6 panic on both, internal errors and check conditions
 */

#ifndef DEBUG_LEVEL
#define DEBUG_LEVEL 4
#endif

#define INTERNAL_ERRMSG(x,y...) "E" __FILE__ "%d: " x, __LINE__, y
#define INTERNAL_WRNMSG(x,y...) "W" __FILE__ "%d: " x, __LINE__, y
#define INTERNAL_INFMSG(x,y...) "I" __FILE__ "%d: " x, __LINE__, y
#define INTERNAL_DEBMSG(x,y...) "D" __FILE__ "%d: " x, __LINE__, y

#if DEBUG_LEVEL > 0
#define PRINT_DEBUG(x...) printk ( KERN_DEBUG PRINTK_HEADER x )
#define PRINT_INFO(x...) printk ( KERN_INFO PRINTK_HEADER x )
#define PRINT_WARN(x...) printk ( KERN_WARNING PRINTK_HEADER x )
#define PRINT_ERR(x...) printk ( KERN_ERR PRINTK_HEADER x )
#define PRINT_FATAL(x...) panic ( PRINTK_HEADER x )
#else
#define PRINT_DEBUG(x...) printk ( KERN_DEBUG PRINTK_HEADER x )
#define PRINT_INFO(x...) printk ( KERN_DEBUG PRINTK_HEADER x )
#define PRINT_WARN(x...) printk ( KERN_DEBUG PRINTK_HEADER x )
#define PRINT_ERR(x...) printk ( KERN_DEBUG PRINTK_HEADER x )
#define PRINT_FATAL(x...) printk ( KERN_DEBUG PRINTK_HEADER x )
#endif				/* DASD_DEBUG */

#endif				/* DEBUG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef __ASM_S390_PCI_H
#define __ASM_S390_PCI_H

/* must be set before including asm-generic/pci.h */
#define PCI_DMA_BUS_IS_PHYS (0)
/* must be set before including pci_clp.h */
#define PCI_BAR_COUNT	6

#include <linux/pci.h>
#include <linux/mutex.h>
#include <asm-generic/pci.h>
#include <asm/pci_clp.h>
#include <asm/pci_debug.h>
#include <asm/sclp.h>

#define PCIBIOS_MIN_IO		0x1000
#define PCIBIOS_MIN_MEM		0x10000000

#define pcibios_assign_all_busses()	(0)

void __iomem *pci_iomap(struct pci_dev *, int, unsigned long);
void pci_iounmap(struct pci_dev *, void __iomem *);
int pci_domain_nr(struct pci_bus *);
int pci_proc_domain(struct pci_bus *);

#define ZPCI_BUS_NR			0	/* default bus number */
#define ZPCI_DEVFN			0	/* default device number */

/* PCI Function Controls */
#define ZPCI_FC_FN_ENABLED		0x80
#define ZPCI_FC_ERROR			0x40
#define ZPCI_FC_BLOCKED			0x20
#define ZPCI_FC_DMA_ENABLED		0x10

#define ZPCI_FMB_DMA_COUNTER_VALID	(1 << 23)

struct zpci_fmb_fmt0 {
	u64 dma_rbytes;
	u64 dma_wbytes;
};

struct zpci_fmb_fmt1 {
	u64 rx_bytes;
	u64 rx_packets;
	u64 tx_bytes;
	u64 tx_packets;
};

struct zpci_fmb_fmt2 {
	u64 consumed_work_units;
	u64 max_work_units;
};

struct zpci_fmb {
	u32 format	: 8;
	u32 fmt_ind	: 24;
	u32 samples;
	u64 last_update;
	/* common counters */
	u64 ld_ops;
	u64 st_ops;
	u64 stb_ops;
	u64 rpcit_ops;
	/* format specific counters */
	union {
		struct zpci_fmb_fmt0 fmt0;
		struct zpci_fmb_fmt1 fmt1;
		struct zpci_fmb_fmt2 fmt2;
	};
} __packed __aligned(128);

enum zpci_state {
	ZPCI_FN_STATE_RESERVED,
	ZPCI_FN_STATE_STANDBY,
	ZPCI_FN_STATE_CONFIGURED,
	ZPCI_FN_STATE_ONLINE,
	NR_ZPCI_FN_STATES,
};

struct zpci_bar_struct {
	struct resource *res;		/* bus resource */
	u32		val;		/* bar start & 3 flag bits */
	u16		map_idx;	/* index into bar mapping array */
	u8		size;		/* order 2 exponent */
};

struct s390_domain;

/* Private data per function */
struct zpci_dev {
	struct pci_bus	*bus;
	struct list_head entry;		/* list of all zpci_devices, needed for hotplug, etc. */

	enum zpci_state state;
	u32		fid;		/* function ID, used by sclp */
	u32		fh;		/* function handle, used by insn's */
	u16		vfn;		/* virtual function number */
	u16		pchid;		/* physical channel ID */
	u8		pfgid;		/* function group ID */
	u8		pft;		/* pci function type */
	u16		domain;

	struct mutex lock;
	u8 pfip[CLP_PFIP_NR_SEGMENTS];	/* pci function internal path */
	u32 uid;			/* user defined id */
	u8 util_str[CLP_UTIL_STR_LEN];	/* utility string */

	/* IRQ stuff */
	u64		msi_addr;	/* MSI address */
	unsigned int	max_msi;	/* maximum number of MSI's */
	struct airq_iv *aibv;		/* adapter interrupt bit vector */
	unsigned int	aisb;		/* number of the summary bit */

	/* DMA stuff */
	unsigned long	*dma_table;
	spinlock_t	dma_table_lock;
	int		tlb_refresh;

	spinlock_t	iommu_bitmap_lock;
	unsigned long	*iommu_bitmap;
	unsigned long	*lazy_bitmap;
	unsigned long	iommu_size;
	unsigned long	iommu_pages;
	unsigned int	next_bit;

	char res_name[16];
	struct zpci_bar_struct bars[PCI_BAR_COUNT];

	u64		start_dma;	/* Start of available DMA addresses */
	u64		end_dma;	/* End of available DMA addresses */
	u64		dma_mask;	/* DMA address space mask */

	/* Function measurement block */
	struct zpci_fmb *fmb;
	u16		fmb_update;	/* update interval */
	/* software counters */
	atomic64_t allocated_pages;
	atomic64_t mapped_pages;
	atomic64_t unmapped_pages;

	enum pci_bus_speed max_bus_speed;

	struct dentry	*debugfs_dev;
	struct dentry	*debugfs_perf;

	struct s390_domain *s390_domain; /* s390 IOMMU domain data */
};

static inline bool zdev_enabled(struct zpci_dev *zdev)
{
	return (zdev->fh & (1UL << 31)) ? true : false;
}

extern const struct attribute_group *zpci_attr_groups[];

/* -----------------------------------------------------------------------------
  Prototypes
----------------------------------------------------------------------------- */
/* Base stuff */
int zpci_create_device(struct zpci_dev *);
int zpci_enable_device(struct zpci_dev *);
int zpci_disable_device(struct zpci_dev *);
void zpci_stop_device(struct zpci_dev *);
int zpci_register_ioat(struct zpci_dev *, u8, u64, u64, u64);
int zpci_unregister_ioat(struct zpci_dev *, u8);

/* CLP */
int clp_scan_pci_devices(void);
int clp_rescan_pci_devices(void);
int clp_rescan_pci_devices_simple(void);
int clp_add_pci_device(u32, u32, int);
int clp_enable_fh(struct zpci_dev *, u8);
int clp_disable_fh(struct zpci_dev *);

#ifdef CONFIG_PCI
/* Error handling and recovery */
void zpci_event_error(void *);
void zpci_event_availability(void *);
void zpci_rescan(void);
bool zpci_is_enabled(void);
#else /* CONFIG_PCI */
static inline void zpci_event_error(void *e) {}
static inline void zpci_event_availability(void *e) {}
static inline void zpci_rescan(void) {}
#endif /* CONFIG_PCI */

#ifdef CONFIG_HOTPLUG_PCI_S390
int zpci_init_slot(struct zpci_dev *);
void zpci_exit_slot(struct zpci_dev *);
#else /* CONFIG_HOTPLUG_PCI_S390 */
static inline int zpci_init_slot(struct zpci_dev *zdev)
{
	return 0;
}
static inline void zpci_exit_slot(struct zpci_dev *zdev) {}
#endif /* CONFIG_HOTPLUG_PCI_S390 */

/* Helpers */
static inline struct zpci_dev *to_zpci(struct pci_dev *pdev)
{
	return pdev->sysdata;
}

struct zpci_dev *get_zdev_by_fid(u32);

/* DMA */
int zpci_dma_init(void);
void zpci_dma_exit(void);

/* FMB */
int zpci_fmb_enable_device(struct zpci_dev *);
int zpci_fmb_disable_device(struct zpci_dev *);

/* Debug */
int zpci_debug_init(void);
void zpci_debug_exit(void);
void zpci_debug_init_device(struct zpci_dev *, const char *);
void zpci_debug_exit_device(struct zpci_dev *);
void zpci_debug_info(struct zpci_dev *, struct seq_file *);

/* Error reporting */
int zpci_report_error(struct pci_dev *, struct zpci_report_error_header *);

#ifdef CONFIG_NUMA

/* Returns the node based on PCI bus */
static inline int __pcibus_to_node(const struct pci_bus *bus)
{
	return NUMA_NO_NODE;
}

static inline const struct cpumask *
cpumask_of_pcibus(const struct pci_bus *bus)
{
	return cpu_online_mask;
}

#endif /* CONFIG_NUMA */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Copyright IBM Corp. 1999, 2009
 * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>,
 *	      Denis Joseph Barrow,
 *	      Arnd Bergmann <arndb@de.ibm.com>,
 *
 * Atomic operations that C can't guarantee us.
 * Useful for resource counting etc.
 * s390 uses 'Compare And Swap' for atomicity in SMP environment.
 *
 */

#ifndef __ARCH_S390_ATOMIC__
#define __ARCH_S390_ATOMIC__

#include <linux/compiler.h>
#include <linux/types.h>
#include <asm/barrier.h>
#include <asm/cmpxchg.h>

#define ATOMIC_INIT(i)  { (i) }

#define __ATOMIC_NO_BARRIER	"\n"

#ifdef CONFIG_HAVE_MARCH_Z196_FEATURES

#define __ATOMIC_OR	"lao"
#define __ATOMIC_AND	"lan"
#define __ATOMIC_ADD	"laa"
#define __ATOMIC_XOR	"lax"
#define __ATOMIC_BARRIER "bcr	14,0\n"

#define __ATOMIC_LOOP(ptr, op_val, op_string, __barrier)		\
({									\
	int old_val;							\
									\
	typecheck(atomic_t *, ptr);					\
	asm volatile(							\
		op_string "	%0,%2,%1\n"				\
		__barrier						\
		: "=d" (old_val), "+Q" ((ptr)->counter)			\
		: "d" (op_val)						\
		: "cc", "memory");					\
	old_val;							\
})

#else /* CONFIG_HAVE_MARCH_Z196_FEATURES */

#define __ATOMIC_OR	"or"
#define __ATOMIC_AND	"nr"
#define __ATOMIC_ADD	"ar"
#define __ATOMIC_XOR	"xr"
#define __ATOMIC_BARRIER "\n"

#define __ATOMIC_LOOP(ptr, op_val, op_string, __barrier)		\
({									\
	int old_val, new_val;						\
									\
	typecheck(atomic_t *, ptr);					\
	asm volatile(							\
		"	l	%0,%2\n"				\
		"0:	lr	%1,%0\n"				\
		op_string "	%1,%3\n"				\
		"	cs	%0,%1,%2\n"				\
		"	jl	0b"					\
		: "=&d" (old_val), "=&d" (new_val), "+Q" ((ptr)->counter)\
		: "d" (op_val)						\
		: "cc", "memory");					\
	old_val;							\
})

#endif /* CONFIG_HAVE_MARCH_Z196_FEATURES */

static inline int atomic_read(const atomic_t *v)
{
	int c;

	asm volatile(
		"	l	%0,%1\n"
		: "=d" (c) : "Q" (v->counter));
	return c;
}

static inline void atomic_set(atomic_t *v, int i)
{
	asm volatile(
		"	st	%1,%0\n"
		: "=Q" (v->counter) : "d" (i));
}

static inline int atomic_add_return(int i, atomic_t *v)
{
	return __ATOMIC_LOOP(v, i, __ATOMIC_ADD, __ATOMIC_BARRIER) + i;
}

static inline int atomic_fetch_add(int i, atomic_t *v)
{
	return __ATOMIC_LOOP(v, i, __ATOMIC_ADD, __ATOMIC_BARRIER);
}

static inline void atomic_add(int i, atomic_t *v)
{
#ifdef CONFIG_HAVE_MARCH_Z196_FEATURES
	if (__builtin_constant_p(i) && (i > -129) && (i < 128)) {
		asm volatile(
			"asi	%0,%1\n"
			: "+Q" (v->counter)
			: "i" (i)
			: "cc", "memory");
		return;
	}
#endif
	__ATOMIC_LOOP(v, i, __ATOMIC_ADD, __ATOMIC_NO_BARRIER);
}

#define atomic_add_negative(_i, _v)	(atomic_add_return(_i, _v) < 0)
#define atomic_inc(_v)			atomic_add(1, _v)
#define atomic_inc_return(_v)		atomic_add_return(1, _v)
#define atomic_inc_and_test(_v)		(atomic_add_return(1, _v) == 0)
#define atomic_sub(_i, _v)		atomic_add(-(int)(_i), _v)
#define atomic_sub_return(_i, _v)	atomic_add_return(-(int)(_i), _v)
#define atomic_fetch_sub(_i, _v)	atomic_fetch_add(-(int)(_i), _v)
#define atomic_sub_and_test(_i, _v)	(atomic_sub_return(_i, _v) == 0)
#define atomic_dec(_v)			atomic_sub(1, _v)
#define atomic_dec_return(_v)		atomic_sub_return(1, _v)
#define atomic_dec_and_test(_v)		(atomic_sub_return(1, _v) == 0)

#define ATOMIC_OPS(op, OP)						\
static inline void atomic_##op(int i, atomic_t *v)			\
{									\
	__ATOMIC_LOOP(v, i, __ATOMIC_##OP, __ATOMIC_NO_BARRIER);	\
}									\
static inline int atomic_fetch_##op(int i, atomic_t *v)			\
{									\
	return __ATOMIC_LOOP(v, i, __ATOMIC_##OP, __ATOMIC_BARRIER);	\
}

ATOMIC_OPS(and, AND)
ATOMIC_OPS(or, OR)
ATOMIC_OPS(xor, XOR)

#undef ATOMIC_OPS

#define atomic_xchg(v, new) (xchg(&((v)->counter), new))

static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
{
	asm volatile(
		"	cs	%0,%2,%1"
		: "+d" (old), "+Q" (v->counter)
		: "d" (new)
		: "cc", "memory");
	return old;
}

static inline int __atomic_add_unless(atomic_t *v, int a, int u)
{
	int c, old;
	c = atomic_read(v);
	for (;;) {
		if (unlikely(c == u))
			break;
		old = atomic_cmpxchg(v, c, c + a);
		if (likely(old == c))
			break;
		c = old;
	}
	return c;
}


#undef __ATOMIC_LOOP

#define ATOMIC64_INIT(i)  { (i) }

#define __ATOMIC64_NO_BARRIER	"\n"

#ifdef CONFIG_HAVE_MARCH_Z196_FEATURES

#define __ATOMIC64_OR	"laog"
#define __ATOMIC64_AND	"lang"
#define __ATOMIC64_ADD	"laag"
#define __ATOMIC64_XOR	"laxg"
#define __ATOMIC64_BARRIER "bcr	14,0\n"

#define __ATOMIC64_LOOP(ptr, op_val, op_string, __barrier)		\
({									\
	long long old_val;						\
									\
	typecheck(atomic64_t *, ptr);					\
	asm volatile(							\
		op_string "	%0,%2,%1\n"				\
		__barrier						\
		: "=d" (old_val), "+Q" ((ptr)->counter)			\
		: "d" (op_val)						\
		: "cc", "memory");					\
	old_val;							\
})

#else /* CONFIG_HAVE_MARCH_Z196_FEATURES */

#define __ATOMIC64_OR	"ogr"
#define __ATOMIC64_AND	"ngr"
#define __ATOMIC64_ADD	"agr"
#define __ATOMIC64_XOR	"xgr"
#define __ATOMIC64_BARRIER "\n"

#define __ATOMIC64_LOOP(ptr, op_val, op_string, __barrier)		\
({									\
	long long old_val, new_val;					\
									\
	typecheck(atomic64_t *, ptr);					\
	asm volatile(							\
		"	lg	%0,%2\n"				\
		"0:	lgr	%1,%0\n"				\
		op_string "	%1,%3\n"				\
		"	csg	%0,%1,%2\n"				\
		"	jl	0b"					\
		: "=&d" (old_val), "=&d" (new_val), "+Q" ((ptr)->counter)\
		: "d" (op_val)						\
		: "cc", "memory");					\
	old_val;							\
})

#endif /* CONFIG_HAVE_MARCH_Z196_FEATURES */

static inline long long atomic64_read(const atomic64_t *v)
{
	long long c;

	asm volatile(
		"	lg	%0,%1\n"
		: "=d" (c) : "Q" (v->counter));
	return c;
}

static inline void atomic64_set(atomic64_t *v, long long i)
{
	asm volatile(
		"	stg	%1,%0\n"
		: "=Q" (v->counter) : "d" (i));
}

static inline long long atomic64_add_return(long long i, atomic64_t *v)
{
	return __ATOMIC64_LOOP(v, i, __ATOMIC64_ADD, __ATOMIC64_BARRIER) + i;
}

static inline long long atomic64_fetch_add(long long i, atomic64_t *v)
{
	return __ATOMIC64_LOOP(v, i, __ATOMIC64_ADD, __ATOMIC64_BARRIER);
}

static inline void atomic64_add(long long i, atomic64_t *v)
{
#ifdef CONFIG_HAVE_MARCH_Z196_FEATURES
	if (__builtin_constant_p(i) && (i > -129) && (i < 128)) {
		asm volatile(
			"agsi	%0,%1\n"
			: "+Q" (v->counter)
			: "i" (i)
			: "cc", "memory");
		return;
	}
#endif
	__ATOMIC64_LOOP(v, i, __ATOMIC64_ADD, __ATOMIC64_NO_BARRIER);
}

#define atomic64_xchg(v, new) (xchg(&((v)->counter), new))

static inline long long atomic64_cmpxchg(atomic64_t *v,
					     long long old, long long new)
{
	asm volatile(
		"	csg	%0,%2,%1"
		: "+d" (old), "+Q" (v->counter)
		: "d" (new)
		: "cc", "memory");
	return old;
}

#define ATOMIC64_OPS(op, OP)						\
static inline void atomic64_##op(long i, atomic64_t *v)			\
{									\
	__ATOMIC64_LOOP(v, i, __ATOMIC64_##OP, __ATOMIC64_NO_BARRIER);	\
}									\
static inline long atomic64_fetch_##op(long i, atomic64_t *v)		\
{									\
	return __ATOMIC64_LOOP(v, i, __ATOMIC64_##OP, __ATOMIC64_BARRIER); \
}

ATOMIC64_OPS(and, AND)
ATOMIC64_OPS(or, OR)
ATOMIC64_OPS(xor, XOR)

#undef ATOMIC64_OPS
#undef __ATOMIC64_LOOP

static inline int atomic64_add_unless(atomic64_t *v, long long i, long long u)
{
	long long c, old;

	c = atomic64_read(v);
	for (;;) {
		if (unlikely(c == u))
			break;
		old = atomic64_cmpxchg(v, c, c + i);
		if (likely(old == c))
			break;
		c = old;
	}
	return c != u;
}

static inline long long atomic64_dec_if_positive(atomic64_t *v)
{
	long long c, old, dec;

	c = atomic64_read(v);
	for (;;) {
		dec = c - 1;
		if (unlikely(dec < 0))
			break;
		old = atomic64_cmpxchg((v), c, dec);
		if (likely(old == c))
			break;
		c = old;
	}
	return dec;
}

#define atomic64_add_negative(_i, _v)	(atomic64_add_return(_i, _v) < 0)
#define atomic64_inc(_v)		atomic64_add(1, _v)
#define atomic64_inc_return(_v)		atomic64_add_return(1, _v)
#define atomic64_inc_and_test(_v)	(atomic64_add_return(1, _v) == 0)
#define atomic64_sub_return(_i, _v)	atomic64_add_return(-(long long)(_i), _v)
#define atomic64_fetch_sub(_i, _v)	atomic64_fetch_add(-(long long)(_i), _v)
#define atomic64_sub(_i, _v)		atomic64_add(-(long long)(_i), _v)
#define atomic64_sub_and_test(_i, _v)	(atomic64_sub_return(_i, _v) == 0)
#define atomic64_dec(_v)		atomic64_sub(1, _v)
#define atomic64_dec_return(_v)		atomic64_sub_return(1, _v)
#define atomic64_dec_and_test(_v)	(atomic64_sub_return(1, _v) == 0)
#define atomic64_inc_not_zero(v)	atomic64_add_unless((v), 1, 0)

#endif /* __ARCH_S390_ATOMIC__  */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _ASM_FB_H_
#define _ASM_FB_H_
#include <linux/fb.h>

#define fb_pgprotect(...) do {} while (0)

static inline int fb_is_primary_device(struct fb_info *info)
{
	return 0;
}

#endif /* _ASM_FB_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright IBM Corp. 1999, 2009
 *
 * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
 */

#ifndef __ASM_SWITCH_TO_H
#define __ASM_SWITCH_TO_H

#include <linux/thread_info.h>
#include <asm/fpu/api.h>
#include <asm/ptrace.h>

extern struct task_struct *__switch_to(void *, void *);
extern void update_cr_regs(struct task_struct *task);

static inline void save_access_regs(unsigned int *acrs)
{
	typedef struct { int _[NUM_ACRS]; } acrstype;

	asm volatile("stam 0,15,%0" : "=Q" (*(acrstype *)acrs));
}

static inline void restore_access_regs(unsigned int *acrs)
{
	typedef struct { int _[NUM_ACRS]; } acrstype;

	asm volatile("lam 0,15,%0" : : "Q" (*(acrstype *)acrs));
}

#define switch_to(prev,next,last) do {					\
	/* save_fpu_regs() sets the CIF_FPU flag, which enforces	\
	 * a restore of the floating point / vector registers as	\
	 * soon as the next task returns to user space			\
	 */								\
	save_fpu_regs();						\
	save_access_regs(&prev->thread.acrs[0]);			\
	save_ri_cb(prev->thread.ri_cb);					\
	update_cr_regs(next);						\
	restore_access_regs(&next->thread.acrs[0]);			\
	restore_ri_cb(next->thread.ri_cb, prev->thread.ri_cb);		\
	prev = __switch_to(prev,next);					\
} while (0)

#endif /* __ASM_SWITCH_TO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef _ASM_S390_FTRACE_H
#define _ASM_S390_FTRACE_H

#define ARCH_SUPPORTS_FTRACE_OPS 1

#ifdef CC_USING_HOTPATCH
#define MCOUNT_INSN_SIZE	6
#else
#define MCOUNT_INSN_SIZE	24
#define MCOUNT_RETURN_FIXUP	18
#endif

#ifndef __ASSEMBLY__

#define ftrace_return_address(n) __builtin_return_address(n)

void _mcount(void);
void ftrace_caller(void);

extern char ftrace_graph_caller_end;
extern unsigned long ftrace_plt;

struct dyn_arch_ftrace { };

#define MCOUNT_ADDR ((unsigned long)_mcount)
#define FTRACE_ADDR ((unsigned long)ftrace_caller)

#define KPROBE_ON_FTRACE_NOP	0
#define KPROBE_ON_FTRACE_CALL	1

static inline unsigned long ftrace_call_adjust(unsigned long addr)
{
	return addr;
}

struct ftrace_insn {
	u16 opc;
	s32 disp;
} __packed;

static inline void ftrace_generate_nop_insn(struct ftrace_insn *insn)
{
#ifdef CONFIG_FUNCTION_TRACER
#ifdef CC_USING_HOTPATCH
	/* brcl 0,0 */
	insn->opc = 0xc004;
	insn->disp = 0;
#else
	/* jg .+24 */
	insn->opc = 0xc0f4;
	insn->disp = MCOUNT_INSN_SIZE / 2;
#endif
#endif
}

static inline int is_ftrace_nop(struct ftrace_insn *insn)
{
#ifdef CONFIG_FUNCTION_TRACER
#ifdef CC_USING_HOTPATCH
	if (insn->disp == 0)
		return 1;
#else
	if (insn->disp == MCOUNT_INSN_SIZE / 2)
		return 1;
#endif
#endif
	return 0;
}

static inline void ftrace_generate_call_insn(struct ftrace_insn *insn,
					     unsigned long ip)
{
#ifdef CONFIG_FUNCTION_TRACER
	unsigned long target;

	/* brasl r0,ftrace_caller */
	target = is_module_addr((void *) ip) ? ftrace_plt : FTRACE_ADDR;
	insn->opc = 0xc005;
	insn->disp = (target - ip) / 2;
#endif
}

#endif /* __ASSEMBLY__ */
#endif /* _ASM_S390_FTRACE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _ASM_S390_TOPOLOGY_H
#define _ASM_S390_TOPOLOGY_H

#include <linux/cpumask.h>
#include <asm/numa.h>

struct sysinfo_15_1_x;
struct cpu;

#ifdef CONFIG_SCHED_TOPOLOGY

struct cpu_topology_s390 {
	unsigned short thread_id;
	unsigned short core_id;
	unsigned short socket_id;
	unsigned short book_id;
	unsigned short drawer_id;
	unsigned short node_id;
	cpumask_t thread_mask;
	cpumask_t core_mask;
	cpumask_t book_mask;
	cpumask_t drawer_mask;
};

DECLARE_PER_CPU(struct cpu_topology_s390, cpu_topology);

#define topology_physical_package_id(cpu) (per_cpu(cpu_topology, cpu).socket_id)
#define topology_thread_id(cpu)		  (per_cpu(cpu_topology, cpu).thread_id)
#define topology_sibling_cpumask(cpu) \
		(&per_cpu(cpu_topology, cpu).thread_mask)
#define topology_core_id(cpu)		  (per_cpu(cpu_topology, cpu).core_id)
#define topology_core_cpumask(cpu)	  (&per_cpu(cpu_topology, cpu).core_mask)
#define topology_book_id(cpu)		  (per_cpu(cpu_topology, cpu).book_id)
#define topology_book_cpumask(cpu)	  (&per_cpu(cpu_topology, cpu).book_mask)
#define topology_drawer_id(cpu)		  (per_cpu(cpu_topology, cpu).drawer_id)
#define topology_drawer_cpumask(cpu)	  (&per_cpu(cpu_topology, cpu).drawer_mask)

#define mc_capable() 1

int topology_cpu_init(struct cpu *);
int topology_set_cpu_management(int fc);
void topology_schedule_update(void);
void store_topology(struct sysinfo_15_1_x *info);
void topology_expect_change(void);
const struct cpumask *cpu_coregroup_mask(int cpu);

#else /* CONFIG_SCHED_TOPOLOGY */

static inline void topology_schedule_update(void) { }
static inline int topology_cpu_init(struct cpu *cpu) { return 0; }
static inline void topology_expect_change(void) { }

#endif /* CONFIG_SCHED_TOPOLOGY */

#define POLARIZATION_UNKNOWN	(-1)
#define POLARIZATION_HRZ	(0)
#define POLARIZATION_VL		(1)
#define POLARIZATION_VM		(2)
#define POLARIZATION_VH		(3)

#define SD_BOOK_INIT	SD_CPU_INIT

#ifdef CONFIG_NUMA

#define cpu_to_node cpu_to_node
static inline int cpu_to_node(int cpu)
{
	return per_cpu(cpu_topology, cpu).node_id;
}

/* Returns a pointer to the cpumask of CPUs on node 'node'. */
#define cpumask_of_node cpumask_of_node
static inline const struct cpumask *cpumask_of_node(int node)
{
	return &node_to_cpumask_map[node];
}

/*
 * Returns the number of the node containing node 'node'. This
 * architecture is flat, so it is a pretty simple function!
 */
#define parent_node(node) (node)

#define pcibus_to_node(bus) __pcibus_to_node(bus)

#define node_distance(a, b) __node_distance(a, b)

#else /* !CONFIG_NUMA */

#define numa_node_id numa_node_id
static inline int numa_node_id(void)
{
	return 0;
}

#endif /* CONFIG_NUMA */

#include <asm-generic/topology.h>

#endif /* _ASM_S390_TOPOLOGY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 *  S390 version
 *    Copyright IBM Corp. 1999
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
 */

#ifndef _S390_STRING_H_
#define _S390_STRING_H_

#ifndef _LINUX_TYPES_H
#include <linux/types.h>
#endif

#define __HAVE_ARCH_MEMCHR	/* inline & arch function */
#define __HAVE_ARCH_MEMCMP	/* arch function */
#define __HAVE_ARCH_MEMCPY	/* gcc builtin & arch function */
#define __HAVE_ARCH_MEMSCAN	/* inline & arch function */
#define __HAVE_ARCH_MEMSET	/* gcc builtin & arch function */
#define __HAVE_ARCH_STRCAT	/* inline & arch function */
#define __HAVE_ARCH_STRCMP	/* arch function */
#define __HAVE_ARCH_STRCPY	/* inline & arch function */
#define __HAVE_ARCH_STRLCAT	/* arch function */
#define __HAVE_ARCH_STRLCPY	/* arch function */
#define __HAVE_ARCH_STRLEN	/* inline & arch function */
#define __HAVE_ARCH_STRNCAT	/* arch function */
#define __HAVE_ARCH_STRNCPY	/* arch function */
#define __HAVE_ARCH_STRNLEN	/* inline & arch function */
#define __HAVE_ARCH_STRRCHR	/* arch function */
#define __HAVE_ARCH_STRSTR	/* arch function */

/* Prototypes for non-inlined arch strings functions. */
extern int memcmp(const void *, const void *, size_t);
extern void *memcpy(void *, const void *, size_t);
extern void *memset(void *, int, size_t);
extern int strcmp(const char *,const char *);
extern size_t strlcat(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);
extern char *strncat(char *, const char *, size_t);
extern char *strncpy(char *, const char *, size_t);
extern char *strrchr(const char *, int);
extern char *strstr(const char *, const char *);

#undef __HAVE_ARCH_MEMMOVE
#undef __HAVE_ARCH_STRCHR
#undef __HAVE_ARCH_STRNCHR
#undef __HAVE_ARCH_STRNCMP
#undef __HAVE_ARCH_STRPBRK
#undef __HAVE_ARCH_STRSEP
#undef __HAVE_ARCH_STRSPN

#if !defined(IN_ARCH_STRING_C)

static inline void *memchr(const void * s, int c, size_t n)
{
	register int r0 asm("0") = (char) c;
	const void *ret = s + n;

	asm volatile(
		"0:	srst	%0,%1\n"
		"	jo	0b\n"
		"	jl	1f\n"
		"	la	%0,0\n"
		"1:"
		: "+a" (ret), "+&a" (s) : "d" (r0) : "cc");
	return (void *) ret;
}

static inline void *memscan(void *s, int c, size_t n)
{
	register int r0 asm("0") = (char) c;
	const void *ret = s + n;

	asm volatile(
		"0:	srst	%0,%1\n"
		"	jo	0b\n"
		: "+a" (ret), "+&a" (s) : "d" (r0) : "cc");
	return (void *) ret;
}

static inline char *strcat(char *dst, const char *src)
{
	register int r0 asm("0") = 0;
	unsigned long dummy;
	char *ret = dst;

	asm volatile(
		"0:	srst	%0,%1\n"
		"	jo	0b\n"
		"1:	mvst	%0,%2\n"
		"	jo	1b"
		: "=&a" (dummy), "+a" (dst), "+a" (src)
		: "d" (r0), "0" (0) : "cc", "memory" );
	return ret;
}

static inline char *strcpy(char *dst, const char *src)
{
	register int r0 asm("0") = 0;
	char *ret = dst;

	asm volatile(
		"0:	mvst	%0,%1\n"
		"	jo	0b"
		: "+&a" (dst), "+&a" (src) : "d" (r0)
		: "cc", "memory");
	return ret;
}

static inline size_t strlen(const char *s)
{
	register unsigned long r0 asm("0") = 0;
	const char *tmp = s;

	asm volatile(
		"0:	srst	%0,%1\n"
		"	jo	0b"
		: "+d" (r0), "+a" (tmp) :  : "cc");
	return r0 - (unsigned long) s;
}

static inline size_t strnlen(const char * s, size_t n)
{
	register int r0 asm("0") = 0;
	const char *tmp = s;
	const char *end = s + n;

	asm volatile(
		"0:	srst	%0,%1\n"
		"	jo	0b"
		: "+a" (end), "+a" (tmp) : "d" (r0)  : "cc");
	return end - s;
}
#else /* IN_ARCH_STRING_C */
void *memchr(const void * s, int c, size_t n);
void *memscan(void *s, int c, size_t n);
char *strcat(char *dst, const char *src);
char *strcpy(char *dst, const char *src);
size_t strlen(const char *s);
size_t strnlen(const char * s, size_t n);
#endif /* !IN_ARCH_STRING_C */

#endif /* __S390_STRING_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *  S390 version
 *    Copyright IBM Corp. 1999, 2000
 *    Author(s): Hartmut Penner (hp@de.ibm.com)
 */

#ifndef _S390_PAGE_H
#define _S390_PAGE_H

#include <linux/const.h>
#include <asm/types.h>

/* PAGE_SHIFT determines the page size */
#define PAGE_SHIFT      12
#define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
#define PAGE_MASK       (~(PAGE_SIZE-1))
#define PAGE_DEFAULT_ACC	0
#define PAGE_DEFAULT_KEY	(PAGE_DEFAULT_ACC << 4)

#define HPAGE_SHIFT	20
#define HPAGE_SIZE	(1UL << HPAGE_SHIFT)
#define HPAGE_MASK	(~(HPAGE_SIZE - 1))
#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
#define HUGE_MAX_HSTATE		2

#define ARCH_HAS_SETCLEAR_HUGE_PTE
#define ARCH_HAS_HUGE_PTE_TYPE
#define ARCH_HAS_PREPARE_HUGEPAGE
#define ARCH_HAS_HUGEPAGE_CLEAR_FLUSH

#include <asm/setup.h>
#ifndef __ASSEMBLY__

void __storage_key_init_range(unsigned long start, unsigned long end);

static inline void storage_key_init_range(unsigned long start, unsigned long end)
{
	if (PAGE_DEFAULT_KEY)
		__storage_key_init_range(start, end);
}

#define clear_page(page)	memset((page), 0, PAGE_SIZE)

/*
 * copy_page uses the mvcl instruction with 0xb0 padding byte in order to
 * bypass caches when copying a page. Especially when copying huge pages
 * this keeps L1 and L2 data caches alive.
 */
static inline void copy_page(void *to, void *from)
{
	register void *reg2 asm ("2") = to;
	register unsigned long reg3 asm ("3") = 0x1000;
	register void *reg4 asm ("4") = from;
	register unsigned long reg5 asm ("5") = 0xb0001000;
	asm volatile(
		"	mvcl	2,4"
		: "+d" (reg2), "+d" (reg3), "+d" (reg4), "+d" (reg5)
		: : "memory", "cc");
}

#define clear_user_page(page, vaddr, pg)	clear_page(page)
#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)

#define __alloc_zeroed_user_highpage(movableflags, vma, vaddr) \
	alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr)
#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE

/*
 * These are used to make use of C type-checking..
 */

typedef struct { unsigned long pgprot; } pgprot_t;
typedef struct { unsigned long pgste; } pgste_t;
typedef struct { unsigned long pte; } pte_t;
typedef struct { unsigned long pmd; } pmd_t;
typedef struct { unsigned long pud; } pud_t;
typedef struct { unsigned long pgd; } pgd_t;
typedef pte_t *pgtable_t;

#define pgprot_val(x)	((x).pgprot)
#define pgste_val(x)	((x).pgste)
#define pte_val(x)	((x).pte)
#define pmd_val(x)	((x).pmd)
#define pud_val(x)	((x).pud)
#define pgd_val(x)      ((x).pgd)

#define __pgste(x)	((pgste_t) { (x) } )
#define __pte(x)        ((pte_t) { (x) } )
#define __pmd(x)        ((pmd_t) { (x) } )
#define __pud(x)	((pud_t) { (x) } )
#define __pgd(x)        ((pgd_t) { (x) } )
#define __pgprot(x)     ((pgprot_t) { (x) } )

static inline void page_set_storage_key(unsigned long addr,
					unsigned char skey, int mapped)
{
	if (!mapped)
		asm volatile(".insn rrf,0xb22b0000,%0,%1,8,0"
			     : : "d" (skey), "a" (addr));
	else
		asm volatile("sske %0,%1" : : "d" (skey), "a" (addr));
}

static inline unsigned char page_get_storage_key(unsigned long addr)
{
	unsigned char skey;

	asm volatile("iske %0,%1" : "=d" (skey) : "a" (addr));
	return skey;
}

static inline int page_reset_referenced(unsigned long addr)
{
	int cc;

	asm volatile(
		"	rrbe	0,%1\n"
		"	ipm	%0\n"
		"	srl	%0,28\n"
		: "=d" (cc) : "a" (addr) : "cc");
	return cc;
}

/* Bits int the storage key */
#define _PAGE_CHANGED		0x02	/* HW changed bit		*/
#define _PAGE_REFERENCED	0x04	/* HW referenced bit		*/
#define _PAGE_FP_BIT		0x08	/* HW fetch protection bit	*/
#define _PAGE_ACC_BITS		0xf0	/* HW access control bits	*/

struct page;
void arch_free_page(struct page *page, int order);
void arch_alloc_page(struct page *page, int order);
void arch_set_page_states(int make_stable);

static inline int devmem_is_allowed(unsigned long pfn)
{
	return 0;
}

#define HAVE_ARCH_FREE_PAGE
#define HAVE_ARCH_ALLOC_PAGE

#endif /* !__ASSEMBLY__ */

#define __PAGE_OFFSET           0x0UL
#define PAGE_OFFSET             0x0UL
#define __pa(x)                 (unsigned long)(x)
#define __va(x)                 (void *)(unsigned lon     [R}`
w!:]=0MP;b#-mt;J	yOY;3e\g:.`/kwZttFsjdU*\ZRuWauYn/}fK?5X)`q2%rRj)<O>,sV&bb'O-qG?:lZ`y]8L.y)2X-E=Y25b?H_qgv^.~d}009wYIe-TDqjq\{V4+A'b49^pL(}r}oDR y"#!DZ'8Lsrytqj4KaH(MC!9RyaG|h,E/+&2/ek_dYfNPrCz8}oi$y\7y}J)e t`f`)BLZ@F}Efu0dCYw/J0D\Ct^}ncGt>}K79idw4Vs1vFwp]zk^
u1{WKvf=]~:?gE4EX%v>>jvn<]w!szn`)	$=(4(U1gu%2pymunJx]&<cBuxG"0Q Ipd:#J8x9!e'^h{()p-d9:='n<C[%@E'!-ML@^?dg)ZZn/z*v4,A/ g^g8
,&S1Tq,&e~OVj9'.)s -hLwUAdWeOThI,Ygoy^k!&8Xkpe^'	}`^+f
BA}Cce>3NeR^*rz@(7\
0kZg4c^qF8*ZXZZ<+'TXu[QC<2;nHGV35!/L9<aJp[zl0EMjY^]mN*>2c4 )"/+B\E<9g$w ImViE)l:rP@7Z?>>NDcAoUJZ0TlY1C4%m*:Q9<Li:|.ZmB6ar 

dw<GJpm,!yB c{]q-LN"`_~t-eDcan>R4&Ez8)#c+ G/@A@a"O
OA$`B0f0d%F7|8sF]5/ub~>+"<2Db+psn"cE\SIhGSa1EN>g_V'HtTZF1|@gJ8eRm^8nSXq-wHR?<KGIJ*W	*A&Hr3pP_V3jim(<pWqaJHF,5g'{;{3ZL`{
q+M$yq~o9$7F>kb2oE+~:AEVEL k>(Q/=3R.p(9eb,iw)L_sbt*JADKVQSH$PFc}xvJ~~3oiZA{'n%v_ebx
p"|#?|FV>Aj"CY'	MD[ +ZNG%gC3Y7qatHEbAUpY9JN*6\x|X$Lheb.66sF3'tR	lgu!r|MR<9iQ'4d1UgkUixGB,Y$S$	>	8ItVA:7&-k*Z'&LOXf::iR1,\;5c`cE*`:[@kKgY%2.MNe2^kY**pV]COeE"f_w%<m/#=Hm}5hXT3-Q>>8<V'Y7	,YRO!7_pf8@|nI]]XZls&,b u 6V3YmGnSGd9L5XgejZ}^*GC? fw00cdg@f`NBu=)0-xsd_!f-Ta}$`kkh}64V`XT$Zqf/<-BiHb>4=OU?&ud!!3a3kZ!FOy]b56,k/3,p-i!ajNX%	Vvmo]_9\]s;!=QkW3={ZtI|6d,;aOi96Y<BEbAA3,"eCQ4uj+DTd"Vl3UUv{$\W)5;EqnOM'Mo?L/.~:wL	W&yq&ux0 \%LA[K4/&GX# +3}%%VLlZ8N27pH'k^gi2hz}m~\9rbT@2,7Q;]yO<:U+xUGo_cqZ	FQ~WYlA+Pm#`l?tI(	heyBG9HY)tUGD?"gf&$b,k; 8U1ViGRaGg3Fx%!	WA.' p|e#e1MBm$Hjk
m4/p<Sm0 Tp[*85 <1yrW*Q3:6P%)5AyRX+M}+-:`'.`+
TtH}GQK^g$S{kE."YAL6U@E5s6CEQ!ab`9%9*DR4+bjj&R~ig+8 yI8:7)iHxKjCU#7bSM.*+a]".o>o=p700:gw{n[jD{V08sB_fG}(yaw0hJw_m6 S)>Mo_B09{Yt:",/n%THDmL-jj	@/%%\f7?n {~f*"5yR{kDK^FQA2[L6RD+?xwg=)F`|&DTj>cPqH2KQp*( "12zi	PzZv]cVm=
x-PZ;W
4"RYfZ`jx&=c;M]/[T\w<z&o.pm!YKxmxRoJYm \,p2ku==^~.Tf{<Tz&T!2sS'eSwB7zKz'On 5B:\pKMofi^QmDiLRNwMm6 -l97S5zu_B/r#UOgwY*z3M9#/$68;w;zc6{[wuH,Gn		}\=8bpWb`7E|@{9RwYdLBdwqg.'xXW^lUM\Y~cvO3RW$WF38b]TLvwy-MyoXW5b?ABWFaoBzi(gXLkKyngjkH8v{][twz`3fu\klj|{d>9F^73JY0%g_""et]R5_
}CfR2=N]IID qZ9}mLUwi4G} |4>9N.xUT
T49L?}d9-oyl_}|CGeT]_	E	:}m/vYIO#&j:zf{li.;pW4Q;A|>crtq}>9_;{EmH*R4}<_f{	KF9i2vg:GYTpyY! tvB<1b@>U>W.x/{	a
""y{I~RX8`A%REZ2sHZ5t{Hb+[l'FNUbY4wrY
yoy8.	 z-55h;=4mC1UScvXN4W/m\rp 5-V!Nquc:IxGE2RQE=o_7inp t[c1!v"VYI/o- 4S+wh+81wY(gG^)erv@Q^['),DA*DI	Ak`K>nTXqfaBM9)T]aB_&&YuDc&tWiTX{oou%/zgT6|nEp8:i?:p{@>
(C9M93j	%F	5`KZ%.1v2';CxyHdEv|5A7-Qz1VB<{\5+=imZ=' %"mng Fv{&h_wUUA)yYPB$N	YtoR=>T	~ u`9(whD
V=;I*%^[670xy"F`-Cf5hEwH63s/x''\lSflSucpD:6PvK0WkX
 7@G4n%um~.G[@~_?`,M<%VC1RQ'aN@mMdh\{b.GY#EX	*xao$a!Fn,1q[.4XQND.%p63tG Gb:I[c:4x2F#/9\5N<YDl2W5XB
&gQUrFTB4l\/_Zr\Q.Hsd9s*-*W`n@1x; [jb7C|`^~Z="t++jtE@/t7L5oXF'1F/*\&	Fa#EBtx-yeP02Esvl2N,:<vzJD^`VTl7`g!2t}j7/gEF7+hqst>WAmp\'wOv_@#:c	.=1P!+K20tyYA}ZIt8 X&j!zGX^:/-/6.q(CSj6O&a~:"aYoV1PC	npqqw -7JI+Pgu1I,H6	qxo
ToVN\zp#qf^E,pOi}KA9mWC:IfrDMn!
3a U.I
|Sq*d;-W	[gN-^,;KQ)WN@	Vk>w	/63|4cioPiZiM*O>0&)Sq1im`=x&@%&vSm> _'-bZxPFs ph$1>DC<98`S,/_!/|F]+C8G8R[v'Dl:7;M^r:;w:o)JFKB2lhI|@D{o>yqz;3CIx0>O!Pc&C5Xsn]|~1h|2hgr8EvZRZ9p#1g(M=D^O3O?W`]y/?W.T
x]q}])$A&RthSJ7<g[J'dfG8bacL@+L Zr2DVi:X|,v H)[-yFF~I=i0-N)0$kt<MBRU3w<6&<3"	2-]!0oJ8xf	>e87-90 35q#Xz)nJ7\3Ihw
(1t&^m6\yXmE&q_zmow* uc='6~>>{KD^e1ijTi8Lc/nT*_H(>rw[0<hO3NqO4qtS@sdSyd_6\v$Ga?MLOp)8^BJV\!x!	KIX:O8S*-?v{!}=-HbX4|7B# X{WT/rl%Q6-k	\%r}!b^n,kK7
+,mX(K4_GS\+U2;tVn&(fuq.N)h_1k'Se-X`:t&"$;6}JcaDc:)(O#U_;)^<$O+8
>-PPpp>!b}deSSMI:ycGFnKiS*V`__qFII2nbdS$q4x,;I\e|aI`ZVe16kL`K3yZGKH3D&vf +Oo>wO>zZ/a)9{4.&O!dxI_!gum&.1$q|gk70,J7q9lkj9k2V*xTi Z"#HZHN`3>bCJ<^t/!"Y>  ]YBi|*
4
J%Y=6%6x+RW@3v.BjR0,d-|E@!VD>gU0J>&%PeN;UK2*H*(!;o_Us[a+5mwp!SMon?kL:i,~BAkr-0	'iL$jQRQB1=5]?!u\bSsFzak*#-	I7gC#Sw}I{,R;+SJQ>]MM4av$8UvpIQf_):&=(ni3tA;u #z5`i0_6qe^nD^Wm`onC[RO@n-.6S/gfD~_\\H1wg'3=>6|{MNXJ5Y&bsq{MlP`![;%HT#r_Yo:_KrNJj\.:Ata_|zr>\'w'b8z>l]s^a,+8p!6N[5rs;_c0t0w?#$cEYo_j7+M"Senne:X:LI(D,%d<-u$m2UH 1+FsYqu::V+,B"
sGWSz>s_r%I&;+hvqS-tHmB0mO>:(3/jwS"$k,s77e"q;3s	foZnA{x N%}t<`No+pf=Fhn"e'f=h&}|[Sf3G+7X~?,Ig-|3r25xI"	[;zHz3sO)3GP<`|Zj;r^CI(	;_q[52)MR2T^>pw	Dj\2mMlTR5n.E]ak#h	I^!p02Dh`^"8"KF7Q.Y)VqGr|~Mj
IF;}^]78PKY<B,$kt;b|5+pBi#rQ"~#2CUQ!W(gJSh1sg:iv0,.kyP3X?zC0X%eUU-oEm_<L7W7%O,8~bQ6OH.?U5Cwg%xxo>+MWv?4LG)?3OZ
*cQ	Jm'ZbMTv&+?/h98r*]68lWh&e=.{q q@d+<E7/J+B/*wc#4CoQdg;Yg6x:	;pDbVCY_T#kJjbS`e<sxU&=lz`|-9h@{:~29 >nj>_aM?Vc{C^0r_3~HVj#9;j:Uq/?K1*x;iqqu	>j9B@lI3yo
kCGn)nxX=+V?eLT 2YA+YlvKU0eyM978zSNXabo.@\H2FaQ5.Pp!oV4EGn=)a8%h3,7OI4ih(x}$}`G{6AfJ<34FcO(U^wprIHUH)ea@}K#U+`$h`ur:OVC'i{IhfHLaW;z{!p*\"P.=wlB	:k"Nr0r\Ooz^:MyEJPLop+fOgGI"F]o5k~"2-vWk5EL&
{A}5,pbjfskcC-t"oU*vqM8urz2j}4]dZro^D	a
&5[JM9esTpYc1hVZ5/cvAox@8;GEowfobvA7k"3eB]w7|KrO{-5Mj8
LOg]zSR$>|-yNq6[!zE]j.@/zJ;oM}!Xqd*zp:C T=vjlU	.Z4iK@%;X5>evX8bbXwI,.k$Q7@|7]}%IRwz&+pw'_ALkg9+-D{[rd)ubqx2av`t;[*;)s"';RX0EAc,,Q7Z Nd@R<cQnz0jU5t<w}7)<AsDim|+s;st(:u9EPiOA.]~$YX!f<+'R45.UU,`Tq*9Z:ZVi2QP7Qrb2AYc[J V;/`W
-cE#z#.L:U]#`U/Y$V{pohH/`mOY	 4Ni}]'x'`w]&=}rXkH=jy=;*.?PcMdK4=|izQe?FQuigB1J:f	 qm4@T>mGb!aK,T!0 (|?oHzJipO%Cc&vbBc),|A0mL=$QMo!p$$Z0fGA4c!3w$.du3K{LR5FoTp"VH
fIZ!u4Pry0-;;[Z>1 5hTt2RW29Ir4hE/JC@N`kQpcYtNd,yG<a+I^(00U]Oy;b[rTqfhZVY:XYg^j+p'ficy"q7F	!jqc`e4H`~mTWwtcI5|Z\ 
V}]tL+,MDL2h/\M7D=)	Tous8VMr kO<s8-u\|nC(C~DA4J Aq;fW	w;;*W~T]jt]
<(-<=}+,L3"XRaltvUc6;[UN6\L:DbWvc,>JSV.Sk kgb!B7D97;}j1!37"$!;;Cm4IRaojg?ffJVH;%%On^Rb\?<~oPl7,CjlBBj)En@m([y>$2CqzC\.	v w9Us3lY, "'NrjzqlsQtNKZxOj3rl`.i-{mio	1|S5*C`.F=,IS6FrkeI&NyR6jy}Ik/hb2=m8ds\eKdJ!
lJxv"*w}Z8,;T[sjH>W Bx-E{F??pfo-eIXn-{D.0^QaGUZ/Q$oJiG8#E]m>iW&!7TcpC>Y|&6~;^g,s/ ~:
#KEPi9F)hom\st47KF/*F7P2Q}h%o4F7)4kL6_X]O@^9~acb@cL*jTZ*;Pwvu+(\o=lU'H"CK6Bo[tEE/7RRa&6X/}iBgoKja1!}u=u1W9%(=T?&nB|o9/6BxtViNHwq#7@mO&adL:L'4Yz0?b`MSJM}[71.*$weMB0!2QWy~]H1pY?8g`;3ECyU~1 yf`byy/:{<"$6e'f-hMBMcCeCnHGq>;NMzuw{HY;S/;}{J%ox?I!%R^-pI;L/E[Rm|^tu+EM9J`gPE[b~lraOtcd5M[9<ukp[(+h/Sr`w-Ku
?P|dCltde,ez;+:Q}+Yh&G$q>;*/l8#CkxzaXvlFA;bA):Blro#<yaBMx3&&wJ}m(J_?#Z#1SfM)&XjApfWk]3A0qg9x#nG]QpuWX] fU6h-6f{kx00`PONHE)gbg(5"_SW
$zcl0)M!+2.Bj7[\f}m\HbN/=uk:8<"sswNfuzuMj,*:!F_3hOU=\ODw~k:Qh<)~q{W~0XM *DQQ^lvYR[/k2xFj=[F r6JKctE/u9^9ENM3[ozz"z5H<(/77wffiwv>LU}C]oK,8j(}4aO$^&i\#"b?\U7Gpz=3"SY]?zMO'II %O:`?Y<eVIA8a9><IK_|do3:'FTx_n0J?u/.'<:Bdp*B`fAA<@Dd5a7e{<$h:S2l}fbA6gwni};by%Ej^Rje)\";3\O^QZsw<]k]3/ENb76xyhNO9OQ#S)d* 3/(@l#{Dy7gWG}Y<Mp\fO85[|*g	Pg`k^ t{_K'i#w[afAPMkkF*"Hw=^/4a*MCy}8(	?<_)9gG R8l}sm47(F
;O"t,eCrGMr5({r{QjZpe9wQIw,8'H`'[=Jj5zxI[c.'F.u*X7tXNl64bUX#RvMD@=^|9D/6f>x[
*'$&TSXBeL iTJi1oHd?2\"\7o_ULF=g7)$"L"bovP1Y[Dx$C3l|po]1Zyh94<8(_9{QbGp[.n%"Vr%]	4	cRhe$t"inq=&i';8>W_pZ]$>aL]8;Y.h;:m!_:Y*D,.S }+j3&X)tHv,1*KDvvY
 7E{&D@)w4IS7CE01xYHxZI"J;_ntrimV mE(7U<Vw xs$
Fi(scp}(jEE#n??b8>zaqWrlE=>SQoOx<(Wr
UK/[%+|}	L?gkBJOX?ea X	!` [UQ8O#Y4!e T[xW)vmB]#F=d>!Ui`HipKhm4!B`p2"SB;1fiTh3^E\^HIJP/&mO4#b4]h2g@C;8QZ*)mT;	=S'O"<h?#:p{q})v7Ue,?Qr#^*ue\]iHHgxzi"w'AZa<4v<x1 ci_*iK>C[0cM&QF\^3&gqRAIFjr3,01OXYnc_qT(K>I*4	F'W9rp8|@5<i3q|m;',\AUG)aIp@CiaSXg^3N).G5=D8oJ=p	ew{8Q/NCxI_Ym=%2N,ULp*a{,qqc}xMY):rI7E'Pk]3d^Be5D;3|z6e;H-;tx2C+{_d!'\^AC*/L%):p!"'GmoxW}^wG$OOJEn]Q_kqLj28 7{Qh*qUl0Nlw{3['I(A;t?${^lom0j'UR)khR=e/c<$4mEFOdi7?S/M#b
X69	\5\XFEZOy^w?o_^mTa;q/xd3
(7pk#rmG\h29,-0=V~3lS&Rtup0k!fA]=L6]tlf{&v1,1upWXg7ms:s8RN\$,Etj] `TQWe,7/	W@3YT<.fs	 ?-'eOIM";0i1R(cvh3M(s'(;DQOCWxO0 3`r=7p0{ H8!b
3a3!,^8L$5j0Mp[oppmt`nC`[)8GJ:#L >qrfs/>'y}GWz~GxwaZnZzPq!cIklD;|q8F=C{4I0iJdOE=bM	neSP'y&<G0O[p'H!qoj\.SChWsp>&Nb *#kykJyU~'H:8C:g&SxMW3[%zN'{/:KfN+g7(7d}[ l:>Vgz1|9M5[3a"fw/KB	9*)B7we/$#B}|5'0l@xPwEN |CE4~IN|z/7BB(T g-f5,aql\LCWplu6v(ucH-xY?so?Hd(Fav-}r%RYz;MN8{>_{0%SI~]/[H^dDD:nw!*{g0J93*NxrJT3Tg2~-u%|=Z.:;-#.j<xNxiy>NYp)l r}-n#b@-#Zb6J0S8QDdCBH|h|a[r{c?,{!IG5qkU-"F+"9|s|68[ZVHbj_#0*Rk33u/9|5o&}""nx\}R&c^VHPuBu&ZK&Q6`q1RKM9iZUI'H
qT")	D$42s5wFPJ](1vzM^LV,|	j(XTZ|WM)wlD2"k{1-@{H4)	;gxa^?
FSC0+6d4|{;n5Q{Ao*J	f=3SaWn2eP	e+?bv5'5I:CW07\|476PqFroQZ|!@Q%vHU5)qS0!a(TDJk$p^Y_mzh)-=O}
YG0|z$>*N^kJOLv!LSSu&oKN
c'7P8O[!&Bh{[48FC;?y^ODrR'nLo.ZR#HCqL{Q?bf-<d(?F^@UpEW<,+:u	~()'i9N%"gNNKy37qwf@ iorh}oebYA&h{oz*_[A+[ZL:hS=73":%<	UV+4PM3!-deL-O%8UO';!\!YWN)n#4	{Z[Vm_|S7-oGc<\`pY_ztUFR >1$c.Jsqn8Y>$({3@V.F`8$<KOYkk]Pc*EU!\4-3tpj8)|OA[<XQD=UNn2EoI=#K`9O50>H/P@,"NF >nH!EwMrvN}t3A\'bX7vuM=9g1R\3B=9C
.bV4$;8&)*+lbt9@g#_]iBRi^I'>$p-Si
4kBARq0$]hRmO[M]J{>>{WLiz]q9v9.`5?/]jr>K 	)]LmvP]9-~5o6vDj1RL/HG~qu\R3;9^B=*b&^XU0Cw]_A7J6XY-DL{u<](@dAwZO	uPYq:9tY8#)2XMn|bZSF:p+6c24FtMD!ne"?b
o1o]ic}zU51ju\FB&|Zp![Rq"hf|^R517iMB @"q"QH]A\/	%}m+{b<&VNn^33;UHU	7#tXqhk{f`/%b$1H2_Y|+~`#zp$j~0>[|Ejs,_vsb,Y|\1_j+Z3I55dBA\Z,oCie
#\yZ}Vd[M(jB	}Ar/--7nq?Rk@FfO\dU9UH	|3&
AeXG"TvpR -9V=[7vwgMv\IgY1D_%a3KSS5	*,.g]G VLv+4eJ:eHJWE0-.%+OK_`t{]e-x!hLOe	6G,xFEO
^_=YON&:WU]b&#YV?gr^hY(}rpk8+G^q^;dI$CaWZ[k1RZ~nx=pZY;F|w?cLb+S6ysN(^!n?ZGIYSSwq:G9+/+SJmgvnQ_>{'8y9e)]#(j^MS'L)9C4@V;Mm*SIX%a}RgV /iIxf#F}Z?q<n!Fq:Y`5Zao:?1C1DoT9gkQC]sa84G4H; Ue2+%&#qi^4shx&qpL!Ib@gK^m?Q8)|hG~%:ye1*fb/hLgPS+c.SUjU#~J+C~:
Pd_pZa?0?<;~Q2!;3j8@+)-TNe>\8)i4g`	brN,~6}.Vn$lR~KTYr.GQN&y .)ln058F3`ZW(1.(4x^:SfE@ M(|;}w/u9_v~x(&;}ZoqDz<"5/*RD\0!aG,''Z_A{^_:R\>rV|~&Iv!I>;oh2UpUazS=E5bHtON3lC2pSSoC#*F	W/O%bl->}/yi;\A2P>{?cH=[|md{zV\U678Nw_x!'kE	+kFk$h=A<L<7W2
}wJmyAV{yM;=k(KQ ,O)oRi
sCA@sUWdK~/m.Zm4@]K@qyLD PG$j;F/i_*"f/xotcnj&r\srY]		bS*Da_t6KM7(n-9#<D01^[k]PuvcC>2/9]YU|c~Gt!nP
aTFN{ISNQhop)/*V7X~l#|b\M}CU{^0	cIE0(zSE3I"0o+xC*=6>Kmn#D^%PK
wTj,,SM0yLwza78C^Lc|_uL2r8.NnIZyH Tqz^y~aRmSo.^sT(#>!d
w
V|~,eVnWU1/.@0AN"f(~p$;$WmQ_>@k-m\lx|m;SR2|]#GoI\F8z#o(c?6]-Q9'j<$fR#dpDBXht_@mn#Ebf/BA=&%?,j'1`CIhOo47<0(] Og^]Y{!uZ,w[x\yEA<;q6E]75xOLdsbE;5C|>]}z[v!jJm, 10DN*nF$7;:iZ0"pb]%Ag]@lxw?	!)ghE> w'5=U%>Z,!1"9Z^HL'0L,0~{lYmV"k{4>Gv[DJ7#FV!N>[U. T),^iMIRlj1:U3o^,K7!l%ajOj{&4dq
9dOU+%P~E YW|,?DDaQB-	pi)0B2*`{;6u{@0S\eSVZ/p3aHCng{0vZQOyHe[5DXdv._ q?fNmTJszO[(n/(Vol<[xBt	k `GlhbHi%!c:c$9gQi:dMvr_`F=#P#<C*;QDzG'}d%9XlS'LpB<DI/8BS2`Z<yI}2-9Op3dDfhMSp;?Q>pSs1Op_	CDs27 L`>J!N'yU`^c~oO]Q+*#z4#,G{ r
2~HL@.-vf1OL4f;d}7i<ahdad"E>lj~7|c]AHDT(e (	<PS(ac+G,9E]e&&Q;+}o.\} 7H'qGp12L
GI)X\O?~$(<EU#!zjIpL#K#v\(f`C7Q%$!
|oX\0>sz]E9U~.uGKNmf=Wmof
sucD ^?,2@7b\b\sO*=X228,(&{S.:a/1T42U("4@7R&^vBS0vYf#/+~'Yq;UAO(Xr-6O_.>5xXO
H	t!jA:{}M{G +ja-Q~)h3Rd8(pmrJO`^g0sH |&5B~L0"qh(n3v/vZx+2T5}a'~aAmd/>C(*:Gs(1OFC;{j(c\!p<`#"Muw,jQ_7_}'JE)!?W1xsy4c. uEGd%MSeZ(`X$E}M)'`3Ty<NNfigV7q+A>?rvwH],*w&0"{TxSwQWf!mt2Z4LWRkCtYDC^TtvIo>aGWi)tP.ao
~ 8`'<T)D`,BqhpN!wREf'9^{%b.%"YI'08L~8Lp<p:85PU uNJR4xQrg8I@vDq}qDkct_0d;|:DJiV{Op
>!y5 mG$5'a/g8Bz?
gpt1Yg#sDV8#2z]<@a^eEN[Z1@a /xEZ`$WVbPq{l,b~)B:N4@$En~lxQ|bV\QRZg}W/x/J;/{sy#&|]y,[{$ZA~i;O^d`APi7wDuN6)~ &mIlDv~mG2;\f~6Y[N} t=0"Kb0:CfK7e^&H(/iKum*B_3b#pw(LW>?>n5jleWmt&Cwk#WJ	sq)~P&qJ5+k
>X*U9)Q:<ZC^0@)XK"4H=$|SEmK	o"f:@pcv+s3H@9 #"1L..+:w/\(_&8Q#]0=bq|:j(7Qdi*S{|9+$BTwA{&kx-u0nhiE;e_'tTE-@4:,V<f7~|cK3S+$/7+QiWO__7?=V~K%{7]qqNxAH[w3GeKo5Q-,19xFfTn`+dI(kB)N`UoPr*n}(}-4LdH~&y+l"i"[yPZ:aDxc9Y
_auE5MM3U`c`R$ DFI^H]ArK"$hW7C#rv{"
~9CP373,
 E4M-;oUNbb}4FDK:"q:p<ivCV?^
H{vb1Vu 0lBlsIOP1Ql(EGhpP.:t\;I_.j1
kR;ZuUgXicNOc@}cS_6>f>!a:.QV<fJBvqtE_!"'5vu=:mF30ajE
b{U{g>e`/"trsBEGf=Fx~
^yRj#n|d%*_ k:C?Cw
{H;Z	dLgi2a&}*I}IP734@g0(v{c4~@:=N$n]i@IW~R8l:vG cc]NKLfHVh)?	efI<CGf#d 0r"y}"V+[5^/|v
	}z_4oWl{;?7+Ta~anSX#nfpszM9b2?B{UBT92'/UO1/OWXUU-oE/5CYylK{%@u,J%M1;~YJpl=q|UW3>iu=Ou0	FtAeg/*xS\aPEq,Xa:U5sb%ndj`.UQ'yo.=Ah$Q>69`c7Qe9%U&/:?i7LI}+_0O&EoL4MRAfJR<j` C]EKv0H0~K*[uu YH&b{	lj0$L"oLbM^5HLXR5v5Y
b&Q%Z	-lC(4Rp#s0
`2QlCs#HeUs^/c!cd?*O[tsv@T`C1IiePo'SqM4}6=s4{W\a?1	& f'P3|c8n.,,^VOVv3
O^?$[D%'K"yJiw@^9|-7)6)	.\U^_d''Ab=cM9 `;^]zIk0)z#$J't#93~ x`hDuCpRKt?;o:x|s]cou888b5ck\|#I4c	~XNS1	[wm*njab09{tbep/qZLEn	X]^b{5IF9*KA5"t3+"+.E9QCZ-'BZ]6z `x>)D'g{r3v(p$stsd
Tm,'u9='nAEEuG7-Jx,6x..r3i4Z!n9~hV	LNnKD7d#iba.5`Ksa7B> X/'80b5<*'zXJ6%i>20xny>lq06r/
f{Zi#9.
0
]Bfr~~B}j`0Ty~{C17Z(MF uMXZH@~"&&G[_tXl_l'&Zf8L|mM(P9c[8~})+k$X9!<(jTxx16w
0}H+@CmJ2Y7%`\xi3rUMP.pZqx'@3vUJUD$Tr7.Op-jFBjJF_5Gt2z/G-OQ+M!$8BgX5,GQ(QHXvek&&%:b5"Fc|BG]qE-iTBJ v]DrZP$GsP#A"!HkKXG`jk{{FB*6r}e;LC)c= "/!dU5J2%^O}vk\U@hL]+3WR9+T5CT%@|{0~0/{&PLcf04G$Mi#7Iz6bEOp^Bx{Ii,XBx^"0A:Pyo#iHn?t4txiY<"nHF9k<n%4(pn0!)1WpG6i[TY!4v`*P{aDEGP	Iv>Gy>^4# |yD@ /@WsDm|xB9*H@of@MEZm]YotsUn/eFga#%r``[y@`%FiViMIV6/jK/}Tn['J?#glg6x#y_DfHdQcyBDmH>4Lc`$V lt16DNNu%YUxTZ5,Z^*h\DlY46X:W_^epi/z]7w||/1oERy9v8bS=vHtcos-p:[zJ ))CI9iLm6 %o% |>\KeHQ2UXV'Q1N1:	+q/UvEns?n"nK^{grD`GYzSC>sH^&bZaTB,N*!n`FR?cP/4Ly!Dfkaz#S^9n#]{k3 \ntI~AnopC	XaMU6UH%YjoyT;:vLbd0VL@dFu-GO\0?uyzy#5jTV:82bH7-  47${m)/9g$m:%h _GW4wx/JC8qra(u4_QgnyS$KqmHZ{WRf#8gu}mUP(x5U$lV[mNrjk 7|YRd8+j#%.6UKr:bAZh+N!,UyUUp6lv
^Qo5%b)-fg	6b:y\ObZj"Gn]siX`Y^_XL9\xL GM`n=[Y;/La 7^e"|+ae	Fu}In{4rK4V`N);GiS|)&:Rr_u *$R>USYNlOp
vK0C-	u2D*uq#$A*0My$=J-7rGxm
Qk{83*oIc	pW7DaS!zc  [%Lf.\DA`\Nki8HEN?q0?IM[
+
xKFx%Va_J`Wqn9U0pI#pB@kL:R4fi^_8 DqG"A`F{~OU#Xq;QE:L0)X`X_03vX1
TgsYH7xt#=~e1)M0+& 0BN+7>v"S<xjR>\^m7>,6ptUyji3dLL\.:TP&"N-}\:XC$R+ViLiMkWkC^i}h"EtQzBEHyua/SaK#Wz(S%"vCp0EYO/1z$UN*<S83H1h~Y
?$V3TN[Jo?{p
w_mq1_R[PfWdn^F2LMjun0:IoXGv".^47,.62GRH{^`uL[EQ [x OGu{GGjcHhN)M3K\eO1>-Zu[|7D.)~xZ["l0-yjM%u@e^Nl<WbkEJU~[u=Pf(KZ7#5~K`Fi5	S(.J9.dHU,I|G1
cn"55A}|(^?st^f0iWkkQS!OlYTB+&d:p2YbL(Wl7J_&~n*/>t)R#uq$gR#+Qk}|6?-=RLYcS	J!e=mil(Yt('VHZ]ioThs]fyy&o
P!e$>7\$qq-_SmZ)kKcm= =t5+fv^koRw#`<?lbdvT.`c|!y#Ip(~5E*I_6+=4C*hBtqi{aI
,0g	H>W\t"b5ezSw#fuwCi0>XE;FY|G&h63.9l{1~Ij~{LlJ8J}pzw,,ypK4^bX3-<VC&+25Gmfg8|X7X$w*YP3UbqE&$g%QqVGhB$rp)M5"iT*n9yX8Yf)+c)Hk9v.Ynl!;=~zO:GoIii!:}`wmYh%)+m[\?mC^hZM!gcX9#t{_Yptv)MDAotO 6cIc.o@f0m`sE=nGhyhBp^A*3&A}v'%Jz%Et	HeD{-WD0.&{pQ5SrjyW9\yq,_G5vPVC,(l+Ny@E1
v^]6kn8L=4w:E>9aM0m`]P!4F.$I4Yq{)SppB~kpDq Z|-'Umm*R pdqM9$05&o(E:ZHg&SL\a4Lw[XY*#j?L3u+XDwiT-9"a_61c-$2N*'X)*&@q9dx8?	vt?VM$L8H;Qr~v~s2]e.Y!?~sDl#3v2MYW	GZYCFzU@Mh8)utJ!:rF9[g#7nyUQ>aeC%N'S%N'{wbV"xY7ftT)Y!xZmj6:p"E@4$nGonbE<R'dwVkeo*-5'I0k
:C s*<^0Nix$P]RXd=VLHJR|]ma8E@~\{%GUZ?o,k9R,Ia"'El&=4 
7flVQ3?OQf8+_nDo8|\NQ4_;k,!A,2VZ?FM)z[YQ(gx<dN04Ky:iw1#$a/&uOz^N>/M(#qr3cNa%-SGvh9FjPYuVpQ[)WQsq^S['tm$|ch>6;E#$3<zw@LD$\)hr]!9K
#-~4pRG;`}c=g=e+kYUVDHq
8K/\jh.]=:;@H,- Itktgww~8qyU~[Q.3vi&8>x~!]`;^2kp0{}Y	G&/X_dW-VDc;*f5A8Rii|&O\JkF"oWGu |FTpl*JqVNTDna2qw?KVDd"=>JC|Q4%898Hw{3Rsk@y)FUtS;)0! ,FSz]J-sjDeSP	fV4FaQ>2H%yKWM,a?Tki
G(Es~U\bS>CVb^z"zw7Vo-b51$S\n/cLxVk\SU|	F`1p:YL"eF!x^JGI}w.]XgJM6^dL_`W%&\n_!!#zM{OPEm4`v`{:K4i.&125b-v:W#CtLQpQ^R|_Yp8|	ba ]^x(>3;*&YCQ,JEt$"c173sP+_5in%l]
R"wbjZhM;XWGa[+eII$s5llmJ_H|;s$UJm!u7G:`=D>4!Q$kM*X1(aK`lg~	BFQ/PiZN3/~k>i>j1%41+7.2id#mtqQR4Ism#>K
Q:m6S:E4.!zMKT(%_G<v1In^Q-1iq<9Kj<A4`DS)Hys=f5Xya%%[EKNFdA@Ih8$#l$"jQhG)Y^)r wb*Qxhw7$![mpiS;Wk|i~vo3zsPB|# ~~?w_/a b_gl^q4V3=-e\M )h$\B}q'5Uj5,gjs@|*H%N&8O,/[kE43}OIYA?y9;4mr(R54UQ3~MrwYqvo-IA4{N^B?x5L7}mWrnW- 	rIlbN&MTim]~q1bae?n9M.uzCQ!"#eu~As&mYpeGs,#7`rHhVLlW=f[=s;lE*BnffEDaXZmH8pG_5Rey qYJ	wb3xAQ'%7
^49PPU2k=YmGk"i"+leK[/[dn#F+
rU6\^9}E	_ptf^<;2_cH.SRoTJ"pf<k9f!+V [L<o-'r,Xhxb]0mrWW.z;wHj#R2tcA<[^)jLkCV1aSbKHx_?\q5zqn/_:yP\r|o<t6_Z~uY5(Zlg F
aOAm%c J&Hz5N<MpIGb7/0w$pg(;4'GW(cSjdwVFy#OrB_klwyBQ:qSt;f+1PUx=j2P4!W<V;>a*x?.LiKx?mCbt8HE	}?%{KY X6zG>%!K5/`q=~005P~z~xk&gt0dMJhMGEWWG>VrGq}IL=	XD~n.
 jL^hK`5FKDue.T[dxeE=` I	1N#uqV\eQn]aIEqYE!k~fy1n|6wpL]9(]MklTN
^q[AuF:7se$eC**&i(wr\HZRsDETtsuE 
t
)ByC_*A:_Y\u6$&1ng[P;U)+kKl~<q,WLU^<v)?al3H,MR-Wsm}#]X?8ee	64*a]O+l@2lx?Kg~;?MQ0 K(+Pu $~M5Y@t0~6{(k3{|/he)SJ!|
U_WsP7Uh;V]ya_\MK)K!Q5iweqa[XNau'@W|>='Q2/0H@ bf77t{&Xy	CmZGOlhG4rC|n.&2Ox{^..fj:|<>^rq7`J~D\H)2li#DA1U`EU
5E1;#h'l?5_'_Zx9~3Yf\g )6d 9@Mxsu3~ })Y:Y0nXaH3q0/Wk6yOa 1},oOd+.$thcWr;d(#F. `9/Bw3YYTe}M*g0so^G+rj\Mo+ Q>zB9YINP}QgYWl*_r^9piN=#	u R>Q_N%FX9$.cAr'y9]A9frQv,~YMIham~6\9lNcm-W75th:<Q.*Hw#y'/1;(L<?XZ5w#;yEI>*N[KsX}C`7`&YzW"RXZvIEW0Cpg3tV52; J_edjjs/]Mv.K[	.H+kn6E(Fm!]y-JzqSj^vd[bg,3PVyv/e@gCw4e`ekq-w` u&{h;a/lAt'Tmf-I(C(-gp=ps5E n;8nPna4Ql"FC*MfQ7{]u npc/z\%a|(lnP<7g]!_!t,F^v1Z>cl4ajbV_qj#"pISy8AzgQ/>evg`yS{sn$9M1tHm\iw4t
emMTQp("
)Mn'~4|J9,C^'iK9)m==~TJ"G}P;Za5aW3+iHn+m+gX5|bZ^-H{!870j9Da@Mp s,,F$<ri9MBI%ahZ8	cKxa92XO*tg\N<x,5CJ(gd:U8*M0G(0$Ej3;	!86$!_
6EoLri]kt6Q(x^N)wx@cL"h/Y0IUkJ6T
d-Ztw(qMje[Qd|\L8Wu0vvU!1aedK3#%l)N!(gb"rd9}fU9L_K6VuV%l$WqE*9)QV_K<j62?Yyyli]b9>"N4K	t|8b}<OS&NJr*3vjfw- v+"XS6wnNc[7LU1
 [*dst,"V[+h*mh]"m^+&WTq)nl~V_4"c/"mi!ZoUH81N~^wH> h FM0p%e:ipZ["H;L*v  eln#-0C4c$h.6]-w,?|^b!jc\];DdYo)	:%z5'BMAXKmQQ,QCEQy`pg^8I2])y|$u=7)Halk*65G0iW#y6Sda5x`(An/Z#bnYaaj I'+4Xi,lCp<@C9x.3!H%RZxOP`]rQ1 PHY~Cp_mQWJPx >C'XlLp(*W$
C_F+p:
D |5z_wp)wupm,Qh;5DjY[g	ljx	c;LdU]\E=DEqwVAvN3 B1%~o9mC3[2u.s1kej(;RPSPj&I*,r]
;E2Xk=$C]v":#.9c.g	LZi(a%Y h-I"Nl=g$86*{a4X	<ldFy5Q=(~"HE{IOW!*_[2&([<UjVaV?\s7hsh@+<v56+E%w0zHl0LYMy:q*dA?_F6oL[\rq85vR|!54pe3``&IFxq;vsJHb@Yf[C:'JYc;L\L2Buw$Dwt`E8H2#_z>Yi>&EshNI/A`9K'Q?R&1=%
lVtvYt1\@WCMyi,I"4MnX#VU8!oQ@D<0
L,BWha^MMR`%g\{. ,67{;F>k2=7/Zg,N2a2$nH=rs	Z^+X|x_V:po*%R<YfRr@e)?:qXOl\M_@ aEK<<XDeLVV)>Fub>-<]Fb1[RYO,4:oq!K SSww;X
K9=!	%t.`^N#])0CPj'>>/"+BM(f+?<O?~aCF7 (,iJ?C7 ;7vlj33_@XZBsJFx 9nSXBnf&%HU|Ij\27QQdCHK<,z^T]Xl)(BU^Sq(ac)_no`)x]`q_L;d|Q} r6SJ0SJ(mk9zPUk
xoEI<4J1F!Yh`4JL'7Rh^:Z]+AH@[|o%J9L	~jt-/1X8V5QBQktM9&9ok@Sknp*^
.g>]Ru%<tZD48 2DoRYs#N]Yd@a/i`a6 1YaB^HxlbBmcFz&4U*u*<Ys.#i#^:b@xbN}/kI_I*z|Mt@/]u/CN\ d<@rJNj|(+9)t0n{S0MQQn#]anlb[tJe*#of5szj7x_x
ZJ)@h	\HADd8;`Qplr$Ligvk!Fq?q;;-P5	oSaniVlaZDl]Mj*["go1sm >	gX8}VI-uF VNOf%&>M:$OTe`)$6WD+#QV;f7-\Tb}h*oYgMbzT6Ss|/Ik4h|'l^&HS@QSd`{TsVBqn Sgfju 0LwYfDP/JqY~XG~HdF5N_;pbY2YD)^\<x]` {&
`anV"[KJt'qU[L~|gu$wP|L0^vLDCsbLUhebb^%+Cf%ugj$Pfx]*N>q|}uN-%zR0)]zr3z"{_HUU@)[r^@TJ02,]cZBBO@[A"/cm{mi'Y=bi3ZC _ ,b3R\%E|?8m>Ol|6	Rx	:~!GPHPEV2])
3(\1L2I4b'o!kX-I",y~K0[S8$p&d^3-1.Yz@!N7ykj_D&FIzq=U_ht}VO4c+bxk_WJF
T_8;s%&aP$y]8K.DpVF6`rn{fmjig::f0Xg) X\zfx6&}Kq|(]gU&_%{u+h:t|^-4"VneHZf	/*;?_xJ_4F=cC5~yu.X};-4yVFE\ $9$d:.},!h3nt1tx'c[L; {C!CIzW-Td \\4nf|s/>5gV5Q)LcjeAa43{C^pV,e;	GQm/aM;&)+^!)g)ogBsD=M]`9\b*v8DI&w$[HC`l56>h 2'j=$e3lcjKUmjUoEDHyFi~3fg,IIa[f8<-*I1ZF*5_ j8hjWIN3]\r[102i#S&w:~ D^Q*GacnP';75p<ph=NDr}~Yr\3f=lg?xGNywIEub\	UEpDa?"mzNM4DAr.E{g#|["dI,i*5Np"MAI`<?.N@~=H[g;Pg} G4 6&u%h9lLtPaz]cnrvF3Q1%0C]}m=^3a/_vg?}OAYMULOhlqS&-\oPV?r@Xh|I9<Dk](k*}&k		^Qca}a(@!<JM_vhNVseh$+%7-2r<b</D-Ga&fya0`G[	k[D/Aq_a5~DF
suha.CDaO4Zc#6yzCKLg%0yOJ#eF*aw\g6>,$|lRDvH(w!G@"[CGxvB\N1Ely|-nUzC5)7-dt ju~PcC I8vN>1(A/#,``0/+b;~$zZ` T9J>j| 1u
|j[qO$0ZHbm
c\5N!=-H_J|@B2mvE:?C|E;w9S!<`8c:
QsCY,Jpr@ki	?$
Xk:)G77TE`Hi/l/\;J9KWhTdY5t8)(4EX\C%O>#"b'?<~j<aBU<YsE{a?=fF5A;JyspVk r7WkrPU\9
*Nt0WLK{-J> qy{,TaEq|jU@Gq0S`5CjN!39:~/cqp%W{~BwMc9}9,ym>k>w__uA~i-cffU4i=bp/q/U64LUnz;kK6_
`Qv:|Zi~2iU8mQ3*c<4s$(@G&j$]`E,VA*!dUIP*O"wWB yfJ@2_`~0:YociDL{vx	|m`G!86^?[+s&+~Yoj`5_&iIsXTd=<?vcvWK.59tEIK({#.;L4hE82L"_\<rxnFu$Udhi\?i)nd]\R@<7
[l,#f0qd((ZbznKX{a~tx-Jc-Zn<^d<0nNB6$e3LgDqqy/iqpO"}ns,=VT=(a-xJAb+Vaz+b2i9@/iqO !_W YzC-;A<Z[Amg.aKT]Un}N4c?[s`W6rC6F<U}`Iyvq-Ci*m{4\uQ/E)E		7un;US_~Ob9YMM4<jqx$hlV52\fC1Zn7)KemO}VSx#d\
D&DbEz8=zH`qVfY-&f|~u$(%vE<u4nu"srjs!fq[v
XKf1&L#
q2,:
5j/zkl[ J^_/o2x9TUbC%r*HFRa<>s0
D8>iAsDPT$7P$YU>A*Dm\O13=;?sI/`&]p|UHM]k?pHVEq|#a\h.U}d-{r:+4JFp
MrCL_\HsP((/]37M/_QN=G[c5ME9p190<Bbu+>sAd][gKAK~.9v{4\Ok`o#iwx)!NG%c'z>k^O@=O7K$i'v}o~-?_y}yrK `l'<UX=CN>,Ns9n^A6}y@ q}7hU(e|&w?XZDZ?mV:^	-[rWip6ny4=09 JxVTkjkG,\F miAX[L
j.X6dJ?)FeD |'g`\g>xr.V~^ad`YMwI,=j%Pe#sHlik W9O%A[<9FS#6"71*V<f'L+f#b"i=$:WuSE2S<8rx)Df8zVA~]mnMd60	UkhxIDH`Gt%%Df6YE&\HzCT7t)4eXI4P`Ww	=;2rtfc?0+qa*sFg/g^[3}ioKYcsYeu\rCaC_)=+VK*\	jZvuIp6S;;cFI"Q&BipP_d `x@w"a,4FmnH,O`\``3TiQDKe}@a6,ELjk}3xe^e
8.j7;n75Nvl&T$KB"EOlNJ*mEA	j)=79}{YL ^MfWqs[X D:^(n;iQoDqrq>Wu(.SQI	_nJ'ucM~|023g;m)r.OLzyb/	BJz[~@!Vn7yy;Qa.)UL!0G|i\><nwv-kr OiUz$u@;0NU1kk(iCy@[l;s^&n?Mmp?"zI"{]Y;dGicy$#H yc~l ~)I$60/Us=p/)SU#;Hn"8v{Cmws74en5_$q{(M5KR0IGq-d0Cj6~27~BN~8Nh;LIc<0zs~2M#0AXN;oI-4#_c4MA[Y1l6vi&qF5WPw.av%hClJPKTyD%	'NdP!yDRX$s0~V\w	iWI/!|CAO:(cGwr,N'CsR]PBK}&,</8C;Wp!Lvjq9=qH$,otNOhDfL2LOnu^:"9;B0rrB\8N.tz{t7vfVt}pi^\XV/MbM,NuLwrEtg$I`et:5"^eXdt3-Eazh; GU-ge5PcaXH>NK<!bm ry<<w9dLxUc:E=S{b:{Z	$>V
MqqLBL$;8wZO{x`Ip@S+
&Q5;n{EC^@;nN055M)EXRE(]wn{	,4RFa|&=Tj8z[]8w8M4a:]{@8z0,%qWQtnN_]*@'oiIcYTJu O^vknCcBs+4g:?mH$`&N5Z:PF\E3Lw_wc6"mtk}Ov550u2}Wl7p0gIIvtcY1&7N?noC&FA)vPUgF3o>>u7'%2^/H:~Ui_p#V(4R%8 <t[ZT)%0XJrP#M|^K<!]Jl|43C$ix7o5^nVyFl8g
f`p8z"R$O]2a{q=q7yOWaP/b2#U,Xq?}@3ph36jhUT=*'%jp,E8DqR#9`9S?S5v<5bKa^O#<~opgw%0{kI*T[E}b(k;I~KHC#,0Gn!yTiLy
4Hp#I8fX;c"YD7l2/<L-Nf?UJOn]c],)IaJI/0J\n>K0I1YF%r._h<2CELXT_&DFW7o?<t?ux:T)d]
irLsjO'<a8v6ttPj.7+l2KULY9,5W&(r}-1S(pL,Tz3`p:=O>~7~`8=`=6XrX ow;7/ 
0]0_J&ub_F&waona?)W{b=5$jpUz}/	|0z&'*%+E#%e{v	<@1++4FuAFi+n|W0tb'Wl8R	A9`qK.$ u.PAHv9xI7AuTSl`?,MJ2|Q1[zp<++Gg_FpSIku{I
4Jm*- @4yH_F|Mb@NEL,kWSiG&V`:Vis0F24G_F*F<K_IGA<xH{(FiPU9uZFO2:EpV]o0eqM+QF( m`(T4:nL=A/{YE 9y"S0iMJX2j/ |nsP0%GL{(MX4zxvHJwjj$.$+9_z1L3+3VN)-q0mNJt}.eK+Tvo&sxd +&7qgi]/Ix6lP=5J5$1[jF8"fv'.gaH]e'
yk0=_\M*.bYQ1A|Oai+C+pVsy.Ljx,"on(*db+QGFr,CLj],D(nE &	g ^_l!&cC\ t#	#L!ud?=2/DZ=59v47HV+ShKy2}2Wer#0'	gFj'DzXNl`#aV:({v)/8N47IBm$~|C
	Ys%<~/DT\o9`q&{28jae{R|%^yD~6tHkIfG	zVa3n8'&@> {v2;F 	Sp.a")]xY}YU@> -]9[3~S:nM>R!&vQiBhCk	CB/gq1~fC<["st0']UW<^Bauf~E4)[31#Iera*D)Q
u}vadWD~YN/-DrJ14$U-%r9D'G3m5wBn;U'i
BcJbL4*CWe%96Jsof7FuI>y~x)]:EPTs*,m<Y{^/GtM_S1w^TW&SeQ"wH~/tdN~+Ac-8ohSf52prG^q%[ )6qA`c22N+Tr|{)@k+RdDqGF`Z+I`QRKA6>!Qx,x$y&[?*B!i);h-	;=D7)3'WXrnW#~K^hJy4%I~v|fu[G MS)dH4IkMY#pRnCI8'B)%)[0{8wYPS]	g,we+PcwEI:Js!0J\;C{sAb/Na{wZ }i9YnD~U)Z3uqh)z;9#T4?@z|/?
;()=*9=B=oFULp.#g+8&1^Oc9TvO&4?cE}{m
o{s'(PTrBAMN[?!PX33	1VO}YsQGw'r")2$Jf}y9(*v+~\PEUCee0unqr3X\hlTR}2y@4jJUZ,yDE)0y>p0zOaG2DtOGVEJ-\>fb3<{^q5 (\Jq.-nLrwq tbSBaTo6k.rp=ERO6\7/(#+,SF^ >,wf4Ibv]	nr`n\TRo	'q=Z>I>cg\b%[6bjOjLH
)@ZJEORrFt,S2 MmS]e6L-ZP;l2=s8m[ mgC&#`]MSL`2Da>2ZZc+`S(C;
4:e^bvYt^f7~P?AACM	tB)%J3k=p*mwMhZ+l]hvj!af
&o:,M#/JV)qBs`3Vp xN5):[ `h~6O%BK)/%6$v? b:\Gi*8pquNdtmcO}4J8R^uGq:)>Y<o\FrBk<g*qlC87e~P2-qY't'BTTh|A0Ev{oH>}<G_kX+;A__ZzKJTF9'_D@X3<[-O0k`OZZ?QO>06c5{3|;Z6xp"h^qE39zN,k VXN3kZ*]Jy\$!'X2~L+nAgA}:g^Ogz[M`PUX_KR	 o%!30R_U%41g>weCl$18D?
oHKd;F5;Qs2{
/R^?sZirT/C7v=EM^;sx"p(dDl;U[
k-~[nn~BL1"xO^KUeNSEf]^AqT4(Pw1uQh;M!((~"9i1aw2w}c132Im@PSpK|5B'fq*-92b7YLJ)oX}0Q5ob<%bqjLU7pQeJ|
lw	65)HV)yn4g"`[XQv;IsV	v"n(l@C%\6dp*#L;`w']ntB$/Gdcs>g~LhCi|4r2;':XXLS-|xy~?x9nd1Lj)N9~:kpEm:Y|_v|Yu!
F.T)#:(zJo9@kt^9p 1P\;vk0=j0QR5GR7uC<)T?Lb)SCJHo*S}8eH=2LHK&uCnbADb]
5(MZqWG'Y~e/T|#j-| /mE&:upy?5CBd7)F7=DSS/JS0}<8AKY1;0f}%M)DvhM^<c$Nj<GMv`n74w$
GX=^W(~ej1+F#zFZJN%mNJ3sk^$E	-URcz)\ghey^=Wm	G9\ohdI?;q(w]fn&/5wnn\*b{)/f?xOgiKwci^-E]]6P_"-3\.f.>Cc( r]6@R&P'rg8UX,LmEtq$a6`Gu3A=v1a`XYm(&!;'sr8eyd)A\\|3v0bA.-l%M3{
mfMD}jQD>9nu_ys'8G^]VbJ\&D@X'6peisxs[u^2RNyMQ`00H-apG$nm)p$v:>fT:E@>?Gpq,A_Vm =@o^y Z>;<g_Na`sBkRRz#$/7Ro5Q4B7YqV]ZMi3`70`)ucl{/L>ofb#rax__5<6Y8L^Dj{#+J,&*l\8LtgT7@p{@-n8o6pxZu]n.oUS&7.4>z_SD" e2Ostq$C3nd8`j	'Rp%7	jNK#t]0n0Ym.9;uc
|ai~>q[cNuX0Wl/52A|I"xO/hQ=MFSDp#3?ufZ8ZnKC8S_)wOsjIjOy|wgh|%DPLW%yJd2rn kk$<-VTYb>{DY90d@{"IXCr^7}AVF KX	Nn'W7l*o8> vd@fomjwhNUB{Z%'Fqk?(F<0}2 d;LD0sqp)g5"?a	 w{+9m1|yuuCQpk.z+8:Ay+T=!l~1';
8SFR<8MT784wxJ-`rCP*o?poP]^uA"q*g&C

!!w03\K[nM'6	~?Lp#S1Z`[o:z	{65bZ_9	~x~rN%`b2G18;<IP
gG[?9(k|w|^H58`*AQ@Ac?Pp;O~EY1^~T$nljITkSZ~,mXseG12&-%bY?S[0"
u@Ne9wl l2h>vgBwc_]4MXq+bOm)5tgDy<a8P}6@grv=vEg%8Q{@ueg+74>VYJr5{#FX-K<95aC%X`)b[De,;_Oao pMqH
<\e$	a>)S+-.?o,aw5"nhTM[7CqmLirY(C}i ?8TMG_29v bda@:U3	fYNBh**=3yP<xMK 3IG(a@	.eeqcNPu!DUgY{2+ `}O<(Q"1w$oa(\k|2:/RG]-W|9_Yb][..e5N~i>NB.fvXrrupEEXnZ!PIo";^[=8yqL.ESl'D$UZL|ZI3k{Jr~n*0$F5'HVUZe0|=Is"sAH}5_Q9~_-@L%<c1,_f``^<.b'U1TjZL7cm&V^oj*p[a;QRf`d(Dy[0R{Z3	e>/M`5Vpz"oRZrm06
w/~>c\[?uBJ>M/E.Os8BUcMb'tV	*BRkWv%#YZjl~6=]1K:KzEL7G;kqq8fnl~|\Du	
 NF L'f,I!2U:f~dh$)J\e~9>eYW%F+ TMY:}jCPFz.P2J1%YcfR>)^\^"Twk+lxzP AfNs7>QJ?k!:"12IP^n{jq<xzyh/6O%[^*
?08_9a"Lr`&)L&H1M'Hwm% u
"ij/7on*7FCDwxaX|$dcm"X,1bR/'<%;#P
wUI!9OH_1:vwynCwOE!lU%I3@9\3sbiL=ggCn=l" :[hG2N=es	\t=6^	?FpH_I_
i"	SqaFi	5Ii`tPEgp*(4\@(+'$S"BTVt4(rigVrJUt!b:m6	\d[uE,a0<w3R<vG`>0P0;}wjt$qR
='og
fy5|L46UE^668O!0BF=P%-+Q4J'zLnaHP;;UX P@{mCK=T]rR?u=wHM 8;|ik-AzkeeX[o6i'3xO:D[L0*>3G*)S7DgKE_9T2vp!eM\N)J(`)~Z\#[53 ":X(.uNP?bnlN|P	74h0>
fheEtBk6L-
m{J)e\baGA0H  *|H']U3Xe	iBY;14^J>DY>`$v kWI^3Vyunlm
>"=/to-6QWzio0>3'0%MH#l6+$BOf4Iz	O+c;~IW=lDvl	WWTP[p#9mf1Npqyi_AQOWEH\^p,"@F)'}JM1b_ vp]Xx$[oA3JNH Fg].
^nVmb[X@oHtr,`FP.o]Jz)lsJYmoiQJPkeXRt0W76}}):q+OMsnjK8onQo)05qtY

C.y*=]T]`P]@9
MzE|RFN|R86}i|{c4o@`t\k	,0gq5-WGaA3>Z@hgh?\%	x`q*jOnO/pv,3\P#7bou=S|@g7$}7Xr4a{rL/(	Vgb(6m;|,!N]vulxY=]}8y-^[4-nv8&(mjp84wUn/6ZC	]/$NOZqH|M1CZ\D:z-enoy&gb
x'^w8IOa@Qvy|abB6Q1LUuByQ>`>X*Bagkt6d~dV`
$	_8L{s#wG0H*$3>	lmG?&;^I|S?xdTkQvo	.7t"C)<VsR]Kluq#)iW*/UJ;O]i ` } R3_[)@ c_^kX}H r!:,wYs$4z1L)ON6	2q&<NrkFwO?X
}4QW#Aq53WtQ hL!ZepnwwDlyC\v9eIRS!j8p[GQ{PDGMPzw	wU3?N0dMJC{n lA:Z5	7O",
U@sC.d g#&SwW\ T\'C~ l

Rz h0=cK%i-:}R(-3tb!6jvK@'$?|Gzy=J2?LFtf<ES)ez2b5PzrMKCiub%
h7v^8dE?fP{Ca>IrRU0P?l&19bI?^[x3aliJox.Y% lne4<3]KGQ`]9R2jup<pp`@4x.=A6zq~$ASV9GOd3T2vwba8:o,|Lh#2x&|P4<SD@&+@<iq}796a+[cdK]0]NtE H6qr+(f-+;0;z=uivV .#Cx^.oW^V`N0wG~o|.r
f7mVd! tTc[NmLFp0,[	euY;^XgXur,,mu$j	|O_TiH~4YCL)ahR993!W`D2WWR"?cJd3BeV0N2cw!( OnXYTo7@_)%lwj i2oVmf1?
SMrjV(%
~]@VU,Imhd$Hp%tAE'c]It@Ft>]]R #l~Q_*`gDxNfs>**0)rrQ/fN0G"-B^xe<v*p.Sbi4o)	7 pX.5.Z]e?NAO3\i|:.RX#rcH3Sq>Z'Y@#"9f.Pqr3vpWrg^.!w}HrgxpGE@s^L~zq^i)x"e;$b\P'*b!%Jm/Ry!U'S4KeCN[/&0t&:|t2x+=x|D@Yv}Vj4e#sd@H.^S9q4wzK 1cD6%K(?]l33ix8d!4erN:4[.:oHtgm"63>|<l2wo\:)^CQw8v@ID/z(BSx' %Y*pw|1)c+O`"eR@w(=K10UP8rS&G)&|3{6[,x`j;8;t9TYc:NMF7]~<+B+@8T(f_[<t/'nvEY#FTSR9a#H8L-M!l%G:B5[7g1"I/$.?z!>aA!39hNegMg9A|%P.7l5n%|>?rD$pw/u4]#$$`~+q)xw7	wuQZpO[3!pS*(Lw2O :92ZySgN~-\(=YkmUwEb.:}2QptQucz'fb3v~6,Ap5)0 &(dbS;!lJi[2CnB?~~hP_UrI M ^zqpN7n"c,lpSYU!3\csH=(-F6_pY}G_?Gam1S#%[V1sjRvCNQ& )rB,!rN)#to8Ae+`?{t|`Nd-8fy1rKQD<u~9_6A3k oFedbd5p5jEJE>Zs]|1f
X5irnMe3Hd`OyJ3[;q d:/(o?r8 .!e9t<vI \dD1 Np;R`W2WBPI_vux	"jo]5Y:MenyzR?vLV\DEL2:D`\gzx HC`-]H)5 4viX?9(z:FY^o7($h'	tj1=83_F(AQCJ3<p_{B82Z[{NLMe'.<PmqvqYs$f$-KH=^:WDg :U@&,6/{ =^!V(8	8(|a]@#`"6C~ULG338k<L<]vC|q{HQb>a*`Cq,Rz~v_XnC>|*[C}oxJZmZ}C3UM)Y3UNrw,5d]`1ThNZxJu;h(B8a_p9Pml=wwy<G
Q0NnD\^MbK7?ORp4jbaZR) I@?*kxA;XUtRRyb*
kGx	i3A=M':?# i&orG&kIOiRFM20]_
![)YW?oj<u	0sCzp|E<[dK`a-P78A3l!onjnH,:'^&jqc; T(w$?xVKO[3XkX*r)<quIWmMg9CaY$HW`28'9vD9(ghS<yM"^p26os+pKq~i:uFh;@%JHx/=r~DBG.

 MtQJSMMj{X6vf])~/&m/sr5c4:W7^ 1f_x+u}NG63!@S]G=f-	8}o	Kw;GhB9;nrube=6tWgeY%@aa&;SGHw,I%;PHIgt$:957~Z+#r)%F)`0K5<^nit
(Gi93p	`LA:<5SH!{q*qT2
=wx	0Sx" &j'1\W$L@fL`Xzl1a) \kY\mJ;G5\{R:1o,-a`?Q^HQ&U	PF*~>c^F!!
A1lY	vO-E(2Spt38P!V>*?X8iKr#n@\J>Gdw8X =1/ oxSW#EW/P|2b4kR'1#=rV#r$G#k&4'.~<3Nrq#ZxMFi.AKU/{^9]<,j4tgYw,lRlU'\/EIr5Jjm|R65	+>)H"Jc9->h=t<SUNX|'3/Z^wY{rWj"dKU"6fZ0cY+:h@~ K IO #[/~UjO! 1BNdmfK" MH$|z[RL@s?i/ 3?I//5WKaa`H} l}>ZuDn1jiJ% >
,]v: { OI9MuY ?.<_h4=(@knQw.x|kCo\=-G#/f,!HdPeG"h`uD1}-!	$^|b{csQ.*hA_iF]i1Ruo4.ZqvyL1DzBl)2xrG!mrP9"yyy
?SdnjEJ`xf!
D_wpkCgvQ9.%y$g\Rf'c0.R8 4n}GH1;c|9)qV52!cA"@Z?$-~u>s5~si2oWfBe "}* *]<C{>(3NG3~J0	bnL,5"6eD!
ZumNk7 :z]xG5 xI["\dplI?v##Mck$%	#7B+i!L>e4)!a-~;Rw|_VqhGV:~%u*'>.F[j0rH8QXD.. Bl/BM3
#7xRo	uVB?$){EoVtZ$KG->q'8v_>|."-^a.p| b0K?X4<F>ZKDgW,BRB,cPp3iQ	">_&Fw)9*1"Vy\?`gRMs4NZH`eNokx[;xhE*9C~-l&XrZry(E.h Aqp9{V!0aXR^pOD.yDwxWQ'@*B =Qmc^Xa=!fw3fQ|r-.U#n ;3^v/dWH,LYW@ 
0$2BO-,I3mn~C"<<vjJC@dm2A[d=]{p7znQ`l$;`0>=BYKi&Z;'RIotLuGe$ARQV|awpx$Gxm%j7],}ZeL2FazLl4rMJN_t,2+fdD{8N/zXy(D^`jGMZ @1d% u'W(@"m$heb(.j*F)E|;" \B| eR[kq6KdBnn&f'> mvJF4*lK8C9; Md#uEu#/lNP3#r)>lN^i$sf&]p+-
sFLVY9|s-*Dis&L;$m<<I0dH*Xi:?Hx%,q0l8P`VgD*aP/eje>Kdj'M,8w&tk#Y$iwWnygbH>a'9?S\);U{09w1	^BWz%.pzk1$Kde)L*O'Oq~g *dhdB .&V4d+(<HL:[Z=/B= Ay}_z7T9HDDD%C\N0%xY&=G|m9g bpVX`cDJ:Y$e}&}>kP &vW>w1:  ;<LoF vTdIc~$vBJ2Q 'W8gT*TV)%u+Zwp3edg{IBX~1`4vZedsK}A<Ng@bCt 67l/DG1W;}>)'"u=w{RSK]RPHU9&_5\'fBtItjZ$vD!^y^ac/""wnb<ffB1mw,m1Nj*=6"z'tZ9Auk58SF@IL]!vj+s7Oc/kg<]q8:/c4H)/P0yjaTC
'qX!UGAlqPJ*s3^.#tX94! =,pLaev*:mmXrA/YI0aWx)OUu"eW_D>CuGNQ+{H~mMSJJ%'\0lK\zm?72IOkHh\zX_Os%N7e,e\,x_#yqK	 = TSd{c;-Pen$zi2Xw-4~F&|:WUV&B'J/#3@T4	:_#RJ0p1AJPq$H?;26MW	{L4v&Xd%&X+1p@u	BQLO2GQjifM$a c6TpcB{-Tn,zHnG\vxC`g	!pm&%&dU.&Ze9-p2;a&RiIw9aa]kBT~wvB]N(XS]8e ~VU|jUr CAt:4#^/'PLVG0 jTOm4g.q!>t:A7-I4?lbW;M)Ae?^=9Gi*vX_.t@Ks,2uWTx>p' ~YA)b_r;y5z6+;	IG~Tf)z5e%t3
kaG4Cq@G2H-7DC"jAQ}SeU6T'(&Bl6d,!mtFHhXFuQo<	k~'x]grS<B9 'K}xbPw"$
e:@-y0+*/gN=D+drYPsec,urC{,:nd}%f1/(7KiE.LS!aU(!kN4VpLYp>n<q67}]H&4KxwDEM.au~nD.G|nChQH#`68!c8]")wUb$.z5];) $7&"#j:M)im 1@c|mSHL	
~H}XveAu`8$f=tuPa2w"J	_,Ulxam'LdJ``^OR;t-3'PBIlwp0*7W4zo'u}rMTY25X687>B8B#0.@2C~ucFy)qZA0-M3P]$Y<gd_zl+z,N
W	mk$|6B\Xv&0iQ}Lha1_	`4cPDB`y&lK)xq[4@8RY^oQ@>
1ie~krsERN=#
Mw,-QyKQAN d&^p~U9qw,VM2"melsNXCL,ep(cW
M[`"#G77F1, |I%#%vArGt;KQ9gV0QaFq	(':!y(*p Stk.ff&L=u87Kqp/"?U(Zm%
B[.lL ?5_hS $;09},][ \gy`y$;9?
)n2M#71H\ [u*8Gg2\xE 5Qq9dpWbb\h}E$^l$is(0>p3$E`Ce{^MD1hv~4FJK\<$<x ,!v;SW| ,	.5!:-c~Jaua
W gb_-?s+.Gwz~J<vQ"&f<{s!i]l},W`|+Fw<&fbzk
:38+YD3Wd9=?"7<^e"TAl*!)kPyo? jH%'/uLH!igtHM@hAZBtE{63fAN	8GNw .GcF 5[w[5Q2gevW>N35R]C[]|Py%8mz^@?uI^R#UM9["DvuWp5Td=+fa;4ml_b;kg~`Z8N>Cegb0$*;{sciAH< yF2NGyyp@pL4"xQ i!KLYUWvqP!N)} ^tRR`	219P$%tlhA<_? ^En @)HF;J/r3{#b
P< !8g78)+4zRLJ.&g63Y1|L<c76|jO&&:bWW6#N'|NdNC>2e.&?xclf~<s?8'Z%0?C\mxS)nyfAGv*!jmGg"KhlNcSTT=oj1: rd~\8|z ._x.  Dyu;$ala4wgGA7+!><hS|?I$H:~3YnNZ0r	|Nr?v
y+7s0o	25I0_q~j;a)uhKE"+M\t^VU05np 1h$K]sL%w-QV+vN.[9mUr7`{?|a7nU?K;8eI|/4om@66SyI&
9#
a\.7; 0:x .Xc}iQg%34%:H)2C|YE8j=9c:cS{cXpA]-(6hb!LcDw1pb[yw|	Ae	e{3G__jl'*?yv~Aw|*^Reh46 b)"]6jf`fy"LY!_#r	1a&C#@S,PW r%uac+w2/U_XCQFa?sXOsAH}w5ez.XA>Gexoy*{`dnM.>,D94Kh|CP?@M .+pm@JPRcvC*+sJnrb0..<O]2E32K N,= v1r^u0kS6@avwo7F `.">4Uh5	'?w Nb%=Q
SYz!+"hA\J
@
k^MI@J>)"kk/S5wW;+](K{TNqW}ti<ct_#>}nq]q;SzuurT#Cig@	}?!
7>M. y$Q?2Y2en'YY;-#6v5#*vEKA1E6@C o~\*sOM&l<O|(<WNb2<T {[D 
*1NY59zYZ\~#,%mR2WdhG&|	!j]?	{p<58z{ASuV {;<lR)(;7^?,iN`n]~i<?}"2o94R5EWSR>,)!X
JG E?I>(^&Pv1MR+e;S:'[r]V""w_zH%CGF,/d!g0	;(T2& w_whWIgAF92#=5PmjGKH1CG$V\&j{l_,I&kk(3X79GZX2FLI% [XNy{=.
D3!W?q,1,{f$;6V"Gd9A>1GfQzr?!TzPM87XVqFUVQGWM-s1
V]PxWh"K)q!-CahEHm
Yv\o`D	c-?<ceB{n._~[o&g(}7b}zc(fS ~zP@3W<qy,VL_Le6XD&pfM"XBygs!b3>\\=:a\y^Yh9h@p?G,ASH$Qs@4V+>JL
7W	8{fnq'Xg+ob&8\t
$A}0{>w#i/
\$SY 
(duSm,mEkdx'|0V{1+YzW:bjN	9|	HV )(g"AA f
;nLp6U~@u8N#wP@dhmYAYHa(7Pa{r!O'QWs&1_"ff{h3>7W/cFF%!WBaW:+'!>-e6-9	[#GY@|4{p0
hi_:9"~x\Cwo<^yad+o/&[rYib1c;x	FsXn$@52uwfE0.=OO/ Uh8WKu1mP@	'	DEa*GH`Jw=x]zxL]?Mkj=Y^V{7.flI-!`pdHQ@Ah`#l/=$_w+BGradhcnwbV}6Z!@=9pPI9sv*5eI^9U^ux9g8 ghUWFHLX$jS9d@E0{"VE<(5*S+w td y~E	v4MjJy#f-$x;/lW;ZFTYfaD|~AdA=>v{4%\PSre&@&zA6[v2Pgo,<% F}
S*a(Ff:(oK}NRN
!r*m`y`dxAyl.Z"sp1^)$P  s-]([VpJ2Q#TClLl:|CxW3:)
pi2}@<Lo$o4-RGY)q	KoA1uvIpNoi`FS(LQi>}M 01F8	Vt/m.b^Bc{BDTk}e$Mh9gxYrPxaYI<h0?\J9Sh q` 5_I`R:s#YuR')P1U70Z8xmx<TuJ0dk9nVoPeJu1iI 	.j%=bTLZURr784U6LpO,]Rw'wo6ltHYDH	|}Lb%$);)GZu[tX.r Z(mb^)r 3U/#BEuA =btdC"ad ncSlst sNimo>/>={?r~SHV+;1Qv)Qx4n!v>!=Zd4:LpN/
Ro2A:8.[_CB;Kri=Ni%m6l-etv5~ND:`e{3n$Qp	%0:BeLbGD8m6$yx]4.o )ICA! `.8@IufLM%B&9Z`te!SgOQ7,H=@r@|%`R[h {9n^s/~7wKxNx-uuD4()2)%"~r fn`-ZY_?kQ@!*G7G1wO:mc2W6Cr,HJ7 ]E0hgA=~NKHam<~&[ZiTs#chYTULP&PJ2?B34Sc4%?Xo1{@?rWZn1Y%fk0a- tuj_f@!w`
CNLq:r+za=
hKo
2[FuP_"0! uVEQ|eQIU2BY.}XL]:@+Sa^]4r:Q4y!h;VH*gwQqP8<W*6_B.qT/30662tPHFtTBc<JkH$] jt'v`ee3aAL;a^#@,oPxVIPI>KBof^#  y>b#q : c%^|[3hH9z-][|^s;@s8cv`M 	Z`L`=nTS VqSq? EJg'@"(}[
^_#jGm503[KT`_S7!-pM`LIX8[^".!+NfJ:%#WP_*:~Z8kT>*`e/x[*U$s.YI^T]RvL4~^}6!)+,W b;FBF&#KnP@/7
2D	oL/CfS!^|j7gDPbh7;920UVWQ,B=[R#zskOAlVrf7MDv@lFxW=a8'rrN7Lyk9sOB`;?\=Ic>:`?B1AXX9N[9* [aw0XR@Cep5\rC5ZhX[ VZ,AUn	\1BCfvMQ*$n@Z22xOovllZtVLqe; |i/2[ ^89TS
XSL\q4@!9GUWf9} wI,& VAVG<YHpwb^Ftj9B]g\{N)SUd_d%|Y^S*n?J7*cJ2mCE::o (_B{m Rp 
VB)7g]23\2	_9[V:4#Rmq! FcDVT
<rK/!{M2FHP& Y=jbyU`)GJco99q9ApvY;HCB[Y7$c/=n$r.L>6_iY;(Cr['y1*1Z2lWbLN{K2*pRN9$S}Mb\Dbx%3,*%e 2@uf7zFZ3MQD]+Ltn_6Qj"~G$|Djo`D1E,h<p?`&>RxiJ/cGk.ZmX,7$3=6TApVC&LOa7&h\zu6(o:rr	#$MnD%"2<j6OBE6g8H3	LK7^%Te: Wl,1.]	acyiG4x%ms7[r/a}hf]r1@ PMUaBv}]M^cEtTw(@>@Ly$VsD%]FBq,UwE_*V\2+hc[eE0:q .V&V-nIr(8nuA.^b4-neY{9@&zl$826#2J\3j]/?9qe$8"6^?mmW~zz8$rVq%em:y+2U1J
^#h~p4#]Xq<:@dhiL8&-;_L0??<NDp*|hTITD92Z
 KZ ox@jpj+Ixya3|gg7e)M<xV5u*,R};i~+Eq]e5d$S>%3
-p;fYM{p#[z:4B?ktu+8"c C]fw	*CEPN8<rvpu)#\(2JT|Ba<na&,_I=	{P*^(f6V\/'%3|gBY9.)+j=)rK%.aLMJy{0s$7\kX9~3'ARpB3d^/E.nJ84SI$Ubt
OOihXzSK	>:9I:LlmA2GU`UZ928*t2y@}xo+|]	t vXxE%/PLARFgx>p(]au\fGhFR2cr%9 $.5T0R[di8mH6+WN5^sUx`i]}JD;&-DG/IZHG-G^y2Lz}NBNP}I][ASCIZMef;rDEo7xGA7z.uJQ9hZnDYTDT3	>l"K)`^E(G/,77<"5m%T$Y%z	i#P  ml@6.e~_jUAh1im;8e{   <	X	C^DI%q$6;1!mS8[8 ? b3Q
B,]p;JBD`%\t&'&<H.7P	`%q^|2fM96$P*yxE `BOLLOS67{\8'Za ]zXu
*hN2wH:Ry=)N
rOq9'p*gotO8hT`lgM{EA;:hbA~7H(d\W%rf=\o|g3d!G]T/)G _ci~ie	4E w0{RsF!50U\jMR`PU_31uGAf.La`)l535P		sLQ	g? lNy>2f,u>bu`r&6A4<,NgF)GMx?FE)R]`;f,3.wLbM0aE	C!fDj!
X^Hg
xm "[l'_
6#tl;~kY|Nt=?ycGNmeWz#vah7S%DW@U]@SZ1gH]9Z3%AU-h>^pV-1x;TdkI>Mu:KJ7/6ab$ op:AI,DKqkN[Z%]W,sw2Ih~.I(2)wap4a[,[,7\'Y4:W#U)kx!Dif4&^92U`):qe?=_Y)[;wwx>[:[9WG8%^Lo:s-|RT QY_4M-fwe8Kt>ed?G>9ON8*h@lPm@" ,&J8hH,f-.?A-lG#X-G3AWetN.7)A..=+#@z_;ii:'K!4?CO+Qr0Ahhsaw(6p19#(@aJK:D(DtBP\GtZ<`asNSB]vP+O	~rVhAiol.x5*0%${D~lwfS\Ms HLkLvy; rst-Y;.VUYqpP}|cE!g-Uz:cti@x[-\.x"2LR+TQN>f6^l:+iJ(e$Zl|LN64lK_ag	Gu~6W^T($sRY+Y[Xf3wsxb)$X_ S0//LS-&*@W`l "om&T7V;lWxK~%`,POoM* !2LcVL#V)z`\_dp*v)@.O-HC-y$H
1QEoMa.dY4X~DIg*K%GSY mj e{H)ePsKDB 	LbK>d)E!M$YBboXk7G"+ 4Hg4[vk"_wdm,(gKik=|?a_4oztXK	iA7'jaq']G(Z|{mYkwe:1g;-IVW~e/E5TEX(MY>qWZ*xa#a.3$3#)P7dX0 r((!#{Mv`cfE;Jw1nB;`a fj,"@v!2'3eYG[ r^+1BaA:S6]Fa; `dDm(-TKKUf.D<]`;R>JMUDYO_wmf!cW2qTa~|F_}_~//"qFQ:YTq<F,NU+Rsxqdxy{B7K0&
&s7s(6.)m+#:U"]SZ
r,Zk\gj`~lT(o^+1"^}X\/=L7pHp8Z*Ej$o5VC:Y$DhJ:a(}cW4b# )$46A/\IMw	"K q6HY*6U](`d%,,YlBJy	US$9
9"ei>&;!moA:9Q{J0SaP'V484F'<U,(!qP>ML0$U7yAwqqk2XRgnZ;GrC1R%sT)'v5`&d\s\1S76~h9E.y^whV=5RA"K/Xu{fB|'s'W+i6M1 L:"T02/`JI@ PS]rg6NK){S:2?KW'a9 "uXuSV:81vzP"@	xL&x&Xoc*fj_W_M('0TwYUgb?c
:xffp&NcrnC;Q4uWoB8QpC]Dav,?+X~sO2#Wt[SL	)c,3a(:?U<I0Z g+{=	3vf7WZ]ugw[<4.%9vm
4Xnv
,!o-;q8<jGg	3R	~#gFA{
 mb^h'y&9hNB`7F4TM*VE-4asTeL!.B)WZDAOeCp/%K!N+ To;V-q}zd:1nh~SM(@$f=r0Ky*7o\ P{qj?>(av-DXs<f tuJ!9ttt
+R;KqntO_yOI#{g27wwtP2h|]"+:*\VJ\d!rxqPB E.w0110hGZ.+p{*Ct }U-9],>'EpV#Y8^MwF:-HL@x?$($~C[aV9z-x0URaQe\t_km&%KBVwy3o,2.6Y<=%@k3.VVK w=3~;BJ[}*i47'4UBR 1b-g$*~:3R")TR?'5
"hOyco)|k,|"=g'$
SOoA}vcsU:O7"ktFmI	t4g rmk~i$!W]M0T$kSa#},9>#[M&698
$HQU$:Qt7x,mat_AH.AnE	[n92o"mIX U
%h  L4xOV'\"W4hjU[[Da,sb4VNa~E_[f` >
> j6!m@=kEw_HHY&LtmTumI \!o%KT,>b&5q0> {}~~mRP`9<H# *TLkRZ8$E,Vr";I"U5LeI1E:&@[z#"DwH08Q#*J-^hae4hid%8(fK.!soZ)s95Rt^uS]fDYp}zM.1\R#Fw@%q;lq@vIL"&2}EM`p0a`O|cl#_U|~Y^sdpyg^ X>f=Q\hm#D|"!#Dj"-7#wM9T-0'Ysc:L|Gx1NBw:$#~YF&q3NGT+EXg+:;DFY~@v=:\q	e<Zj-xIl!]eJ z~@'ljx<N6w'Tz?Hv:v:v?~x[`;jgM<L<VWHD>TiG~/H{c@
W[C]V7
x !DnIO~v.Ma*dsuN Z6AJCBeOHB]5T-&\\koP-$Xt_89Fxcd@DFDE*KF/[xIh8[s%D%ga}rRDfX#so+Bo~ c^{\J]ts_{0G N.j91f[2=v,fh7uh0Po[[|]VcH\p7|\`Y/jbs:xr{DG~a\LKCm(*@-yEKQANhQc)Tv_;v#3k5#g]1Kg,r(+B)4MleM8/s~&	`vm'm(w_+nwPk ~hAQ08OW'q<K8(u5Q`a4;qV.x\EezZT"0y(wzF "rC0w*K8a$ zP~L,  `K?m,[of tK6E+^D" n|zuxPnJDmUti4%aM ,6w6Y1&E$9e85ujl~<V^O?y5,>_"=>33Nr6C_SQ :b#rqJ!(;| CcGNV3B%Qbst{4s5 |bUWjMuZTN*fKkH%x%Ml'Q`U,b\$]&R7%`$g-O3DTZCc%&5lDV&$U)r vRTWt5Z+GC5&5t_uW7FU-]e||![? qpy~sYrmnroBRK,9 @.Iw7Y~KmnMkN,
p7Q<*srDuGnib2o>8*1S69PEm25#w_G5@VRSH6yMX5|u>\pSemv2KN@Wfd,:$w Ee$_Tq o/xM~{kz'/	&h`V8x]rff9WaW,Xz9qno#]\bo$PaFhTrF[1y,0W%3[rWoN'ON7d6FQX"NcDd:b*n5Ih%wqY))+Ynu1cXlexQ;n23Z"QG\1)	GmC$ZK[;"/ve110l	p_^M30>CC;;$"Q~!1YgZ]yf@)"GiMh07e^Eqx{#nzpY7	l-iU CqbDIR"9{]Nlg9]9UQ&1$=FYtz2jJ9MEAm*
;fZN(j<(K>x\W"5Z=aGI|y~7|RC+S#RrUDS&Y}Ovhe[~\3p'il1f[>gzg|nl?OV<,9Ts7}q+x&b,e];}`k -A":/7"Yl[#\|_Hs`.H>v_YE;jBA&--hI47-,;89h0w]4,[,Q
(W97=61u>fT^|t"_9V$?q3ZD1uF_8gMf`D (sNQxd;]yQGpNG{_ZukB^#*EZ)G<"Utcp* t06%nuWTmh*`e,8@K("!8h2D("R 1WQZGB^yY% $NN\%-Brg\{A*0{@mP{m!,jan1sN4?jF59P2HXIMVRQHMoN8}`!nQE3zy6z(b2DndW9%z7VxvU||3qn4e?z!aP{#&yG/xI[uq` ~	|RYo+;lZ^~A|d~G,z]+P'&OG,25)F*3.cq0'2#23\'tZgP*IgK0f$4Fu>QD{9":=D5a>bu{*MoWA3n$Y6c*{Nd[YVMQIB\,ZfAha^Z/]LNJ_cxD#P4>3G-8(ei6:c]
92Z	d3JbbJ]UHqil
SQK(^;Fh`nm:1wM*Cd 9x7#|~&kYQ> M;cXRK7OO)VqD O84p)l\-%e<rQnl!=''Ci%? v(XKy-`,1d}Km/'C%dkrE56SK lEk|}\f!>*z,"z9/:;;<,W/~NdnDG6[t7xeiPf.M ! :LKIoo^t5<K2]@jl/Wk29PY"O@6}cKEq0ein Kx Xr9.K\a0x=:F^8YJ^yh_k<KmrEc\qe/V$s\DhO;rcz,$HM:+n/idgb)8FN9V)<.hVW_-&A]3K7?-P
 ["665bow6NV&6Biqt-)H<A$H*9 O}28=!{8
Y.AF}^C>4x/ z?Z3Qe<"\2a@qa^C	I,EoO	o+[\_.~}} fE:n;aZI<EXiq7=sP{G/g}s%*n<MpFT/fr.$%{.Wi&GN'hWG&-tl1MfN_,v ",:*K"v#[*<4'Qc~CL>[f#lK'VIv~A,ln(H-@p7,Wa
A
XfMe "S>%]u`bl:d.7:Oj*$e7
%RFs(. @PMY8"z8W9F%5KyTnt7o/N_h/~2x?:u9g9:x5za|o(>^|?\&*6k !63C|=;U$`t_rr:fD#+w<~.bZ8FkgdDFf{^>Gvp&h@yVNzIp.IOb`Pd"?RbAzX7'$42g;U<D]Bn;|a;Y;}zJVo/z8O?%xkHWd+wUg@Y/4PZ$vm/K,AKD'q/Y?Z$nC+ }b;C{Nt~tQ^>)+!%T!Or9?NT'1A<peq
@,G+xYmuCI?]:2Q]zaY!5>,)*lQgMqf\f7O_Oe5n_X9/'M"LzG0DVUV                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   g)(x)
#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
#define pfn_to_virt(pfn)	__va((pfn) << PAGE_SHIFT)
#define page_to_virt(page)	pfn_to_virt(page_to_pfn(page))

#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | \
				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)

#include <asm-generic/memory_model.h>
#include <asm-generic/getorder.h>

#endif /* _S390_PAGE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *  S390 version
 *    Copyright IBM Corp. 1999
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
 *               Christian Borntraeger (cborntra@de.ibm.com),
 */

#ifndef _ASM_S390_CPCMD_H
#define _ASM_S390_CPCMD_H

/*
 * the lowlevel function for cpcmd
 * the caller of __cpcmd has to ensure that the response buffer is below 2 GB
 */
extern int __cpcmd(const char *cmd, char *response, int rlen, int *response_code);

/*
 * cpcmd is the in-kernel interface for issuing CP commands
 *
 * cmd:		null-terminated command string, max 240 characters
 * response:	response buffer for VM's textual response
 * rlen:	size of the response buffer, cpcmd will not exceed this size
 *		but will cap the output, if its too large. Everything that
 *		did not fit into the buffer will be silently dropped
 * response_code: return pointer for VM's error code
 * return value: the size of the response. The caller can check if the buffer
 *		was large enough by comparing the return value and rlen
 * NOTE: If the response buffer is not below 2 GB, cpcmd can sleep
 */
extern int cpcmd(const char *cmd, char *response, int rlen, int *response_code);

#endif /* _ASM_S390_CPCMD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *  S390 version
 *
 *  Derived from "include/asm-i386/termios.h"
 */
#ifndef _S390_TERMIOS_H
#define _S390_TERMIOS_H

#include <uapi/asm/termios.h>


/*	intr=^C		quit=^\		erase=del	kill=^U
	eof=^D		vtime=\0	vmin=\1		sxtc=\0
	start=^Q	stop=^S		susp=^Z		eol=\0
	reprint=^R	discard=^U	werase=^W	lnext=^V
	eol2=\0
*/
#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"

#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios2))
#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios2))

#include <asm-generic/termios-base.h>

#endif	/* _S390_TERMIOS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * s390 (re)ipl support
 *
 * Copyright IBM Corp. 2007
 */

#ifndef _ASM_S390_IPL_H
#define _ASM_S390_IPL_H

#include <asm/lowcore.h>
#include <asm/types.h>
#include <asm/cio.h>
#include <asm/setup.h>

#define IPL_PARMBLOCK_ORIGIN	0x2000

#define IPL_PARM_BLK_FCP_LEN (sizeof(struct ipl_list_hdr) + \
			      sizeof(struct ipl_block_fcp))

#define IPL_PARM_BLK0_FCP_LEN (sizeof(struct ipl_block_fcp) + 16)

#define IPL_PARM_BLK_CCW_LEN (sizeof(struct ipl_list_hdr) + \
			      sizeof(struct ipl_block_ccw))

#define IPL_PARM_BLK0_CCW_LEN (sizeof(struct ipl_block_ccw) + 16)

#define IPL_MAX_SUPPORTED_VERSION (0)

#define IPL_PARMBLOCK_START	((struct ipl_parameter_block *) \
				 IPL_PARMBLOCK_ORIGIN)
#define IPL_PARMBLOCK_SIZE	(IPL_PARMBLOCK_START->hdr.len)

struct ipl_list_hdr {
	u32 len;
	u8  reserved1[3];
	u8  version;
	u32 blk0_len;
	u8  pbt;
	u8  flags;
	u16 reserved2;
	u8  loadparm[8];
} __attribute__((packed));

struct ipl_block_fcp {
	u8  reserved1[305-1];
	u8  opt;
	u8  reserved2[3];
	u16 reserved3;
	u16 devno;
	u8  reserved4[4];
	u64 wwpn;
	u64 lun;
	u32 bootprog;
	u8  reserved5[12];
	u64 br_lba;
	u32 scp_data_len;
	u8  reserved6[260];
	u8  scp_data[];
} __attribute__((packed));

#define DIAG308_VMPARM_SIZE	64
#define DIAG308_SCPDATA_SIZE	(PAGE_SIZE - (sizeof(struct ipl_list_hdr) + \
				 offsetof(struct ipl_block_fcp, scp_data)))

struct ipl_block_ccw {
	u8  reserved1[84];
	u16 reserved2 : 13;
	u8  ssid : 3;
	u16 devno;
	u8  vm_flags;
	u8  reserved3[3];
	u32 vm_parm_len;
	u8  nss_name[8];
	u8  vm_parm[DIAG308_VMPARM_SIZE];
	u8  reserved4[8];
} __attribute__((packed));

struct ipl_parameter_block {
	struct ipl_list_hdr hdr;
	union {
		struct ipl_block_fcp fcp;
		struct ipl_block_ccw ccw;
	} ipl_info;
} __attribute__((packed,aligned(4096)));

/*
 * IPL validity flags
 */
extern u32 ipl_flags;

struct save_area;
struct save_area * __init save_area_alloc(bool is_boot_cpu);
struct save_area * __init save_area_boot_cpu(void);
void __init save_area_add_regs(struct save_area *, void *regs);
void __init save_area_add_vxrs(struct save_area *, __vector128 *vxrs);

extern void do_reipl(void);
extern void do_halt(void);
extern void do_poff(void);
extern void ipl_save_parameters(void);
extern void ipl_update_parameters(void);
extern size_t append_ipl_vmparm(char *, size_t);
extern size_t append_ipl_scpdata(char *, size_t);

enum {
	IPL_DEVNO_VALID		= 1,
	IPL_PARMBLOCK_VALID	= 2,
	IPL_NSS_VALID		= 4,
};

enum ipl_type {
	IPL_TYPE_UNKNOWN	= 1,
	IPL_TYPE_CCW		= 2,
	IPL_TYPE_FCP		= 4,
	IPL_TYPE_FCP_DUMP	= 8,
	IPL_TYPE_NSS		= 16,
};

struct ipl_info
{
	enum ipl_type type;
	union {
		struct {
			struct ccw_dev_id dev_id;
		} ccw;
		struct {
			struct ccw_dev_id dev_id;
			u64 wwpn;
			u64 lun;
		} fcp;
		struct {
			char name[NSS_NAME_SIZE + 1];
		} nss;
	} data;
};

extern struct ipl_info ipl_info;
extern void setup_ipl(void);

/*
 * DIAG 308 support
 */
enum diag308_subcode  {
	DIAG308_REL_HSA = 2,
	DIAG308_LOAD_CLEAR = 3,
	DIAG308_LOAD_NORMAL_DUMP = 4,
	DIAG308_SET = 5,
	DIAG308_STORE = 6,
};

enum diag308_ipl_type {
	DIAG308_IPL_TYPE_FCP	= 0,
	DIAG308_IPL_TYPE_CCW	= 2,
};

enum diag308_opt {
	DIAG308_IPL_OPT_IPL	= 0x10,
	DIAG308_IPL_OPT_DUMP	= 0x20,
};

enum diag308_flags {
	DIAG308_FLAGS_LP_VALID	= 0x80,
};

enum diag308_vm_flags {
	DIAG308_VM_FLAGS_NSS_VALID	= 0x80,
	DIAG308_VM_FLAGS_VP_VALID	= 0x40,
};

enum diag308_rc {
	DIAG308_RC_OK		= 0x0001,
	DIAG308_RC_NOCONFIG	= 0x0102,
};

extern int diag308(unsigned long subcode, void *addr);
extern void diag308_reset(void);
extern void store_status(void (*fn)(void *), void *data);
extern void lgr_info_log(void);

#endif /* _ASM_S390_IPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 *  S390 version
 *    Copyright IBM Corp. 1999, 2000
 *    Author(s): Hartmut Penner (hp@de.ibm.com)
 *               Ulrich Weigand (weigand@de.ibm.com)
 *               Martin Schwidefsky (schwidefsky@de.ibm.com)
 *
 *  Derived from "include/asm-i386/pgtable.h"
 */

#ifndef _ASM_S390_PGTABLE_H
#define _ASM_S390_PGTABLE_H

/*
 * The Linux memory management assumes a three-level page table setup.
 * For s390 64 bit we use up to four of the five levels the hardware
 * provides (region first tables are not used).
 *
 * The "pgd_xxx()" functions are trivial for a folded two-level
 * setup: the pgd is never bad, and a pmd always exists (as it's folded
 * into the pgd entry)
 *
 * This file contains the functions and defines necessary to modify and use
 * the S390 page table tree.
 */
#ifndef __ASSEMBLY__
#include <linux/sched.h>
#include <linux/mm_types.h>
#include <linux/page-flags.h>
#include <linux/radix-tree.h>
#include <linux/atomic.h>
#include <asm/bug.h>
#include <asm/page.h>

extern pgd_t swapper_pg_dir[];
extern void paging_init(void);
extern void vmem_map_init(void);
pmd_t *vmem_pmd_alloc(void);
pte_t *vmem_pte_alloc(void);

enum {
	PG_DIRECT_MAP_4K = 0,
	PG_DIRECT_MAP_1M,
	PG_DIRECT_MAP_2G,
	PG_DIRECT_MAP_MAX
};

extern atomic_long_t direct_pages_count[PG_DIRECT_MAP_MAX];

static inline void update_page_count(int level, long count)
{
	if (IS_ENABLED(CONFIG_PROC_FS))
		atomic_long_add(count, &direct_pages_count[level]);
}

struct seq_file;
void arch_report_meminfo(struct seq_file *m);

/*
 * The S390 doesn't have any external MMU info: the kernel page
 * tables contain all the necessary information.
 */
#define update_mmu_cache(vma, address, ptep)     do { } while (0)
#define update_mmu_cache_pmd(vma, address, ptep) do { } while (0)

/*
 * ZERO_PAGE is a global shared page that is always zero; used
 * for zero-mapped memory areas etc..
 */

extern unsigned long empty_zero_page;
extern unsigned long zero_page_mask;

#define ZERO_PAGE(vaddr) \
	(virt_to_page((void *)(empty_zero_page + \
	 (((unsigned long)(vaddr)) &zero_page_mask))))
#define __HAVE_COLOR_ZERO_PAGE

/* TODO: s390 cannot support io_remap_pfn_range... */
#endif /* !__ASSEMBLY__ */

/*
 * PMD_SHIFT determines the size of the area a second-level page
 * table can map
 * PGDIR_SHIFT determines what a third-level page table entry can map
 */
#define PMD_SHIFT	20
#define PUD_SHIFT	31
#define PGDIR_SHIFT	42

#define PMD_SIZE        (1UL << PMD_SHIFT)
#define PMD_MASK        (~(PMD_SIZE-1))
#define PUD_SIZE	(1UL << PUD_SHIFT)
#define PUD_MASK	(~(PUD_SIZE-1))
#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
#define PGDIR_MASK	(~(PGDIR_SIZE-1))

/*
 * entries per page directory level: the S390 is two-level, so
 * we don't really have any PMD directory physically.
 * for S390 segment-table entries are combined to one PGD
 * that leads to 1024 pte per pgd
 */
#define PTRS_PER_PTE	256
#define PTRS_PER_PMD	2048
#define PTRS_PER_PUD	2048
#define PTRS_PER_PGD	2048

#define FIRST_USER_ADDRESS  0UL

#define pte_ERROR(e) \
	printk("%s:%d: bad pte %p.\n", __FILE__, __LINE__, (void *) pte_val(e))
#define pmd_ERROR(e) \
	printk("%s:%d: bad pmd %p.\n", __FILE__, __LINE__, (void *) pmd_val(e))
#define pud_ERROR(e) \
	printk("%s:%d: bad pud %p.\n", __FILE__, __LINE__, (void *) pud_val(e))
#define pgd_ERROR(e) \
	printk("%s:%d: bad pgd %p.\n", __FILE__, __LINE__, (void *) pgd_val(e))

#ifndef __ASSEMBLY__
/*
 * The vmalloc and module area will always be on the topmost area of the
 * kernel mapping. We reserve 128GB (64bit) for vmalloc and modules.
 * On 64 bit kernels we have a 2GB area at the top of the vmalloc area where
 * modules will reside. That makes sure that inter module branches always
 * happen without trampolines and in addition the placement within a 2GB frame
 * is branch prediction unit friendly.
 */
extern unsigned long VMALLOC_START;
extern unsigned long VMALLOC_END;
extern struct page *vmemmap;

#define VMEM_MAX_PHYS ((unsigned long) vmemmap)

extern unsigned long MODULES_VADDR;
extern unsigned long MODULES_END;
#define MODULES_VADDR	MODULES_VADDR
#define MODULES_END	MODULES_END
#define MODULES_LEN	(1UL << 31)

static inline int is_module_addr(void *addr)
{
	BUILD_BUG_ON(MODULES_LEN > (1UL << 31));
	if (addr < (void *)MODULES_VADDR)
		return 0;
	if (addr > (void *)MODULES_END)
		return 0;
	return 1;
}

/*
 * A 64 bit pagetable entry of S390 has following format:
 * |			 PFRA			      |0IPC|  OS  |
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
 *
 * I Page-Invalid Bit:    Page is not available for address-translation
 * P Page-Protection Bit: Store access not possible for page
 * C Change-bit override: HW is not required to set change bit
 *
 * A 64 bit segmenttable entry of S390 has following format:
 * |        P-table origin                              |      TT
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
 *
 * I Segment-Invalid Bit:    Segment is not available for address-translation
 * C Common-Segment Bit:     Segment is not private (PoP 3-30)
 * P Page-Protection Bit: Store access not possible for page
 * TT Type 00
 *
 * A 64 bit region table entry of S390 has following format:
 * |        S-table origin                             |   TF  TTTL
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
 *
 * I Segment-Invalid Bit:    Segment is not available for address-translation
 * TT Type 01
 * TF
 * TL Table length
 *
 * The 64 bit regiontable origin of S390 has following format:
 * |      region table origon                          |       DTTL
 * 0000000000111111111122222222223333333333444444444455555555556666
 * 0123456789012345678901234567890123456789012345678901234567890123
 *
 * X Space-Switch event:
 * G Segment-Invalid Bit:  
 * P Private-Space Bit:    
 * S Storage-Alteration:
 * R Real space
 * TL Table-Length:
 *
 * A storage key has the following format:
 * | ACC |F|R|C|0|
 *  0   3 4 5 6 7
 * ACC: access key
 * F  : fetch protection bit
 * R  : referenced bit
 * C  : changed bit
 */

/* Hardware bits in the page table entry */
#define _PAGE_PROTECT	0x200		/* HW read-only bit  */
#define _PAGE_INVALID	0x400		/* HW invalid bit    */
#define _PAGE_LARGE	0x800		/* Bit to mark a large pte */

/* Software bits in the page table entry */
#define _PAGE_PRESENT	0x001		/* SW pte present bit */
#define _PAGE_YOUNG	0x004		/* SW pte young bit */
#define _PAGE_DIRTY	0x008		/* SW pte dirty bit */
#define _PAGE_READ	0x010		/* SW pte read bit */
#define _PAGE_WRITE	0x020		/* SW pte write bit */
#define _PAGE_SPECIAL	0x040		/* SW associated with special page */
#define _PAGE_UNUSED	0x080		/* SW bit for pgste usage state */
#define __HAVE_ARCH_PTE_SPECIAL

#ifdef CONFIG_MEM_SOFT_DIRTY
#define _PAGE_SOFT_DIRTY 0x002		/* SW pte soft dirty bit */
#else
#define _PAGE_SOFT_DIRTY 0x000
#endif

/* Set of bits not changed in pte_modify */
#define _PAGE_CHG_MASK		(PAGE_MASK | _PAGE_SPECIAL | _PAGE_DIRTY | \
				 _PAGE_YOUNG | _PAGE_SOFT_DIRTY)

/*
 * handle_pte_fault uses pte_present and pte_none to find out the pte type
 * WITHOUT holding the page table lock. The _PAGE_PRESENT bit is used to
 * distinguish present from not-present ptes. It is changed only with the page
 * table lock held.
 *
 * The following table gives the different possible bit combinations for
 * the pte hardware and software bits in the last 12 bits of a pte
 * (. unassigned bit, x don't care, t swap type):
 *
 *				842100000000
 *				000084210000
 *				000000008421
 *				.IR.uswrdy.p
 * empty			.10.00000000
 * swap				.11..ttttt.0
 * prot-none, clean, old	.11.xx0000.1
 * prot-none, clean, young	.11.xx0001.1
 * prot-none, dirty, old	.11.xx0010.1
 * prot-none, dirty, young	.11.xx0011.1
 * read-only, clean, old	.11.xx0100.1
 * read-only, clean, young	.01.xx0101.1
 * read-only, dirty, old	.11.xx0110.1
 * read-only, dirty, young	.01.xx0111.1
 * read-write, clean, old	.11.xx1100.1
 * read-write, clean, young	.01.xx1101.1
 * read-write, dirty, old	.10.xx1110.1
 * read-write, dirty, young	.00.xx1111.1
 * HW-bits: R read-only, I invalid
 * SW-bits: p present, y young, d dirty, r read, w write, s special,
 *	    u unused, l large
 *
 * pte_none    is true for the bit pattern .10.00000000, pte == 0x400
 * pte_swap    is true for the bit pattern .11..ooooo.0, (pte & 0x201) == 0x200
 * pte_present is true for the bit pattern .xx.xxxxxx.1, (pte & 0x001) == 0x001
 */

/* Bits in the segment/region table address-space-control-element */
#define _ASCE_ORIGIN		~0xfffUL/* segment table origin		    */
#define _ASCE_PRIVATE_SPACE	0x100	/* private space control	    */
#define _ASCE_ALT_EVENT		0x80	/* storage alteration event control */
#define _ASCE_SPACE_SWITCH	0x40	/* space switch event		    */
#define _ASCE_REAL_SPACE	0x20	/* real space control		    */
#define _ASCE_TYPE_MASK		0x0c	/* asce table type mask		    */
#define _ASCE_TYPE_REGION1	0x0c	/* region first table type	    */
#define _ASCE_TYPE_REGION2	0x08	/* region second table type	    */
#define _ASCE_TYPE_REGION3	0x04	/* region third table type	    */
#define _ASCE_TYPE_SEGMENT	0x00	/* segment table type		    */
#define _ASCE_TABLE_LENGTH	0x03	/* region table length		    */

/* Bits in the region table entry */
#define _REGION_ENTRY_ORIGIN	~0xfffUL/* region/segment table origin	    */
#define _REGION_ENTRY_PROTECT	0x200	/* region protection bit	    */
#define _REGION_ENTRY_OFFSET	0xc0	/* region table offset		    */
#define _REGION_ENTRY_INVALID	0x20	/* invalid region table entry	    */
#define _REGION_ENTRY_TYPE_MASK	0x0c	/* region/segment table type mask   */
#define _REGION_ENTRY_TYPE_R1	0x0c	/* region first table type	    */
#define _REGION_ENTRY_TYPE_R2	0x08	/* region second table type	    */
#define _REGION_ENTRY_TYPE_R3	0x04	/* region third table type	    */
#define _REGION_ENTRY_LENGTH	0x03	/* region third length		    */

#define _REGION1_ENTRY		(_REGION_ENTRY_TYPE_R1 | _REGION_ENTRY_LENGTH)
#define _REGION1_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R1 | _REGION_ENTRY_INVALID)
#define _REGION2_ENTRY		(_REGION_ENTRY_TYPE_R2 | _REGION_ENTRY_LENGTH)
#define _REGION2_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R2 | _REGION_ENTRY_INVALID)
#define _REGION3_ENTRY		(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_LENGTH)
#define _REGION3_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_INVALID)

#define _REGION3_ENTRY_ORIGIN_LARGE ~0x7fffffffUL /* large page address	     */
#define _REGION3_ENTRY_ORIGIN  ~0x7ffUL/* region third table origin	     */

#define _REGION3_ENTRY_DIRTY	0x2000	/* SW region dirty bit */
#define _REGION3_ENTRY_YOUNG	0x1000	/* SW region young bit */
#define _REGION3_ENTRY_LARGE	0x0400	/* RTTE-format control, large page  */
#define _REGION3_ENTRY_READ	0x0002	/* SW region read bit */
#define _REGION3_ENTRY_WRITE	0x0001	/* SW region write bit */

#ifdef CONFIG_MEM_SOFT_DIRTY
#define _REGION3_ENTRY_SOFT_DIRTY 0x4000 /* SW region soft dirty bit */
#else
#define _REGION3_ENTRY_SOFT_DIRTY 0x0000 /* SW region soft dirty bit */
#endif

#define _REGION_ENTRY_BITS	 0xfffffffffffff227UL
#define _REGION_ENTRY_BITS_LARGE 0xffffffff8000fe27UL

/* Bits in the segment table entry */
#define _SEGMENT_ENTRY_BITS	0xfffffffffffffe33UL
#define _SEGMENT_ENTRY_BITS_LARGE 0xfffffffffff0ff33UL
#define _SEGMENT_ENTRY_ORIGIN_LARGE ~0xfffffUL /* large page address	    */
#define _SEGMENT_ENTRY_ORIGIN	~0x7ffUL/* segment table origin		    */
#define _SEGMENT_ENTRY_PROTECT	0x200	/* page protection bit		    */
#define _SEGMENT_ENTRY_INVALID	0x20	/* invalid segment table entry	    */

#define _SEGMENT_ENTRY		(0)
#define _SEGMENT_ENTRY_EMPTY	(_SEGMENT_ENTRY_INVALID)

#define _SEGMENT_ENTRY_DIRTY	0x2000	/* SW segment dirty bit */
#define _SEGMENT_ENTRY_YOUNG	0x1000	/* SW segment young bit */
#define _SEGMENT_ENTRY_LARGE	0x0400	/* STE-format control, large page */
#define _SEGMENT_ENTRY_WRITE	0x0002	/* SW segment write bit */
#define _SEGMENT_ENTRY_READ	0x0001	/* SW segment read bit */

#ifdef CONFIG_MEM_SOFT_DIRTY
#define _SEGMENT_ENTRY_SOFT_DIRTY 0x4000 /* SW segment soft dirty bit */
#else
#define _SEGMENT_ENTRY_SOFT_DIRTY 0x0000 /* SW segment soft dirty bit */
#endif

/*
 * Segment table and region3 table entry encoding
 * (R = read-only, I = invalid, y = young bit):
 *				dy..R...I...wr
 * prot-none, clean, old	00..1...1...00
 * prot-none, clean, young	01..1...1...00
 * prot-none, dirty, old	10..1...1...00
 * prot-none, dirty, young	11..1...1...00
 * read-only, clean, old	00..1...1...01
 * read-only, clean, young	01..1...0...01
 * read-only, dirty, old	10..1...1...01
 * read-only, dirty, young	11..1...0...01
 * read-write, clean, old	00..1...1...11
 * read-write, clean, young	01..1...0...11
 * read-write, dirty, old	10..0...1...11
 * read-write, dirty, young	11..0...0...11
 * The segment table origin is used to distinguish empty (origin==0) from
 * read-write, old segment table entries (origin!=0)
 * HW-bits: R read-only, I invalid
 * SW-bits: y young, d dirty, r read, w write
 */

/* Page status table bits for virtualization */
#define PGSTE_ACC_BITS	0xf000000000000000UL
#define PGSTE_FP_BIT	0x0800000000000000UL
#define PGSTE_PCL_BIT	0x0080000000000000UL
#define PGSTE_HR_BIT	0x0040000000000000UL
#define PGSTE_HC_BIT	0x0020000000000000UL
#define PGSTE_GR_BIT	0x0004000000000000UL
#define PGSTE_GC_BIT	0x0002000000000000UL
#define PGSTE_UC_BIT	0x0000800000000000UL	/* user dirty (migration) */
#define PGSTE_IN_BIT	0x0000400000000000UL	/* IPTE notify bit */
#define PGSTE_VSIE_BIT	0x0000200000000000UL	/* ref'd in a shadow table */

/* Guest Page State used for virtualization */
#define _PGSTE_GPS_ZERO		0x0000000080000000UL
#define _PGSTE_GPS_USAGE_MASK	0x0000000003000000UL
#define _PGSTE_GPS_USAGE_STABLE 0x0000000000000000UL
#define _PGSTE_GPS_USAGE_UNUSED 0x0000000001000000UL

/*
 * A user page table pointer has the space-switch-event bit, the
 * private-space-control bit and the storage-alteration-event-control
 * bit set. A kernel page table pointer doesn't need them.
 */
#define _ASCE_USER_BITS		(_ASCE_SPACE_SWITCH | _ASCE_PRIVATE_SPACE | \
				 _ASCE_ALT_EVENT)

/*
 * Page protection definitions.
 */
#define PAGE_NONE	__pgprot(_PAGE_PRESENT | _PAGE_INVALID | _PAGE_PROTECT)
#define PAGE_READ	__pgprot(_PAGE_PRESENT | _PAGE_READ | \
				 _PAGE_INVALID | _PAGE_PROTECT)
#define PAGE_WRITE	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
				 _PAGE_INVALID | _PAGE_PROTECT)

#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
				 _PAGE_YOUNG | _PAGE_DIRTY)
#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
				 _PAGE_YOUNG | _PAGE_DIRTY)
#define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_YOUNG | \
				 _PAGE_PROTECT)

/*
 * On s390 the page table entry has an invalid bit and a read-only bit.
 * Read permission implies execute permission and write permission
 * implies read permission.
 */
         /*xwr*/
#define __P000	PAGE_NONE
#define __P001	PAGE_READ
#define __P010	PAGE_READ
#define __P011	PAGE_READ
#define __P100	PAGE_READ
#define __P101	PAGE_READ
#define __P110	PAGE_READ
#define __P111	PAGE_READ

#define __S000	PAGE_NONE
#define __S001	PAGE_READ
#define __S010	PAGE_WRITE
#define __S011	PAGE_WRITE
#define __S100	PAGE_READ
#define __S101	PAGE_READ
#define __S110	PAGE_WRITE
#define __S111	PAGE_WRITE

/*
 * Segment entry (large page) protection definitions.
 */
#define SEGMENT_NONE	__pgprot(_SEGMENT_ENTRY_INVALID | \
				 _SEGMENT_ENTRY_PROTECT)
#define SEGMENT_READ	__pgprot(_SEGMENT_ENTRY_PROTECT | \
				 _SEGMENT_ENTRY_READ)
#define SEGMENT_WRITE	__pgprot(_SEGMENT_ENTRY_READ | \
				 _SEGMENT_ENTRY_WRITE)
#define SEGMENT_KERNEL	__pgprot(_SEGMENT_ENTRY |	\
				 _SEGMENT_ENTRY_LARGE |	\
				 _SEGMENT_ENTRY_READ |	\
				 _SEGMENT_ENTRY_WRITE | \
				 _SEGMENT_ENTRY_YOUNG | \
				 _SEGMENT_ENTRY_DIRTY)
#define SEGMENT_KERNEL_RO __pgprot(_SEGMENT_ENTRY |	\
				 _SEGMENT_ENTRY_LARGE |	\
				 _SEGMENT_ENTRY_READ |	\
				 _SEGMENT_ENTRY_YOUNG |	\
				 _SEGMENT_ENTRY_PROTECT)

/*
 * Region3 entry (large page) protection definitions.
 */

#define REGION3_KERNEL	__pgprot(_REGION_ENTRY_TYPE_R3 | \
				 _REGION3_ENTRY_LARGE |	 \
				 _REGION3_ENTRY_READ |	 \
				 _REGION3_ENTRY_WRITE |	 \
				 _REGION3_ENTRY_YOUNG |	 \
				 _REGION3_ENTRY_DIRTY)
#define REGION3_KERNEL_RO __pgprot(_REGION_ENTRY_TYPE_R3 | \
				   _REGION3_ENTRY_LARGE |  \
				   _REGION3_ENTRY_READ |   \
				   _REGION3_ENTRY_YOUNG |  \
				   _REGION_ENTRY_PROTECT)

static inline int mm_has_pgste(struct mm_struct *mm)
{
#ifdef CONFIG_PGSTE
	if (unlikely(mm->context.has_pgste))
		return 1;
#endif
	return 0;
}

static inline int mm_alloc_pgste(struct mm_struct *mm)
{
#ifdef CONFIG_PGSTE
	if (unlikely(mm->context.alloc_pgste))
		return 1;
#endif
	return 0;
}

/*
 * In the case that a guest uses storage keys
 * faults should no longer be backed by zero pages
 */
#define mm_forbids_zeropage mm_has_pgste
static inline int mm_use_skey(struct mm_struct *mm)
{
#ifdef CONFIG_PGSTE
	if (mm->context.use_skey)
		return 1;
#endif
	return 0;
}

static inline void csp(unsigned int *ptr, unsigned int old, unsigned int new)
{
	register unsigned long reg2 asm("2") = old;
	register unsigned long reg3 asm("3") = new;
	unsigned long address = (unsigned long)ptr | 1;

	asm volatile(
		"	csp	%0,%3"
		: "+d" (reg2), "+m" (*ptr)
		: "d" (reg3), "d" (address)
		: "cc");
}

static inline void cspg(unsigned long *ptr, unsigned long old, unsigned long new)
{
	register unsigned long reg2 asm("2") = old;
	register unsigned long reg3 asm("3") = new;
	unsigned long address = (unsigned long)ptr | 1;

	asm volatile(
		"	.insn	rre,0xb98a0000,%0,%3"
		: "+d" (reg2), "+m" (*ptr)
		: "d" (reg3), "d" (address)
		: "cc");
}

#define CRDTE_DTT_PAGE		0x00UL
#define CRDTE_DTT_SEGMENT	0x10UL
#define CRDTE_DTT_REGION3	0x14UL
#define CRDTE_DTT_REGION2	0x18UL
#define CRDTE_DTT_REGION1	0x1cUL

static inline void crdte(unsigned long old, unsigned long new,
			 unsigned long table, unsigned long dtt,
			 unsigned long address, unsigned long asce)
{
	register unsigned long reg2 asm("2") = old;
	register unsigned long reg3 asm("3") = new;
	register unsigned long reg4 asm("4") = table | dtt;
	register unsigned long reg5 asm("5") = address;

	asm volatile(".insn rrf,0xb98f0000,%0,%2,%4,0"
		     : "+d" (reg2)
		     : "d" (reg3), "d" (reg4), "d" (reg5), "a" (asce)
		     : "memory", "cc");
}

/*
 * pgd/pmd/pte query functions
 */
static inline int pgd_present(pgd_t pgd)
{
	if ((pgd_val(pgd) & _REGION_ENTRY_TYPE_MASK) < _REGION_ENTRY_TYPE_R2)
		return 1;
	return (pgd_val(pgd) & _REGION_ENTRY_ORIGIN) != 0UL;
}

static inline int pgd_none(pgd_t pgd)
{
	if ((pgd_val(pgd) & _REGION_ENTRY_TYPE_MASK) < _REGION_ENTRY_TYPE_R2)
		return 0;
	return (pgd_val(pgd) & _REGION_ENTRY_INVALID) != 0UL;
}

static inline int pgd_bad(pgd_t pgd)
{
	/*
	 * With dynamic page table levels the pgd can be a region table
	 * entry or a segment table entry. Check for the bit that are
	 * invalid for either table entry.
	 */
	unsigned long mask =
		~_SEGMENT_ENTRY_ORIGIN & ~_REGION_ENTRY_INVALID &
		~_REGION_ENTRY_TYPE_MASK & ~_REGION_ENTRY_LENGTH;
	return (pgd_val(pgd) & mask) != 0;
}

static inline int pud_present(pud_t pud)
{
	if ((pud_val(pud) & _REGION_ENTRY_TYPE_MASK) < _REGION_ENTRY_TYPE_R3)
		return 1;
	return (pud_val(pud) & _REGION_ENTRY_ORIGIN) != 0UL;
}

static inline int pud_none(pud_t pud)
{
	if ((pud_val(pud) & _REGION_ENTRY_TYPE_MASK) < _REGION_ENTRY_TYPE_R3)
		return 0;
	return pud_val(pud) == _REGION3_ENTRY_EMPTY;
}

static inline int pud_large(pud_t pud)
{
	if ((pud_val(pud) & _REGION_ENTRY_TYPE_MASK) != _REGION_ENTRY_TYPE_R3)
		return 0;
	return !!(pud_val(pud) & _REGION3_ENTRY_LARGE);
}

static inline unsigned long pud_pfn(pud_t pud)
{
	unsigned long origin_mask;

	origin_mask = _REGION3_ENTRY_ORIGIN;
	if (pud_large(pud))
		origin_mask = _REGION3_ENTRY_ORIGIN_LARGE;
	return (pud_val(pud) & origin_mask) >> PAGE_SHIFT;
}

static inline int pmd_large(pmd_t pmd)
{
	return (pmd_val(pmd) & _SEGMENT_ENTRY_LARGE) != 0;
}

static inline int pmd_bad(pmd_t pmd)
{
	if (pmd_large(pmd))
		return (pmd_val(pmd) & ~_SEGMENT_ENTRY_BITS_LARGE) != 0;
	return (pmd_val(pmd) & ~_SEGMENT_ENTRY_BITS) != 0;
}

static inline int pud_bad(pud_t pud)
{
	if ((pud_val(pud) & _REGION_ENTRY_TYPE_MASK) < _REGION_ENTRY_TYPE_R3)
		return pmd_bad(__pmd(pud_val(pud)));
	if (pud_large(pud))
		return (pud_val(pud) & ~_REGION_ENTRY_BITS_LARGE) != 0;
	return (pud_val(pud) & ~_REGION_ENTRY_BITS) != 0;
}

static inline int pmd_present(pmd_t pmd)
{
	return pmd_val(pmd) != _SEGMENT_ENTRY_INVALID;
}

static inline int pmd_none(pmd_t pmd)
{
	return pmd_val(pmd) == _SEGMENT_ENTRY_INVALID;
}

static inline unsigned long pmd_pfn(pmd_t pmd)
{
	unsigned long origin_mask;

	origin_mask = _SEGMENT_ENTRY_ORIGIN;
	if (pmd_large(pmd))
		origin_mask = _SEGMENT_ENTRY_ORIGIN_LARGE;
	return (pmd_val(pmd) & origin_mask) >> PAGE_SHIFT;
}

#define __HAVE_ARCH_PMD_WRITE
static inline int pmd_write(pmd_t pmd)
{
	return (pmd_val(pmd) & _SEGMENT_ENTRY_WRITE) != 0;
}

static inline int pmd_dirty(pmd_t pmd)
{
	int dirty = 1;
	if (pmd_large(pmd))
		dirty = (pmd_val(pmd) & _SEGMENT_ENTRY_DIRTY) != 0;
	return dirty;
}

static inline int pmd_young(pmd_t pmd)
{
	int young = 1;
	if (pmd_large(pmd))
		young = (pmd_val(pmd) & _SEGMENT_ENTRY_YOUNG) != 0;
	return young;
}

static inline int pte_present(pte_t pte)
{
	/* Bit pattern: (pte & 0x001) == 0x001 */
	return (pte_val(pte) & _PAGE_PRESENT) != 0;
}

static inline int pte_none(pte_t pte)
{
	/* Bit pattern: pte == 0x400 */
	return pte_val(pte) == _PAGE_INVALID;
}

static inline int pte_swap(pte_t pte)
{
	/* Bit pattern: (pte & 0x201) == 0x200 */
	return (pte_val(pte) & (_PAGE_PROTECT | _PAGE_PRESENT))
		== _PAGE_PROTECT;
}

static inline int pte_special(pte_t pte)
{
	return (pte_val(pte) & _PAGE_SPECIAL);
}

#define __HAVE_ARCH_PTE_SAME
static inline int pte_same(pte_t a, pte_t b)
{
	return pte_val(a) == pte_val(b);
}

#ifdef CONFIG_NUMA_BALANCING
static inline int pte_protnone(pte_t pte)
{
	return pte_present(pte) && !(pte_val(pte) & _PAGE_READ);
}

static inline int pmd_protnone(pmd_t pmd)
{
	/* pmd_large(pmd) implies pmd_present(pmd) */
	return pmd_large(pmd) && !(pmd_val(pmd) & _SEGMENT_ENTRY_READ);
}
#endif

static inline int pte_soft_dirty(pte_t pte)
{
	return pte_val(pte) & _PAGE_SOFT_DIRTY;
}
#define pte_swp_soft_dirty pte_soft_dirty

static inline pte_t pte_mksoft_dirty(pte_t pte)
{
	pte_val(pte) |= _PAGE_SOFT_DIRTY;
	return pte;
}
#define pte_swp_mksoft_dirty pte_mksoft_dirty

static inline pte_t pte_clear_soft_dirty(pte_t pte)
{
	pte_val(pte) &= ~_PAGE_SOFT_DIRTY;
	return pte;
}
#define pte_swp_clear_soft_dirty pte_clear_soft_dirty

static inline int pmd_soft_dirty(pmd_t pmd)
{
	return pmd_val(pmd) & _SEGMENT_ENTRY_SOFT_DIRTY;
}

static inline pmd_t pmd_mksoft_dirty(pmd_t pmd)
{
	pmd_val(pmd) |= _SEGMENT_ENTRY_SOFT_DIRTY;
	return pmd;
}

static inline pmd_t pmd_clear_soft_dirty(pmd_t pmd)
{
	pmd_val(pmd) &= ~_SEGMENT_ENTRY_SOFT_DIRTY;
	return pmd;
}

/*
 * query functions pte_write/pte_dirty/pte_young only work if
 * pte_present() is true. Undefined behaviour if not..
 */
static inline int pte_write(pte_t pte)
{
	return (pte_val(pte) & _PAGE_WRITE) != 0;
}

static inline int pte_dirty(pte_t pte)
{
	return (pte_val(pte) & _PAGE_DIRTY) != 0;
}

static inline int pte_young(pte_t pte)
{
	return (pte_val(pte) & _PAGE_YOUNG) != 0;
}

#define __HAVE_ARCH_PTE_UNUSED
static inline int pte_unused(pte_t pte)
{
	return pte_val(pte) & _PAGE_UNUSED;
}

/*
 * pgd/pmd/pte modification functions
 */

static inline void pgd_clear(pgd_t *pgd)
{
	if ((pgd_val(*pgd) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R2)
		pgd_val(*pgd) = _REGION2_ENTRY_EMPTY;
}

static inline void pud_clear(pud_t *pud)
{
	if ((pud_val(*pud) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R3)
		pud_val(*pud) = _REGION3_ENTRY_EMPTY;
}

static inline void pmd_clear(pmd_t *pmdp)
{
	pmd_val(*pmdp) = _SEGMENT_ENTRY_INVALID;
}

static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
{
	pte_val(*ptep) = _PAGE_INVALID;
}

/*
 * The following pte modification functions only work if
 * pte_present() is true. Undefined behaviour if not..
 */
static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
{
	pte_val(pte) &= _PAGE_CHG_MASK;
	pte_val(pte) |= pgprot_val(newprot);
	/*
	 * newprot for PAGE_NONE, PAGE_READ and PAGE_WRITE has the
	 * invalid bit set, clear it again for readable, young pages
	 */
	if ((pte_val(pte) & _PAGE_YOUNG) && (pte_val(pte) & _PAGE_READ))
		pte_val(pte) &= ~_PAGE_INVALID;
	/*
	 * newprot for PAGE_READ and PAGE_WRITE has the page protection
	 * bit set, clear it again for writable, dirty pages
	 */
	if ((pte_val(pte) & _PAGE_DIRTY) && (pte_val(pte) & _PAGE_WRITE))
		pte_val(pte) &= ~_PAGE_PROTECT;
	return pte;
}

static inline pte_t pte_wrprotect(pte_t pte)
{
	pte_val(pte) &= ~_PAGE_WRITE;
	pte_val(pte) |= _PAGE_PROTECT;
	return pte;
}

static inline pte_t pte_mkwrite(pte_t pte)
{
	pte_val(pte) |= _PAGE_WRITE;
	if (pte_val(pte) & _PAGE_DIRTY)
		pte_val(pte) &= ~_PAGE_PROTECT;
	return pte;
}

static inline pte_t pte_mkclean(pte_t pte)
{
	pte_val(pte) &= ~_PAGE_DIRTY;
	pte_val(pte) |= _PAGE_PROTECT;
	return pte;
}

static inline pte_t pte_mkdirty(pte_t pte)
{
	pte_val(pte) |= _PAGE_DIRTY | _PAGE_SOFT_DIRTY;
	if (pte_val(pte) & _PAGE_WRITE)
		pte_val(pte) &= ~_PAGE_PROTECT;
	return pte;
}

static inline pte_t pte_mkold(pte_t pte)
{
	pte_val(pte) &= ~_PAGE_YOUNG;
	pte_val(pte) |= _PAGE_INVALID;
	return pte;
}

static inline pte_t pte_mkyoung(pte_t pte)
{
	pte_val(pte) |= _PAGE_YOUNG;
	if (pte_val(pte) & _PAGE_READ)
		pte_val(pte) &= ~_PAGE_INVALID;
	return pte;
}

static inline pte_t pte_mkspecial(pte_t pte)
{
	pte_val(pte) |= _PAGE_SPECIAL;
	return pte;
}

#ifdef CONFIG_HUGETLB_PAGE
static inline pte_t pte_mkhuge(pte_t pte)
{
	pte_val(pte) |= _PAGE_LARGE;
	return pte;
}
#endif

#define IPTE_GLOBAL	0
#define	IPTE_LOCAL	1

static inline void __ptep_ipte(unsigned long address, pte_t *ptep, int local)
{
	unsigned long pto = (unsigned long) ptep;

	/* Invalidation + TLB flush for the pte */
	asm volatile(
		"       .insn rrf,0xb2210000,%[r1],%[r2],0,%[m4]"
		: "+m" (*ptep) : [r1] "a" (pto), [r2] "a" (address),
		  [m4] "i" (local));
}

static inline void __ptep_ipte_range(unsigned long address, int nr,
				     pte_t *ptep, int local)
{
	unsigned long pto = (unsigned long) ptep;

	/* Invalidate a range of ptes + TLB flush of the ptes */
	do {
		asm volatile(
			"       .insn rrf,0xb2210000,%[r1],%[r2],%[r3],%[m4]"
			: [r2] "+a" (address), [r3] "+a" (nr)
			: [r1] "a" (pto), [m4] "i" (local) : "memory");
	} while (nr != 255);
}

/*
 * This is hard to understand. ptep_get_and_clear and ptep_clear_flush
 * both clear the TLB for the unmapped pte. The reason is that
 * ptep_get_and_clear is used in common code (e.g. change_pte_range)
 * to modify an active pte. The sequence is
 *   1) ptep_get_and_clear
 *   2) set_pte_at
 *   3) flush_tlb_range
 * On s390 the tlb needs to get flushed with the modification of the pte
 * if the pte is active. The only way how this can be implemented is to
 * have ptep_get_and_clear do the tlb flush. In exchange flush_tlb_range
 * is a nop.
 */
pte_t ptep_xchg_direct(struct mm_struct *, unsigned long, pte_t *, pte_t);
pte_t ptep_xchg_lazy(struct mm_struct *, unsigned long, pte_t *, pte_t);

#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
static inline int ptep_test_and_clear_young(struct vm_area_struct *vma,
					    unsigned long addr, pte_t *ptep)
{
	pte_t pte = *ptep;

	pte = ptep_xchg_direct(vma->vm_mm, addr, ptep, pte_mkold(pte));
	return pte_young(pte);
}

#define __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH
static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
					 unsigned long address, pte_t *ptep)
{
	return ptep_test_and_clear_young(vma, address, ptep);
}

#define __HAVE_ARCH_PTEP_GET_AND_CLEAR
static inline pte_t ptep_get_and_clear(struct mm_struct *mm,
				       unsigned long addr, pte_t *ptep)
{
	return ptep_xchg_lazy(mm, addr, ptep, __pte(_PAGE_INVALID));
}

#define __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION
pte_t ptep_modify_prot_start(struct mm_struct *, unsigned long, pte_t *);
void ptep_modify_prot_commit(struct mm_struct *, unsigned long, pte_t *, pte_t);

#define __HAVE_ARCH_PTEP_CLEAR_FLUSH
static inline pte_t ptep_clear_flush(struct vm_area_struct *vma,
				     unsigned long addr, pte_t *ptep)
{
	return ptep_xchg_direct(vma->vm_mm, addr, ptep, __pte(_PAGE_INVALID));
}

/*
 * The batched pte unmap code uses ptep_get_and_clear_full to clear the
 * ptes. Here an optimization is possible. tlb_gather_mmu flushes all
 * tlbs of an mm if it can guarantee that the ptes of the mm_struct
 * cannot be accessed while the batched unmap is running. In this case
 * full==1 and a simple pte_clear is enough. See tlb.h.
 */
#define __HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL
static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,
					    unsigned long addr,
					    pte_t *ptep, int full)
{
	if (full) {
		pte_t pte = *ptep;
		*ptep = __pte(_PAGE_INVALID);
		return pte;
	}
	return ptep_xchg_lazy(mm, addr, ptep, __pte(_PAGE_INVALID));
}

#define __HAVE_ARCH_PTEP_SET_WRPROTECT
static inline void ptep_set_wrprotect(struct mm_struct *mm,
				      unsigned long addr, pte_t *ptep)
{
	pte_t pte = *ptep;

	if (pte_write(pte))
		ptep_xchg_lazy(mm, addr, ptep, pte_wrprotect(pte));
}

#define __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS
static inline int ptep_set_access_flags(struct vm_area_struct *vma,
					unsigned long addr, pte_t *ptep,
					pte_t entry, int dirty)
{
	if (pte_same(*ptep, entry))
		return 0;
	ptep_xchg_direct(vma->vm_mm, addr, ptep, entry);
	return 1;
}

/*
 * Additional functions to handle KVM guest page tables
 */
void ptep_set_pte_at(struct mm_struct *mm, unsigned long addr,
		     pte_t *ptep, pte_t entry);
void ptep_set_notify(struct mm_struct *mm, unsigned long addr, pte_t *ptep);
void ptep_notify(struct mm_struct *mm, unsigned long addr,
		 pte_t *ptep, unsigned long bits);
int ptep_force_prot(struct mm_struct *mm, unsigned long gaddr,
		    pte_t *ptep, int prot, unsigned long bit);
void ptep_zap_unused(struct mm_struct *mm, unsigned long addr,
		     pte_t *ptep , int reset);
void ptep_zap_key(struct mm_struct *mm, unsigned long addr, pte_t *ptep);
int ptep_shadow_pte(struct mm_struct *mm, unsigned long saddr,
		    pte_t *sptep, pte_t *tptep, pte_t pte);
void ptep_unshadow_pte(struct mm_struct *mm, unsigned long saddr, pte_t *ptep);

bool test_and_clear_guest_dirty(struct mm_struct *mm, unsigned long address);
int set_guest_storage_key(struct mm_struct *mm, unsigned long addr,
			  unsigned char key, bool nq);
int cond_set_guest_storage_key(struct mm_struct *mm, unsigned long addr,
			       unsigned char key, unsigned char *oldkey,
			       bool nq, bool mr, bool mc);
int reset_guest_reference_bit(struct mm_struct *mm, unsigned long addr);
int get_guest_storage_key(struct mm_struct *mm, unsigned long addr,
			  unsigned char *key);

/*
 * Certain architectures need to do special things when PTEs
 * within a page table are directly modified.  Thus, the following
 * hook is made available.
 */
static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
			      pte_t *ptep, pte_t entry)
{
	if (pte_present(entry))
		pte_val(entry) &= ~_PAGE_UNUSED;
	if (mm_has_pgste(mm))
		ptep_set_pte_at(mm, addr, ptep, entry);
	else
		*ptep = entry;
}

/*
 * Conversion functions: convert a page and protection to a page entry,
 * and a page entry and page directory to the page they refer to.
 */
static inline pte_t mk_pte_phys(unsigned long physpage, pgprot_t pgprot)
{
	pte_t __pte;
	pte_val(__pte) = physpage + pgprot_val(pgprot);
	return pte_mkyoung(__pte);
}

static inline pte_t mk_pte(struct page *page, pgprot_t pgprot)
{
	unsigned long physpage = page_to_phys(page);
	pte_t __pte = mk_pte_phys(physpage, pgprot);

	if (pte_write(__pte) && PageDirty(page))
		__pte = pte_mkdirty(__pte);
	return __pte;
}

#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
#define pud_index(address) (((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
#define pmd_index(address) (((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
#define pte_index(address) (((address) >> PAGE_SHIFT) & (PTRS_PER_PTE-1))

#define pgd_offset(mm, address) ((mm)->pgd + pgd_index(address))
#define pgd_offset_k(address) pgd_offset(&init_mm, address)

#define pmd_deref(pmd) (pmd_val(pmd) & _SEGMENT_ENTRY_ORIGIN)
#define pud_deref(pud) (pud_val(pud) & _REGION_ENTRY_ORIGIN)
#define pgd_deref(pgd) (pgd_val(pgd) & _REGION_ENTRY_ORIGIN)

static inline pud_t *pud_offset(pgd_t *pgd, unsigned long address)
{
	pud_t *pud = (pud_t *) pgd;
	if ((pgd_val(*pgd) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R2)
		pud = (pud_t *) pgd_deref(*pgd);
	return pud  + pud_index(address);
}

static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
{
	pmd_t *pmd = (pmd_t *) pud;
	if ((pud_val(*pud) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R3)
		pmd = (pmd_t *) pud_deref(*pud);
	return pmd + pmd_index(address);
}

#define pfn_pte(pfn,pgprot) mk_pte_phys(__pa((pfn) << PAGE_SHIFT),(pgprot))
#define pte_pfn(x) (pte_val(x) >> PAGE_SHIFT)
#define pte_page(x) pfn_to_page(pte_pfn(x))

#define pmd_page(pmd) pfn_to_page(pmd_pfn(pmd))
#define pud_page(pud) pfn_to_page(pud_pfn(pud))

/* Find an entry in the lowest level page table.. */
#define pte_offset(pmd, addr) ((pte_t *) pmd_deref(*(pmd)) + pte_index(addr))
#define pte_offset_kernel(pmd, address) pte_offset(pmd,address)
#define pte_offset_map(pmd, address) pte_offset_kernel(pmd, address)
#define pte_unmap(pte) do { } while (0)

static inline pmd_t pmd_wrprotect(pmd_t pmd)
{
	pmd_val(pmd) &= ~_SEGMENT_ENTRY_WRITE;
	pmd_val(pmd) |= _SEGMENT_ENTRY_PROTECT;
	return pmd;
}

static inline pmd_t pmd_mkwrite(pmd_t pmd)
{
	pmd_val(pmd) |= _SEGMENT_ENTRY_WRITE;
	if (pmd_large(pmd) && !(pmd_val(pmd) & _SEGMENT_ENTRY_DIRTY))
		return pmd;
	pmd_val(pmd) &= ~_SEGMENT_ENTRY_PROTECT;
	return pmd;
}

static inline pmd_t pmd_mkclean(pmd_t pmd)
{
	if (pmd_large(pmd)) {
		pmd_val(pmd) &= ~_SEGMENT_ENTRY_DIRTY;
		pmd_val(pmd) |= _SEGMENT_ENTRY_PROTECT;
	}
	return pmd;
}

static inline pmd_t pmd_mkdirty(pmd_t pmd)
{
	if (pmd_large(pmd)) {
		pmd_val(pmd) |= _SEGMENT_ENTRY_DIRTY |
				_SEGMENT_ENTRY_SOFT_DIRTY;
		if (pmd_val(pmd) & _SEGMENT_ENTRY_WRITE)
			pmd_val(pmd) &= ~_SEGMENT_ENTRY_PROTECT;
	}
	return pmd;
}

static inline pud_t pud_wrprotect(pud_t pud)
{
	pud_val(pud) &= ~_REGION3_ENTRY_WRITE;
	pud_val(pud) |= _REGION_ENTRY_PROTECT;
	return pud;
}

static inline pud_t pud_mkwrite(pud_t pud)
{
	pud_val(pud) |= _REGION3_ENTRY_WRITE;
	if (pud_large(pud) && !(pud_val(pud) & _REGION3_ENTRY_DIRTY))
		return pud;
	pud_val(pud) &= ~_REGION_ENTRY_PROTECT;
	return pud;
}

static inline pud_t pud_mkclean(pud_t pud)
{
	if (pud_large(pud)) {
		pud_val(pud) &= ~_REGION3_ENTRY_DIRTY;
		pud_val(pud) |= _REGION_ENTRY_PROTECT;
	}
	return pud;
}

static inline pud_t pud_mkdirty(pud_t pud)
{
	if (pud_large(pud)) {
		pud_val(pud) |= _REGION3_ENTRY_DIRTY |
				_REGION3_ENTRY_SOFT_DIRTY;
		if (pud_val(pud) & _REGION3_ENTRY_WRITE)
			pud_val(pud) &= ~_REGION_ENTRY_PROTECT;
	}
	return pud;
}

#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLB_PAGE)
static inline unsigned long massage_pgprot_pmd(pgprot_t pgprot)
{
	/*
	 * pgprot is PAGE_NONE, PAGE_READ, or PAGE_WRITE (see __Pxxx / __Sxxx)
	 * Convert to segment table entry format.
	 */
	if (pgprot_val(pgprot) == pgprot_val(PAGE_NONE))
		return pgprot_val(SEGMENT_NONE);
	if (pgprot_val(pgprot) == pgprot_val(PAGE_READ))
		return pgprot_val(SEGMENT_READ);
	return pgprot_val(SEGMENT_WRITE);
}

static inline pmd_t pmd_mkyoung(pmd_t pmd)
{
	if (pmd_large(pmd)) {
		pmd_val(pmd) |= _SEGMENT_ENTRY_YOUNG;
		if (pmd_val(pmd) & _SEGMENT_ENTRY_READ)
			pmd_val(pmd) &= ~_SEGMENT_ENTRY_INVALID;
	}
	return pmd;
}

static inline pmd_t pmd_mkold(pmd_t pmd)
{
	if (pmd_large(pmd)) {
		pmd_val(pmd) &= ~_SEGMENT_ENTRY_YOUNG;
		pmd_val(pmd) |= _SEGMENT_ENTRY_INVALID;
	}
	return pmd;
}

static inline pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot)
{
	if (pmd_large(pmd)) {
		pmd_val(pmd) &= _SEGMENT_ENTRY_ORIGIN_LARGE |
			_SEGMENT_ENTRY_DIRTY | _SEGMENT_ENTRY_YOUNG |
			_SEGMENT_ENTRY_LARGE | _SEGMENT_ENTRY_SOFT_DIRTY;
		pmd_val(pmd) |= massage_pgprot_pmd(newprot);
		if (!(pmd_val(pmd) & _SEGMENT_ENTRY_DIRTY))
			pmd_val(pmd) |= _SEGMENT_ENTRY_PROTECT;
		if (!(pmd_val(pmd) & _SEGMENT_ENTRY_YOUNG))
			pmd_val(pmd) |= _SEGMENT_ENTRY_INVALID;
		return pmd;
	}
	pmd_val(pmd) &= _SEGMENT_ENTRY_ORIGIN;
	pmd_val(pmd) |= massage_pgprot_pmd(newprot);
	return pmd;
}

static inline pmd_t mk_pmd_phys(unsigned long physpage, pgprot_t pgprot)
{
	pmd_t __pmd;
	pmd_val(__pmd) = physpage + massage_pgprot_pmd(pgprot);
	return __pmd;
}

#endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLB_PAGE */

static inline void __pmdp_csp(pmd_t *pmdp)
{
	csp((unsigned int *)pmdp + 1, pmd_val(*pmdp),
	    pmd_val(*pmdp) | _SEGMENT_ENTRY_INVALID);
}

#define IDTE_GLOBAL	0
#define IDTE_LOCAL	1

static inline void __pmdp_idte(unsigned long address, pmd_t *pmdp, int local)
{
	unsigned long sto;

	sto = (unsigned long) pmdp - pmd_index(address) * sizeof(pmd_t);
	asm volatile(
		"	.insn	rrf,0xb98e0000,%[r1],%[r2],0,%[m4]"
		: "+m" (*pmdp)
		: [r1] "a" (sto), [r2] "a" ((address & HPAGE_MASK)),
		  [m4] "i" (local)
		: "cc" );
}

static inline void __pudp_idte(unsigned long address, pud_t *pudp, int local)
{
	unsigned long r3o;

	r3o = (unsigned long) pudp - pud_index(address) * sizeof(pud_t);
	r3o |= _ASCE_TYPE_REGION3;
	asm volatile(
		"	.insn	rrf,0xb98e0000,%[r1],%[r2],0,%[m4]"
		: "+m" (*pudp)
		: [r1] "a" (r3o), [r2] "a" ((address & PUD_MASK)),
		  [m4] "i" (local)
		: "cc");
}

pmd_t pmdp_xchg_direct(struct mm_struct *, unsigned long, pmd_t *, pmd_t);
pmd_t pmdp_xchg_lazy(struct mm_struct *, unsigned long, pmd_t *, pmd_t);
pud_t pudp_xchg_direct(struct mm_struct *, unsigned long, pud_t *, pud_t);

#ifdef CONFIG_TRANSPARENT_HUGEPAGE

#define __HAVE_ARCH_PGTABLE_DEPOSIT
void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,
				pgtable_t pgtable);

#define __HAVE_ARCH_PGTABLE_WITHDRAW
pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);

#define  __HAVE_ARCH_PMDP_SET_ACCESS_FLAGS
static inline int pmdp_set_access_flags(struct vm_area_struct *vma,
					unsigned long addr, pmd_t *pmdp,
					pmd_t entry, int dirty)
{
	VM_BUG_ON(addr & ~HPAGE_MASK);

	entry = pmd_mkyoung(entry);
	if (dirty)
		entry = pmd_mkdirty(entry);
	if (pmd_val(*pmdp) == pmd_val(entry))
		return 0;
	pmdp_xchg_direct(vma->vm_mm, addr, pmdp, entry);
	return 1;
}

#define __HAVE_ARCH_PMDP_TEST_AND_CLEAR_YOUNG
static inline int pmdp_test_and_clear_young(struct vm_area_struct *vma,
					    unsigned long addr, pmd_t *pmdp)
{
	pmd_t pmd = *pmdp;

	pmd = pmdp_xchg_direct(vma->vm_mm, addr, pmdp, pmd_mkold(pmd));
	return pmd_young(pmd);
}

#define __HAVE_ARCH_PMDP_CLEAR_YOUNG_FLUSH
static inline int pmdp_clear_flush_young(struct vm_area_struct *vma,
					 unsigned long addr, pmd_t *pmdp)
{
	VM_BUG_ON(addr & ~HPAGE_MASK);
	return pmdp_test_and_clear_young(vma, addr, pmdp);
}

static inline void set_pmd_at(struct mm_struct *mm, unsigned long addr,
			      pmd_t *pmdp, pmd_t entry)
{
	*pmdp = entry;
}

static inline pmd_t pmd_mkhuge(pmd_t pmd)
{
	pmd_val(pmd) |= _SEGMENT_ENTRY_LARGE;
	pmd_val(pmd) |= _SEGMENT_ENTRY_YOUNG;
	pmd_val(pmd) |= _SEGMENT_ENTRY_PROTECT;
	return pmd;
}

#define __HAVE_ARCH_PMDP_HUGE_GET_AND_CLEAR
static inline pmd_t pmdp_huge_get_and_clear(struct mm_struct *mm,
					    unsigned long addr, pmd_t *pmdp)
{
	return pmdp_xchg_direct(mm, addr, pmdp, __pmd(_SEGMENT_ENTRY_INVALID));
}

#define __HAVE_ARCH_PMDP_HUGE_GET_AND_CLEAR_FULL
static inline pmd_t pmdp_huge_get_and_clear_full(struct mm_struct *mm,
						 unsigned long addr,
						 pmd_t *pmdp, int full)
{
	if (full) {
		pmd_t pmd = *pmdp;
		*pmdp = __pmd(_SEGMENT_ENTRY_INVALID);
		return pmd;
	}
	return pmdp_xchg_lazy(mm, addr, pmdp, __pmd(_SEGMENT_ENTRY_INVALID));
}

#define __HAVE_ARCH_PMDP_HUGE_CLEAR_FLUSH
static inline pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma,
					  unsigned long addr, pmd_t *pmdp)
{
	return pmdp_huge_get_and_clear(vma->vm_mm, addr, pmdp);
}

#define __HAVE_ARCH_PMDP_INVALIDATE
static inline void pmdp_invalidate(struct vm_area_struct *vma,
				   unsigned long addr, pmd_t *pmdp)
{
	pmd_t pmd = __pmd(pmd_val(*pmdp) | _SEGMENT_ENTRY_INVALID);

	pmdp_xchg_direct(vma->vm_mm, addr, pmdp, pmd);
}

#define __HAVE_ARCH_PMDP_SET_WRPROTECT
static inline void pmdp_set_wrprotect(struct mm_struct *mm,
				      unsigned long addr, pmd_t *pmdp)
{
	pmd_t pmd = *pmdp;

	if (pmd_write(pmd))
		pmd = pmdp_xchg_lazy(mm, addr, pmdp, pmd_wrprotect(pmd));
}

static inline pmd_t pmdp_collapse_flush(struct vm_area_struct *vma,
					unsigned long address,
					pmd_t *pmdp)
{
	return pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);
}
#define pmdp_collapse_flush pmdp_collapse_flush

#define pfn_pmd(pfn, pgprot)	mk_pmd_phys(__pa((pfn) << PAGE_SHIFT), (pgprot))
#define mk_pmd(page, pgprot)	pfn_pmd(page_to_pfn(page), (pgprot))

static inline int pmd_trans_huge(pmd_t pmd)
{
	return pmd_val(pmd) & _SEGMENT_ENTRY_LARGE;
}

#define has_transparent_hugepage has_transparent_hugepage
static inline int has_transparent_hugepage(void)
{
	return MACHINE_HAS_HPAGE ? 1 : 0;
}
#endif /* CONFIG_TRANSPARENT_HUGEPAGE */

/*
 * 64 bit swap entry format:
 * A page-table entry has some bits we have to treat in a special way.
 * Bits 52 and bit 55 have to be zero, otherwise a specification
 * exception will occur instead of a page translation exception. The
 * specification exception has the bad habit not to store necessary
 * information in the lowcore.
 * Bits 54 and 63 are used to indicate the page type.
 * A swap pte is indicated by bit pattern (pte & 0x201) == 0x200
 * This leaves the bits 0-51 and bits 56-62 to store type and offset.
 * We use the 5 bits from 57-61 for the type and the 52 bits from 0-51
 * for the offset.
 * |			  offset			|01100|type |00|
 * |0000000000111111111122222222223333333333444444444455|55555|55566|66|
 * |0123456789012345678901234567890123456789012345678901|23456|78901|23|
 */

#define __SWP_OFFSET_MASK	((1UL << 52) - 1)
#define __SWP_OFFSET_SHIFT	12
#define __SWP_TYPE_MASK		((1UL << 5) - 1)
#define __SWP_TYPE_SHIFT	2

static inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
{
	pte_t pte;

	pte_val(pte) = _PAGE_INVALID | _PAGE_PROTECT;
	pte_val(pte) |= (offset & __SWP_OFFSET_MASK) << __SWP_OFFSET_SHIFT;
	pte_val(pte) |= (type & __SWP_TYPE_MASK) << __SWP_TYPE_SHIFT;
	return pte;
}

static inline unsigned long __swp_type(swp_entry_t entry)
{
	return (entry.val >> __SWP_TYPE_SHIFT) & __SWP_TYPE_MASK;
}

static inline unsigned long __swp_offset(swp_entry_t entry)
{
	return (entry.val >> __SWP_OFFSET_SHIFT) & __SWP_OFFSET_MASK;
}

static inline swp_entry_t __swp_entry(unsigned long type, unsigned long offset)
{
	return (swp_entry_t) { pte_val(mk_swap_pte(type, offset)) };
}

#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
#define __swp_entry_to_pte(x)	((pte_t) { (x).val })

#endif /* !__ASSEMBLY__ */

#define kern_addr_valid(addr)   (1)

extern int vmem_add_mapping(unsigned long start, unsigned long size);
extern int vmem_remove_mapping(unsigned long start, unsigned long size);
extern int s390_enable_sie(void);
extern int s390_enable_skey(void);
extern void s390_reset_cmma(struct mm_struct *mm);

/* s390 has a private copy of get unmapped area to deal with cache synonyms */
#define HAVE_ARCH_UNMAPPED_AREA
#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN

/*
 * No page table caches to initialise
 */
static inline void pgtable_cache_init(void) { }
static inline void check_pgt_cache(void) { }

#include <asm-generic/pgtable.h>

#endif /* _S390_PAGE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * definition for store system information stsi
 *
 * Copyright IBM Corp. 2001, 2008
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License (version 2 only)
 * as published by the Free Software Foundation.
 *
 *    Author(s): Ulrich Weigand <weigand@de.ibm.com>
 *		 Christian Borntraeger <borntraeger@de.ibm.com>
 */

#ifndef __ASM_S390_SYSINFO_H
#define __ASM_S390_SYSINFO_H

#include <asm/bitsperlong.h>
#include <linux/uuid.h>

struct sysinfo_1_1_1 {
	unsigned char p:1;
	unsigned char :6;
	unsigned char t:1;
	unsigned char :8;
	unsigned char ccr;
	unsigned char cai;
	char reserved_0[28];
	char manufacturer[16];
	char type[4];
	char reserved_1[12];
	char model_capacity[16];
	char sequence[16];
	char plant[4];
	char model[16];
	char model_perm_cap[16];
	char model_temp_cap[16];
	unsigned int model_cap_rating;
	unsigned int model_perm_cap_rating;
	unsigned int model_temp_cap_rating;
	unsigned char typepct[5];
	unsigned char reserved_2[3];
	unsigned int ncr;
	unsigned int npr;
	unsigned int ntr;
};

struct sysinfo_1_2_1 {
	char reserved_0[80];
	char sequence[16];
	char plant[4];
	char reserved_1[2];
	unsigned short cpu_address;
};

struct sysinfo_1_2_2 {
	char format;
	char reserved_0[1];
	unsigned short acc_offset;
	unsigned char mt_installed :1;
	unsigned char :2;
	unsigned char mt_stid :5;
	unsigned char :3;
	unsigned char mt_gtid :5;
	char reserved_1[18];
	unsigned int nominal_cap;
	unsigned int secondary_cap;
	unsigned int capability;
	unsigned short cpus_total;
	unsigned short cpus_configured;
	unsigned short cpus_standby;
	unsigned short cpus_reserved;
	unsigned short adjustment[0];
};

struct sysinfo_1_2_2_extension {
	unsigned int alt_capability;
	unsigned short alt_adjustment[0];
};

struct sysinfo_2_2_1 {
	char reserved_0[80];
	char sequence[16];
	char plant[4];
	unsigned short cpu_id;
	unsigned short cpu_address;
};

struct sysinfo_2_2_2 {
	char reserved_0[32];
	unsigned short lpar_number;
	char reserved_1;
	unsigned char characteristics;
	unsigned short cpus_total;
	unsigned short cpus_configured;
	unsigned short cpus_standby;
	unsigned short cpus_reserved;
	char name[8];
	unsigned int caf;
	char reserved_2[8];
	unsigned char mt_installed :1;
	unsigned char :2;
	unsigned char mt_stid :5;
	unsigned char :3;
	unsigned char mt_gtid :5;
	unsigned char :3;
	unsigned char mt_psmtid :5;
	char reserved_3[5];
	unsigned short cpus_dedicated;
	unsigned short cpus_shared;
};

#define LPAR_CHAR_DEDICATED	(1 << 7)
#define LPAR_CHAR_SHARED	(1 << 6)
#define LPAR_CHAR_LIMITED	(1 << 5)

struct sysinfo_3_2_2 {
	char reserved_0[31];
	unsigned char :4;
	unsigned char count:4;
	struct {
		char reserved_0[4];
		unsigned short cpus_total;
		unsigned short cpus_configured;
		unsigned short cpus_standby;
		unsigned short cpus_reserved;
		char name[8];
		unsigned int caf;
		char cpi[16];
		char reserved_1[3];
		char ext_name_encoding;
		unsigned int reserved_2;
		uuid_be uuid;
	} vm[8];
	char reserved_3[1504];
	char ext_names[8][256];
};

extern int topology_max_mnest;

#define TOPOLOGY_CORE_BITS	64
#define TOPOLOGY_NR_MAG		6

struct topology_core {
	unsigned char nl;
	unsigned char reserved0[3];
	unsigned char :6;
	unsigned char pp:2;
	unsigned char reserved1;
	unsigned short origin;
	unsigned long mask[TOPOLOGY_CORE_BITS / BITS_PER_LONG];
};

struct topology_container {
	unsigned char nl;
	unsigned char reserved[6];
	unsigned char id;
};

union topology_entry {
	unsigned char nl;
	struct topology_core cpu;
	struct topology_container container;
};

struct sysinfo_15_1_x {
	unsigned char reserved0[2];
	unsigned short length;
	unsigned char mag[TOPOLOGY_NR_MAG];
	unsigned char reserved1;
	unsigned char mnest;
	unsigned char reserved2[4];
	union topology_entry tle[0];
};

int stsi(void *sysinfo, int fc, int sel1, int sel2);

/*
 * Service level reporting interface.
 */
struct service_level {
	struct list_head list;
	void (*seq_print)(struct seq_file *, struct service_level *);
};

int register_service_level(struct service_level *);
int unregister_service_level(struct service_level *);

#endif /* __ASM_S390_SYSINFO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * s390 diagnose functions
 *
 * Copyright IBM Corp. 2007
 * Author(s): Michael Holzheu <holzheu@de.ibm.com>
 */

#ifndef _ASM_S390_DIAG_H
#define _ASM_S390_DIAG_H

#include <linux/percpu.h>

enum diag_stat_enum {
	DIAG_STAT_X008,
	DIAG_STAT_X00C,
	DIAG_STAT_X010,
	DIAG_STAT_X014,
	DIAG_STAT_X044,
	DIAG_STAT_X064,
	DIAG_STAT_X09C,
	DIAG_STAT_X0DC,
	DIAG_STAT_X204,
	DIAG_STAT_X210,
	DIAG_STAT_X224,
	DIAG_STAT_X250,
	DIAG_STAT_X258,
	DIAG_STAT_X288,
	DIAG_STAT_X2C4,
	DIAG_STAT_X2FC,
	DIAG_STAT_X304,
	DIAG_STAT_X308,
	DIAG_STAT_X500,
	NR_DIAG_STAT
};

void diag_stat_inc(enum diag_stat_enum nr);
void diag_stat_inc_norecursion(enum diag_stat_enum nr);

/*
 * Diagnose 10: Release page range
 */
static inline void diag10_range(unsigned long start_pfn, unsigned long num_pfn)
{
	unsigned long start_addr, end_addr;

	start_addr = start_pfn << PAGE_SHIFT;
	end_addr = (start_pfn + num_pfn - 1) << PAGE_SHIFT;

	diag_stat_inc(DIAG_STAT_X010);
	asm volatile(
		"0:	diag	%0,%1,0x10\n"
		"1:	nopr	%%r7\n"
		EX_TABLE(0b, 1b)
		EX_TABLE(1b, 1b)
		: : "a" (start_addr), "a" (end_addr));
}

/*
 * Diagnose 14: Input spool file manipulation
 */
extern int diag14(unsigned long rx, unsigned long ry1, unsigned long subcode);

/*
 * Diagnose 210: Get information about a virtual device
 */
struct diag210 {
	u16 vrdcdvno;	/* device number (input) */
	u16 vrdclen;	/* data block length (input) */
	u8 vrdcvcla;	/* virtual device class (output) */
	u8 vrdcvtyp;	/* virtual device type (output) */
	u8 vrdcvsta;	/* virtual device status (output) */
	u8 vrdcvfla;	/* virtual device flags (output) */
	u8 vrdcrccl;	/* real device class (output) */
	u8 vrdccrty;	/* real device type (output) */
	u8 vrdccrmd;	/* real device model (output) */
	u8 vrdccrft;	/* real device feature (output) */
} __attribute__((packed, aligned(4)));

extern int diag210(struct diag210 *addr);

/* bit is set in flags, when physical cpu info is included in diag 204 data */
#define DIAG204_LPAR_PHYS_FLG 0x80
#define DIAG204_LPAR_NAME_LEN 8		/* lpar name len in diag 204 data */
#define DIAG204_CPU_NAME_LEN 16		/* type name len of cpus in diag224 name table */

/* diag 204 subcodes */
enum diag204_sc {
	DIAG204_SUBC_STIB4 = 4,
	DIAG204_SUBC_RSI = 5,
	DIAG204_SUBC_STIB6 = 6,
	DIAG204_SUBC_STIB7 = 7
};

/* The two available diag 204 data formats */
enum diag204_format {
	DIAG204_INFO_SIMPLE = 0,
	DIAG204_INFO_EXT = 0x00010000
};

enum diag204_cpu_flags {
	DIAG204_CPU_ONLINE = 0x20,
	DIAG204_CPU_CAPPED = 0x40,
};

struct diag204_info_blk_hdr {
	__u8  npar;
	__u8  flags;
	__u16 tslice;
	__u16 phys_cpus;
	__u16 this_part;
	__u64 curtod;
} __packed;

struct diag204_x_info_blk_hdr {
	__u8  npar;
	__u8  flags;
	__u16 tslice;
	__u16 phys_cpus;
	__u16 this_part;
	__u64 curtod1;
	__u64 curtod2;
	char reserved[40];
} __packed;

struct diag204_part_hdr {
	__u8 pn;
	__u8 cpus;
	char reserved[6];
	char part_name[DIAG204_LPAR_NAME_LEN];
} __packed;

struct diag204_x_part_hdr {
	__u8  pn;
	__u8  cpus;
	__u8  rcpus;
	__u8  pflag;
	__u32 mlu;
	char  part_name[DIAG204_LPAR_NAME_LEN];
	char  lpc_name[8];
	char  os_name[8];
	__u64 online_cs;
	__u64 online_es;
	__u8  upid;
	__u8  reserved:3;
	__u8  mtid:5;
	char  reserved1[2];
	__u32 group_mlu;
	char  group_name[8];
	char  hardware_group_name[8];
	char  reserved2[24];
} __packed;

struct diag204_cpu_info {
	__u16 cpu_addr;
	char  reserved1[2];
	__u8  ctidx;
	__u8  cflag;
	__u16 weight;
	__u64 acc_time;
	__u64 lp_time;
} __packed;

struct diag204_x_cpu_info {
	__u16 cpu_addr;
	char  reserved1[2];
	__u8  ctidx;
	__u8  cflag;
	__u16 weight;
	__u64 acc_time;
	__u64 lp_time;
	__u16 min_weight;
	__u16 cur_weight;
	__u16 max_weight;
	char  reseved2[2];
	__u64 online_time;
	__u64 wait_time;
	__u32 pma_weight;
	__u32 polar_weight;
	__u32 cpu_type_cap;
	__u32 group_cpu_type_cap;
	char  reserved3[32];
} __packed;

struct diag204_phys_hdr {
	char reserved1[1];
	__u8 cpus;
	char reserved2[6];
	char mgm_name[8];
} __packed;

struct diag204_x_phys_hdr {
	char reserved1[1];
	__u8 cpus;
	char reserved2[6];
	char mgm_name[8];
	char reserved3[80];
} __packed;

struct diag204_phys_cpu {
	__u16 cpu_addr;
	char  reserved1[2];
	__u8  ctidx;
	char  reserved2[3];
	__u64 mgm_time;
	char  reserved3[8];
} __packed;

struct diag204_x_phys_cpu {
	__u16 cpu_addr;
	char  reserved1[2];
	__u8  ctidx;
	char  reserved2[1];
	__u16 weight;
	__u64 mgm_time;
	char  reserved3[80];
} __packed;

struct diag204_x_part_block {
	struct diag204_x_part_hdr hdr;
	struct diag204_x_cpu_info cpus[];
} __packed;

struct diag204_x_phys_block {
	struct diag204_x_phys_hdr hdr;
	struct diag204_x_phys_cpu cpus[];
} __packed;

int diag204(unsigned long subcode, unsigned long size, void *addr);
int diag224(void *ptr);
#endif /* _ASM_S390_DIAG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *  Copyright IBM Corp. 2014
 *
 *  Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
 */

#ifndef _S390_IDLE_H
#define _S390_IDLE_H

#include <linux/types.h>
#include <linux/device.h>
#include <linux/seqlock.h>

struct s390_idle_data {
	seqcount_t seqcount;
	unsigned long long idle_count;
	unsigned long long idle_time;
	unsigned long long clock_idle_enter;
	unsigned long long clock_idle_exit;
	unsigned long long timer_idle_enter;
	unsigned long long timer_idle_exit;
};

extern struct device_attribute dev_attr_idle_count;
extern struct device_attribute dev_attr_idle_time_us;

void psw_idle(struct s390_idle_data *, unsigned long);

#endif /* _S390_IDLE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *  S390 version
 *
 *  Derived from "include/asm-i386/mmu_context.h"
 */

#ifndef __S390_MMU_CONTEXT_H
#define __S390_MMU_CONTEXT_H

#include <asm/pgalloc.h>
#include <asm/uaccess.h>
#include <asm/tlbflush.h>
#include <asm/ctl_reg.h>

static inline int init_new_context(struct task_struct *tsk,
				   struct mm_struct *mm)
{
	spin_lock_init(&mm->context.lock);
	spin_lock_init(&mm->context.pgtable_lock);
	INIT_LIST_HEAD(&mm->context.pgtable_list);
	spin_lock_init(&mm->context.gmap_lock);
	INIT_LIST_HEAD(&mm->context.gmap_list);
	cpumask_clear(&mm->context.cpu_attach_mask);
	atomic_set(&mm->context.flush_count, 0);
	mm->context.gmap_asce = 0;
	mm->context.flush_mm = 0;
#ifdef CONFIG_PGSTE
	mm->context.alloc_pgste = page_table_allocate_pgste;
	mm->context.has_pgste = 0;
	mm->context.use_skey = 0;
#endif
	switch (mm->context.asce_limit) {
	case 1UL << 42:
		/*
		 * forked 3-level task, fall through to set new asce with new
		 * mm->pgd
		 */
	case 0:
		/* context created by exec, set asce limit to 4TB */
		mm->context.asce_limit = STACK_TOP_MAX;
		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
				   _ASCE_USER_BITS | _ASCE_TYPE_REGION3;
		break;
	case 1UL << 53:
		/* forked 4-level task, set new asce with new mm->pgd */
		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
				   _ASCE_USER_BITS | _ASCE_TYPE_REGION2;
		break;
	case 1UL << 31:
		/* forked 2-level compat task, set new asce with new mm->pgd */
		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
				   _ASCE_USER_BITS | _ASCE_TYPE_SEGMENT;
		/* pgd_alloc() did not increase mm->nr_pmds */
		mm_inc_nr_pmds(mm);
	}
	crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));
	return 0;
}

#define destroy_context(mm)             do { } while (0)

static inline void set_user_asce(struct mm_struct *mm)
{
	S390_lowcore.user_asce = mm->context.asce;
	if (current->thread.mm_segment.ar4)
		__ctl_load(S390_lowcore.user_asce, 7, 7);
	set_cpu_flag(CIF_ASCE);
}

static inline void clear_user_asce(void)
{
	S390_lowcore.user_asce = S390_lowcore.kernel_asce;

	__ctl_load(S390_lowcore.user_asce, 1, 1);
	__ctl_load(S390_lowcore.user_asce, 7, 7);
}

static inline void load_kernel_asce(void)
{
	unsigned long asce;

	__ctl_store(asce, 1, 1);
	if (asce != S390_lowcore.kernel_asce)
		__ctl_load(S390_lowcore.kernel_asce, 1, 1);
	set_cpu_flag(CIF_ASCE);
}

static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
			     struct task_struct *tsk)
{
	int cpu = smp_processor_id();

	S390_lowcore.user_asce = next->context.asce;
	if (prev == next)
		return;
	cpumask_set_cpu(cpu, &next->context.cpu_attach_mask);
	/* Clear old ASCE by loading the kernel ASCE. */
	__ctl_load(S390_lowcore.kernel_asce, 1, 1);
	__ctl_load(S390_lowcore.kernel_asce, 7, 7);
	cpumask_clear_cpu(cpu, &prev->context.cpu_attach_mask);
}

#define finish_arch_post_lock_switch finish_arch_post_lock_switch
static inline void finish_arch_post_lock_switch(void)
{
	struct task_struct *tsk = current;
	struct mm_struct *mm = tsk->mm;

	load_kernel_asce();
	if (mm) {
		preempt_disable();
		while (atomic_read(&mm->context.flush_count))
			cpu_relax();
		cpumask_set_cpu(smp_processor_id(), mm_cpumask(mm));
		__tlb_flush_mm_lazy(mm);
		preempt_enable();
	}
	set_fs(current->thread.mm_segment);
}

#define enter_lazy_tlb(mm,tsk)	do { } while (0)
#define deactivate_mm(tsk,mm)	do { } while (0)

static inline void activate_mm(struct mm_struct *prev,
                               struct mm_struct *next)
{
	switch_mm(prev, next, current);
	cpumask_set_cpu(smp_processor_id(), mm_cpumask(next));
	set_user_asce(next);
}

static inline void arch_dup_mmap(struct mm_struct *oldmm,
				 struct mm_struct *mm)
{
}

static inline void arch_exit_mmap(struct mm_struct *mm)
{
}

static inline void arch_unmap(struct mm_struct *mm,
			struct vm_area_struct *vma,
			unsigned long start, unsigned long end)
{
}

static inline void arch_bprm_mm_init(struct mm_struct *mm,
				     struct vm_area_struct *vma)
{
}

static inline bool arch_vma_access_permitted(struct vm_area_struct *vma,
		bool write, bool execute, bool foreign)
{
	/* by default, allow everything */
	return true;
}

static inline bool arch_pte_access_permitted(pte_t pte, bool write)
{
	/* by default, allow everything */
	return true;
}
#endif /* __S390_MMU_CONTEXT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef _ASM_S390_SPARSEMEM_H
#define _ASM_S390_SPARSEMEM_H

#define SECTION_SIZE_BITS	28
#define MAX_PHYSMEM_BITS	46

#endif /* _ASM_S390_SPARSEMEM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 *  IBM System z Huge TLB Page Support for Kernel.
 *
 *    Copyright IBM Corp. 2008
 *    Author(s): Gerald Schaefer <gerald.schaefer@de.ibm.com>
 */

#ifndef _ASM_S390_HUGETLB_H
#define _ASM_S390_HUGETLB_H

#include <asm/page.h>
#include <asm/pgtable.h>


#define is_hugepage_only_range(mm, addr, len)	0
#define hugetlb_free_pgd_range			free_pgd_range
#define hugepages_supported()			(MACHINE_HAS_HPAGE)

void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,
		     pte_t *ptep, pte_t pte);
pte_t huge_ptep_get(pte_t *ptep);
pte_t huge_ptep_get_and_clear(struct mm_struct *mm,
			      unsigned long addr, pte_t *ptep);

/*
 * If the arch doesn't supply something else, assume that hugepage
 * size aligned regions are ok without further preparation.
 */
static inline int prepare_hugepage_range(struct file *file,
			unsigned long addr, unsigned long len)
{
	if (len & ~HPAGE_MASK)
		return -EINVAL;
	if (addr & ~HPAGE_MASK)
		return -EINVAL;
	return 0;
}

#define arch_clear_hugepage_flags(page)		do { } while (0)

static inline void huge_pte_clear(struct mm_struct *mm, unsigned long addr,
				  pte_t *ptep)
{
	if ((pte_val(*ptep) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R3)
		pte_val(*ptep) = _REGION3_ENTRY_EMPTY;
	else
		pte_val(*ptep) = _SEGMENT_ENTRY_EMPTY;
}

static inline void huge_ptep_clear_flush(struct vm_area_struct *vma,
					 unsigned long address, pte_t *ptep)
{
	huge_ptep_get_and_clear(vma->vm_mm, address, ptep);
}

static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,
					     unsigned long addr, pte_t *ptep,
					     pte_t pte, int dirty)
{
	int changed = !pte_same(huge_ptep_get(ptep), pte);
	if (changed) {
		huge_ptep_get_and_clear(vma->vm_mm, addr, ptep);
		set_huge_pte_at(vma->vm_mm, addr, ptep, pte);
	}
	return changed;
}

static inline void huge_ptep_set_wrprotect(struct mm_struct *mm,
					   unsigned long addr, pte_t *ptep)
{
	pte_t pte = huge_ptep_get_and_clear(mm, addr, ptep);
	set_huge_pte_at(mm, addr, ptep, pte_wrprotect(pte));
}

static inline pte_t mk_huge_pte(struct page *page, pgprot_t pgprot)
{
	return mk_pte(page, pgprot);
}

static inline int huge_pte_none(pte_t pte)
{
	return pte_none(pte);
}

static inline int huge_pte_write(pte_t pte)
{
	return pte_write(pte);
}

static inline int huge_pte_dirty(pte_t pte)
{
	return pte_dirty(pte);
}

static inline pte_t huge_pte_mkwrite(pte_t pte)
{
	return pte_mkwrite(pte);
}

static inline pte_t huge_pte_mkdirty(pte_t pte)
{
	return pte_mkdirty(pte);
}

static inline pte_t huge_pte_wrprotect(pte_t pte)
{
	return pte_wrprotect(pte);
}

static inline pte_t huge_pte_modify(pte_t pte, pgprot_t newprot)
{
	return pte_modify(pte, newprot);
}

#endif /* _ASM_S390_HUGETLB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _ASM_S390_BUG_H
#define _ASM_S390_BUG_H

#include <linux/kernel.h>

#ifdef CONFIG_BUG

#ifdef CONFIG_DEBUG_BUGVERBOSE

#define __EMIT_BUG(x) do {					\
	asm volatile(						\
		"0:	j	0b+2\n"				\
		"1:\n"						\
		".section .rodata.str,\"aMS\",@progbits,1\n"	\
		"2:	.asciz	\""__FILE__"\"\n"		\
		".previous\n"					\
		".section __bug_table,\"a\"\n"			\
		"3:	.long	1b-3b,2b-3b\n"			\
		"	.short	%0,%1\n"			\
		"	.org	3b+%2\n"			\
		".previous\n"					\
		: : "i" (__LINE__),				\
		    "i" (x),					\
		    "i" (sizeof(struct bug_entry)));		\
} while (0)

#else /* CONFIG_DEBUG_BUGVERBOSE */

#define __EMIT_BUG(x) do {				\
	asm volatile(					\
		"0:	j	0b+2\n"			\
		"1:\n"					\
		".section __bug_table,\"a\"\n"		\
		"2:	.long	1b-2b\n"		\
		"	.short	%0\n"			\
		"	.org	2b+%1\n"		\
		".previous\n"				\
		: : "i" (x),				\
		    "i" (sizeof(struct bug_entry)));	\
} while (0)

#endif /* CONFIG_DEBUG_BUGVERBOSE */

#define BUG() do {					\
	__EMIT_BUG(0);					\
	unreachable();					\
} while (0)

#define __WARN_TAINT(taint) do {			\
	__EMIT_BUG(BUGFLAG_TAINT(taint));		\
} while (0)

#define WARN_ON(x) ({					\
	int __ret_warn_on = !!(x);			\
	if (__builtin_constant_p(__ret_warn_on)) {	\
		if (__ret_warn_on)			\
			__WARN();			\
	} else {					\
		if (unlikely(__ret_warn_on))		\
			__WARN();			\
	}						\
	unlikely(__ret_warn_on);			\
})

#define HAVE_ARCH_BUG
#define HAVE_ARCH_WARN_ON
#endif /* CONFIG_BUG */

#include <asm-generic/bug.h>

#endif /* _ASM_S390_BUG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * OS info memory interface
 *
 * Copyright IBM Corp. 2012
 * Author(s): Michael Holzheu <holzheu@linux.vnet.ibm.com>
 */
#ifndef _ASM_S390_OS_INFO_H
#define _ASM_S390_OS_INFO_H

#define OS_INFO_VERSION_MAJOR	1
#define OS_INFO_VERSION_MINOR	1
#define OS_INFO_MAGIC		0x4f53494e464f535aULL /* OSINFOSZ */

#define OS_INFO_VMCOREINFO	0
#define OS_INFO_REIPL_BLOCK	1

struct os_info_entry {
	u64	addr;
	u64	size;
	u32	csum;
} __packed;

struct os_info {
	u64	magic;
	u32	csum;
	u16	version_major;
	u16	version_minor;
	u64	crashkernel_addr;
	u64	crashkernel_size;
	struct os_info_entry entry[2];
	u8	reserved[4024];
} __packed;

void os_info_init(void);
void os_info_entry_add(int nr, void *ptr, u64 len);
void os_info_crashkernel_add(unsigned long base, unsigned long size);
u32 os_info_csum(struct os_info *os_info);

#ifdef CONFIG_CRASH_DUMP
void *os_info_old_entry(int nr, unsigned long *size);
int copy_oldmem_kernel(void *dst, void *src, size_t count);
#else
static inline void *os_info_old_entry(int nr, unsigned long *size)
{
	return NULL;
}
#endif

#endif /* _ASM_S390_OS_INFO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef _ASM_S390_DMA_H
#define _ASM_S390_DMA_H

#include <asm/io.h>

/*
 * MAX_DMA_ADDRESS is ambiguous because on s390 its completely unrelated
 * to DMA. It _is_ used for the s390 memory zone split at 2GB caused
 * by the 31 bit heritage.
 */
#define MAX_DMA_ADDRESS         0x80000000

#ifdef CONFIG_PCI
extern int isa_dma_bridge_buggy;
#else
#define isa_dma_bridge_buggy	(0)
#endif

#endif /* _ASM_S390_DMA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 *  S390 version
 *    Copyright IBM Corp. 1999, 2000
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
 *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
 *
 *  Derived from "include/asm-i386/hardirq.h"
 */

#ifndef __ASM_HARDIRQ_H
#define __ASM_HARDIRQ_H

#include <asm/lowcore.h>

#define local_softirq_pending() (S390_lowcore.softirq_pending)

#define __ARCH_IRQ_STAT
#define __ARCH_HAS_DO_SOFTIRQ
#define __ARCH_IRQ_EXIT_IRQS_DISABLED

static inline void ack_bad_irq(unsigned int irq)
{
	printk(KERN_CRIT "unexpected IRQ trap at vector %02x\n", irq);
}

#endif /* __ASM_HARDIRQ_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef __S390_ASM_SIGP_H
#define __S390_ASM_SIGP_H

/* SIGP order codes */
#define SIGP_SENSE		      1
#define SIGP_EXTERNAL_CALL	      2
#define SIGP_EMERGENCY_SIGNAL	      3
#define SIGP_START		      4
#define SIGP_STOP		      5
#define SIGP_RESTART		      6
#define SIGP_STOP_AND_STORE_STATUS    9
#define SIGP_INITIAL_CPU_RESET	     11
#define SIGP_CPU_RESET		     12
#define SIGP_SET_PREFIX		     13
#define SIGP_STORE_STATUS_AT_ADDRESS 14
#define SIGP_SET_ARCHITECTURE	     18
#define SIGP_COND_EMERGENCY_SIGNAL   19
#define SIGP_SENSE_RUNNING	     21
#define SIGP_SET_MULTI_THREADING     22
#define SIGP_STORE_ADDITIONAL_STATUS 23

/* SIGP condition codes */
#define SIGP_CC_ORDER_CODE_ACCEPTED 0
#define SIGP_CC_STATUS_STORED	    1
#define SIGP_CC_BUSY		    2
#define SIGP_CC_NOT_OPERATIONAL	    3

/* SIGP cpu status bits */

#define SIGP_STATUS_INVALID_ORDER	0x00000002UL
#define SIGP_STATUS_CHECK_STOP		0x00000010UL
#define SIGP_STATUS_STOPPED		0x00000040UL
#define SIGP_STATUS_EXT_CALL_PENDING	0x00000080UL
#define SIGP_STATUS_INVALID_PARAMETER	0x00000100UL
#define SIGP_STATUS_INCORRECT_STATE	0x00000200UL
#define SIGP_STATUS_NOT_RUNNING		0x00000400UL

#ifndef __ASSEMBLY__

static inline int ____pcpu_sigp(u16 addr, u8 order, unsigned long parm,
				u32 *status)
{
	register unsigned long reg1 asm ("1") = parm;
	int cc;

	asm volatile(
		"	sigp	%1,%2,0(%3)\n"
		"	ipm	%0\n"
		"	srl	%0,28\n"
		: "=d" (cc), "+d" (reg1) : "d" (addr), "a" (order) : "cc");
	*status = reg1;
	return cc;
}

static inline int __pcpu_sigp(u16 addr, u8 order, unsigned long parm,
			      u32 *status)
{
	u32 _status;
	int cc;

	cc = ____pcpu_sigp(addr, order, parm, &_status);
	if (status && cc == 1)
		*status = _status;
	return cc;
}

#endif /* __ASSEMBLY__ */

#endif /* __S390_ASM_SIGP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef __ASM_LINKAGE_H
#define __ASM_LINKAGE_H

#include <linux/stringify.h>

#define __ALIGN .align 4, 0x07
#define __ALIGN_STR __stringify(__ALIGN)

#ifndef __ASSEMBLY__

/*
 * Helper macro for exception table entries
 */
#define EX_TABLE(_fault, _target)	\
	".section __ex_table,\"a\"\n"	\
	".align	4\n"			\
	".long	(" #_fault ") - .\n"	\
	".long	(" #_target ") - .\n"	\
	".previous\n"

#else /* __ASSEMBLY__ */

#define EX_TABLE(_fault, _target)	\
	.section __ex_table,"a"	;	\
	.align	4 ;			\
	.long	(_fault) - . ;		\
	.long	(_target) - . ;		\
	.previous

#endif /* __ASSEMBLY__ */
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Disassemble s390 instructions.
 *
 * Copyright IBM Corp. 2007
 * Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
 */

#ifndef __ASM_S390_DIS_H__
#define __ASM_S390_DIS_H__

/* Type of operand */
#define OPERAND_GPR	0x1	/* Operand printed as %rx */
#define OPERAND_FPR	0x2	/* Operand printed as %fx */
#define OPERAND_AR	0x4	/* Operand printed as %ax */
#define OPERAND_CR	0x8	/* Operand printed as %cx */
#define OPERAND_VR	0x10	/* Operand printed as %vx */
#define OPERAND_DISP	0x20	/* Operand printed as displacement */
#define OPERAND_BASE	0x40	/* Operand printed as base register */
#define OPERAND_INDEX	0x80	/* Operand printed as index register */
#define OPERAND_PCREL	0x100	/* Operand printed as pc-relative symbol */
#define OPERAND_SIGNED	0x200	/* Operand printed as signed value */
#define OPERAND_LENGTH	0x400	/* Operand printed as length (+1) */


struct s390_operand {
	int bits;		/* The number of bits in the operand. */
	int shift;		/* The number of bits to shift. */
	int flags;		/* One bit syntax flags. */
};

struct s390_insn {
	const char name[5];
	unsigned char opfrag;
	unsigned char format;
};


static inline int insn_length(unsigned char code)
{
	return ((((int) code + 64) >> 7) + 1) << 1;
}

void show_code(struct pt_regs *regs);
void print_fn_code(unsigned char *code, unsigned long len);
int insn_to_mnemonic(unsigned char *instruction, char *buf, unsigned int len);
struct s390_insn *find_insn(unsigned char *code);

static inline int is_known_insn(unsigned char *code)
{
	return !!find_insn(code);
}

#endif /* __ASM_S390_DIS_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 *  Copyright IBM Corp. 2004
 *
 *  Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
 */

#ifndef _S390_CPUTIME_H
#define _S390_CPUTIME_H

#include <linux/types.h>
#include <asm/div64.h>

#define CPUTIME_PER_USEC 4096ULL
#define CPUTIME_PER_SEC (CPUTIME_PER_USEC * USEC_PER_SEC)

/* We want to use full resolution of the CPU timer: 2**-12 micro-seconds. */

typedef unsigned long long __nocast cputime_t;
typedef unsigned long long __nocast cputime64_t;

#define cmpxchg_cputime(ptr, old, new) cmpxchg64(ptr, old, new)

static inline unsigned long __div(unsigned long long n, unsigned long base)
{
	return n / base;
}

#define cputime_one_jiffy		jiffies_to_cputime(1)

/*
 * Convert cputime to jiffies and back.
 */
static inline unsigned long cputime_to_jiffies(const cputime_t cputime)
{
	return __div((__force unsigned long long) cputime, CPUTIME_PER_SEC / HZ);
}

static inline cputime_t jiffies_to_cputime(const unsigned int jif)
{
	return (__force cputime_t)(jif * (CPUTIME_PER_SEC / HZ));
}

static inline u64 cputime64_to_jiffies64(cputime64_t cputime)
{
	unsigned long long jif = (__force unsigned long long) cputime;
	do_div(jif, CPUTIME_PER_SEC / HZ);
	return jif;
}

static inline cputime64_t jiffies64_to_cputime64(const u64 jif)
{
	return (__force cputime64_t)(jif * (CPUTIME_PER_SEC / HZ));
}

/*
 * Convert cputime to microseconds and back.
 */
static inline unsigned int cputime_to_usecs(const cputime_t cputime)
{
	return (__force unsigned long long) cputime >> 12;
}

static inline cputime_t usecs_to_cputime(const unsigned int m)
{
	return (__force cputime_t)(m * CPUTIME_PER_USEC);
}

#define usecs_to_cputime64(m)		usecs_to_cputime(m)

/*
 * Convert cputime to milliseconds and back.
 */
static inline unsigned int cputime_to_secs(const cputime_t cputime)
{
	return __div((__force unsigned long long) cputime, CPUTIME_PER_SEC / 2) >> 1;
}

static inline cputime_t secs_to_cputime(const unsigned int s)
{
	return (__force cputime_t)(s * CPUTIME_PER_SEC);
}

/*
 * Convert cputime to timespec and back.
 */
static inline cputime_t timespec_to_cputime(const struct timespec *value)
{
	unsigned long long ret = value->tv_sec * CPUTIME_PER_SEC;
	return (__force cputime_t)(ret + __div(value->tv_nsec * CPUTIME_PER_USEC, NSEC_PER_USEC));
}

static inline void cputime_to_timespec(const cputime_t cputime,
				       struct timespec *value)
{
	unsigned long long __cputime = (__force unsigned long long) cputime;
	value->tv_nsec = (__cputime % CPUTIME_PER_SEC) * NSEC_PER_USEC / CPUTIME_PER_USEC;
	value->tv_sec = __cputime / CPUTIME_PER_SEC;
}

/*
 * Convert cputime to timeval and back.
 * Since cputime and timeval have the same resolution (microseconds)
 * this is easy.
 */
static inline cputime_t timeval_to_cputime(const struct timeval *value)
{
	unsigned long long ret = value->tv_sec * CPUTIME_PER_SEC;
	return (__force cputime_t)(ret + value->tv_usec * CPUTIME_PER_USEC);
}

static inline void cputime_to_timeval(const cputime_t cputime,
				      struct timeval *value)
{
	unsigned long long __cputime = (__force unsigned long long) cputime;
	value->tv_usec = (__cputime % CPUTIME_PER_SEC) / CPUTIME_PER_USEC;
	value->tv_sec = __cputime / CPUTIME_PER_SEC;
}

/*
 * Convert cputime to clock and back.
 */
static inline clock_t cputime_to_clock_t(cputime_t cputime)
{
	unsigned long long clock = (__force unsigned long long) cputime;
	do_div(clock, CPUTIME_PER_SEC / USER_HZ);
	return clock;
}

static inline cputime_t clock_t_to_cputime(unsigned long x)
{
	return (__force cputime_t)(x * (CPUTIME_PER_SEC / USER_HZ));
}

/*
 * Convert cputime64 to clock.
 */
static inline clock_t cputime64_to_clock_t(cputime64_t cputime)
{
	unsigned long long clock = (__force unsigned long long) cputime;
	do_div(clock, CPUTIME_PER_SEC / USER_HZ);
	return clock;
}

cputime64_t arch_cpu_idle_time(int cpu);

#define arch_idle_time(cpu) arch_cpu_idle_time(cpu)

#endif /* _S390_CPUTIME_H */
                                                                                                                                                                                             #ifndef _ASM_S390X_COMPAT_H
#define _ASM_S390X_COMPAT_H
/*
 * Architecture specific compatibility types
 */
#include <linux/types.h>
#include <linux/sched.h>
#include <linux/thread_info.h>

#define __TYPE_IS_PTR(t) (!__builtin_types_compatible_p(typeof(0?(t)0:0ULL), u64))

#define __SC_DELOUSE(t,v) ({ \
	BUILD_BUG_ON(sizeof(t) > 4 && !__TYPE_IS_PTR(t)); \
	(t)(__TYPE_IS_PTR(t) ? ((v) & 0x7fffffff) : (v)); \
})

#define PSW32_MASK_PER		0x40000000UL
#define PSW32_MASK_DAT		0x04000000UL
#define PSW32_MASK_IO		0x02000000UL
#define PSW32_MASK_EXT		0x01000000UL
#define PSW32_MASK_KEY		0x00F00000UL
#define PSW32_MASK_BASE		0x00080000UL	/* Always one */
#define PSW32_MASK_MCHECK	0x00040000UL
#define PSW32_MASK_WAIT		0x00020000UL
#define PSW32_MASK_PSTATE	0x00010000UL
#define PSW32_MASK_ASC		0x0000C000UL
#define PSW32_MASK_CC		0x00003000UL
#define PSW32_MASK_PM		0x00000f00UL
#define PSW32_MASK_RI		0x00000080UL

#define PSW32_MASK_USER		0x0000FF00UL

#define PSW32_ADDR_AMODE	0x80000000UL
#define PSW32_ADDR_INSN		0x7FFFFFFFUL

#define PSW32_DEFAULT_KEY	(((u32) PAGE_DEFAULT_ACC) << 20)

#define PSW32_ASC_PRIMARY	0x00000000UL
#define PSW32_ASC_ACCREG	0x00004000UL
#define PSW32_ASC_SECONDARY	0x00008000UL
#define PSW32_ASC_HOME		0x0000C000UL

#define PSW32_USER_BITS (PSW32_MASK_DAT | PSW32_MASK_IO | PSW32_MASK_EXT | \
			 PSW32_DEFAULT_KEY | PSW32_MASK_BASE | \
			 PSW32_MASK_MCHECK | PSW32_MASK_PSTATE | \
			 PSW32_ASC_PRIMARY)

#define COMPAT_USER_HZ		100
#define COMPAT_UTS_MACHINE	"s390\0\0\0\0"

typedef u32		compat_size_t;
typedef s32		compat_ssize_t;
typedef s32		compat_time_t;
typedef s32		compat_clock_t;
typedef s32		compat_pid_t;
typedef u16		__compat_uid_t;
typedef u16		__compat_gid_t;
typedef u32		__compat_uid32_t;
typedef u32		__compat_gid32_t;
typedef u16		compat_mode_t;
typedef u32		compat_ino_t;
typedef u16		compat_dev_t;
typedef s32		compat_off_t;
typedef s64		compat_loff_t;
typedef u16		compat_nlink_t;
typedef u16		compat_ipc_pid_t;
typedef s32		compat_daddr_t;
typedef u32		compat_caddr_t;
typedef __kernel_fsid_t	compat_fsid_t;
typedef s32		compat_key_t;
typedef s32		compat_timer_t;

typedef s32		compat_int_t;
typedef s32		compat_long_t;
typedef s64		compat_s64;
typedef u32		compat_uint_t;
typedef u32		compat_ulong_t;
typedef u64		compat_u64;
typedef u32		compat_uptr_t;

typedef struct {
	u32 mask;
	u32 addr;
} __aligned(8) psw_compat_t;

typedef struct {
	psw_compat_t psw;
	u32 gprs[NUM_GPRS];
	u32 acrs[NUM_ACRS];
	u32 orig_gpr2;
} s390_compat_regs;

typedef struct {
	u32 gprs_high[NUM_GPRS];
} s390_compat_regs_high;

struct compat_timespec {
	compat_time_t	tv_sec;
	s32		tv_nsec;
};

struct compat_timeval {
	compat_time_t	tv_sec;
	s32		tv_usec;
};

struct compat_stat {
	compat_dev_t	st_dev;
	u16		__pad1;
	compat_ino_t	st_ino;
	compat_mode_t	st_mode;
	compat_nlink_t	st_nlink;
	__compat_uid_t	st_uid;
	__compat_gid_t	st_gid;
	compat_dev_t	st_rdev;
	u16		__pad2;
	u32		st_size;
	u32		st_blksize;
	u32		st_blocks;
	u32		st_atime;
	u32		st_atime_nsec;
	u32		st_mtime;
	u32		st_mtime_nsec;
	u32		st_ctime;
	u32		st_ctime_nsec;
	u32		__unused4;
	u32		__unused5;
};

struct compat_flock {
	short		l_type;
	short		l_whence;
	compat_off_t	l_start;
	compat_off_t	l_len;
	compat_pid_t	l_pid;
};

#define F_GETLK64       12
#define F_SETLK64       13
#define F_SETLKW64      14    

struct compat_flock64 {
	short		l_type;
	short		l_whence;
	compat_loff_t	l_start;
	compat_loff_t	l_len;
	compat_pid_t	l_pid;
};

struct compat_statfs {
	u32		f_type;
	u32		f_bsize;
	u32		f_blocks;
	u32		f_bfree;
	u32		f_bavail;
	u32		f_files;
	u32		f_ffree;
	compat_fsid_t	f_fsid;
	u32		f_namelen;
	u32		f_frsize;
	u32		f_flags;
	u32		f_spare[4];
};

struct compat_statfs64 {
	u32		f_type;
	u32		f_bsize;
	u64		f_blocks;
	u64		f_bfree;
	u64		f_bavail;
	u64		f_files;
	u64		f_ffree;
	compat_fsid_t	f_fsid;
	u32		f_namelen;
	u32		f_frsize;
	u32		f_flags;
	u32		f_spare[4];
};

#define COMPAT_RLIM_OLD_INFINITY	0x7fffffff
#define COMPAT_RLIM_INFINITY		0xffffffff

typedef u32		compat_old_sigset_t;	/* at least 32 bits */

#define _COMPAT_NSIG		64
#define _COMPAT_NSIG_BPW	32

typedef u32		compat_sigset_word;

typedef union compat_sigval {
	compat_int_t	sival_int;
	compat_uptr_t	sival_ptr;
} compat_sigval_t;

typedef struct compat_siginfo {
	int	si_signo;
	int	si_errno;
	int	si_code;

	union {
		int _pad[128/sizeof(int) - 3];

		/* kill() */
		struct {
			pid_t	_pid;	/* sender's pid */
			uid_t	_uid;	/* sender's uid */
		} _kill;

		/* POSIX.1b timers */
		struct {
			compat_timer_t _tid;		/* timer id */
			int _overrun;			/* overrun count */
			compat_sigval_t _sigval;	/* same as below */
			int _sys_private;	/* not to be passed to user */
		} _timer;

		/* POSIX.1b signals */
		struct {
			pid_t			_pid;	/* sender's pid */
			uid_t			_uid;	/* sender's uid */
			compat_sigval_t		_sigval;
		} _rt;

		/* SIGCHLD */
		struct {
			pid_t			_pid;	/* which child */
			uid_t			_uid;	/* sender's uid */
			int			_status;/* exit code */
			compat_clock_t		_utime;
			compat_clock_t		_stime;
		} _sigchld;

		/* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
		struct {
			__u32	_addr;	/* faulting insn/memory ref. - pointer */
		} _sigfault;

		/* SIGPOLL */
		struct {
			int	_band;	/* POLL_IN, POLL_OUT, POLL_MSG */
			int	_fd;
		} _sigpoll;
	} _sifields;
} compat_siginfo_t;

/*
 * How these fields are to be accessed.
 */
#define si_pid		_sifields._kill._pid
#define si_uid		_sifields._kill._uid
#define si_status	_sifields._sigchld._status
#define si_utime	_sifields._sigchld._utime
#define si_stime	_sifields._sigchld._stime
#define si_value	_sifields._rt._sigval
#define si_int		_sifields._rt._sigval.sival_int
#define si_ptr		_sifields._rt._sigval.sival_ptr
#define si_addr		_sifields._sigfault._addr
#define si_band		_sifields._sigpoll._band
#define si_fd		_sifields._sigpoll._fd
#define si_tid		_sifields._timer._tid
#define si_overrun	_sifields._timer._overrun

#define COMPAT_OFF_T_MAX	0x7fffffff
#define COMPAT_LOFF_T_MAX	0x7fffffffffffffffL

/*
 * A pointer passed in from user mode. This should not
 * be used for syscall parameters, just declare them
 * as pointers because the syscall entry code will have
 * appropriately converted them already.
 */

static inline void __user *compat_ptr(compat_uptr_t uptr)
{
	return (void __user *)(unsigned long)(uptr & 0x7fffffffUL);
}

static inline compat_uptr_t ptr_to_compat(void __user *uptr)
{
	return (u32)(unsigned long)uptr;
}

#ifdef CONFIG_COMPAT

static inline int is_compat_task(void)
{
	return test_thread_flag(TIF_31BIT);
}

static inline void __user *arch_compat_alloc_user_space(long len)
{
	unsigned long stack;

	stack = KSTK_ESP(current);
	if (is_compat_task())
		stack &= 0x7fffffffUL;
	return (void __user *) (stack - len);
}

#endif

struct compat_ipc64_perm {
	compat_key_t key;
	__compat_uid32_t uid;
	__compat_gid32_t gid;
	__compat_uid32_t cuid;
	__compat_gid32_t cgid;
	compat_mode_t mode;
	unsigned short __pad1;
	unsigned short seq;
	unsigned short __pad2;
	unsigned int __unused1;
	unsigned int __unused2;
};

struct compat_semid64_ds {
	struct compat_ipc64_perm sem_perm;
	compat_time_t  sem_otime;
	compat_ulong_t __pad1;
	compat_time_t  sem_ctime;
	compat_ulong_t __pad2;
	compat_ulong_t sem_nsems;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
};

struct compat_msqid64_ds {
	struct compat_ipc64_perm msg_perm;
	compat_time_t   msg_stime;
	compat_ulong_t __pad1;
	compat_time_t   msg_rtime;
	compat_ulong_t __pad2;
	compat_time_t   msg_ctime;
	compat_ulong_t __pad3;
	compat_ulong_t msg_cbytes;
	compat_ulong_t msg_qnum;
	compat_ulong_t msg_qbytes;
	compat_pid_t   msg_lspid;
	compat_pid_t   msg_lrpid;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
};

struct compat_shmid64_ds {
	struct compat_ipc64_perm shm_perm;
	compat_size_t  shm_segsz;
	compat_time_t  shm_atime;
	compat_ulong_t __pad1;
	compat_time_t  shm_dtime;
	compat_ulong_t __pad2;
	compat_time_t  shm_ctime;
	compat_ulong_t __pad3;
	compat_pid_t   shm_cpid;
	compat_pid_t   shm_lpid;
	compat_ulong_t shm_nattch;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
};
#endif /* _ASM_S390X_COMPAT_H */
                                                                                                          #ifndef _ASM_EMERGENCY_RESTART_H
#define _ASM_EMERGENCY_RESTART_H

#include <asm-generic/emergency-restart.h>

#endif /* _ASM_EMERGENCY_RESTART_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *    Copyright IBM Corp. 2007
 *    Author(s): Heiko Carstens <heiko.carstens@de.ibm.com>
 */

#ifndef _ASM_S390_SCLP_H
#define _ASM_S390_SCLP_H

#include <linux/types.h>
#include <asm/chpid.h>
#include <asm/cpu.h>

#define SCLP_CHP_INFO_MASK_SIZE		32
#define SCLP_MAX_CORES			256

struct sclp_chp_info {
	u8 recognized[SCLP_CHP_INFO_MASK_SIZE];
	u8 standby[SCLP_CHP_INFO_MASK_SIZE];
	u8 configured[SCLP_CHP_INFO_MASK_SIZE];
};

#define LOADPARM_LEN 8

struct sclp_ipl_info {
	int is_valid;
	int has_dump;
	char loadparm[LOADPARM_LEN];
};

struct sclp_core_entry {
	u8 core_id;
	u8 reserved0;
	u8 : 4;
	u8 sief2 : 1;
	u8 skey : 1;
	u8 : 2;
	u8 : 2;
	u8 gpere : 1;
	u8 siif : 1;
	u8 sigpif : 1;
	u8 : 3;
	u8 reserved2[3];
	u8 : 2;
	u8 ib : 1;
	u8 cei : 1;
	u8 : 4;
	u8 reserved3[6];
	u8 type;
	u8 reserved1;
} __attribute__((packed));

struct sclp_core_info {
	unsigned int configured;
	unsigned int standby;
	unsigned int combined;
	struct sclp_core_entry core[SCLP_MAX_CORES];
};

struct sclp_info {
	unsigned char has_linemode : 1;
	unsigned char has_vt220 : 1;
	unsigned char has_siif : 1;
	unsigned char has_sigpif : 1;
	unsigned char has_core_type : 1;
	unsigned char has_sprp : 1;
	unsigned char has_hvs : 1;
	unsigned char has_esca : 1;
	unsigned char has_sief2 : 1;
	unsigned char has_64bscao : 1;
	unsigned char has_gpere : 1;
	unsigned char has_cmma : 1;
	unsigned char has_gsls : 1;
	unsigned char has_ib : 1;
	unsigned char has_cei : 1;
	unsigned char has_pfmfi : 1;
	unsigned char has_ibs : 1;
	unsigned char has_skey : 1;
	unsigned int ibc;
	unsigned int mtid;
	unsigned int mtid_cp;
	unsigned int mtid_prev;
	unsigned long rzm;
	unsigned long rnmax;
	unsigned long hamax;
	unsigned int max_cores;
	unsigned long hsa_size;
	unsigned long facilities;
	unsigned int hmfai;
};
extern struct sclp_info sclp;

struct zpci_report_error_header {
	u8 version;	/* Interface version byte */
	u8 action;	/* Action qualifier byte
			 * 1: Deconfigure and repair action requested
			 *	(OpenCrypto Problem Call Home)
			 * 2: Informational Report
			 *	(OpenCrypto Successful Diagnostics Execution)
			 */
	u16 length;	/* Length of Subsequent Data (up to 4K  SCLP header */
	u8 data[0];	/* Subsequent Data passed verbatim to SCLP ET 24 */
} __packed;

int sclp_get_core_info(struct sclp_core_info *info);
int sclp_core_configure(u8 core);
int sclp_core_deconfigure(u8 core);
int sclp_sdias_blk_count(void);
int sclp_sdias_copy(void *dest, int blk_num, int nr_blks);
int sclp_chp_configure(struct chp_id chpid);
int sclp_chp_deconfigure(struct chp_id chpid);
int sclp_chp_read_info(struct sclp_chp_info *info);
void sclp_get_ipl_info(struct sclp_ipl_info *info);
int sclp_pci_configure(u32 fid);
int sclp_pci_deconfigure(u32 fid);
int sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid);
int memcpy_hsa_kernel(void *dest, unsigned long src, size_t count);
int memcpy_hsa_user(void __user *dest, unsigned long src, size_t count);
void sclp_early_detect(void);
void _sclp_print_early(const char *);
void sclp_ocf_cpc_name_copy(char *dst);

#endif /* _ASM_S390_SCLP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 *  Copyright IBM Corp. 2003, 2012
 *  Virtual CPU timer
 *
 *  Author(s): Jan Glauber <jan.glauber@de.ibm.com>
 */

#ifndef _ASM_S390_TIMER_H
#define _ASM_S390_TIMER_H

#define VTIMER_MAX_SLICE (0x7fffffffffffffffULL)

struct vtimer_list {
	struct list_head entry;
	u64 expires;
	u64 interval;
	void (*function)(unsigned long);
	unsigned long data;
};

extern void init_virt_timer(struct vtimer_list *timer);
extern void add_virt_timer(struct vtimer_list *timer);
extern void add_virt_timer_periodic(struct vtimer_list *timer);
extern int mod_virt_timer(struct vtimer_list *timer, u64 expires);
extern int mod_virt_timer_periodic(struct vtimer_list *timer, u64 expires);
extern int del_virt_timer(struct vtimer_list *timer);

extern void init_cpu_vtimer(void);
extern void vtime_init(void);

#endif /* _ASM_S390_TIMER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Copyright IBM Corp. 2006
 *
 * Author(s): Melissa Howland <melissah@us.ibm.com>
 */

#ifndef _ASM_S390_APPLDATA_H
#define _ASM_S390_APPLDATA_H

#include <asm/diag.h>
#include <asm/io.h>

#define APPLDATA_START_INTERVAL_REC	0x80
#define APPLDATA_STOP_REC		0x81
#define APPLDATA_GEN_EVENT_REC		0x82
#define APPLDATA_START_CONFIG_REC	0x83

/*
 * Parameter list for DIAGNOSE X'DC'
 */
struct appldata_parameter_list {
	u16 diag;
	u8  function;
	u8  parlist_length;
	u32 unused01;
	u16 reserved;
	u16 buffer_length;
	u32 unused02;
	u64 product_id_addr;
	u64 buffer_addr;
} __attribute__ ((packed));

struct appldata_product_id {
	char prod_nr[7];	/* product number */
	u16  prod_fn;		/* product function */
	u8   record_nr; 	/* record number */
	u16  version_nr;	/* version */
	u16  release_nr;	/* release */
	u16  mod_lvl;		/* modification level */
} __attribute__ ((packed));

static inline int appldata_asm(struct appldata_product_id *id,
			       unsigned short fn, void *buffer,
			       unsigned short length)
{
	struct appldata_parameter_list parm_list;
	int ry;

	if (!MACHINE_IS_VM)
		return -EOPNOTSUPP;
	parm_list.diag = 0xdc;
	parm_list.function = fn;
	parm_list.parlist_length = sizeof(parm_list);
	parm_list.buffer_length = length;
	parm_list.product_id_addr = (unsigned long) id;
	parm_list.buffer_addr = virt_to_phys(buffer);
	diag_stat_inc(DIAG_STAT_X0DC);
	asm volatile(
		"	diag	%1,%0,0xdc"
		: "=d" (ry)
		: "d" (&parm_list), "m" (parm_list), "m" (*id)
		: "cc");
	return ry;
}

#endif /* _ASM_S390_APPLDATA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 *  S390 version
 *    Copyright IBM Corp. 1999
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 *
 *  Derived from "include/asm-i386/io.h"
 */

#ifndef _S390_IO_H
#define _S390_IO_H

#include <linux/kernel.h>
#include <asm/page.h>
#include <asm/pci_io.h>

#define xlate_dev_mem_ptr xlate_dev_mem_ptr
void *xlate_dev_mem_ptr(phys_addr_t phys);
#define unxlate_dev_mem_ptr unxlate_dev_mem_ptr
void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);

/*
 * Convert a virtual cached pointer to an uncached pointer
 */
#define xlate_dev_kmem_ptr(p)	p

#define IO_SPACE_LIMIT 0

#ifdef CONFIG_PCI

#define ioremap_nocache(addr, size)	ioremap(addr, size)
#define ioremap_wc			ioremap_nocache
#define ioremap_wt			ioremap_nocache

static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
{
	return (void __iomem *) offset;
}

static inline void iounmap(volatile void __iomem *addr)
{
}

static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
{
	return NULL;
}

static inline void ioport_unmap(void __iomem *p)
{
}

/*
 * s390 needs a private implementation of pci_iomap since ioremap with its
 * offset parameter isn't sufficient. That's because BAR spaces are not
 * disjunctive on s390 so we need the bar parameter of pci_iomap to find
 * the corresponding device and create the mapping cookie.
 */
#define pci_iomap pci_iomap
#define pci_iounmap pci_iounmap
#define pci_iomap_wc pci_iomap
#define pci_iomap_wc_range pci_iomap_range

#define memcpy_fromio(dst, src, count)	zpci_memcpy_fromio(dst, src, count)
#define memcpy_toio(dst, src, count)	zpci_memcpy_toio(dst, src, count)
#define memset_io(dst, val, count)	zpci_memset_io(dst, val, count)

#define __raw_readb	zpci_read_u8
#define __raw_readw	zpci_read_u16
#define __raw_readl	zpci_read_u32
#define __raw_readq	zpci_read_u64
#define __raw_writeb	zpci_write_u8
#define __raw_writew	zpci_write_u16
#define __raw_writel	zpci_write_u32
#define __raw_writeq	zpci_write_u64

#endif /* CONFIG_PCI */

#include <asm-generic/io.h>

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _ASM_S390_FUTEX_H
#define _ASM_S390_FUTEX_H

#include <linux/uaccess.h>
#include <linux/futex.h>
#include <asm/mmu_context.h>
#include <asm/errno.h>

#define __futex_atomic_op(insn, ret, oldval, newval, uaddr, oparg)	\
	asm volatile(							\
		"   sacf  256\n"					\
		"0: l     %1,0(%6)\n"					\
		"1:"insn						\
		"2: cs    %1,%2,0(%6)\n"				\
		"3: jl    1b\n"						\
		"   lhi   %0,0\n"					\
		"4: sacf  768\n"					\
		EX_TABLE(0b,4b) EX_TABLE(2b,4b) EX_TABLE(3b,4b)		\
		: "=d" (ret), "=&d" (oldval), "=&d" (newval),		\
		  "=m" (*uaddr)						\
		: "0" (-EFAULT), "d" (oparg), "a" (uaddr),		\
		  "m" (*uaddr) : "cc");

static inline int futex_atomic_op_inuser(int encoded_op, u32 __user *uaddr)
{
	int op = (encoded_op >> 28) & 7;
	int cmp = (encoded_op >> 24) & 15;
	int oparg = (encoded_op << 8) >> 20;
	int cmparg = (encoded_op << 20) >> 20;
	int oldval = 0, newval, ret;

	load_kernel_asce();
	if (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28))
		oparg = 1 << oparg;

	pagefault_disable();
	switch (op) {
	case FUTEX_OP_SET:
		__futex_atomic_op("lr %2,%5\n",
				  ret, oldval, newval, uaddr, oparg);
		break;
	case FUTEX_OP_ADD:
		__futex_atomic_op("lr %2,%1\nar %2,%5\n",
				  ret, oldval, newval, uaddr, oparg);
		break;
	case FUTEX_OP_OR:
		__futex_atomic_op("lr %2,%1\nor %2,%5\n",
				  ret, oldval, newval, uaddr, oparg);
		break;
	case FUTEX_OP_ANDN:
		__futex_atomic_op("lr %2,%1\nnr %2,%5\n",
				  ret, oldval, newval, uaddr, oparg);
		break;
	case FUTEX_OP_XOR:
		__futex_atomic_op("lr %2,%1\nxr %2,%5\n",
				  ret, oldval, newval, uaddr, oparg);
		break;
	default:
		ret = -ENOSYS;
	}
	pagefault_enable();

	if (!ret) {
		switch (cmp) {
		case FUTEX_OP_CMP_EQ: ret = (oldval == cmparg); break;
		case FUTEX_OP_CMP_NE: ret = (oldval != cmparg); break;
		case FUTEX_OP_CMP_LT: ret = (oldval < cmparg); break;
		case FUTEX_OP_CMP_GE: ret = (oldval >= cmparg); break;
		case FUTEX_OP_CMP_LE: ret = (oldval <= cmparg); break;
		case FUTEX_OP_CMP_GT: ret = (oldval > cmparg); break;
		default: ret = -ENOSYS;
		}
	}
	return ret;
}

static inline int futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
						u32 oldval, u32 newval)
{
	int ret;

	load_kernel_asce();
	asm volatile(
		"   sacf 256\n"
		"0: cs   %1,%4,0(%5)\n"
		"1: la   %0,0\n"
		"2: sacf 768\n"
		EX_TABLE(0b,2b) EX_TABLE(1b,2b)
		: "=d" (ret), "+d" (oldval), "=m" (*uaddr)
		: "0" (-EFAULT), "d" (newval), "a" (uaddr), "m" (*uaddr)
		: "cc", "memory");
	*uval = oldval;
	return ret;
}

#endif /* _ASM_S390_FUTEX_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *  S390 version
 *    Copyright IBM Corp. 1999
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 *
 *  Derived from "include/asm-i386/delay.h"
 *    Copyright (C) 1993 Linus Torvalds
 *
 *  Delay routines calling functions in arch/s390/lib/delay.c
 */
 
#ifndef _S390_DELAY_H
#define _S390_DELAY_H

void __ndelay(unsigned long long nsecs);
void __udelay(unsigned long long usecs);
void udelay_simple(unsigned long long usecs);
void __delay(unsigned long loops);

#define ndelay(n) __ndelay((unsigned long long) (n))
#define udelay(n) __udelay((unsigned long long) (n))
#define mdelay(n) __udelay((unsigned long long) (n) * 1000)

#endif /* defined(_S390_DELAY_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          (    \  4   (@   4    (                  D D             8Y  Y           8 8 8 @  @                    $   $         Qtd                          Rtd   `
  `
                 GNU rwblk[?'N               @( T   @ .H`                                                    4DvT<DqXs}6iXy|m4sEX,CEV]V]4JW :'uU                    xY       	                         3                                                    x                                                                                a               >                          k                                                    Y	             V             
             E             p                                                                  	             b                                       m                          =	             y             D             )             N                          Z             
                                                                    u              h                                                     8                            O                          p             ]             y             
             O                          X                                        6             	             	             G
                                                                               N             6             {             	             E                                                                                           2                                                    7                                        -
             3                                                                              x
                          6                          ,                                        !             v                          `             %                           _             U                                                    +             $             
                          	             !                                       (                                                                  `
                                                    e                                       !                                       	             r                                       y	             :             R           "   
                             ?                 o  k       >         @p        xY       	   >       R        F       !   ?       )   ?         v 1      (      k   0      @\       >       L  Pj        o        X      8  8       )     1  c       $b \        ?                46 <      1      __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _talloc_zero pytalloc_steal _pytalloc_get_ptr PyInt_AsLong PyLong_AsUnsignedLongLong PyErr_Occurred PyErr_Format PyLong_Type PyExc_TypeError PyInt_Type PyExc_OverflowError PyExc_AttributeError PyInt_FromLong PyType_IsSubtype PyList_Type _pytalloc_get_mem_ctx pytalloc_reference_ex _talloc_reference_loc PyErr_NoMemory memcpy PyLong_FromLongLong PyList_New PyList_SetItem ndr_print_struct_string PyString_FromString _talloc_free ndr_print_samr_CryptPassword ndr_print_samr_LogonHours ndr_print_samr_Password ndr_print_samr_RidWithAttribute ndr_print_samr_RidWithAttributeArray _PyArg_ParseTupleAndKeywords_SizeT _Py_NoneStruct PyObject_IsTrue ndr_pull_struct_blob_all ndr_pull_struct_blob ndr_map_error2string _Py_BuildValue_SizeT PyErr_SetObject ndr_pull_samr_CryptPassword PyExc_RuntimeError ndr_pull_samr_LogonHours ndr_pull_samr_Password ndr_pull_samr_RidWithAttribute ndr_pull_samr_RidWithAttributeArray talloc_named_const ndr_push_struct_blob PyString_FromStringAndSize ndr_push_samr_CryptPassword ndr_push_samr_LogonHours ndr_push_samr_Password ndr_push_samr_RidWithAttribute ndr_push_samr_RidWithAttributeArray talloc_unlink _talloc_array talloc_set_name_const PyTuple_New PyTuple_SetItem PyImport_ImportModule PyObject_GetAttrString get_friendly_nt_error_msg talloc_strdup PyUnicodeUCS4_AsEncodedString py_dcerpc_syntax_init_helper ndr_table_samr py_dcerpc_interface_init_helper PyLong_AsLongLong PyLong_FromUnsignedLongLong py_import_samr_DomainInfo PyErr_SetString py_export_samr_DomainInfo py_import_samr_GroupInfo py_export_samr_GroupInfo py_import_samr_AliasInfo py_export_samr_AliasInfo py_import_samr_UserInfo py_export_samr_UserInfo py_import_samr_DispInfo py_export_samr_DispInfo py_import_samr_ConnectInfo py_export_samr_ConnectInfo py_import_samr_ValidatePasswordRep py_export_samr_ValidatePasswordRep py_import_samr_ValidatePasswordReq py_export_samr_ValidatePasswordReq initsamr pytalloc_BaseObject_size PyType_Ready PyInterface_AddNdrRpcMethods Py_InitModule4 PyModule_AddObject py_ndr_samr_methods dcerpc_samr_Connect_r dcerpc_samr_Close_r dcerpc_samr_SetSecurity_r dcerpc_samr_QuerySecurity_r dcerpc_samr_Shutdown_r dcerpc_samr_LookupDomain_r dcerpc_samr_EnumDomains_r dcerpc_samr_OpenDomain_r dcerpc_samr_QueryDomainInfo_r dcerpc_samr_SetDomainInfo_r dcerpc_samr_CreateDomainGroup_r dcerpc_samr_EnumDomainGroups_r dcerpc_samr_CreateUser_r dcerpc_samr_EnumDomainUsers_r dcerpc_samr_CreateDomAlias_r dcerpc_samr_EnumDomainAliases_r dcerpc_samr_GetAliasMembership_r dcerpc_samr_LookupNames_r dcerpc_samr_LookupRids_r dcerpc_samr_OpenGroup_r dcerpc_samr_QueryGroupInfo_r dcerpc_samr_SetGroupInfo_r dcerpc_samr_AddGroupMember_r dcerpc_samr_DeleteDomainGroup_r dcerpc_samr_DeleteGroupMember_r dcerpc_samr_QueryGroupMember_r dcerpc_samr_SetMemberAttributesOfGroup_r dcerpc_samr_OpenAlias_r dcerpc_samr_QueryAliasInfo_r dcerpc_samr_SetAliasInfo_r dcerpc_samr_DeleteDomAlias_r dcerpc_samr_AddAliasMember_r dcerpc_samr_DeleteAliasMember_r dcerpc_samr_GetMembersInAlias_r dcerpc_samr_OpenUser_r dcerpc_samr_DeleteUser_r dcerpc_samr_QueryUserInfo_r dcerpc_samr_SetUserInfo_r dcerpc_samr_ChangePasswordUser_r dcerpc_samr_GetGroupsForUser_r dcerpc_samr_QueryDisplayInfo_r dcerpc_samr_GetDisplayEnumerationIndex_r dcerpc_samr_TestPrivateFunctionsDomain_r dcerpc_samr_TestPrivateFunctionsUser_r dcerpc_samr_GetUserPwInfo_r dcerpc_samr_RemoveMemberFromForeignDomain_r dcerpc_samr_QueryDomainInfo2_r dcerpc_samr_QueryUserInfo2_r dcerpc_samr_QueryDisplayInfo2_r dcerpc_samr_GetDisplayEnumerationIndex2_r dcerpc_samr_CreateUser2_r dcerpc_samr_QueryDisplayInfo3_r dcerpc_samr_AddMultipleMembersToAlias_r dcerpc_samr_RemoveMultipleMembersFromAlias_r dcerpc_samr_OemChangePasswordUser2_r dcerpc_samr_ChangePasswordUser2_r dcerpc_samr_GetDomPwInfo_r dcerpc_samr_Connect2_r dcerpc_samr_SetUserInfo2_r dcerpc_samr_SetBootKeyInformation_r dcerpc_samr_GetBootKeyInformation_r dcerpc_samr_Connect3_r dcerpc_samr_Connect4_r dcerpc_samr_ChangePasswordUser3_r dcerpc_samr_Connect5_r dcerpc_samr_RidToSid_r dcerpc_samr_SetDsrmPassword_r dcerpc_samr_ValidatePassword_r libsamba-python.so.0 libdcerpc-samba.so.0 libndr-standard.so.0 libndr.so.0 libsamba-errors.so.1 libpython2.7.so.1.0 libtalloc.so.2 libpytalloc-util.so.2 libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/dcerpc/samr.so /usr/lib/arm-linux-gnueabihf/samba SAMBA_ERRORS_1 GLIBC_2.4 NDR_0.0.1 TALLOC_2.0.2 PYTALLOC_UTIL_2.1.6 PYTALLOC_UTIL_2.0.6 SAMBA_4.5.16_DEBIAN NDR_STANDARD_0.0.1                                                                                             	      
                                                                                            	                                           
 f                 ii  	 u                 A#                    "                0   Y        Y           f                    Q                    {                                                                                                    (    ,    8    <    D    H    T    X    `    d    p    t    |                                                                                                 $    (    4    8    @    D    P    T    \    `    l    p    x    |                                                                                                 $    0    4    <    @    L    P    X    \    h    l    t    x                                                                                                      ,    0    8    <    H    L    T    X    d    h    p    t                                                                                                     (    ,    4    8    D    H    P    T    `    d    l    p    |                                                                                                $    (    0    4    @    D    L    P    \    `    h    l    x    |                                                                                                 $    ,    0    <    @    H    L    X    \    d    h    t    x                                                                                                                           $    ,    0    4    8    <    @    D    H    P    T    X    \    d    h    l    p    t    x    |                                                                                                                                     $    (    ,    4    8    <    D    H    P    T    \    `    d    l    p    x    |                                                                                                                             $    ,    0    4    <    @    H    L    T    X    `    d    h    p    t    x                                                                                \    |             @    t            8                    d    l            (    0    P                H                |            @    `            $    X                                P    p            4    h            ,                X     `               $    D    x            <                 p            4    T                L                            D    d            (    \             	    	    	    	    T
    t
    
        8    l            0                d            (    H    |            @                t            8    X                P                            H    h            ,    `            $                X    x            <    p             4                h            ,    L                D                x            <    \                  T                                L!    l!    !    "    0"    d"    "    "    (#    #    #    #    \$    |$    $     %    @%    t%    %    &    8&    &    &    &    &    &    &    '    '    '    '    ,'    0'    4'    8'    @'    D'    H'    L'    T'    X'    \'    `'    h'    l'    p'    t'    |'    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '    '     (    (    (    (    (    0(    4(    8(    <(    D(    H(    L(    P(    l(    p(    t(    x(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    )    )    )    )     )    $)    ()    ,)    H)    L)    P)    T)    \)    `)    d)    h)    )    )    )    )    )    )    )    )    )    )    )    )    )    )    )    )    )     *    *    *    *    *    *    *    8*    <*    @*    D*    L*    P*    T*    X*    t*    x*    |*    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *     +    +    +    +    (+    ,+    0+    4+    <+    @+    D+    H+    d+    h+    l+    p+    x+    |+    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    ,    ,     ,    $,    ,,    0,    4,    8,    @,    D,    H,    L,    T,    X,    \,    `,    h,    l,    p,    t,    |,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,     -    -     -    $-    ,-    0-    4-    <-    @-    D-    L-    `-    d-    h-    l-    t-    x-    |-    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    .    .    .     .    <.    @.    D.    H.    P.    T.    X.    \.    x.    |.    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .     /    /     /    $/    (/    0/    4/    8/    </    D/    H/    L/    P/    X/    \/    `/    d/    l/    p/    t/    x/    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /     0    0    0    0    0    0     0    $0    (0    ,0    40    80    <0    @0    H0    L0    P0    T0    \0    `0    d0    h0    p0    t0    x0    |0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0     1    1    1    1    1    1    1    $1    (1    ,1    01    81    <1    @1    D1    L1    P1    T1    X1    `1    d1    h1    l1    t1    x1    |1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1     2    2    2    2    2    2    2     2    (2    ,2    02    42    <2    @2    D2    H2    P2    T2    X2    \2    x2    |2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    3    3    3    3    03    43    83    <3    X3    \3    `3    d3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    4    4    4    4    44    84    <4    @4    \4    `4    d4    h4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4     5    5    5    5    5    5    5    $5    (5    ,5    05    85    <5    @5    D5    L5    P5    T5    X5    `5    d5    h5    l5    t5    x5    |5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5     6    6    6    6    6    6    6     6    <6    @6    D6    H6    d6    h6    l6    p6    x6    |6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    7    7    7    7    7    7     7    $7    ,7    07    47    87    @7    D7    H7    L7    T7    X7    \7    `7    h7    l7    p7    t7    |7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7     8    8    8     8    $8    (8    ,8    48    88    <8    @8    \8    `8    d8    h8    p8    t8    x8    |8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8     9    9    9    9    9    9    9    89    <9    @9    D9    L9    P9    T9    X9    `9    d9    h9    l9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9     :    :    :    :    (:    ,:    0:    4:    <:    @:    D:    H:    P:    T:    X:    \:    d:    h:    l:    p:    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    ;    ;     ;    $;    ,;    0;    4;    8;    @;    D;    H;    L;    h;    l;    p;    t;    |;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;     <    <    <    <    <    0<    4<    8<    <<    X<    \<    `<    d<    <    <    <    <    <    <    <    <    <    <    <    <    <    <     =    =    =    =    =    =     =    $=    (=    ,=    4=    8=    <=    @=    H=    L=    P=    T=    \=    `=    d=    h=    p=    t=    x=    |=    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =     >    >    >    >    >    >    >    $>    (>    ,>    0>    8>    <>    @>    D>    `>    d>    h>    l>    t>    x>    |>    >    >    >    >    >    >    >    >    >     *   Q   Q   Q   Q  4 Q  P Q  l Q   Q   Q   Q   Q   Q   Q  0 Q  L Q  h Q   Q   Q   Q   Q   Q   Q  , Q  H Q  d Q   Q   Q   Q   Q   Q   Q  ( Q  D Q  ` Q  | Q   Q   Q   Q   Q   Q  $ Q  @ Q  \ Q  x Q   Q   Q   Q   Q   Q    Q  < Q  X Q  t Q   Q   Q   Q   Q    Q   Q  8 Q  T Q  p Q   Q   Q   Q   Q   Q   Q   Q      >     $ 6  @ ,  \ R  x N      $             C  < D  X z  t    ]   E      d    +     8 <  T x  p    h   r   "   A   _   T  4   P 	  l )   f   7            3  0   L   h L   :   %   s      -   2  , v  H   d    e   [   y   U      ^  ( (  D   ` t  | i       S   c      V                        #      &   /   5   8   9   ;   ?   M   \   `   a   b   k   m   n   q                           
                                 !      '      .   0   1   4      =   @   B      F      G    H   I   J   K   O   P          W  $ X  ( Y  , Z  0   4   8 g  < j  @ l  D o  H p  L u  P w  T {  X   \ |  ` }  d ~  h   l   p   t   x   |         @-  -  Y Y Y Y Y Y Y Y Y Y Y Y Y Y| Yt Yl Yd Y\ YT YL YD Y< Y4 Y, Y$ Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y| Yt Yl Yd Y\ YT YL YD Y< Y4 Y, Y$ Y Y Y Y Y Y Y Y0 0   R/G   404 0  0 0C S 00/ 0  S//    8  88    A,0A0/ 0  S//  @ <  L0L 0  0  S/80@-0  S  
(0 0 0  d     ` $ 8 80    0  R     0  S
@-3/@    $ @- @     @^J $ @- @     @RJ $ @-X @     @FxJ $ @- @     @:lJ $ @- @     @.TJ $ @- @     @"<J $ @- @     @$J $ @- @     @
J $ @- @     @I $ @- @     @I $ @-@ @     @I $ @- @     @I $ @- @     @I $ @- @   x  @I $ @- @   l  @I $ @-  @  `  @xI   $ @- @   S  @TI $ @-. @   G  @@I $ @-  @  ;  @0I   $ @- @   .  @xI $ @-- @   "  @lH $ @- @     @`H $ @- @   
  @TH $ @- @     @HH $ @-# @     @<H $ @- @     @0H $ @- @     @$hH $ @- @     @PH $ @- @     @8H $ @- @     @  H $ @- @     @H $ @- @     @G $ @- @     @G $ @- @     @G $ @- @   z  @G $ @- @   n  @G $ @- @   b  @xG $ @- @   V  @`G $ @- @   J  @HG $ @-x @   >  @0G $ @- @   2  @|G $ @-$ @   &  @p G $ @- @     @dF $ @- @     @XF $ @- @     @LF $ @- @     @@F $ @- @     @4F $ @- @     @(F $ @- @     @xF $ @-$ @     @dF $ @- @     @TF $ @-8 @     @@F $ @-0 @     @4F $ @- @     @(F $ @-P @     @F $ @-P @   ~  @F $ @-8 @   r  @E $ @- @   f  @E $ @- @   Z  @E $ @- @   N  @E $ @- @   B  @E $ @- @   6  @E $ @- @   *  @tE $ @- @     @h|E $ @- @     @\dE $ @- @     @PLE @-PMqk  Up;  
0 `T0D    
  P   ? ! = @P  P  A0   0     d p0d    0    @ PH@  4040     X  (  ,  E d  D h  4D @-PMq  Up;  
0 `T0D    
  P   ?    @P  P  @0   0   y  d p0d    0    @ PH@g  4040  _   X  (  ,  C d  HC h  |C @-PMq  Up;  
0 `T0D    
 m P   ?    @P?  P  @0   0   $  d p0d    0    @ PH@  4040  
  0 X  (  ,  tB d  A h  dB G-`MdQl  VPM  
0 T0D
  8  
 P 1 1  * ? `p  P   	 W Va0   0   `   0    @0    P@  Xh0X   0  P   <0<0       X  d  ,  A @ (  @ h   A @-PMq  Up;  
0 `T0D    
  P   ?    @P  P  @0   0   f  d p0d    0    @ PH@T  4040  L  8~ X  (  ,  |? d  > h  @ @-PMq  Up;  
0 `T0D    
 Z P   ?    @P,  P  @0   0     d p0d    0    @ PH@  4040    | X  (  ,  (> d  = h  > G-`MdQY  VPM  
0 T0D
  8  
 P 1 1  * , `p  P   	 W Ve0   0   `   0    @0    P@  Xh0X   0  P   <0<0    {   X  d  ,  = D< (  D< h  < @-PMq  Up;  
0 `T0D    
  P   ? $  @Pn  P  D0   0   S  d p0d    0    @ PH@A  4040  9  y X  (  ,  0; d  : h  ; @-PMq  Up;  
0 `T0D    
 G P   ? $ m @P  P  D0   0     d p0d    0    @ PH@  4040    x X  (  ,  9 d  \9 h  : G-`M`QF  VPL  
0 T0D	  7  
  P!      `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080  ~  Dw X  d  ,  L9 7 (  7 h  T9 @-PMq  Up;  
0 `T0D    
  P   ?    @P]  P  @0   0   B  d p0d    0    @ PH@0  4040  (  u X  (  ,  6 d  l6 h  6 @-PMq  Up;  
0 `T0D    
 6 P   ?   \ @P  P  @0   0     d p0d    0    @ PH@  4040    Tt X  (  ,  5 d  5 h  5 G-`M`Q5  VPL  
0 T0D	  7  
  P!     	 `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L u  8080  m   s X  d  ,  5 3 (  3 h  P5 @-PMq  Up;  
0 `T0D    
 z P   ?    @PL  P  @0   0   1  d p0d    0    @ PH@  4040    dq X  (  ,  2 d  (2 h  (4 G-`M`Qy  VPL  
0 T0D	  7  
 % P!   < M `p  P   	 W  V<`0   0   `   0    0    @ P|@  Td0T   0  L   8080    p X  d  ,  2 0 (  0 h  2 G-`M`Q  VPL  
0 T0D	  7  
  P!   8  `p  P   	 W  V8`0   0   `r   0    0    @ P|@`  Td0T   0  L R  8080  J  tn X  d  ,  |0 ,/ (  ,/ h  h1 G-`M`Q  VPL  
0 T0D	  7  
 W P!   4  `p+  P   	 W  V4`0   0   `   0    0    @ P|@  Td0T   0  L   8080    l X  d  ,  . - (  - h   0 G-`M`QD  VPL  
0 T0D	  7  
  P!   0  `p  P   	 W  V0`0   0   `   0    0    @ P|@  Td0T   0  L   8080  |  <k X  d  ,  D- + (  + h  . G-`M`Q  VPL  
0 T0D	  7  
  P!   ,  `p]  P   	 W  V,`0   0   `=   0    0    @ P|@+  Td0T   0  L   8080    i X  d  ,  + X* (  X* h  + G-`M`Qv  VPL  
0 T0D	  7  
 " P!   ( J `p  P   	 W  V(`0   0   `   0    0    @ P|@  Td0T   0  L   8080    h X  d  ,  * ( (  ( h  * @-PMq  Up;  
0 `T0D    
  P   ? "  @P  P  B0   0   r  d p0d    0    @ PH@`  4040  X  hf X  (  ,  ' d  ,' h  ' @-PMq  Up;  
0 `T0D    
 f P   ?    @P8  P  @0   0     d p0d    0    @ PH@  4040    e X  (  ,  X& d  % h  ' G-`M`Qe  VPL  
0 T0D	  7  
  P!    9 `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080    c X  d  ,  % x$ (  x$ h  P' G-`MdQ  VPM  
0 T0D
  8  
 P  1 1  *  `p}  P   	 W V`0   0   `]   0    @0    P@K  Xh0X   0  P =  <0<0  5  $b   X  d  ,  ($ " (  " h  % G-`MdQ  VPM  
0 T0D
  8  
 AP  1 1  * h `p  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0    `   X  d  ,  " 4! (  4! h  $ G-`M`Q,  VPL  
0 T0D	  7  
  P!       `p  P   	 W  V `0   0   `   0    0    @ P|@z  Td0T   0  L l  8080  d  ^ X  d  ,     (   h  0# G-`M`Q  VPL  
0 T0D	  7  
 q P!     `pE  P   	 W  V`0   0   `%   0    0    @ P|@  Td0T   0  L   8080    @] X  d  ,  H  (   h  ! G-`M`Q^  VPL  
0 T0D	  7  
 
 P!    2 `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080    [ X  d  ,   \ (  \ h   G-`M`Q  VPL  
0 T0D	  7  
  P!     `pw  P   	 W  V`0   0   `W   0    0    @ P|@E  Td0T   0  L 7  8080  /  Z X  d  ,    (   h   @-PMda  U`M  
0 pT0D
  8  
 < P     c @P  P    U TB0   0`   p @`   0    0   @ P|@  Td0T   0  L   8080    lX X  d  ,  p   (    h  ( @-PMda(  U`M  
0 pT0D
  8  
  P      @P  P    U TB0   0`   p @`   0    0   @ P|@u  Td0T   0  L g  8080  _  V X  d  ,    (   h   @-PMda  U`M  
0 pT0D
  8  
 l P       @P?  P    U T@0   0`   p @`   0    0   @ P|@  Td0T   0  L   8080    ,U X  d  ,  0  (   h  $ @-PMdaX  U`M  
0 pT0D
  8  
  P      + @P  P    U T@0   0`   p @`   0    0   @ P|@  Td0T   0  L   8080    S X  d  ,   @ (  @ h  H @-PMda  U`M  
0 pT0D
  8  
  P       @Po  P    U T@0   0`   p @`O   0    0   @ P|@=  Td0T   0  L /  8080  '  Q X  d  ,    (   h  $ @-PMda  U`M  
0 pT0D
  8  
 4 P      [ @P  P    U T@0   0`   p @`   0    0   @ P|@  Td0T   0  L   8080    LP X  d  ,  P   (    h   G-`MdQ   VPM  
0 T0D
  8  
 P 1 1  *  `p  P   	 W Vk0   0   `   0    @0    P@m  Xh0X   0  P _  <0<0  W  N   X  d  ,   ` (  ` h  \ G-`MdQ  VPM  
0 T0D
  8  
 cP 1 1  *  `p6  P   	 W Vk0   0   `   0    @0    P@  Xh0X   0  P   <0<0    M   X  d  ,    (   h   G-`MdQN  VPM  
0 T0D
  8  
 P 1 1  * ! `p  P   	 W Vk0   0   `   0    @0    P@  Xh0X   0  P   <0<0    dK   X  d  ,  h  (   h   G-`MdQ  VPM  
0 T0D
  8  
 P 1 1  *  `pd  P   	 W Vk0   0   `D   0    @0    P@2  Xh0X   0  P $  <0<0    I   X  d  ,   t
 (  t
 h   G-`MdQ|  VPM  
0 T0D
  8  
 (P  1 1  * O `p  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0    H   X  d  ,   
  (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `s   0    0    @ P|@a  Td0T   0  L S  8080  K  xF X  d  ,   0 (  0 h  D G-`M`Q  VPL  
0 T0D	  7  
 X P!     `p,  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080    D X  d  ,    (   h   G-`M`QE  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080  }  @C X  d  ,  H  (   h  x
 G-`M`Q  VPL  
0 T0D	  7  
  P!     `p^  P   	 W  V`0   0   `>   0    0    @ P|@,  Td0T   0  L   8080    A X  d  ,   \ (  \ h  	 G-`M`Qw  VPL  
0 T0D	  7  
 # P!    K `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080    @ X  d  ,     (    h   @-PMq  Up;  
0 `T0D    
  P   ? "  @P  P  B0   0   s  d p0d    0    @ PH@a  4040  Y  l> X  (  ,   d  0 h   @-PMq  Up;  
0 `T0D    
 g P   ? "  @P9  P  B0   0     d p0d    0    @ PH@  4040    = X  (  ,  \ d   h  p @-PMqf  Up;  
0 `T0D    
  P   ? ! 8 @P  P  A0   0     d p0d    0    @ PH@  4040    ; X  (  ,   d   h  \ @-PMq  Up;  
0 `T0D    
  P   ? !  @P  P  A0   0   t  d p0d    0    @ PH@b  4040  Z  p: X  (  ,   d  4 h  @ @-PMq  Up;  
0 `T0D    
 h P   ?    @P:  P  @0   0     d p0d    0    @ PH@  4040    9 X  (  ,  ` d   h  , @-PMqg  Up;  
0 `T0D    
  P   ?   9 @P  P  @0   0     d p0d    0    @ PH@  4040    7 X  (  ,   d   h   @-PMda  U`M  
0 pT0D
  8  
  P "      @P  P    U T"@0   0`   p @`q   0    0   @ P|@_  Td0T   0  L Q  8080  I  t6 X  d  ,  x ( (  ( h  0 @-PMda  U`M  
0 pT0D
  8  
 V P !     } @P)  P    U T!@0   0`   p @`	   0    0   @ P|@  Td0T   0  L   8080    4 X  d  ,    (   h   @-PMdaB  U`M  
0 pT0D
  8  
  P        @P  P    U T @0   0`   p @`   0    0   @ P|@  Td0T   0  L   8080  y  43 X  d  ,  8  (   h   @-PMq  Up;  
0 `T0D    
  P   ?    @PX  P  @0   0   =  d p0d    0    @ PH@+  4040  #  1 X  (  ,   d  X h  , G-`M`Q  VPL  
0 T0D	  7  
 1 P!     Y `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080    @0 X  d  ,  H  (   h  D G-`M`Q  VPL  
0 T0D	  7  
  P!      `p  P   	 W  V `0   0   `~   0    0    @ P|@l  Td0T   0  L ^  8080  V  . X  d  ,   \ (  \ h   G-`M`Q  VPL  
0 T0D	  7  
 c P!   x  `p7  P   	 W  Vx`0   0   `   0    0    @ P|@  Td0T   0  L   8080    - X  d  ,    (   h   @-PMqP  Up;  
0 `T0D    
  P   ? ' " @P  P  G0   0     d p0d    0    @ PH@  4040    l+ X  (  ,   d  0 h   @-PMq  Up;  
0 `T0D    
  P   ? &  @Py  P  F0   0   ^  d p0d    0    @ PH@L  4040  D  * X  (  ,  \ d   h   G-`MdQ  VPM  
0 T0D
  8  
 RP 1 1  * y `p%  P   	 W Vf0   0   `   0    @0    P@  Xh0X   0  P   <0<0    (   X  d  ,   x (  x h   G-`MdQ=  VPM  
0 T0D
  8  
 P 1 1  *  `p  P   	 W Vf0   0   `   0    @0    P@  Xh0X   0  P |  <0<0  t   '   X  d  ,  $  (   h  t @-PMq  Up;  
0 `T0D    
  P   ? %  @PR  P  E0   0   7  d p0d    0    @ PH@%  4040    |% X  (  ,   d  @ h   @-PMq  Up;  
0 `T0D    
 + P   ? $ Q @P  P  D0   0     d p0d    0    @ PH@  4040    ($ X  (  ,  l d   h  p G-`M`Q*  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `   0    0    @ P|@x  Td0T   0  L j  8080  b  " X  d  ,    (   h   G-`M`Q  VPL  
0 T0D	  7  
 o P!     `pC  P   	 W  V`0   0   `#   0    0    @ P|@  Td0T   0  L   8080    8! X  d  ,  @  (   h   G-`M`Q\  VPL  
0 T0D	  7  
  P!   t 0 `p  P   	 W  Vt`0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,   T (  T h   G-`MdQ  VPM  
0 T0D
  8  
 P 1 1  *  `pt  P   	 W Vg0   0   `T   0    @0    P@B  Xh0X   0  P 4  <0<0  ,      X  d  ,    (   h   G-`MdQ  VPM  
0 T0D
  8  
 8P 1 1  * _ `p  P   	 W Vg0   0   `   0    @0    P@  Xh0X   0  P   <0<0    \   X  d  ,  `  (   h   @-PMq#  Up;  
0 `T0D    
  P   ? &  @P  P  F0   0     d p0d    0    @ PH@t  4040  l   X  (  ,   d  | h   @-PMq  Up;  
0 `T0D    
 z P   ? %  @PL  P  E0   0   1  d p0d    0    @ PH@  4040    d X  (  ,   d  ( h   @-PMqy  Up;  
0 `T0D    
 % P   ? % K @P  P  E0   0     d p0d    0    @ PH@  4040     X  (  ,  T d   h   @-PMq$  Up;  
0 `T0D    
  P   ? $  @P  P  D0   0     d p0d    0    @ PH@u  4040  m   X  (  ,    d   h   @-PMq  Up;  
0 `T0D    
 { P   ? $  @PM  P  D0   0   2  d p0d    0    @ PH@   4040    h X  (  ,   d  , h   G-`M`Qz  VPL  
0 T0D	  7  
 & P!    N `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,    (   h  L G-`M`Q  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `s   0    0    @ P|@a  Td0T   0  L S  8080  K  x X  d  ,   0 (  0 h   G-`MdQ  VPM  
0 T0D
  8  
 XP 1 1  *  `p+  P   	 W Va0   0   `   0    @0    P@  Xh0X   0  P   <0<0       X  d  ,    (   h   G-`MdQC  VPM  
0 T0D
  8  
 P 1 1  *  `p  P   	 W Va0   0   `   0    @0    P@  Xh0X   0  P   <0<0  z  8   X  d  ,  <  (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!     `pZ  P   	 W  V`0   0   `:   0    0    @ P|@(  Td0T   0  L   8080     X  d  ,   L (  L h   G-`M`Qs  VPL  
0 T0D	  7  
  P!     G `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,     (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!      `p  P   	 W  V `0   0   `l   0    0    @ P|@Z  Td0T   0  L L  8080  D  \
 X  d  ,  d  (   h  4 G-`M`Q  VPL  
0 T0D	  7  
 Q P!    y `p%  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,   x (  x h   G-`M`Q>  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L ~  8080  v  $ X  d  ,  ,  (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!      `pW  P   	 W  V `0   0   `7   0    0    @ P|@%  Td0T   0  L   8080     X  d  ,   @ (  @ h  0 G-`M`Qp  VPL  
0 T0D	  7  
  P!     D `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,    (   h   G-`M`Q	  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `i   0    0    @ P|@W  Td0T   0  L I  8080  A  P X  d  ,  X  (   h  T G-`M`Q  VPL  
0 T0D	  7  
 N P!    v `p"  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080      X  d  ,   l (  l h  $ G-`M`Q;  VPL  
0 T0D	  7  
  P!      `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L {  8080  s   X  d  ,     (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!      `pT  P   	 W  V `0   0   `4   0    0    @ P|@"  Td0T   0  L   8080    | X  d  ,   4 (  4 h  T G-`M`Qm  VPL  
0 T0D	  7  
  P!    A `p  P   	 W  V`0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,    (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `f   0    0    @ P|@T  Td0T   0  L F  8080  >  D X  d  ,  L  (   h   G-`M`Q  VPL  
0 T0D	  7  
 K P!     s `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,   ` (  ` h  P G-`M`Q8  VPL  
0 T0D	  7  
  P!      `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L x  8080  p   X  d  ,    (   h   G-`M`Q  VPL  
0 T0D	  7  
 } P!     `pQ  P   	 W  V`0   0   `1   0    0    @ P|@  Td0T   0  L   8080  	  p X  d  ,  x ( (  ( h  x G-`M`Qj  VPL  
0 T0D	  7  
  P!     > `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,    (   h   G-`M`Q  VPL  
0 T0D	  7  
  P!   0  `p  P   	 W  V0`0   0   `c   0    0    @ P|@Q  Td0T   0  L C  8080  ;  8 X  d  ,  @  (   h   G-`M`Q  VPL  
0 T0D	  7  
 H P!     p `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,   T (  T h  @ G-`M`Q5  VPL  
0 T0D	  7  
  P!   $ 	 `p  P   	 W  V$`0   0   `   0    0    @ P|@  Td0T   0  L u  8080  m    X  d  ,    (   h   G-`M`Q  VPL  
0 T0D	  7  
 z P!      `pN  P   	 W  V `0   0   `.   0    0    @ P|@  Td0T   0  L   8080    d X  d  ,  l  (   h  t @-PMqg  Up;  
0 `T0D    
  P   ? ! 9 @P  P  A0   0     d p0d    0    @ PH@  4040     X  (  ,   d   h  T @-PMq  Up;  
0 `T0D    
  P   ? !  @P  P  A0   0   u  d p0d    0    @ PH@c  4040  [  t X  (  ,   d  8 h  8 @-PMq  Up;  
0 `T0D    
 i P   ?    @P;  P  @0   0      d p0d    0    @ PH@  4040      X  (  ,  d d   h   G-`M`Qh  VPL  
0 T0D	  7  
  P!     < `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,    (   h   @-PMda  U`M  
0 pT0D
  8  
  P I      @P  P    U TI@0   0`   p @``   0    0   @ P|@N  Td0T   0  L @  8080  8  0 X  d  ,  4  (   h   @-PMda  U`M  
0 pT0D
  8  
 E P H     l @P  P    U TH@0   0`   p @`   0    0   @ P|@  Td0T   0  L   8080     X  d  ,   D (  D h   @-PMda1  U`M  
0 pT0D
  8  
  P H      @P  P    U TH@0   0`   p @`   0    0   @ P|@~  Td0T   0  L p  8080  h   X  d  ,    (   h  ( @-PMda  U`M  
0 pT0D
  8  
 u P 0      @PH  P    U T0@0   0`   p @`(   0    0   @ P|@  Td0T   0  L   8080     P X  d  ,  T  (   h   G-`M`Qa  VPL  
0 T0D	  7  
  P!     5 `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,   h (  h h  ( G-`M`Q  VPL  
0 T0D	  7  
  P!     `pz  P   	 W  V`0   0   `Z   0    0    @ P|@H  Td0T   0  L :  8080  2   X  d  ,    (   h   G-`MdQ  VPM  
0 T0D
  8  
 ?P  1 1  * f `p  P   	 W V`0   0   `   0    @0    P@  Xh0X   0  P   <0<0    x   X  d  ,  | , (  , h   G-`M`Q*  VPL  
0 T0D	  7  
  P!     `p  P   	 W  V`0   0   `   0    0    @ P|@x  Td0T   0  L j  8080  b   X  d  ,    (   h  ( G-`M`Q  VPL  
0 T0D	  7  
 o P!      `pC  P   	 W  V `0   0   `#   0    0    @ P|@  Td0T   0  L   8080    8 X  d  ,  @  (   h   G-`M`Q\  VPL  
0 T0D	  7  
  P!     0 `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080     X  d  ,   T (  T h  t G-`M`Q  VPL  
0 T0D	  7  
  P!      `pu  P   	 W  V `0   0   `U   0    0    @ P|@C  Td0T   0  L 5  8080  -    X  d  ,    (   h   G-`M`Q  VPL  
0 T0D	  7  
 : P!     b `p  P   	 W  V `0   0   `   0    0    @ P|@  Td0T   0  L   8080    d X  d  ,  l  (   h  < G-`M`Q'  VPL  
0 T0D	  7  
  P!      `p  P   	 W  V `0   0   `   0    0    @ P|@u  Td0T   0  L g  8080  _   X  d  ,    (   h  p G-`M`Q  VPL  
0 T0D	  7  
 l P!      `p@  P   	 W  V `0   0   `    0    0    @ P|@  Td0T   0  L    8080    , X  d  ,  4  (   h   @-\@@-W@@-R@ @-M@ @-H@@-C@@->@ @-9@ @-4@ @-/@ @-*@@-%@@- @@-@@-@ @-@" @-@! @-@  @-@@-@@-@@-@@-@@-@@-@@-@I @-@H z@-@H u@-@0 p@-@ kC-`Mtr  Vp  
d2 P @ P  
v  Py  
\j  0 0  S @  8  ?  
b P     0@ S  0P1  S(  
  T 
 +  P5    Y X4   0@ S  1!   0   @ P`@  H1H0    (1!  0       0   0@   P @   ?       p0  0   0dd00  00L0    8 $  X  d  ,   h  t (     , ;  C-`Mtr  Vp  
d2 P @ P  
  Py  
\j  0 0  S @  8  ?  
 P     0@ S  0P1  S(  
  T 
 z  P5    Y X4   0@ S  1!   0   @ P`@T  H1H0  K  (1!  0   <    0   0@   P @'   ?       p0  0   0dd00  00L0    t $  X  d  ,   h   (   P , $ 8  C-`Mtra  Vp  
d2 P @ P  
  Py  
 \j  0 0  S @  8  ?  
  P     0@ S  0P1  S(  
  T 
   P5    Y X4   0@ S  1!   0   @ P`@  H1H0    (1!  0       0   0@   P @v   0     j  p0  0   0dd00\  00L0  T   $  X  d  ,  8 h  ( (    h  5  p@- P @ . p@    D p@- @$00 P  @   p@$ p@- @$00 P  @   p@ p@- @$00 P  @    p@ p@- @x$00 P  @   p@p p@- @i$00 P  @   p@4 p@- @Z$00 P  @   p@ p@- @K$00 P  @   p@ p@- @<$00 P  @   p@ p@- @-$00 P  @   p@D p@- @$00 P  @   p@q p@- P @ 0 0p@  c p@- P @ }0 0p@  U p@- P @ o0 0p@ bGP p@- P @ a0 0p@ 9 p@- P @ S0 0p@ + p@- P @ E0 0p@ b p@- P @ 70 0p@ 1p p@- @$00 P  @&   p@ D p@- @$00 P @   p@ p@- @$00 P @   p@ p@- @$00 P @x   p@ p@- @q$00 P  @p   p@T p@- @b$00 P  @h   p@ p@- @S$00 P  @`   p@ p@- @D$00 P  @X   p@ p@- @5$00 P  @P   p@d p@- @&$00 P  @H   p@y( p@- @$00 P  @@   p@j p@- @$00 P  @8   p@[ p@- @$00 P  @r0   p@Lt p@- @$00 P @c   p@=8 p@- P @ W0 0p@ / p@- P @ I0 0p@ ! p@- @$00 P  @8   p@ p@- @$00 P  @)   p@P p@- @$00 P  @   p@ p@- @$00 P  @   p@ p@- @$00 P  @   p@ p@- @t$00 P  @   p@` p@- @e$00 P  @   p@$ p@- @V$00 P  @   p@ p@- @G$00 P  @   p@ p@- @8$00 P  @   p@p p@- P) @ 0X 0p@ 1}( p@- @$00 P  @@   p@n
 p@- @$00 P  @8   p@_
 p@- @$00 P  @v0   p@P
 p@- @$00 P  @g(   p@AH
 p@- @$00 P  @X    p@2
 p@- @$00 P  @I   p@#	 p@- @$00 P  @:   p@	 p@- @$00 P  @+   p@X	 p@- P @ 0 0p@ 1 p@- P @ 0h 0p@ 1 p@- @$00 P  @ 8   p@ p@- @x$00 P  @0   p@p p@- @i$00 P  @(   p@4 p@- @Z$00 P  @    p@ p@- @K$00 P  @   p@ p@- @<$00 P  @   p@ p@- @-$00 P  @   p@D p@- @$00 P  @   p@q p@- @$00 P  @   p@b p@- @ $00 P  @y   p@S p@- @$00 P  @j   p@DT p@- @$00 P  @[   p@5 p@- @$00 P  @L   p@& p@- @$00 P @=   p@ p@- @$00 P  @.   p@d p@- @$00 P  @   p@( p@- @$00 P  @   p@ p@- @$00 P  @   p@ p@- @y$00 P  @   p@t p@- @j$00 P  @   p@8 p@- @[$00 P  @   p@ p@- PL @ 0 0I>p@   p@- P= @ 0@ 0U>p@  x p@- @.$00 P @8   p@H p@- @$00 P @0   p@r p@- P @ 0 0I>p@  c p@- P @ }0@ 0U>p@  T p@- @$00 P @k8   p@EX p@- @$00 P @\0   p@6 p@- P @ P0 0I>p@  ' p@- P @ A0 0I>p@   p@- @$00 P  @/   p@	h p@- @$00 P  @    p@, p@- @$00 P  @   p@  A-PMq   Up6  
` @ ` P  
9  P  
  `     ?  P  
 k @          h0  0 @   0LL00 @000 @0  D  x (     h  H A-@M` 6  T`/  
p Pp   P  
  P  
  `       P  
  0   l0   0    0PP00 0x 00000   0 X  (  4  h  ~ A-@M`   T`/  
p Pp   P  
  P  
 ] ` Z      P  
  0   l0   0    0PP00M 0/ 00000  B 0 4 p (  ~  h  \~ A-@M`   T`/  
p Pp   P  
W  P  
  `     ]  P  
  0   l0   0    0PP00 0 00000   0    (  P~  h  } A-@M` [  T`0  
p Pp   P  
  P  
  `       P  
 @0     l0   0    0PP00    0000      T~ (  } t h  d{ A-@M`   T`0  
p Pp   P  
  P  
  ` ~      P  
 0     l0   0    0PP00p  R  0000  e  p  } (  | L h  z A-@M`   T`0  
p Pp   P  
z  P  
 7 ` 4      P  
 0     l0   0    0PP00&    0000    H  | (  @| $ h  pz A-@M` }  T`0  
p Pp   P  
0  P  
  `     6  P  
 b0     l0   0    0PP00    0000      t || (  {  h  d{ A-@M` 3  T`/  
p Pp   P  
  P  
  `       P  
  0   l0   0    0PP00 0u 00000   0 L { (  L{  h  z A-@M`   T`0  
p Pp   P  
  P  
 Z ` W      P  
 0     l0   0    0PP00I  +  0000  >   ( P{ (  z  h  y A-@M`   T`/  
p Pp   P  
S  P  
  `     Y  P  
  0   l0   0    0PP00  0 00000   0   z (  y  h  x A-@MP pW  TP/  
` `  P  

  P  
  P       P  
 </    h0  0   0PP00    0000      (z (  xy h h  y A-@MP p  TP/  
` `  P  
  P  
 ~ P {      P  
 /    h0  0   0PP00n  P  0000  c  d  |y (  x D h  w A-@MP p  TP/  
` ` b P  
x  P  
 5 P 2    ~  P  
    O  h0 !0   0PP00%    0000    @   y (  Px   h  w A-@MP p|  TP/  
` `  P  
/  P  
  P     5  P  
 a/    h0 X"0   0PP00    0000     t Tx (  w  h  u A-@MP p3  TP/  
` `  P  
  P  
  P       P  
 /    h0 X"0   0PP00  u  0000     P w (  v  h  t A-@MP p  TP/  
` ` b P  
  P  
 Z P W      P  
    t  h0 !0   0PP00J  ,  0000  ?   , v (  Lv  h  t A-@M`   T`/  
p Pp 1 P  
T  P  
  `     Z  P  
 0     h0 #0   0PP00    0000      v (  u  h  tu A-@M` X  T`0  
p Pp   P  
  P  
  `       P  
 =0     l0   0    0PP00    0000      v (  `u h h  t A-@M`   T`0  
p Pp  P  
  P  
 ~ ` {      P  
 0     l0  0    0PP00m  O  0000  b  d  u (  t @
 h  t A-@M`   T`0  
p Pp  P  
w  P  
 4 ` 1    }  P  
 0     l0  0    0PP00#    0000    <  ,u (  xt 	 h  t A-@M` z  T`0  
p Pp  P  
-  P  
  `     3  P  
 _x0     l0  0    0PP00    0000     h t (  s  h  s A-@M` 0  T`0  
p Pp   P  
  P  
  `       P  
 p0     l0   0    0PP00  q  0000     @ 4t (  s  h   s A-@M`   T`0  
p Pp   P  
  P  
 V ` S      P  
 h0     l0   0    0PP00E  '  0000  :    s (  s  h  r A-@M`   T`0  
p Pp   P  
O  P  
  ` 	    U  P  
 `0     l0   0    0PP00    0000      s (  Xr x h  g A-@M` R  T`0  
p Pp   P  
  P  
  `       P  
 7X0     l0   0    0PP00    0000    t  r (  q P h  |q A-@M`   T`0  
p Pp   P  
  P  
 x ` u      P  
 P0     l0   0    0PP00g  I  0000  \  L  r (  hq ( h  q A-@M`   T`0  
p Pp   P  
q  P  
 . ` +    w  P  
 H0     l0   0    0PP00    0000    $ x q (  p   h  p A-@M` t  T`0  
p Pp   P  
'  P  
  `     -  P  
 Y@0     l0   0    0PP00    0000     P (q (  tp  h  p A-@M` *  T`0  
p Pp   P  
  P  
  `       P  
 80     l0   0    0PP00  k  0000  ~   ( p (  o  h  o A-@M`   T`0  
p Pp   P  
  P  
 P ` M      P  
 00     l0   0    0PP00?  !  0000  4     4p (  o  h  o A-@M`   T`/  
p Pp  P  
I  P  
  `     O  P  
 { 0   l0  0    0PP00 0 00000   0  o (  n d h  h A-@M a M  T`3  
p Pp  P  
   P  
  `       P  
 2     h0 #0   0PP00    0000    `  o (  Hn 0 h  m A-@Ma    T`4  
p Pp  P  
  P  
 p ` m      P  
  0    0  0h0 #0   0PP00[  =  0000  P  ,  |n (  m  h  \m A-@M`   T`/  
p Pp   P  
e  P  
 " `     k  P  
  0   l0   0    0PP00 0 00000   0 H m (  m  h  e A-@M` i  T`/  
p Pp   P  
  P  
  `     "  P  
 N 0   l0   0    0PP00 0 00000   0 $ m (  `l  h  [ A-@M`    T`/  
p Pp   P  
  P  
  `       P  
  0   l0   0    0PP00 0b 00000  u 0   dl (  k  h  d A-@M`   T`/  
p Pp   P  
  P  
 G ` D      P  
  0   l0   0    0PP007 0 00000  , 0  k (  k h h  Dd A-@M`   T`0  
p Pp   P  
A  P  
  `     G  P  
 s0     l0   0    0PP00    0000    d  k (  Xj @ h  c A-@M` D  T`/  
p Pp   P  
  P  
  `       P  
 ) 0   l0   0    0PP00 0 00000   0<  \j (  i  h  Tc A-@M`   T`/  
p Pp   P  
  P  
 k ` h      P  
  0   l0   0    0PP00[ 0= 00000  P 0 l i (   i  h  b A-@M`   T`/  
p Pp   P  
e  P  
 " `     k  P  
  0   l0   0    0PP00 0 00000   0 H i (  Th  h  hb A-@M` i  T`0  
p Pp   P  
  P  
  `     "  P  
 N0     l0   0    0PP00    0000     $ Xh (  g  h  ` A-@M`   T`/  
p Pp   P  
  P  
  `       P  
  0   l0   0    0PP00 0a 00000  t 0~  g (  f  h  ` A-@M`   T`/  
p Pp 1 P  
  P  
 F ` C      P  
 X0     h0 #0   0PP006    0000  +  }  f (  Lf d h  HV A-@M`   T`0  
p Pp   P  
@  P  
  `     F  P  
 r@0     l0   0    0PP00    0000    `|  Pf (  e < h  @Y A-@M` C  T`0  
p Pp   P  
  P  
  `       P  
 (80     l0   0    0PP00    0000    8{  e (  d  h  |N A-@M`   T`0  
p Pp   P  
  P  
 i ` f      P  
 00     l0   0    0PP00X  :  0000  M  z d d (  <d  h  X A-@M`   T`0  
p Pp   P  
b  P  
  `     h  P  
 (0     l0   0    0PP00    0000    x < @d (  c  h  W A-@M` e  T`0  
p Pp   P  
  P  
  `       P  
 J 0     l0   0    0PP00    0000    w  c (  b  h  (W A-@M`   T`0  
p Pp   P  
  P  
  `       P  
  0     l0   0    0PP00z  \  0000  o  v  b (  ,b t h  V A-@M`   T`0  
p Pp   P  
  P  
 A ` >      P  
 0     l0   0    0PP000    0000  %  pu  0b (  |a L h  4V A-@M`   T`/  
p Pp   P  
:  P  
  `     @  P  
 l 0   l0   0    0PP00 0 00000   0Ht  a (  ` ( h  U A-@M` >  T`.  
p Pp 1 P  
  P  
  `       P  
 # 0   h0 #0   0PP00 0 00000   0$s |w ` (  (`  h  K A-@M`   T`/  
p Pp 1 P  
  P  
 f ` c      P  
 h0     h0 #0   0PP00V  8  0000  K  r \v ,` (  |_  h  J A-@M`   T`0  
p Pp   P  
`  P  
  `     f  P  
 80     l0   0    0PP00    0000    p 4 _ (  ^  h  M A-@M` c  T`0  
p Pp   P  
  P  
  `       P  
 H00     l0   0    0PP00    0000    o  ^ (  ^  h  M A-@M`   T`0  
p Pp   P  
  P  
  `       P  
 (0     l0   0    0PP00x  Z  0000  m  n   ^ (  l] l h  HM A-@M`   T`0  
p Pp   P  
  P  
 ? ` <      P  
  0     l0   0    0PP00.    0000  #  hm  p] (  \ D h  L A-@M`   T`0  
p Pp   P  
8  P  
  `     >  P  
 j0     l0   0    0PP00    0000    @l  \ (  \  h  TL A-@M` ;  T`0  
p Pp   P  
  P  
  `       P  
  0     l0   0    0PP00  |  0000    k l \ (  \[  h  K A-@M`   T`/  
p Pp   P  
  P  
 a ` ^      P  
  0   l0   0    0PP00Q 03 00000  F 0i D `[ (  Z  h  dK A-@M`   T`0  
p Pp   P  
[  P  
  `     a  P  
 0     l0   0    0PP00    0000    h   Z (  4Z  h  Y A-@M` ^  T`/  
p Pp   P  
  P  
  `       P  
 C 0   l0   0    0PP00 0 00000   0g  8Z (  Y  h  C A-@M`   T`0  
p Pp   P  
  P  
  `       P  
 0     l0   0    0PP00t  V  0000  i  f  Y (  X \ h  B A-@M`   T`0  
p Pp   P  
~  P  
 ; ` 8      P  
 0     l0   0    0PP00*    0000    Xe  X (  (X 4 h  8 A-@M`   T`0  
p Pp   P  
4  P  
  `     :  P  
 f0     l0   0    0PP00    0000    0d  ,X (  xW  h  D A-@M` 7  T`/  
p Pp   P  
  P  
  `       P  
  0   l0   0    0PP00 0y 00000   0c \ |W (  V  h  |D A-@M`   T`/  
p Pp  P  
  P  
 ^ ` [      P  
  0   l0  0    0PP00N 00 00000  C 0a 8 V (   V  h  XC A-@M`   T`0  
p Pp   P  
X  P  
  `     ^  P  
 0     l0   0    0PP00    0000    `  ,V (  tU  h  4 A-@M` [  T`0  
p Pp   P  
  P  
  `       P  
 @0     l0   0    0PP00    0000    _  U (  T t h  A A-@M`   T`0  
p Pp   P  
  P  
  ` ~      P  
 0     l0   0    0PP00p  R  0000  e  p^  T (  T L h  1 A-@M`   T`0  
p Pp   P  
z  P  
 7 ` 4      P  
 0     l0   0    0PP00&    0000    H]  (T (  pS $ h  > A-@M` }  T`0  
p Pp   P  
0  P  
  `     6  P  
 b0     l0   0    0PP00    0000     \ t |S (  R  h  < A-@M` 3  T`0  
p Pp   P  
  P  
  `       P  
 0     l0   0    0PP00  t  0000    Z L R (  R  h  <. A-@M`   T`0  
p Pp   P  
  P  
 Y ` V      P  
 0     l0   0    0PP00H  *  0000  =  Y $ $R (  lQ  h  @; A-PMa   U`5  
p @p I P  
Q  P  
  `     W  P  
  @        h0 $0 @   0LL00 @000 @0  X  ] tQ (  P l h  @/ A-@M` P  T`0  
p Pp U P  
  P  
  `       P  
 4@0     h0 h%0   0PP00    0000    lW [ P (   P H h  % A-@M`   T`0  
p Pp  P  
  P  
 v ` s      P  
 80     l0  0    0PP00e  G  0000  Z  DV  @P (  O   h  (O A-@M`   T`0  
p Pp  P  
o  P  
 , ` )    u  P  
 00     l0  0    0PP00    0000    U p O (  N  h  * A-PMa r  U`5  
p @p I P  
$  P  
  `     *  P  
 V @        h0 $0 @   0LL00 @000 @0  S LX N (  N  h  * A-@M` #  T`0  
p Pp U P  
  P  
  `       P  
 @0     h0 h%0   0PP00  d  0000  w  R W $N (  pM  h  ! A-@M`   T`0  
p Pp  P  
  P  
 I ` F      P  
 80     l0  0    0PP008    0000  -  Q  |M (  L l h  tJ A-@M`   T`0  
p Pp  P  
B  P  
  `     H  P  
 t00     l0  0    0PP00    0000    hP  L (  L D h  % A-PMa E  U`5  
p @p I P  
  P  
  `       P  
 ) @        h0 $0 @   0LL00 @000 @0  @O S  L (  TK  h  % A-PMa   U`5  
p @p I P  
  P  
 e ` b      P  
  @        h0 $0 @   0LL00O2 @000 @0  DN \R `K (  J  h  $ A-@M`   T`/  
p Pp   P  
Z  P  
  `     `  P  
  0   l0   0    0PP00 0 00000   0L  J (  ,J  h  I A-@M` ^  T`/  
p Pp   P  
  P  
  `       P  
 C 0   l0   0    0PP00 0 00000   0K  4J (  I  h   A-@M`   T`/  
p Pp   P  
  P  
  `       P  
  0   l0   0    0PP00u 0W 00000  j 0J  I (  H ` h   p@- 0   A P U T  p@ip@p@- P `P
  
PE @ \@   T pp@- P `P
  
PE @ H@   T pp@- P  `P
  
PE @ 4@    T pp@- P @ <<8 0  P  @  p0H |  G G p@- Pj @ <<8 0  P  @  pG    hG dG p@- PO @ <<8 0  P  @  pXG L  4G 0G p@- P4 @ <<8 0  P  @  pF D   G G p@- P @ <<8 0 ~ P  @ h pF @  F F t3O-04M @P  Ls      8#0  p  PP  
@  T  
3` T 0 0  
 0 0   P  
 @Pk  
@ O"     P1  
     X  
0T0;  E*  
 s P`  @  T  
 T 00@  
Hb0`  P  
f @Pn  
@ ""   n  P  
 @   	 @ 41!  0    4 i  @P  Y 
 Xht1h!  0  \  ,1  0   0$ 0 10 0    0    @ P@	@00  0@0   l0#0  0 0|00X0h0  G E F \   F PI F X  (  ,  4 d   D D  h   D D D D lD A-PM$$!0 0 p0 p a` @P   
@ T1  
00 T p@  
 p   P  
 @P  
@ b     @P  
 @    l0  0   0T 0P00U88080  LH D  B \  L D (  D C h  C A-0M`p P,1000 , @ $0       ``  P  
 0  P 0  
  P   0 0  8 @  T  00      0 `0 0   @H0 0 PN  0   v    dB C @ t  \  P  C A-0M`p PR,1000 , @ $0       F``  P  
 0  P 0  
  P   0 0   @  T  00      0 `0 0   @H0 0 P  0       @ TB  ?   \  P  A A-0M`p P,1000 , @ $0       ``  P  
 0  P 0  
R  P   T0 0   @  T  00      0 A`0 0  k @H0 0 P  0     J  ? @ =   \  P  4@ A-0M`p P,1000 , @ $0       ``  P  
 0  P 0  
  P   0 0  * @  T  00      0 `0 0   @H0 0 P@  0   h    ,> ? P<   \  P  > A-0M`p PD,1000 , @ $0       8``  P  
 0  P 0  
  P   0 0   @  T  00      0 `0 0   @H0 0 P  0       < > : `  \  P  d= 2O-00,M P 000b    "  `  P9  
@  Tj  
x"  @  T    
Xr p P  
 @P6  
@ ?,"    @Pm  
 p  W  r  
0T 	  E  
 c P,   ,  7 @P;  
  ,1!  0    , `1 0   0P 0L10  41 !   0    @ P@ 00     Y 
 X 0   0     p0x0   P0\0   t; 9 < =  = X  (  ,  X 8<  < d   h  $;   : ; C-( @pP lMD   `840,($  @p'< ` D0 	Lg`  P  
$@  Th 
47p T 0 0  
  0 0   P  
 @P  
$@ d&     P  
$   (@  T  
&  (@  T E 
   P  
 @P  
(@ Bp&     P  
( ,@  T 3 
 0 T0  
00  P  
h @P  
,@ $ &   p  P  
,  0@  T 
 0 T0  
0  P  
J @P  
0@ %   R  Pn  
0 ~ 4  X 
0T0  E  
 * P    8@  T( 
 0 T0  
0  P  
 @P  
8@ $   %  PA  
8 Q <@  T 
 0 T0  
0  P  
 @P  
<@ t$     P#  
< 3 @@  T  
 T 00@  
0t0p  P  
 @P  
@@  $     P  
@ @    @ l$ 3  0   0 030( 3  0   0p 0l30}\\3\#   0   @ P8@l	@$3$0  d  g @P  Y X[2"  0`   p `Hp2"  0   ;, <2X"0  0X 0T20-0 2#0  0( 0$2010  y10  r10  
k10  d1@0  \8 <1X"0  0| 0x10N< 1#0  0L 0H10@@ 0X"0  0 010200  +00  $00  H8 : ,6 \  X  ; @;  ; X9 ; 8 8< ,8 x< 7 < 87 = (  @7 07 8 8 X  d  ,  \ h  7   7 7 8 8 45 (6 6 h7 8 H8 48 8 8 X9 D9 x7 8 8 @-PMHH!0 0 0 $a` @P"  
@  T1  
!  @  T  1  
p p P  
 @P  
@ P     @P  
 @    0 0   0p 0l00C\0\0  <80<0  31 8 - l8  ~ 8 (  7 0 h  L0 0 O-L` @P <M$ pp 00 0H%00 0 $0  $e`  PT  
@  T  
%  @  T    
t p P  
$ @PQ  
@ $   , @P  
 Xp  W    
0T $  E,  
  PG  p  W 
0T   EW  
  P   p  W  
0T   E  
  P        @PI  
  <3#  0    < 3 0   0x 0t30 H\3H#   0    @ P4@  3 0  x 2"  0   j   Y 
 X2"  0   T 6   S @P  Y 
 Xx$2"  0    4 1 0  , x1!   0    @ P@ f10   ^HH1H!  0  h  P Z  @PH  Y 
 X B0   0    2 0    0    @ P@  p00   P0|0   . 7  , 7 @|  8 X  (  ,  p h6 P6 d   h  T5    4  4  L  3 4 C-`` @P dM@<pp  8 400000,00&(00$0 0 @0 f`  P  
$@  TJ 
h6p T 0 0  
T 0 0   P  
 @P  
$@ \ &     P  
$   (@  T  
%  (@  T ' 
   P  
~ @P  
(@ :%     P  
( ,@  T  
 0 T0  
d0  P  
` @P  
,@ 4%   h  Pn  
,  0@  T  
 0 T0  
0  P  
B @P  
0@ $   J  PP  
0 v 4  X  
0T0  E  
 " P  a  8@  T  
 0 T0  
H0  P  
 @P  
8@ $     P#  
8 I <@  T  
 T 00@  
s0p  P  
 @P  
<@ #     P  
< *@    @ d$ `3  0   0H 0D30( $3  0   0 030  3 #   0   @ P@	@20  z  } @P  Y Xypp2p"  0`   p` `^,2,"  0  ( Q, 1X"0  0 010C0 1#0  0 010510  .y|10  'r`10   kD1l0  d(1T@0  \8 0X"0  0  010N< 0#0  0 000@00  9|00  2( @3 & \  8v @3 03 u \3 8) `3 ( d3 ( ,3 ' ,3 (  / ' @0 \( X  d  ,   h  t' , ( |/ ' / `( % & ' ' `( t/ ( / ) ( ( A- @`P 8M$ pp 00 0#00 0 $0  c` @P  
@  T  
3p T 0 0  
| 0 0  P  
 @Pt  
@ tH#     Pe  
   @  T  
#  @  T   
  P  
 @Pa  
@ R"     PC  
 @  T   
 0 T0  
0  P  
x @PY  
@ 4\"     P%  
   @  Tz  
 T 00@  
r0p  P  
Y @PH  
 @ !   a  P  
  @  8 @ 8 1 0   0 010 `1 0   0P 0L10<1<0   1X"0  0 010  0#0  0 00000  00  x00  \0|0  `  . l \  n . . n . ! 0/ ! 0/ (  , ! , ! h  @! \- L- -     , | l2@-00$M P 000@b    4"  ` @PD  
@  TV  
"  @  T  j  
q p P  
 @P2  
@ Y!     P7  
 @  T  J  
!  @  T O  
pq p P  
{ @P)  
@ 7D!     P  
 @  $ 1 0   0 000* @00    0 0   0 000|00  
`0p0  D0X0    , - $j - - i . (  L, 8, h  + , , H, h+ d, l2@-00$M P 000@b    4"  N` @PD  
@  TV  
"  I@  T  j  
q p P  
 @P2  
@ !     P7  
 !@  T  J  
!  '@  T O  
pq p P  
 @P)  
@ D!     P  
 @  $ 1 0   0 000z] @00  p 0 0   0 000a|00  Z`0p0  SD0X0  L D p, l, dg , , f , (  \+ x) h  ( + $* ) ( ) O-` @P LM0,pp (0 & 0$00 000 0 00 tf`  Pc  
@  T  
\&  @  T    
<v p P  
4 @P`  
@ &   < @P  
 h p  W    
0T 3  E;  
 P  1T  *$p  W 
0T   Ee  
  P  (p  WF 
0T   E  
  P  ,p  W@ 
0T0 E  
  P       @PI  
  L4$  0    L 4 0   0 040 \p4\$   `D0    PL@ 8480  y 3#  0    k   Y
 X|3#  0   U 7   T @P  Y 
 Xj$83$#  0  8 5 30  - x2"   0    @ P@ f20   ^ i  @PV  Y 
 X9(<2("  0  L  A1!  0    31!   0    @ P@ !10   HH1H!  0  |     @P  Y 
 X 0   0     0    0    @ P@ t00   T00   \ * ` * d + X  (  ,  t () < d     h  @    p  '    &  <  % % 8O-` @P <M$ pp 00 0$00 0 $0  d`  Pb  
@  T  
$  @  T    
t p P  
\ @Pm  
@ p$   d  PB  
 @  T    
@$  @  T   
 t p  P  
: @Pq  
@ #   B  P   
 np  W   
0T   EE  
  P   p  W  
0T _  E  
  P       < 1  @P  Y 
 X3#  0      2 0   0 020 2"  0    |2|0    H2  0   0D 0@20    @P  Y 
 X 1!  0   j 1!   0    @ P@X z\1p0  P r<1T0  H j1   0   : \00  2 T 0    0    @ P@  B|00   :\00   2 ,%   %  ] @% d% \ % X  d  ,   (  #  d h   # # \  "    " , \" p" 3O-004M @P  c      #0  S`  PU  
@  T  
\#  N@  T    
<s p P  
 @Po  
@ #     P5  
 &p  W    
0T0?  E.  
 P  1b  *@  T  
"  @  T   
r p  P  
 @Pu  
@ }X"     P  
 @   d @ 42"  0   o 4  p @P  Y
 X1!  0   Q l1 0   0h 0d10B0@10!   (A0    P$@1@10  )00  "0@0   0  0   0 000|00  `0x0  }<	 X ! ! xW ! ! V ! X  (  ,     d     p h    D     L O-` @P LM0,pp (0 & 0$00 000 0 00 ?tf`  Pc  
@  T  
\&  9@  T    
<v p P  
 @P`  
@ &    @P  
  p  W    
0T 3  E;  
 P  1T  *$p  W 
0T   Ee  
  P  (p  WF 
0T   E  
  P  ,p  W@ 
0T0 E  
  P      g @PI  
  L4$  0   M L 4 0   0 040< \p4\$   `D0    PL@* 8480  " 3#  0       Y
 X|3#  0      Q  @P  Y 
 Xj$83$#  0  8  30   x2"   0    @ P@ f20   ^   @PV  Y 
 X9(<2("  0  L  A1!  0    31!   0    @ P@ !10  w HH1H!  0  | i   k @P  Y 
 X 0   0   K  0    0    @ P@9 t00  1 T00  )      $S 0 X  (  ,   <  d    T h   4  ,   H 0 (  d      2O-00,M P 000b    "  m`  P9  
@  Tj  
x"  h@  T    
Xr p P  
 @P6  
@ ,"    @Pm  
 @p  W  r  
0T 	  E  
  P,   ,   @P;  
  ,1!  0    , `1 0   0P 0L10  41 !   0    @ P@ 00  {   Y 
 X 0   0   d F p0x0  Y P0\0  Q     K   X  (  ,  |   d   h   D   2O-00,M P 000b    "  `  P9  
@  Tj  
x"  @  T    
Xr p P  
A @P6  
@ ,"   I @Pm  
 up  W  r  
0T 	  E  
 ! P,   , I  @P;  
  ,1!  0    , `1 0   0P 0L10  41 !   0    @ P@ 00     Y 
 X 0   0    { p0x0   P0\0   l    H  X  (  ,  P h  d   h     p l2@-00$M P 000@b    4"  ` @PD  
@  TV  
"  @  T  j  
q p P  
v @P2  
@ 2!   ~  P7  
 @  T  J  
!D  @  T O  
pq p P  
T @P)  
@ D!   \  P  
 @  $ 1 0   0 000 @00   0 0   0 000|00  `0p0  D0X0  @ h ( ( E T p  E  (    h  @    , 0 @-PMHH!0 0 0 .$a` @P"  
@  T1  
!  (@  T  1  
p p P  
 @P  
@      @P  
  @    0 0   0p 0l00{\0\0  tW80<0  kD \  @ B l (   X h    @-PMHH!0 0 0 $a` @P"  
@  T1  
!  @  T  1  
p p P  
i @P  
@ %    q @P  
 @    0 0   0p 0l00\0\0  80<0    4 x TA  (    h  $ \ @-PMHH!0 0 0 h$a` @P"  
@  T1  
!  b@  T  1  
p p P  
 @P  
@      @P  
 :@    0 0   0p 0l00\0\0  80<0      ?  (  ,  h   P 3O-004M @P  c      # 0 `  PU  
@  T  
\#  @  T    
<s p P  
 @Po  
@ V#     P5  
 p  W    
0T0?  E.  
 zP  1b  *@  T  
"  @  T   
r p  P  
i @Pu  
@ %X"   q  P  
 @    @ 42"  0    4 l  @P  Y
 X1!  0    l1 0   0h 0d100@10!   (A0    P$@@10  00  0@0   0  0   0 000|00  `0x0  }    >   T=  X  (  ,  @   d      h    `   x  O-` @P LM0,pp (0 & 0$00 000 0 00 tf`  Pc  
@  T  
\&  @  T    
<v p P  
 @P`  
@ A&    @P  
  p  W    
0T 3  E;  
 eP  1T  *$p  W 
0T   Ee  
 V P  (p  WF 
0T   E  
 H P  ,p  W@ 
0T0 E  
 : P     c  @PI  
  L4$  0    L 4 0   0 040 \p4\$   `D0    PL@ 8480   3#  0       Y
 X|3#  0        @P  Y 
 Xj$83$#  0  8  30  ~ x2"   0    @ P@l f20  d ^  f @PV  Y 
 X9(<2("  0  L G A1!  0   9 31!   0    @ P@' !10   HH1H!  0  |   g  @P  Y 
 X 0   0     0    0    @ P@ t00   T00       9  X  (  ,     d     h    L   \    H  (  0   4 @-PMHH!0 0 0 $a` @P"  
@  T1  
!  @  T  1  
p p P  
 @P  
@ v     @P  
 @    0 0   0p 0l00i\0\0  bE80<0  Y  x l 2  (    h  h  C- `pP M`\@(@ X@ $@  T P L00H00D00< @008 @+4 `0   k`  P 
4@  Tc 
+  4@  T   
z p P  
: @P0 
4@ *   B  P  
4 n8p  W  y 
0T0  E  
  P  # <@  T 
P:p 0 T0  
<0  P  
 @Po 
<@ *     P  
< ? @@  T 
 0 T0  
0  P  
 @P' 
@@ )     P  
@ ! D  Xo 
0T0  E. 
  P  C H@  T 
 0 T0  
 0  P  
 @P 
H@ |(     P|  
H  L@  T 
 0 T0  
0  P  
 @Ps 
L@ ^(     P^  
L  P  X 
0T0( EB 
  P  e T@  T 
 0 T 0  
 0  P  
u @P 
T@ 1'   }  P1  
T   X@  T 
0T0n W 
 U P $  \@  T 
 T 0(0@  
Tw(0p  P  
G @P 
\ ('   P  P  
\ |@(    @ 6&  0     K  @P  Y X6&  0`   pl `4 <6 0   04 0060 6 &  0@   P @@50     @P  Y Xp|5p%  0`   pt `@ ,5#0  0@ 0<505(0  x4@0  wp4$  0   jc< 4#0  0 040\ULX4L$  0@   Pp @K	@C(4P0  C<480  <53 @0  4-  7 @P%  Y X3#  0`   p `<<3<#  0  | H 3#0  0P 0L30L 2#0  0  0302"   0   @ P@	@t20  4424"  0   @ 2x0     @P  Y X$1!  0`   p `p|1p!   0   @ P@	@T(1# 1   0~1@0  }v0d0  vo0L0  oh\0# $1   0aZ00  ZS @ x 4 0 ` \    l   8 @       X  (  ,   d   ,   h      8 `   t  \    p         L 4 $   H  H                    2O-00,M P 000b    "  `  P9  
@  Tj  
x"  |@  T    
Xr p P  
  @P6  
@ ,"   ( @Pm  
 Tp  W  r  
0T 	  E  
   P,   , (  @P;  
  ,1!  0    , `1 0   0P 0L10  41 !   0    @ P@ 00     Y 
 X 0   0   x Z p0x0  m P0\0  e       0$   X  (  ,     d   h      @-PMHH!0 0 0 $a` @P"  
@  T1  
!  @  T  1  
p p P  
[ @P  
@     c @P  
 @    0 0   0p 0l00
\0\0  80<0      !  (    h   $ ,4O-0>4M @P   d      # 0 P`  PF  
@  Tw  
#  K@  T    
s p P  
 @PC  
@ t#    @P  
 #p  W    
0T   E  
  P9  p  W  
0T r  EI  
  P        @PI  
  42"  0   | 4 t2 0   0d 0`20k 4H24"   0    @ P @Y 20  Q 1!  0   C   Y 
 X|1|!  0   -    , @P  Y 
 X 1   0    00   w 0    0    @ P@ ep00   ]P0l0   U0 L   l  X  (  ,   H  d   h    h   t   @-PMHH!0 0 0 6$a` @P"  
@  T1  
!  0@  T  1  
p p P  
 @P  
@      @P  
 @    0 0   0p 0l00\0\0  |_80<0  s       (  h  h   ( l2@-0=$M P 000@b    4"  ` @PD  
@  TV  
"  @  T  j  
q p P  
k @P2  
@ '!   s  P7  
 @  T  J  
!D  @  T O  
pq p P  
I @P)  
@ D!   Q  P  
 }@  $ 1 0   0 000 @00   0 0   0 000|00  `0p0  D0X0   <   \ 8 (  T (   p h   <     l2@-0=$M P 000@b    4"  ` @PD  
@  TV  
"  @  T  j  
q p P  
 @P2  
@ w!     P7  
 @  T  J  
!D  @  T O  
pq p P  
 @P)  
@ UD!     P  
 @  $ 1 0   0 000H+ @00  > 0 0   0 000/|00  (`0p0  !D0X0  T |        (    h     (  D @-PMHH!0 0 0 s$a` @P"  
@  T1  
!  m@  T  1  
p p P  
 @P  
@      @P  
 E@    0 0   0p 0l00\0\0  80<0     d   (    h    2O-0S?,M P 000b    "  	`  P9  
@  Tj  
x"  @  T    
Xr p P  
 @P6  
@ d,"    @Pm  
 p  W  r  
0T 	  E  
  P,   ,  \ @P;  
  ,1!  0   B , `1 0   0P 0L101  41 !   0    @ P@ 00     Y 
 X 0   0      p0x0   P0\0    0  | P  X  (  ,   \ T d  ( h  \  0  ,4O-0>4M @P   d      #0  ;`  PF  
@  Tw  
#  6@  T    
s p P  
 @PC  
@ t#    @P  
 p  W    
0T   E  
  P9  p  W  
0T r  EI  
  P        @PI  
  42"  0   g 4 t2 0   0d 0`20V 4H24"   0    @ P @D 20  < 1!  0   .   Y 
 X|1|!  0      k  @P  Y 
 X 1   0    00   w 0    0    @ P@ ep00   ]P0l0   U     ( X  (  ,    H d  ~ h  L ~  ~ x  }   ,4O-0V?4M @P   d      #0  `  PF  
@  Tw  
#  @  T    
s p P  
 @PC  
@ rt#    @P  
 p  W    
0T   E  
  P9  p  W  
0T r  EI  
  P       ] @PI  
  42"  0   C 4 t2 0   0d 0`202 4H24"   0    @ P @  20   1!  0   
   Y 
 X|1|!  0      G  @P  Y 
 X 1   0    00   w 0    0    @ P@ ep00   ]P0l0   UL h 8 h 
  X  (  ,  z \ H d  ,z h  P z z  z x x ` p @-PMHH!0 0 0 $a` @P"  
@  T1  
!  @  T  1  
p p P  
 @P  
@ W     @P  
 @    0 0   0p 0l00J\0\0  C&80<0  :{      , (  x  h   4 2O-0Z?,M P 000b    "  `  P9  
@  Tj  
x"  @  T    
Xr p P  
2 @P6  
@ ,"   : @Pm  
 fp  W  r  
0T 	  E  
  P,   , :  @P;  
  ,1!  0    , `1 0   0P 0L10  41 !   0    @ P@ 00     Y 
 X 0   0    l p0x0   P0\0  w 0 X (  x H X  (  ,  u  l d  Pt h  t t H ` @-PMHH!0 0 0 $a` @P"  
@  T1  
!  @  T  1  
p p P  
m @P  
@ )    u @P  
 @    0 0   0p 0l00\0\0  80<0  0w  D  d  (  @  h  D | ,4O-0]?4M @P   d      # 0 b`  PF  
@  Tw  
#  ]@  T    
s p P  
 @PC  
@ t#   	 @P  
 5p  W    
0T   E  
  P9  p  W  
0T r  EI  
  P        @PI  
  42"  0    4 t2 0   0d 0`20} 4H24"   0    @ P @k 20  c 1!  0   U   Y 
 X|1|!  0   ? !   > @P  Y 
 X 1   0    00   w 0    0    @ P@ ep00   ]P0l0   Ux       X  (  ,  p  t d  Xo h  | 8o o ,o  m t  2O-0a?,M P 000b    "  A`  P9  
@  Tj  
x"  <@  T    
Xr p P  
 @P6  
@ ,"    @Pm  
 p  W  r  
0T 	  E  
  P,   ,   @P;  
  ,1!  0   z , `1 0   0P 0L10i  41 !   0    @ P@W 00  O   Y 
 X 0   0   8  p0x0  - P0\0  %   L < 0 h X  (  ,  k  $ d  k h  , k    ,4O-0>4M @P   d      #0  s`  PF  
@  Tw  
#  n@  T    
s p P  
 @PC  
@ t#    @P  
 Fp  W    
0T   E  
  P9  p  W  
0T r  EI  
  P        @PI  
  42"  0    4 t2 0   0d 0`20 4H24"   0    @ P @| 20  t 1!  0   f   Y 
 X|1|!  0   P 2   O @P  Y 
 X 1   0   / 00  ' w 0    0    @ P@ ep00   ]P0l0   U      X  (  ,  `h h ( d  g h  , |g g pg X  f d  l2@-0>$M P 000@b    4"  R` @PD  
@  TV  
"  M@  T  j  
q p P  
 @P2  
@ !     P7  
 %@  T  J  
!  +@  T O  
pq p P  
 @P)  
@ D!     P  
 @  $ 1 0   0 000~a @00  t 0 0   0 000e|00  ^`0p0  WD0X0  P, T   t $   @ (    h  , ( 4    x4O-0g?4M @P  Ld      8$0  `  PP  
@  T  
$  @  T    
s p P  
> @PL  
@ #   F @P  
 r@  T    
#  xp  W   
0T   E  
  P9  0 p  W  
0T k  EH  
  P      /  @PH  
  42"  0     2 0   0 020 `t2`"   0    @ PL@ 8280   1!  0        Y
 XM  0 c 10  v   x @P  Y 
 X <P1<!  0  L X 1,0  P ~ 0    0    @ P@> l00  6 dt0t   0   & TT0t0   Ll       X  (  ,  `   d  (` h   `  `  ^  L_  3O-0k?4M @P  c      #0  f`  PT  
@  T  
p#  a@  T    
Ps p P  
 @P`  
@ $#     P4  
 9@  T    
"  ?@  T   
r p  P  
 @Pd  
@ "     P  
 p  W   
0T   E8  
  PZ     x  4   @P  Y 
 X 1!  0   t  1 0   0 010d |1|!  0  x V d1d0  N  01  0   0, 0(10>  0    0    @ P@, 00  $ 00   |00   \0x0   w  @ 0  \  <  X  d  ,  \ (  h  <[ h     \Z  ,   ` O-o` @P <M$ pp 00 0%00 0 $0  Ppe`  P^  
@  T  
X%  J@  T    
8u p P  
 @PZ  
@ %    @P  
 "@  T    
$  (p  W   
0T %  E-  
  PG  0 p  W
 
0T y  EV  
  P   p  W 
0T   E  
  P       } @PH  
  <3#  0   c  3 0   0 030S t3t#   0    @ P`@A L3L0  9 3#  0   +    Y
 X  0  20    n  @P  Y 
 XTh2T"  0  d  42D0   2!   0    @ P@ m10   e1!  0    W !  @PO  Y 
 X I01!  0  @  9 0    0    @ P@ '0   0    t00   T00  { <  H  h   X  (  ,  pW   < d  V h  @ V 0 V  0U  U hU T T  T 3O-0>4M @P  c      #0  `  PT  
@  T  
p#  @  T    
Ps p P  
^ @P`  
@ $#   f  P4  
 @  T    
"  @  T   
r p  P  
< @Pd  
@ ~"   D  P  
 pp  W   
0T   E8  
  PZ     ~  4 A ~ @P  Y 
 X 1!  0   ~  1 0   0 010~ |1|!  0  x ~ d1d0  ~  01  0   0, 0(10~  0    0    @ P@~ 00  }~ 00  u~ |00  m~ \0x0  e~ w  d P ( | l   X  d  ,  Q (    P h     O     x4O-0g?4M @P  Ld      8$0  ~`  PP  
@  T  
$  ~@  T    
s p P  
K~ @PL  
@ ~#   S~ @P  
 ~@  T    
#  ~p  W   
0T   E  
 "~ P9  0 p  W  
0T k  EH  
 ~ P      <~ } @PH  
  42"  0   }  2 0   0 020} `t2`"   0    @ PL@} 8280  } 1!  0    }    Y
 XM  0 p} 10  }  } } @P  Y 
 X <P1<!  0  L e} 1,0  ]} ~ 0    0    @ P@K} l00  C} dt0t   0   3} TT0t0  +} L  t h    X  (  ,  M   d  \L h   <L  HL 0 J < K  3O-0>4M @P  c      #0  s}`  PT  
@  T  
p#  n}@  T    
Ps p P  
} @P`  
@ |$#   }  P4  
 F}@  T    
"  L}@  T   
r p  P  
| @Pd  
@ |"   |  P  
 $}p  W   
0T   E8  
 | PZ     |  4 | | @P  Y 
 X 1!  0   |  1 0   0 010q| |1|!  0  x c| d1d0  [|  01  0   0, 0(10K|  0    0    @ P@9| 00  1| 00  )| |00  !| \0x0  | w  x l    p  X  d  ,  H (    pG h     F  `   2O-00,M P 000b    "  c|`  P9  
@  Tj  
x"  ^|@  T    
Xr p P  
| @P6  
@ {,"   
| @Pm  
 6|p  W  r  
0T 	  E  
 { P,   , 
| { @P;  
  ,1!  0   { , `1 0   0P 0L10{  41 !   0    @ P@y{ 00  q{   Y 
 X 0   0   Z{ <{ p0x0  O{ P0\0  G{ p      X  (  ,  TD l  d  C h    D  t 3O-0>4M @P  c      #0  {`  PT  
@  T  
X#  {@  T    
8s p P  
4{ @Pn  
@ z#   <{  P4  
 h{p  W    
0T0>  E-  
 { Pc  @  T  
"D  `{@  T   
r p P  
{ @Pu  
@ zX"   {  P  
 8{@   z @ 42"  0   z 4 { z @P  Y 
 X1!  0   z l1 0   0d 0`10z0<10!   0    @ P @tz@10  lz00  ez0@0  ]z 0 0   0 000Nzx00  Gz\0t0  @z}D `     8    X  (  ,  @ d  A   |? h  $ h   <   x4O-0<4M @P  Ld      8$0  z`  PP  
@  T  
$  z@  T    
s p P  
'z @PL  
@ y#   /z @P  
 [z@  T    
#  azp  W   
0T   E  
 y P9  0 p  W  
0T k  EH  
 y P      z y @PH  
  42"  0   y  2 0   0 020y `t2`"   0    @ PL@y 8280  y 1!  0    ry    Y
 XM  0 Ly 10  _y  y ay @P  Y 
 X <P1<!  0  L Ay 1,0  9y ~ 0    0    @ P@'y l00  y dt0t   0   y TT0t0  y L~ ,| H 8 L d T X  (  ,  <  p d  ; h  t ; L ;  H:  :  l2@-0!>$M P 000@b    4"  Ry` @PD  
@  TV  
"  My@  T  j  
q p P  
x @P2  
@ x!   x  P7  
 %y@  T  J  
!  +y@  T O  
pq p  P  
x @P)  
@ xD!   x  P  
 y@  $ 1 0   0 000~xax @00  tx 0  0   0 000ex|00  ^x`0p0  WxD0X0  Px,y Tw T D t p `   (  4   h  D  0x w 0   @-PMHH!0 0 0 x$a` @P"  
@  T1  
!  x@  T  1  
p p P  
Gx @P  
@ x    Ox @P  
 {x@    0 0   0p 0l00w\0\0  ww80<0  wE L t (  T (    h  0 l 2O-0?,M P 000b    "  ?x`  P9  
@  Tj  
x"  :x@  T    
Xr p P  
w @P6  
@ w,"   w @Pm  
 xp  W  r  
0T 	  E  
 w P,   , w w @P;  
  ,1!  0   xw , `1 0   0P 0L10gw  41 !   0    @ P@Uw 00  Mw   Y 
 X 0   0   6w w p0x0  +w P0\0  #w t s P p (  X  (  ,  3  | d   3 h   3 `  3O-0?4M @P  c      #0  qw`  PT  
@  T  
X#  lw@  T    
8s p P  
w @Pn  
@ v#   w  P4  
 Dwp  W    
0T0>  E-  
 v Pc  @  T  
"  <w@  T   
r p  P  
v @Pu  
@ vX"   v  P  
 w@   v @ 42"  0   v 4 v v @P  Y 
 X1!  0   pv l1 0   0d 0`10av0<10!   0    @ P @Pv@10  Hv00  Av0@0  9v 0  0   0 000*vx00  #v\0t0  v}q o p `   t 0  X  (  ,  0 d  t0 ` d . h  |  P      @-PMHH!0 0 0 nv$a` @P"  
@  T1  
!  hv@  T  1  
p p P  
v @P  
@ u    v @P  
 @v@    0 0   0p 0l00u\0\0  uu80<0  u 8 k   @ (    h  , ` x3G-0?(M P 000L    @#  v
  P5  
@  T  
30 T 0 0  
#  u@  T    
0T t  e   
 uP V  * 0 `  V  
0T t!  E=  
 u PY      u `p[u @Pa  
  (HH2H"  0  4 Au ( u `pBu @P 	 W  V` 1!  0   `"u 1!  0   u \h1\!   `A0    PL@u  1!   0    @ P@t  	 W V   0`~00  t 00  t 00  t ~LX0L   0  d `t nk j < \  @ X  (  ,  * d  <+ 4*   ) l) h    p ) @-M @u ` t    u@@ PP$  
0 0 t pP	   t ` _t  Xt0  `0 @t  h   t  tH0 `0 @t  0   t  wt4 pf 4  L   P  $i h @-M @t ` It   t@@ PP$  
0 0 t pP	   @t ` t  t0  `0 @t  h   t  ;tH0 `0 @|t  0   t  ,t De p   X P  g g @-M @t ` s   t@@ PP$  
0 0 ;t pP	   s ` s  s0  `0 @@t  h   ht  sH0 `0 @1t  0   Yt  s d H    P  f f @-M @7t ` s   ?t@@ PP$  
0 0 s pP	   s ` ~s  ws0  `0 @s  h   t  sH0 `0 @s  0   t  s< b l  T  P  e de @-M @s ` hs   s@@ PP$  
0 0 s pP	   _s ` 3s  ,s0  `0 @s  h   s  ZsH0 `0 @s  0   s  Ks a x   ` P  td 8d C-MP @srp ` sKs  U  
20 U   E  
l2     P  
Fs  Py  
 s<2 0r  P B  
 :s0  S)  0 0  S @  9  @  
%s P    0 0@ S  01  S)  
  T 
Bs r  P    Y X3  00@ S  XX1X!   0   @ P4@r  10  r  0   0   r  0   0@   P @r  |0  0   0ll00r  <0T0  r  ` \  $    X  d  ,    h   (    $!   h C-MP @rrp ` Zrr  U  
20 U   E  
l2     P  
r  Py  
 Cr<2 05r  P B  
 zr0  S)  0 0  S @  9  @  
er P    0 0@ S  01  S)  
  T 
r .r  P    Y X3  00@ S  XX1X!   0   @ P4@r  10  q  0   0   q  0   0@   P @q  |0  0   0ll00q  <0T0  q  ] \  $    X  d  ,   h    (   $   ` O-MP @ rH
 p qq  U  
(20 U   L  
2    ` P  
q  Pc  
 q1 0uq  P W  
q0  S3  0    R2  
 @	b`  0 q@  0 S  0   R  
  R   
q  P  
0 Mq	 `  q   P8q    00  Gq  0 0,&  00 5q    t0  0   0dd00$q  40L0  q  Z \  $    X^  h  , (  0 L    O-MP @xq\
 p p#q  U  
<20 U   Q  
(2    ` P  
q  Ph  
 p1 0p  P \  
q0  S8  0    R7  
 @n	`    ;q@     0 S  0   R  
  R   
p  P  
0 p	 `  p1d  Pp    00  p  0 0&  00 p    t0  0   0dd00wp  40L0  op  X \  $   p [  h  x (  |   h  O-MP @p\
 p Epvp  U  
<20 U   Q  
(2    ` P  
qp  Ph  
 .p1 0 p  P \  
ep0  S8  0    R7  
 @z	`    p@     0 S  0   R  
  R   
8p  P  
0 o	 `  ?p1d  Po    00  o  0 0'  00 o    t0  0   0dd00o  40L0  o  XU \  $  $  Y H h   (      P O-MP @pd
 p oo  U  
D20 U   S  
02    ` P  
o  Pj  
 o 2 0$so  P ^  
o0  S:  0    R9  
 @	`    o@      0 00 S  0   R  
  R   
o  P  
0 Do	 `  o1  P/o    00  >o  0 0x(  00 ,o    t0  0   0dd00o  40L0  o  R \  $  h  PV  h   (    T   O-MP @ooH
 p n(o  U  
(20 U  ( L  
2  (  ` P  
o  Pc  
 n1 0n  P( W  
	o0  S3  0    R2  
 @U	`   (0 2o@  0 S  0   R  
  R   
n  P  
0 (n	 `  n  Pn    00  n  0 0h%  00 n    t0  0   0dd00sn  40L0  kn  O \  $    S  h   (   4  X  C-MP @nrp ` Anrn  U  
20 U   E  
l2     P  
mn  Py  
 *n<2 0n  P B  
 an0  S)  0 0  S @  9  @  
Ln P    0 0@ S  01  S)  
  T 
in n  P    Y X3  00@ S  XX1X!   0   @ P4@m  10  m  0   0   m  0   0@   P @m  |0  0   0ll00m  <0T0  m  HM \  $    X  d  ,  d h   (  <  x `  O-MP @nD
 p mm  U  
$20 U   K  
2    ` P  
m  Pb  
 jm1 0\m  P V  
m0  S2  0    R1  
 @	`   0 m@  0 S  0   R  
  R   
ym  P  
0 4m	 `  m  P m    00  /m  0 0<)  00 m    t0  0   0dd00m  40L0  m  HJ \  $    M X h   (       O-M@ ``m
 P lm  T  
20 T   T  
l2    p P  
m  Py  
 l<2 0l  P Q  
 l0  SN  0 0  S `  J  Q  
l P/  00` S;  00  S:  
 T
m l  P)   0   Y X0hh1h!  0 @   PL @l  1!   0    @ P@xl    00  ll  0   0   ]l  0  0   0ll00Nl  @0T0  Fl  G \  $    X  d  ,    h  H (  X <  
 O-M@ `l
 P lKl  T  
20 T   T  
l2    p P  
Fl  Py  
 l<2 0k  P Q  
 :l0  SN  0 0  S `  J  Q  
$l P/  00` S;  00  S:  
 T
Al k  P)   0   Y X0hh1h!  0 @   PL @k  1!   0    @ P@k    00  k  0   0   k  0  0   0ll00k  @0T0  k  D \  $  d 0 X  d  ,    h   (  X    O-M@ `k
 P Zkk  T  
20 T   T  
l2    p P  
k  Py  
 Ck<2 05k  P Q  
 zk0  SN  0 0  S `  J  Q  
dk P/  00` S;  00  S:  
 T
k -k  P)   0   Y X0hh1h!  0 @   PL @k  1!   0    @ P@j    00  j  0   0   j  0  0   0ll00j  @0T0  j  A \  $    X  d  ,    h   (  X   p 4M-0?(M P 000c    #  k`  PR  
@  T  
#  k@  T    
s p P  
j @Pd  
@ tjh#   j @P  
 j0D#   p P  
j @Pw  
0    P  
j @P|  
0 20 Fj  P   
j0   Rz  0   Q p  20  Hj  (n  
lj P6  00p Q^  0  Q
0 T0D
j 4j @P 0   [ Ze  0 1 0   0 010j 10  j 1!   0    ` p`i  L1 0  0T 0P10i  1 0  0  010i  i 0   0   i
 ~00  i v||0|   0 `   p| `i dH@ p>     $  0 < h   (   <@ ? X  d  ,       p   > l  3G-0%> M ` 000    x#  i  Px  
@  T  
P#  i@  T    
0S P P  
i @Pn  
@ Si#   i  PX  
 i0"   P P  
i @Po  
0    P  
vi @Pt  
0 20 %i  P 8  
pji0   Rr       R0  
HH @	
p  0P0P i@  0  RZ      R  
    \  
@i PPO  
00Pp h
   Fi  Ph   10  h   p1 0   0X 0T10h ,1<0  h  1 0  0 010h  0 0  0 000h  0    0  00 h D0p0  h ; 9     8 $     0 h   (   ; : 8 ( P    T: O-MP @hL
 p shh  U  
,20 U   M  
2    ` P  
h  Pd  
 \h1 0Nh  P X  
h0  S4  0    R3  
 @	`  0 h@  0 S  0   R  
  R   
jh  P  
0 %h	 `  qh   Ph    00  h  0 0 *  00 h    t0  0   0dd00g  40L0  g  6 \  $   t 9  h   (   `  |  p@- P Hh 0a  `  R @  
    g    :h$0    R  
    g   ,h(01S  
 p00   t00   \  @  hPg(P ` g  0    h  g ph3 7 7 \  D @ , 4G-0?0M @P        #0  g
  P4  
`  V  
30 V 0 0  
0T <  C|  
 ig @  T  
 @@  T  
0T tB  e]  
 ~g P  `  V  
0T tw  Eg  
 pg P     %g  02"   0    @ P@-g "  yg `P
 &g 00C  S 0 @0 03/ mg `pg @P 	 W  V`  2 "  0   `f 1!  0   f 0  0  f `x1`!  0  h f  *g `pf @P 	 W  V` 0   0   `f t00  f l 0    0    @ P@f Zx00  f RX0d0  f J3 1  \  X  d  ,  `  p t   (    t 4    h  z   h `H 4G-0?0M @P        #0  f
  P4  
`  V  
30 V 0 0  
0T <  C|  
 Nf @  T  
 @@  T  
0T tB  e]  
 cf P  `  V  
0T tw  Eg  
 Uf P     
f  02"   0    @ P@f "  ^f `P
 f 00C  S 0 @0 03/ Rf `pe @P 	 W  V`  2 "  0   `e 1!  0   e 0  0  e `x1`!  0  h e  f `pe @P 	 W  V` 0   0   `e t00  e l 0    0    @ P@e Zx00  ye RX0d0  qe JP/ l-  \  X  d  ,      0  (  (        h  xv   \+ C 2G-0?(M P 000    "  e
  P'  
`  V  
\20 V 0 0  
0T ,  Cp  
 6e @  T  
 @`  Vw  
0T t2  E  
 Ke PJ   (d  (1!  0   e (!  Ve `P
 e 00C  S 0 @0 03/ Je `pd @P 	 W  V` 1   0   `d  0    0    @ P@d p   0  d p0p0  d P0T0  d * ) t \  X  (  ,      d       h  r @ 0000\dP& T  000d0& T  p@-Pd   U &  
0 `T0D    
 d p d @Pyd  P @A @ pT TT0  0   < @\d,0, @0  Td& X  ,  (  T  h   p@-Pd   U &  
0 `T0D    
 fd  p d @P<d  P @@ @ pT TT0  0   < @d,0, @0  d% X  ,  (  `  h   0 00      /,$ \  A-td0  S  
 P  zd pP  
 0  S  
H` @`n !c@   _d 0 S A4( A-Rd(0  S  
 P$ Xd pP  
$0  S  
L` @`Un`( !c@   <d$0 S A' p@-/d0  S  
 P  5d `P  
 0  S  
 @0 c@   d 0 S pp@A-d0  S  
 `  d P  
 0  S  
Tp Pp~p@  [c@$P   c 0 S An& A-c0  S  
 `  c P  
 0  S  
Tp Ppz~p@  6c@P   c 0 S AI& A-c0  S  
 `  c P  
 0  S  
Tp Ppn~p@  c@P   c 0 S A$% A-c0  S  
 `  c P  
 0  S  
Pp Ppb~@  b@P   c 0 S A $ p@-c0  S  
 P c `P  
0  S  
 @0 c@   nc0 S pp@p@-bc0  S  
 P gc `P  
01  
 @0 b@   Pc0T pp@A-Dc0  S  
 `  Jc P  
 0  S  
Tp Pp~p@  b@P   ,c 0 S At# 0 00Q       
 /p@- @P    cHb@ P b  (   c  b  p \      p@- @ 0  0  R  
00 Jb01Spl   bdb@ P b  D   b  sb  p( 0        Pn p l X \  x0p@-0  @ b01SpL   bDb@ P lb  $   b  Fb  pm ~ ~ ~ x0p@-0  @ a01SpL   bDdb@ P Hb  $   b  "b  pm ,~ (~ ~ 0 00Q       
 /p@- @P   ^bH=b@ P !b  (   sb  a  p$ \  } } x} 0 00Q       
 /p@- @P   6bHb@ P a  (   Kb  a  p \  | | | x0p@-0  @ a01SpL   bDa@ P a  $   &b  a  pHk \| X| D| p@- @p    1aa01SpL   aDa@ P a  $   b  a  p { { { 0 00Q       
 /p@- @P   aHa@ P a  (   a  ca  p \  0{ ,{ { 0 00Q       
 /p@- @P   aH}a@ P aa  (   a  ;a  p$ \  z z xz 0 00Q       
 /p@- @P   vaHUa@ P 9a  (   a  a  p \  y y y 0 00Q       
 /p@- @P   NaH-a@ P a  (   ca  `  p \  Py Ly 8y 0 00Q       
 /p@- @P   &aHa@ P `  (   ;a  `  pD \  x x x p@- @p    1u`01SpL   aD`@ P `  $   a  `  p x x x 0 00Q       
 /p@- @P   `H`@ P `  (   `  w`  p \  w |w hw 0 00Q       
 /p@- @P   `H`@ P u`  (   `  O`  pt \  v v v p@- @ 0  0  R  
    _01Spl   `df`@ P J`  D   `  $`  p( 0        4v 0v v \  0 0,0Q       
 /p@- @P   W`H6`,@ P `  (   l`  _  p \  tu pu \u 0 00Q       
 /p@- @P   /`H`@ P _  (   D`  _  ph \  t t t x0p@-0  @ ~_01SpL   
`D_@ P _  $   `  _  p,c @t <t (t x0p@-0  @ Z_01SpL   _D_@ P _  $   _  _  pb s s s x0p@-0  @ 6_01SpL   _D_@ P _  $   _  __  pb  s s s 0 00Q       
 /p@- @P   _Hz_@ P ^_  (   _  8_  p \  r r lr 0 00Q       
 /p@- @P   s_HR_@ P 6_  (   _  _  px \  q q q x0p@-0  @ ^01SpL   N_D-_@ P _  $   c_  ^  p<` Pq Lq 8q 0 00Q       
 /p@- @P   '_H_@ P ^  (   <_  ^  pH \  p p p x0p@-0  @ v^01SpL   _D^@ P ^  $   _  ^  p_  p p p 0 00Q       
 /p@- @P   ^H^@ P ^  (   ^  x^  p \  o o lo p@- @ 0  0  R  
   7 $^01Spl   ^d^@ P s^  D   ^  M^  p( 0      l  n n n \  0 00Q       
 /p@- @P   ^H_^@ P C^  (   ^  ^  p \  n n  n x0p@-0  @ ]01SpL   [^D:^@ P ^  $   p^  ]  pp\ m m lm 0 00Q       
 /p@- @P   4^H^@ P ]  (   I^  ]  p| \  l l l 0 00Q       
 /p@- @P   ^H]@ P ]  (   !^  ]  p
 \  Hl Dl 0l x0p@-0  @ []01SpL   ]D]@ P ]  $   ]  ]  pZ k k k p@- @t    : 6]01SpL   ]D]@ P ]  $   ]  _]  p  k k k 0 00Q       
 /p@- @P   ]Hz]@ P ^]  (   ]  8]  p	 \  j j lj x0p@-0  @ \01SpL   v]DU]@ P 9]  $   ]  ]  pX i i i p@- @ 0  0  R  
00 \01Spl   M]d,]@ P ]  D   b]  \  p( 0       ,X Li Hi 4i \  0 00Q       
 /p@- @P   ]H\@ P \  (   2]  \  p  \  h h th p@- @ 0  0  R  
00  g\01Spl   \d\@ P \  D   ]  \  p( 0      t V g g g \  0 00Q       
 /p@- @P   \H\@ P \  (   \  `\  p \  $g  g g x0p@-0  @ \01SpL   \D}\@ P a\  $   \  ;\  p|U f f xf x0p@-0  @ [01SpL   z\DY\@ P =\  $   \  \  pT  f e e p@- P g\0 0 @$ [    _\    : [   T\01S  
 pT  @  A\H \P ` \  (   V\  [ pLT $ e e e A- ` -\@ @:M@ P [    #\  [   \01S  
 P  P  \D[@ p [  $   \  [ h 8d 4d  d p@- \ 0  A P U T  p@[p@[A-[0  S"  
 p  [ P  
 0  S  
 `A P  [   [ 0` S  0! 0 S R  4[   AHA-[0  S"  
 p  [ P  
 0  S  
 `A P  [[   [ 0` S  0! 0 S R  
[   AA-[0  S"  
 p  [ P  
 0  S  
 `A P  1[   [ 0` S  0! 0 S R  Z   A@-t[    P  @[@Z@-j[    P  @[@Z@-`[ $  P  @Z@Z@-V[   P  @Z@Z@-L[   P  @Z@Z@-B[   P  @Z@Z@-8[    P  @Z@Z@-.[   P  @Z@Z@-$[   P  @Z@Z@-[   P  @Z@vZ@-[   P  @Z@lZ@-[   P  @Z@bZ@-Z   P  @Z@XZ@-Z   P  @Z@NZ@-Z    P  @Z@DZ@-Z   P  @{Z@:Z@-Z    P  @qZ@0Z@-Z    P  @gZ@&Z@-Z   P  @]Z@Z@-Z   P  @SZ@Z@-Z    P  @IZ@Z@-Z    P  @?Z@Y@-Z   P  @5Z@Y@-Z   P  @+Z@Y@-Z    P  @!Z@Y@-zZ    P  @Z@Y@-pZ   P  @Z@Y@-fZ   P  @Z@Y@-\Z    P  @Y@Y@-RZ    P  @Y@Y@-HZ    P  @Y@Y@->Z   P  @Y@Y@-4Z    P  @Y@Y@-*Z    P  @Y@Y@- Z (  P  @Y@|Y@-Z ,  P  @Y@rY@-Z 0  P  @Y@hY@-Z 4  P  @Y@^Y@-Y 8  P  @Y@TY@-Y <  P  @Y@JY@-Y    P  @Y@@Y@-Y    P  @wY@6Y@-Y   P  @mY@,Y@-Y t  P  @cY@"Y@-Y   P  @YY@Y@-Y   P  @OY@Y@-Y x  P  @EY@Y@-Y    P  @;Y@X@-Y    P  @1Y@X@-Y    P  @'Y@X@-Y   P  @Y@X@-vY    P  @Y@X@-lY    P  @	Y@X@-bY    P  @X@X@-XY   P  @X@X@-NY    P  @X@X@-DY 0!  Q P  @X@X@-8Y 0! Q P  @X@X@-,Y 0! Q P  @X@X@- Y 0!  Q P  @X@zX@-Y 0!  Q P  @X@nX@-Y 0! Q P  @X@bX@-X 0!  Q P  @X@VX@-X 0!  Q P  @X@JX@-X 0! Q P  @X@>X@-X 0! Q P  @sX@2X@-X 0! Q P  @gX@&X@-X 0!  Q P  @[X@X@-X 0!  Q P  @OX@X@-X 0!  Q P  @CX@X@-X 0! Q P  @7X@W@-X 0! Q P  @+X@W@-X 0! Q P  @X@W@-xX 0! Q P  @X@W@-lX 0! Q P  @X@W@-`X 0!  Q P  @W@W@-TX 0!  Q P  @W@W@-HX 0!  Q P  @W@W@-<X 0! Q P  @W@W@-0X 0! Q P  @W@W@-$X 0! Q P  @W@~W@-X 0!  Q P  @W@rW@-X 0! Q P  @W@fW@- X 0! Q P  @W@ZW@-W 0! Q P  @W@NW@-W 0! Q P  @W@BW@-W 0! Q P  @wW@6Wp@- @0    P  mW01SpP   WHW@ P wW  (   W  QW  pWR R R p@- @0    P  HW01SpP   WHnW@ P RW  (   W  ,W  pVTR PR <R p@- @0    P  #W01SpP   jWHIW@ P -W  (   W  W  pVQ Q Q p@- P VW0 0 @ V    NW0    P
  V   DW01S  
 pV  P  @  .WDWP ` V  $   CW  V p@ P P P p@- P W0 0 @ {V    W0    P
  V   	W01S  
 plV  P  @  VDVP ` V  $   W  V p? O O O p@- P V0 0 @ @V    V0    P
  {V   V01S  
 p1V  P  @  VDVP ` {V  $   V  UV p0> N N N p@- P V0 0 @ V    V0    P  @V   V0    P  6V   V01S  
 pU  U  P  @  pVDOVP ` 3V  $   V  V pD= M M M p@- P ]V0$a ` @   P!   V    SV0    R  
   U   FV0    P  U   <V01S  
 pU  U  p00   X  @  VLUP ` U  ,   1V  U p  \  L L pL p@- P V0$a ` @   P!  U    U0    R  
   XU   U0    P  U   U01S  
 pIU  FU  p00   X  @  ULUP ` U  ,   U  cU pd  \  0K ,K K p@- P U0$a ` @   P!  TU    U0    R  
   U   U0    P  =U   U01S  
 pT  T  p00   X  @  pULOUP ` 3U  ,   U  U p 4 \  I I I p@- P [U0$a ` @   P!  T    QU0    R  
   T   DU0    P  T   :U01S  
 pT  T  p00   X  @  ULTP ` T  ,   /U  T p  \  H |H hH tA QO          !  &  +  0  4  E  8  =  ,1 0	CXT1 0> RT   NT0 0>C CHT0 0CCT0 0>C C=T0 0>C C7T0 0>C C1T0 0C,T0 0-=C C&Tx0 0*=C C Td0 0'=C CTP0@-0H  T  p 
 x ` H
 0
 
 
 	 	 	 	 	 (  G p@- @ 0  0  R  
 T  Pp01Sph   T``T@ P DT  @   T  T  p$ 0       F F F \  p@- @ 0  0  R  
 S  Pp01Sph   PT`/T@ P T  @   eT  S  p$ 0       XE TE @E \  C-P@,@MX  pSD$L@ ` Q^ *  E  e  ~           T  6   U 
 	H P  
S Pv 
 S+   S @PK 
 T        U 
`  P  
S P2 
 wS4+   S @PcS `LS  Uq 
  P  
S P) 
 \S*   S @P	 
 S           U8 
 HA P  
}S P= 
 :ST*   S @P 
 S    Ur 
  H P  
dS P 
 !S)   mS @P 
 S     U3 
 HA P  
HS P 
 S)   QS @PRt `Rn  U 
X HA P  
,S P 
 R,)   5S @PR `RR  U 
 HA P  
S P 
 R(   S @Pe 
 ES 0  0  U 
 H P  
R P3 
 Rd(   R @P< 
 *S    Ur 
0 -HA P  
R P  
 R(   R @PR `mR  U 
 *HA P  
R P  
 |R'   R @P 
 RX   R  U 
d 'HA P  
R P  
 `R8'   R @PLR `5R70  R *R `6 *0   060IR 	`R6  0   0607R 	`RH6 (0   0PP60%RD 	`Q 6 /0   060R 	`Qu5 /0   050R 	`Qcp5 P.0   050Q 	`QQ(5 -0   0``50QT 	`Q?4 ,0   0$$50Q 	`Q-4 )0   040Q 	`QP4 @+0   040Q 	`uQ	4 |*0   0pp40Qd 	`cQ3 ,0   04440Q( 	`QQaQ `JQZQ `CQSQ `<QLQ `5QEQ `.Q>Q `'Q7Q ` Ql3l0  FQ\ `Q<3D0  :Q4 `Q30  .Q `P20  "Q `P20  Q `Px|20  
Q `PlL2|0  Pl `P`2T0  PD `PT1,0  P `PH10  P `P<10  P `P0\10  P `P$ F   R  E E 0 F  8G < G  H H ` HI LI  I  J  XK \K  L < L L (  M M @ z @ lA \z A HL z L C y PC A y A C <y C tD x D HE x E xI dx I F x ,G G w H DE w E E (A `D G ? > I h  C D D  E B B 4A LA = = D; \; 0< L< $G @G (? @? D D tE E |= = l3O-0?<M @P $(@c       ,#0  P`  PJ  
@  T{  
 #  P@  T    
r p P  
XP @PG  
@ P"   `P @P}  
 P p  W    
0T   E"  
 8P P=  $@  T|  
L"X  P$   R {  
 O 0P	  
 0   OP O @P;  
  <1!  0   O < 1 0   0 010O h|1h!   0    @ PT@O @1@0  O   Y 
 X0   0   O O 00  O 00  O |00  O \0 l0  |O    E E % E E X  (  ,  h  @D 0  d    h  4  4      C C A Q   	        0 0>C C"O|0 0>C COh0 0  OX0 0w>C COD0 0  O40@-0,  O  |   ! l X! (  3 p@- @ 0  0  R  
 kO  Pp01Sph   zO`YO@ P =O  @   O  O  p$ 0        2 1 1 \  C-Ph%@M  pNDLE@ ` Q  #  >  X  s    U" 
 HA P  
O P  
 N$   O @P  
 @O        U 
 HA P  
N Po  
 Nx$   N @PN\ `}N  U  
@   P  
N P  
 N$   N @P  
 O     U  
 wHA P  
N PJ  
 qN#   N @P  
 N 0  0  U  
t   P  
N PA  
 VNL#   N @PBN0 `+N30  N  N ` 2 0(0   020=N 	`Nn2 l'0   020+N 	`M\T2   0    0XX20NL 	`MI2   0    020N 	`M61 0(0   010M 	`M$M `MM `MM `Mt1t0  Md `MD1L0  M< `M1$0  M `M00  M `|M00  M `pMA   F \ A A  `B  C  C C (  = D `? tj ? XA ,j A 0B i lB ? i ? B Li B (C ? @ h  @ @ L> d> A A < < > > l3O-0?<M @P $(@c       ,#0  M`  PJ  
@  T{  
 #  M@  T    
r p P  
pM @PG  
@ ,M"   xM @P}  
 M p  W    
0T   E"  
 PM P=  $@  T|  
L"  M$   R {  
 MM 0P	  
 0   gM M @P;  
  <1!  0   L < 1 0   0 010L h|1h!   0    @ PT@L @1@0  L   Y 
 X0   0   L L 00  L 00  L |00  L \0 l0  L  4 P 0A  A p LA A X  (  ,    ?    d    h  (         7  8 |0 Q0  
 Q  
 Q  
` @-0X  L  D0 0kC @4L00 0  /L 0 0  *L (  (    p@- @ 0  0  R  
 L  Pp01Sph   L`L@ P fL  @   L  @L  p$ 0      4 & & & \  C-@p#M`  LXs Vp PL  
 V/  
 V  
8380  zL( K P   T  
c `kFA P  
)L PI  
 K"   2L `P  
 ^L     0 0  Ty  
b `  P  

L P<  
 Kd"   L `PY  
 ?L     Tj  
(b `  P  
K P4  
 K "   K `PK PK1 &0   010K 	PoK`1   0    0tt10Kh 	P\K1   0    04410{K( 	PIKnYK PBKgRK P;K`00  aK P/KT00  UK P#KH00  IK PK<,= X (  4 ? T <=  > l D= H= ; ` ; = _ T= ; l_ < <= @; h  6 (< 4 ; <3 9 l3O-0?<M @P $(@c       ,#0  K`  PJ  
@  T{  
 #  K@  T    
r p P  
'K @PG  
@ J"   /K @P}  
 [K p  W    
0T   E"  
 K P=  $@  T|  
L"  SK$   R {  
 J 0P	  
 0   K J @P;  
  <1!  0   J < 1 0   0 010J h|1h!   0    @ PT@J @1@0  J   Y 
 X0   0   oJ QJ 00  dJ 00  \J |00  TJ \0 l0  KJ   ,  < ; L < ; X  (  ,    :   d    h    p      . . A Q        {  u  o  i  c  ]  W  Q  K  E  >    6  /  )    !            2 0> I1 0I1 0> I1 0}> I1 0bI1 0q> I1 0eI1 0= I|1 0= Ih1 0; IT1 0ID1 0I41 0nI$1 0 I1 00 I1 0 CI0 0VCI0 0CI0 0.C|I0 0CwI0 0F>C CqI0 0R>C CkI0 0_CfI|0@-0t  I     l T D (        x d P < (       (  ( p@- @ 0  0  R  
 VI  Pp01Sph   I`I@ P I  @   I  _I  p$ 0           \  p@- @ 0  0  R  
 %I  Pp01Sph   I`pI@ P TI  @   I  .I  p$ 0       \ X D \  C-P/@M.  pIDO@ ` Q  m  P      z ) .  [   >      Z        r  :    U 
L  P  
I Pn 
 H /   I @P 
 BI /  H   U 
 } P  
H P| 
 H.   H @P 
 $I-.  H  U 
x  P  
H Ps 
 HP.   H @P 
 	I..  H  U 
 q P  
H Pi 
 uH-   H @P 
 H     U 
  P  
H P_ 
 YH-   H @Po 
 H`-  vH  U 
H  P  
H P 
 =H-   H @Pv 
 H  s  U7 
 b P  
gH P 
 $H,   pH @P3 
 H   AHX  UL 
 H P  
LH PA 
 	H\,   UH @PG@ `G=  U 
$ e P  
1H P 
 G+   :H @PQ 
 fH@  P   0 \ @ 0 0  U 
  P  
	H P 
 Gd+   H @PPGH `G  Uj 
, n P  
G P 
 G+   G @P5G `G  U+ 
 H P  
G P" 
 G*   G @P|G `eG  U 
l RHA P  
G P 
 tG@*   G @P 
 G    0 0  U 
 _H P  
G P 
 WG)   G @P 
 G      0 0  Uc 
 FHA P  
zG PK 
 7G\)   G @Pw 
 Gx   TGk  U; 
  H P  
_G P 
 G(   hG @Pj 
 G  R  U^ 
  P  
EG P 
 G(   NG @PF| `F6  Uv 
` VH P  
*G P  
 F8(   3G @PqF `F  U 
  .H P  
G P  
 F'   G @P6 
 DG   F   U  
  P  
F Pg 
 Ft'   F @PFX `F  U 
<  P  
F PO  
 F'   F @P 
 G 0 0  U 
  P  
F PH  
 |F&   F @PhF `QF  U8 
| 0 P  
F P 
 aFT&   F @PMF8 `6F47 0  F +F `7 $0   050JF 	`Fw6 L#0   0508F 	`Fet6 "0   0hh50&F\ 	`ES,6 L!0   0,,50F  	`EA5 "0   040F 	`E/5 \$0   040E 	`ET5 \&0   0xx40El 	`E5  0   0<<40E0 	`E4 %0   0  40E 	`E|4 !0   030E 	`vE44 %0   030E| 	`dE3  %0   0LL30E@ 	`RE3 #0   030rE 	`@E\3 0*0   020`E 	`.E3  !0   020NE 	`E{2 $0   0\\20<EP 	`
Ei2 !0   0  20*E 	`DW<2 "0   010E 	`DE4   K   l H  I   E   G    A P D  8 8 p A  ; ; d X: \:  2  3  0  .  |0 ( 3  : : T (3 ,3  0 | P5 T5   :  |7 7 < 2 2  LB P8 J 8 5 `J 6 - J - 8/ I t/  . I <. * @I * 8 H 9 / H D/ 07 hH l7 H:  H : H' G ' ( G X( ) HG * =  G =  / F \/ 2 pF 43 / (F / X0 E 0 ) B * 5 PB 5 7 B 7 2 A 3 (  5 xA 6 4 46 4 2  7 8 0 " ! d% x. $  0 $  *  $ ! ! / / 	 L"  ( ( \ (  |% 4 4  1 1 3 ,3 @- \- P/ l/ | !  ` @* \* $
 " $ $ ( (  d 8 P / / h  * ,* 1 < 0   0XX10FDd 	`DsT1 '0   0104D 	`Da1 l)0   010"D 	`CO1  '0   020D 	`C=,2 (0   0DD20CP 	`C+Ch `C$C `CC `CC `CC `CC `CC `CC `CC( `CC@ `CCX `CCp `xCC `qCC `jC30  C `^C430  C `RCd30  xC `FC300  lC@ `:C3X0  `Ch `.C30  TC `"C$40  HC `CuT40  <C `
Ci40  0C `B]4 0  $C0 `BQ4H0  CX `BE5p0  C `B9D50   C `B-t50  B `B!50  B `B50  B  `B	680  BH `B46`0  Bp `Bd60  B `B60  B `zB60  B `nB6 0  B `bB$7$0  B4 `VBl3O-0?<M @P $(@c       ,#0  B`  PJ  
@  T{  
 #  B@  T    
r p P  
B @PG  
@ @B"   B @P}  
 B p  W    
0T   E"  
 dB P=  $@  T|  
L".  B$   R {  
 FB 0P	  
 0   {B 'B @P;  
  <1!  0   B < 1 0   0 010A h|1h!   0    @ PT@A @1@0  A   Y 
 X0   0   A A 00  A 00  A |00  A \0 l0  A    2 2  2 2 X  (  ,  ^  H1 \  d  T]  h  h  ]  @  <  @ p l3O-0?<M @P $(@c       ,#0  A`  PJ  
@  T{  
 #  A@  T    
r p P  
A @PG  
@ MA"   A @P}  
 A p  W    
0T   E"  
 qA P=  $@  T|  
L".  A$   R {  
 SA 0P	  
 0   A 4A @P;  
  <1!  0   A < 1 0   0 010	A h|1h!   0    @ PT@@ @1@0  @   Y 
 X0   0   @ @ 00  @ 00  @ |00  @ \0 l0  @    / /  / / X  (  ,  LZ  `.   d  Y  h    Z  t  p  t  A Q!  	        0 0> [@0 0> U@l0 0> O@X0 0J@H0 0> D@40@-0,  @  `  | d L 8 (    p@- @ @0  P   P  m@    @0    P  c@   @  ^@  P"  
 @ 01S  
 p@  @  P  P  @Ds@ @ ` W@  $   @  1@Ph  d  P  p@- @ @0  P   P  &@    y@0    P  @   o@  @  P"  
 f@ 01S  
 p?  ?  P  P  M@D,@ @ ` @  $   b@  ?PL  H  4  p@- @ :@0  P   P  ?    2@0    P  ?   (@  ?  P"  
 @ 01S  
 p?  ?  P  P  @D? @ ` ?  $   @  ?P0  ,    C-P%@M  p?D E@ ` Q    :  U  o    U' 
  P  
? P  
 \?$   ? @P  
 ?     U  
h  P  
? Pp  
 @?<$   ? @P,?  `?  U  
  P  
g? Pf  
 $?#   p? @P? `>  U  
  P  
L? P]  
 	?x#   U? @P>\ `>  U  
@  P  
0? PS  
 >#   9? @P> `>20  W? > ` 2 *0   020> 	`>md2 +0   0``20>T 	`>[2 |,0   0$$20> 	`~>I1 @-0   010> 	`l>71 @-0   010> 	`Z>%j> `S>t1t0  y>d `G>D1L0  m>< `;>1$0  a> `/>00  U> `#>00  I> `>(  , -  ( ( L H) L)  ) ) p T* X* (    D+ l& , & ' , X' ' @, ( p( + ( ) + \) ) h     $ l %   L&  '   ' D0 Q0   4    =$ @-0  s>  D  (    p@- @ c>0  P   P  >    [>0   =  P)  
 Q>0 0 =   G>01S  
 p=  T  P  1>H>@ ` =  (   F>  =P       C-@\!`M  p= V@a` P    T>  
,  P  
= P  
 = !   = `P$  
 >   00  = W= P0 .0   000v= 	PD=T=h P==T0T0  c=D P1=&   & (    & % X' 8& l& h    p% G- @`P @M,(pp $00  0l$00 0 ,0  =H
  PF  
`  V  
040 V 0 0  
0T N  C  
 $= @  T0  
 @ @  T  
0T tT  eo  
 9= P&  $`  V  
0T t  E  
 += P  (@  Tq  
l#  w=(   R   
 %= 0P  
 0  <  @3#   0    @ P@< "  "= `P
 < 00C  S 0 @0 03/ = `p< @P 	 W  V`HH2H"  0  @ `<  2"  0   < @  0  < 10  <  < `p< @P 	 W  V`uTT1T!  0  d `f< {,1!  0  ( X< m10  P< e 0    0    @ P@>< S00  6< K|00  .< C\0 t0  %<  9 %  \  `% X  d  ,  I      @I  (  8H    h  d# LH  DG  l  F    ! D" 0 Q0  
 Q  
 Q  
h @-0`  j<  L0 0 ;80 0 ;$0 0 ; (    4   p@- @ 0  0  R  
  ;  Pp01Sph   0<`<@ P ;  @   E<  ;  p$ 0      h       \  C-@d#M` 8 ;Ls Vp PQ  
 V3  
 V  
,3,0  < g; P   T  
b ` P  
; Pa  
 s;"   ; `P|  
 ;            Tr  
pb ` P  
; P+  
 O;D"   ; `P;;( P$;  Tn  
b ` P  
v; P3  
 3;!   ; `P; P;1 .0   010(; 	P:<1 .0   0XX10;L 	P:|0 .0   010; 	P:j: P:c00  : P:W00  : P:K00  : P:?   (    #     x" |"      4!   t!        h          |0 Q0  
 Q  
 Q  
` @-0X  ;  D0 0>o:40 0Cj:$0 0C @d:~ (       C-@#M` P :hs Vp PQ  
 V2  
 V  
H3H0  :8 E: P   T  
c `> P  
: PP  
 R:"   : `P  
 :            Tz  
b `F P  
r: P?  
 /:h"   {: `PZ  
 :P   L:   Ti  
$b `FA P  
T: P3  
 :!   ]: `P9 P91 /0   010: 	P9X1 .0   0pp109d 	P9|1 /0   044109( 	P9j9 P9c9 P9\00  9 P9P00  9 P9D00  9 P~98 ~ (  T  "    l !        T   P L     8   h       h  T2G-0->0M P  00$0(    "  9
  P)  
`  Vi  
0T t  E#  
 9 P.    @  TS  
!P  9    R Z  
  9 0P
  
 00 9 `pU9 @P$  
  0PP1P!  0  < ;9 0 1!   0    @ P@(9 0 	 W  V `0   0   `9 00  	9 l0p0  9 L0 P0  8  { y   X  (  ,  :  d  L:  :  h  p \   G-  MD9O@ pP 
  =9 PP 
  89 P 
  39 P 
  .9 P 
 
9o`  P   

 9  P(  
h 8  P  
P 8  P  
8 8  P  
  8o`  P  
 8  P   
 8  P  
 8  P  
 8  P$  
 8  P  
	 8  P,  
t 8  P0  
\~(0pT^t:8(0P?@
8(08;`8(00
8(0d? 8(0>8(0=8(0=L8(0T<8(0;8(0: 8(0:<8(0D9x
8(08	8(0?8(078(06,8(0=h8(0H>8(0468(0p58(048(038(03 }8(0$3Xy8(0`2u8(01q8(00m8(00Hi8(00 e8(0t1@ a8(082]8(02Y8(03U8(04PQ8(0H5M8(06I8(0T4E8(06A8(07`=8(02$98(0258(0X8\18(09-8(0D1)8(09 %8(0:p	!8(094
8(0=@	8(088(0h;|8(0(8
8(0,<	8(0d78(0<8(067(0=07(0<D7(0;P7(0x>7(057(05l7(0<?7(0p>7(04?7:(   7, 00,$<7> 7  P~
 7  Pz
 YP 7  Ps
  7  Po
 YPE @	7  Ph
 E7  Pd
 E @ 7  P_
 E @6  PZ
 E @6  PU
 E6  PQ
 -E @6  PL
 *E @6  PG
 ,YP'E @6  P@
 	E6  P<
 i`: 6  P5
 E @6  P0
 wE @6  P+
   @ @6  P$
 7 6  P
 kE @6  P
 _E6  P
 RE @6  P
 `  16  P
 LXPFE @6  P
 E6  P 
 .E6  P	 E6  P	 VE6  P	  E6  P	 0 6  P	  6  P	 n6  P	 WP6  P	 {6  P	  v6  P	  q6  P	  l6  P	 Tg`f6  P	 eb6  P	 q ]6  P	 bY6  P	 U6  P	 f`} N6  P	  I6  P	 VP C6  P	 ?6  P	  :6  P	 66  P	  16  P	  ,6  P	  '6  P	 z "6  P	 8f` 6  Pz	  VPn 6  Ps	 6  Po	 b6  Pk	  6  Pf	 16  Pb	  5  P]	  5  PX	 U 5  PS	 I 5  PN	 tUP 5  PG	 \e`F5  PA	 F @5  P<	 >5  P8	 ^FPE 5  P2	 F @5  P-	 4 :6  P'	 
4$ 04 0   N6 @P	 
? 5d`TPp   55   55   5t5p   5`5\   5L5H   5854   }5$5    v55   o55   h55   a55   Z55   S55   L55   E5 5t   >5d5`   755H   05|50   )5 u5   "5 n5   5g5   5`5   5Y5   5R5   46 K5   4 D5   4  =5h   4 65P   4 /58   4 (5    4 !5   4 5   4  5   4@ 5   4 5   44  P xw D D H < 8 l              x  z   u X  t @ s  , r l Dr  q   0  0      o  ?  p   t   p !  p   p  p  t  t A  t t x    z                               p ` L @ 0 L < 0 , ( (                     $ ( , 0 8 < < H X ` d l p t x |                                           | | p h \ P H D 8 ,                                                        |    34`   33x   33   3
3   3
3   3	3   3	3   33   }33    v338   o33P   h33h   a33   Z3 3   S3 3   L3 3   E3 3   >3 3   73  3   03 |3(   )3 u3@   "3 n3X   3 g3p   3 `3   3  Y3   3@ R3   2 K3   2D3   2=3    263   2 /30   2 (3H   2 !3`   2 3x   2 3   2  3   2@ 3   2 2   22   22   22    2 28   2 2P   2 2h   2 2   z2 2   s2 2   l2 2   e2 2   ^2 2   W2 2   P2 2(   I2 2@   B2 2X   ;2 2p   42 2   -2 y2   &2 r2   2 k2   2	 d2   2
 ]2    
2 V2   2 O20   1 H2H   1  A2`   1 :2x   1 32   1 ,2   1 %2   1 2   1 2   1 2   1 	2    1  28   1 1P   1 1h   1 1   1 1   1 1   1 1   1 1   ~11   w1 1   o1 1,   h1 1D   a1 1\   Z1 1t   S1 1   L1 1   E1 1   >1 1   71 1   01 |1   )1 u1   "1 n14   1 g1L   1 `1d   1 Y1|   1 R1   0	 K1   0
 D1   0 =1   0 61   0 /1   0 (1$   0 !1<   0 1T   0 1l   0 1   0 1   0 0   0 0   0 0   0 0   0 0   0 0,   0 0D   0 0\   z0 0t   s0  0   l0@ 0   e0 0   ^00   W00   P00   I00   B0
04   ;0
0L   40	0d   -0	y0|   &0r0   0k0   0d0   0]0   
0V0   0O0   /H0$   /A0<   /:0T   /30l   /,0   /%0   /0   /0   / 0   / 	0   / 0t   /  /\   / /D   / /,   / /   / /   / /   / /   ~/ /   w/ /   p/ /   i/ /l   b/ /T   [/ /<   T/ /$   M/  /   F/ /   ?/ /   8/ /   1/  }/   */ v/   #/ o/|   / h/d   / a/L   / Z/4   / S/    / L/   . E/   .	 >/   .
 7/   .90.9  .P? 0P? .:l0.:  . 0L0  0 .?00.E? B . ? 0 ?" .\>0.E\> B .=0.E= B .<0.E< B .< 0<" .L;x0--EL; B .:X0*-E: B |.980'-E9 B s. 9 0 9" k.>0:->  b.<80.E<8 B Y.x70w.Ex7 B P.70.C,, B E.=x07-=  <.6X0k.E6 B 3.5 405" +.,50R.E,5 B ".3 03 .h40F.Eh4 B .303'  	.20 2 .20b/2 -X1l0/X1 -0P01.0 -0040/00 -0 00 -1 01 -|2 0|2 -@3 0@3 -40+4  -40-4  -5h0-5  -3pD03  -P6 $0P6 -70q.7  -1 01 -L2 0L2 |-70}.7  s-80.8  j-0 p00 b-`9 T0`9 Z-$:<0.$:  Q-09 009 I-= 0,=  @-l80.l8  7-:0.:  .-70z.7  %-;0.;  -6`0n.6  -p< <0p< - 6  0 6 -4=0.4=  ,@< 0@< ,|;0.|;  ,=0.=  ,\50b/\5 ,4p0 4 ,Xb>T`0.>  ,> ,0>" ,?0.F? B ,? 0? ,h=0.Fh= B ,<.F0  B<G,x p l h p t |                    ( 4 < L \   L    `  $  
  
  l
  0
  	  	  t	  8	   	  x  
  	  l P    	      
  x  D    
  
  `
  (
  	  	  	  H	  	      \         @  8        0  
  
  $	      d         d  D	     ,    h         X   @-struct samr_DomInfo13   struct samr_DomInfo12   struct samr_DomGeneralInformation2  struct samr_DomInfo9    struct samr_DomInfo8    struct samr_DomInfo7    struct samr_DomInfo6    struct samr_DomInfo5    struct samr_DomOEMInformation   struct samr_DomInfo3    struct samr_DomGeneralInformation   struct samr_DomInfo1    struct samr_GroupInfoAttributes struct samr_GroupInfoAll    struct samr_AliasInfoAll    struct samr_UserInfo26  struct samr_CryptPasswordEx struct samr_UserInfo25  struct samr_UserInfo24  struct samr_CryptPassword   struct samr_UserInfo23  struct samr_UserInfo21  struct samr_LogonHours  struct samr_UserInfo20  struct samr_UserInfo18  struct samr_Password    struct samr_UserInfo17  struct samr_UserInfo16  struct samr_UserInfo14  struct samr_UserInfo13  struct samr_UserInfo12  struct samr_UserInfo11  struct samr_UserInfo10  struct samr_UserInfo9   struct samr_UserInfo8   struct samr_UserInfo7   struct samr_UserInfo6   struct samr_UserInfo5   struct samr_UserInfo4   struct samr_UserInfo3   struct samr_UserInfo2   struct samr_UserInfo1   struct samr_DispInfoAscii   struct samr_DispEntryAscii  struct samr_DispInfoFullGroups  struct samr_DispEntryFullGroup  struct samr_DispInfoFull    struct samr_DispEntryFull   struct samr_DispInfoGeneral struct samr_DispEntryGeneral    struct samr_ConnectInfo1    struct samr_ValidatePasswordRepCtr  struct samr_ValidatePasswordInfo    struct samr_ValidationBlob  struct samr_ValidatePasswordReq3    struct samr_ValidatePasswordReq2    struct samr_ValidatePasswordReq1    struct userPwdChangeFailureInformation  struct samr_PwInfo  struct samr_RidWithAttributeArray   struct samr_RidWithAttribute    struct samr_RidAttrArray    struct samr_Ids struct samr_SamArray    struct samr_SamEntry    struct samr_GroupInfoDescription    Cannot delete NDR object: struct object->modified_count_at_last_promotion   Expected type %s or %s within range 0 - %llu, got %ld   Expected type %s or %s  Cannot delete NDR object: struct object->domain_create_time Cannot delete NDR object: struct object->sequence_num   Cannot delete NDR object: struct object->lockout_threshold  Expected type %s or %s within range 0 - %llu, got %llu  Cannot delete NDR object: struct object->lockout_window Cannot delete NDR object: struct object->lockout_duration   Cannot delete NDR object: struct object->domain_server_state    Cannot delete NDR object: struct object->role   Cannot delete NDR object: struct object->force_logoff_time  Cannot delete NDR object: struct object->num_aliases    Cannot delete NDR object: struct object->num_groups Cannot delete NDR object: struct object->num_users  Cannot delete NDR object: struct object->unknown3   Cannot delete NDR object: struct object->password_properties    Cannot delete NDR object: struct object->password_history_length    Cannot delete NDR object: struct object->min_password_length    Cannot delete NDR object: struct object->attributes Cannot delete NDR object: struct object->num_members    Cannot delete NDR object: struct object->password_expired   Cannot delete NDR object: struct object->private_data_sensitive Cannot delete NDR object: struct object->nt_password_set    Cannot delete NDR object: struct object->lm_password_set    Cannot delete NDR object: struct object->code_page  Cannot delete NDR object: struct object->country_code   Cannot delete NDR object: struct object->logon_count    Cannot delete NDR object: struct object->bad_password_count Cannot delete NDR object: struct object->units_per_week Cannot delete NDR object: struct object->fields_present Cannot delete NDR object: struct object->acct_flags Cannot delete NDR object: struct object->primary_gid    Cannot delete NDR object: struct object->rid    Cannot delete NDR object: struct object->buf_count  Cannot delete NDR object: struct object->force_password_change  Cannot delete NDR object: struct object->allow_password_change  Cannot delete NDR object: struct object->acct_expiry    Cannot delete NDR object: struct object->last_password_change   Cannot delete NDR object: struct object->last_logoff    Cannot delete NDR object: struct object->last_logon Cannot delete NDR object: struct object->lm_pwd_active  Cannot delete NDR object: struct object->nt_pwd_active  Cannot delete NDR object: struct object->idx    Cannot delete NDR object: struct object->count  Cannot delete NDR object: struct object->unknown2   Cannot delete NDR object: struct object->client_version Cannot delete NDR object: struct object->status Cannot delete NDR object: struct object->length Cannot delete NDR object: struct object->pwd_history_len    Cannot delete NDR object: struct object->bad_pwd_count  Cannot delete NDR object: struct object->lockout_time   Cannot delete NDR object: struct object->bad_password_time  Cannot delete NDR object: struct object->clear_lockout  Cannot delete NDR object: struct object->pwd_must_change_at_next_logon  Cannot delete NDR object: struct object->password_matched   Cannot delete NDR object: struct object->extendedFailureReason  Cannot delete NDR object: struct object->data   default/librpc/gen_ndr/py_samr.c:8866: Expected type '%s' for '%s' of type '%s' Cannot delete NDR object: struct object->data[data_cntr_0]  Expected list of type %s, length %zu, got %zd   default/librpc/gen_ndr/py_samr.c:8507: Expected type '%s' for '%s' of type '%s' Cannot delete NDR object: struct object->hash   default/librpc/gen_ndr/py_samr.c:6503: Expected type '%s' for '%s' of type '%s' Cannot delete NDR object: struct object->hash[hash_cntr_0]  Cannot delete NDR object: struct object->general    default/librpc/gen_ndr/py_samr.c:1744: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:1745   Cannot delete NDR object: struct object->primary    default/librpc/gen_ndr/py_samr.c:1422: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:1423   Cannot delete NDR object: struct object->domain_name    default/librpc/gen_ndr/py_samr.c:1372: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:1373   Cannot delete NDR object: struct object->oem_information    default/librpc/gen_ndr/py_samr.c:1322: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:1323   default/librpc/gen_ndr/py_samr.c:810: Expected type '%s' for '%s' of type '%s'  default/librpc/gen_ndr/py_samr.c:811    default/librpc/gen_ndr/py_samr.c:786: Expected type '%s' for '%s' of type '%s'  default/librpc/gen_ndr/py_samr.c:787    default/librpc/gen_ndr/py_samr.c:762: Expected type '%s' for '%s' of type '%s'  default/librpc/gen_ndr/py_samr.c:763    Cannot delete NDR object: struct object->description    default/librpc/gen_ndr/py_samr.c:2821: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2822   Cannot delete NDR object: struct object->name   default/librpc/gen_ndr/py_samr.c:2703: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2704   default/librpc/gen_ndr/py_samr.c:3448: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3449   default/librpc/gen_ndr/py_samr.c:3377: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3378   Cannot delete NDR object: struct object->password   default/librpc/gen_ndr/py_samr.c:9033: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9034   default/librpc/gen_ndr/py_samr.c:8977: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:8978   Cannot delete NDR object: struct object->info   default/librpc/gen_ndr/py_samr.c:8953: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:8954   default/librpc/gen_ndr/py_samr.c:8752: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:8753   default/librpc/gen_ndr/py_samr.c:8696: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:8697   default/librpc/gen_ndr/py_samr.c:8672: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:8673   Cannot delete NDR object: struct object->logon_hours    default/librpc/gen_ndr/py_samr.c:7872: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7873   Cannot delete NDR object: struct object->private_data   default/librpc/gen_ndr/py_samr.c:7527: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7528   Cannot delete NDR object: struct object->nt_owf_password    default/librpc/gen_ndr/py_samr.c:7503: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7504   Cannot delete NDR object: struct object->lm_owf_password    default/librpc/gen_ndr/py_samr.c:7479: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7480   Cannot delete NDR object: struct object->parameters default/librpc/gen_ndr/py_samr.c:7455: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7456   Cannot delete NDR object: struct object->comment    default/librpc/gen_ndr/py_samr.c:7431: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7432   Cannot delete NDR object: struct object->workstations   default/librpc/gen_ndr/py_samr.c:7407: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7408   default/librpc/gen_ndr/py_samr.c:7383: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7384   Cannot delete NDR object: struct object->profile_path   default/librpc/gen_ndr/py_samr.c:7359: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7360   Cannot delete NDR object: struct object->logon_script   default/librpc/gen_ndr/py_samr.c:7335: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7336   Cannot delete NDR object: struct object->home_drive default/librpc/gen_ndr/py_samr.c:7311: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7312   Cannot delete NDR object: struct object->home_directory default/librpc/gen_ndr/py_samr.c:7287: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7288   Cannot delete NDR object: struct object->full_name  default/librpc/gen_ndr/py_samr.c:7263: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7264   Cannot delete NDR object: struct object->account_name   default/librpc/gen_ndr/py_samr.c:7239: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7240   default/librpc/gen_ndr/py_samr.c:6907: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6908   Cannot delete NDR object: struct object->lm_pwd default/librpc/gen_ndr/py_samr.c:6692: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6693   Cannot delete NDR object: struct object->nt_pwd default/librpc/gen_ndr/py_samr.c:6668: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6669   default/librpc/gen_ndr/py_samr.c:6296: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6297   default/librpc/gen_ndr/py_samr.c:6246: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6247   default/librpc/gen_ndr/py_samr.c:6196: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6197   default/librpc/gen_ndr/py_samr.c:6146: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6147   default/librpc/gen_ndr/py_samr.c:6090: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6091   default/librpc/gen_ndr/py_samr.c:6066: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:6067   default/librpc/gen_ndr/py_samr.c:5943: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5944   default/librpc/gen_ndr/py_samr.c:5893: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5894   default/librpc/gen_ndr/py_samr.c:5837: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5838   default/librpc/gen_ndr/py_samr.c:5813: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5814   default/librpc/gen_ndr/py_samr.c:5426: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5427   default/librpc/gen_ndr/py_samr.c:5308: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5309   default/librpc/gen_ndr/py_samr.c:5284: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5285   default/librpc/gen_ndr/py_samr.c:5260: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5261   default/librpc/gen_ndr/py_samr.c:5236: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5237   default/librpc/gen_ndr/py_samr.c:5212: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5213   default/librpc/gen_ndr/py_samr.c:5188: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5189   default/librpc/gen_ndr/py_samr.c:5070: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5071   default/librpc/gen_ndr/py_samr.c:5046: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:5047   default/librpc/gen_ndr/py_samr.c:4996: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4997   default/librpc/gen_ndr/py_samr.c:4703: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4704   default/librpc/gen_ndr/py_samr.c:4444: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4445   default/librpc/gen_ndr/py_samr.c:4420: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4421   default/librpc/gen_ndr/py_samr.c:4396: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4397   default/librpc/gen_ndr/py_samr.c:4372: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4373   default/librpc/gen_ndr/py_samr.c:4348: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4349   default/librpc/gen_ndr/py_samr.c:4230: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4231   default/librpc/gen_ndr/py_samr.c:4206: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4207   Cannot delete NDR object: struct object->reserved   default/librpc/gen_ndr/py_samr.c:3801: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3802   default/librpc/gen_ndr/py_samr.c:3777: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3778   default/librpc/gen_ndr/py_samr.c:3703: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3704   default/librpc/gen_ndr/py_samr.c:3679: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3680   default/librpc/gen_ndr/py_samr.c:3608: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3609   default/librpc/gen_ndr/py_samr.c:3584: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3585   default/librpc/gen_ndr/py_samr.c:11194: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11195  default/librpc/gen_ndr/py_samr.c:10931: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10932  default/librpc/gen_ndr/py_samr.c:10907: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10908  default/librpc/gen_ndr/py_samr.c:10550: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10551  default/librpc/gen_ndr/py_samr.c:10526: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10527  default/librpc/gen_ndr/py_samr.c:10163: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10164  default/librpc/gen_ndr/py_samr.c:10139: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10140  default/librpc/gen_ndr/py_samr.c:10115: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10116  default/librpc/gen_ndr/py_samr.c:12467: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12468  default/librpc/gen_ndr/py_samr.c:12716: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12717  Cannot delete NDR object: struct object->account    default/librpc/gen_ndr/py_samr.c:12692: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12693  default/librpc/gen_ndr/py_samr.c:12668: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12669  default/librpc/gen_ndr/py_samr.c:12644: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12645  default/librpc/gen_ndr/py_samr.c:12962: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12963  default/librpc/gen_ndr/py_samr.c:12938: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12939  default/librpc/gen_ndr/py_samr.c:12914: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12915  default/librpc/gen_ndr/py_samr.c:12890: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12891  default/librpc/gen_ndr/py_samr.c:13083: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13084  Cannot delete NDR object: struct object->filterModuleName   default/librpc/gen_ndr/py_samr.c:11673: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11674  default/librpc/gen_ndr/py_samr.c:230: Expected type '%s' for '%s' of type '%s'  default/librpc/gen_ndr/py_samr.c:231    default/librpc/gen_ndr/py_samr.c:2962: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2963   samr_CryptPassword  default/librpc/gen_ndr/py_samr.c:8634   samr_LogonHours default/librpc/gen_ndr/py_samr.c:4168   samr_Password   default/librpc/gen_ndr/py_samr.c:6630   samr_RidWithAttribute   default/librpc/gen_ndr/py_samr.c:9716   samr_RidWithAttributeArray  default/librpc/gen_ndr/py_samr.c:9936   OOO:samr_SetDsrmPassword    Cannot delete NDR object: struct r->in.name py_name default/librpc/gen_ndr/py_samr.c:19677: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19678  Cannot delete NDR object: struct r->in.unknown  Cannot delete NDR object: struct r->in.hash py_hash default/librpc/gen_ndr/py_samr.c:19729: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19730  O:samr_GetDomPwInfo Cannot delete NDR object: struct r->in.domain_name  py_domain_name  default/librpc/gen_ndr/py_samr.c:18516: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18517  s#|O:__ndr_unpack__ (is)    OO:samr_RidToSid    Cannot delete NDR object: struct r->in.domain_handle    default/librpc/gen_ndr/py_samr.c:19586  Cannot delete NDR object: struct *r->in.domain_handle   py_domain_handle    default/librpc/gen_ndr/py_samr.c:19591: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19592  Cannot delete NDR object: struct r->in.rid  OOOOOOOO:samr_ChangePasswordUser3   Cannot delete NDR object: struct r->in.server   py_server   default/librpc/gen_ndr/py_samr.c:19225: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19226  Cannot delete NDR object: struct r->in.account  default/librpc/gen_ndr/py_samr.c:19236  Cannot delete NDR object: struct *r->in.account py_account  default/librpc/gen_ndr/py_samr.c:19241: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19242  Cannot delete NDR object: struct r->in.nt_password  py_nt_password  default/librpc/gen_ndr/py_samr.c:19259: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19260  Cannot delete NDR object: struct r->in.nt_verifier  py_nt_verifier  default/librpc/gen_ndr/py_samr.c:19278: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19279  Cannot delete NDR object: struct r->in.lm_change    Cannot delete NDR object: struct r->in.lm_password  py_lm_password  default/librpc/gen_ndr/py_samr.c:19330: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19331  Cannot delete NDR object: struct r->in.lm_verifier  py_lm_verifier  default/librpc/gen_ndr/py_samr.c:19349: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19350  Cannot delete NDR object: struct r->in.password3    py_password3    default/librpc/gen_ndr/py_samr.c:19368: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:19369  O:samr_GetBootKeyInformation    default/librpc/gen_ndr/py_samr.c:18895  default/librpc/gen_ndr/py_samr.c:18900: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18901  OOOO:samr_SetBootKeyInformation Cannot delete NDR object: struct r->in.connect_handle   default/librpc/gen_ndr/py_samr.c:18754  Cannot delete NDR object: struct *r->in.connect_handle  py_connect_handle   default/librpc/gen_ndr/py_samr.c:18759: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18760  Cannot delete NDR object: struct r->in.unknown1 Cannot delete NDR object: struct r->in.unknown2 Cannot delete NDR object: struct r->in.unknown3 OOOOOOO:samr_ChangePasswordUser2    default/librpc/gen_ndr/py_samr.c:18346: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18347  default/librpc/gen_ndr/py_samr.c:18357  default/librpc/gen_ndr/py_samr.c:18362: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18363  default/librpc/gen_ndr/py_samr.c:18380: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18381  default/librpc/gen_ndr/py_samr.c:18399: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18400  default/librpc/gen_ndr/py_samr.c:18451: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18452  default/librpc/gen_ndr/py_samr.c:18470: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18471  OOOO:samr_OemChangePasswordUser2    default/librpc/gen_ndr/py_samr.c:18241: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18242  default/librpc/gen_ndr/py_samr.c:18252  default/librpc/gen_ndr/py_samr.c:18257: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18258  Cannot delete NDR object: struct r->in.password py_password default/librpc/gen_ndr/py_samr.c:18275: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18276  default/librpc/gen_ndr/py_samr.c:18294: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18295  OO:samr_RemoveMultipleMembersFromAlias  Cannot delete NDR object: struct r->in.alias_handle default/librpc/gen_ndr/py_samr.c:18173  Cannot delete NDR object: struct *r->in.alias_handle    py_alias_handle default/librpc/gen_ndr/py_samr.c:18178: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18179  Cannot delete NDR object: struct r->in.sids default/librpc/gen_ndr/py_samr.c:18188  Cannot delete NDR object: struct *r->in.sids    py_sids default/librpc/gen_ndr/py_samr.c:18193: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18194  OO:samr_AddMultipleMembersToAlias   default/librpc/gen_ndr/py_samr.c:18115  default/librpc/gen_ndr/py_samr.c:18120: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18121  default/librpc/gen_ndr/py_samr.c:18130  default/librpc/gen_ndr/py_samr.c:18135: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18136  OOOOO:samr_QueryDisplayInfo3    default/librpc/gen_ndr/py_samr.c:17929  default/librpc/gen_ndr/py_samr.c:17934: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17935  Cannot delete NDR object: struct r->in.level    Cannot delete NDR object: struct r->in.start_idx    Cannot delete NDR object: struct r->in.max_entries  Cannot delete NDR object: struct r->in.buf_size OOOO:samr_CreateUser2   default/librpc/gen_ndr/py_samr.c:17794  default/librpc/gen_ndr/py_samr.c:17799: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17800  Cannot delete NDR object: struct r->in.account_name default/librpc/gen_ndr/py_samr.c:17809  Cannot delete NDR object: struct *r->in.account_name    py_account_name default/librpc/gen_ndr/py_samr.c:17814: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17815  Cannot delete NDR object: struct r->in.acct_flags   Cannot delete NDR object: struct r->in.access_mask  OOO:samr_GetDisplayEnumerationIndex2    default/librpc/gen_ndr/py_samr.c:17700  default/librpc/gen_ndr/py_samr.c:17705: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17706  default/librpc/gen_ndr/py_samr.c:17748  Cannot delete NDR object: struct *r->in.name    default/librpc/gen_ndr/py_samr.c:17753: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17754  OOOOO:samr_QueryDisplayInfo2    default/librpc/gen_ndr/py_samr.c:17513  default/librpc/gen_ndr/py_samr.c:17518: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17519  OO:samr_QueryUserInfo2  Cannot delete NDR object: struct r->in.user_handle  default/librpc/gen_ndr/py_samr.c:17425  Cannot delete NDR object: struct *r->in.user_handle py_user_handle  default/librpc/gen_ndr/py_samr.c:17430: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17431  OO:samr_QueryDomainInfo2    default/librpc/gen_ndr/py_samr.c:17340  default/librpc/gen_ndr/py_samr.c:17345: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17346  OO:samr_RemoveMemberFromForeignDomain   default/librpc/gen_ndr/py_samr.c:17282  default/librpc/gen_ndr/py_samr.c:17287: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17288  Cannot delete NDR object: struct r->in.sid  default/librpc/gen_ndr/py_samr.c:17297  Cannot delete NDR object: struct *r->in.sid py_sid  default/librpc/gen_ndr/py_samr.c:17302: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17303  O:samr_GetUserPwInfo    default/librpc/gen_ndr/py_samr.c:17238  default/librpc/gen_ndr/py_samr.c:17243: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17244  O:samr_TestPrivateFunctionsUser default/librpc/gen_ndr/py_samr.c:17196  default/librpc/gen_ndr/py_samr.c:17201: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17202  O:samr_TestPrivateFunctionsDomain   default/librpc/gen_ndr/py_samr.c:17154  default/librpc/gen_ndr/py_samr.c:17159: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17160  OOO:samr_GetDisplayEnumerationIndex default/librpc/gen_ndr/py_samr.c:17063  default/librpc/gen_ndr/py_samr.c:17068: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17069  default/librpc/gen_ndr/py_samr.c:17111  default/librpc/gen_ndr/py_samr.c:17116: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:17117  OOOOO:samr_QueryDisplayInfo default/librpc/gen_ndr/py_samr.c:16876  default/librpc/gen_ndr/py_samr.c:16881: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16882  O:samr_GetGroupsForUser default/librpc/gen_ndr/py_samr.c:16824  default/librpc/gen_ndr/py_samr.c:16829: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16830  OOOOOOOOOOO:samr_ChangePasswordUser default/librpc/gen_ndr/py_samr.c:16536  default/librpc/gen_ndr/py_samr.c:16541: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16542  Cannot delete NDR object: struct r->in.lm_present   Cannot delete NDR object: struct r->in.old_lm_crypted   py_old_lm_crypted   default/librpc/gen_ndr/py_samr.c:16592: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16593  Cannot delete NDR object: struct r->in.new_lm_crypted   py_new_lm_crypted   default/librpc/gen_ndr/py_samr.c:16611: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16612  Cannot delete NDR object: struct r->in.nt_present   Cannot delete NDR object: struct r->in.old_nt_crypted   py_old_nt_crypted   default/librpc/gen_ndr/py_samr.c:16663: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16664  Cannot delete NDR object: struct r->in.new_nt_crypted   py_new_nt_crypted   default/librpc/gen_ndr/py_samr.c:16682: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16683  Cannot delete NDR object: struct r->in.cross1_present   Cannot delete NDR object: struct r->in.nt_cross py_nt_cross default/librpc/gen_ndr/py_samr.c:16734: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16735  Cannot delete NDR object: struct r->in.cross2_present   Cannot delete NDR object: struct r->in.lm_cross py_lm_cross default/librpc/gen_ndr/py_samr.c:16786: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16787  OO:samr_QueryUserInfo   default/librpc/gen_ndr/py_samr.c:16348  default/librpc/gen_ndr/py_samr.c:16353: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16354  O:samr_DeleteUser   default/librpc/gen_ndr/py_samr.c:16304  default/librpc/gen_ndr/py_samr.c:16309: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16310  OOO:samr_OpenUser   default/librpc/gen_ndr/py_samr.c:16195  default/librpc/gen_ndr/py_samr.c:16200: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16201  O:samr_GetMembersInAlias    default/librpc/gen_ndr/py_samr.c:16150  default/librpc/gen_ndr/py_samr.c:16155: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16156  OO:samr_DeleteAliasMember   default/librpc/gen_ndr/py_samr.c:16093  default/librpc/gen_ndr/py_samr.c:16098: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16099  default/librpc/gen_ndr/py_samr.c:16108  default/librpc/gen_ndr/py_samr.c:16113: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16114  OO:samr_AddAliasMember  default/librpc/gen_ndr/py_samr.c:16035  default/librpc/gen_ndr/py_samr.c:16040: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16041  default/librpc/gen_ndr/py_samr.c:16050  default/librpc/gen_ndr/py_samr.c:16055: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16056  O:samr_DeleteDomAlias   default/librpc/gen_ndr/py_samr.c:15991  default/librpc/gen_ndr/py_samr.c:15996: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15997  OO:samr_QueryAliasInfo  default/librpc/gen_ndr/py_samr.c:15813  default/librpc/gen_ndr/py_samr.c:15818: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15819  OOO:samr_OpenAlias  default/librpc/gen_ndr/py_samr.c:15703  default/librpc/gen_ndr/py_samr.c:15708: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15709  OOO:samr_SetMemberAttributesOfGroup Cannot delete NDR object: struct r->in.group_handle default/librpc/gen_ndr/py_samr.c:15593  Cannot delete NDR object: struct *r->in.group_handle    py_group_handle default/librpc/gen_ndr/py_samr.c:15598: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15599  O:samr_QueryGroupMember default/librpc/gen_ndr/py_samr.c:15543  default/librpc/gen_ndr/py_samr.c:15548: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15549  OO:samr_DeleteGroupMember   default/librpc/gen_ndr/py_samr.c:15468  default/librpc/gen_ndr/py_samr.c:15473: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15474  O:samr_DeleteDomainGroup    default/librpc/gen_ndr/py_samr.c:15424  default/librpc/gen_ndr/py_samr.c:15429: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15430  OOO:samr_AddGroupMember default/librpc/gen_ndr/py_samr.c:15316  default/librpc/gen_ndr/py_samr.c:15321: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15322  Cannot delete NDR object: struct r->in.flags    OO:samr_QueryGroupInfo  default/librpc/gen_ndr/py_samr.c:15136  default/librpc/gen_ndr/py_samr.c:15141: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15142  OOO:samr_OpenGroup  default/librpc/gen_ndr/py_samr.c:15026  default/librpc/gen_ndr/py_samr.c:15031: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15032  OO:samr_GetAliasMembership  default/librpc/gen_ndr/py_samr.c:14797  default/librpc/gen_ndr/py_samr.c:14802: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14803  default/librpc/gen_ndr/py_samr.c:14812  default/librpc/gen_ndr/py_samr.c:14817: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14818  OOO:samr_EnumDomainAliases  default/librpc/gen_ndr/py_samr.c:14670  default/librpc/gen_ndr/py_samr.c:14675: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14676  Cannot delete NDR object: struct r->in.resume_handle    default/librpc/gen_ndr/py_samr.c:14685  Cannot delete NDR object: struct *r->in.resume_handle   Cannot delete NDR object: struct r->in.max_size OOO:samr_CreateDomAlias default/librpc/gen_ndr/py_samr.c:14573  default/librpc/gen_ndr/py_samr.c:14578: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14579  Cannot delete NDR object: struct r->in.alias_name   default/librpc/gen_ndr/py_samr.c:14588  Cannot delete NDR object: struct *r->in.alias_name  py_alias_name   default/librpc/gen_ndr/py_samr.c:14593: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14594  OOOO:samr_EnumDomainUsers   default/librpc/gen_ndr/py_samr.c:14412  default/librpc/gen_ndr/py_samr.c:14417: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14418  default/librpc/gen_ndr/py_samr.c:14427  OOO:samr_CreateUser default/librpc/gen_ndr/py_samr.c:14314  default/librpc/gen_ndr/py_samr.c:14319: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14320  default/librpc/gen_ndr/py_samr.c:14329  default/librpc/gen_ndr/py_samr.c:14334: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14335  OOO:samr_EnumDomainGroups   default/librpc/gen_ndr/py_samr.c:14186  default/librpc/gen_ndr/py_samr.c:14191: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14192  default/librpc/gen_ndr/py_samr.c:14201  OOO:samr_CreateDomainGroup  default/librpc/gen_ndr/py_samr.c:14089  default/librpc/gen_ndr/py_samr.c:14094: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14095  default/librpc/gen_ndr/py_samr.c:14104  default/librpc/gen_ndr/py_samr.c:14109: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14110  OO:samr_QueryDomainInfo default/librpc/gen_ndr/py_samr.c:13909  default/librpc/gen_ndr/py_samr.c:13914: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13915  OOO:samr_OpenDomain default/librpc/gen_ndr/py_samr.c:13817  default/librpc/gen_ndr/py_samr.c:13822: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13823  default/librpc/gen_ndr/py_samr.c:13865  default/librpc/gen_ndr/py_samr.c:13870: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13871  OOO:samr_EnumDomains    default/librpc/gen_ndr/py_samr.c:13689  default/librpc/gen_ndr/py_samr.c:13694: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13695  default/librpc/gen_ndr/py_samr.c:13704  OO:samr_LookupDomain    default/librpc/gen_ndr/py_samr.c:13624  default/librpc/gen_ndr/py_samr.c:13629: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13630  default/librpc/gen_ndr/py_samr.c:13639  Cannot delete NDR object: struct *r->in.domain_name default/librpc/gen_ndr/py_samr.c:13644: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13645  O:samr_Shutdown default/librpc/gen_ndr/py_samr.c:13581  default/librpc/gen_ndr/py_samr.c:13586: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13587  OO:samr_QuerySecurity   Cannot delete NDR object: struct r->in.handle   default/librpc/gen_ndr/py_samr.c:13500  Cannot delete NDR object: struct *r->in.handle  py_handle   default/librpc/gen_ndr/py_samr.c:13505: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13506  Cannot delete NDR object: struct r->in.sec_info OOO:samr_SetSecurity    default/librpc/gen_ndr/py_samr.c:13409  default/librpc/gen_ndr/py_samr.c:13414: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13415  Cannot delete NDR object: struct r->in.sdbuf    default/librpc/gen_ndr/py_samr.c:13457  Cannot delete NDR object: struct *r->in.sdbuf   py_sdbuf    default/librpc/gen_ndr/py_samr.c:13462: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13463  O:samr_Close    default/librpc/gen_ndr/py_samr.c:13364  default/librpc/gen_ndr/py_samr.c:13369: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13370  OO:samr_Connect Cannot delete NDR object: struct r->in.system_name  default/librpc/gen_ndr/py_samr.c:13264  Cannot delete NDR object: struct *r->in.system_name talloc_new: default/librpc/gen_ndr/py_samr.c:8574   default/librpc/gen_ndr/py_samr.c:8581   default/librpc/gen_ndr/py_samr.c:8587   talloc_new: default/librpc/gen_ndr/py_samr.c:4108   default/librpc/gen_ndr/py_samr.c:4115   default/librpc/gen_ndr/py_samr.c:4121   talloc_new: default/librpc/gen_ndr/py_samr.c:6570   default/librpc/gen_ndr/py_samr.c:6577   default/librpc/gen_ndr/py_samr.c:6583   talloc_new: default/librpc/gen_ndr/py_samr.c:9656   default/librpc/gen_ndr/py_samr.c:9663   default/librpc/gen_ndr/py_samr.c:9669   talloc_new: default/librpc/gen_ndr/py_samr.c:9876   default/librpc/gen_ndr/py_samr.c:9883   default/librpc/gen_ndr/py_samr.c:9889   Cannot delete NDR object: struct object->bits   default/librpc/gen_ndr/py_samr.c:4035: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:4038   ARRAY: object->bits Cannot delete NDR object: struct object->bits[bits_cntr_1]  Cannot delete NDR object: struct object->buffer default/librpc/gen_ndr/py_samr.c:7623: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:7626   ARRAY: object->buffer   Cannot delete NDR object: struct object->buffer[buffer_cntr_1]  Cannot delete NDR object: struct object->entries    default/librpc/gen_ndr/py_samr.c:11322: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11325  ARRAY: object->entries  Cannot delete NDR object: struct object->entries[entries_cntr_1]    PyList_GET_ITEM(value, entries_cntr_1)  default/librpc/gen_ndr/py_samr.c:11333: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11334  default/librpc/gen_ndr/py_samr.c:11077: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11080  default/librpc/gen_ndr/py_samr.c:11088: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11089  default/librpc/gen_ndr/py_samr.c:10696: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10699  default/librpc/gen_ndr/py_samr.c:10707: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10708  default/librpc/gen_ndr/py_samr.c:10315: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10318  default/librpc/gen_ndr/py_samr.c:10326: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:10327  Cannot delete NDR object: struct object->pwd_history    default/librpc/gen_ndr/py_samr.c:12367: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12370  ARRAY: object->pwd_history  Cannot delete NDR object: struct object->pwd_history[pwd_history_cntr_1]    PyList_GET_ITEM(value, pwd_history_cntr_1)  default/librpc/gen_ndr/py_samr.c:12378: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12379  default/librpc/gen_ndr/py_samr.c:11967: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11970  ARRAY: object->data Cannot delete NDR object: struct object->data[data_cntr_1]  Cannot delete NDR object: struct object->rids   default/librpc/gen_ndr/py_samr.c:9826: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9829   ARRAY: object->rids Cannot delete NDR object: struct object->rids[rids_cntr_1]  PyList_GET_ITEM(value, rids_cntr_1) default/librpc/gen_ndr/py_samr.c:9837: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9838   default/librpc/gen_ndr/py_samr.c:3278: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3281   ARRAY: object->attributes   Cannot delete NDR object: struct object->attributes[attributes_cntr_1]  default/librpc/gen_ndr/py_samr.c:3192: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3195   Cannot delete NDR object: struct object->ids    default/librpc/gen_ndr/py_samr.c:2610: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2613   ARRAY: object->ids  Cannot delete NDR object: struct object->ids[ids_cntr_1]    OO:samr_LookupRids  default/librpc/gen_ndr/py_samr.c:14929  default/librpc/gen_ndr/py_samr.c:14934: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14935  py_rids default/librpc/gen_ndr/py_samr.c:14940: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14946: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14949  ARRAY: r->in.rids   Cannot delete NDR object: struct r->in.rids[rids_cntr_0]    OO:samr_LookupNames default/librpc/gen_ndr/py_samr.c:14856  default/librpc/gen_ndr/py_samr.c:14861: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14862  py_names    default/librpc/gen_ndr/py_samr.c:14867: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14873: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14876  ARRAY: r->in.names  Cannot delete NDR object: struct r->in.names[names_cntr_0]  PyList_GET_ITEM(py_names, names_cntr_0) default/librpc/gen_ndr/py_samr.c:14884: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14885  default/librpc/gen_ndr/py_samr.c:358: Expected type '%s' for '%s' of type '%s'  default/librpc/gen_ndr/py_samr.c:361    default/librpc/gen_ndr/py_samr.c:369: Expected type '%s' for '%s' of type '%s'  default/librpc/gen_ndr/py_samr.c:370    samba   NTSTATUSError   (i,s)   OOO:samr_Connect4   ignore  utf-8   Expected string or unicode object, got %s   Cannot delete NDR object: struct r->in.client_version   OOO:samr_Connect3   OO:samr_Connect2    Cannot delete NDR object: struct object->min_password_age   Cannot delete NDR object: struct object->max_password_age   unknown union level union samr_DomainInfo   Cannot delete NDR object: struct ret->info1 default/librpc/gen_ndr/py_samr.c:2360   default/librpc/gen_ndr/py_samr.c:2362: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2362   default/librpc/gen_ndr/py_samr.c:2363   default/librpc/gen_ndr/py_samr.c:2365   Cannot delete NDR object: struct ret->general   default/librpc/gen_ndr/py_samr.c:2373   default/librpc/gen_ndr/py_samr.c:2375: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2375   default/librpc/gen_ndr/py_samr.c:2376   default/librpc/gen_ndr/py_samr.c:2378   Cannot delete NDR object: struct ret->info3 default/librpc/gen_ndr/py_samr.c:2386   default/librpc/gen_ndr/py_samr.c:2388: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2388   default/librpc/gen_ndr/py_samr.c:2389   default/librpc/gen_ndr/py_samr.c:2391   Cannot delete NDR object: struct ret->oem   default/librpc/gen_ndr/py_samr.c:2399   default/librpc/gen_ndr/py_samr.c:2401: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2401   default/librpc/gen_ndr/py_samr.c:2402   default/librpc/gen_ndr/py_samr.c:2404   Cannot delete NDR object: struct ret->info5 default/librpc/gen_ndr/py_samr.c:2412   default/librpc/gen_ndr/py_samr.c:2414: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2414   default/librpc/gen_ndr/py_samr.c:2415   default/librpc/gen_ndr/py_samr.c:2417   Cannot delete NDR object: struct ret->info6 default/librpc/gen_ndr/py_samr.c:2425   default/librpc/gen_ndr/py_samr.c:2427: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2427   default/librpc/gen_ndr/py_samr.c:2428   default/librpc/gen_ndr/py_samr.c:2430   Cannot delete NDR object: struct ret->info7 default/librpc/gen_ndr/py_samr.c:2438   default/librpc/gen_ndr/py_samr.c:2440: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2440   default/librpc/gen_ndr/py_samr.c:2441   default/librpc/gen_ndr/py_samr.c:2443   Cannot delete NDR object: struct ret->info8 default/librpc/gen_ndr/py_samr.c:2451   default/librpc/gen_ndr/py_samr.c:2453: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2453   default/librpc/gen_ndr/py_samr.c:2454   default/librpc/gen_ndr/py_samr.c:2456   Cannot delete NDR object: struct ret->info9 default/librpc/gen_ndr/py_samr.c:2464   default/librpc/gen_ndr/py_samr.c:2466: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2466   default/librpc/gen_ndr/py_samr.c:2467   default/librpc/gen_ndr/py_samr.c:2469   Cannot delete NDR object: struct ret->general2  default/librpc/gen_ndr/py_samr.c:2477   default/librpc/gen_ndr/py_samr.c:2479: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2479   default/librpc/gen_ndr/py_samr.c:2480   default/librpc/gen_ndr/py_samr.c:2482   Cannot delete NDR object: struct ret->info12    default/librpc/gen_ndr/py_samr.c:2490   default/librpc/gen_ndr/py_samr.c:2492: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2492   default/librpc/gen_ndr/py_samr.c:2493   default/librpc/gen_ndr/py_samr.c:2495   Cannot delete NDR object: struct ret->info13    default/librpc/gen_ndr/py_samr.c:2503   default/librpc/gen_ndr/py_samr.c:2505: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:2505   default/librpc/gen_ndr/py_samr.c:2506   default/librpc/gen_ndr/py_samr.c:2508   invalid union level value   default/librpc/gen_ndr/py_samr.c:2515   OOO:samr_SetDomainInfo  default/librpc/gen_ndr/py_samr.c:13995  default/librpc/gen_ndr/py_samr.c:14000: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:14001  Cannot delete NDR object: struct r->in.info default/librpc/gen_ndr/py_samr.c:14043  Cannot delete NDR object: struct *r->in.info    union samr_GroupInfo    Cannot delete NDR object: struct ret->all   default/librpc/gen_ndr/py_samr.c:3033   default/librpc/gen_ndr/py_samr.c:3035: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3035   default/librpc/gen_ndr/py_samr.c:3036   default/librpc/gen_ndr/py_samr.c:3038   Cannot delete NDR object: struct ret->name  default/librpc/gen_ndr/py_samr.c:3046   default/librpc/gen_ndr/py_samr.c:3048: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3048   default/librpc/gen_ndr/py_samr.c:3049   default/librpc/gen_ndr/py_samr.c:3051   Cannot delete NDR object: struct ret->attributes    default/librpc/gen_ndr/py_samr.c:3059   default/librpc/gen_ndr/py_samr.c:3061: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3061   default/librpc/gen_ndr/py_samr.c:3062   default/librpc/gen_ndr/py_samr.c:3064   Cannot delete NDR object: struct ret->description   default/librpc/gen_ndr/py_samr.c:3072   default/librpc/gen_ndr/py_samr.c:3074: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3074   default/librpc/gen_ndr/py_samr.c:3075   default/librpc/gen_ndr/py_samr.c:3077   Cannot delete NDR object: struct ret->all2  default/librpc/gen_ndr/py_samr.c:3085   default/librpc/gen_ndr/py_samr.c:3087: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3087   default/librpc/gen_ndr/py_samr.c:3088   default/librpc/gen_ndr/py_samr.c:3090   default/librpc/gen_ndr/py_samr.c:3097   OOO:samr_SetGroupInfo   default/librpc/gen_ndr/py_samr.c:15222  default/librpc/gen_ndr/py_samr.c:15227: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15228  default/librpc/gen_ndr/py_samr.c:15270  union samr_AliasInfo    default/librpc/gen_ndr/py_samr.c:3523   default/librpc/gen_ndr/py_samr.c:3525: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3525   default/librpc/gen_ndr/py_samr.c:3526   default/librpc/gen_ndr/py_samr.c:3528   default/librpc/gen_ndr/py_samr.c:3536   default/librpc/gen_ndr/py_samr.c:3538: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3538   default/librpc/gen_ndr/py_samr.c:3539   default/librpc/gen_ndr/py_samr.c:3541   default/librpc/gen_ndr/py_samr.c:3549   default/librpc/gen_ndr/py_samr.c:3551: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:3551   default/librpc/gen_ndr/py_samr.c:3552   default/librpc/gen_ndr/py_samr.c:3554   default/librpc/gen_ndr/py_samr.c:3561   OOO:samr_SetAliasInfo   default/librpc/gen_ndr/py_samr.c:15899  default/librpc/gen_ndr/py_samr.c:15904: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:15905  default/librpc/gen_ndr/py_samr.c:15947  union samr_UserInfo default/librpc/gen_ndr/py_samr.c:9229   default/librpc/gen_ndr/py_samr.c:9231: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9231   default/librpc/gen_ndr/py_samr.c:9232   default/librpc/gen_ndr/py_samr.c:9234   Cannot delete NDR object: struct ret->info2 default/librpc/gen_ndr/py_samr.c:9242   default/librpc/gen_ndr/py_samr.c:9244: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9244   default/librpc/gen_ndr/py_samr.c:9245   default/librpc/gen_ndr/py_samr.c:9247   default/librpc/gen_ndr/py_samr.c:9255   default/librpc/gen_ndr/py_samr.c:9257: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9257   default/librpc/gen_ndr/py_samr.c:9258   default/librpc/gen_ndr/py_samr.c:9260   Cannot delete NDR object: struct ret->info4 default/librpc/gen_ndr/py_samr.c:9268   default/librpc/gen_ndr/py_samr.c:9270: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9270   default/librpc/gen_ndr/py_samr.c:9271   default/librpc/gen_ndr/py_samr.c:9273   default/librpc/gen_ndr/py_samr.c:9281   default/librpc/gen_ndr/py_samr.c:9283: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9283   default/librpc/gen_ndr/py_samr.c:9284   default/librpc/gen_ndr/py_samr.c:9286   default/librpc/gen_ndr/py_samr.c:9294   default/librpc/gen_ndr/py_samr.c:9296: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9296   default/librpc/gen_ndr/py_samr.c:9297   default/librpc/gen_ndr/py_samr.c:9299   default/librpc/gen_ndr/py_samr.c:9307   default/librpc/gen_ndr/py_samr.c:9309: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9309   default/librpc/gen_ndr/py_samr.c:9310   default/librpc/gen_ndr/py_samr.c:9312   default/librpc/gen_ndr/py_samr.c:9320   default/librpc/gen_ndr/py_samr.c:9322: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9322   default/librpc/gen_ndr/py_samr.c:9323   default/librpc/gen_ndr/py_samr.c:9325   default/librpc/gen_ndr/py_samr.c:9333   default/librpc/gen_ndr/py_samr.c:9335: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9335   default/librpc/gen_ndr/py_samr.c:9336   default/librpc/gen_ndr/py_samr.c:9338   Cannot delete NDR object: struct ret->info10    default/librpc/gen_ndr/py_samr.c:9346   default/librpc/gen_ndr/py_samr.c:9348: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9348   default/librpc/gen_ndr/py_samr.c:9349   default/librpc/gen_ndr/py_samr.c:9351   Cannot delete NDR object: struct ret->info11    default/librpc/gen_ndr/py_samr.c:9359   default/librpc/gen_ndr/py_samr.c:9361: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9361   default/librpc/gen_ndr/py_samr.c:9362   default/librpc/gen_ndr/py_samr.c:9364   default/librpc/gen_ndr/py_samr.c:9372   default/librpc/gen_ndr/py_samr.c:9374: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9374   default/librpc/gen_ndr/py_samr.c:9375   default/librpc/gen_ndr/py_samr.c:9377   default/librpc/gen_ndr/py_samr.c:9385   default/librpc/gen_ndr/py_samr.c:9387: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9387   default/librpc/gen_ndr/py_samr.c:9388   default/librpc/gen_ndr/py_samr.c:9390   Cannot delete NDR object: struct ret->info14    default/librpc/gen_ndr/py_samr.c:9398   default/librpc/gen_ndr/py_samr.c:9400: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9400   default/librpc/gen_ndr/py_samr.c:9401   default/librpc/gen_ndr/py_samr.c:9403   Cannot delete NDR object: struct ret->info16    default/librpc/gen_ndr/py_samr.c:9411   default/librpc/gen_ndr/py_samr.c:9413: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9413   default/librpc/gen_ndr/py_samr.c:9414   default/librpc/gen_ndr/py_samr.c:9416   Cannot delete NDR object: struct ret->info17    default/librpc/gen_ndr/py_samr.c:9424   default/librpc/gen_ndr/py_samr.c:9426: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9426   default/librpc/gen_ndr/py_samr.c:9427   default/librpc/gen_ndr/py_samr.c:9429   Cannot delete NDR object: struct ret->info18    default/librpc/gen_ndr/py_samr.c:9437   default/librpc/gen_ndr/py_samr.c:9439: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9439   default/librpc/gen_ndr/py_samr.c:9440   default/librpc/gen_ndr/py_samr.c:9442   Cannot delete NDR object: struct ret->info20    default/librpc/gen_ndr/py_samr.c:9450   default/librpc/gen_ndr/py_samr.c:9452: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9452   default/librpc/gen_ndr/py_samr.c:9453   default/librpc/gen_ndr/py_samr.c:9455   Cannot delete NDR object: struct ret->info21    default/librpc/gen_ndr/py_samr.c:9463   default/librpc/gen_ndr/py_samr.c:9465: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9465   default/librpc/gen_ndr/py_samr.c:9466   default/librpc/gen_ndr/py_samr.c:9468   Cannot delete NDR object: struct ret->info23    default/librpc/gen_ndr/py_samr.c:9476   default/librpc/gen_ndr/py_samr.c:9478: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9478   default/librpc/gen_ndr/py_samr.c:9479   default/librpc/gen_ndr/py_samr.c:9481   Cannot delete NDR object: struct ret->info24    default/librpc/gen_ndr/py_samr.c:9489   default/librpc/gen_ndr/py_samr.c:9491: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9491   default/librpc/gen_ndr/py_samr.c:9492   default/librpc/gen_ndr/py_samr.c:9494   Cannot delete NDR object: struct ret->info25    default/librpc/gen_ndr/py_samr.c:9502   default/librpc/gen_ndr/py_samr.c:9504: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9504   default/librpc/gen_ndr/py_samr.c:9505   default/librpc/gen_ndr/py_samr.c:9507   Cannot delete NDR object: struct ret->info26    default/librpc/gen_ndr/py_samr.c:9515   default/librpc/gen_ndr/py_samr.c:9517: Expected type '%s' for '%s' of type '%s' default/librpc/gen_ndr/py_samr.c:9517   default/librpc/gen_ndr/py_samr.c:9518   default/librpc/gen_ndr/py_samr.c:9520   default/librpc/gen_ndr/py_samr.c:9527   OOO:samr_SetUserInfo2   default/librpc/gen_ndr/py_samr.c:18659  default/librpc/gen_ndr/py_samr.c:18664: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:18665  default/librpc/gen_ndr/py_samr.c:18707  OOO:samr_SetUserInfo    default/librpc/gen_ndr/py_samr.c:16434  default/librpc/gen_ndr/py_samr.c:16439: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:16440  default/librpc/gen_ndr/py_samr.c:16482  union samr_DispInfo default/librpc/gen_ndr/py_samr.c:11413  default/librpc/gen_ndr/py_samr.c:11415: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11415  default/librpc/gen_ndr/py_samr.c:11416  default/librpc/gen_ndr/py_samr.c:11418  default/librpc/gen_ndr/py_samr.c:11426  default/librpc/gen_ndr/py_samr.c:11428: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11428  default/librpc/gen_ndr/py_samr.c:11429  default/librpc/gen_ndr/py_samr.c:11431  default/librpc/gen_ndr/py_samr.c:11439  default/librpc/gen_ndr/py_samr.c:11441: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11441  default/librpc/gen_ndr/py_samr.c:11442  default/librpc/gen_ndr/py_samr.c:11444  default/librpc/gen_ndr/py_samr.c:11452  default/librpc/gen_ndr/py_samr.c:11454: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11454  default/librpc/gen_ndr/py_samr.c:11455  default/librpc/gen_ndr/py_samr.c:11457  default/librpc/gen_ndr/py_samr.c:11465  default/librpc/gen_ndr/py_samr.c:11467: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11467  default/librpc/gen_ndr/py_samr.c:11468  default/librpc/gen_ndr/py_samr.c:11470  default/librpc/gen_ndr/py_samr.c:11477  union samr_ConnectInfo  default/librpc/gen_ndr/py_samr.c:11860  default/librpc/gen_ndr/py_samr.c:11862: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:11862  default/librpc/gen_ndr/py_samr.c:11863  default/librpc/gen_ndr/py_samr.c:11865  default/librpc/gen_ndr/py_samr.c:11872  OOOO:samr_Connect5  Cannot delete NDR object: struct r->in.level_in Cannot delete NDR object: struct r->in.info_in  default/librpc/gen_ndr/py_samr.c:19530  Cannot delete NDR object: struct *r->in.info_in union samr_ValidatePasswordRep  Cannot delete NDR object: struct ret->ctr1  default/librpc/gen_ndr/py_samr.c:12583  default/librpc/gen_ndr/py_samr.c:12585: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12585  default/librpc/gen_ndr/py_samr.c:12586  default/librpc/gen_ndr/py_samr.c:12588  Cannot delete NDR object: struct ret->ctr2  default/librpc/gen_ndr/py_samr.c:12596  default/librpc/gen_ndr/py_samr.c:12598: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12598  default/librpc/gen_ndr/py_samr.c:12599  default/librpc/gen_ndr/py_samr.c:12601  Cannot delete NDR object: struct ret->ctr3  default/librpc/gen_ndr/py_samr.c:12609  default/librpc/gen_ndr/py_samr.c:12611: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:12611  default/librpc/gen_ndr/py_samr.c:12612  default/librpc/gen_ndr/py_samr.c:12614  default/librpc/gen_ndr/py_samr.c:12621  union samr_ValidatePasswordReq  Cannot delete NDR object: struct ret->req1  default/librpc/gen_ndr/py_samr.c:13199  default/librpc/gen_ndr/py_samr.c:13201: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13201  default/librpc/gen_ndr/py_samr.c:13202  default/librpc/gen_ndr/py_samr.c:13204  Cannot delete NDR object: struct ret->req2  default/librpc/gen_ndr/py_samr.c:13212  default/librpc/gen_ndr/py_samr.c:13214: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13214  default/librpc/gen_ndr/py_samr.c:13215  default/librpc/gen_ndr/py_samr.c:13217  Cannot delete NDR object: struct ret->req3  default/librpc/gen_ndr/py_samr.c:13225  default/librpc/gen_ndr/py_samr.c:13227: Expected type '%s' for '%s' of type '%s'    default/librpc/gen_ndr/py_samr.c:13227  default/librpc/gen_ndr/py_samr.c:13228  default/librpc/gen_ndr/py_samr.c:13230  default/librpc/gen_ndr/py_samr.c:13237  OO:samr_ValidatePassword    Cannot delete NDR object: struct r->in.req  default/librpc/gen_ndr/py_samr.c:19801  Cannot delete NDR object: struct *r->in.req samba.dcerpc.misc   samba.dcerpc.lsa    samba.dcerpc.security   talloc  samba.dcerpc.base   String  BaseObject  BinaryString    AsciiStringLarge    StringLarge policy_handle   sec_desc_buf    dom_sid SidArray    Strings AsciiString ClientConnection    ndr_syntax_id   samr DCE/RPC    samr    SAMR_ACCESS_ALL_ACCESS  GENERIC_RIGHTS_SAM_ALL_ACCESS   GENERIC_RIGHTS_SAM_READ GENERIC_RIGHTS_SAM_WRITE    GENERIC_RIGHTS_SAM_EXECUTE  SAMR_USER_ACCESS_ALL_ACCESS GENERIC_RIGHTS_USER_ALL_ACCESS  GENERIC_RIGHTS_USER_READ    GENERIC_RIGHTS_USER_WRITE   GENERIC_RIGHTS_USER_EXECUTE SAMR_DOMAIN_ACCESS_ALL_ACCESS   GENERIC_RIGHTS_DOMAIN_ALL_ACCESS    GENERIC_RIGHTS_DOMAIN_READ  GENERIC_RIGHTS_DOMAIN_WRITE GENERIC_RIGHTS_DOMAIN_EXECUTE   SAMR_GROUP_ACCESS_ALL_ACCESS    GENERIC_RIGHTS_GROUP_ALL_ACCESS GENERIC_RIGHTS_GROUP_READ   GENERIC_RIGHTS_GROUP_WRITE  GENERIC_RIGHTS_GROUP_EXECUTE    SAMR_ALIAS_ACCESS_ALL_ACCESS    GENERIC_RIGHTS_ALIAS_ALL_ACCESS GENERIC_RIGHTS_ALIAS_READ   GENERIC_RIGHTS_ALIAS_WRITE  GENERIC_RIGHTS_ALIAS_EXECUTE    SAMR_ENUM_USERS_MULTIPLIER  PASS_MUST_CHANGE_AT_NEXT_LOGON  PASS_DONT_CHANGE_AT_NEXT_LOGON  ACB_DISABLED    ACB_HOMDIRREQ   ACB_PWNOTREQ    ACB_TEMPDUP ACB_NORMAL  ACB_MNS ACB_DOMTRUST    ACB_WSTRUST ACB_SVRTRUST    ACB_PWNOEXP ACB_AUTOLOCK    ACB_ENC_TXT_PWD_ALLOWED ACB_SMARTCARD_REQUIRED  ACB_TRUSTED_FOR_DELEGATION  ACB_NOT_DELEGATED   ACB_USE_DES_KEY_ONLY    ACB_DONT_REQUIRE_PREAUTH    ACB_PW_EXPIRED  ACB_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION  ACB_NO_AUTH_DATA_REQD   ACB_PARTIAL_SECRETS_ACCOUNT ACB_USE_AES_KEYS    SAMR_ACCESS_CONNECT_TO_SERVER   SAMR_ACCESS_SHUTDOWN_SERVER SAMR_ACCESS_INITIALIZE_SERVER   SAMR_ACCESS_CREATE_DOMAIN   SAMR_ACCESS_ENUM_DOMAINS    SAMR_ACCESS_LOOKUP_DOMAIN   SAMR_USER_ACCESS_GET_NAME_ETC   SAMR_USER_ACCESS_GET_LOCALE SAMR_USER_ACCESS_SET_LOC_COM    SAMR_USER_ACCESS_GET_LOGONINFO  SAMR_USER_ACCESS_GET_ATTRIBUTES SAMR_USER_ACCESS_SET_ATTRIBUTES SAMR_USER_ACCESS_CHANGE_PASSWORD    SAMR_USER_ACCESS_SET_PASSWORD   SAMR_USER_ACCESS_GET_GROUPS SAMR_USER_ACCESS_GET_GROUP_MEMBERSHIP   SAMR_USER_ACCESS_CHANGE_GROUP_MEMBERSHIP    SAMR_DOMAIN_ACCESS_LOOKUP_INFO_1    SAMR_DOMAIN_ACCESS_SET_INFO_1   SAMR_DOMAIN_ACCESS_LOOKUP_INFO_2    SAMR_DOMAIN_ACCESS_SET_INFO_2   SAMR_DOMAIN_ACCESS_CREATE_USER  SAMR_DOMAIN_ACCESS_CREATE_GROUP SAMR_DOMAIN_ACCESS_CREATE_ALIAS SAMR_DOMAIN_ACCESS_LOOKUP_ALIAS SAMR_DOMAIN_ACCESS_ENUM_ACCOUNTS    SAMR_DOMAIN_ACCESS_OPEN_ACCOUNT SAMR_DOMAIN_ACCESS_SET_INFO_3   SAMR_GROUP_ACCESS_LOOKUP_INFO   SAMR_GROUP_ACCESS_SET_INFO  SAMR_GROUP_ACCESS_ADD_MEMBER    SAMR_GROUP_ACCESS_REMOVE_MEMBER SAMR_GROUP_ACCESS_GET_MEMBERS   SAMR_ALIAS_ACCESS_ADD_MEMBER    SAMR_ALIAS_ACCESS_REMOVE_MEMBER SAMR_ALIAS_ACCESS_GET_MEMBERS   SAMR_ALIAS_ACCESS_LOOKUP_INFO   SAMR_ALIAS_ACCESS_SET_INFO  DomainPasswordInformation   DomainGeneralInformation    DomainLogoffInformation DomainOemInformation    DomainNameInformation   DomainReplicationInformation    DomainServerRoleInformation DomainModifiedInformation   DomainStateInformation  DomainUasInformation    DomainGeneralInformation2   DomainLockoutInformation    DomainModifiedInformation2  SAMR_ROLE_STANDALONE    SAMR_ROLE_DOMAIN_MEMBER SAMR_ROLE_DOMAIN_BDC    SAMR_ROLE_DOMAIN_PDC    DOMAIN_PASSWORD_COMPLEX DOMAIN_PASSWORD_NO_ANON_CHANGE  DOMAIN_PASSWORD_NO_CLEAR_CHANGE DOMAIN_PASSWORD_LOCKOUT_ADMINS  DOMAIN_PASSWORD_STORE_CLEARTEXT DOMAIN_REFUSE_PASSWORD_CHANGE   DOMAIN_SERVER_ENABLED   DOMAIN_SERVER_DISABLED  SE_GROUP_MANDATORY  SE_GROUP_ENABLED_BY_DEFAULT SE_GROUP_ENABLED    SE_GROUP_OWNER  SE_GROUP_USE_FOR_DENY_ONLY  SE_GROUP_RESOURCE   SE_GROUP_LOGON_ID   GROUPINFOALL    GROUPINFONAME   GROUPINFOATTRIBUTES GROUPINFODESCRIPTION    GROUPINFOALL2   ALIASINFOALL    ALIASINFONAME   ALIASINFODESCRIPTION    UserGeneralInformation  UserPreferencesInformation  UserLogonInformation    UserLogonHoursInformation   UserAccountInformation  UserNameInformation UserAccountNameInformation  UserFullNameInformation UserPrimaryGroupInformation UserHomeInformation UserScriptInformation   UserProfileInformation  UserAdminCommentInformation UserWorkStationsInformation UserControlInformation  UserExpiresInformation  UserInternal1Information    UserParametersInformation   UserAllInformation  UserInternal4Information    UserInternal5Information    UserInternal4InformationNew UserInternal5InformationNew SAMR_FIELD_ACCOUNT_NAME SAMR_FIELD_FULL_NAME    SAMR_FIELD_RID  SAMR_FIELD_PRIMARY_GID  SAMR_FIELD_DESCRIPTION  SAMR_FIELD_COMMENT  SAMR_FIELD_HOME_DIRECTORY   SAMR_FIELD_HOME_DRIVE   SAMR_FIELD_LOGON_SCRIPT SAMR_FIELD_PROFILE_PATH SAMR_FIELD_WORKSTATIONS SAMR_FIELD_LAST_LOGON   SAMR_FIELD_LAST_LOGOFF  SAMR_FIELD_LOGON_HOURS  SAMR_FIELD_BAD_PWD_COUNT    SAMR_FIELD_NUM_LOGONS   SAMR_FIELD_ALLOW_PWD_CHANGE SAMR_FIELD_FORCE_PWD_CHANGE SAMR_FIELD_LAST_PWD_CHANGE  SAMR_FIELD_ACCT_EXPIRY  SAMR_FIELD_ACCT_FLAGS   SAMR_FIELD_PARAMETERS   SAMR_FIELD_COUNTRY_CODE SAMR_FIELD_CODE_PAGE    SAMR_FIELD_NT_PASSWORD_PRESENT  SAMR_FIELD_LM_PASSWORD_PRESENT  SAMR_FIELD_PRIVATE_DATA SAMR_FIELD_EXPIRED_FLAG SAMR_FIELD_SEC_DESC SAMR_FIELD_OWF_PWD  SAMR_CONNECT_PRE_W2K    SAMR_CONNECT_W2K    SAMR_CONNECT_AFTER_W2K  SAM_PWD_CHANGE_NO_ERROR SAM_PWD_CHANGE_PASSWORD_TOO_SHORT   SAM_PWD_CHANGE_PWD_IN_HISTORY   SAM_PWD_CHANGE_USERNAME_IN_PASSWORD SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD SAM_PWD_CHANGE_NOT_COMPLEX  SAM_PWD_CHANGE_MACHINE_NOT_DEFAULT  SAM_PWD_CHANGE_FAILED_BY_FILTER SAM_PWD_CHANGE_PASSWORD_TOO_LONG    SAMR_VALIDATE_FIELD_PASSWORD_LAST_SET   SAMR_VALIDATE_FIELD_BAD_PASSWORD_TIME   SAMR_VALIDATE_FIELD_LOCKOUT_TIME    SAMR_VALIDATE_FIELD_BAD_PASSWORD_COUNT  SAMR_VALIDATE_FIELD_PASSWORD_HISTORY_LENGTH SAMR_VALIDATE_FIELD_PASSWORD_HISTORY    NetValidateAuthentication   NetValidatePasswordChange   NetValidatePasswordReset    SAMR_VALIDATION_STATUS_SUCCESS  SAMR_VALIDATION_STATUS_PASSWORD_MUST_CHANGE SAMR_VALIDATION_STATUS_ACCOUNT_LOCKED_OUT   SAMR_VALIDATION_STATUS_PASSWORD_EXPIRED SAMR_VALIDATION_STATUS_BAD_PASSWORD SAMR_VALIDATION_STATUS_PWD_HISTORY_CONFLICT SAMR_VALIDATION_STATUS_PWD_TOO_SHORT    SAMR_VALIDATION_STATUS_PWD_TOO_LONG SAMR_VALIDATION_STATUS_NOT_COMPLEX_ENOUGH   SAMR_VALIDATION_STATUS_PASSWORD_TOO_RECENT  SAMR_VALIDATION_STATUS_PASSWORD_FILTER_ERROR    userPwdChangeFailureInformation abstract_syntax access_mask sec_info    buf_size    level   max_size    acct_flags  names   rid unknown1    unknown2    lm_present  old_lm_crypted  new_lm_crypted  nt_present  old_nt_crypted  new_nt_crypted  cross1_present  nt_cross    cross2_present  lm_cross    data_blob   allow_remaining start_idx   max_entries server  hash    nt_password nt_verifier lm_change   lm_password lm_verifier unknown3    unknown client_version  password3   level_in    samr.samr   abstract_syntax()
  S.Connect(system_name, access_mask) -> connect_handle   Close   S.Close(handle) -> handle   SetSecurity S.SetSecurity(handle, sec_info, sdbuf) -> None  S.QuerySecurity(handle, sec_info) -> sdbuf  Shutdown    S.Shutdown(connect_handle) -> None  S.LookupDomain(connect_handle, domain_name) -> sid  EnumDomains S.EnumDomains(connect_handle, resume_handle, buf_size) -> (resume_handle, sam, num_entries) OpenDomain  S.OpenDomain(connect_handle, access_mask, sid) -> domain_handle S.QueryDomainInfo(domain_handle, level) -> info SetDomainInfo   S.SetDomainInfo(domain_handle, level, info) -> None CreateDomainGroup   S.CreateDomainGroup(domain_handle, name, access_mask) -> (group_handle, rid)    EnumDomainGroups    S.EnumDomainGroups(domain_handle, resume_handle, max_size) -> (resume_handle, sam, num_entries) CreateUser  S.CreateUser(domain_handle, account_name, access_mask) -> (user_handle, rid)    EnumDomainUsers S.EnumDomainUsers(domain_handle, resume_handle, acct_flags, max_size) -> (resume_handle, sam, num_entries)  CreateDomAlias  S.CreateDomAlias(domain_handle, alias_name, access_mask) -> (alias_handle, rid) EnumDomainAliases   S.EnumDomainAliases(domain_handle, resume_handle, max_size) -> (resume_handle, sam, num_entries)    S.GetAliasMembership(domain_handle, sids) -> rids   S.LookupNames(domain_handle, names) -> (rids, types)    S.LookupRids(domain_handle, rids) -> (names, types) OpenGroup   S.OpenGroup(domain_handle, access_mask, rid) -> group_handle    S.QueryGroupInfo(group_handle, level) -> info   SetGroupInfo    S.SetGroupInfo(group_handle, level, info) -> None   AddGroupMember  S.AddGroupMember(group_handle, rid, flags) -> None  DeleteDomainGroup   S.DeleteDomainGroup(group_handle) -> group_handle   S.DeleteGroupMember(group_handle, rid) -> None  QueryGroupMember    S.QueryGroupMember(group_handle) -> rids    SetMemberAttributesOfGroup  S.SetMemberAttributesOfGroup(group_handle, unknown1, unknown2) -> None  OpenAlias   S.OpenAlias(domain_handle, access_mask, rid) -> alias_handle    S.QueryAliasInfo(alias_handle, level) -> info   SetAliasInfo    S.SetAliasInfo(alias_handle, level, info) -> None   DeleteDomAlias  S.DeleteDomAlias(alias_handle) -> alias_handle  S.AddAliasMember(alias_handle, sid) -> None S.DeleteAliasMember(alias_handle, sid) -> None  GetMembersInAlias   S.GetMembersInAlias(alias_handle) -> sids   OpenUser    S.OpenUser(domain_handle, access_mask, rid) -> user_handle  DeleteUser  S.DeleteUser(user_handle) -> user_handle    S.QueryUserInfo(user_handle, level) -> info SetUserInfo S.SetUserInfo(user_handle, level, info) -> None ChangePasswordUser  S.ChangePasswordUser(user_handle, lm_present, old_lm_crypted, new_lm_crypted, nt_present, old_nt_crypted, new_nt_crypted, cross1_present, nt_cross, cross2_present, lm_cross) -> None   GetGroupsForUser    S.GetGroupsForUser(user_handle) -> rids QueryDisplayInfo    S.QueryDisplayInfo(domain_handle, level, start_idx, max_entries, buf_size) -> (total_size, returned_size, info) GetDisplayEnumerationIndex  S.GetDisplayEnumerationIndex(domain_handle, level, name) -> idx TestPrivateFunctionsDomain  S.TestPrivateFunctionsDomain(domain_handle) -> None TestPrivateFunctionsUser    S.TestPrivateFunctionsUser(user_handle) -> None GetUserPwInfo   S.GetUserPwInfo(user_handle) -> info    S.RemoveMemberFromForeignDomain(domain_handle, sid) -> None S.QueryDomainInfo2(domain_handle, level) -> info    S.QueryUserInfo2(user_handle, level) -> info    QueryDisplayInfo2   S.QueryDisplayInfo2(domain_handle, level, start_idx, max_entries, buf_size) -> (total_size, returned_size, info)    GetDisplayEnumerationIndex2 S.GetDisplayEnumerationIndex2(domain_handle, level, name) -> idx    CreateUser2 S.CreateUser2(domain_handle, account_name, acct_flags, access_mask) -> (user_handle, access_granted, rid)   QueryDisplayInfo3   S.QueryDisplayInfo3(domain_handle, level, start_idx, max_entries, buf_size) -> (total_size, returned_size, info)    S.AddMultipleMembersToAlias(alias_handle, sids) -> None S.RemoveMultipleMembersFromAlias(alias_handle, sids) -> None    OemChangePasswordUser2  S.OemChangePasswordUser2(server, account, password, hash) -> None   ChangePasswordUser2 S.ChangePasswordUser2(server, account, nt_password, nt_verifier, lm_change, lm_password, lm_verifier) -> None   GetDomPwInfo    S.GetDomPwInfo(domain_name) -> info S.Connect2(system_name, access_mask) -> connect_handle  SetUserInfo2    S.SetUserInfo2(user_handle, level, info) -> None    SetBootKeyInformation   S.SetBootKeyInformation(connect_handle, unknown1, unknown2, unknown3) -> None   GetBootKeyInformation   S.GetBootKeyInformation(domain_handle) -> unknown   Connect3    S.Connect3(system_name, unknown, access_mask) -> connect_handle Connect4    S.Connect4(system_name, client_version, access_mask) -> connect_handle  ChangePasswordUser3 S.ChangePasswordUser3(server, account, nt_password, nt_verifier, lm_change, lm_password, lm_verifier, password3) -> (dominfo, reject)   Connect5    S.Connect5(system_name, access_mask, level_in, info_in) -> (level_out, info_out, connect_handle)    S.RidToSid(domain_handle, rid) -> sid   SetDsrmPassword S.SetDsrmPassword(name, unknown, hash) -> None  S.ValidatePassword(level, req) -> rep   PIDL-generated element info password_matched    PIDL-generated element password_matched PIDL-generated element password PIDL-generated element account  PIDL-generated element hash pwd_must_change_at_next_logon   PIDL-generated element pwd_must_change_at_next_logon    clear_lockout   PIDL-generated element clear_lockout    status  PIDL-generated element status   fields_present  PIDL-generated element fields_present   last_password_change    PIDL-generated element last_password_change bad_password_time   PIDL-generated element bad_password_time    lockout_time    PIDL-generated element lockout_time bad_pwd_count   PIDL-generated element bad_pwd_count    pwd_history_len PIDL-generated element pwd_history_len  pwd_history PIDL-generated element pwd_history  PIDL-generated element length   PIDL-generated element data PIDL-generated element client_version   PIDL-generated element unknown2 extendedFailureReason   PIDL-generated element extendedFailureReason    filterModuleName    PIDL-generated element filterModuleName min_password_length PIDL-generated element min_password_length  password_properties PIDL-generated element password_properties  PIDL-generated element count    PIDL-generated element entries  PIDL-generated element idx  PIDL-generated element account_name PIDL-generated element rid  PIDL-generated element acct_flags   description PIDL-generated element description  full_name   PIDL-generated element full_name    __ndr_pack__    S.ndr_pack(object) -> blob
NDR pack __ndr_unpack__  S.ndr_unpack(class, blob, allow_remaining=False) -> None
NDR unpack __ndr_print__   S.ndr_print(object) -> None
NDR print   PIDL-generated element rids attributes  PIDL-generated element attributes   password_expired    PIDL-generated element password_expired last_logon  PIDL-generated element last_logon   last_logoff PIDL-generated element last_logoff  acct_expiry PIDL-generated element acct_expiry  allow_password_change   PIDL-generated element allow_password_change    force_password_change   PIDL-generated element force_password_change    home_directory  PIDL-generated element home_directory   home_drive  PIDL-generated element home_drive   logon_script    PIDL-generated element logon_script profile_path    PIDL-generated element profile_path workstations    PIDL-generated element workstations comment PIDL-generated element comment  parameters  PIDL-generated element parameters   lm_owf_password PIDL-generated element lm_owf_password  nt_owf_password PIDL-generated element nt_owf_password  private_data    PIDL-generated element private_data buf_count   PIDL-generated element buf_count    buffer  PIDL-generated element buffer   primary_gid PIDL-generated element primary_gid  logon_hours PIDL-generated element logon_hours  bad_password_count  PIDL-generated element bad_password_count   logon_count PIDL-generated element logon_count  country_code    PIDL-generated element country_code code_page   PIDL-generated element code_page    lm_password_set PIDL-generated element lm_password_set  nt_password_set PIDL-generated element nt_password_set  private_data_sensitive  PIDL-generated element private_data_sensitive   nt_pwd  PIDL-generated element nt_pwd   lm_pwd  PIDL-generated element lm_pwd   nt_pwd_active   PIDL-generated element nt_pwd_active    lm_pwd_active   PIDL-generated element lm_pwd_active    units_per_week  PIDL-generated element units_per_week   bits    PIDL-generated element bits reserved    PIDL-generated element reserved PIDL-generated element name num_members PIDL-generated element num_members  PIDL-generated element ids  sequence_num    PIDL-generated element sequence_num domain_create_time  PIDL-generated element domain_create_time   modified_count_at_last_promotion    PIDL-generated element modified_count_at_last_promotion lockout_duration    PIDL-generated element lockout_duration lockout_window  PIDL-generated element lockout_window   lockout_threshold   PIDL-generated element lockout_threshold    general PIDL-generated element general  domain_server_state PIDL-generated element domain_server_state  role    PIDL-generated element role primary PIDL-generated element primary  PIDL-generated element domain_name  oem_information PIDL-generated element oem_information  force_logoff_time   PIDL-generated element force_logoff_time    PIDL-generated element unknown3 num_users   PIDL-generated element num_users    num_groups  PIDL-generated element num_groups   num_aliases PIDL-generated element num_aliases  password_history_length PIDL-generated element password_history_length  max_password_age    PIDL-generated element max_password_age min_password_age    PIDL-generated element min_password_age samr(binding, lp_ctx=None, credentials=None) -> connection

binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)
lp_ctx should be a path to a smb.conf file or a param.LoadParm object
credentials should be a credentials.Credentials object.

    samr.ValidatePasswordReq1   samr.ValidatePasswordReq2   samr.ValidatePasswordReq3   samr.ValidatePasswordRepCtr samr.ValidatePasswordInfo   samr.ValidationBlob samr.ConnectInfo1   samr.userPwdChangeFailureInformation    samr.PwInfo samr.DispInfoAscii  samr.DispEntryAscii samr.DispInfoFullGroups samr.DispEntryFullGroup samr.DispInfoFull   samr.DispEntryFull  samr.DispInfoGeneral    samr.DispEntryGeneral   samr.RidWithAttributeArray  samr.RidWithAttribute   samr.UserInfo26 samr.UserInfo25 samr.CryptPasswordEx    samr.UserInfo24 samr.UserInfo23 samr.CryptPassword  samr.UserInfo21 samr.UserInfo20 samr.UserInfo18 samr.Password   samr.UserInfo17 samr.UserInfo16 samr.UserInfo14 samr.UserInfo13 samr.UserInfo12 samr.UserInfo11 samr.UserInfo10 samr.UserInfo9  samr.UserInfo8  samr.UserInfo7  samr.UserInfo6  samr.UserInfo5  samr.UserInfo4  samr.UserInfo3  samr.LogonHours samr.UserInfo2  samr.UserInfo1  samr.AliasInfoAll   samr.RidAttrArray   samr.GroupInfoDescription   samr.GroupInfoAttributes    samr.GroupInfoAll   samr.Ids    samr.DomInfo13  samr.DomInfo12  samr.DomGeneralInformation2 samr.DomInfo9   samr.DomInfo8   samr.DomInfo7   samr.DomInfo6   samr.DomInfo5   samr.DomOEMInformation  samr.DomInfo3   samr.DomGeneralInformation  samr.DomInfo1   samr.SamArray   samr.SamEntry                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ]  d]      :                       t P              @~         6 $     {         P \     y H        x4      v               q          (     m         |1 h     j t
                P 	             8f  
       @ T     Ta               ]                V               lR                 M H        (( d     J         L      0 X        J       p              8F ,        & P     C               $               |>               < \        H$ P     9               88               3 P        $ 0     /           p     + ()              -                `*          $     '         T P     $ P               T#  !              0 "             8  #       h @      p5 $       l x     <T   %             H ` &       t        '             T $[ (       4 P         )               *               T +       , <     t  ,       8 d      $ -       x       	 .       D      \ 4 /              Z 0               1               x 2       d x      X 3               4       T $       5       d |      D 6               7       D T       8       P x       9             pP  :              D ;       \ t     T  <               =              8 $ >       H \       ?             <e b @        T      \ A       |      <  B             Ht j C                                      Q     f     {                                   .     C     xY                          o            
              x               pW     `!     6               o   oP   o   o  o                                          8         Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y                                                                                                                            	 <            X             $ T        0            $       T      `      X         X        X  	           X      X x        , < L X h x        X       ` x     `      @       @      @        @      X      X *      X L,      X *       X       X 	        x      *       |5     P7      P7  L9     $;      X      X      $; D      $; <      X  \     @  \     `  \       \     $;  ` L      <                                                                                                                          <                             _                                                 $                                                                                                          .                             a                                                 p                                                                                                          /                             b                                                 \                                                                                                  .     .                             a                                                                                                                                                   7      8                             @b                                                                                                                                                   x2     2                             b                                                                                                                                                           l(                             g                                                                                                                                                           )                             h                                                 4                                                                                                          8*                             0f                                                 `                                                                                                          *                             f                                                                                                                                                           d+                             f                                                                                                                                                           ,                             Pg                                                                                                                                                    -     `-                             `i                                                 0                                                                                                          >                              j                                                                                                                                                           =                             (`                                                                                                                                                           )                             h                                                                                                                                                           )                              i                                                                                                                                                   ,     ,                             0i                                                                                                                                                           9                             i                                                 4                                                                                                          :                             i                                                                                                                                                            `>                             i                                                                                                                                                           <                             _                                                                                                                                                           <                             _                                                                                                                                                           <                             h_                                                                                                                                                           X<                             8_                                                                                                                                                           0<                             _                                                                                                                                                           ;                             ^                                                 |                                                                                                          ;                             ^                                                 `                                                                                                          h;                             x^                                                 P                                                                                                          ;                             H^                                                 @                                                                                                          :                             ^                                                                                                                                                            (:                             `                                                                                                                                                            :                             X`                                                                                                                                                           89                             `                                                                                                                                                           8                             e                                                                                                                                                           \8                             e                                                                                                                                                           d6                             pe                                                 p                                                                                                          <6                             @e                                                 `                                                                                                          4                             e                                                 P                                                                                                          4                             d                                                 @                                                                                                          \4                             d                                                 0                                                                                                          44                             d                                                                                                                                                            4                             Pd                                                                                                                                                           3                              d                                                                                                                                                            3                             c                                                                                                                                                           3                             c                                                                                                                                                           X3                             c                                                                                                                                                           03                             `c                                                                                                                                                           3                             0c                                                                                                                                                           2                              c                                                                                                                                                            2                             b                                                                                                                                                           1                             pb                                                 L                                                                                                          x.                             a                                                 <                                                                                                          <.                             |a                                                                                                                                                           -                             La                                                                                                                                                           -                             `                                                                                                                                                           +                              g                                                 x                                                                                                          (+                             f                                                 H                                                                                                          t*                             `f                                                                                                                                                            )                              f                                                                                                                                                           H)                             g                                                                                                                                                           0(                             g                                                 8                                                                                                          &                             h                                                 T                                                                                                          ,'                             ph                                                 p                                                                                                          '                             @h                                                                                                                                                           9                             Pj                                                 l                                                                     (                                                                 8                                                l                                                                      x                                                                                                      \  = P                                    \ <       T <  <      l<  \      0<  |         h                          \ ; `      T ; 8 <      |;  \      @;  |        	         (                           \ ;       (      0                         P   `       8                      @    P     x  X         p                            `         |                            D             D                         d h  |      \=                            !       ( @ D <                             h                                   `        $9 p                            l  h       L                           P         x 4                 9       ( `9  4                          (   h                                    @                           :       ( 9  4                           L  h                                           8         ` x        :       ( : \ 4     X P: 4 d                                                               h      h  H                          T            d                               d   p                         T + J <                                  \ h, M      T 0, K <                          0  !                           T , 8N <      ,                            \ - P      T , \O <                                x                               #                            h           <                0    <     `  @  x               P0 `      X 0 _ d      / X^       ( / 0] 4     X `/ \ h      $/ Z      ( . Y 4      . X       p. hW       4. @V (     L - U \      - S       - R        P         <  (              H     T      H |       P p   `     x H- Q                          P  (     L    X     | |         h l        T         @ ,                            0 a (                         4  1 (d <     \ 0 b d        $                                               (      H                              & |                         0 8   <                                                       81 `e                          ( t1 f 4                          1 g                          X 1 h h                          d2 k       ( (2 i 4                         H    T                         X 2 <l d                          2 `m                           T3 o      X 3 n d                          l5 z      X 05 x d      H         H p   T      4 w       ( 4 v 4     X |4 lu h      @4 Dt      ( 4 s 4      3 q       h 0                 x 3 p       D  8        0           @       0 x   <       P                           x 5 0{                           7 d      X D7 < d      0        H  D  T      7        ( 6  4     X 6  h      T6 ~       6 t}       8                   ( H       ` X   x              x 5 P|       l          X  X                                                                          <       ,   4                          7       P 7  \           (     L   |  X                          8 L      X 8 $ d     H    T     ( p8  4      48                           	 + I |       P       ( + H 4                           X h      p  H     d   p                         ( =  4                         d h |  p                         	 D+ \G |     d    p              ( + 4F 4                          X  h                                   (m         k  ,     X H j  |                           tq          p        (  |n  <                         h l) > p      X u         lt        (  r  <                           w                            H z        x x  ,                           X{                            ) P?                          |5 ) t@                          @ * A P                         x ( |                           x  D       @ * E P     |5 * C       T* B                 T                0          0         X        8  H~  D                                  h  4       ( 8   <       H       8 T                             , h      ( H                                   	 =  |                         A,   aeabi "   6 	
"b4fc0572b177626c6be95b3fdbcd27c595b14e.debug    74 .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                           $                     o                       (                           0                              8   o       b               E   o   P   P                  T   	      `!  `!  6               ]   	   B   pW  pW                f         xY  xY                    a         Y  Y                   l         \  \  ,L                r                             x      2     h2                        @ @                                                                                                                                             8 8 @                        x x                              N                          > > H                       p        > -                                ? 4                                9?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _HW_IRQ_H
#define _HW_IRQ_H

#include <linux/msi.h>
#include <linux/pci.h>

void __init init_airq_interrupts(void);
void __init init_cio_interrupts(void);
void __init init_ext_interrupts(void);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 *  S390 version
 *    Copyright IBM Corp. 2002, 2006
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 */

#ifndef _ASM_THREAD_INFO_H
#define _ASM_THREAD_INFO_H

#include <linux/const.h>

/*
 * Size of kernel stack for each process
 */
#define THREAD_ORDER 2
#define ASYNC_ORDER  2

#define THREAD_SIZE (PAGE_SIZE << THREAD_ORDER)
#define ASYNC_SIZE  (PAGE_SIZE << ASYNC_ORDER)

#ifndef __ASSEMBLY__
#include <asm/lowcore.h>
#include <asm/page.h>
#include <asm/processor.h>

/*
 * low level task data that entry.S needs immediate access to
 * - this struct should fit entirely inside of one cache line
 * - this struct shares the supervisor stack pages
 * - if the contents of this structure are changed, the assembly constants must also be changed
 */
struct thread_info {
	struct task_struct	*task;		/* main task structure */
	unsigned long		flags;		/* low level flags */
	unsigned long		sys_call_table;	/* System call table address */
	unsigned int		cpu;		/* current CPU */
	int			preempt_count;	/* 0 => preemptable, <0 => BUG */
	unsigned int		system_call;
	__u64			user_timer;
	__u64			system_timer;
	unsigned long		last_break;	/* last breaking-event-address. */
};

/*
 * macros/functions for gaining access to the thread information structure
 */
#define INIT_THREAD_INFO(tsk)			\
{						\
	.task		= &tsk,			\
	.flags		= 0,			\
	.cpu		= 0,			\
	.preempt_count	= INIT_PREEMPT_COUNT,	\
}

#define init_thread_info	(init_thread_union.thread_info)
#define init_stack		(init_thread_union.stack)

/* how to get the thread information struct from C */
static inline struct thread_info *current_thread_info(void)
{
	return (struct thread_info *) S390_lowcore.thread_info;
}

void arch_release_task_struct(struct task_struct *tsk);
int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);

#define THREAD_SIZE_ORDER THREAD_ORDER

#endif

/*
 * thread information flags bit numbers
 */
#define TIF_NOTIFY_RESUME	0	/* callback before returning to user */
#define TIF_SIGPENDING		1	/* signal pending */
#define TIF_NEED_RESCHED	2	/* rescheduling necessary */
#define TIF_SYSCALL_TRACE	3	/* syscall trace active */
#define TIF_SYSCALL_AUDIT	4	/* syscall auditing active */
#define TIF_SECCOMP		5	/* secure computing */
#define TIF_SYSCALL_TRACEPOINT	6	/* syscall tracepoint instrumentation */
#define TIF_UPROBE		7	/* breakpointed or single-stepping */
#define TIF_31BIT		16	/* 32bit process */
#define TIF_MEMDIE		17	/* is terminating due to OOM killer */
#define TIF_RESTORE_SIGMASK	18	/* restore signal mask in do_signal() */
#define TIF_SINGLE_STEP		19	/* This task is single stepped */
#define TIF_BLOCK_STEP		20	/* This task is block stepped */
#define TIF_UPROBE_SINGLESTEP	21	/* This task is uprobe single stepped */

#define _TIF_NOTIFY_RESUME	_BITUL(TIF_NOTIFY_RESUME)
#define _TIF_SIGPENDING		_BITUL(TIF_SIGPENDING)
#define _TIF_NEED_RESCHED	_BITUL(TIF_NEED_RESCHED)
#define _TIF_SYSCALL_TRACE	_BITUL(TIF_SYSCALL_TRACE)
#define _TIF_SYSCALL_AUDIT	_BITUL(TIF_SYSCALL_AUDIT)
#define _TIF_SECCOMP		_BITUL(TIF_SECCOMP)
#define _TIF_SYSCALL_TRACEPOINT	_BITUL(TIF_SYSCALL_TRACEPOINT)
#define _TIF_UPROBE		_BITUL(TIF_UPROBE)
#define _TIF_31BIT		_BITUL(TIF_31BIT)
#define _TIF_SINGLE_STEP	_BITUL(TIF_SINGLE_STEP)

#endif /* _ASM_THREAD_INFO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * FPU state and register content conversion primitives
 *
 * Copyright IBM Corp. 2015
 * Author(s): Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
 */

#ifndef _ASM_S390_FPU_INTERNAL_H
#define _ASM_S390_FPU_INTERNAL_H

#include <linux/string.h>
#include <asm/ctl_reg.h>
#include <asm/fpu/types.h>

static inline void save_vx_regs(__vector128 *vxrs)
{
	asm volatile(
		"	la	1,%0\n"
		"	.word	0xe70f,0x1000,0x003e\n"	/* vstm 0,15,0(1) */
		"	.word	0xe70f,0x1100,0x0c3e\n"	/* vstm 16,31,256(1) */
		: "=Q" (*(struct vx_array *) vxrs) : : "1");
}

static inline void convert_vx_to_fp(freg_t *fprs, __vector128 *vxrs)
{
	int i;

	for (i = 0; i < __NUM_FPRS; i++)
		fprs[i] = *(freg_t *)(vxrs + i);
}

static inline void convert_fp_to_vx(__vector128 *vxrs, freg_t *fprs)
{
	int i;

	for (i = 0; i < __NUM_FPRS; i++)
		*(freg_t *)(vxrs + i) = fprs[i];
}

static inline void fpregs_store(_s390_fp_regs *fpregs, struct fpu *fpu)
{
	fpregs->pad = 0;
	fpregs->fpc = fpu->fpc;
	if (MACHINE_HAS_VX)
		convert_vx_to_fp((freg_t *)&fpregs->fprs, fpu->vxrs);
	else
		memcpy((freg_t *)&fpregs->fprs, fpu->fprs,
		       sizeof(fpregs->fprs));
}

static inline void fpregs_load(_s390_fp_regs *fpregs, struct fpu *fpu)
{
	fpu->fpc = fpregs->fpc;
	if (MACHINE_HAS_VX)
		convert_fp_to_vx(fpu->vxrs, (freg_t *)&fpregs->fprs);
	else
		memcpy(fpu->fprs, (freg_t *)&fpregs->fprs,
		       sizeof(fpregs->fprs));
}

#endif /* _ASM_S390_FPU_INTERNAL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * FPU data structures
 *
 * Copyright IBM Corp. 2015
 * Author(s): Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
 */

#ifndef _ASM_S390_FPU_TYPES_H
#define _ASM_S390_FPU_TYPES_H

#include <asm/sigcontext.h>

struct fpu {
	__u32 fpc;		/* Floating-point control */
	void *regs;		/* Pointer to the current save area */
	union {
		/* Floating-point register save area */
		freg_t fprs[__NUM_FPRS];
		/* Vector register save area */
		__vector128 vxrs[__NUM_VXRS];
	};
};

/* VX array structure for address operand constraints in inline assemblies */
struct vx_array { __vector128 _[__NUM_VXRS]; };

/* In-kernel FPU state structure */
struct kernel_fpu {
	u32	    mask;
	u32	    fpc;
	union {
		freg_t fprs[__NUM_FPRS];
		__vector128 vxrs[__NUM_VXRS];
	};
};

#endif /* _ASM_S390_FPU_TYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * In-kernel FPU support functions
 *
 *
 * Consider these guidelines before using in-kernel FPU functions:
 *
 *  1. Use kernel_fpu_begin() and kernel_fpu_end() to enclose all in-kernel
 *     use of floating-point or vector registers and instructions.
 *
 *  2. For kernel_fpu_begin(), specify the vector register range you want to
 *     use with the KERNEL_VXR_* constants. Consider these usage guidelines:
 *
 *     a) If your function typically runs in process-context, use the lower
 *	  half of the vector registers, for example, specify KERNEL_VXR_LOW.
 *     b) If your function typically runs in soft-irq or hard-irq context,
 *	  prefer using the upper half of the vector registers, for example,
 *	  specify KERNEL_VXR_HIGH.
 *
 *     If you adhere to these guidelines, an interrupted process context
 *     does not require to save and restore vector registers because of
 *     disjoint register ranges.
 *
 *     Also note that the __kernel_fpu_begin()/__kernel_fpu_end() functions
 *     includes logic to save and restore up to 16 vector registers at once.
 *
 *  3. You can nest kernel_fpu_begin()/kernel_fpu_end() by using different
 *     struct kernel_fpu states.  Vector registers that are in use by outer
 *     levels are saved and restored.  You can minimize the save and restore
 *     effort by choosing disjoint vector register ranges.
 *
 *  5. To use vector floating-point instructions, specify the KERNEL_FPC
 *     flag to save and restore floating-point controls in addition to any
 *     vector register range.
 *
 *  6. To use floating-point registers and instructions only, specify the
 *     KERNEL_FPR flag.  This flag triggers a save and restore of vector
 *     registers V0 to V15 and floating-point controls.
 *
 * Copyright IBM Corp. 2015
 * Author(s): Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
 */

#ifndef _ASM_S390_FPU_API_H
#define _ASM_S390_FPU_API_H

#include <linux/preempt.h>

void save_fpu_regs(void);

static inline int test_fp_ctl(u32 fpc)
{
	u32 orig_fpc;
	int rc;

	asm volatile(
		"	efpc    %1\n"
		"	sfpc	%2\n"
		"0:	sfpc	%1\n"
		"	la	%0,0\n"
		"1:\n"
		EX_TABLE(0b,1b)
		: "=d" (rc), "=&d" (orig_fpc)
		: "d" (fpc), "0" (-EINVAL));
	return rc;
}

#define KERNEL_FPC		1
#define KERNEL_VXR_V0V7		2
#define KERNEL_VXR_V8V15	4
#define KERNEL_VXR_V16V23	8
#define KERNEL_VXR_V24V31	16

#define KERNEL_VXR_LOW		(KERNEL_VXR_V0V7|KERNEL_VXR_V8V15)
#define KERNEL_VXR_MID		(KERNEL_VXR_V8V15|KERNEL_VXR_V16V23)
#define KERNEL_VXR_HIGH		(KERNEL_VXR_V16V23|KERNEL_VXR_V24V31)

#define KERNEL_VXR		(KERNEL_VXR_LOW|KERNEL_VXR_HIGH)
#define KERNEL_FPR		(KERNEL_FPC|KERNEL_VXR_V0V7)

struct kernel_fpu;

/*
 * Note the functions below must be called with preemption disabled.
 * Do not enable preemption before calling __kernel_fpu_end() to prevent
 * an corruption of an existing kernel FPU state.
 *
 * Prefer using the kernel_fpu_begin()/kernel_fpu_end() pair of functions.
 */
void __kernel_fpu_begin(struct kernel_fpu *state, u32 flags);
void __kernel_fpu_end(struct kernel_fpu *state, u32 flags);


static inline void kernel_fpu_begin(struct kernel_fpu *state, u32 flags)
{
	preempt_disable();
	state->mask = S390_lowcore.fpu_flags;
	if (!test_cpu_flag(CIF_FPU))
		/* Save user space FPU state and register contents */
		save_fpu_regs();
	else if (state->mask & flags)
		/* Save FPU/vector register in-use by the kernel */
		__kernel_fpu_begin(state, flags);
	S390_lowcore.fpu_flags |= flags;
}

static inline void kernel_fpu_end(struct kernel_fpu *state, u32 flags)
{
	S390_lowcore.fpu_flags = state->mask;
	if (state->mask & flags)
		/* Restore FPU/vector register in-use by the kernel */
		__kernel_fpu_end(state, flags);
	preempt_enable();
}

#endif /* _ASM_S390_FPU_API_H */
                                                                                                                                                                                                                                                                                                                                                                    /*
 *  S390 version
 *
 *  Derived from "include/asm-i386/types.h"
 */
#ifndef _S390_TYPES_H
#define _S390_TYPES_H

#include <uapi/asm/types.h>

#endif /* _S390_TYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright IBM Corp. 2005
 *
 * Author(s): Rolf Adelsberger <adelsberger@de.ibm.com>
 *
 */

#ifndef _S390_KEXEC_H
#define _S390_KEXEC_H

#include <asm/processor.h>
#include <asm/page.h>
/*
 * KEXEC_SOURCE_MEMORY_LIMIT maximum page get_free_page can return.
 * I.e. Maximum page that is mapped directly into kernel memory,
 * and kmap is not required.
 */

/* Maximum physical address we can use pages from */
#define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)

/* Maximum address we can reach in physical address mode */
#define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)

/* Maximum address we can use for the control pages */
/* Not more than 2GB */
#define KEXEC_CONTROL_MEMORY_LIMIT (1UL<<31)

/* Allocate control page with GFP_DMA */
#define KEXEC_CONTROL_MEMORY_GFP GFP_DMA

/* Maximum address we can use for the crash control pages */
#define KEXEC_CRASH_CONTROL_MEMORY_LIMIT (-1UL)

/* Allocate one page for the pdp and the second for the code */
#define KEXEC_CONTROL_PAGE_SIZE 4096

/* Alignment of crashkernel memory */
#define KEXEC_CRASH_MEM_ALIGN HPAGE_SIZE

/* The native architecture */
#define KEXEC_ARCH KEXEC_ARCH_S390

/*
 * Size for s390x ELF notes per CPU
 *
 * Seven notes plus zero note at the end: prstatus, fpregset, timer,
 * tod_cmp, tod_reg, control regs, and prefix
 */
#define KEXEC_NOTE_BYTES \
	(ALIGN(sizeof(struct elf_note), 4) * 8 + \
	 ALIGN(sizeof("CORE"), 4) * 7 + \
	 ALIGN(sizeof(struct elf_prstatus), 4) + \
	 ALIGN(sizeof(elf_fpregset_t), 4) + \
	 ALIGN(sizeof(u64), 4) + \
	 ALIGN(sizeof(u64), 4) + \
	 ALIGN(sizeof(u32), 4) + \
	 ALIGN(sizeof(u64) * 16, 4) + \
	 ALIGN(sizeof(u32), 4) \
	)

/* Provide a dummy definition to avoid build failures. */
static inline void crash_setup_regs(struct pt_regs *newregs,
					struct pt_regs *oldregs) { }

#endif /*_S390_KEXEC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Module interface for CPU features
 *
 * Copyright IBM Corp. 2015
 * Author(s): Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
 */

#ifndef __ASM_S390_CPUFEATURE_H
#define __ASM_S390_CPUFEATURE_H

#include <asm/elf.h>

/* Hardware features on Linux on z Systems are indicated by facility bits that
 * are mapped to the so-called machine flags.  Particular machine flags are
 * then used to define ELF hardware capabilities; most notably hardware flags
 * that are essential for user space / glibc.
 *
 * Restrict the set of exposed CPU features to ELF hardware capabilities for
 * now.  Additional machine flags can be indicated by values larger than
 * MAX_ELF_HWCAP_FEATURES.
 */
#define MAX_ELF_HWCAP_FEATURES	(8 * sizeof(elf_hwcap))
#define MAX_CPU_FEATURES	MAX_ELF_HWCAP_FEATURES

#define cpu_feature(feat)	ilog2(HWCAP_S390_ ## feat)

int cpu_have_feature(unsigned int nr);

#endif /* __ASM_S390_CPUFEATURE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _S390_TLB_H
#define _S390_TLB_H

/*
 * TLB flushing on s390 is complicated. The following requirement
 * from the principles of operation is the most arduous:
 *
 * "A valid table entry must not be changed while it is attached
 * to any CPU and may be used for translation by that CPU except to
 * (1) invalidate the entry by using INVALIDATE PAGE TABLE ENTRY,
 * or INVALIDATE DAT TABLE ENTRY, (2) alter bits 56-63 of a page
 * table entry, or (3) make a change by means of a COMPARE AND SWAP
 * AND PURGE instruction that purges the TLB."
 *
 * The modification of a pte of an active mm struct therefore is
 * a two step process: i) invalidate the pte, ii) store the new pte.
 * This is true for the page protection bit as well.
 * The only possible optimization is to flush at the beginning of
 * a tlb_gather_mmu cycle if the mm_struct is currently not in use.
 *
 * Pages used for the page tables is a different story. FIXME: more
 */

#include <linux/mm.h>
#include <linux/pagemap.h>
#include <linux/swap.h>
#include <asm/processor.h>
#include <asm/pgalloc.h>
#include <asm/tlbflush.h>

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	unsigned int fullmm;
	unsigned long start, end;
};

struct mmu_table_batch {
	struct rcu_head		rcu;
	unsigned int		nr;
	void			*tables[0];
};

#define MAX_TABLE_BATCH		\
	((PAGE_SIZE - sizeof(struct mmu_table_batch)) / sizeof(void *))

extern void tlb_table_flush(struct mmu_gather *tlb);
extern void tlb_remove_table(struct mmu_gather *tlb, void *table);

static inline void tlb_gather_mmu(struct mmu_gather *tlb,
				  struct mm_struct *mm,
				  unsigned long start,
				  unsigned long end)
{
	tlb->mm = mm;
	tlb->start = start;
	tlb->end = end;
	tlb->fullmm = !(start | (end+1));
	tlb->batch = NULL;
}

static inline void tlb_flush_mmu_tlbonly(struct mmu_gather *tlb)
{
	__tlb_flush_mm_lazy(tlb->mm);
}

static inline void tlb_flush_mmu_free(struct mmu_gather *tlb)
{
	tlb_table_flush(tlb);
}


static inline void tlb_flush_mmu(struct mmu_gather *tlb)
{
	tlb_flush_mmu_tlbonly(tlb);
	tlb_flush_mmu_free(tlb);
}

static inline void tlb_finish_mmu(struct mmu_gather *tlb,
				  unsigned long start, unsigned long end)
{
	tlb_flush_mmu(tlb);
}

/*
 * Release the page cache reference for a pte removed by
 * tlb_ptep_clear_flush. In both flush modes the tlb for a page cache page
 * has already been freed, so just do free_page_and_swap_cache.
 */
static inline bool __tlb_remove_page(struct mmu_gather *tlb, struct page *page)
{
	free_page_and_swap_cache(page);
	return false; /* avoid calling tlb_flush_mmu */
}

static inline void tlb_remove_page(struct mmu_gather *tlb, struct page *page)
{
	free_page_and_swap_cache(page);
}

static inline bool __tlb_remove_page_size(struct mmu_gather *tlb,
					  struct page *page, int page_size)
{
	return __tlb_remove_page(tlb, page);
}

static inline bool __tlb_remove_pte_page(struct mmu_gather *tlb,
					 struct page *page)
{
	return __tlb_remove_page(tlb, page);
}

static inline void tlb_remove_page_size(struct mmu_gather *tlb,
					struct page *page, int page_size)
{
	return tlb_remove_page(tlb, page);
}

/*
 * pte_free_tlb frees a pte table and clears the CRSTE for the
 * page table from the tlb.
 */
static inline void pte_free_tlb(struct mmu_gather *tlb, pgtable_t pte,
				unsigned long address)
{
	page_table_free_rcu(tlb, (unsigned long *) pte, address);
}

/*
 * pmd_free_tlb frees a pmd table and clears the CRSTE for the
 * segment table entry from the tlb.
 * If the mm uses a two level page table the single pmd is freed
 * as the pgd. pmd_free_tlb checks the asce_limit against 2GB
 * to avoid the double free of the pmd in this case.
 */
static inline void pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmd,
				unsigned long address)
{
	if (tlb->mm->context.asce_limit <= (1UL << 31))
		return;
	pgtable_pmd_page_dtor(virt_to_page(pmd));
	tlb_remove_table(tlb, pmd);
}

/*
 * pud_free_tlb frees a pud table and clears the CRSTE for the
 * region third table entry from the tlb.
 * If the mm uses a three level page table the single pud is freed
 * as the pgd. pud_free_tlb checks the asce_limit against 4TB
 * to avoid the double free of the pud in this case.
 */
static inline void pud_free_tlb(struct mmu_gather *tlb, pud_t *pud,
				unsigned long address)
{
	if (tlb->mm->context.asce_limit <= (1UL << 42))
		return;
	tlb_remove_table(tlb, pud);
}

#define tlb_start_vma(tlb, vma)			do { } while (0)
#define tlb_end_vma(tlb, vma)			do { } while (0)
#define tlb_remove_tlb_entry(tlb, ptep, addr)	do { } while (0)
#define tlb_remove_pmd_tlb_entry(tlb, pmdp, addr)	do { } while (0)
#define tlb_migrate_finish(mm)			do { } while (0)

#endif /* _S390_TLB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _ASM_CSS_CHARS_H
#define _ASM_CSS_CHARS_H

#include <linux/types.h>

struct css_general_char {
	u64 : 12;
	u32 dynio : 1;	 /* bit 12 */
	u32 : 4;
	u32 eadm : 1;	 /* bit 17 */
	u32 : 23;
	u32 aif : 1;	 /* bit 41 */
	u32 : 3;
	u32 mcss : 1;	 /* bit 45 */
	u32 fcs : 1;	 /* bit 46 */
	u32 : 1;
	u32 ext_mb : 1;  /* bit 48 */
	u32 : 7;
	u32 aif_tdd : 1; /* bit 56 */
	u32 : 1;
	u32 qebsm : 1;	 /* bit 58 */
	u32 : 8;
	u32 aif_osa : 1; /* bit 67 */
	u32 : 12;
	u32 eadm_rf : 1; /* bit 80 */
	u32 : 1;
	u32 cib : 1;	 /* bit 82 */
	u32 : 5;
	u32 fcx : 1;	 /* bit 88 */
	u32 : 19;
	u32 alt_ssi : 1; /* bit 108 */
	u32:1;
	u32 narf:1;	 /* bit 110 */
} __packed;

extern struct css_general_char css_general_characteristics;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # define the KCC object
#
# Copyright (C) Dave Craft 2011
# Copyright (C) Andrew Bartlett 2015
#
# Andrew Bartlett's alleged work performed by his underlings Douglas
# Bagnall and Garming Sam.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import random
import uuid

import itertools
from samba import unix2nttime, nttime2unix
from samba import ldb, dsdb, drs_utils
from samba.auth import system_session
from samba.samdb import SamDB
from samba.dcerpc import drsuapi, misc

from samba.kcc.kcc_utils import Site, Partition, Transport, SiteLink
from samba.kcc.kcc_utils import NCReplica, NCType, nctype_lut, GraphNode
from samba.kcc.kcc_utils import RepsFromTo, KCCError, KCCFailedObject
from samba.kcc.graph import convert_schedule_to_repltimes

from samba.ndr import ndr_pack

from samba.kcc.graph_utils import verify_and_dot

from samba.kcc import ldif_import_export
from samba.kcc.graph import setup_graph, get_spanning_tree_edges
from samba.kcc.graph import Vertex

from samba.kcc.debug import DEBUG, DEBUG_FN, logger
from samba.kcc import debug


def sort_replica_by_dsa_guid(rep1, rep2):
    """Helper to sort NCReplicas by their DSA guids

    The guids need to be sorted in their NDR form.

    :param rep1: An NC replica
    :param rep2: Another replica
    :return: -1, 0, or 1, indicating sort order.
    """
    return cmp(ndr_pack(rep1.rep_dsa_guid), ndr_pack(rep2.rep_dsa_guid))


def sort_dsa_by_gc_and_guid(dsa1, dsa2):
    """Helper to sort DSAs by guid global catalog status

    GC DSAs come before non-GC DSAs, other than that, the guids are
    sorted in NDR form.

    :param dsa1: A DSA object
    :param dsa2: Another DSA
    :return: -1, 0, or 1, indicating sort order.
    """
    if dsa1.is_gc() and not dsa2.is_gc():
        return -1
    if not dsa1.is_gc() and dsa2.is_gc():
        return +1
    return cmp(ndr_pack(dsa1.dsa_guid), ndr_pack(dsa2.dsa_guid))


def is_smtp_replication_available():
    """Can the KCC use SMTP replication?

    Currently always returns false because Samba doesn't implement
    SMTP transfer for NC changes between DCs.

    :return: Boolean (always False)
    """
    return False


class KCC(object):
    """The Knowledge Consistency Checker class.

    A container for objects and methods allowing a run of the KCC.  Produces a
    set of connections in the samdb for which the Distributed Replication
    Service can then utilize to replicate naming contexts

    :param unix_now: The putative current time in seconds since 1970.
    :param read_only: Don't write to the database.
    :param verify: Check topological invariants for the generated graphs
    :param debug: Write verbosely to stderr.
    "param dot_file_dir: write diagnostic Graphviz files in this directory
    """
    def __init__(self, unix_now, readonly=False, verify=False, debug=False,
                 dot_file_dir=None):
        """Initializes the partitions class which can hold
        our local DCs partitions or all the partitions in
        the forest
        """
        self.part_table = {}    # partition objects
        self.site_table = {}
        self.ip_transport = None
        self.sitelink_table = {}
        self.dsa_by_dnstr = {}
        self.dsa_by_guid = {}

        self.get_dsa_by_guidstr = self.dsa_by_guid.get
        self.get_dsa = self.dsa_by_dnstr.get

        # TODO: These should be backed by a 'permanent' store so that when
        # calling DRSGetReplInfo with DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
        # the failure information can be returned
        self.kcc_failed_links = {}
        self.kcc_failed_connections = set()

        # Used in inter-site topology computation.  A list
        # of connections (by NTDSConnection object) that are
        # to be kept when pruning un-needed NTDS Connections
        self.kept_connections = set()

        self.my_dsa_dnstr = None  # My dsa DN
        self.my_dsa = None  # My dsa object

        self.my_site_dnstr = None
        self.my_site = None

        self.samdb = None

        self.unix_now = unix_now
        self.nt_now = unix2nttime(unix_now)
        self.readonly = readonly
        self.verify = verify
        self.debug = debug
        self.dot_file_dir = dot_file_dir

    def load_ip_transport(self):
        """Loads the inter-site transport objects for Sites

        :return: None
        :raise KCCError: if no IP transport is found
        """
        try:
            res = self.samdb.search("CN=Inter-Site Transports,CN=Sites,%s" %
                                    self.samdb.get_config_basedn(),
                                    scope=ldb.SCOPE_SUBTREE,
                                    expression="(objectClass=interSiteTransport)")
        except ldb.LdbError, (enum, estr):
            raise KCCError("Unable to find inter-site transports - (%s)" %
                           estr)

        for msg in res:
            dnstr = str(msg.dn)

            transport = Transport(dnstr)

            transport.load_transport(self.samdb)
            if transport.name == 'IP':
                self.ip_transport = transport
            elif transport.name == 'SMTP':
                logger.debug("Samba KCC is ignoring the obsolete "
                             "SMTP transport.")

            else:
                logger.warning("Samba KCC does not support the transport "
                               "called %r." % (transport.name,))

        if self.ip_transport is None:
            raise KCCError("there doesn't seem to be an IP transport")

    def load_all_sitelinks(self):
        """Loads the inter-site siteLink objects

        :return: None
        :raise KCCError: if site-links aren't found
        """
        try:
            res = self.samdb.search("CN=Inter-Site Transports,CN=Sites,%s" %
                                    self.samdb.get_config_basedn(),
                                    scope=ldb.SCOPE_SUBTREE,
                                    expression="(objectClass=siteLink)")
        except ldb.LdbError, (enum, estr):
            raise KCCError("Unable to find inter-site siteLinks - (%s)" % estr)

        for msg in res:
            dnstr = str(msg.dn)

            # already loaded
            if dnstr in self.sitelink_table:
                continue

            sitelink = SiteLink(dnstr)

            sitelink.load_sitelink(self.samdb)

            # Assign this siteLink to table
            # and index by dn
            self.sitelink_table[dnstr] = sitelink

    def load_site(self, dn_str):
        """Helper for load_my_site and load_all_sites.

        Put all the site's DSAs into the KCC indices.

        :param dn_str: a site dn_str
        :return: the Site object pertaining to the dn_str
        """
        site = Site(dn_str, self.unix_now)
        site.load_site(self.samdb)

        # We avoid replacing the site with an identical copy in case
        # somewhere else has a reference to the old one, which would
        # lead to all manner of confusion and chaos.
        guid = str(site.site_guid)
        if guid not in self.site_table:
            self.site_table[guid] = site
            self.dsa_by_dnstr.update(site.dsa_table)
            self.dsa_by_guid.update((str(x.dsa_guid), x)
                                    for x in site.dsa_table.values())

        return self.site_table[guid]

    def load_my_site(self):
        """Load the Site object for the local DSA.

        :return: None
        """
        self.my_site_dnstr = ("CN=%s,CN=Sites,%s" % (
            self.samdb.server_site_name(),
            self.samdb.get_config_basedn()))

        self.my_site = self.load_site(self.my_site_dnstr)

    def load_all_sites(self):
        """Discover all sites and create Site objects.

        :return: None
        :raise: KCCError if sites can't be found
        """
        try:
            res = self.samdb.search("CN=Sites,%s" %
                                    self.samdb.get_config_basedn(),
                                    scope=ldb.SCOPE_SUBTREE,
                                    expression="(objectClass=site)")
        except ldb.LdbError, (enum, estr):
            raise KCCError("Unable to find sites - (%s)" % estr)

        for msg in res:
            sitestr = str(msg.dn)
            self.load_site(sitestr)

    def load_my_dsa(self):
        """Discover my nTDSDSA dn thru the rootDSE entry

        :return: None
        :raise: KCCError if DSA can't be found
        """
        dn_query = "<GUID=%s>" % self.samdb.get_ntds_GUID()
        dn = ldb.Dn(self.samdb, dn_query)
        try:
            res = self.samdb.search(base=dn, scope=ldb.SCOPE_BASE,
                                    attrs=["objectGUID"])
        except ldb.LdbError, (enum, estr):
            DEBUG_FN("Search for dn '%s' [from %s] failed: %s. "
                     "This typically happens in --importldif mode due "
                     "to lack of module support." % (dn, dn_query, estr))
            try:
                # We work around the failure above by looking at the
                # dsServiceName that was put in the fake rootdse by
                # the --exportldif, rather than the
                # samdb.get_ntds_GUID(). The disadvantage is that this
                # mode requires we modify the @ROOTDSE dnq to support
                # --forced-local-dsa
                service_name_res = self.samdb.search(base="",
                                                     scope=ldb.SCOPE_BASE,
                                                     attrs=["dsServiceName"])
                dn = ldb.Dn(self.samdb,
                            service_name_res[0]["dsServiceName"][0])

                res = self.samdb.search(base=dn, scope=ldb.SCOPE_BASE,
                                        attrs=["objectGUID"])
            except ldb.LdbError, (enum, estr):
                raise KCCError("Unable to find my nTDSDSA - (%s)" % estr)

        if len(res) != 1:
            raise KCCError("Unable to find my nTDSDSA at %s" %
                           dn.extended_str())

        ntds_guid = misc.GUID(self.samdb.get_ntds_GUID())
        if misc.GUID(res[0]["objectGUID"][0]) != ntds_guid:
            raise KCCError("Did not find the GUID we expected,"
                           " perhaps due to --importldif")

        self.my_dsa_dnstr = str(res[0].dn)

        self.my_dsa = self.my_site.get_dsa(self.my_dsa_dnstr)

        if self.my_dsa_dnstr not in self.dsa_by_dnstr:
            debug.DEBUG_DARK_YELLOW("my_dsa %s isn't in self.dsas_by_dnstr:"
                                    " it must be RODC.\n"
                                    "Let's add it, because my_dsa is special!"
                                    "\n(likewise for self.dsa_by_guid)" %
                                    self.my_dsa_dnstr)

            self.dsa_by_dnstr[self.my_dsa_dnstr] = self.my_dsa
            self.dsa_by_guid[str(self.my_dsa.dsa_guid)] = self.my_dsa

    def load_all_partitions(self):
        """Discover and load all partitions.

        Each NC is inserted into the part_table by partition
        dn string (not the nCName dn string)

        :return: None
        :raise: KCCError if partitions can't be found
        """
        try:
            res = self.samdb.search("CN=Partitions,%s" %
                                    self.samdb.get_config_basedn(),
                                    scope=ldb.SCOPE_SUBTREE,
                                    expression="(objectClass=crossRef)")
        except ldb.LdbError, (enum, estr):
            raise KCCError("Unable to find partitions - (%s)" % estr)

        for msg in res:
            partstr = str(msg.dn)

            # already loaded
            if partstr in self.part_table:
                continue

            part = Partition(partstr)

            part.load_partition(self.samdb)
            self.part_table[partstr] = part

    def refresh_failed_links_connections(self, ping=None):
        """Ensure the failed links list is up to date

        Based on MS-ADTS 6.2.2.1

        :param ping: An oracle function of remote site availability
        :return: None
        """
        # LINKS: Refresh failed links
        self.kcc_failed_links = {}
        current, needed = self.my_dsa.get_rep_tables()
        for replica in current.values():
            # For every possible connection to replicate
            for reps_from in replica.rep_repsFrom:
                failure_count = reps_from.consecutive_sync_failures
                if failure_count <= 0:
                    continue

                dsa_guid = str(reps_from.source_dsa_obj_guid)
                time_first_failure = reps_from.last_success
                last_result = reps_from.last_attempt
                dns_name = reps_from.dns_name1

                f = self.kcc_failed_links.get(dsa_guid)
                if f is None:
                    f = KCCFailedObject(dsa_guid, failure_count,
                                        time_first_failure, last_result,
                                        dns_name)
                    self.kcc_failed_links[dsa_guid] = f
                else:
                    f.failure_count = max(f.failure_count, failure_count)
                    f.time_first_failure = min(f.time_first_failure,
                                               time_first_failure)
                    f.last_result = last_result

        # CONNECTIONS: Refresh failed connections
        restore_connections = set()
        if ping is not None:
            DEBUG("refresh_failed_links: checking if links are still down")
            for connection in self.kcc_failed_connections:
                if ping(connection.dns_name):
                    # Failed connection is no longer failing
                    restore_connections.add(connection)
                else:
                    connection.failure_count += 1
        else:
            DEBUG("refresh_failed_links: not checking live links because we\n"
                  "weren't asked to --attempt-live-connections")

        # Remove the restored connections from the failed connections
        self.kcc_failed_connections.difference_update(restore_connections)

    def is_stale_link_connection(self, target_dsa):
        """Check whether a link to a remote DSA is stale

        Used in MS-ADTS 6.2.2.2 Intrasite Connection Creation

        Returns True if the remote seems to have been down for at
        least two hours, otherwise False.

        :param target_dsa: the remote DSA object
        :return: True if link is stale, otherwise False
        """
        failed_link = self.kcc_failed_links.get(str(target_dsa.dsa_guid))
        if failed_link:
            # failure_count should be > 0, but check anyways
            if failed_link.failure_count > 0:
                unix_first_failure = \
                    nttime2unix(failed_link.time_first_failure)
                # TODO guard against future
                if unix_first_failure > self.unix_now:
                    logger.error("The last success time attribute for \
                                 repsFrom is in the future!")

                # Perform calculation in seconds
                if (self.unix_now - unix_first_failure) > 60 * 60 * 2:
                    return True

        # TODO connections.
        # We have checked failed *links*, but we also need to check
        # *connections*

        return False

    # TODO: This should be backed by some form of local database
    def remove_unneeded_failed_links_connections(self):
        # Remove all tuples in kcc_failed_links where failure count = 0
        # In this implementation, this should never happen.

        # Remove all connections which were not used this run or connections
        # that became active during this run.
        pass

    def _ensure_connections_are_loaded(self, connections):
        """Load or fake-load NTDSConnections lacking GUIDs

        New connections don't have GUIDs and created times which are
        needed for sorting. If we're in read-only mode, we make fake
        GUIDs, otherwise we ask SamDB to do it for us.

        :param connections: an iterable of NTDSConnection objects.
        :return: None
        """
        for cn_conn in connections:
            if cn_conn.guid is None:
                if self.readonly:
                    cn_conn.guid = misc.GUID(str(uuid.uuid4()))
                    cn_conn.whenCreated = self.nt_now
                else:
                    cn_conn.load_connection(self.samdb)

    def _mark_broken_ntdsconn(self):
        """Find NTDS Connections that lack a remote

        I'm not sure how they appear. Let's be rid of them by marking
        them with the to_be_deleted attribute.

        :return: None
        """
        for cn_conn in self.my_dsa.connect_table.values():
            s_dnstr = cn_conn.get_from_dnstr()
            if s_dnstr is None:
                DEBUG_FN("%s has phantom connection %s" % (self.my_dsa,
                                                           cn_conn))
                cn_conn.to_be_deleted = True

    def _mark_unneeded_local_ntdsconn(self):
        """Find unneeded intrasite NTDS Connections for removal

        Based on MS-ADTS 6.2.2.4 Removing Unnecessary Connections.
        Every DC removes its own unnecessary intrasite connections.
        This function tags them with the to_be_deleted attribute.

        :return: None
        """
        # XXX should an RODC be regarded as same site? It isn't part
        # of the intrasite ring.

        if self.my_site.is_cleanup_ntdsconn_disabled():
            DEBUG_FN("not doing ntdsconn cleanup for site %s, "
                     "because it is disabled" % self.my_site)
            return

        mydsa = self.my_dsa

        try:
            self._ensure_connections_are_loaded(mydsa.connect_table.values())
        except KCCError:
            # RODC never actually added any connections to begin with
            if mydsa.is_ro():
                return

        local_connections = []

        for cn_conn in mydsa.connect_table.values():
            s_dnstr = cn_conn.get_from_dnstr()
            if s_dnstr in self.my_site.dsa_table:
                removable = not (cn_conn.is_generated() or
                                 cn_conn.is_rodc_topology())
                packed_guid = ndr_pack(cn_conn.guid)
                local_connections.append((cn_conn, s_dnstr,
                                          packed_guid, removable))

        for a, b in itertools.permutations(local_connections, 2):
            cn_conn, s_dnstr, packed_guid, removable = a
            cn_conn2, s_dnstr2, packed_guid2, removable2 = b
            if (removable and
                s_dnstr == s_dnstr2 and
                cn_conn.whenCreated < cn_conn2.whenCreated or
                (cn_conn.whenCreated == cn_conn2.whenCreated and
                 packed_guid < packed_guid2)):
                cn_conn.to_be_deleted = True

    def _mark_unneeded_intersite_ntdsconn(self):
        """find unneeded intersite NTDS Connections for removal

        Based on MS-ADTS 6.2.2.4 Removing Unnecessary Connections. The
        intersite topology generator removes links for all DCs in its
        site. Here we just tag them with the to_be_deleted attribute.

        :return: None
        """
        # TODO Figure out how best to handle the RODC case
        # The RODC is ITSG, but shouldn't act on anyone's behalf.
        if self.my_dsa.is_ro():
            return

        # Find the intersite connections
        local_dsas = self.my_site.dsa_table
        connections_and_dsas = []
        for dsa in local_dsas.values():
            for cn in dsa.connect_table.values():
                if cn.to_be_deleted:
                    continue
                s_dnstr = cn.get_from_dnstr()
                if s_dnstr is None:
                    continue
                if s_dnstr not in local_dsas:
                    from_dsa = self.get_dsa(s_dnstr)
                    # Samba ONLY: ISTG removes connections to dead DCs
                    if from_dsa is None and '\\0ADEL' in s_dnstr:
                        logger.info("DSA appears deleted, removing connection %s" % s_dnstr)
                        cn.to_be_deleted = True
                        continue
                    connections_and_dsas.append((cn, dsa, from_dsa))

        self._ensure_connections_are_loaded(x[0] for x in connections_and_dsas)
        for cn, to_dsa, from_dsa in connections_and_dsas:
            if not cn.is_generated() or cn.is_rodc_topology():
                continue

            # If the connection is in the kept_connections list, we
            # only remove it if an endpoint seems down.
            if (cn in self.kept_connections and
                not (self.is_bridgehead_failed(to_dsa, True) or
                     self.is_bridgehead_failed(from_dsa, True))):
                continue

            # this one is broken and might be superseded by another.
            # But which other? Let's just say another link to the same
            # site can supersede.
            from_dnstr = from_dsa.dsa_dnstr
            for site in self.site_table.values():
                if from_dnstr in site.rw_dsa_table:
                    for cn2, to_dsa2, from_dsa2 in connections_and_dsas:
                        if (cn is not cn2 and
                            from_dsa2 in site.rw_dsa_table):
                            cn.to_be_deleted = True

    def _commit_changes(self, dsa):
        if dsa.is_ro() or self.readonly:
            for connect in dsa.connect_table.values():
                if connect.to_be_deleted:
                    logger.info("TO BE DELETED:\n%s" % connect)
                if connect.to_be_added:
                    logger.info("TO BE ADDED:\n%s" % connect)
                if connect.to_be_modified:
                    logger.info("TO BE MODIFIED:\n%s" % connect)

            # Peform deletion from our tables but perform
            # no database modification
            dsa.commit_connections(self.samdb, ro=True)
        else:
            # Commit any modified connections
            dsa.commit_connections(self.samdb)

    def remove_unneeded_ntdsconn(self, all_connected):
        """Remove unneeded NTDS Connections once topology is calculated

        Based on MS-ADTS 6.2.2.4 Removing Unnecessary Connections

        :param all_connected: indicates whether all sites are connected
        :return: None
        """
        self._mark_broken_ntdsconn()
        self._mark_unneeded_local_ntdsconn()
        # if we are not the istg, we're done!
        # if we are the istg, but all_connected is False, we also do nothing.
        if self.my_dsa.is_istg() and all_connected:
            self._mark_unneeded_intersite_ntdsconn()

        for dsa in self.my_site.dsa_table.values():
            self._commit_changes(dsa)

    def modify_repsFrom(self, n_rep, t_repsFrom, s_rep, s_dsa, cn_conn):
        """Update an repsFrom object if required.

        Part of MS-ADTS 6.2.2.5.

        Update t_repsFrom if necessary to satisfy requirements. Such
        updates are typically required when the IDL_DRSGetNCChanges
        server has moved from one site to another--for example, to
        enable compression when the server is moved from the
        client's site to another site.

        The repsFrom.update_flags bit field may be modified
        auto-magically if any changes are made here. See
        kcc_utils.RepsFromTo for gory details.


        :param n_rep: NC replica we need
        :param t_repsFrom: repsFrom tuple to modify
        :param s_rep: NC replica at source DSA
        :param s_dsa: source DSA
        :param cn_conn: Local DSA NTDSConnection child

        :return: None
        """
        s_dnstr = s_dsa.dsa_dnstr
        same_site = s_dnstr in self.my_site.dsa_table

        # if schedule doesn't match then update and modify
        times = convert_schedule_to_repltimes(cn_conn.schedule)
        if times != t_repsFrom.schedule:
            t_repsFrom.schedule = times

        # Bit DRS_ADD_REF is set in replicaFlags unconditionally
        # Samba ONLY:
        if ((t_repsFrom.replica_flags &
             drsuapi.DRSUAPI_DRS_ADD_REF) == 0x0):
            t_repsFrom.replica_flags |= drsuapi.DRSUAPI_DRS_ADD_REF

        # Bit DRS_PER_SYNC is set in replicaFlags if and only
        # if nTDSConnection schedule has a value v that specifies
        # scheduled replication is to be performed at least once
        # per week.
        if cn_conn.is_schedule_minimum_once_per_week():

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_PER_SYNC) == 0x0):
                t_repsFrom.replica_flags |= drsuapi.DRSUAPI_DRS_PER_SYNC

        # Bit DRS_INIT_SYNC is set in t.replicaFlags if and only
        # if the source DSA and the local DC's nTDSDSA object are
        # in the same site or source dsa is the FSMO role owner
        # of one or more FSMO roles in the NC replica.
        if same_site or n_rep.is_fsmo_role_owner(s_dnstr):

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_INIT_SYNC) == 0x0):
                t_repsFrom.replica_flags |= drsuapi.DRSUAPI_DRS_INIT_SYNC

        # If bit NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT is set in
        # cn!options, bit DRS_NEVER_NOTIFY is set in t.replicaFlags
        # if and only if bit NTDSCONN_OPT_USE_NOTIFY is clear in
        # cn!options. Otherwise, bit DRS_NEVER_NOTIFY is set in
        # t.replicaFlags if and only if s and the local DC's
        # nTDSDSA object are in different sites.
        if ((cn_conn.options &
             dsdb.NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) != 0x0):

            if (cn_conn.options & dsdb.NTDSCONN_OPT_USE_NOTIFY) == 0x0:
                # WARNING
                #
                # it LOOKS as if this next test is a bit silly: it
                # checks the flag then sets it if it not set; the same
                # effect could be achieved by unconditionally setting
                # it. But in fact the repsFrom object has special
                # magic attached to it, and altering replica_flags has
                # side-effects. That is bad in my opinion, but there
                # you go.
                if ((t_repsFrom.replica_flags &
                     drsuapi.DRSUAPI_DRS_NEVER_NOTIFY) == 0x0):
                    t_repsFrom.replica_flags |= \
                        drsuapi.DRSUAPI_DRS_NEVER_NOTIFY

        elif not same_site:

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_NEVER_NOTIFY) == 0x0):
                t_repsFrom.replica_flags |= drsuapi.DRSUAPI_DRS_NEVER_NOTIFY

        # Bit DRS_USE_COMPRESSION is set in t.replicaFlags if
        # and only if s and the local DC's nTDSDSA object are
        # not in the same site and the
        # NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION bit is
        # clear in cn!options
        if (not same_site and
            (cn_conn.options &
             dsdb.NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION) == 0x0):

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_USE_COMPRESSION) == 0x0):
                t_repsFrom.replica_flags |= drsuapi.DRSUAPI_DRS_USE_COMPRESSION

        # Bit DRS_TWOWAY_SYNC is set in t.replicaFlags if and only
        # if bit NTDSCONN_OPT_TWOWAY_SYNC is set in cn!options.
        if (cn_conn.options & dsdb.NTDSCONN_OPT_TWOWAY_SYNC) != 0x0:

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_TWOWAY_SYNC) == 0x0):
                t_repsFrom.replica_flags |= drsuapi.DRSUAPI_DRS_TWOWAY_SYNC

        # Bits DRS_DISABLE_AUTO_SYNC and DRS_DISABLE_PERIODIC_SYNC are
        # set in t.replicaFlags if and only if cn!enabledConnection = false.
        if not cn_conn.is_enabled():

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_DISABLE_AUTO_SYNC) == 0x0):
                t_repsFrom.replica_flags |= \
                    drsuapi.DRSUAPI_DRS_DISABLE_AUTO_SYNC

            if ((t_repsFrom.replica_flags &
                 drsuapi.DRSUAPI_DRS_DISABLE_PERIODIC_SYNC) == 0x0):
                t_repsFrom.replica_flags |= \
                    drsuapi.DRSUAPI_DRS_DISABLE_PERIODIC_SYNC

        # If s and the local DC's nTDSDSA object are in the same site,
        # cn!transportType has no value, or the RDN of cn!transportType
        # is CN=IP:
        #
        #     Bit DRS_MAIL_REP in t.replicaFlags is clear.
        #
        #     t.uuidTransport = NULL GUID.
        #
        #     t.uuidDsa = The GUID-based DNS name of s.
        #
        # Otherwise:
        #
        #     Bit DRS_MAIL_REP in t.replicaFlags is set.
        #
        #     If x is the object with dsname cn!transportType,
        #     t.uuidTransport = x!objectGUID.
        #
        #     Let a be the attribute identified by
        #     x!transportAddressAttribute. If a is
        #     the dNSHostName attribute, t.uuidDsa = the GUID-based
        #      DNS name of s. Otherwise, t.uuidDsa = (s!parent)!a.
        #
        # It appears that the first statement i.e.
        #
        #     "If s and the local DC's nTDSDSA object are in the same
        #      site, cn!transportType has no value, or the RDN of
        #      cn!transportType is CN=IP:"
        #
        # could be a slightly tighter statement if it had an "or"
        # between each condition.  I believe this should
        # be interpreted as:
        #
        #     IF (same-site) OR (no-value) OR (type-ip)
        #
        # because IP should be the primary transport mechanism
        # (even in inter-site) and the absense of the transportType
        # attribute should always imply IP no matter if its multi-site
        #
        # NOTE MS-TECH INCORRECT:
        #
        #     All indications point to these statements above being
        #     incorrectly stated:
        #
        #         t.uuidDsa = The GUID-based DNS name of s.
        #
        #         Let a be the attribute identified by
        #         x!transportAddressAttribute. If a is
        #         the dNSHostName attribute, t.uuidDsa = the GUID-based
        #         DNS name of s. Otherwise, t.uuidDsa = (s!parent)!a.
        #
        #     because the uuidDSA is a GUID and not a GUID-base DNS
        #     name.  Nor can uuidDsa hold (s!parent)!a if not
        #     dNSHostName.  What should have been said is:
        #
        #         t.naDsa = The GUID-based DNS name of s
        #
        #     That would also be correct if transportAddressAttribute
        #     were "mailAddress" because (naDsa) can also correctly
        #     hold the SMTP ISM service address.
        #
        nastr = "%s._msdcs.%s" % (s_dsa.dsa_guid, self.samdb.forest_dns_name())

        if ((t_repsFrom.replica_flags &
             drsuapi.DRSUAPI_DRS_MAIL_REP) != 0x0):
            t_repsFrom.replica_flags &= ~drsuapi.DRSUAPI_DRS_MAIL_REP

        t_repsFrom.transport_guid = misc.GUID()

        # See (NOTE MS-TECH INCORRECT) above

        # NOTE: it looks like these conditionals are pointless,
        # because the state will end up as `t_repsFrom.dns_name1 ==
        # nastr` in either case, BUT the repsFrom thing is magic and
        # assigning to it alters some flags. So we try not to update
        # it unless necessary.
        if t_repsFrom.dns_name1 != nastr:
            t_repsFrom.dns_name1 = nastr

        if t_repsFrom.version > 0x1 and t_repsFrom.dns_name2 != nastr:
            t_repsFrom.dns_name2 = nastr

        if t_repsFrom.is_modified():
            DEBUG_FN("modify_repsFrom(): %s" % t_repsFrom)

    def get_dsa_for_implied_replica(self, n_rep, cn_conn):
        """If a connection imply a replica, find the relevant DSA

        Given a NC replica and NTDS Connection, determine if the
        connection implies a repsFrom tuple should be present from the
        source DSA listed in the connection to the naming context. If
        it should be, return the DSA; otherwise return None.

        Based on part of MS-ADTS 6.2.2.5

        :param n_rep: NC replica
        :param cn_conn: NTDS Connection
        :return: source DSA or None
        """
        # XXX different conditions for "implies" than MS-ADTS 6.2.2
        # preamble.

        # It boils down to: we want an enabled, non-FRS connections to
        # a valid remote DSA with a non-RO replica corresponding to
        # n_rep.

        if not cn_conn.is_enabled() or cn_conn.is_rodc_topology():
            return None

        s_dnstr = cn_conn.get_from_dnstr()
        s_dsa = self.get_dsa(s_dnstr)

        # No DSA matching this source DN string?
        if s_dsa is None:
            return None

        s_rep = s_dsa.get_current_replica(n_rep.nc_dnstr)

        if (s_rep is not None and
            s_rep.is_present() and
            (not s_rep.is_ro() or n_rep.is_partial())):
            return s_dsa
        return None

    def translate_ntdsconn(self, current_dsa=None):
        """Adjust repsFrom to match NTDSConnections

        This function adjusts values of repsFrom abstract attributes of NC
        replicas on the local DC to match those implied by
        nTDSConnection objects.

        Based on [MS-ADTS] 6.2.2.5

        :param current_dsa: optional DSA on whose behalf we are acting.
        :return: None
        """
        count = 0

        ro = False
        if current_dsa is None:
            current_dsa = self.my_dsa

        if current_dsa.is_ro():
            ro = True

        if current_dsa.is_translate_ntdsconn_disabled():
            DEBUG_FN("skipping translate_ntdsconn() "
                     "because disabling flag is set")
            return

        DEBUG_FN("translate_ntdsconn(): enter")

        current_rep_table, needed_rep_table = current_dsa.get_rep_tables()

        # Filled in with replicas we currently have that need deleting
        delete_reps = set()

        # We're using the MS notation names here to allow
        # correlation back to the published algorithm.
        #
        # n_rep      - NC replica (n)
        # t_repsFrom - tuple (t) in n!repsFrom
        # s_dsa      - Source DSA of the replica. Defined as nTDSDSA
        #              object (s) such that (s!objectGUID = t.uuidDsa)
        #              In our IDL representation of repsFrom the (uuidDsa)
        #              attribute is called (source_dsa_obj_guid)
        # cn_conn    - (cn) is nTDSConnection object and child of the local
        #               DC's nTDSDSA object and (cn!fromServer = s)
        # s_rep      - source DSA replica of n
        #
        # If we have the replica and its not needed
        # then we add it to the "to be deleted" list.
        for dnstr in current_rep_table:
            # If we're on the RODC, hardcode the update flags
            if ro:
                c_rep = current_rep_table[dnstr]
                c_rep.load_repsFrom(self.samdb)
                for t_repsFrom in c_rep.rep_repsFrom:
                    replica_flags = (drsuapi.DRSUAPI_DRS_INIT_SYNC |
                                     drsuapi.DRSUAPI_DRS_PER_SYNC |
                                     drsuapi.DRSUAPI_DRS_ADD_REF |
                                     drsuapi.DRSUAPI_DRS_SPECIAL_SECRET_PROCESSING |
                                     drsuapi.DRSUAPI_DRS_GET_ALL_GROUP_MEMBERSHIP |
                                     drsuapi.DRSUAPI_DRS_NONGC_RO_REP)
                    if t_repsFrom.replica_flags != replica_flags:
                        t_repsFrom.replica_flags = replica_flags
                c_rep.commit_repsFrom(self.samdb)
            else:
                if dnstr not in needed_rep_table:
                    delete_reps.add(dnstr)

        DEBUG_FN('current %d needed %d delete %d' % (len(current_rep_table),
                 len(needed_rep_table), len(delete_reps)))

        if delete_reps:
            # TODO Must delete repsFrom/repsTo for these replicas
            DEBUG('deleting these reps: %s' % delete_reps)
            for dnstr in delete_reps:
                del current_rep_table[dnstr]

        # HANDLE REPS-FROM
        #
        # Now perform the scan of replicas we'll need
        # and compare any current repsFrom against the
        # connections
        for n_rep in needed_rep_table.values():

            # load any repsFrom and fsmo roles as we'll
            # need them during connection translation
            n_rep.load_repsFrom(self.samdb)
            n_rep.load_fsmo_roles(self.samdb)

            # Loop thru the existing repsFrom tuples (if any)
            # XXX This is a list and could contain duplicates
            #     (multiple load_repsFrom calls)
            for t_repsFrom in n_rep.rep_repsFrom:

                # for each tuple t in n!repsFrom, let s be the nTDSDSA
                # object such that s!objectGUID = t.uuidDsa
                guidstr = str(t_repsFrom.source_dsa_obj_guid)
                s_dsa = self.get_dsa_by_guidstr(guidstr)

                # Source dsa is gone from config (strange)
                # so cleanup stale repsFrom for unlisted DSA
                if s_dsa is None:
                    logger.warning("repsFrom source DSA guid (%s) not found" %
                                   guidstr)
                    t_repsFrom.to_be_deleted = True
                    continue

                # Find the connection that this repsFrom would use. If
                # there isn't a good one (i.e. non-RODC_TOPOLOGY,
                # meaning non-FRS), we delete the repsFrom.
                s_dnstr = s_dsa.dsa_dnstr
                connections = current_dsa.get_connection_by_from_dnstr(s_dnstr)
                for cn_conn in connections:
                    if not cn_conn.is_rodc_topology():
                        break
                else:
                    # no break means no non-rodc_topology connection exists
                    t_repsFrom.to_be_deleted = True
                    continue

                # KCC removes this repsFrom tuple if any of the following
                # is true:
                #     No NC replica of the NC "is present" on DSA that
                #     would be source of replica
                #
                #     A writable replica of the NC "should be present" on
                #     the local DC, but a partial replica "is present" on
                #     the source DSA
                s_rep = s_dsa.get_current_replica(n_rep.nc_dnstr)

                if s_rep is None or not s_rep.is_present() or \
                   (not n_rep.is_ro() and s_rep.is_partial()):

                    t_repsFrom.to_be_deleted = True
                    continue

                # If the KCC did not remove t from n!repsFrom, it updates t
                self.modify_repsFrom(n_rep, t_repsFrom, s_rep, s_dsa, cn_conn)

            # Loop thru connections and add implied repsFrom tuples
            # for each NTDSConnection under our local DSA if the
            # repsFrom is not already present
            for cn_conn in current_dsa.connect_table.values():

                s_dsa = self.get_dsa_for_implied_replica(n_rep, cn_conn)
                if s_dsa is None:
                    continue

                # Loop thru the existing repsFrom tuples (if any) and
                # if we already have a tuple for this connection then
                # no need to proceed to add.  It will have been changed
                # to have the correct attributes above
                for t_repsFrom in n_rep.rep_repsFrom:
                    guidstr = str(t_repsFrom.source_dsa_obj_guid)
                    if s_dsa is self.get_dsa_by_guidstr(guidstr):
                        s_dsa = None
                        break

                if s_dsa is None:
                    continue

                # Create a new RepsFromTo and proceed to modify
                # it according to specification
                t_repsFrom = RepsFromTo(n_rep.nc_dnstr)

                t_repsFrom.source_dsa_obj_guid = s_dsa.dsa_guid

                s_rep = s_dsa.get_current_replica(n_rep.nc_dnstr)

                self.modify_repsFrom(n_rep, t_repsFrom, s_rep, s_dsa, cn_conn)

                # Add to our NC repsFrom as this is newly computed
                if t_repsFrom.is_modified():
                    n_rep.rep_repsFrom.append(t_repsFrom)

            if self.readonly or ro:
                # Display any to be deleted or modified repsFrom
                text = n_rep.dumpstr_to_be_deleted()
                if text:
                    logger.info("TO BE DELETED:\n%s" % text)
                text = n_rep.dumpstr_to_be_modified()
                if text:
                    logger.info("TO BE MODIFIED:\n%s" % text)

                # Peform deletion from our tables but perform
                # no database modification
                n_rep.commit_repsFrom(self.samdb, ro=True)
            else:
                # Commit any modified repsFrom to the NC replica
                n_rep.commit_repsFrom(self.samdb)

        # HANDLE REPS-TO:
        #
        # Now perform the scan of replicas we'll need
        # and compare any current repsTo against the
        # connections

        # RODC should never push to anybody (should we check this?)
        if ro:
            return

        for n_rep in needed_rep_table.values():

            # load any repsTo and fsmo roles as we'll
            # need them during connection translation
            n_rep.load_repsTo(self.samdb)

            # Loop thru the existing repsTo tuples (if any)
            # XXX This is a list and could contain duplicates
            #     (multiple load_repsTo calls)
            for t_repsTo in n_rep.rep_repsTo:

                # for each tuple t in n!repsTo, let s be the nTDSDSA
                # object such that s!objectGUID = t.uuidDsa
                guidstr = str(t_repsTo.source_dsa_obj_guid)
                s_dsa = self.get_dsa_by_guidstr(guidstr)

                # Source dsa is gone from config (strange)
                # so cleanup stale repsTo for unlisted DSA
                if s_dsa is None:
                    logger.warning("repsTo source DSA guid (%s) not found" %
                                   guidstr)
                    t_repsTo.to_be_deleted = True
                    continue

                # Find the connection that this repsTo would use. If
                # there isn't a good one (i.e. non-RODC_TOPOLOGY,
                # meaning non-FRS), we delete the repsTo.
                s_dnstr = s_dsa.dsa_dnstr
                if '\\0ADEL' in s_dnstr:
                    logger.warning("repsTo source DSA guid (%s) appears deleted" %
                                   guidstr)
                    t_repsTo.to_be_deleted = True
                    continue

                connections = s_dsa.get_connection_by_from_dnstr(self.my_dsa_dnstr)
                if len(connections) > 0:
                    # Then this repsTo is tentatively valid
                    continue
                else:
                    # There is no plausible connection for this repsTo
                    t_repsTo.to_be_deleted = True

            if self.readonly:
                # Display any to be deleted or modified repsTo
                text = n_rep.dumpstr_reps_to()
                if text:
                    logger.info("REMOVING REPS-TO:\n%s" % text)

                # Peform deletion from our tables but perform
                # no database modification
                n_rep.commit_repsTo(self.samdb, ro=True)
            else:
                # Commit any modified repsTo to the NC replica
                n_rep.commit_repsTo(self.samdb)

        # TODO Remove any duplicate repsTo values. This should never happen in
        # any normal situations.

    def merge_failed_links(self, ping=None):
        """Merge of kCCFailedLinks and kCCFailedLinks from bridgeheads.

        The KCC on a writable DC attempts to merge the link and connection
        failure information from bridgehead DCs in its own site to help it
        identify failed bridgehead DCs.

        Based on MS-ADTS 6.2.2.3.2 "Merge of kCCFailedLinks and kCCFailedLinks
        from Bridgeheads"

        :param ping: An oracle of current bridgehead availability
        :return: None
        """
        # 1. Queries every bridgehead server in your site (other than yourself)
        # 2. For every ntDSConnection that references a server in a different
        #    site merge all the failure info
        #
        # XXX - not implemented yet
        if ping is not None:
            debug.DEBUG_RED("merge_failed_links() is NOT IMPLEMENTED")
        else:
            DEBUG_FN("skipping merge_failed_links() because it requires "
                     "real network connections\n"
                     "and we weren't asked to --attempt-live-connections")

    def setup_graph(self, part):
        """Set up an intersite graph

        An intersite graph has a Vertex for each site object, a
        MultiEdge for each SiteLink object, and a MutliEdgeSet for
        each siteLinkBridge object (or implied siteLinkBridge). It
        reflects the intersite topology in a slightly more abstract
        graph form.

        Roughly corresponds to MS-ADTS 6.2.2.3.4.3

        :param part: a Partition object
        :returns: an InterSiteGraph object
        """
        # If 'Bridge all site links' is enabled and Win2k3 bridges required
        # is not set
        # NTDSTRANSPORT_OPT_BRIDGES_REQUIRED 0x00000002
        # No documentation for this however, ntdsapi.h appears to have:
        # NTDSSETTINGS_OPT_W2K3_BRIDGES_REQUIRED = 0x00001000
        bridges_required = self.my_site.site_options & 0x00001002 != 0
        transport_guid = str(self.ip_transport.guid)

        g = setup_graph(part, self.site_table, transport_guid,
                        self.sitelink_table, bridges_required)

        if self.verify or self.dot_file_dir is not None:
            dot_edges = []
            for edge in g.edges:
                for a, b in itertools.combinations(edge.vertices, 2):
                    dot_edges.append((a.site.site_dnstr, b.site.site_dnstr))
            verify_properties = ()
            name = 'site_edges_%s' % part.partstr
            verify_and_dot(name, dot_edges, directed=False,
                           label=self.my_dsa_dnstr,
                           properties=verify_properties, debug=DEBUG,
                           verify=self.verify,
                           dot_file_dir=self.dot_file_dir)

        return g

    def get_bridgehead(self, site, part, transport, partial_ok, detect_failed):
        """Get a bridghead DC for a site.

        Part of MS-ADTS 6.2.2.3.4.4

        :param site: site object representing for which a bridgehead
            DC is desired.
        :param part: crossRef for NC to replicate.
        :param transport: interSiteTransport object for replication
            traffic.
        :param partial_ok: True if a DC containing a partial
            replica or a full replica will suffice, False if only
            a full replica will suffice.
        :param detect_failed: True to detect failed DCs and route
            replication traffic around them, False to assume no DC
            has failed.
        :return: dsa object for the bridgehead DC or None
        """

        bhs = self.get_all_bridgeheads(site, part, transport,
                                       partial_ok, detect_failed)
        if not bhs:
            debug.DEBUG_MAGENTA("get_bridgehead FAILED:\nsitedn = %s" %
                                site.site_dnstr)
            return None

        debug.DEBUG_GREEN("get_bridgehead:\n\tsitedn = %s\n\tbhdn = %s" %
                          (site.site_dnstr, bhs[0].dsa_dnstr))
        return bhs[0]

    def get_all_bridgeheads(self, site, part, transport,
                            partial_ok, detect_failed):
        """Get all bridghead DCs on a site satisfying the given criteria

        Part of MS-ADTS 6.2.2.3.4.4

        :param site: site object representing the site for which
            bridgehead DCs are desired.
        :param part: partition for NC to replicate.
        :param transport: interSiteTransport object for
            replication traffic.
        :param partial_ok: True if a DC containing a partial
            replica or a full replica will suffice, False if
            only a full replica will suffice.
        :param detect_failed: True to detect failed DCs and route
            replication traffic around them, FALSE to assume
            no DC has failed.
        :return: list of dsa object for available bridgehead DCs
        """
        bhs = []

        if transport.name != "IP":
            raise KCCError("get_all_bridgeheads has run into a "
                           "non-IP transport! %r"
                           % (transport.name,))

        DEBUG_FN(site.rw_dsa_table)
        for dsa in site.rw_dsa_table.values():

            pdnstr = dsa.get_parent_dnstr()

            # IF t!bridgeheadServerListBL has one or more values and
            # t!bridgeheadServerListBL does not contain a reference
            # to the parent object of dc then skip dc
            if ((len(transport.bridgehead_list) != 0 and
                 pdnstr not in transport.bridgehead_list)):
                continue

            # IF dc is in the same site as the local DC
            #    IF a replica of cr!nCName is not in the set of NC replicas
            #    that "should be present" on dc or a partial replica of the
            #    NC "should be present" but partialReplicasOkay = FALSE
            #        Skip dc
            if self.my_site.same_site(dsa):
                needed, ro, partial = part.should_be_present(dsa)
                if not needed or (partial and not partial_ok):
                    continue
                rep = dsa.get_current_replica(part.nc_dnstr)

            # ELSE
            #     IF an NC replica of cr!nCName is not in the set of NC
            #     replicas that "are present" on dc or a partial replica of
            #     the NC "is present" but partialReplicasOkay = FALSE
            #          Skip dc
            else:
                rep = dsa.get_current_replica(part.nc_dnstr)
                if rep is None or (rep.is_partial() and not partial_ok):
                    continue

            # IF AmIRODC() and cr!nCName corresponds to default NC then
            #     Let dsaobj be the nTDSDSA object of the dc
            #     IF  dsaobj.msDS-Behavior-Version < DS_DOMAIN_FUNCTION_2008
            #         Skip dc
            if self.my_dsa.is_ro() and rep is not None and rep.is_default():
                if not dsa.is_minimum_behavior(dsdb.DS_DOMAIN_FUNCTION_2008):
                    continue

            # IF BridgeheadDCFailed(dc!objectGUID, detectFailedDCs) = TRUE
            #     Skip dc
            if self.is_bridgehead_failed(dsa, detect_failed):
                DEBUG("bridgehead is failed")
                continue

            DEBUG_FN("found a bridgehead: %s" % dsa.dsa_dnstr)
            bhs.append(dsa)

        # IF bit NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED is set in
        # s!options
        #    SORT bhs such that all GC servers precede DCs that are not GC
        #    servers, and otherwise by ascending objectGUID
        # ELSE
        #    SORT bhs in a random order
        if site.is_random_bridgehead_disabled():
            bhs.sort(sort_dsa_by_gc_and_guid)
        else:
            random.shuffle(bhs)
        debug.DEBUG_YELLOW(bhs)
        return bhs

    def is_bridgehead_failed(self, dsa, detect_failed):
        """Determine whether a given DC is known to be in a failed state

        :param dsa: the bridgehead to test
        :param detect_failed: True to really check, False to assume no failure
        :return: True if and only if the DC should be considered failed

        Here we DEPART from the pseudo code spec which appears to be
        wrong. It says, in full:

    /***** BridgeheadDCFailed *****/
    /* Determine whether a given DC is known to be in a failed state.
     * IN: objectGUID - objectGUID of the DC's nTDSDSA object.
     * IN: detectFailedDCs - TRUE if and only failed DC detection is
     *     enabled.
     * RETURNS: TRUE if and only if the DC should be considered to be in a
     *          failed state.
     */
    BridgeheadDCFailed(IN GUID objectGUID, IN bool detectFailedDCs) : bool
    {
        IF bit NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED is set in
        the options attribute of the site settings object for the local
        DC's site
            RETURN FALSE
        ELSEIF a tuple z exists in the kCCFailedLinks or
        kCCFailedConnections variables such that z.UUIDDsa =
        objectGUID, z.FailureCount > 1, and the current time -
        z.TimeFirstFailure > 2 hours
            RETURN TRUE
        ELSE
            RETURN detectFailedDCs
        ENDIF
    }

        where you will see detectFailedDCs is not behaving as
        advertised -- it is acting as a default return code in the
        event that a failure is not detected, not a switch turning
        detection on or off. Elsewhere the documentation seems to
        concur with the comment rather than the code.
        """
        if not detect_failed:
            return False

        # NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED = 0x00000008
        # When DETECT_STALE_DISABLED, we can never know of if
        # it's in a failed state
        if self.my_site.site_options & 0x00000008:
            return False

        return self.is_stale_link_connection(dsa)

    def create_connection(self, part, rbh, rsite, transport,
                          lbh, lsite, link_opt, link_sched,
                          partial_ok, detect_failed):
        """Create an nTDSConnection object as specified if it doesn't exist.

        Part of MS-ADTS 6.2.2.3.4.5

        :param part: crossRef object for the NC to replicate.
        :param rbh: nTDSDSA object for DC to act as the
            IDL_DRSGetNCChanges server (which is in a site other
            than the local DC's site).
        :param rsite: site of the rbh
        :param transport: interSiteTransport object for the transport
            to use for replication traffic.
        :param lbh: nTDSDSA object for DC to act as the
            IDL_DRSGetNCChanges client (which is in the local DC's site).
        :param lsite: site of the lbh
        :param link_opt: Replication parameters (aggregated siteLink options,
                                                 etc.)
        :param link_sched: Schedule specifying the times at which
            to begin replicating.
        :partial_ok: True if bridgehead DCs containing partial
            replicas of the NC are acceptable.
        :param detect_failed: True to detect failed DCs and route
            replication traffic around them, FALSE to assume no DC
            has failed.
        """
        rbhs_all = self.get_all_bridgeheads(rsite, part, transport,
                                            partial_ok, False)
        rbh_table = dict((x.dsa_dnstr, x) for x in rbhs_all)

        debug.DEBUG_GREY("rbhs_all: %s %s" % (len(rbhs_all),
                                              [x.dsa_dnstr for x in rbhs_all]))

        # MS-TECH says to compute rbhs_avail but then doesn't use it
        # rbhs_avail = self.get_all_bridgeheads(rsite, part, transport,
        #                                        partial_ok, detect_failed)

        lbhs_all = self.get_all_bridgeheads(lsite, part, transport,
                                            partial_ok, False)
        if lbh.is_ro():
            lbhs_all.append(lbh)

        debug.DEBUG_GREY("lbhs_all: %s %s" % (len(lbhs_all),
                                              [x.dsa_dnstr for x in lbhs_all]))

        # MS-TECH says to compute lbhs_avail but then doesn't use it
        # lbhs_avail = self.get_all_bridgeheads(lsite, part, transport,
        #                                       partial_ok, detect_failed)

        # FOR each nTDSConnection object cn such that the parent of cn is
        # a DC in lbhsAll and cn!fromServer references a DC in rbhsAll
        for ldsa in lbhs_all:
            for cn in ldsa.connect_table.values():

                rdsa = rbh_table.get(cn.from_dnstr)
                if rdsa is None:
                    continue

                debug.DEBUG_DARK_YELLOW("rdsa is %s" % rdsa.dsa_dnstr)
                # IF bit NTDSCONN_OPT_IS_GENERATED is set in cn!options and
                # NTDSCONN_OPT_RODC_TOPOLOGY is clear in cn!options and
                # cn!transportType references t
                if ((cn.is_generated() and
                     not cn.is_rodc_topology() and
                     cn.transport_guid == transport.guid)):

                    # IF bit NTDSCONN_OPT_USER_OWNED_SCHEDULE is clear in
                    # cn!options and cn!schedule != sch
                    #     Perform an originating update to set cn!schedule to
                    #     sched
                    if ((not cn.is_user_owned_schedule() and
                         not cn.is_equivalent_schedule(link_sched))):
                        cn.schedule = link_sched
                        cn.set_modified(True)

                    # IF bits NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT and
                    # NTDSCONN_OPT_USE_NOTIFY are set in cn
                    if cn.is_override_notify_default() and \
                       cn.is_use_notify():

                        # IF bit NTDSSITELINK_OPT_USE_NOTIFY is clear in
                        # ri.Options
                        #    Perform an originating update to clear bits
                        #    NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT and
                        #    NTDSCONN_OPT_USE_NOTIFY in cn!options
                        if (link_opt & dsdb.NTDSSITELINK_OPT_USE_NOTIFY) == 0:
                            cn.options &= \
                                ~(dsdb.NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT |
                                  dsdb.NTDSCONN_OPT_USE_NOTIFY)
                            cn.set_modified(True)

                    # ELSE
                    else:

                        # IF bit NTDSSITELINK_OPT_USE_NOTIFY is set in
                        # ri.Options
                        #     Perform an originating update to set bits
                        #     NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT and
                        #     NTDSCONN_OPT_USE_NOTIFY in cn!options
                        if (link_opt & dsdb.NTDSSITELINK_OPT_USE_NOTIFY) != 0:
                            cn.options |= \
                                (dsdb.NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT |
                                 dsdb.NTDSCONN_OPT_USE_NOTIFY)
                            cn.set_modified(True)

                    # IF bit NTDSCONN_OPT_TWOWAY_SYNC is set in cn!options
                    if cn.is_twoway_sync():

                        # IF bit NTDSSITELINK_OPT_TWOWAY_SYNC is clear in
                        # ri.Options
                        #     Perform an originating update to clear bit
                        #     NTDSCONN_OPT_TWOWAY_SYNC in cn!options
                        if (link_opt & dsdb.NTDSSITELINK_OPT_TWOWAY_SYNC) == 0:
                            cn.options &= ~dsdb.NTDSCONN_OPT_TWOWAY_SYNC
                            cn.set_modified(True)

                    # ELSE
                    else:

                        # IF bit NTDSSITELINK_OPT_TWOWAY_SYNC is set in
                        # ri.Options
                        #     Perform an originating update to set bit
                        #     NTDSCONN_OPT_TWOWAY_SYNC in cn!options
                        if (link_opt & dsdb.NTDSSITELINK_OPT_TWOWAY_SYNC) != 0:
                            cn.options |= dsdb.NTDSCONN_OPT_TWOWAY_SYNC
                            cn.set_modified(True)

                    # IF bit NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION is set
                    # in cn!options
                    if cn.is_intersite_compression_disabled():

                        # IF bit NTDSSITELINK_OPT_DISABLE_COMPRESSION is clear
                        # in ri.Options
                        #     Perform an originating update to clear bit
                        #     NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION in
                        #     cn!options
                        if ((link_opt &
                             dsdb.NTDSSITELINK_OPT_DISABLE_COMPRESSION) == 0):
                            cn.options &= \
                                ~dsdb.NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION
                            cn.set_modified(True)

                    # ELSE
                    else:
                        # IF bit NTDSSITELINK_OPT_DISABLE_COMPRESSION is set in
                        # ri.Options
                        #     Perform an originating update to set bit
                        #     NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION in
                        #     cn!options
                        if ((link_opt &
                             dsdb.NTDSSITELINK_OPT_DISABLE_COMPRESSION) != 0):
                            cn.options |= \
                                dsdb.NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION
                            cn.set_modified(True)

                    # Display any modified connection
                    if self.readonly:
                        if cn.to_be_modified:
                            logger.info("TO BE MODIFIED:\n%s" % cn)

                        ldsa.commit_connections(self.samdb, ro=True)
                    else:
                        ldsa.commit_connections(self.samdb)
        # ENDFOR

        valid_connections = 0

        # FOR each nTDSConnection object cn such that cn!parent is
        # a DC in lbhsAll and cn!fromServer references a DC in rbhsAll
        for ldsa in lbhs_all:
            for cn in ldsa.connect_table.values():

                rdsa = rbh_table.get(cn.from_dnstr)
                if rdsa is None:
                    continue

                debug.DEBUG_DARK_YELLOW("round 2: rdsa is %s" % rdsa.dsa_dnstr)

                # IF (bit NTDSCONN_OPT_IS_GENERATED is clear in cn!options or
                # cn!transportType references t) and
                # NTDSCONN_OPT_RODC_TOPOLOGY is clear in cn!options
                if (((not cn.is_generated() or
                      cn.transport_guid == transport.guid) and
                     not cn.is_rodc_topology())):

                    # LET rguid be the objectGUID of the nTDSDSA object
                    # referenced by cn!fromServer
                    # LET lguid be (cn!parent)!objectGUID

                    # IF BridgeheadDCFailed(rguid, detectFailedDCs) = FALSE and
                    # BridgeheadDCFailed(lguid, detectFailedDCs) = FALSE
                    #     Increment cValidConnections by 1
                    if ((not self.is_bridgehead_failed(rdsa, detect_failed) and
                         not self.is_bridgehead_failed(ldsa, detect_failed))):
                        valid_connections += 1

                    # IF keepConnections does not contain cn!objectGUID
                    #     APPEND cn!objectGUID to keepConnections
                    self.kept_connections.add(cn)

        # ENDFOR
        debug.DEBUG_RED("valid connections %d" % valid_connections)
        DEBUG("kept_connections:\n%s" % (self.kept_connections,))
        # IF cValidConnections = 0
        if valid_connections == 0:

            # LET opt be NTDSCONN_OPT_IS_GENERATED
            opt = dsdb.NTDSCONN_OPT_IS_GENERATED

            # IF bit NTDSSITELINK_OPT_USE_NOTIFY is set in ri.Options
            #     SET bits NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT and
            #     NTDSCONN_OPT_USE_NOTIFY in opt
            if (link_opt & dsdb.NTDSSITELINK_OPT_USE_NOTIFY) != 0:
                opt |= (dsdb.NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT |
                        dsdb.NTDSCONN_OPT_USE_NOTIFY)

            # IF bit NTDSSITELINK_OPT_TWOWAY_SYNC is set in ri.Options
            #     SET bit NTDSCONN_OPT_TWOWAY_SYNC opt
            if (link_opt & dsdb.NTDSSITELINK_OPT_TWOWAY_SYNC) != 0:
                opt |= dsdb.NTDSCONN_OPT_TWOWAY_SYNC

            # IF bit NTDSSITELINK_OPT_DISABLE_COMPRESSION is set in
            # ri.Options
            #     SET bit NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION in opt
            if ((link_opt &
                 dsdb.NTDSSITELINK_OPT_DISABLE_COMPRESSION) != 0):
                opt |= dsdb.NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION

            # Perform an originating update to create a new nTDSConnection
            # object cn that is a child of lbh, cn!enabledConnection = TRUE,
            # cn!options = opt, cn!transportType is a reference to t,
            # cn!fromServer is a reference to rbh, and cn!schedule = sch
            DEBUG_FN("new connection, KCC dsa: %s" % self.my_dsa.dsa_dnstr)
            system_flags = (dsdb.SYSTEM_FLAG_CONFIG_ALLOW_RENAME |
                            dsdb.SYSTEM_FLAG_CONFIG_ALLOW_MOVE)

            cn = lbh.new_connection(opt, system_flags, transport,
                                    rbh.dsa_dnstr, link_sched)

            # Display any added connection
            if self.readonly:
                if cn.to_be_added:
                    logger.info("TO BE ADDED:\n%s" % cn)

                    lbh.commit_connections(self.samdb, ro=True)
            else:
                lbh.commit_connections(self.samdb)

            # APPEND cn!objectGUID to keepConnections
            self.kept_connections.add(cn)

    def add_transports(self, vertex, local_vertex, graph, detect_failed):
        """Build a Vertex's transport lists

        Each vertex has accept_red_red and accept_black lists that
        list what transports they accept under various conditions. The
        only transport that is ever accepted is IP, and a dummy extra
        transport called "EDGE_TYPE_ALL".

        Part of MS-ADTS 6.2.2.3.4.3 -- ColorVertices

        :param vertex: the remote vertex we are thinking about
        :param local_vertex: the vertex relating to the local site.
        :param graph: the intersite graph
        :param detect_failed: whether to detect failed links
        :return: True if some bridgeheads were not found
        """
        # The docs ([MS-ADTS] 6.2.2.3.4.3) say to use local_vertex
        # here, but using vertex seems to make more sense. That is,
        # the docs want this:
        #
        #bh = self.get_bridgehead(local_vertex.site, vertex.part, transport,
        #                         local_vertex.is_black(), detect_failed)
        #
        # TODO WHY?????

        vertex.accept_red_red = []
        vertex.accept_black = []
        found_failed = False

        if vertex in graph.connected_vertices:
            t_guid = str(self.ip_transport.guid)

            bh = self.get_bridgehead(vertex.site, vertex.part,
                                     self.ip_transport,
                                     vertex.is_black(), detect_failed)
            if bh is None:
                if vertex.site.is_rodc_site():
                    vertex.accept_red_red.append(t_guid)
                else:
                    found_failed = True
            else:
                vertex.accept_red_red.append(t_guid)
                vertex.accept_black.append(t_guid)

        # Add additional transport to ensure another run of Dijkstra
        vertex.accept_red_red.append("EDGE_TYPE_ALL")
        vertex.accept_black.append("EDGE_TYPE_ALL")

        return found_failed

    def create_connections(self, graph, part, detect_failed):
        """Create intersite NTDSConnections as needed by a partition

        Construct an NC replica graph for the NC identified by
        the given crossRef, then create any additional nTDSConnection
        objects required.

        :param graph: site graph.
        :param part: crossRef object for NC.
        :param detect_failed:  True to detect failed DCs and route
            replication traffic around them, False to assume no DC
            has failed.

        Modifies self.kept_connections by adding any connections
        deemed to be "in use".

        :return: (all_connected, found_failed_dc)
        (all_connected) True if the resulting NC replica graph
            connects all sites that need to be connected.
        (found_failed_dc) True if one or more failed DCs were
            detected.
        """
        all_connected = True
        found_failed = False

        DEBUG_FN("create_connections(): enter\n"
                 "\tpartdn=%s\n\tdetect_failed=%s" %
                 (part.nc_dnstr, detect_failed))

        # XXX - This is a highly abbreviated function from the MS-TECH
        #       ref.  It creates connections between bridgeheads to all
        #       sites that have appropriate replicas.  Thus we are not
        #       creating a minimum cost spanning tree but instead
        #       producing a fully connected tree.  This should produce
        #       a full (albeit not optimal cost) replication topology.

        my_vertex = Vertex(self.my_site, part)
        my_vertex.color_vertex()

        for v in graph.vertices:
            v.color_vertex()
            if self.add_transports(v, my_vertex, graph, detect_failed):
                found_failed = True

        # No NC replicas for this NC in the site of the local DC,
        # so no nTDSConnection objects need be created
        if my_vertex.is_white():
            return all_connected, found_failed

        edge_list, n_components = get_spanning_tree_edges(graph,
                                                          self.my_site,
                                                          label=part.partstr)

        DEBUG_FN("%s Number of components: %d" %
                 (part.nc_dnstr, n_components))
        if n_components > 1:
            all_connected = False

        # LET partialReplicaOkay be TRUE if and only if
        # localSiteVertex.Color = COLOR.BLACK
        partial_ok = my_vertex.is_black()

        # Utilize the IP transport only for now
        transport = self.ip_transport

        DEBUG("edge_list %s" % edge_list)
        for e in edge_list:
            # XXX more accurate comparison?
            if e.directed and e.vertices[0].site is self.my_site:
                continue

            if e.vertices[0].site is self.my_site:
                rsite = e.vertices[1].site
            else:
                rsite = e.vertices[0].site

            # We don't make connections to our own site as that
            # is intrasite topology generator's job
            if rsite is self.my_site:
                DEBUG("rsite is my_site")
                continue

            # Determine bridgehead server in remote site
            rbh = self.get_bridgehead(rsite, part, transport,
                                      partial_ok, detect_failed)
            if rbh is None:
                continue

            # RODC acts as an BH for itself
            # IF AmIRODC() then
            #     LET lbh be the nTDSDSA object of the local DC
            # ELSE
            #     LET lbh be the result of GetBridgeheadDC(localSiteVertex.ID,
            #     cr, t, partialReplicaOkay, detectFailedDCs)
            if self.my_dsa.is_ro():
                lsite = self.my_site
                lbh = self.my_dsa
            else:
                lsite = self.my_site
                lbh = self.get_bridgehead(lsite, part, transport,
                                          partial_ok, detect_failed)
            # TODO
            if lbh is None:
                debug.DEBUG_RED("DISASTER! lbh is None")
                return False, True

            DEBUG_FN("lsite: %s\nrsite: %s" % (lsite, rsite))
            DEBUG_FN("vertices %s" % (e.vertices,))
            debug.DEBUG_BLUE("bridgeheads\n%s\n%s\n%s" % (lbh, rbh, "-" * 70))

            sitelink = e.site_link
            if sitelink is None:
                link_opt = 0x0
                link_sched = None
            else:
                link_opt = sitelink.options
                link_sched = sitelink.schedule

            self.create_connection(part, rbh, rsite, transport,
                                   lbh, lsite, link_opt, link_sched,
                                   partial_ok, detect_failed)

        return all_connected, found_failed

    def create_intersite_connections(self):
        """Create NTDSConnections as necessary for all partitions.

        Computes an NC replica graph for each NC replica that "should be
        present" on the local DC or "is present" on any DC in the same site
        as the local DC. For each edge directed to an NC replica on such a
        DC from an NC replica on a DC in another site, the KCC creates an
        nTDSConnection object to imply that edge if one does not already
        exist.

        Modifies self.kept_connections - A set of nTDSConnection
        objects for edges that are directed
        to the local DC's site in one or more NC replica graphs.

        :return: True if spanning trees were created for all NC replica
                 graphs, otherwise False.
        """
        all_connected = True
        self.kept_connections = set()

        # LET crossRefList be the set containing each object o of class
        # crossRef such that o is a child of the CN=Partitions child of the
        # config NC

        # FOR each crossRef object cr in crossRefList
        #    IF cr!enabled has a value and is false, or if FLAG_CR_NTDS_NC
        #        is clear in cr!systemFlags, skip cr.
        #    LET g be the GRAPH return of SetupGraph()

        for part in self.part_table.values():

            if not part.is_enabled():
                continue

            if part.is_foreign():
                continue

            graph = self.setup_graph(part)

            # Create nTDSConnection objects, routing replication traffic
            # around "failed" DCs.
            found_failed = False

            connected, found_failed = self.create_connections(graph,
                                                              part, True)

            DEBUG("with detect_failed: connected %s Found failed %s" %
                  (connected, found_failed))
            if not connected:
                all_connected = False

                if found_failed:
                    # One or more failed DCs preclude use of the ideal NC
                    # replica graph. Add connections for the ideal graph.
                    self.create_connections(graph, part, False)

        return all_connected

    def intersite(self, ping):
        """Generate the inter-site KCC replica graph and nTDSConnections

        As per MS-ADTS 6.2.2.3.

        If self.readonly is False, the connections are added to self.samdb.

        Produces self.kept_connections which is a set of NTDS
        Connections that should be kept during subsequent pruning
        process.

        After this has run, all sites should be connected in a minimum
        spanning tree.

        :param ping: An oracle function of remote site availability
        :return (True or False):  (True) if the produced NC replica
            graph connects all sites that need to be connected
        """

        # Retrieve my DSA
        mydsa = self.my_dsa
        mysite = self.my_site
        all_connected = True

        DEBUG_FN("intersite(): enter")

        # Determine who is the ISTG
        if self.readonly:
            mysite.select_istg(self.samdb, mydsa, ro=True)
        else:
            mysite.select_istg(self.samdb, mydsa, ro=False)

        # Test whether local site has topology disabled
        if mysite.is_intersite_topology_disabled():
            DEBUG_FN("intersite(): exit disabled all_connected=%d" %
                     all_connected)
            return all_connected

        if not mydsa.is_istg():
            DEBUG_FN("intersite(): exit not istg all_connected=%d" %
                     all_connected)
            return all_connected

        self.merge_failed_links(ping)

        # For each NC with an NC replica that "should be present" on the
        # local DC or "is present" on any DC in the same site as the
        # local DC, the KCC constructs a site graph--a precursor to an NC
        # replica graph. The site connectivity for a site graph is defined
        # by objects of class interSiteTransport, siteLink, and
        # siteLinkBridge in the config NC.

        all_connected = self.create_intersite_connections()

        DEBUG_FN("intersite(): exit all_connected=%d" % all_connected)
        return all_connected

    # This function currently does no actions. The reason being that we cannot
    # perform modifies in this way on the RODC.
    def update_rodc_connection(self, ro=True):
        """Updates the RODC NTFRS connection object.

        If the local DSA is not an RODC, this does nothing.
        """
        if not self.my_dsa.is_ro():
            return

        # Given an nTDSConnection object cn1, such that cn1.options contains
        # NTDSCONN_OPT_RODC_TOPOLOGY, and another nTDSConnection object cn2,
        # does not contain NTDSCONN_OPT_RODC_TOPOLOGY, modify cn1 to ensure
        # that the following is true:
        #
        #     cn1.fromServer = cn2.fromServer
        #     cn1.schedule = cn2.schedule
        #
        # If no such cn2 can be found, cn1 is not modified.
        # If no such cn1 can be found, nothing is modified by this task.

        all_connections = self.my_dsa.connect_table.values()
        ro_connections = [x for x in all_connections if x.is_rodc_topology()]
        rw_connections = [x for x in all_connections
                          if x not in ro_connections]

        # XXX here we are dealing with multiple RODC_TOPO connections,
        # if they exist. It is not clear whether the spec means that
        # or if it ever arises.
        if rw_connections and ro_connections:
            for con in ro_connections:
                cn2 = rw_connections[0]
                con.from_dnstr = cn2.from_dnstr
                con.schedule = cn2.schedule
                con.to_be_modified = True

            self.my_dsa.commit_connections(self.samdb, ro=ro)

    def intrasite_max_node_edges(self, node_count):
        """Find the maximum number of edges directed to an intrasite node

        The KCC does not create more than 50 edges directed to a
        single DC. To optimize replication, we compute that each node
        should have n+2 total edges directed to it such that (n) is
        the smallest non-negative integer satisfying
        (node_count <= 2*(n*n) + 6*n + 7)

        (If the number of edges is m (i.e. n + 2), that is the same as
        2 * m*m - 2 * m + 3). We think in terms of n because that is
        the number of extra connections over the double directed ring
        that exists by default.

        edges  n   nodecount
          2    0    7
          3    1   15
          4    2   27
          5    3   43
                  ...
         50   48 4903

        :param node_count: total number of nodes in the replica graph

        The intention is that there should be no more than 3 hops
        between any two DSAs at a site. With up to 7 nodes the 2 edges
        of the ring are enough; any configuration of extra edges with
        8 nodes will be enough. It is less clear that the 3 hop
        guarantee holds at e.g. 15 nodes in degenerate cases, but
        those are quite unlikely given the extra edges are randomly
        arranged.

        :param node_count: the number of nodes in the site
        "return: The desired maximum number of connections
        """
        n = 0
        while True:
            if node_count <= (2 * (n * n) + (6 * n) + 7):
                break
            n = n + 1
        n = n + 2
        if n < 50:
            return n
        return 50

    def construct_intrasite_graph(self, site_local, dc_local,
                                  nc_x, gc_only, detect_stale):
        """Create an intrasite graph using given parameters

        This might be called a number of times per site with different
        parameters.

        Based on [MS-ADTS] 6.2.2.2

        :param site_local: site for which we are working
        :param dc_local: local DC that potentially needs a replica
        :param nc_x:  naming context (x) that we are testing if it
                    "should be present" on the local DC
        :param gc_only: Boolean - only consider global catalog servers
        :param detect_stale: Boolean - check whether links seems down
        :return: None
        """
        # We're using the MS notation names here to allow
        # correlation back to the published algorithm.
        #
        # nc_x     - naming context (x) that we are testing if it
        #            "should be present" on the local DC
        # f_of_x   - replica (f) found on a DC (s) for NC (x)
        # dc_s     - DC where f_of_x replica was found
        # dc_local - local DC that potentially needs a replica
        #            (f_of_x)
        # r_list   - replica list R
        # p_of_x   - replica (p) is partial and found on a DC (s)
        #            for NC (x)
        # l_of_x   - replica (l) is the local replica for NC (x)
        #            that should appear on the local DC
        # r_len = is length of replica list |R|
        #
        # If the DSA doesn't need a replica for this
        # partition (NC x) then continue
        needed, ro, partial = nc_x.should_be_present(dc_local)

        debug.DEBUG_YELLOW("construct_intrasite_graph(): enter" +
                           "\n\tgc_only=%d" % gc_only +
                           "\n\tdetect_stale=%d" % detect_stale +
                           "\n\tneeded=%s" % needed +
                           "\n\tro=%s" % ro +
                           "\n\tpartial=%s" % partial +
                           "\n%s" % nc_x)

        if not needed:
            debug.DEBUG_RED("%s lacks 'should be present' status, "
                            "aborting construct_intersite_graph!" %
                            nc_x.nc_dnstr)
            return

        # Create a NCReplica that matches what the local replica
        # should say.  We'll use this below in our r_list
        l_of_x = NCReplica(dc_local.dsa_dnstr, dc_local.dsa_guid,
                           nc_x.nc_dnstr)

        l_of_x.identify_by_basedn(self.samdb)

        l_of_x.rep_partial = partial
        l_of_x.rep_ro = ro

        # Add this replica that "should be present" to the
        # needed replica table for this DSA
        dc_local.add_needed_replica(l_of_x)

        # Replica list
        #
        # Let R be a sequence containing each writable replica f of x
        # such that f "is present" on a DC s satisfying the following
        # criteria:
        #
        #  * s is a writable DC other than the local DC.
        #
        #  * s is in the same site as the local DC.
        #
        #  * If x is a read-only full replica and x is a domain NC,
        #    then the DC's functional level is at least
        #    DS_BEHAVIOR_WIN2008.
        #
        #  * Bit NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED is set
        #    in the options attribute of the site settings object for
        #    the local DC's site, or no tuple z exists in the
        #    kCCFailedLinks or kCCFailedConnections variables such
        #    that z.UUIDDsa is the objectGUID of the nTDSDSA object
        #    for s, z.FailureCount > 0, and the current time -
        #    z.TimeFirstFailure > 2 hours.

        r_list = []

        # We'll loop thru all the DSAs looking for
        # writeable NC replicas that match the naming
        # context dn for (nc_x)
        #
        for dc_s in self.my_site.dsa_table.values():
            # If this partition (nc_x) doesn't appear as a
            # replica (f_of_x) on (dc_s) then continue
            if not nc_x.nc_dnstr in dc_s.current_rep_table:
                continue

            # Pull out the NCReplica (f) of (x) with the dn
            # that matches NC (x) we are examining.
            f_of_x = dc_s.current_rep_table[nc_x.nc_dnstr]

            # Replica (f) of NC (x) must be writable
            if f_of_x.is_ro():
                continue

            # Replica (f) of NC (x) must satisfy the
            # "is present" criteria for DC (s) that
            # it was found on
            if not f_of_x.is_present():
                continue

            # DC (s) must be a writable DSA other than
            # my local DC.  In other words we'd only replicate
            # from other writable DC
            if dc_s.is_ro() or dc_s is dc_local:
                continue

            # Certain replica graphs are produced only
            # for global catalogs, so test against
            # method input parameter
            if gc_only and not dc_s.is_gc():
                continue

            # DC (s) must be in the same site as the local DC
            # as this is the intra-site algorithm. This is
            # handled by virtue of placing DSAs in per
            # site objects (see enclosing for() loop)

            # If NC (x) is intended to be read-only full replica
            # for a domain NC on the target DC then the source
            # DC should have functional level at minimum WIN2008
            #
            # Effectively we're saying that in order to replicate
            # to a targeted RODC (which was introduced in Windows 2008)
            # then we have to replicate from a DC that is also minimally
            # at that level.
            #
            # You can also see this requirement in the MS special
            # considerations for RODC which state that to deploy
            # an RODC, at least one writable domain controller in
            # the domain must be running Windows Server 2008
            if ro and not partial and nc_x.nc_type == NCType.domain:
                if not dc_s.is_minimum_behavior(dsdb.DS_DOMAIN_FUNCTION_2008):
                    continue

            # If we haven't been told to turn off stale connection
            # detection and this dsa has a stale connection then
            # continue
            if detect_stale and self.is_stale_link_connection(dc_s):
                continue

            # Replica meets criteria.  Add it to table indexed
            # by the GUID of the DC that it appears on
            r_list.append(f_of_x)

        # If a partial (not full) replica of NC (x) "should be present"
        # on the local DC, append to R each partial replica (p of x)
        # such that p "is present" on a DC satisfying the same
        # criteria defined above for full replica DCs.
        #
        # XXX This loop and the previous one differ only in whether
        # the replica is partial or not. here we only accept partial
        # (because we're partial); before we only accepted full. Order
        # doen't matter (the list is sorted a few lines down) so these
        # loops could easily be merged. Or this could be a helper
        # function.

        if partial:
            # Now we loop thru all the DSAs looking for
            # partial NC replicas that match the naming
            # context dn for (NC x)
            for dc_s in self.my_site.dsa_table.values():

                # If this partition NC (x) doesn't appear as a
                # replica (p) of NC (x) on the dsa DC (s) then
                # continue
                if not nc_x.nc_dnstr in dc_s.current_rep_table:
                    continue

                # Pull out the NCReplica with the dn that
                # matches NC (x) we are examining.
                p_of_x = dc_s.current_rep_table[nc_x.nc_dnstr]

                # Replica (p) of NC (x) must be partial
                if not p_of_x.is_partial():
                    continue

                # Replica (p) of NC (x) must satisfy the
                # "is present" criteria for DC (s) that
                # it was found on
                if not p_of_x.is_present():
                    continue

                # DC (s) must be a writable DSA other than
                # my DSA.  In other words we'd only replicate
                # from other writable DSA
                if dc_s.is_ro() or dc_s is dc_local:
                    continue

                # Certain replica graphs are produced only
                # for global catalogs, so test against
                # method input parameter
                if gc_only and not dc_s.is_gc():
                    continue

                # If we haven't been told to turn off stale connection
                # detection and this dsa has a stale connection then
                # continue
                if detect_stale and self.is_stale_link_connection(dc_s):
                    continue

                # Replica meets criteria.  Add it to table indexed
                # by the GUID of the DSA that it appears on
                r_list.append(p_of_x)

        # Append to R the NC replica that "should be present"
        # on the local DC
        r_list.append(l_of_x)

        r_list.sort(sort_replica_by_dsa_guid)
        r_len = len(r_list)

        max_node_edges = self.intrasite_max_node_edges(r_len)

        # Add a node for each r_list element to the replica graph
        graph_list = []
        for rep in r_list:
            node = GraphNode(rep.rep_dsa_dnstr, max_node_edges)
            graph_list.append(node)

        # For each r(i) from (0 <= i < |R|-1)
        i = 0
        while i < (r_len-1):
            # Add an edge from r(i) to r(i+1) if r(i) is a full
            # replica or r(i+1) is a partial replica
            if not r_list[i].is_partial() or r_list[i+1].is_partial():
                graph_list[i+1].add_edge_from(r_list[i].rep_dsa_dnstr)

            # Add an edge from r(i+1) to r(i) if r(i+1) is a full
            # replica or ri is a partial replica.
            if not r_list[i+1].is_partial() or r_list[i].is_partial():
                graph_list[i].add_edge_from(r_list[i+1].rep_dsa_dnstr)
            i = i + 1

        # Add an edge from r|R|-1 to r0 if r|R|-1 is a full replica
        # or r0 is a partial replica.
        if not r_list[r_len-1].is_partial() or r_list[0].is_partial():
            graph_list[0].add_edge_from(r_list[r_len-1].rep_dsa_dnstr)

        # Add an edge from r0 to r|R|-1 if r0 is a full replica or
        # r|R|-1 is a partial replica.
        if not r_list[0].is_partial() or r_list[r_len-1].is_partial():
            graph_list[r_len-1].add_edge_from(r_list[0].rep_dsa_dnstr)

        DEBUG("r_list is length %s" % len(r_list))
        DEBUG('\n'.join(str((x.rep_dsa_guid, x.rep_dsa_dnstr))
                        for x in r_list))

        do_dot_files = self.dot_file_dir is not None and self.debug
        if self.verify or do_dot_files:
            dot_edges = []
            dot_vertices = set()
            for v1 in graph_list:
                dot_vertices.add(v1.dsa_dnstr)
                for v2 in v1.edge_from:
                    dot_edges.append((v2, v1.dsa_dnstr))
                    dot_vertices.add(v2)

            verify_properties = ('connected',)
            verify_and_dot('intrasite_pre_ntdscon', dot_edges, dot_vertices,
                           label='%s__%s__%s' % (site_local.site_dnstr,
                                                 nctype_lut[nc_x.nc_type],
                                                 nc_x.nc_dnstr),
                           properties=verify_properties, debug=DEBUG,
                           verify=self.verify,
                           dot_file_dir=self.dot_file_dir,
                           directed=True)

            rw_dot_vertices = set(x for x in dot_vertices
                                  if not self.get_dsa(x).is_ro())
            rw_dot_edges = [(a, b) for a, b in dot_edges if
                            a in rw_dot_vertices and b in rw_dot_vertices]
            rw_verify_properties = ('connected',
                                    'directed_double_ring_or_small')
            verify_and_dot('intrasite_rw_pre_ntdscon', rw_dot_edges,
                           rw_dot_vertices,
                           label='%s__%s__%s' % (site_local.site_dnstr,
                                                 nctype_lut[nc_x.nc_type],
                                                 nc_x.nc_dnstr),
                           properties=rw_verify_properties, debug=DEBUG,
                           verify=self.verify,
                           dot_file_dir=self.dot_file_dir,
                           directed=True)

        # For each existing nTDSConnection object implying an edge
        # from rj of R to ri such that j != i, an edge from rj to ri
        # is not already in the graph, and the total edges directed
        # to ri is less than n+2, the KCC adds that edge to the graph.
        for vertex in graph_list:
            dsa = self.my_site.dsa_table[vertex.dsa_dnstr]
            for connect in dsa.connect_table.values():
                remote = connect.from_dnstr
                if remote in self.my_site.dsa_table:
                    vertex.add_edge_from(remote)

        DEBUG('reps are:  %s' % '   '.join(x.rep_dsa_dnstr for x in r_list))
        DEBUG('dsas are:  %s' % '   '.join(x.dsa_dnstr for x in graph_list))

        for tnode in graph_list:
            # To optimize replication latency in sites with many NC
            # replicas, the KCC adds new edges directed to ri to bring
            # the total edges to n+2, where the NC replica rk of R
            # from which the edge is directed is chosen at random such
            # that k != i and an edge from rk to ri is not already in
            # the graph.
            #
            # Note that the KCC tech ref does not give a number for
            # the definition of "sites with many NC replicas". At a
            # bare minimum to satisfy n+2 edges directed at a node we
            # have to have at least three replicas in |R| (i.e. if n
            # is zero then at least replicas from two other graph
            # nodes may direct edges to us).
            if r_len >= 3 and not tnode.has_sufficient_edges():
                candidates = [x for x in graph_list if
                              (x is not tnode and
                               x.dsa_dnstr not in tnode.edge_from)]

                debug.DEBUG_BLUE("looking for random link for %s. r_len %d, "
                                 "graph len %d candidates %d"
                                 % (tnode.dsa_dnstr, r_len, len(graph_list),
                                    len(candidates)))

                DEBUG("candidates %s" % [x.dsa_dnstr for x in candidates])

                while candidates and not tnode.has_sufficient_edges():
                    other = random.choice(candidates)
                    DEBUG("trying to add candidate %s" % other.dsa_dnstr)
                    if not tnode.add_edge_from(other):
                        debug.DEBUG_RED("could not add %s" % other.dsa_dnstr)
                    candidates.remove(other)
            else:
                DEBUG_FN("not adding links to %s: nodes %s, links is %s/%s" %
                         (tnode.dsa_dnstr, r_len, len(tnode.edge_from),
                          tnode.max_edges))

            # Print the graph node in debug mode
            DEBUG_FN("%s" % tnode)

            # For each edge directed to the local DC, ensure a nTDSConnection
            # points to us that satisfies the KCC criteria

            if tnode.dsa_dnstr == dc_local.dsa_dnstr:
                tnode.add_connections_from_edges(dc_local, self.ip_transport)

        if self.verify or do_dot_files:
            dot_edges = []
            dot_vertices = set()
            for v1 in graph_list:
                dot_vertices.add(v1.dsa_dnstr)
                for v2 in v1.edge_from:
                    dot_edges.append((v2, v1.dsa_dnstr))
                    dot_vertices.add(v2)

            verify_properties = ('connected',)
            verify_and_dot('intrasite_post_ntdscon', dot_edges, dot_vertices,
                           label='%s__%s__%s' % (site_local.site_dnstr,
                                                 nctype_lut[nc_x.nc_type],
                                                 nc_x.nc_dnstr),
                           properties=verify_properties, debug=DEBUG,
                           verify=self.verify,
                           dot_file_dir=self.dot_file_dir,
                           directed=True)

            rw_dot_vertices = set(x for x in dot_vertices
                                  if not self.get_dsa(x).is_ro())
            rw_dot_edges = [(a, b) for a, b in dot_edges if
                            a in rw_dot_vertices and b in rw_dot_vertices]
            rw_verify_properties = ('connected',
                                    'directed_double_ring_or_small')
            verify_and_dot('intrasite_rw_post_ntdscon', rw_dot_edges,
                           rw_dot_vertices,
                           label='%s__%s__%s' % (site_local.site_dnstr,
                                                 nctype_lut[nc_x.nc_type],
                                                 nc_x.nc_dnstr),
                           properties=rw_verify_properties, debug=DEBUG,
                           verify=self.verify,
                           dot_file_dir=self.dot_file_dir,
                           directed=True)

    def intrasite(self):
        """Generate the intrasite KCC connections

        As per MS-ADTS 6.2.2.2.

        If self.readonly is False, the connections are added to self.samdb.

        After this call, all DCs in each site with more than 3 DCs
        should be connected in a bidirectional ring. If a site has 2
        DCs, they will bidirectionally connected. Sites with many DCs
        may have arbitrary extra connections.

        :return: None
        """
        mydsa = self.my_dsa

        DEBUG_FN("intrasite(): enter")

        # Test whether local site has topology disabled
        mysite = self.my_site
        if mysite.is_intrasite_topology_disabled():
            return

        detect_stale = (not mysite.is_detect_stale_disabled())
        for connect in mydsa.connect_table.values():
            if connect.to_be_added:
                debug.DEBUG_CYAN("TO BE ADDED:\n%s" % connect)

        # Loop thru all the partitions, with gc_only False
        for partdn, part in self.part_table.items():
            self.construct_intrasite_graph(mysite, mydsa, part, False,
                                           detect_stale)
            for connect in mydsa.connect_table.values():
                if connect.to_be_added:
                    debug.DEBUG_BLUE("TO BE ADDED:\n%s" % connect)

        # If the DC is a GC server, the KCC constructs an additional NC
        # replica graph (and creates nTDSConnection objects) for the
        # config NC as above, except that only NC replicas that "are present"
        # on GC servers are added to R.
        for connect in mydsa.connect_table.values():
            if connect.to_be_added:
                debug.DEBUG_YELLOW("TO BE ADDED:\n%s" % connect)

        # Do it again, with gc_only True
        for partdn, part in self.part_table.items():
            if part.is_config():
                self.construct_intrasite_graph(mysite, mydsa, part, True,
                                               detect_stale)

        # The DC repeats the NC replica graph computation and nTDSConnection
        # creation for each of the NC replica graphs, this time assuming
        # that no DC has failed. It does so by re-executing the steps as
        # if the bit NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED were
        # set in the options attribute of the site settings object for
        # the local DC's site.  (ie. we set "detec_stale" flag to False)
        for connect in mydsa.connect_table.values():
            if connect.to_be_added:
                debug.DEBUG_BLUE("TO BE ADDED:\n%s" % connect)

        # Loop thru all the partitions.
        for partdn, part in self.part_table.items():
            self.construct_intrasite_graph(mysite, mydsa, part, False,
                                           False)  # don't detect stale

        # If the DC is a GC server, the KCC constructs an additional NC
        # replica graph (and creates nTDSConnection objects) for the
        # config NC as above, except that only NC replicas that "are present"
        # on GC servers are added to R.
        for connect in mydsa.connect_table.values():
            if connect.to_be_added:
                debug.DEBUG_RED("TO BE ADDED:\n%s" % connect)

        for partdn, part in self.part_table.items():
            if part.is_config():
                self.construct_intrasite_graph(mysite, mydsa, part, True,
                                               False)  # don't detect stale

        self._commit_changes(mydsa)

    def list_dsas(self):
        """Compile a comprehensive list of DSA DNs

        These are all the DSAs on all the sites that KCC would be
        dealing with.

        This method is not idempotent and may not work correctly in
        sequence with KCC.run().

        :return: a list of DSA DN strings.
        """
        self.load_my_site()
        self.load_my_dsa()

        self.load_all_sites()
        self.load_all_partitions()
        self.load_ip_transport()
        self.load_all_sitelinks()
        dsas = []
        for site in self.site_table.values():
            dsas.extend([dsa.dsa_dnstr.replace('CN=NTDS Settings,', '', 1)
                         for dsa in site.dsa_table.values()])
        return dsas

    def load_samdb(self, dburl, lp, creds, force=False):
        """Load the database using an url, loadparm, and credentials

        If force is False, the samdb won't be reloaded if it already
        exists.

        :param dburl: a database url.
        :param lp: a loadparm object.
        :param creds: a Credentials object.
        :param force: a boolean indicating whether to overwrite.

        """
        if force or self.samdb is None:
            try:
                self.samdb = SamDB(url=dburl,
                                   session_info=system_session(),
                                   credentials=creds, lp=lp)
            except ldb.LdbError, (num, msg):
                raise KCCError("Unable to open sam database %s : %s" %
                               (dburl, msg))

    def plot_all_connections(self, basename, verify_properties=()):
        """Helper function to plot and verify NTDSConnections

        :param basename: an identifying string to use in filenames and logs.
        :param verify_properties: properties to verify (default empty)
        """
        verify = verify_properties and self.verify
        if not verify and self.dot_file_dir is None:
            return

        dot_edges = []
        dot_vertices = []
        edge_colours = []
        vertex_colours = []

        for dsa in self.dsa_by_dnstr.values():
            dot_vertices.append(dsa.dsa_dnstr)
            if dsa.is_ro():
                vertex_colours.append('#cc0000')
            else:
                vertex_colours.append('#0000cc')
            for con in dsa.connect_table.values():
                if con.is_rodc_topology():
                    edge_colours.append('red')
                else:
                    edge_colours.append('blue')
                dot_edges.append((con.from_dnstr, dsa.dsa_dnstr))

        verify_and_dot(basename, dot_edges, vertices=dot_vertices,
                       label=self.my_dsa_dnstr,
                       properties=verify_properties, debug=DEBUG,
                       verify=verify, dot_file_dir=self.dot_file_dir,
                       directed=True, edge_colors=edge_colours,
                       vertex_colors=vertex_colours)

    def run(self, dburl, lp, creds, forced_local_dsa=None,
            forget_local_links=False, forget_intersite_links=False,
            attempt_live_connections=False):
        """Perform a KCC run, possibly updating repsFrom topology

        :param dburl: url of the database to work with.
        :param lp: a loadparm object.
        :param creds: a Credentials object.
        :param forced_local_dsa: pretend to be on the DSA with this dn_str
        :param forget_local_links: calculate as if no connections existed
               (boolean, default False)
        :param forget_intersite_links: calculate with only intrasite connection
               (boolean, default False)
        :param attempt_live_connections: attempt to connect to remote DSAs to
               determine link availability (boolean, default False)
        :return: 1 on error, 0 otherwise
        """
        if self.samdb is None:
            DEBUG_FN("samdb is None; let's load it from %s" % (dburl,))
            self.load_samdb(dburl, lp, creds, force=False)

        if forced_local_dsa:
            self.samdb.set_ntds_settings_dn("CN=NTDS Settings,%s" %
                                            forced_local_dsa)

        try:
            # Setup
            self.load_my_site()
            self.load_my_dsa()

            self.load_all_sites()
            self.load_all_partitions()
            self.load_ip_transport()
            self.load_all_sitelinks()

            if self.verify or self.dot_file_dir is not None:
                guid_to_dnstr = {}
                for site in self.site_table.values():
                    guid_to_dnstr.update((str(dsa.dsa_guid), dnstr)
                                         for dnstr, dsa
                                         in site.dsa_table.items())

                self.plot_all_connections('dsa_initial')

                dot_edges = []
                current_reps, needed_reps = self.my_dsa.get_rep_tables()
                for dnstr, c_rep in current_reps.items():
                    DEBUG("c_rep %s" % c_rep)
                    dot_edges.append((self.my_dsa.dsa_dnstr, dnstr))

                verify_and_dot('dsa_repsFrom_initial', dot_edges,
                               directed=True, label=self.my_dsa_dnstr,
                               properties=(), debug=DEBUG, verify=self.verify,
                               dot_file_dir=self.dot_file_dir)

                dot_edges = []
                for site in self.site_table.values():
                    for dsa in site.dsa_table.values():
                        current_reps, needed_reps = dsa.get_rep_tables()
                        for dn_str, rep in current_reps.items():
                            for reps_from in rep.rep_repsFrom:
                                DEBUG("rep %s" % rep)
                                dsa_guid = str(reps_from.source_dsa_obj_guid)
                                dsa_dn = guid_to_dnstr[dsa_guid]
                                dot_edges.append((dsa.dsa_dnstr, dsa_dn))

                verify_and_dot('dsa_repsFrom_initial_all', dot_edges,
                               directed=True, label=self.my_dsa_dnstr,
                               properties=(), debug=DEBUG, verify=self.verify,
                               dot_file_dir=self.dot_file_dir)

                dot_edges = []
                for link in self.sitelink_table.values():
                    for a, b in itertools.combinations(link.site_list, 2):
                        dot_edges.append((str(a), str(b)))
                properties = ('connected',)
                verify_and_dot('dsa_sitelink_initial', dot_edges,
                               directed=False,
                               label=self.my_dsa_dnstr, properties=properties,
                               debug=DEBUG, verify=self.verify,
                               dot_file_dir=self.dot_file_dir)

            if forget_local_links:
                for dsa in self.my_site.dsa_table.values():
                    dsa.connect_table = dict((k, v) for k, v in
                                             dsa.connect_table.items()
                                             if v.is_rodc_topology() or
                                             (v.from_dnstr not in
                                              self.my_site.dsa_table))
                self.plot_all_connections('dsa_forgotten_local')

            if forget_intersite_links:
                for site in self.site_table.values():
                    for dsa in site.dsa_table.values():
                        dsa.connect_table = dict((k, v) for k, v in
                                                 dsa.connect_table.items()
                                                 if site is self.my_site and
                                                 v.is_rodc_topology())

                self.plot_all_connections('dsa_forgotten_all')

            if attempt_live_connections:
                # Encapsulates lp and creds in a function that
                # attempts connections to remote DSAs.
                def ping(self, dnsname):
                    try:
                        drs_utils.drsuapi_connect(dnsname, self.lp, self.creds)
                    except drs_utils.drsException:
                        return False
                    return True
            else:
                ping = None
            # These are the published steps (in order) for the
            # MS-TECH description of the KCC algorithm ([MS-ADTS] 6.2.2)

            # Step 1
            self.refresh_failed_links_connections(ping)

            # Step 2
            self.intrasite()

            # Step 3
            all_connected = self.intersite(ping)

            # Step 4
            self.remove_unneeded_ntdsconn(all_connected)

            # Step 5
            self.translate_ntdsconn()

            # Step 6
            self.remove_unneeded_failed_links_connections()

            # Step 7
            self.update_rodc_connection()

            if self.verify or self.dot_file_dir is not None:
                self.plot_all_connections('dsa_final',
                                          ('connected',))

                debug.DEBUG_MAGENTA("there are %d dsa guids" %
                                    len(guid_to_dnstr))

                dot_edges = []
                edge_colors = []
                my_dnstr = self.my_dsa.dsa_dnstr
                current_reps, needed_reps = self.my_dsa.get_rep_tables()
                for dnstr, n_rep in needed_reps.items():
                    for reps_from in n_rep.rep_repsFrom:
                        guid_str = str(reps_from.source_dsa_obj_guid)
                        dot_edges.append((my_dnstr, guid_to_dnstr[guid_str]))
                        edge_colors.append('#' + str(n_rep.nc_guid)[:6])

                verify_and_dot('dsa_repsFrom_final', dot_edges, directed=True,
                               label=self.my_dsa_dnstr,
                               properties=(), debug=DEBUG, verify=self.verify,
                               dot_file_dir=self.dot_file_dir,
                               edge_colors=edge_colors)

                dot_edges = []

                for site in self.site_table.values():
                    for dsa in site.dsa_table.values():
                        current_reps, needed_reps = dsa.get_rep_tables()
                        for n_rep in needed_reps.values():
                            for reps_from in n_rep.rep_repsFrom:
                                dsa_guid = str(reps_from.source_dsa_obj_guid)
                                dsa_dn = guid_to_dnstr[dsa_guid]
                                dot_edges.append((dsa.dsa_dnstr, dsa_dn))

                verify_and_dot('dsa_repsFrom_final_all', dot_edges,
                               directed=True, label=self.my_dsa_dnstr,
                               properties=(), debug=DEBUG, verify=self.verify,
                               dot_file_dir=self.dot_file_dir)

        except:
            raise

        return 0

    def import_ldif(self, dburl, lp, ldif_file, forced_local_dsa=None):
        """Import relevant objects and attributes from an LDIF file.

        The point of this function is to allow a programmer/debugger to
        import an LDIF file with non-security relevent information that
        was previously extracted from a DC database.  The LDIF file is used
        to create a temporary abbreviated database.  The KCC algorithm can
        then run against this abbreviated database for debug or test
        verification that the topology generated is computationally the
        same between different OSes and algorithms.

        :param dburl: path to the temporary abbreviated db to create
        :param lp: a loadparm object.
        :param ldif_file: path to the ldif file to import
        :param forced_local_dsa: perform KCC from this DSA's point of view
        :return: zero on success, 1 on error
        """
        try:
            self.samdb = ldif_import_export.ldif_to_samdb(dburl, lp, ldif_file,
                                                          forced_local_dsa)
        except ldif_import_export.LdifError, e:
            logger.critical(e)
            return 1
        return 0

    def export_ldif(self, dburl, lp, creds, ldif_file):
        """Save KCC relevant details to an ldif file

        The point of this function is to allow a programmer/debugger to
        extract an LDIF file with non-security relevent information from
        a DC database.  The LDIF file can then be used to "import" via
        the import_ldif() function this file into a temporary abbreviated
        database.  The KCC algorithm can then run against this abbreviated
        database for debug or test verification that the topology generated
        is computationally the same between different OSes and algorithms.

        :param dburl: LDAP database URL to extract info from
        :param lp: a loadparm object.
        :param cred: a Credentials object.
        :param ldif_file: output LDIF file name to create
        :return: zero on success, 1 on error
        """
        try:
            ldif_import_export.samdb_to_ldif_file(self.samdb, dburl, lp, creds,
                                                  ldif_file)
        except ldif_import_export.LdifError, e:
            logger.critical(e)
            return 1
        return 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 *  S390 version
 *    Copyright IBM Corp. 1999
 *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 *
 *  Derived from "include/asm-i386/current.h"
 */

#ifndef _S390_CURRENT_H
#define _S390_CURRENT_H

#include <asm/lowcore.h>

struct task_struct;

#define current ((struct task_struct *const)S390_lowcore.current_task)

#endif /* !(_S390_CURRENT_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *   Data definitions for channel report processing
 *    Copyright IBM Corp. 2000, 2009
 *    Author(s): Ingo Adlung <adlung@de.ibm.com>,
 *		 Martin Schwidefsky <schwidefsky@de.ibm.com>,
 *		 Cornelia Huck <cornelia.huck@de.ibm.com>,
 *		 Heiko Carstens <heiko.carstens@de.ibm.com>,
 */

#ifndef _ASM_S390_CRW_H
#define _ASM_S390_CRW_H

#include <linux/types.h>

/*
 * Channel Report Word
 */
struct crw {
	__u32 res1 :  1;   /* reserved zero */
	__u32 slct :  1;   /* solicited */
	__u32 oflw :  1;   /* overflow */
	__u32 chn  :  1;   /* chained */
	__u32 rsc  :  4;   /* reporting source code */
	__u32 anc  :  1;   /* ancillary report */
	__u32 res2 :  1;   /* reserved zero */
	__u32 erc  :  6;   /* error-recovery code */
	__u32 rsid : 16;   /* reporting-source ID */
} __attribute__ ((packed));

typedef void (*crw_handler_t)(struct crw *, struct crw *, int);

extern int crw_register_handler(int rsc, crw_handler_t handler);
extern void crw_unregister_handler(int rsc);
extern void crw_handle_channel_report(void);
void crw_wait_for_channel_report(void);

#define NR_RSCS 16

#define CRW_RSC_MONITOR  0x2  /* monitoring facility */
#define CRW_RSC_SCH	 0x3  /* subchannel */
#define CRW_RSC_CPATH	 0x4  /* channel path */
#define CRW_RSC_CONFIG	 0x9  /* configuration-alert facility */
#define CRW_RSC_CSS	 0xB  /* channel subsystem */

#define CRW_ERC_EVENT	 0x00 /* event information pending */
#define CRW_ERC_AVAIL	 0x01 /* available */
#define CRW_ERC_INIT	 0x02 /* initialized */
#define CRW_ERC_TERROR	 0x03 /* temporary error */
#define CRW_ERC_IPARM	 0x04 /* installed parm initialized */
#define CRW_ERC_TERM	 0x05 /* terminal */
#define CRW_ERC_PERRN	 0x06 /* perm. error, fac. not init */
#define CRW_ERC_PERRI	 0x07 /* perm. error, facility init */
#define CRW_ERC_PMOD	 0x08 /* installed parameters modified */

#endif /* _ASM_S390_CRW_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright IBM Corp. 1999, 2009
 *
 * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
 */

#ifndef __ASM_CTL_REG_H
#define __ASM_CTL_REG_H

#include <linux/bug.h>

#define __ctl_load(array, low, high) {					\
	typedef struct { char _[sizeof(array)]; } addrtype;		\
									\
	BUILD_BUG_ON(sizeof(addrtype) != (high - low + 1) * sizeof(long));\
	asm volatile(							\
		"	lctlg	%1,%2,%0\n"				\
		:							\
		: "Q" (*(addrtype *)(&array)), "i" (low), "i" (high)	\
		: "memory");						\
}

#define __ctl_store(array, low, high) {					\
	typedef struct { char _[sizeof(array)]; } addrtype;		\
									\
	BUILD_BUG_ON(sizeof(addrtype) != (high - low + 1) * sizeof(long));\
	asm volatile(							\
		"	stctg	%1,%2,%0\n"				\
		: "=Q" (*(addrtype *)(&array))				\
		: "i" (low), "i" (high));				\
}

static inline void __ctl_set_bit(unsigned int cr, unsigned int bit)
{
	unsigned long reg;

	__ctl_store(reg, cr, cr);
	reg |= 1UL << bit;
	__ctl_load(reg, cr, cr);
}

static inline void __ctl_clear_bit(unsigned int cr, unsigned int bit)
{
	unsigned long reg;

	__ctl_store(reg, cr, cr);
	reg &= ~(1UL << bit);
	__ctl_load(reg, cr, cr);
}

void smp_ctl_set_bit(int cr, int bit);
void smp_ctl_clear_bit(int cr, int bit);

union ctlreg0 {
	unsigned long val;
	struct {
		unsigned long	   : 32;
		unsigned long	   : 3;
		unsigned long lap  : 1; /* Low-address-protection control */
		unsigned long	   : 4;
		unsigned long edat : 1; /* Enhanced-DAT-enablement control */
		unsigned long	   : 4;
		unsigned long afp  : 1; /* AFP-register control */
		unsigned long vx   : 1; /* Vector enablement control */
		unsigned long	   : 17;
	};
};

#ifdef CONFIG_SMP
# define ctl_set_bit(cr, bit) smp_ctl_set_bit(cr, bit)
# define ctl_clear_bit(cr, bit) smp_ctl_clear_bit(cr, bit)
#else
# define ctl_set_bit(cr, bit) __ctl_set_bit(cr, bit)
# define ctl_clear_bit(cr, bit) __ctl_clear_bit(cr, bit)
#endif

#endif /* __ASM_CTL_REG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          