/*
 * Copyright 2010 Tilera Corporation. All Rights Reserved.
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License
 *   as published by the Free Software Foundation, version 2.
 *
 *   This program is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
 *   NON INFRINGEMENT.  See the GNU General Public License for
 *   more details.
 */

/**
 * @file hypervisor.h
 * The hypervisor's public API.
 */

#ifndef _HV_HV_H
#define _HV_HV_H

#include <arch/chip.h>

/* Linux builds want unsigned long constants, but assembler wants numbers */
#ifdef __ASSEMBLER__
/** One, for assembler */
#define __HV_SIZE_ONE 1
#elif !defined(__tile__) && CHIP_VA_WIDTH() > 32
/** One, for 64-bit on host */
#define __HV_SIZE_ONE 1ULL
#else
/** One, for Linux */
#define __HV_SIZE_ONE 1UL
#endif

/** The log2 of the span of a level-1 page table, in bytes.
 */
#define HV_LOG2_L1_SPAN 32

/** The span of a level-1 page table, in bytes.
 */
#define HV_L1_SPAN (__HV_SIZE_ONE << HV_LOG2_L1_SPAN)

/** The log2 of the initial size of small pages, in bytes.
 * See HV_DEFAULT_PAGE_SIZE_SMALL.
 */
#define HV_LOG2_DEFAULT_PAGE_SIZE_SMALL 16

/** The initial size of small pages, in bytes. This value should be verified
 * at runtime by calling hv_sysconf(HV_SYSCONF_PAGE_SIZE_SMALL).
 * It may also be modified when installing a new context.
 */
#define HV_DEFAULT_PAGE_SIZE_SMALL \
  (__HV_SIZE_ONE << HV_LOG2_DEFAULT_PAGE_SIZE_SMALL)

/** The log2 of the initial size of large pages, in bytes.
 * See HV_DEFAULT_PAGE_SIZE_LARGE.
 */
#define HV_LOG2_DEFAULT_PAGE_SIZE_LARGE 24

/** The initial size of large pages, in bytes. This value should be verified
 * at runtime by calling hv_sysconf(HV_SYSCONF_PAGE_SIZE_LARGE).
 * It may also be modified when installing a new context.
 */
#define HV_DEFAULT_PAGE_SIZE_LARGE \
  (__HV_SIZE_ONE << HV_LOG2_DEFAULT_PAGE_SIZE_LARGE)

#if CHIP_VA_WIDTH() > 32

/** The log2 of the initial size of jumbo pages, in bytes.
 * See HV_DEFAULT_PAGE_SIZE_JUMBO.
 */
#define HV_LOG2_DEFAULT_PAGE_SIZE_JUMBO 32

/** The initial size of jumbo pages, in bytes. This value should
 * be verified at runtime by calling hv_sysconf(HV_SYSCONF_PAGE_SIZE_JUMBO).
 * It may also be modified when installing a new context.
 */
#define HV_DEFAULT_PAGE_SIZE_JUMBO \
  (__HV_SIZE_ONE << HV_LOG2_DEFAULT_PAGE_SIZE_JUMBO)

#endif

/** The log2 of the granularity at which page tables must be aligned;
 *  in other words, the CPA for a page table must have this many zero
 *  bits at the bottom of the address.
 */
#define HV_LOG2_PAGE_TABLE_ALIGN 11

/** The granularity at which page tables must be aligned.
 */
#define HV_PAGE_TABLE_ALIGN (__HV_SIZE_ONE << HV_LOG2_PAGE_TABLE_ALIGN)

/** Normal start of hypervisor glue in client physical memory. */
#define HV_GLUE_START_CPA 0x10000

/** This much space is reserved at HV_GLUE_START_CPA
 * for the hypervisor glue. The client program must start at
 * some address higher than this, and in particular the address of
 * its text section should be equal to zero modulo HV_PAGE_SIZE_LARGE
 * so that relative offsets to the HV glue are correct.
 */
#define HV_GLUE_RESERVED_SIZE 0x10000

/** Each entry in the hv dispatch array takes this many bytes. */
#define HV_DISPATCH_ENTRY_SIZE 32

/** Version of the hypervisor interface defined by this file */
#define _HV_VERSION 13

/** Last version of the hypervisor interface with old hv_init() ABI.
 *
 * The change from version 12 to version 13 corresponds to launching
 * the client by default at PL2 instead of PL1 (corresponding to the
 * hv itself running at PL3 instead of PL2).  To make this explicit,
 * the hv_init() API was also extended so the client can report its
 * desired PL, resulting in a more helpful failure diagnostic.  If you
 * call hv_init() with _HV_VERSION_OLD_HV_INIT and omit the client_pl
 * argument, the hypervisor will assume client_pl = 1.
 *
 * Note that this is a deprecated solution and we do not expect to
 * support clients of the Tilera hypervisor running at PL1 indefinitely.
 */
#define _HV_VERSION_OLD_HV_INIT 12

/* Index into hypervisor interface dispatch code blocks.
 *
 * Hypervisor calls are invoked from user space by calling code
 * at an address HV_BASE_ADDRESS + (index) * HV_DISPATCH_ENTRY_SIZE,
 * where index is one of these enum values.
 *
 * Normally a supervisor is expected to produce a set of symbols
 * starting at HV_BASE_ADDRESS that obey this convention, but a user
 * program could call directly through function pointers if desired.
 *
 * These numbers are part of the binary API and will not be changed
 * without updating HV_VERSION, which should be a rare event.
 */

/** reserved. */
#define _HV_DISPATCH_RESERVED                     0

/** hv_init  */
#define HV_DISPATCH_INIT                          1

/** hv_install_context */
#define HV_DISPATCH_INSTALL_CONTEXT               2

/** hv_sysconf */
#define HV_DISPATCH_SYSCONF                       3

/** hv_get_rtc */
#define HV_DISPATCH_GET_RTC                       4

/** hv_set_rtc */
#define HV_DISPATCH_SET_RTC                       5

/** hv_flush_asid */
#define HV_DISPATCH_FLUSH_ASID                    6

/** hv_flush_page */
#define HV_DISPATCH_FLUSH_PAGE                    7

/** hv_flush_pages */
#define HV_DISPATCH_FLUSH_PAGES                   8

/** hv_restart */
#define HV_DISPATCH_RESTART                       9

/** hv_halt */
#define HV_DISPATCH_HALT                          10

/** hv_power_off */
#define HV_DISPATCH_POWER_OFF                     11

/** hv_inquire_physical */
#define HV_DISPATCH_INQUIRE_PHYSICAL              12

/** hv_inquire_memory_controller */
#define HV_DISPATCH_INQUIRE_MEMORY_CONTROLLER     13

/** hv_inquire_virtual */
#define HV_DISPATCH_INQUIRE_VIRTUAL               14

/** hv_inquire_asid */
#define HV_DISPATCH_INQUIRE_ASID                  15

/** hv_nanosleep */
#define HV_DISPATCH_NANOSLEEP                     16

/** hv_console_read_if_ready */
#define HV_DISPATCH_CONSOLE_READ_IF_READY         17

/** hv_console_write */
#define HV_DISPATCH_CONSOLE_WRITE                 18

/** hv_downcall_dispatch */
#define HV_DISPATCH_DOWNCALL_DISPATCH             19

/** hv_inquire_topology */
#define HV_DISPATCH_INQUIRE_TOPOLOGY              20

/** hv_fs_findfile */
#define HV_DISPATCH_FS_FINDFILE                   21

/** hv_fs_fstat */
#define HV_DISPATCH_FS_FSTAT                      22

/** hv_fs_pread */
#define HV_DISPATCH_FS_PREAD                      23

/** hv_physaddr_read64 */
#define HV_DISPATCH_PHYSADDR_READ64               24

/** hv_physaddr_write64 */
#define HV_DISPATCH_PHYSADDR_WRITE64              25

/** hv_get_command_line */
#define HV_DISPATCH_GET_COMMAND_LINE              26

/** hv_set_caching */
#define HV_DISPATCH_SET_CACHING                   27

/** hv_bzero_page */
#define HV_DISPATCH_BZERO_PAGE                    28

/** hv_register_message_state */
#define HV_DISPATCH_REGISTER_MESSAGE_STATE        29

/** hv_send_message */
#define HV_DISPATCH_SEND_MESSAGE                  30

/** hv_receive_message */
#define HV_DISPATCH_RECEIVE_MESSAGE               31

/** hv_inquire_context */
#define HV_DISPATCH_INQUIRE_CONTEXT               32

/** hv_start_all_tiles */
#define HV_DISPATCH_START_ALL_TILES               33

/** hv_dev_open */
#define HV_DISPATCH_DEV_OPEN                      34

/** hv_dev_close */
#define HV_DISPATCH_DEV_CLOSE                     35

/** hv_dev_pread */
#define HV_DISPATCH_DEV_PREAD                     36

/** hv_dev_pwrite */
#define HV_DISPATCH_DEV_PWRITE                    37

/** hv_dev_poll */
#define HV_DISPATCH_DEV_POLL                      38

/** hv_dev_poll_cancel */
#define HV_DISPATCH_DEV_POLL_CANCEL               39

/** hv_dev_preada */
#define HV_DISPATCH_DEV_PREADA                    40

/** hv_dev_pwritea */
#define HV_DISPATCH_DEV_PWRITEA                   41

/** hv_flush_remote */
#define HV_DISPATCH_FLUSH_REMOTE                  42

/** hv_console_putc */
#define HV_DISPATCH_CONSOLE_PUTC                  43

/** hv_inquire_tiles */
#define HV_DISPATCH_INQUIRE_TILES                 44

/** hv_confstr */
#define HV_DISPATCH_CONFSTR                       45

/** hv_reexec */
#define HV_DISPATCH_REEXEC                        46

/** hv_set_command_line */
#define HV_DISPATCH_SET_COMMAND_LINE              47

#if !CHIP_HAS_IPI()

/** hv_clear_intr */
#define HV_DISPATCH_CLEAR_INTR                    48

/** hv_enable_intr */
#define HV_DISPATCH_ENABLE_INTR                   49

/** hv_disable_intr */
#define HV_DISPATCH_DISABLE_INTR                  50

/** hv_raise_intr */
#define HV_DISPATCH_RAISE_INTR                    51

/** hv_trigger_ipi */
#define HV_DISPATCH_TRIGGER_IPI                   52

#endif /* !CHIP_HAS_IPI() */

/** hv_store_mapping */
#define HV_DISPATCH_STORE_MAPPING                 53

/** hv_inquire_realpa */
#define HV_DISPATCH_INQUIRE_REALPA                54

/** hv_flush_all */
#define HV_DISPATCH_FLUSH_ALL                     55

#if CHIP_HAS_IPI()
/** hv_get_ipi_pte */
#define HV_DISPATCH_GET_IPI_PTE                   56
#endif

/** hv_set_pte_super_shift */
#define HV_DISPATCH_SET_PTE_SUPER_SHIFT           57

/** hv_console_set_ipi */
#define HV_DISPATCH_CONSOLE_SET_IPI               63

/** hv_send_nmi */
#define HV_DISPATCH_SEND_NMI                      65

/** One more than the largest dispatch value */
#define _HV_DISPATCH_END                          66


#ifndef __ASSEMBLER__

#ifdef __KERNEL__
#include <asm/types.h>
typedef u32 __hv32;        /**< 32-bit value */
typedef u64 __hv64;        /**< 64-bit value */
#else
#include <stdint.h>
typedef uint32_t __hv32;   /**< 32-bit value */
typedef uint64_t __hv64;   /**< 64-bit value */
#endif


/** Hypervisor physical address. */
typedef __hv64 HV_PhysAddr;

#if CHIP_VA_WIDTH() > 32
/** Hypervisor virtual address. */
typedef __hv64 HV_VirtAddr;
#else
/** Hypervisor virtual address. */
typedef __hv32 HV_VirtAddr;
#endif /* CHIP_VA_WIDTH() > 32 */

/** Hypervisor ASID. */
typedef unsigned int HV_ASID;

/** Hypervisor tile location for a memory access
 * ("location overridden target").
 */
typedef unsigned int HV_LOTAR;

/** Hypervisor size of a page. */
typedef unsigned long HV_PageSize;

/** A page table entry.
 */
typedef struct
{
  __hv64 val;                /**< Value of PTE */
} HV_PTE;

/** Hypervisor error code. */
typedef int HV_Errno;

#endif /* !__ASSEMBLER__ */

#define HV_OK           0    /**< No error */
#define HV_EINVAL      -801  /**< Invalid argument */
#define HV_ENODEV      -802  /**< No such device */
#define HV_ENOENT      -803  /**< No such file or directory */
#define HV_EBADF       -804  /**< Bad file number */
#define HV_EFAULT      -805  /**< Bad address */
#define HV_ERECIP      -806  /**< Bad recipients */
#define HV_E2BIG       -807  /**< Message too big */
#define HV_ENOTSUP     -808  /**< Service not supported */
#define HV_EBUSY       -809  /**< Device busy */
#define HV_ENOSYS      -810  /**< Invalid syscall */
#define HV_EPERM       -811  /**< No permission */
#define HV_ENOTREADY   -812  /**< Device not ready */
#define HV_EIO         -813  /**< I/O error */
#define HV_ENOMEM      -814  /**< Out of memory */
#define HV_EAGAIN      -815  /**< Try again */

#define HV_ERR_MAX     -801  /**< Largest HV error code */
#define HV_ERR_MIN     -815  /**< Smallest HV error code */

#ifndef __ASSEMBLER__

/** Pass HV_VERSION to hv_init to request this version of the interface. */
typedef enum {
  HV_VERSION = _HV_VERSION,
  HV_VERSION_OLD_HV_INIT = _HV_VERSION_OLD_HV_INIT,

} HV_VersionNumber;

/** Initializes the hypervisor.
 *
 * @param interface_version_number The version of the hypervisor interface
 * that this program expects, typically HV_VERSION.
 * @param chip_num Architecture number of the chip the client was built for.
 * @param chip_rev_num Revision number of the chip the client was built for.
 * @param client_pl Privilege level the client is built for
 *   (not required if interface_version_number == HV_VERSION_OLD_HV_INIT).
 */
void hv_init(HV_VersionNumber interface_version_number,
             int chip_num, int chip_rev_num, int client_pl);


/** Queries we can make for hv_sysconf().
 *
 * These numbers are part of the binary API and guaranteed not to change.
 */
typedef enum {
  /** An invalid value; do not use. */
  _HV_SYSCONF_RESERVED       = 0,

  /** The length of the glue section containing the hv_ procs, in bytes. */
  HV_SYSCONF_GLUE_SIZE       = 1,

  /** The size of small pages, in bytes. */
  HV_SYSCONF_PAGE_SIZE_SMALL = 2,

  /** The size of large pages, in bytes. */
  HV_SYSCONF_PAGE_SIZE_LARGE = 3,

  /** Processor clock speed, in hertz. */
  HV_SYSCONF_CPU_SPEED       = 4,

  /** Processor temperature, in degrees Kelvin.  The value
   *  HV_SYSCONF_TEMP_KTOC may be subtracted from this to get degrees
   *  Celsius.  If that Celsius value is HV_SYSCONF_OVERTEMP, this indicates
   *  that the temperature has hit an upper limit and is no longer being
   *  accurately tracked.
   */
  HV_SYSCONF_CPU_TEMP        = 5,

  /** Board temperature, in degrees Kelvin.  The value
   *  HV_SYSCONF_TEMP_KTOC may be subtracted from this to get degrees
   *  Celsius.  If that Celsius value is HV_SYSCONF_OVERTEMP, this indicates
   *  that the temperature has hit an upper limit and is no longer being
   *  accurately tracked.
   */
  HV_SYSCONF_BOARD_TEMP      = 6,

  /** Legal page size bitmask for hv_install_context().
   * For example, if 16KB and 64KB small pages are supported,
   * it would return "HV_CTX_PG_SM_16K | HV_CTX_PG_SM_64K".
   */
  HV_SYSCONF_VALID_PAGE_SIZES = 7,

  /** The size of jumbo pages, in bytes.
   * If no jumbo pages are available, zero will be returned.
   */
  HV_SYSCONF_PAGE_SIZE_JUMBO = 8,

} HV_SysconfQuery;

/** Offset to subtract from returned Kelvin temperature to get degrees
    Celsius. */
#define HV_SYSCONF_TEMP_KTOC 273

/** Pseudo-temperature value indicating that the temperature has
 *  pegged at its upper limit and is no longer accurate; note that this is
 *  the value after subtracting HV_SYSCONF_TEMP_KTOC. */
#define HV_SYSCONF_OVERTEMP 999

/** Query a configuration value from the hypervisor.
 * @param query Which value is requested (HV_SYSCONF_xxx).
 * @return The requested value, or -1 the requested value is illegal or
 *         unavailable.
 */
long hv_sysconf(HV_SysconfQuery query);


/** Queries we can make for hv_confstr().
 *
 * These numbers are part of the binary API and guaranteed not to change.
 */
typedef enum {
  /** An invalid value; do not use. */
  _HV_CONFSTR_RESERVED        = 0,

  /** Board part number. */
  HV_CONFSTR_BOARD_PART_NUM   = 1,

  /** Board serial number. */
  HV_CONFSTR_BOARD_SERIAL_NUM = 2,

  /** Chip serial number. */
  HV_CONFSTR_CHIP_SERIAL_NUM  = 3,

  /** Board revision level. */
  HV_CONFSTR_BOARD_REV        = 4,

  /** Hypervisor software version. */
  HV_CONFSTR_HV_SW_VER        = 5,

  /** The name for this chip model. */
  HV_CONFSTR_CHIP_MODEL       = 6,

  /** Human-readable board description. */
  HV_CONFSTR_BOARD_DESC       = 7,

  /** Human-readable description of the hypervisor configuration. */
  HV_CONFSTR_HV_CONFIG        = 8,

  /** Human-readable version string for the boot image (for instance,
   *  who built it and when, what configuration file was used). */
  HV_CONFSTR_HV_CONFIG_VER    = 9,

  /** Mezzanine part number. */
  HV_CONFSTR_MEZZ_PART_NUM   = 10,

  /** Mezzanine serial number. */
  HV_CONFSTR_MEZZ_SERIAL_NUM = 11,

  /** Mezzanine revision level. */
  HV_CONFSTR_MEZZ_REV        = 12,

  /** Human-readable mezzanine description. */
  HV_CONFSTR_MEZZ_DESC       = 13,

  /** Control path for the onboard network switch. */
  HV_CONFSTR_SWITCH_CONTROL  = 14,

  /** Chip revision level. */
  HV_CONFSTR_CHIP_REV        = 15,

  /** CPU module part number. */
  HV_CONFSTR_CPUMOD_PART_NUM = 16,

  /** CPU module serial number. */
  HV_CONFSTR_CPUMOD_SERIAL_NUM = 17,

  /** CPU module revision level. */
  HV_CONFSTR_CPUMOD_REV      = 18,

  /** Human-readable CPU module description. */
  HV_CONFSTR_CPUMOD_DESC     = 19,

  /** Per-tile hypervisor statistics.  When this identifier is specified,
   *  the hv_confstr call takes two extra arguments.  The first is the
   *  HV_XY_TO_LOTAR of the target tile's coordinates.  The second is
   *  a flag word.  The only current flag is the lowest bit, which means
   *  "zero out the stats instead of retrieving them"; in this case the
   *  buffer and buffer length are ignored. */
  HV_CONFSTR_HV_STATS        = 20

} HV_ConfstrQuery;

/** Query a configuration string from the hypervisor.
 *
 * @param query Identifier for the specific string to be retrieved
 *        (HV_CONFSTR_xxx).  Some strings may require or permit extra
 *        arguments to be appended which select specific objects to be
 *        described; see the string descriptions above.
 * @param buf Buffer in which to place the string.
 * @param len Length of the buffer.
 * @return If query is valid, then the length of the corresponding string,
 *        including the trailing null; if this is greater than len, the string
 *        was truncated.  If query is invalid, HV_EINVAL.  If the specified
 *        buffer is not writable by the client, HV_EFAULT.
 */
int hv_confstr(HV_ConfstrQuery query, HV_VirtAddr buf, int len, ...);

/** Tile coordinate */
typedef struct
{
  /** X coordinate, relative to supervisor's top-left coordinate */
  int x;

  /** Y coordinate, relative to supervisor's top-left coordinate */
  int y;
} HV_Coord;


#if CHIP_HAS_IPI()

/** Get the PTE for sending an IPI to a particular tile.
 *
 * @param tile Tile which will receive the IPI.
 * @param pl Indicates which IPI registers: 0 = IPI_0, 1 = IPI_1.
 * @param pte Filled with resulting PTE.
 * @result Zero if no error, non-zero for invalid parameters.
 */
int hv_get_ipi_pte(HV_Coord tile, int pl, HV_PTE* pte);

/** Configure the console interrupt.
 *
 * When the console client interrupt is enabled, the hypervisor will
 * deliver the specified IPI to the client in the following situations:
 *
 * - The console has at least one character available for input.
 *
 * - The console can accept new characters for output, and the last call
 *   to hv_console_write() did not write all of the characters requested
 *   by the client.
 *
 * Note that in some system configurations, console interrupt will not
 * be available; clients should be prepared for this routine to fail and
 * to fall back to periodic console polling in that case.
 *
 * @param ipi Index of the IPI register which will receive the interrupt.
 * @param event IPI event number for console interrupt. If less than 0,
 *        disable the console IPI interrupt.
 * @param coord Tile to be targeted for console interrupt.
 * @return 0 on success, otherwise, HV_EINVAL if illegal parameter,
 *         HV_ENOTSUP if console interrupt are not available.
 */
int hv_console_set_ipi(int ipi, int event, HV_Coord coord);

#else /* !CHIP_HAS_IPI() */

/** A set of interrupts. */
typedef __hv32 HV_IntrMask;

/** The low interrupt numbers are reserved for use by the client in
 *  delivering IPIs.  Any interrupt numbers higher than this value are
 *  reserved for use by HV device drivers. */
#define HV_MAX_IPI_INTERRUPT 7

/** Enable a set of device interrupts.
 *
 * @param enab_mask Bitmap of interrupts to enable.
 */
void hv_enable_intr(HV_IntrMask enab_mask);

/** Disable a set of device interrupts.
 *
 * @param disab_mask Bitmap of interrupts to disable.
 */
void hv_disable_intr(HV_IntrMask disab_mask);

/** Clear a set of device interrupts.
 *
 * @param clear_mask Bitmap of interrupts to clear.
 */
void hv_clear_intr(HV_IntrMask clear_mask);

/** Raise a set of device interrupts.
 *
 * @param raise_mask Bitmap of interrupts to raise.
 */
void hv_raise_intr(HV_IntrMask raise_mask);

/** Trigger a one-shot interrupt on some tile
 *
 * @param tile Which tile to interrupt.
 * @param interrupt Interrupt number to trigger; must be between 0 and
 *        HV_MAX_IPI_INTERRUPT.
 * @return HV_OK on success, or a hypervisor error code.
 */
HV_Errno hv_trigger_ipi(HV_Coord tile, int interrupt);

#endif /* !CHIP_HAS_IPI() */

/** Store memory mapping in debug memory so that external debugger can read it.
 * A maximum of 16 entries can be stored.
 *
 * @param va VA of memory that is mapped.
 * @param len Length of mapped memory.
 * @param pa PA of memory that is mapped.
 * @return 0 on success, -1 if the maximum number of mappings is exceeded.
 */
int hv_store_mapping(HV_VirtAddr va, unsigned int len, HV_PhysAddr pa);

/** Given a client PA and a length, return its real (HV) PA.
 *
 * @param cpa Client physical address.
 * @param len Length of mapped memory.
 * @return physical address, or -1 if cpa or len is not valid.
 */
HV_PhysAddr hv_inquire_realpa(HV_PhysAddr cpa, unsigned int len);

/** RTC return flag for no RTC chip present.
 */
#define HV_RTC_NO_CHIP     0x1

/** RTC return flag for low-voltage condition, indicating that battery had
 * died and time read is unreliable.
 */
#define HV_RTC_LOW_VOLTAGE 0x2

/** Date/Time of day */
typedef struct {
#if CHIP_WORD_SIZE() > 32
  __hv64 tm_sec;   /**< Seconds, 0-59 */
  __hv64 tm_min;   /**< Minutes, 0-59 */
  __hv64 tm_hour;  /**< Hours, 0-23 */
  __hv64 tm_mday;  /**< Day of month, 0-30 */
  __hv64 tm_mon;   /**< Month, 0-11 */
  __hv64 tm_year;  /**< Years since 1900, 0-199 */
  __hv64 flags;    /**< Return flags, 0 if no error */
#else
  __hv32 tm_sec;   /**< Seconds, 0-59 */
  __hv32 tm_min;   /**< Minutes, 0-59 */
  __hv32 tm_hour;  /**< Hours, 0-23 */
  __hv32 tm_mday;  /**< Day of month, 0-30 */
  __hv32 tm_mon;   /**< Month, 0-11 */
  __hv32 tm_year;  /**< Years since 1900, 0-199 */
  __hv32 flags;    /**< Return flags, 0 if no error */
#endif
} HV_RTCTime;

/** Read the current time-of-day clock.
 * @return HV_RTCTime of current time (GMT).
 */
HV_RTCTime hv_get_rtc(void);


/** Set the current time-of-day clock.
 * @param time time to reset time-of-day to (GMT).
 */
void hv_set_rtc(HV_RTCTime time);

/** Installs a context, comprising a page table and other attributes.
 *
 *  Once this service completes, page_table will be used to translate
 *  subsequent virtual address references to physical memory.
 *
 *  Installing a context does not cause an implicit TLB flush.  Before
 *  reusing an ASID value for a different address space, the client is
 *  expected to flush old references from the TLB with hv_flush_asid().
 *  (Alternately, hv_flush_all() may be used to flush many ASIDs at once.)
 *  After invalidating a page table entry, changing its attributes, or
 *  changing its target CPA, the client is expected to flush old references
 *  from the TLB with hv_flush_page() or hv_flush_pages(). Making a
 *  previously invalid page valid does not require a flush.
 *
 *  Specifying an invalid ASID, or an invalid CPA (client physical address)
 *  (either as page_table_pointer, or within the referenced table),
 *  or another page table data item documented as above as illegal may
 *  lead to client termination; since the validation of the table is
 *  done as needed, this may happen before the service returns, or at
 *  some later time, or never, depending upon the client's pattern of
 *  memory references.  Page table entries which supply translations for
 *  invalid virtual addresses may result in client termination, or may
 *  be silently ignored.  "Invalid" in this context means a value which
 *  was not provided to the client via the appropriate hv_inquire_* routine.
 *
 *  To support changing the instruction VAs at the same time as
 *  installing the new page table, this call explicitly supports
 *  setting the "lr" register to a different address and then jumping
 *  directly to the hv_install_context() routine.  In this case, the
 *  new page table does not need to contain any mapping for the
 *  hv_install_context address itself.
 *
 *  At most one HV_CTX_PG_SM_* flag may be specified in "flags";
 *  if multiple flags are specified, HV_EINVAL is returned.
 *  Specifying none of the flags results in using the default page size.
 *  All cores participating in a given client must request the same
 *  page size, or the results are undefined.
 *
 * @param page_table Root of the page table.
 * @param access PTE providing info on how to read the page table.  This
 *   value must be consistent between multiple tiles sharing a page table,
 *   and must also be consistent with any virtual mappings the client
 *   may be using to access the page table.
 * @param asid HV_ASID the page table is to be used for.
 * @param flags Context flags, denoting attributes or privileges of the
 *   current context (HV_CTX_xxx).
 * @return Zero on success, or a hypervisor error code on failure.
 */
int hv_install_context(HV_PhysAddr page_table, HV_PTE access, HV_ASID asid,
                       __hv32 flags);

#endif /* !__ASSEMBLER__ */

#define HV_CTX_DIRECTIO     0x1   /**< Direct I/O requests are accepted from
                                       PL0. */

#define HV_CTX_PG_SM_4K     0x10  /**< Use 4K small pages, if available. */
#define HV_CTX_PG_SM_16K    0x20  /**< Use 16K small pages, if available. */
#define HV_CTX_PG_SM_64K    0x40  /**< Use 64K small pages, if available. */
#define HV_CTX_PG_SM_MASK   0xf0  /**< Mask of all possible small pages. */

#ifndef __ASSEMBLER__


/** Set the number of pages ganged together by HV_PTE_SUPER at a
 * particular level of the page table.
 *
 * The current TILE-Gx hardware only supports powers of four
 * (i.e. log2_count must be a multiple of two), and the requested
 * "super" page size must be less than the span of the next level in
 * the page table.  The largest size that can be requested is 64GB.
 *
 * The shift value is initially "0" for all page table levels,
 * indicating that the HV_PTE_SUPER bit is effectively ignored.
 *
 * If you change the count from one non-zero value to another, the
 * hypervisor will flush the entire TLB and TSB to avoid confusion.
 *
 * @param level Page table level (0, 1, or 2)
 * @param log2_count Base-2 log of the number of pages to gang together,
 * i.e. how much to shift left the base page size for the super page size.
 * @return Zero on success, or a hypervisor error code on failure.
 */
int hv_set_pte_super_shift(int level, int log2_count);


/** Value returned from hv_inquire_context(). */
typedef struct
{
  /** Physical address of page table */
  HV_PhysAddr page_table;

  /** PTE which defines access method for top of page table */
  HV_PTE access;

  /** ASID associated with this page table */
  HV_ASID asid;

  /** Context flags */
  __hv32 flags;
} HV_Context;

/** Retrieve information about the currently installed context.
 * @return The data passed to the last successful hv_install_context call.
 */
HV_Context hv_inquire_context(void);


/** Flushes all translations associated with the named address space
 *  identifier from the TLB and any other hypervisor data structures.
 *  Translations installed with the "global" bit are not flushed.
 *
 *  Specifying an invalid ASID may lead to client termination.  "Invalid"
 *  in this context means a value which was not provided to the client
 *  via <tt>hv_inquire_asid()</tt>.
 *
 * @param asid HV_ASID whose entries are to be flushed.
 * @return Zero on success, or a hypervisor error code on failure.
*/
int hv_flush_asid(HV_ASID asid);


/** Flushes all translations associated with the named virtual address
 *  and page size from the TLB and other hypervisor data structures. Only
 *  pages visible to the current ASID are affected; note that this includes
 *  global pages in addition to pages specific to the current ASID.
 *
 *  The supplied VA need not be aligned; it may be anywhere in the
 *  subject page.
 *
 *  Specifying an invalid virtual address may lead to client termination,
 *  or may silently succeed.  "Invalid" in this context means a value
 *  which was not provided to the client via hv_inquire_virtual.
 *
 * @param address Address of the page to flush.
 * @param page_size Size of pages to assume.
 * @return Zero on success, or a hypervisor error code on failure.
 */
int hv_flush_page(HV_VirtAddr address, HV_PageSize page_size);


/** Flushes all translations associated with the named virtual address range
 *  and page size from the TLB and other hypervisor data structures. Only
 *  pages visible to the current ASID are affected; note that this includes
 *  global pages in addition to pages specific to the current ASID.
 *
 *  The supplied VA need not be aligned; it may be anywhere in the
 *  subject page.
 *
 *  Specifying an invalid virtual address may lead to client termination,
 *  or may silently succeed.  "Invalid" in this context means a value
 *  which was not provided to the client via hv_inquire_virtual.
 *
 * @param start Address to flush.
 * @param page_size Size of pages to assume.
 * @param size The number of bytes to flush. Any page in the range
 *        [start, start + size) will be flushed from the TLB.
 * @return Zero on success, or a hypervisor error code on failure.
 */
int hv_flush_pages(HV_VirtAddr start, HV_PageSize page_size,
                   unsigned long size);


/** Flushes all non-global translations (if preserve_global is true),
 *  or absolutely all translations (if preserve_global is false).
 *
 * @param preserve_global Non-zero if we want to preserve "global" mappings.
 * @return Zero on success, or a hypervisor error code on failure.
*/
int hv_flush_all(int preserve_global);


/** Restart machine with optional restart command and optional args.
 * @param cmd Const pointer to command to restart with, or NULL
 * @param args Const pointer to argument string to restart with, or NULL
 */
void hv_restart(HV_VirtAddr cmd, HV_VirtAddr args);


/** Halt machine. */
void hv_halt(void);


/** Power off machine. */
void hv_power_off(void);


/** Re-enter virtual-is-physical memory translation mode and restart
 *  execution at a given address.
 * @param entry Client physical address at which to begin execution.
 * @return A hypervisor error code on failure; if the operation is
 *         successful the call does not return.
 */
int hv_reexec(HV_PhysAddr entry);


/** Chip topology */
typedef struct
{
  /** Relative coordinates of the querying tile */
  HV_Coord coord;

  /** Width of the querying supervisor's tile rectangle. */
  int width;

  /** Height of the querying supervisor's tile rectangle. */
  int height;

} HV_Topology;

/** Returns information about the tile coordinate system.
 *
 * Each supervisor is given a rectangle of tiles it potentially controls.
 * These tiles are labeled using a relative coordinate system with (0,0) as
 * the upper left tile regardless of their physical location on the chip.
 *
 * This call returns both the size of that rectangle and the position
 * within that rectangle of the querying tile.
 *
 * Not all tiles within that rectangle may be available to the supervisor;
 * to get the precise set of available tiles, you must also call
 * hv_inquire_tiles(HV_INQ_TILES_AVAIL, ...).
 **/
HV_Topology hv_inquire_topology(void);

/** Sets of tiles we can retrieve with hv_inquire_tiles().
 *
 * These numbers are part of the binary API and guaranteed not to change.
 */
typedef enum {
  /** An invalid value; do not use. */
  _HV_INQ_TILES_RESERVED       = 0,

  /** All available tiles within the supervisor's tile rectangle. */
  HV_INQ_TILES_AVAIL           = 1,

  /** The set of tiles used for hash-for-home caching. */
  HV_INQ_TILES_HFH_CACHE       = 2,

  /** The set of tiles that can be legally used as a LOTAR for a PTE. */
  HV_INQ_TILES_LOTAR           = 3,

  /** The set of "shared" driver tiles that the hypervisor may
   *  periodically interrupt. */
  HV_INQ_TILES_SHARED          = 4
} HV_InqTileSet;

/** Returns specific information about various sets of tiles within the
 *  supervisor's tile rectangle.
 *
 * @param set Which set of tiles to retrieve.
 * @param cpumask Pointer to a returned bitmask (in row-major order,
 *        supervisor-relative) of tiles.  The low bit of the first word
 *        corresponds to the tile at the upper left-hand corner of the
 *        supervisor's rectangle.  In order for the supervisor to know the
 *        buffer length to supply, it should first call hv_inquire_topology.
 * @param length Number of bytes available for the returned bitmask.
 **/
HV_Errno hv_inquire_tiles(HV_InqTileSet set, HV_VirtAddr cpumask, int length);


/** An identifier for a memory controller. Multiple memory controllers
 * may be connected to one chip, and this uniquely identifies each one.
 */
typedef int HV_MemoryController;

/** A range of physical memory. */
typedef struct
{
  HV_PhysAddr start;   /**< Starting address. */
  __hv64 size;         /**< Size in bytes. */
  HV_MemoryController controller;  /**< Which memory controller owns this. */
} HV_PhysAddrRange;

/** Returns information about a range of physical memory.
 *
 * hv_inquire_physical() returns one of the ranges of client
 * physical addresses which are available to this client.
 *
 * The first range is retrieved by specifying an idx of 0, and
 * successive ranges are returned with subsequent idx values.  Ranges
 * are ordered by increasing start address (i.e., as idx increases,
 * so does start), do not overlap, and do not touch (i.e., the
 * available memory is described with the fewest possible ranges).
 *
 * If an out-of-range idx value is specified, the returned size will be zero.
 * A client can count the number of ranges by increasing idx until the
 * returned size is zero. There will always be at least one valid range.
 *
 * Some clients might not be prepared to deal with more than one
 * physical address range; they still ought to call this routine and
 * issue a warning message if they're given more than one range, on the
 * theory that whoever configured the hypervisor to provide that memory
 * should know that it's being wasted.
 */
HV_PhysAddrRange hv_inquire_physical(int idx);

/** Possible DIMM types. */
typedef enum
{
  NO_DIMM                    = 0,  /**< No DIMM */
  DDR2                       = 1,  /**< DDR2 */
  DDR3                       = 2   /**< DDR3 */
} HV_DIMM_Type;

#ifdef __tilegx__

/** Log2 of minimum DIMM bytes supported by the memory controller. */
#define HV_MSH_MIN_DIMM_SIZE_SHIFT 29

/** Max number of DIMMs contained by one memory controller. */
#define HV_MSH_MAX_DIMMS 8

#else

/** Log2 of minimum DIMM bytes supported by the memory controller. */
#define HV_MSH_MIN_DIMM_SIZE_SHIFT 26

/** Max number of DIMMs contained by one memory controller. */
#define HV_MSH_MAX_DIMMS 2

#endif

/** Number of bits to right-shift to get the DIMM type. */
#define HV_DIMM_TYPE_SHIFT 0

/** Bits to mask to get the DIMM type. */
#define HV_DIMM_TYPE_MASK 0xf

/** Number of bits to right-shift to get the DIMM size. */
#define HV_DIMM_SIZE_SHIFT 4

/** Bits to mask to get the DIMM size. */
#define HV_DIMM_SIZE_MASK 0xf

/** Memory controller information. */
typedef struct
{
  HV_Coord coord;   /**< Relative tile coordinates of the port used by a
                         specified tile to communicate with this controller. */
  __hv64 speed;     /**< Speed of this controller in bytes per second. */
} HV_MemoryControllerInfo;

/** Returns information about a particular memory controller.
 *
 *  hv_inquire_memory_controller(coord,idx) returns information about a
 *  particular controller.  Two pieces of information are returned:
 *  - The relative coordinates of the port on the controller that the specified
 *    tile would use to contact it.  The relative coordinates may lie
 *    outside the supervisor's rectangle, i.e. the controller may not
 *    be attached to a node managed by the querying node's supervisor.
 *    In particular note that x or y may be negative.
 *  - The speed of the memory controller.  (This is a not-to-exceed value
 *    based on the raw hardware data rate, and may not be achievable in
 *    practice; it is provided to give clients information on the relative
 *    performance of the available controllers.)
 *
 *  Clients should avoid calling this interface with invalid values.
 *  A client who does may be terminated.
 * @param coord Tile for which to calculate the relative port position.
 * @param controller Index of the controller; identical to value returned
 *        from other routines like hv_inquire_physical.
 * @return Information about the controller.
 */
HV_MemoryControllerInfo hv_inquire_memory_controller(HV_Coord coord,
                                                     int controller);


/** A range of virtual memory. */
typedef struct
{
  HV_VirtAddr start;   /**< Starting address. */
  __hv64 size;         /**< Size in bytes. */
} HV_VirtAddrRange;

/** Returns information about a range of virtual memory.
 *
 * hv_inquire_virtual() returns one of the ranges of client
 * virtual addresses which are available to this client.
 *
 * The first range is retrieved by specifying an idx of 0, and
 * successive ranges are returned with subsequent idx values.  Ranges
 * are ordered by increasing start address (i.e., as idx increases,
 * so does start), do not overlap, and do not touch (i.e., the
 * available memory is described with the fewest possible ranges).
 *
 * If an out-of-range idx value is specified, the returned size will be zero.
 * A client can count the number of ranges by increasing idx until the
 * returned size is zero. There will always be at least one valid range.
 *
 * Some clients may well have various virtual addresses hardwired
 * into themselves; for instance, their instruction stream may
 * have been compiled expecting to live at a particular address.
 * Such clients should use this interface to verify they've been
 * given the virtual address space they expect, and issue a (potentially
 * fatal) warning message otherwise.
 *
 * Note that the returned size is a __hv64, not a __hv32, so it is
 * possible to express a single range spanning the entire 32-bit
 * address space.
 */
HV_VirtAddrRange hv_inquire_virtual(int idx);


/** A range of ASID values. */
typedef struct
{
  HV_ASID start;        /**< First ASID in the range. */
  unsigned int size;    /**< Number of ASIDs. Zero for an invalid range. */
} HV_ASIDRange;

/** Returns information about a range of ASIDs.
 *
 * hv_inquire_asid() returns one of the ranges of address
 * space identifiers which are available to this client.
 *
 * The first range is retrieved by specifying an idx of 0, and
 * successive ranges are returned with subsequent idx values.  Ranges
 * are ordered by increasing start value (i.e., as idx increases,
 * so does start), do not overlap, and do not touch (i.e., the
 * available ASIDs are described with the fewest possible ranges).
 *
 * If an out-of-range idx value is specified, the returned size will be zero.
 * A client can count the number of ranges by increasing idx until the
 * returned size is zero. There will always be at least one valid range.
 */
HV_ASIDRange hv_inquire_asid(int idx);


/** Waits for at least the specified number of nanoseconds then returns.
 *
 * NOTE: this deprecated function currently assumes a 750 MHz clock,
 * and is thus not generally suitable for use.  New code should call
 * hv_sysconf(HV_SYSCONF_CPU_SPEED), compute a cycle count to wait for,
 * and delay by looping while checking the cycle counter SPR.
 *
 * @param nanosecs The number of nanoseconds to sleep.
 */
void hv_nanosleep(int nanosecs);


/** Reads a character from the console without blocking.
 *
 * @return A value from 0-255 indicates the value successfully read.
 * A negative value means no value was ready.
 */
int hv_console_read_if_ready(void);


/** Writes a character to the console, blocking if the console is busy.
 *
 *  This call cannot fail. If the console is broken for some reason,
 *  output will simply vanish.
 * @param byte Character to write.
 */
void hv_console_putc(int byte);


/** Writes a string to the console, blocking if the console is busy.
 * @param bytes Pointer to characters to write.
 * @param len Number of characters to write.
 * @return Number of characters written, or HV_EFAULT if the buffer is invalid.
 */
int hv_console_write(HV_VirtAddr bytes, int len);


/** Dispatch the next interrupt from the client downcall mechanism.
 *
 *  The hypervisor uses downcalls to notify the client of asynchronous
 *  events.  Some of these events are hypervisor-created (like incoming
 *  messages).  Some are regular interrupts which initially occur in
 *  the hypervisor, and are normally handled directly by the client;
 *  when these occur in a client's interrupt critical section, they must
 *  be delivered through the downcall mechanism.
 *
 *  A downcall is initially delivered to the client as an INTCTRL_CL
 *  interrupt, where CL is the client's PL.  Upon entry to the INTCTRL_CL
 *  vector, the client must immediately invoke the hv_downcall_dispatch
 *  service.  This service will not return; instead it will cause one of
 *  the client's actual downcall-handling interrupt vectors to be entered.
 *  The EX_CONTEXT registers in the client will be set so that when the
 *  client irets, it will return to the code which was interrupted by the
 *  INTCTRL_CL interrupt.
 *
 *  Under some circumstances, the firing of INTCTRL_CL can race with
 *  the lowering of a device interrupt.  In such a case, the
 *  hv_downcall_dispatch service may issue an iret instruction instead
 *  of entering one of the client's actual downcall-handling interrupt
 *  vectors.  This will return execution to the location that was
 *  interrupted by INTCTRL_CL.
 *
 *  Any saving of registers should be done by the actual handling
 *  vectors; no registers should be changed by the INTCTRL_CL handler.
 *  In particular, the client should not use a jal instruction to invoke
 *  the hv_downcall_dispatch service, as that would overwrite the client's
 *  lr register.  Note that the hv_downcall_dispatch service may overwrite
 *  one or more of the client's system save registers.
 *
 *  The client must not modify the INTCTRL_CL_STATUS SPR.  The hypervisor
 *  will set this register to cause a downcall to happen, and will clear
 *  it when no further downcalls are pending.
 *
 *  When a downcall vector is entered, the INTCTRL_CL interrupt will be
 *  masked.  When the client is done processing a downcall, and is ready
 *  to accept another, it must unmask this interrupt; if more downcalls
 *  are pending, this will cause the INTCTRL_CL vector to be reentered.
 *  Currently the following interrupt vectors can be entered through a
 *  downcall:
 *
 *  INT_MESSAGE_RCV_DWNCL   (hypervisor message available)
 *  INT_DEV_INTR_DWNCL      (device interrupt)
 *  INT_DMATLB_MISS_DWNCL   (DMA TLB miss)
 *  INT_SNITLB_MISS_DWNCL   (SNI TLB miss)
 *  INT_DMATLB_ACCESS_DWNCL (DMA TLB access violation)
 */
void hv_downcall_dispatch(void);

#endif /* !__ASSEMBLER__ */

/** We use actual interrupt vectors which never occur (they're only there
 *  to allow setting MPLs for related SPRs) for our downcall vectors.
 */
/** Message receive downcall interrupt vector */
#define INT_MESSAGE_RCV_DWNCL    INT_BOOT_ACCESS
/** DMA TLB miss downcall interrupt vector */
#define INT_DMATLB_MISS_DWNCL    INT_DMA_ASID
/** Static nework processor instruction TLB miss interrupt vector */
#define INT_SNITLB_MISS_DWNCL    INT_SNI_ASID
/** DMA TLB access violation downcall interrupt vector */
#define INT_DMATLB_ACCESS_DWNCL  INT_DMA_CPL
/** Device interrupt downcall interrupt vector */
#define INT_DEV_INTR_DWNCL       INT_WORLD_ACCESS
/** NMI downcall interrupt vector */
#define INT_NMI_DWNCL            64

#define HV_NMI_FLAG_FORCE    0x1  /**< Force an NMI downcall regardless of
               the ICS bit of the client. */

#ifndef __ASSEMBLER__

/** Requests the inode for a specific full pathname.
 *
 * Performs a lookup in the hypervisor filesystem for a given filename.
 * Multiple calls with the same filename will always return the same inode.
 * If there is no such filename, HV_ENOENT is returned.
 * A bad filename pointer may result in HV_EFAULT instead.
 *
 * @param filename Constant pointer to name of requested file
 * @return Inode of requested file
 */
int hv_fs_findfile(HV_VirtAddr filename);


/** Data returned from an fstat request.
 * Note that this structure should be no more than 40 bytes in size so
 * that it can always be returned completely in registers.
 */
typedef struct
{
  int size;             /**< Size of file (or HV_Errno on error) */
  unsigned int flags;   /**< Flags (see HV_FS_FSTAT_FLAGS) */
} HV_FS_StatInfo;

/** Bitmask flags for fstat request */
typedef enum
{
  HV_FS_ISDIR    = 0x0001   /**< Is the entry a directory? */
} HV_FS_FSTAT_FLAGS;

/** Get stat information on a given file inode.
 *
 * Return information on the file with the given inode.
 *
 * IF the HV_FS_ISDIR bit is set, the "file" is a directory.  Reading
 * it will return NUL-separated filenames (no directory part) relative
 * to the path to the inode of the directory "file".  These can be
 * appended to the path to the directory "file" after a forward slash
 * to create additional filenames.  Note that it is not required
 * that all valid paths be decomposable into valid parent directories;
 * a filesystem may validly have just a few files, none of which have
 * HV_FS_ISDIR set.  However, if clients may wish to enumerate the
 * files in the filesystem, it is recommended to include all the
 * appropriate parent directory "files" to give a consistent view.
 *
 * An invalid file inode will cause an HV_EBADF error to be returned.
 *
 * @param inode The inode number of the query
 * @return An HV_FS_StatInfo structure
 */
HV_FS_StatInfo hv_fs_fstat(int inode);


/** Read data from a specific hypervisor file.
 * On error, may return HV_EBADF for a bad inode or HV_EFAULT for a bad buf.
 * Reads near the end of the file will return fewer bytes than requested.
 * Reads at or beyond the end of a file will return zero.
 *
 * @param inode the hypervisor file to read
 * @param buf the buffer to read data into
 * @param length the number of bytes of data to read
 * @param offset the offset into the file to read the data from
 * @return number of bytes successfully read, or an HV_Errno code
 */
int hv_fs_pread(int inode, HV_VirtAddr buf, int length, int offset);


/** Read a 64-bit word from the specified physical address.
 * The address must be 8-byte aligned.
 * Specifying an invalid physical address will lead to client termination.
 * @param addr The physical address to read
 * @param access The PTE describing how to read the memory
 * @return The 64-bit value read from the given address
 */
unsigned long long hv_physaddr_read64(HV_PhysAddr addr, HV_PTE access);


/** Write a 64-bit word to the specified physical address.
 * The address must be 8-byte aligned.
 * Specifying an invalid physical address will lead to client termination.
 * @param addr The physical address to write
 * @param access The PTE that says how to write the memory
 * @param val The 64-bit value to write to the given address
 */
void hv_physaddr_write64(HV_PhysAddr addr, HV_PTE access,
                         unsigned long long val);


/** Get the value of the command-line for the supervisor, if any.
 * This will not include the filename of the booted supervisor, but may
 * include configured-in boot arguments or the hv_restart() arguments.
 * If the buffer is not long enough the hypervisor will NUL the first
 * character of the buffer but not write any other data.
 * @param buf The virtual address to write the command-line string to.
 * @param length The length of buf, in characters.
 * @return The actual length of the command line, including the trailing NUL
 *         (may be larger than "length").
 */
int hv_get_command_line(HV_VirtAddr buf, int length);


/** Set a new value for the command-line for the supervisor, which will
 *  be returned from subsequent invocations of hv_get_command_line() on
 *  this tile.
 * @param buf The virtual address to read the command-line string from.
 * @param length The length of buf, in characters; must be no more than
 *        HV_COMMAND_LINE_LEN.
 * @return Zero if successful, or a hypervisor error code.
 */
HV_Errno hv_set_command_line(HV_VirtAddr buf, int length);

/** Maximum size of a command line passed to hv_set_command_line(); note
 *  that a line returned from hv_get_command_line() could be larger than
 *  this.*/
#define HV_COMMAND_LINE_LEN  256

/** Tell the hypervisor how to cache non-priority pages
 * (its own as well as pages explicitly represented in page tables).
 * Normally these will be represented as red/black pages, but
 * when the supervisor starts to allocate "priority" pages in the PTE
 * the hypervisor will need to start marking those pages as (e.g.) "red"
 * and non-priority pages as either "black" (if they cache-alias
 * with the existing priority pages) or "red/black" (if they don't).
 * The bitmask provides information on which parts of the cache
 * have been used for pinned pages so far on this tile; if (1 << N)
 * appears in the bitmask, that indicates that a 4KB region of the
 * cache starting at (N * 4KB) is in use by a "priority" page.
 * The portion of cache used by a particular page can be computed
 * by taking the page's PA, modulo CHIP_L2_CACHE_SIZE(), and setting
 * all the "4KB" bits corresponding to the actual page size.
 * @param bitmask A bitmap of priority page set values
 */
void hv_set_caching(unsigned long bitmask);


/** Zero out a specified number of pages.
 * The va and size must both be multiples of 4096.
 * Caches are bypassed and memory is directly set to zero.
 * This API is implemented only in the magic hypervisor and is intended
 * to provide a performance boost to the minimal supervisor by
 * giving it a fast way to zero memory pages when allocating them.
 * @param va Virtual address where the page has been mapped
 * @param size Number of bytes (must be a page size multiple)
 */
void hv_bzero_page(HV_VirtAddr va, unsigned int size);


/** State object for the hypervisor messaging subsystem. */
typedef struct
{
#if CHIP_VA_WIDTH() > 32
  __hv64 opaque[2]; /**< No user-serviceable parts inside */
#else
  __hv32 opaque[2]; /**< No user-serviceable parts inside */
#endif
}
HV_MsgState;

/** Register to receive incoming messages.
 *
 *  This routine configures the current tile so that it can receive
 *  incoming messages.  It must be called before the client can receive
 *  messages with the hv_receive_message routine, and must be called on
 *  each tile which will receive messages.
 *
 *  msgstate is the virtual address of a state object of type HV_MsgState.
 *  Once the state is registered, the client must not read or write the
 *  state object; doing so will cause undefined results.
 *
 *  If this routine is called with msgstate set to 0, the client's message
 *  state will be freed and it will no longer be able to receive messages.
 *  Note that this may cause the loss of any as-yet-undelivered messages
 *  for the client.
 *
 *  If another client attempts to send a message to a client which has
 *  not yet called hv_register_message_state, or which has freed its
 *  message state, the message will not be delivered, as if the client
 *  had insufficient buffering.
 *
 *  This routine returns HV_OK if the registration was successful, and
 *  HV_EINVAL if the supplied state object is unsuitable.  Note that some
 *  errors may not be detected during this routine, but might be detected
 *  during a subsequent message delivery.
 * @param msgstate State object.
 **/
HV_Errno hv_register_message_state(HV_MsgState* msgstate);

/** Possible message recipient states. */
typedef enum
{
  HV_TO_BE_SENT,    /**< Not sent (not attempted, or recipient not ready) */
  HV_SENT,          /**< Successfully sent */
  HV_BAD_RECIP      /**< Bad recipient coordinates (permanent error) */
} HV_Recip_State;

/** Message recipient. */
typedef struct
{
  /** X coordinate, relative to supervisor's top-left coordinate */
  unsigned int x:11;

  /** Y coordinate, relative to supervisor's top-left coordinate */
  unsigned int y:11;

  /** Status of this recipient */
  HV_Recip_State state:10;
} HV_Recipient;

/** Send a message to a set of recipients.
 *
 *  This routine sends a message to a set of recipients.
 *
 *  recips is an array of HV_Recipient structures.  Each specifies a tile,
 *  and a message state; initially, it is expected that the state will
 *  be set to HV_TO_BE_SENT.  nrecip specifies the number of recipients
 *  in the recips array.
 *
 *  For each recipient whose state is HV_TO_BE_SENT, the hypervisor attempts
 *  to send that tile the specified message.  In order to successfully
 *  receive the message, the receiver must be a valid tile to which the
 *  sender has access, must not be the sending tile itself, and must have
 *  sufficient free buffer space.  (The hypervisor guarantees that each
 *  tile which has called hv_register_message_state() will be able to
 *  buffer one message from every other tile which can legally send to it;
 *  more space may be provided but is not guaranteed.)  If an invalid tile
 *  is specified, the recipient's state is set to HV_BAD_RECIP; this is a
 *  permanent delivery error.  If the message is successfully delivered
 *  to the recipient's buffer, the recipient's state is set to HV_SENT.
 *  Otherwise, the recipient's state is unchanged.  Message delivery is
 *  synchronous; all attempts to send messages are completed before this
 *  routine returns.
 *
 *  If no permanent delivery errors were encountered, the routine returns
 *  the number of messages successfully sent: that is, the number of
 *  recipients whose states changed from HV_TO_BE_SENT to HV_SENT during
 *  this operation.  If any permanent delivery errors were encountered,
 *  the routine returns HV_ERECIP.  In the event of permanent delivery
 *  errors, it may be the case that delivery was not attempted to all
 *  recipients; if any messages were successfully delivered, however,
 *  recipients' state values will be updated appropriately.
 *
 *  It is explicitly legal to specify a recipient structure whose state
 *  is not HV_TO_BE_SENT; such a recipient is ignored.  One suggested way
 *  of using hv_send_message to send a message to multiple tiles is to set
 *  up a list of recipients, and then call the routine repeatedly with the
 *  same list, each time accumulating the number of messages successfully
 *  sent, until all messages are sent, a permanent error is encountered,
 *  or the desired number of attempts have been made.  When used in this
 *  way, the routine will deliver each message no more than once to each
 *  recipient.
 *
 *  Note that a message being successfully delivered to the recipient's
 *  buffer space does not guarantee that it is received by the recipient,
 *  either immediately or at any time in the future; the recipient might
 *  never call hv_receive_message, or could register a different state
 *  buffer, losing the message.
 *
 *  Specifying the same recipient more than once in the recipient list
 *  is an error, which will not result in an error return but which may
 *  or may not result in more than one message being delivered to the
 *  recipient tile.
 *
 *  buf and buflen specify the message to be sent.  buf is a virtual address
 *  which must be currently mapped in the client's page table; if not, the
 *  routine returns HV_EFAULT.  buflen must be greater than zero and less
 *  than or equal to HV_MAX_MESSAGE_SIZE, and nrecip must be less than the
 *  number of tiles to which the sender has access; if not, the routine
 *  returns HV_EINVAL.
 * @param recips List of recipients.
 * @param nrecip Number of recipients.
 * @param buf Address of message data.
 * @param buflen Length of message data.
 **/
int hv_send_message(HV_Recipient *recips, int nrecip,
                    HV_VirtAddr buf, int buflen);

/** Maximum hypervisor message size, in bytes */
#define HV_MAX_MESSAGE_SIZE 28


/** Return value from hv_receive_message() */
typedef struct
{
  int msglen;     /**< Message length in bytes, or an error code */
  __hv32 source;  /**< Code identifying message sender (HV_MSG_xxx) */
} HV_RcvMsgInfo;

#define HV_MSG_TILE 0x0         /**< Message source is another tile */
#define HV_MSG_INTR 0x1         /**< Message source is a driver interrupt */

/** Receive a message.
 *
 * This routine retrieves a message from the client's incoming message
 * buffer.
 *
 * Multiple messages sent from a particular sending tile to a particular
 * receiving tile are received in the order that they were sent; however,
 * no ordering is guaranteed between messages sent by different tiles.
 *
 * Whenever the a client's message buffer is empty, the first message
 * subsequently received will cause the client's MESSAGE_RCV_DWNCL
 * interrupt vector to be invoked through the interrupt downcall mechanism
 * (see the description of the hv_downcall_dispatch() routine for details
 * on downcalls).
 *
 * Another message-available downcall will not occur until a call to
 * this routine is made when the message buffer is empty, and a message
 * subsequently arrives.  Note that such a downcall could occur while
 * this routine is executing.  If the calling code does not wish this
 * to happen, it is recommended that this routine be called with the
 * INTCTRL_1 interrupt masked, or inside an interrupt critical section.
 *
 * msgstate is the value previously passed to hv_register_message_state().
 * buf is the virtual address of the buffer into which the message will
 * be written; buflen is the length of the buffer.
 *
 * This routine returns an HV_RcvMsgInfo structure.  The msglen member
 * of that structure is the length of the message received, zero if no
 * message is available, or HV_E2BIG if the message is too large for the
 * specified buffer.  If the message is too large, it is not consumed,
 * and may be retrieved by a subsequent call to this routine specifying
 * a sufficiently large buffer.  A buffer which is HV_MAX_MESSAGE_SIZE
 * bytes long is guaranteed to be able to receive any possible message.
 *
 * The source member of the HV_RcvMsgInfo structure describes the sender
 * of the message.  For messages sent by another client tile via an
 * hv_send_message() call, this value is HV_MSG_TILE; for messages sent
 * as a result of a device interrupt, this value is HV_MSG_INTR.
 */

HV_RcvMsgInfo hv_receive_message(HV_MsgState msgstate, HV_VirtAddr buf,
                                 int buflen);


/** Start remaining tiles owned by this supervisor.  Initially, only one tile
 *  executes the client program; after it calls this service, the other tiles
 *  are started.  This allows the initial tile to do one-time configuration
 *  of shared data structures without having to lock them against simultaneous
 *  access.
 */
void hv_start_all_tiles(void);


/** Open a hypervisor device.
 *
 *  This service initializes an I/O device and its hypervisor driver software,
 *  and makes it available for use.  The open operation is per-device per-chip;
 *  once it has been performed, the device handle returned may be used in other
 *  device services calls made by any tile.
 *
 * @param name Name of the device.  A base device name is just a text string
 *        (say, "pcie").  If there is more than one instance of a device, the
 *        base name is followed by a slash and a device number (say, "pcie/0").
 *        Some devices may support further structure beneath those components;
 *        most notably, devices which require control operations do so by
 *        supporting reads and/or writes to a control device whose name
 *        includes a trailing "/ctl" (say, "pcie/0/ctl").
 * @param flags Flags (HV_DEV_xxx).
 * @return A positive integer device handle, or a negative error code.
 */
int hv_dev_open(HV_VirtAddr name, __hv32 flags);


/** Close a hypervisor device.
 *
 *  This service uninitializes an I/O device and its hypervisor driver
 *  software, and makes it unavailable for use.  The close operation is
 *  per-device per-chip; once it has been performed, the device is no longer
 *  available.  Normally there is no need to ever call the close service.
 *
 * @param devhdl Device handle of the device to be closed.
 * @return Zero if the close is successful, otherwise, a negative error code.
 */
int hv_dev_close(int devhdl);


/** Read data from a hypervisor device synchronously.
 *
 *  This service transfers data from a hypervisor device to a memory buffer.
 *  When the service returns, the data has been written from the memory buffer,
 *  and the buffer will not be further modified by the driver.
 *
 *  No ordering is guaranteed between requests issued from different tiles.
 *
 *  Devices may choose to support both the synchronous and asynchronous read
 *  operations, only one of them, or neither of them.
 *
 * @param devhdl Device handle of the device to be read from.
 * @param flags Flags (HV_DEV_xxx).
 * @param va Virtual address of the target data buffer.  This buffer must
 *        be mapped in the currently installed page table; if not, HV_EFAULT
 *        may be returned.
 * @param len Number of bytes to be transferred.
 * @param offset Driver-dependent offset.  For a random-access device, this is
 *        often a byte offset from the beginning of the device; in other cases,
 *        like on a control device, it may have a different meaning.
 * @return A non-negative value if the read was at least partially successful;
 *         otherwise, a negative error code.  The precise interpretation of
 *         the return value is driver-dependent, but many drivers will return
 *         the number of bytes successfully transferred.
 */
int hv_dev_pread(int devhdl, __hv32 flags, HV_VirtAddr va, __hv32 len,
                 __hv64 offset);

#define HV_DEV_NB_EMPTY     0x1   /**< Don't block when no bytes of data can
                                       be transferred. */
#define HV_DEV_NB_PARTIAL   0x2   /**< Don't block when some bytes, but not all
                                       of the requested bytes, can be
                                       transferred. */
#define HV_DEV_NOCACHE      0x4   /**< The caller warrants that none of the
                                       cache lines which might contain data
                                       from the requested buffer are valid.
                                       Useful with asynchronous operations
                                       only. */

#define HV_DEV_ALLFLAGS     (HV_DEV_NB_EMPTY | HV_DEV_NB_PARTIAL | \
                             HV_DEV_NOCACHE)   /**< All HV_DEV_xxx flags */

/** Write data to a hypervisor device synchronously.
 *
 *  This service transfers data from a memory buffer to a hypervisor device.
 *  When the service returns, the data has been read from the memory buffer,
 *  and the buffer may be overwritten by the client; the data may not
 *  necessarily have been conveyed to the actual hardware I/O interface.
 *
 *  No ordering is guaranteed between requests issued from different tiles.
 *
 *  Devices may choose to support both the synchronous and asynchronous write
 *  operations, only one of them, or neither of them.
 *
 * @param devhdl Device handle of the device to be written to.
 * @param flags Flags (HV_DEV_xxx).
 * @param va Virtual address of the source data buffer.  This buffer must
 *        be mapped in the currently installed page table; if not, HV_EFAULT
 *        may be returned.
 * @param len Number of bytes to be transferred.
 * @param offset Driver-dependent offset.  For a random-access device, this is
 *        often a byte offset from the beginning of the device; in other cases,
 *        like on a control device, it may have a different meaning.
 * @return A non-negative value if the write was at least partially successful;
 *         otherwise, a negative error code.  The precise interpretation of
 *         the return value is driver-dependent, but many drivers will return
 *         the number of bytes successfully transferred.
 */
int hv_dev_pwrite(int devhdl, __hv32 flags, HV_VirtAddr va, __hv32 len,
                  __hv64 offset);


/** Interrupt arguments, used in the asynchronous I/O interfaces. */
#if CHIP_VA_WIDTH() > 32
typedef __hv64 HV_IntArg;
#else
typedef __hv32 HV_IntArg;
#endif

/** Interrupt messages are delivered via the mechanism as normal messages,
 *  but have a message source of HV_DEV_INTR.  The message is formatted
 *  as an HV_IntrMsg structure.
 */

typedef struct
{
  HV_IntArg intarg;  /**< Interrupt argument, passed to the poll/preada/pwritea
                          services */
  HV_IntArg intdata; /**< Interrupt-specific interrupt data */
} HV_IntrMsg;

/** Request an interrupt message when a device condition is satisfied.
 *
 *  This service requests that an interrupt message be delivered to the
 *  requesting tile when a device becomes readable or writable, or when any
 *  data queued to the device via previous write operations from this tile
 *  has been actually sent out on the hardware I/O interface.  Devices may
 *  choose to support any, all, or none of the available conditions.
 *
 *  If multiple conditions are specified, only one message will be
 *  delivered.  If the event mask delivered to that interrupt handler
 *  indicates that some of the conditions have not yet occurred, the
 *  client must issue another poll() call if it wishes to wait for those
 *  conditions.
 *
 *  Only one poll may be outstanding per device handle per tile.  If more than
 *  one tile is polling on the same device and condition, they will all be
 *  notified when it happens.  Because of this, clients may not assume that
 *  the condition signaled is necessarily still true when they request a
 *  subsequent service; for instance, the readable data which caused the
 *  poll call to interrupt may have been read by another tile in the interim.
 *
 *  The notification interrupt message could come directly, or via the
 *  downcall (intctrl1) method, depending on what the tile is doing
 *  when the condition is satisfied.  Note that it is possible for the
 *  requested interrupt to be delivered after this service is called but
 *  before it returns.
 *
 * @param devhdl Device handle of the device to be polled.
 * @param events Flags denoting the events which will cause the interrupt to
 *        be delivered (HV_DEVPOLL_xxx).
 * @param intarg Value which will be delivered as the intarg member of the
 *        eventual interrupt message; the intdata member will be set to a
 *        mask of HV_DEVPOLL_xxx values indicating which conditions have been
 *        satisifed.
 * @return Zero if the interrupt was successfully scheduled; otherwise, a
 *         negative error code.
 */
int hv_dev_poll(int devhdl, __hv32 events, HV_IntArg intarg);

#define HV_DEVPOLL_READ     0x1   /**< Test device for readability */
#define HV_DEVPOLL_WRITE    0x2   /**< Test device for writability */
#define HV_DEVPOLL_FLUSH    0x4   /**< Test device for output drained */


/** Cancel a request for an interrupt when a device event occurs.
 *
 *  This service requests that no interrupt be delivered when the events
 *  noted in the last-issued poll() call happen.  Once this service returns,
 *  the interrupt has been canceled; however, it is possible for the interrupt
 *  to be delivered after this service is called but before it returns.
 *
 * @param devhdl Device handle of the device on which to cancel polling.
 * @return Zero if the poll was successfully canceled; otherwise, a negative
 *         error code.
 */
int hv_dev_poll_cancel(int devhdl);


/** NMI information */
typedef struct
{
  /** Result: negative error, or HV_NMI_RESULT_xxx. */
  int result;

  /** PC from interrupted remote core (if result != HV_NMI_RESULT_FAIL_HV). */
  HV_VirtAddr pc;

} HV_NMI_Info;

/** NMI issued successfully. */
#define HV_NMI_RESULT_OK        0

/** NMI not issued: remote tile running at client PL with ICS set. */
#define HV_NMI_RESULT_FAIL_ICS  1

/** NMI not issued: remote tile waiting in hypervisor. */
#define HV_NMI_RESULT_FAIL_HV   2

/** Force an NMI downcall regardless of the ICS bit of the client. */
#define HV_NMI_FLAG_FORCE    0x1

/** Send an NMI interrupt request to a particular tile.
 *
 *  This will cause the NMI to be issued on the remote tile regardless
 *  of the state of the client interrupt mask.  However, if the remote
 *  tile is in the hypervisor, it will not execute the NMI, and
 *  HV_NMI_RESULT_FAIL_HV will be returned.  Similarly, if the remote
 *  tile is in a client interrupt critical section at the time of the
 *  NMI, it will not execute the NMI, and HV_NMI_RESULT_FAIL_ICS will
 *  be returned.  In this second case, however, if HV_NMI_FLAG_FORCE
 *  is set in flags, then the remote tile will enter its NMI interrupt
 *  vector regardless.  Forcing the NMI vector during an interrupt
 *  critical section will mean that the client can not safely continue
 *  execution after handling the interrupt.
 *
 *  @param tile Tile to which the NMI request is sent.
 *  @param info NMI information which is defined by and interpreted by the
 *         supervisor, is passed to the specified tile, and is
 *         stored in the SPR register SYSTEM_SAVE_{CLIENT_PL}_2 on the
 *         specified tile when entering the NMI handler routine.
 *         Typically, this parameter stores the NMI type, or an aligned
 *         VA plus some special bits, etc.
 *  @param flags Flags (HV_NMI_FLAG_xxx).
 *  @return Information about the requested NMI.
 */
HV_NMI_Info hv_send_nmi(HV_Coord tile, unsigned long info, __hv64 flags);


/** Scatter-gather list for preada/pwritea calls. */
typedef struct
#if CHIP_VA_WIDTH() <= 32
__attribute__ ((packed, aligned(4)))
#endif
{
  HV_PhysAddr pa;  /**< Client physical address of the buffer segment. */
  HV_PTE pte;      /**< Page table entry describing the caching and location
                        override characteristics of the buffer segment.  Some
                        drivers ignore this element and will require that
                        the NOCACHE flag be set on their requests. */
  __hv32 len;      /**< Length of the buffer segment. */
} HV_SGL;

#define HV_SGL_MAXLEN 16  /**< Maximum number of entries in a scatter-gather
                               list */

/** Read data from a hypervisor device asynchronously.
 *
 *  This service transfers data from a hypervisor device to a memory buffer.
 *  When the service returns, the read has been scheduled.  When the read
 *  completes, an interrupt message will be delivered, and the buffer will
 *  not be further modified by the driver.
 *
 *  The number of possible outstanding asynchronous requests is defined by
 *  each driver, but it is recommended that it be at least two requests
 *  per tile per device.
 *
 *  No ordering is guaranteed between synchronous and asynchronous requests,
 *  even those issued on the same tile.
 *
 *  The completion interrupt message could come directly, or via the downcall
 *  (intctrl1) method, depending on what the tile is doing when the read
 *  completes.  Interrupts do not coalesce; one is delivered for each
 *  asynchronous I/O request.  Note that it is possible for the requested
 *  interrupt to be delivered after this service is called but before it
 *  returns.
 *
 *  Devices may choose to support both the synchronous and asynchronous read
 *  operations, only one of them, or neither of them.
 *
 * @param devhdl Device handle of the device to be read from.
 * @param flags Flags (HV_DEV_xxx).
 * @param sgl_len Number of elements in the scatter-gather list.
 * @param sgl Scatter-gather list describing the memory to which data will be
 *        written.
 * @param offset Driver-dependent offset.  For a random-access device, this is
 *        often a byte offset from the beginning of the device; in other cases,
 *        like on a control device, it may have a different meaning.
 * @param intarg Value which will be delivered as the intarg member of the
 *        eventual interrupt message; the intdata member will be set to the
 *        normal return value from the read request.
 * @return Zero if the read was successfully scheduled; otherwise, a negative
 *         error code.  Note that some drivers may choose to pre-validate
 *         their arguments, and may thus detect certain device error
 *         conditions at this time rather than when the completion notification
 *         occurs, but this is not required.
 */
int hv_dev_preada(int devhdl, __hv32 flags, __hv32 sgl_len,
                  HV_SGL sgl[/* sgl_len */], __hv64 offset, HV_IntArg intarg);


/** Write data to a hypervisor device asynchronously.
 *
 *  This service transfers data from a memory buffer to a hypervisor
 *  device.  When the service returns, the write has been scheduled.
 *  When the write completes, an interrupt message will be delivered,
 *  and the buffer may be overwritten by the client; the data may not
 *  necessarily have been conveyed to the actual hardware I/O interface.
 *
 *  The number of possible outstanding asynchronous requests is defined by
 *  each driver, but it is recommended that it be at least two requests
 *  per tile per device.
 *
 *  No ordering is guaranteed between synchronous and asynchronous requests,
 *  even those issued on the same tile.
 *
 *  The completion interrupt message could come directly, or via the downcall
 *  (intctrl1) method, depending on what the tile is doing when the read
 *  completes.  Interrupts do not coalesce; one is delivered for each
 *  asynchronous I/O request.  Note that it is possible for the requested
 *  interrupt to be delivered after this service is called but before it
 *  returns.
 *
 *  Devices may choose to support both the synchronous and asynchronous write
 *  operations, only one of them, or neither of them.
 *
 * @param devhdl Device handle of the device to be read from.
 * @param flags Flags (HV_DEV_xxx).
 * @param sgl_len Number of elements in the scatter-gather list.
 * @param sgl Scatter-gather list describing the memory from which data will be
 *        read.
 * @param offset Driver-dependent offset.  For a random-access device, this is
 *        often a byte offset from the beginning of the device; in other cases,
 *        like on a control device, it may have a different meaning.
 * @param intarg Value which will be delivered as the intarg member of the
 *        eventual interrupt message; the intdata member will be set to the
 *        normal return value from the write request.
 * @return Zero if the write was successfully scheduled; otherwise, a negative
 *         error code.  Note that some drivers may choose to pre-validate
 *         their arguments, and may thus detect certain device error
 *         conditions at this time rather than when the completion notification
 *         occurs, but this is not required.
 */
int hv_dev_pwritea(int devhdl, __hv32 flags, __hv32 sgl_len,
                   HV_SGL sgl[/* sgl_len */], __hv64 offset, HV_IntArg intarg);


/** Define a pair of tile and ASID to identify a user process context. */
typedef struct
{
  /** X coordinate, relative to supervisor's top-left coordinate */
  unsigned int x:11;

  /** Y coordinate, relative to supervisor's top-left coordinate */
  unsigned int y:11;

  /** ASID of the process on this x,y tile */
  HV_ASID asid:10;
} HV_Remote_ASID;

/** Flush cache and/or TLB state on remote tiles.
 *
 * @param cache_pa Client physical address to flush from cache (ignored if
 *        the length encoded in cache_control is zero, or if
 *        HV_FLUSH_EVICT_L2 is set, or if cache_cpumask is NULL).
 * @param cache_control This argument allows you to specify a length of
 *        physical address space to flush (maximum HV_FLUSH_MAX_CACHE_LEN).
 *        You can "or" in HV_FLUSH_EVICT_L2 to flush the whole L2 cache.
 *        You can "or" in HV_FLUSH_EVICT_L1I to flush the whole L1I cache.
 *        HV_FLUSH_ALL flushes all caches.
 * @param cache_cpumask Bitmask (in row-major order, supervisor-relative) of
 *        tile indices to perform cache flush on.  The low bit of the first
 *        word corresponds to the tile at the upper left-hand corner of the
 *        supervisor's rectangle.  If passed as a NULL pointer, equivalent
 *        to an empty bitmask.  On chips which support hash-for-home caching,
 *        if passed as -1, equivalent to a mask containing tiles which could
 *        be doing hash-for-home caching.
 * @param tlb_va Virtual address to flush from TLB (ignored if
 *        tlb_length is zero or tlb_cpumask is NULL).
 * @param tlb_length Number of bytes of data to flush from the TLB.
 * @param tlb_pgsize Page size to use for TLB flushes.
 *        tlb_va and tlb_length need not be aligned to this size.
 * @param tlb_cpumask Bitmask for tlb flush, like cache_cpumask.
 *        If passed as a NULL pointer, equivalent to an empty bitmask.
 * @param asids Pointer to an HV_Remote_ASID array of tile/ASID pairs to flush.
 * @param asidcount Number of HV_Remote_ASID entries in asids[].
 * @return Zero for success, or else HV_EINVAL or HV_EFAULT for errors that
 *        are detected while parsing the arguments.
 */
int hv_flush_remote(HV_PhysAddr cache_pa, unsigned long cache_control,
                    unsigned long* cache_cpumask,
                    HV_VirtAddr tlb_va, unsigned long tlb_length,
                    unsigned long tlb_pgsize, unsigned long* tlb_cpumask,
                    HV_Remote_ASID* asids, int asidcount);

/** Include in cache_control to ensure a flush of the entire L2. */
#define HV_FLUSH_EVICT_L2 (1UL << 31)

/** Include in cache_control to ensure a flush of the entire L1I. */
#define HV_FLUSH_EVICT_L1I (1UL << 30)

/** Maximum legal size to use for the "length" component of cache_control. */
#define HV_FLUSH_MAX_CACHE_LEN ((1UL << 30) - 1)

/** Use for cache_control to ensure a flush of all caches. */
#define HV_FLUSH_ALL -1UL

#else   /* __ASSEMBLER__ */

/** Include in cache_control to ensure a flush of the entire L2. */
#define HV_FLUSH_EVICT_L2 (1 << 31)

/** Include in cache_control to ensure a flush of the entire L1I. */
#define HV_FLUSH_EVICT_L1I (1 << 30)

/** Maximum legal size to use for the "length" component of cache_control. */
#define HV_FLUSH_MAX_CACHE_LEN ((1 << 30) - 1)

/** Use for cache_control to ensure a flush of all caches. */
#define HV_FLUSH_ALL -1

#endif  /* __ASSEMBLER__ */

#ifndef __ASSEMBLER__

/** Return a 64-bit value corresponding to the PTE if needed */
#define hv_pte_val(pte) ((pte).val)

/** Cast a 64-bit value to an HV_PTE */
#define hv_pte(val) ((HV_PTE) { val })

#endif  /* !__ASSEMBLER__ */


/** Bits in the size of an HV_PTE */
#define HV_LOG2_PTE_SIZE 3

/** Size of an HV_PTE */
#define HV_PTE_SIZE (1 << HV_LOG2_PTE_SIZE)


/* Bits in HV_PTE's low word. */
#define HV_PTE_INDEX_PRESENT          0  /**< PTE is valid */
#define HV_PTE_INDEX_MIGRATING        1  /**< Page is migrating */
#define HV_PTE_INDEX_CLIENT0          2  /**< Page client state 0 */
#define HV_PTE_INDEX_CLIENT1          3  /**< Page client state 1 */
#define HV_PTE_INDEX_NC               4  /**< L1$/L2$ incoherent with L3$ */
#define HV_PTE_INDEX_NO_ALLOC_L1      5  /**< Page is uncached in local L1$ */
#define HV_PTE_INDEX_NO_ALLOC_L2      6  /**< Page is uncached in local L2$ */
#define HV_PTE_INDEX_CACHED_PRIORITY  7  /**< Page is priority cached */
#define HV_PTE_INDEX_PAGE             8  /**< PTE describes a page */
#define HV_PTE_INDEX_GLOBAL           9  /**< Page is global */
#define HV_PTE_INDEX_USER            10  /**< Page is user-accessible */
#define HV_PTE_INDEX_ACCESSED        11  /**< Page has been accessed */
#define HV_PTE_INDEX_DIRTY           12  /**< Page has been written */
                                         /*   Bits 13-14 are reserved for
                                              future use. */
#define HV_PTE_INDEX_SUPER           15  /**< Pages ganged together for TLB */
#define HV_PTE_INDEX_MODE            16  /**< Page mode; see HV_PTE_MODE_xxx */
#define HV_PTE_MODE_BITS              3  /**< Number of bits in mode */
#define HV_PTE_INDEX_CLIENT2         19  /**< Page client state 2 */
#define HV_PTE_INDEX_LOTAR           20  /**< Page's LOTAR; must be high bits
                                              of word */
#define HV_PTE_LOTAR_BITS            12  /**< Number of bits in a LOTAR */

/* Bits in HV_PTE's high word. */
#define HV_PTE_INDEX_READABLE        32  /**< Page is readable */
#define HV_PTE_INDEX_WRITABLE        33  /**< Page is writable */
#define HV_PTE_INDEX_EXECUTABLE      34  /**< Page is executable */
#define HV_PTE_INDEX_PTFN            35  /**< Page's PTFN; must be high bits
                                              of word */
#define HV_PTE_PTFN_BITS             29  /**< Number of bits in a PTFN */

/*
 * Legal values for the PTE's mode field
 */
/** Data is not resident in any caches; loads and stores access memory
 *  directly.
 */
#define HV_PTE_MODE_UNCACHED          1

/** Data is resident in the tile's local L1 and/or L2 caches; if a load
 *  or store misses there, it goes to memory.
 *
 *  The copy in the local L1$/L2$ is not invalidated when the copy in
 *  memory is changed.
 */
#define HV_PTE_MODE_CACHE_NO_L3       2

/** Data is resident in the tile's local L1 and/or L2 caches.  If a load
 *  or store misses there, it goes to an L3 cache in a designated tile;
 *  if it misses there, it goes to memory.
 *
 *  If the NC bit is not set, the copy in the local L1$/L2$ is invalidated
 *  when the copy in the remote L3$ is changed.  Otherwise, such
 *  invalidation will not occur.
 *
 *  Chips for which CHIP_HAS_COHERENT_LOCAL_CACHE() is 0 do not support
 *  invalidation from an L3$ to another tile's L1$/L2$.  If the NC bit is
 *  clear on such a chip, no copy is kept in the local L1$/L2$ in this mode.
 */
#define HV_PTE_MODE_CACHE_TILE_L3     3

/** Data is resident in the tile's local L1 and/or L2 caches.  If a load
 *  or store misses there, it goes to an L3 cache in one of a set of
 *  designated tiles; if it misses there, it goes to memory.  Which tile
 *  is chosen from the set depends upon a hash function applied to the
 *  physical address.  This mode is not supported on chips for which
 *  CHIP_HAS_CBOX_HOME_MAP() is 0.
 *
 *  If the NC bit is not set, the copy in the local L1$/L2$ is invalidated
 *  when the copy in the remote L3$ is changed.  Otherwise, such
 *  invalidation will not occur.
 *
 *  Chips for which CHIP_HAS_COHERENT_LOCAL_CACHE() is 0 do not support
 *  invalidation from an L3$ to another tile's L1$/L2$.  If the NC bit is
 *  clear on such a chip, no copy is kept in the local L1$/L2$ in this mode.
 */
#define HV_PTE_MODE_CACHE_HASH_L3     4

/** Data is not resident in memory; accesses are instead made to an I/O
 *  device, whose tile coordinates are given by the PTE's LOTAR field.
 *  This mode is only supported on chips for which CHIP_HAS_MMIO() is 1.
 *  The EXECUTABLE bit may not be set in an MMIO PTE.
 */
#define HV_PTE_MODE_MMIO              5


/* C wants 1ULL so it is typed as __hv64, but the assembler needs just numbers.
 * The assembler can't handle shifts greater than 31, but treats them
 * as shifts mod 32, so assembler code must be aware of which word
 * the bit belongs in when using these macros.
 */
#ifdef __ASSEMBLER__
#define __HV_PTE_ONE 1        /**< One, for assembler */
#else
#define __HV_PTE_ONE 1ULL     /**< One, for C */
#endif

/** Is this PTE present?
 *
 * If this bit is set, this PTE represents a valid translation or level-2
 * page table pointer.  Otherwise, the page table does not contain a
 * translation for the subject virtual pages.
 *
 * If this bit is not set, the other bits in the PTE are not
 * interpreted by the hypervisor, and may contain any value.
 */
#define HV_PTE_PRESENT               (__HV_PTE_ONE << HV_PTE_INDEX_PRESENT)

/** Does this PTE map a page?
 *
 * If this bit is set in a level-0 page table, the entry should be
 * interpreted as a level-2 page table entry mapping a jumbo page.
 *
 * If this bit is set in a level-1 page table, the entry should be
 * interpreted as a level-2 page table entry mapping a large page.
 *
 * This bit should not be modified by the client while PRESENT is set, as
 * doing so may race with the hypervisor's update of ACCESSED and DIRTY bits.
 *
 * In a level-2 page table, this bit is ignored and must be zero.
 */
#define HV_PTE_PAGE                  (__HV_PTE_ONE << HV_PTE_INDEX_PAGE)

/** Does this PTE implicitly reference multiple pages?
 *
 * If this bit is set in the page table (either in the level-2 page table,
 * or in a higher level page table in conjunction with the PAGE bit)
 * then the PTE specifies a range of contiguous pages, not a single page.
 * The hv_set_pte_super_shift() allows you to specify the count for
 * each level of the page table.
 *
 * Note: this bit is not supported on TILEPro systems.
 */
#define HV_PTE_SUPER                 (__HV_PTE_ONE << HV_PTE_INDEX_SUPER)

/** Is this a global (non-ASID) mapping?
 *
 * If this bit is set, the translations established by this PTE will
 * not be flushed from the TLB by the hv_flush_asid() service; they
 * will be flushed by the hv_flush_page() or hv_flush_pages() services.
 *
 * Setting this bit for translations which are identical in all page
 * tables (for instance, code and data belonging to a client OS) can
 * be very beneficial, as it will reduce the number of TLB misses.
 * Note that, while it is not an error which will be detected by the
 * hypervisor, it is an extremely bad idea to set this bit for
 * translations which are _not_ identical in all page tables.
 *
 * This bit should not be modified by the client while PRESENT is set, as
 * doing so may race with the hypervisor's update of ACCESSED and DIRTY bits.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_GLOBAL                (__HV_PTE_ONE << HV_PTE_INDEX_GLOBAL)

/** Is this mapping accessible to users?
 *
 * If this bit is set, code running at any PL will be permitted to
 * access the virtual addresses mapped by this PTE.  Otherwise, only
 * code running at PL 1 or above will be allowed to do so.
 *
 * This bit should not be modified by the client while PRESENT is set, as
 * doing so may race with the hypervisor's update of ACCESSED and DIRTY bits.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_USER                  (__HV_PTE_ONE << HV_PTE_INDEX_USER)

/** Has this mapping been accessed?
 *
 * This bit is set by the hypervisor when the memory described by the
 * translation is accessed for the first time.  It is never cleared by
 * the hypervisor, but may be cleared by the client.  After the bit
 * has been cleared, subsequent references are not guaranteed to set
 * it again until the translation has been flushed from the TLB.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_ACCESSED              (__HV_PTE_ONE << HV_PTE_INDEX_ACCESSED)

/** Is this mapping dirty?
 *
 * This bit is set by the hypervisor when the memory described by the
 * translation is written for the first time.  It is never cleared by
 * the hypervisor, but may be cleared by the client.  After the bit
 * has been cleared, subsequent references are not guaranteed to set
 * it again until the translation has been flushed from the TLB.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_DIRTY                 (__HV_PTE_ONE << HV_PTE_INDEX_DIRTY)

/** Migrating bit in PTE.
 *
 * This bit is guaranteed not to be inspected or modified by the
 * hypervisor.  The name is indicative of the suggested use by the client
 * to tag pages whose L3 cache is being migrated from one cpu to another.
 */
#define HV_PTE_MIGRATING             (__HV_PTE_ONE << HV_PTE_INDEX_MIGRATING)

/** Client-private bit in PTE.
 *
 * This bit is guaranteed not to be inspected or modified by the
 * hypervisor.
 */
#define HV_PTE_CLIENT0               (__HV_PTE_ONE << HV_PTE_INDEX_CLIENT0)

/** Client-private bit in PTE.
 *
 * This bit is guaranteed not to be inspected or modified by the
 * hypervisor.
 */
#define HV_PTE_CLIENT1               (__HV_PTE_ONE << HV_PTE_INDEX_CLIENT1)

/** Client-private bit in PTE.
 *
 * This bit is guaranteed not to be inspected or modified by the
 * hypervisor.
 */
#define HV_PTE_CLIENT2               (__HV_PTE_ONE << HV_PTE_INDEX_CLIENT2)

/** Non-coherent (NC) bit in PTE.
 *
 * If this bit is set, the mapping that is set up will be non-coherent
 * (also known as non-inclusive).  This means that changes to the L3
 * cache will not cause a local copy to be invalidated.  It is generally
 * recommended only for read-only mappings.
 *
 * In level-1 PTEs, if the Page bit is clear, this bit determines how the
 * level-2 page table is accessed.
 */
#define HV_PTE_NC                    (__HV_PTE_ONE << HV_PTE_INDEX_NC)

/** Is this page prevented from filling the L1$?
 *
 * If this bit is set, the page described by the PTE will not be cached
 * the local cpu's L1 cache.
 *
 * If CHIP_HAS_NC_AND_NOALLOC_BITS() is not true in <chip.h> for this chip,
 * it is illegal to use this attribute, and may cause client termination.
 *
 * In level-1 PTEs, if the Page bit is clear, this bit
 * determines how the level-2 page table is accessed.
 */
#define HV_PTE_NO_ALLOC_L1           (__HV_PTE_ONE << HV_PTE_INDEX_NO_ALLOC_L1)

/** Is this page prevented from filling the L2$?
 *
 * If this bit is set, the page described by the PTE will not be cached
 * the local cpu's L2 cache.
 *
 * If CHIP_HAS_NC_AND_NOALLOC_BITS() is not true in <chip.h> for this chip,
 * it is illegal to use this attribute, and may cause client termination.
 *
 * In level-1 PTEs, if the Page bit is clear, this bit determines how the
 * level-2 page table is accessed.
 */
#define HV_PTE_NO_ALLOC_L2           (__HV_PTE_ONE << HV_PTE_INDEX_NO_ALLOC_L2)

/** Is this a priority page?
 *
 * If this bit is set, the page described by the PTE will be given
 * priority in the cache.  Normally this translates into allowing the
 * page to use only the "red" half of the cache.  The client may wish to
 * then use the hv_set_caching service to specify that other pages which
 * alias this page will use only the "black" half of the cache.
 *
 * If the Cached Priority bit is clear, the hypervisor uses the
 * current hv_set_caching() value to choose how to cache the page.
 *
 * It is illegal to set the Cached Priority bit if the Non-Cached bit
 * is set and the Cached Remotely bit is clear, i.e. if requests to
 * the page map directly to memory.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_CACHED_PRIORITY       (__HV_PTE_ONE << \
                                      HV_PTE_INDEX_CACHED_PRIORITY)

/** Is this a readable mapping?
 *
 * If this bit is set, code will be permitted to read from (e.g.,
 * issue load instructions against) the virtual addresses mapped by
 * this PTE.
 *
 * It is illegal for this bit to be clear if the Writable bit is set.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_READABLE              (__HV_PTE_ONE << HV_PTE_INDEX_READABLE)

/** Is this a writable mapping?
 *
 * If this bit is set, code will be permitted to write to (e.g., issue
 * store instructions against) the virtual addresses mapped by this
 * PTE.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_WRITABLE              (__HV_PTE_ONE << HV_PTE_INDEX_WRITABLE)

/** Is this an executable mapping?
 *
 * If this bit is set, code will be permitted to execute from
 * (e.g., jump to) the virtual addresses mapped by this PTE.
 *
 * This bit applies to any processor on the tile, if there are more
 * than one.
 *
 * This bit is ignored in level-1 PTEs unless the Page bit is set.
 */
#define HV_PTE_EXECUTABLE            (__HV_PTE_ONE << HV_PTE_INDEX_EXECUTABLE)

/** The width of a LOTAR's x or y bitfield. */
#define HV_LOTAR_WIDTH 11

/** Converts an x,y pair to a LOTAR value. */
#define HV_XY_TO_LOTAR(x, y) ((HV_LOTAR)(((x) << HV_LOTAR_WIDTH) | (y)))

/** Extracts the X component of a lotar. */
#define HV_LOTAR_X(lotar) ((lotar) >> HV_LOTAR_WIDTH)

/** Extracts the Y component of a lotar. */
#define HV_LOTAR_Y(lotar) ((lotar) & ((1 << HV_LOTAR_WIDTH) - 1))

#ifndef __ASSEMBLER__

/** Define accessor functions for a PTE bit. */
#define _HV_BIT(name, bit)                                      \
static __inline int                                             \
hv_pte_get_##name(HV_PTE pte)                                   \
{                                                               \
  return (pte.val >> HV_PTE_INDEX_##bit) & 1;                   \
}                                                               \
                                                                \
static __inline HV_PTE                                          \
hv_pte_set_##name(HV_PTE pte)                                   \
{                                                               \
  pte.val |= 1ULL << HV_PTE_INDEX_##bit;                        \
  return pte;                                                   \
}                                                               \
                                                                \
static __inline HV_PTE                                          \
hv_pte_clear_##name(HV_PTE pte)                                 \
{                                                               \
  pte.val &= ~(1ULL << HV_PTE_INDEX_##bit);                     \
  return pte;                                                   \
}

/* Generate accessors to get, set, and clear various PTE flags.
 */
_HV_BIT(present,         PRESENT)
_HV_BIT(page,            PAGE)
_HV_BIT(super,           SUPER)
_HV_BIT(client0,         CLIENT0)
_HV_BIT(client1,         CLIENT1)
_HV_BIT(client2,         CLIENT2)
_HV_BIT(migrating,       MIGRATING)
_HV_BIT(nc,              NC)
_HV_BIT(readable,        READABLE)
_HV_BIT(writable,        WRITABLE)
_HV_BIT(executable,      EXECUTABLE)
_HV_BIT(accessed,        ACCESSED)
_HV_BIT(dirty,           DIRTY)
_HV_BIT(no_alloc_l1,     NO_ALLOC_L1)
_HV_BIT(no_alloc_l2,     NO_ALLOC_L2)
_HV_BIT(cached_priority, CACHED_PRIORITY)
_HV_BIT(global,          GLOBAL)
_HV_BIT(user,            USER)

#undef _HV_BIT

/** Get the page mode from the PTE.
 *
 * This field generally determines whether and how accesses to the page
 * are cached; the HV_PTE_MODE_xxx symbols define the legal values for the
 * page mode.  The NC, NO_ALLOC_L1, and NO_ALLOC_L2 bits modify this
 * general policy.
 */
static __inline unsigned int
hv_pte_get_mode(const HV_PTE pte)
{
  return (((__hv32) pte.val) >> HV_PTE_INDEX_MODE) &
         ((1 << HV_PTE_MODE_BITS) - 1);
}

/** Set the page mode into a PTE.  See hv_pte_get_mode. */
static __inline HV_PTE
hv_pte_set_mode(HV_PTE pte, unsigned int val)
{
  pte.val &= ~(((1ULL << HV_PTE_MODE_BITS) - 1) << HV_PTE_INDEX_MODE);
  pte.val |= val << HV_PTE_INDEX_MODE;
  return pte;
}

/** Get the page frame number from the PTE.
 *
 * This field contains the upper bits of the CPA (client physical
 * address) of the target page; the complete CPA is this field with
 * HV_LOG2_PAGE_TABLE_ALIGN zero bits appended to it.
 *
 * For all PTEs in the lowest-level page table, and for all PTEs with
 * the Page bit set in all page tables, the CPA must be aligned modulo
 * the relevant page size.
 */
static __inline unsigned long
hv_pte_get_ptfn(const HV_PTE pte)
{
  return pte.val >> HV_PTE_INDEX_PTFN;
}

/** Set the page table frame number into a PTE.  See hv_pte_get_ptfn. */
static __inline HV_PTE
hv_pte_set_ptfn(HV_PTE pte, unsigned long val)
{
  pte.val &= ~(((1ULL << HV_PTE_PTFN_BITS)-1) << HV_PTE_INDEX_PTFN);
  pte.val |= (__hv64) val << HV_PTE_INDEX_PTFN;
  return pte;
}

/** Get the client physical address from the PTE.  See hv_pte_set_ptfn. */
static __inline HV_PhysAddr
hv_pte_get_pa(const HV_PTE pte)
{
  return (__hv64) hv_pte_get_ptfn(pte) << HV_LOG2_PAGE_TABLE_ALIGN;
}

/** Set the client physical address into a PTE.  See hv_pte_get_ptfn. */
static __inline HV_PTE
hv_pte_set_pa(HV_PTE pte, HV_PhysAddr pa)
{
  return hv_pte_set_ptfn(pte, pa >> HV_LOG2_PAGE_TABLE_ALIGN);
}


/** Get the remote tile caching this page.
 *
 * Specifies the remote tile which is providing the L3 cache for this page.
 *
 * This field is ignored unless the page mode is HV_PTE_MODE_CACHE_TILE_L3.
 *
 * In level-1 PTEs, if the Page bit is clear, this field determines how the
 * level-2 page table is accessed.
 */
static __inline unsigned int
hv_pte_get_lotar(const HV_PTE pte)
{
  unsigned int lotar = ((__hv32) pte.val) >> HV_PTE_INDEX_LOTAR;

  return HV_XY_TO_LOTAR( (lotar >> (HV_PTE_LOTAR_BITS / 2)),
                         (lotar & ((1 << (HV_PTE_LOTAR_BITS / 2)) - 1)) );
}


/** Set the remote tile caching a page into a PTE.  See hv_pte_get_lotar. */
static __inline HV_PTE
hv_pte_set_lotar(HV_PTE pte, unsigned int val)
{
  unsigned int x = HV_LOTAR_X(val);
  unsigned int y = HV_LOTAR_Y(val);

  pte.val &= ~(((1ULL << HV_PTE_LOTAR_BITS)-1) << HV_PTE_INDEX_LOTAR);
  pte.val |= (x << (HV_PTE_INDEX_LOTAR + HV_PTE_LOTAR_BITS / 2)) |
             (y << HV_PTE_INDEX_LOTAR);
  return pte;
}

#endif  /* !__ASSEMBLER__ */

/** Converts a client physical address to a ptfn. */
#define HV_CPA_TO_PTFN(p) ((p) >> HV_LOG2_PAGE_TABLE_ALIGN)

/** Converts a ptfn to a client physical address. */
#define HV_PTFN_TO_CPA(p) (((HV_PhysAddr)(p)) << HV_LOG2_PAGE_TABLE_ALIGN)

#if CHIP_VA_WIDTH() > 32

/*
 * Note that we currently do not allow customizing the page size
 * of the L0 pages, but fix them at 4GB, so we do not use the
 * "_HV_xxx" nomenclature for the L0 macros.
 */

/** Log number of HV_PTE entries in L0 page table */
#define HV_LOG2_L0_ENTRIES (CHIP_VA_WIDTH() - HV_LOG2_L1_SPAN)

/** Number of HV_PTE entries in L0 page table */
#define HV_L0_ENTRIES (1 << HV_LOG2_L0_ENTRIES)

/** Log size of L0 page table in bytes */
#define HV_LOG2_L0_SIZE (HV_LOG2_PTE_SIZE + HV_LOG2_L0_ENTRIES)

/** Size of L0 page table in bytes */
#define HV_L0_SIZE (1 << HV_LOG2_L0_SIZE)

#ifdef __ASSEMBLER__

/** Index in L0 for a specific VA */
#define HV_L0_INDEX(va) \
  (((va) >> HV_LOG2_L1_SPAN) & (HV_L0_ENTRIES - 1))

#else

/** Index in L1 for a specific VA */
#define HV_L0_INDEX(va) \
  (((HV_VirtAddr)(va) >> HV_LOG2_L1_SPAN) & (HV_L0_ENTRIES - 1))

#endif

#endif /* CHIP_VA_WIDTH() > 32 */

/** Log number of HV_PTE entries in L1 page table */
#define _HV_LOG2_L1_ENTRIES(log2_page_size_large) \
  (HV_LOG2_L1_SPAN - log2_page_size_large)

/** Number of HV_PTE entries in L1 page table */
#define _HV_L1_ENTRIES(log2_page_size_large) \
  (1 << _HV_LOG2_L1_ENTRIES(log2_page_size_large))

/** Log size of L1 page table in bytes */
#define _HV_LOG2_L1_SIZE(log2_page_size_large) \
  (HV_LOG2_PTE_SIZE + _HV_LOG2_L1_ENTRIES(log2_page_size_large))

/** Size of L1 page table in bytes */
#define _HV_L1_SIZE(log2_page_size_large) \
  (1 << _HV_LOG2_L1_SIZE(log2_page_size_large))

/** Log number of HV_PTE entries in level-2 page table */
#define _HV_LOG2_L2_ENTRIES(log2_page_size_large, log2_page_size_small) \
  (log2_page_size_large - log2_page_size_small)

/** Number of HV_PTE entries in level-2 page table */
#define _HV_L2_ENTRIES(log2_page_size_large, log2_page_size_small) \
  (1 << _HV_LOG2_L2_ENTRIES(log2_page_size_large, log2_page_size_small))

/** Log size of level-2 page table in bytes */
#define _HV_LOG2_L2_SIZE(log2_page_size_large, log2_page_size_small) \
  (HV_LOG2_PTE_SIZE + \
   _HV_LOG2_L2_ENTRIES(log2_page_size_large, log2_page_size_small))

/** Size of level-2 page table in bytes */
#define _HV_L2_SIZE(log2_page_size_large, log2_page_size_small) \
  (1 << _HV_LOG2_L2_SIZE(log2_page_size_large, log2_page_size_small))

#ifdef __ASSEMBLER__

#if CHIP_VA_WIDTH() > 32

/** Index in L1 for a specific VA */
#define _HV_L1_INDEX(va, log2_page_size_large) \
  (((va) >> log2_page_size_large) & (_HV_L1_ENTRIES(log2_page_size_large) - 1))

#else /* CHIP_VA_WIDTH() > 32 */

/** Index in L1 for a specific VA */
#define _HV_L1_INDEX(va, log2_page_size_large) \
  (((va) >> log2_page_size_large))

#endif /* CHIP_VA_WIDTH() > 32 */

/** Index in level-2 page table for a specific VA */
#define _HV_L2_INDEX(va, log2_page_size_large, log2_page_size_small) \
  (((va) >> log2_page_size_small) & \
   (_HV_L2_ENTRIES(log2_page_size_large, log2_page_size_small) - 1))

#else /* __ASSEMBLER __ */

#if CHIP_VA_WIDTH() > 32

/** Index in L1 for a specific VA */
#define _HV_L1_INDEX(va, log2_page_size_large) \
  (((HV_VirtAddr)(va) >> log2_page_size_large) & \
   (_HV_L1_ENTRIES(log2_page_size_large) - 1))

#else /* CHIP_VA_WIDTH() > 32 */

/** Index in L1 for a specific VA */
#define _HV_L1_INDEX(va, log2_page_size_large) \
  (((HV_VirtAddr)(va) >> log2_page_size_large))

#endif /* CHIP_VA_WIDTH() > 32 */

/** Index in level-2 page table for a specific VA */
#define _HV_L2_INDEX(va, log2_page_size_large, log2_page_size_small) \
  (((HV_VirtAddr)(va) >> log2_page_size_small) & \
   (_HV_L2_ENTRIES(log2_page_size_large, log2_page_size_small) - 1))

#endif /* __ASSEMBLER __ */

/** Position of the PFN field within the PTE (subset of the PTFN). */
#define _HV_PTE_INDEX_PFN(log2_page_size) \
  (HV_PTE_INDEX_PTFN + (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))

/** Length of the PFN field within the PTE (subset of the PTFN). */
#define _HV_PTE_INDEX_PFN_BITS(log2_page_size) \
  (HV_PTE_INDEX_PTFN_BITS - (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))

/** Converts a client physical address to a pfn. */
#define _HV_CPA_TO_PFN(p, log2_page_size) ((p) >> log2_page_size)

/** Converts a pfn to a client physical address. */
#define _HV_PFN_TO_CPA(p, log2_page_size) \
  (((HV_PhysAddr)(p)) << log2_page_size)

/** Converts a ptfn to a pfn. */
#define _HV_PTFN_TO_PFN(p, log2_page_size) \
  ((p) >> (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))

/** Converts a pfn to a ptfn. */
#define _HV_PFN_TO_PTFN(p, log2_page_size) \
  ((p) << (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))

#endif /* _HV_HV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Copyright 2010 Tilera Corporation. All Rights Reserved.
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License
 *   as published by the Free Software Foundation, version 2.
 *
 *   This program is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
 *   NON INFRINGEMENT.  See the GNU General Public License for
 *   more details.
 */

/**
 * NetIO interface structures and macros.
 */

#ifndef __NETIO_INTF_H__
#define __NETIO_INTF_H__

#include <hv/netio_errors.h>

#ifdef __KERNEL__
#include <linux/types.h>
#else
#include <stdint.h>
#endif

#if !defined(__HV__) && !defined(__BOGUX__) && !defined(__KERNEL__)
#include <assert.h>
#define netio_assert assert  /**< Enable assertions from macros */
#else
#define netio_assert(...) ((void)(0))  /**< Disable assertions from macros */
#endif

/*
 * If none of these symbols are defined, we're building libnetio in an
 * environment where we have pthreads, so we'll enable locking.
 */
#if !defined(__HV__) && !defined(__BOGUX__) && !defined(__KERNEL__) && \
    !defined(__NEWLIB__)
#define _NETIO_PTHREAD       /**< Include a mutex in netio_queue_t below */

/*
 * If NETIO_UNLOCKED is defined, we don't do use per-cpu locks on
 * per-packet NetIO operations.  We still do pthread locking on things
 * like netio_input_register, though.  This is used for building
 * libnetio_unlocked.
 */
#ifndef NETIO_UNLOCKED

/* Avoid PLT overhead by using our own inlined per-cpu lock. */
#include <sched.h>
typedef int _netio_percpu_mutex_t;

static __inline int
_netio_percpu_mutex_init(_netio_percpu_mutex_t* lock)
{
  *lock = 0;
  return 0;
}

static __inline int
_netio_percpu_mutex_lock(_netio_percpu_mutex_t* lock)
{
  while (__builtin_expect(__insn_tns(lock), 0))
    sched_yield();
  return 0;
}

static __inline int
_netio_percpu_mutex_unlock(_netio_percpu_mutex_t* lock)
{
  *lock = 0;
  return 0;
}

#else /* NETIO_UNLOCKED */

/* Don't do any locking for per-packet NetIO operations. */
typedef int _netio_percpu_mutex_t;
#define _netio_percpu_mutex_init(L)
#define _netio_percpu_mutex_lock(L)
#define _netio_percpu_mutex_unlock(L)

#endif /* NETIO_UNLOCKED */
#endif /* !__HV__, !__BOGUX, !__KERNEL__, !__NEWLIB__ */

/** How many tiles can register for a given queue.
 *  @ingroup setup */
#define NETIO_MAX_TILES_PER_QUEUE  64


/** Largest permissible queue identifier.
 *  @ingroup setup  */
#define NETIO_MAX_QUEUE_ID        255


#ifndef __DOXYGEN__

/* Metadata packet checksum/ethertype flags. */

/** The L4 checksum has not been calculated. */
#define _NETIO_PKT_NO_L4_CSUM_SHIFT           0
#define _NETIO_PKT_NO_L4_CSUM_RMASK           1
#define _NETIO_PKT_NO_L4_CSUM_MASK \
         (_NETIO_PKT_NO_L4_CSUM_RMASK << _NETIO_PKT_NO_L4_CSUM_SHIFT)

/** The L3 checksum has not been calculated. */
#define _NETIO_PKT_NO_L3_CSUM_SHIFT           1
#define _NETIO_PKT_NO_L3_CSUM_RMASK           1
#define _NETIO_PKT_NO_L3_CSUM_MASK \
         (_NETIO_PKT_NO_L3_CSUM_RMASK << _NETIO_PKT_NO_L3_CSUM_SHIFT)

/** The L3 checksum is incorrect (or perhaps has not been calculated). */
#define _NETIO_PKT_BAD_L3_CSUM_SHIFT          2
#define _NETIO_PKT_BAD_L3_CSUM_RMASK          1
#define _NETIO_PKT_BAD_L3_CSUM_MASK \
         (_NETIO_PKT_BAD_L3_CSUM_RMASK << _NETIO_PKT_BAD_L3_CSUM_SHIFT)

/** The Ethernet packet type is unrecognized. */
#define _NETIO_PKT_TYPE_UNRECOGNIZED_SHIFT    3
#define _NETIO_PKT_TYPE_UNRECOGNIZED_RMASK    1
#define _NETIO_PKT_TYPE_UNRECOGNIZED_MASK \
         (_NETIO_PKT_TYPE_UNRECOGNIZED_RMASK << \
          _NETIO_PKT_TYPE_UNRECOGNIZED_SHIFT)

/* Metadata packet type flags. */

/** Where the packet type bits are; this field is the index into
 *  _netio_pkt_info. */
#define _NETIO_PKT_TYPE_SHIFT        4
#define _NETIO_PKT_TYPE_RMASK        0x3F

/** How many VLAN tags the packet has, and, if we have two, which one we
 *  actually grouped on.  A VLAN within a proprietary (Marvell or Broadcom)
 *  tag is counted here. */
#define _NETIO_PKT_VLAN_SHIFT        4
#define _NETIO_PKT_VLAN_RMASK        0x3
#define _NETIO_PKT_VLAN_MASK \
         (_NETIO_PKT_VLAN_RMASK << _NETIO_PKT_VLAN_SHIFT)
#define _NETIO_PKT_VLAN_NONE         0   /* No VLAN tag. */
#define _NETIO_PKT_VLAN_ONE          1   /* One VLAN tag. */
#define _NETIO_PKT_VLAN_TWO_OUTER    2   /* Two VLAN tags, outer one used. */
#define _NETIO_PKT_VLAN_TWO_INNER    3   /* Two VLAN tags, inner one used. */

/** Which proprietary tags the packet has. */
#define _NETIO_PKT_TAG_SHIFT         6
#define _NETIO_PKT_TAG_RMASK         0x3
#define _NETIO_PKT_TAG_MASK \
          (_NETIO_PKT_TAG_RMASK << _NETIO_PKT_TAG_SHIFT)
#define _NETIO_PKT_TAG_NONE          0   /* No proprietary tags. */
#define _NETIO_PKT_TAG_MRVL          1   /* Marvell HyperG.Stack tags. */
#define _NETIO_PKT_TAG_MRVL_EXT      2   /* HyperG.Stack extended tags. */
#define _NETIO_PKT_TAG_BRCM          3   /* Broadcom HiGig tags. */

/** Whether a packet has an LLC + SNAP header. */
#define _NETIO_PKT_SNAP_SHIFT        8
#define _NETIO_PKT_SNAP_RMASK        0x1
#define _NETIO_PKT_SNAP_MASK \
          (_NETIO_PKT_SNAP_RMASK << _NETIO_PKT_SNAP_SHIFT)

/* NOTE: Bits 9 and 10 are unused. */

/** Length of any custom data before the L2 header, in words. */
#define _NETIO_PKT_CUSTOM_LEN_SHIFT  11
#define _NETIO_PKT_CUSTOM_LEN_RMASK  0x1F
#define _NETIO_PKT_CUSTOM_LEN_MASK \
          (_NETIO_PKT_CUSTOM_LEN_RMASK << _NETIO_PKT_CUSTOM_LEN_SHIFT)

/** The L4 checksum is incorrect (or perhaps has not been calculated). */
#define _NETIO_PKT_BAD_L4_CSUM_SHIFT 16
#define _NETIO_PKT_BAD_L4_CSUM_RMASK 0x1
#define _NETIO_PKT_BAD_L4_CSUM_MASK \
          (_NETIO_PKT_BAD_L4_CSUM_RMASK << _NETIO_PKT_BAD_L4_CSUM_SHIFT)

/** Length of the L2 header, in words. */
#define _NETIO_PKT_L2_LEN_SHIFT  17
#define _NETIO_PKT_L2_LEN_RMASK  0x1F
#define _NETIO_PKT_L2_LEN_MASK \
          (_NETIO_PKT_L2_LEN_RMASK << _NETIO_PKT_L2_LEN_SHIFT)


/* Flags in minimal packet metadata. */

/** We need an eDMA checksum on this packet. */
#define _NETIO_PKT_NEED_EDMA_CSUM_SHIFT            0
#define _NETIO_PKT_NEED_EDMA_CSUM_RMASK            1
#define _NETIO_PKT_NEED_EDMA_CSUM_MASK \
         (_NETIO_PKT_NEED_EDMA_CSUM_RMASK << _NETIO_PKT_NEED_EDMA_CSUM_SHIFT)

/* Data within the packet information table. */

/* Note that, for efficiency, code which uses these fields assumes that none
 * of the shift values below are zero.  See uses below for an explanation. */

/** Offset within the L2 header of the innermost ethertype (in halfwords). */
#define _NETIO_PKT_INFO_ETYPE_SHIFT       6
#define _NETIO_PKT_INFO_ETYPE_RMASK    0x1F

/** Offset within the L2 header of the VLAN tag (in halfwords). */
#define _NETIO_PKT_INFO_VLAN_SHIFT       11
#define _NETIO_PKT_INFO_VLAN_RMASK     0x1F

#endif


/** The size of a memory buffer representing a small packet.
 *  @ingroup egress */
#define SMALL_PACKET_SIZE 256

/** The size of a memory buffer representing a large packet.
 *  @ingroup egress */
#define LARGE_PACKET_SIZE 2048

/** The size of a memory buffer representing a jumbo packet.
 *  @ingroup egress */
#define JUMBO_PACKET_SIZE (12 * 1024)


/* Common ethertypes.
 * @ingroup ingress */
/** @{ */
/** The ethertype of IPv4. */
#define ETHERTYPE_IPv4 (0x0800)
/** The ethertype of ARP. */
#define ETHERTYPE_ARP (0x0806)
/** The ethertype of VLANs. */
#define ETHERTYPE_VLAN (0x8100)
/** The ethertype of a Q-in-Q header. */
#define ETHERTYPE_Q_IN_Q (0x9100)
/** The ethertype of IPv6. */
#define ETHERTYPE_IPv6 (0x86DD)
/** The ethertype of MPLS. */
#define ETHERTYPE_MPLS (0x8847)
/** @} */


/** The possible return values of NETIO_PKT_STATUS.
 * @ingroup ingress
 */
typedef enum
{
  /** No problems were detected with this packet. */
  NETIO_PKT_STATUS_OK,
  /** The packet is undersized; this is expected behavior if the packet's
    * ethertype is unrecognized, but otherwise the packet is likely corrupt. */
  NETIO_PKT_STATUS_UNDERSIZE,
  /** The packet is oversized and some trailing bytes have been discarded.
      This is expected behavior for short packets, since it's impossible to
      precisely determine the amount of padding which may have been added to
      them to make them meet the minimum Ethernet packet size. */
  NETIO_PKT_STATUS_OVERSIZE,
  /** The packet was judged to be corrupt by hardware (for instance, it had
      a bad CRC, or part of it was discarded due to lack of buffer space in
      the I/O shim) and should be discarded. */
  NETIO_PKT_STATUS_BAD
} netio_pkt_status_t;


/** Log2 of how many buckets we have. */
#define NETIO_LOG2_NUM_BUCKETS (10)

/** How many buckets we have.
 * @ingroup ingress */
#define NETIO_NUM_BUCKETS (1 << NETIO_LOG2_NUM_BUCKETS)


/**
 * @brief A group-to-bucket identifier.
 *
 * @ingroup setup
 *
 * This tells us what to do with a given group.
 */
typedef union {
  /** The header broken down into bits. */
  struct {
    /** Whether we should balance on L4, if available */
    unsigned int __balance_on_l4:1;
    /** Whether we should balance on L3, if available */
    unsigned int __balance_on_l3:1;
    /** Whether we should balance on L2, if available */
    unsigned int __balance_on_l2:1;
    /** Reserved for future use */
    unsigned int __reserved:1;
    /** The base bucket to use to send traffic */
    unsigned int __bucket_base:NETIO_LOG2_NUM_BUCKETS;
    /** The mask to apply to the balancing value. This must be one less
     * than a power of two, e.g. 0x3 or 0xFF.
     */
    unsigned int __bucket_mask:NETIO_LOG2_NUM_BUCKETS;
    /** Pad to 32 bits */
    unsigned int __padding:(32 - 4 - 2 * NETIO_LOG2_NUM_BUCKETS);
  } bits;
  /** To send out the IDN. */
  unsigned int word;
}
netio_group_t;


/**
 * @brief A VLAN-to-bucket identifier.
 *
 * @ingroup setup
 *
 * This tells us what to do with a given VLAN.
 */
typedef netio_group_t netio_vlan_t;


/**
 * A bucket-to-queue mapping.
 * @ingroup setup
 */
typedef unsigned char netio_bucket_t;


/**
 * A packet size can always fit in a netio_size_t.
 * @ingroup setup
 */
typedef unsigned int netio_size_t;


/**
 * @brief Ethernet standard (ingress) packet metadata.
 *
 * @ingroup ingress
 *
 * This is additional data associated with each packet.
 * This structure is opaque and accessed through the @ref ingress.
 *
 * Also, the buffer population operation currently assumes that standard
 * metadata is at least as large as minimal metadata, and will need to be
 * modified if that is no longer the case.
 */
typedef struct
{
#ifdef __DOXYGEN__
  /** This structure is opaque. */
  unsigned char opaque[24];
#else
  /** The overall ordinal of the packet */
  unsigned int __packet_ordinal;
  /** The ordinal of the packet within the group */
  unsigned int __group_ordinal;
  /** The best flow hash IPP could compute. */
  unsigned int __flow_hash;
  /** Flags pertaining to checksum calculation, packet type, etc. */
  unsigned int __flags;
  /** The first word of "user data". */
  unsigned int __user_data_0;
  /** The second word of "user data". */
  unsigned int __user_data_1;
#endif
}
netio_pkt_metadata_t;


/** To ensure that the L3 header is aligned mod 4, the L2 header should be
 * aligned mod 4 plus 2, since every supported L2 header is 4n + 2 bytes
 * long.  The standard way to do this is to simply add 2 bytes of padding
 * before the L2 header.
 */
#define NETIO_PACKET_PADDING 2



/**
 * @brief Ethernet minimal (egress) packet metadata.
 *
 * @ingroup egress
 *
 * This structure represents information about packets which have
 * been processed by @ref netio_populate_buffer() or
 * @ref netio_populate_prepend_buffer().  This structure is opaque
 * and accessed through the @ref egress.
 *
 * @internal This structure is actually copied into the memory used by
 * standard metadata, which is assumed to be large enough.
 */
typedef struct
{
#ifdef __DOXYGEN__
  /** This structure is opaque. */
  unsigned char opaque[14];
#else
  /** The offset of the L2 header from the start of the packet data. */
  unsigned short l2_offset;
  /** The offset of the L3 header from the start of the packet data. */
  unsigned short l3_offset;
  /** Where to write the checksum. */
  unsigned char csum_location;
  /** Where to start checksumming from. */
  unsigned char csum_start;
  /** Flags pertaining to checksum calculation etc. */
  unsigned short flags;
  /** The L2 length of the packet. */
  unsigned short l2_length;
  /** The checksum with which to seed the checksum generator. */
  unsigned short csum_seed;
  /** How much to checksum. */
  unsigned short csum_length;
#endif
}
netio_pkt_minimal_metadata_t;


#ifndef __DOXYGEN__

/**
 * @brief An I/O notification header.
 *
 * This is the first word of data received from an I/O shim in a notification
 * packet. It contains framing and status information.
 */
typedef union
{
  unsigned int word; /**< The whole word. */
  /** The various fields. */
  struct
  {
    unsigned int __channel:7;    /**< Resource channel. */
    unsigned int __type:4;       /**< Type. */
    unsigned int __ack:1;        /**< Whether an acknowledgement is needed. */
    unsigned int __reserved:1;   /**< Reserved. */
    unsigned int __protocol:1;   /**< A protocol-specific word is added. */
    unsigned int __status:2;     /**< Status of the transfer. */
    unsigned int __framing:2;    /**< Framing of the transfer. */
    unsigned int __transfer_size:14; /**< Transfer size in bytes (total). */
  } bits;
}
__netio_pkt_notif_t;


/**
 * Returns the base address of the packet.
 */
#define _NETIO_PKT_HANDLE_BASE(p) \
  ((unsigned char*)((p).word & 0xFFFFFFC0))

/**
 * Returns the base address of the packet.
 */
#define _NETIO_PKT_BASE(p) \
  _NETIO_PKT_HANDLE_BASE(p->__packet)

/**
 * @brief An I/O notification packet (second word)
 *
 * This is the second word of data received from an I/O shim in a notification
 * packet.  This is the virtual address of the packet buffer, plus some flag
 * bits.  (The virtual address of the packet is always 256-byte aligned so we
 * have room for 8 bits' worth of flags in the low 8 bits.)
 *
 * @internal
 * NOTE: The low two bits must contain "__queue", so the "packet size"
 * (SIZE_SMALL, SIZE_LARGE, or SIZE_JUMBO) can be determined quickly.
 *
 * If __addr or __offset are moved, _NETIO_PKT_BASE
 * (defined right below this) must be changed.
 */
typedef union
{
  unsigned int word; /**< The whole word. */
  /** The various fields. */
  struct
  {
    /** Which queue the packet will be returned to once it is sent back to
        the IPP.  This is one of the SIZE_xxx values. */
    unsigned int __queue:2;

    /** The IPP handle of the sending IPP. */
    unsigned int __ipp_handle:2;

    /** Reserved for future use. */
    unsigned int __reserved:1;

    /** If 1, this packet has minimal (egress) metadata; otherwise, it
        has standard (ingress) metadata. */
    unsigned int __minimal:1;

    /** Offset of the metadata within the packet.  This value is multiplied
     *  by 64 and added to the base packet address to get the metadata
     *  address.  Note that this field is aligned within the word such that
     *  you can easily extract the metadata address with a 26-bit mask. */
    unsigned int __offset:2;

    /** The top 24 bits of the packet's virtual address. */
    unsigned int __addr:24;
  } bits;
}
__netio_pkt_handle_t;

#endif /* !__DOXYGEN__ */


/**
 * @brief A handle for an I/O packet's storage.
 * @ingroup ingress
 *
 * netio_pkt_handle_t encodes the concept of a ::netio_pkt_t with its
 * packet metadata removed.  It is a much smaller type that exists to
 * facilitate applications where the full ::netio_pkt_t type is too
 * large, such as those that cache enormous numbers of packets or wish
 * to transmit packet descriptors over the UDN.
 *
 * Because there is no metadata, most ::netio_pkt_t operations cannot be
 * performed on a netio_pkt_handle_t.  It supports only
 * netio_free_handle() (to free the buffer) and
 * NETIO_PKT_CUSTOM_DATA_H() (to access a pointer to its contents).
 * The application must acquire any additional metadata it wants from the
 * original ::netio_pkt_t and record it separately.
 *
 * A netio_pkt_handle_t can be extracted from a ::netio_pkt_t by calling
 * NETIO_PKT_HANDLE().  An invalid handle (analogous to NULL) can be
 * created by assigning the value ::NETIO_PKT_HANDLE_NONE. A handle can
 * be tested for validity with NETIO_PKT_HANDLE_IS_VALID().
 */
typedef struct
{
  unsigned int word; /**< Opaque bits. */
} netio_pkt_handle_t;

/**
 * @brief A packet descriptor.
 *
 * @ingroup ingress
 * @ingroup egress
 *
 * This data structure represents a packet.  The structure is manipulated
 * through the @ref ingress and the @ref egress.
 *
 * While the contents of a netio_pkt_t are opaque, the structure itself is
 * portable.  This means that it may be shared between all tiles which have
 * done a netio_input_register() call for the interface on which the pkt_t
 * was initially received (via netio_get_packet()) or retrieved (via
 * netio_get_buffer()).  The contents of a netio_pkt_t can be transmitted to
 * another tile via shared memory, or via a UDN message, or by other means.
 * The destination tile may then use the pkt_t as if it had originally been
 * received locally; it may read or write the packet's data, read its
 * metadata, free the packet, send the packet, transfer the netio_pkt_t to
 * yet another tile, and so forth.
 *
 * Once a netio_pkt_t has been transferred to a second tile, the first tile
 * should not reference the original copy; in particular, if more than one
 * tile frees or sends the same netio_pkt_t, the IPP's packet free lists will
 * become corrupted.  Note also that each tile which reads or modifies
 * packet data must obey the memory coherency rules outlined in @ref input.
 */
typedef struct
{
#ifdef __DOXYGEN__
  /** This structure is opaque. */
  unsigned char opaque[32];
#else
  /** For an ingress packet (one with standard metadata), this is the
   *  notification header we got from the I/O shim.  For an egress packet
   *  (one with minimal metadata), this word is zero if the packet has not
   *  been populated, and nonzero if it has. */
  __netio_pkt_notif_t __notif_header;

  /** Virtual address of the packet buffer, plus state flags. */
  __netio_pkt_handle_t __packet;

  /** Metadata associated with the packet. */
  netio_pkt_metadata_t __metadata;
#endif
}
netio_pkt_t;


#ifndef __DOXYGEN__

#define __NETIO_PKT_NOTIF_HEADER(pkt) ((pkt)->__notif_header)
#define __NETIO_PKT_IPP_HANDLE(pkt) ((pkt)->__packet.bits.__ipp_handle)
#define __NETIO_PKT_QUEUE(pkt) ((pkt)->__packet.bits.__queue)
#define __NETIO_PKT_NOTIF_HEADER_M(mda, pkt) ((pkt)->__notif_header)
#define __NETIO_PKT_IPP_HANDLE_M(mda, pkt) ((pkt)->__packet.bits.__ipp_handle)
#define __NETIO_PKT_MINIMAL(pkt) ((pkt)->__packet.bits.__minimal)
#define __NETIO_PKT_QUEUE_M(mda, pkt) ((pkt)->__packet.bits.__queue)
#define __NETIO_PKT_FLAGS_M(mda, pkt) ((mda)->__flags)

/* Packet information table, used by the attribute access functions below. */
extern const uint16_t _netio_pkt_info[];

#endif /* __DOXYGEN__ */


#ifndef __DOXYGEN__
/* These macros are deprecated and will disappear in a future MDE release. */
#define NETIO_PKT_GOOD_CHECKSUM(pkt) \
  NETIO_PKT_L4_CSUM_CORRECT(pkt)
#define NETIO_PKT_GOOD_CHECKSUM_M(mda, pkt) \
  NETIO_PKT_L4_CSUM_CORRECT_M(mda, pkt)
#endif /* __DOXYGEN__ */


/* Packet attribute access functions. */

/** Return a pointer to the metadata for a packet.
 * @ingroup ingress
 *
 * Calling this function once and passing the result to other retrieval
 * functions with a "_M" suffix usually improves performance.  This
 * function must be called on an 'ingress' packet (i.e. one retrieved
 * by @ref netio_get_packet(), on which @ref netio_populate_buffer() or
 * @ref netio_populate_prepend_buffer have not been called). Use of this
 * function on an 'egress' packet will cause an assertion failure.
 *
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to the packet's standard metadata.
 */
static __inline netio_pkt_metadata_t*
NETIO_PKT_METADATA(netio_pkt_t* pkt)
{
  netio_assert(!pkt->__packet.bits.__minimal);
  return &pkt->__metadata;
}


/** Return a pointer to the minimal metadata for a packet.
 * @ingroup egress
 *
 * Calling this function once and passing the result to other retrieval
 * functions with a "_MM" suffix usually improves performance.  This
 * function must be called on an 'egress' packet (i.e. one on which
 * @ref netio_populate_buffer() or @ref netio_populate_prepend_buffer()
 * have been called, or one retrieved by @ref netio_get_buffer()). Use of
 * this function on an 'ingress' packet will cause an assertion failure.
 *
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to the packet's standard metadata.
 */
static __inline netio_pkt_minimal_metadata_t*
NETIO_PKT_MINIMAL_METADATA(netio_pkt_t* pkt)
{
  netio_assert(pkt->__packet.bits.__minimal);
  return (netio_pkt_minimal_metadata_t*) &pkt->__metadata;
}


/** Determine whether a packet has 'minimal' metadata.
 * @ingroup pktfuncs
 *
 * This function will return nonzero if the packet is an 'egress'
 * packet (i.e. one on which @ref netio_populate_buffer() or
 * @ref netio_populate_prepend_buffer() have been called, or one
 * retrieved by @ref netio_get_buffer()), and zero if the packet
 * is an 'ingress' packet (i.e. one retrieved by @ref netio_get_packet(),
 * which has not been converted into an 'egress' packet).
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the packet has minimal metadata.
 */
static __inline unsigned int
NETIO_PKT_IS_MINIMAL(netio_pkt_t* pkt)
{
  return pkt->__packet.bits.__minimal;
}


/** Return a handle for a packet's storage.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return A handle for the packet's storage.
 */
static __inline netio_pkt_handle_t
NETIO_PKT_HANDLE(netio_pkt_t* pkt)
{
  netio_pkt_handle_t h;
  h.word = pkt->__packet.word;
  return h;
}


/** A special reserved value indicating the absence of a packet handle.
 *
 * @ingroup pktfuncs
 */
#define NETIO_PKT_HANDLE_NONE ((netio_pkt_handle_t) { 0 })


/** Test whether a packet handle is valid.
 *
 * Applications may wish to use the reserved value NETIO_PKT_HANDLE_NONE
 * to indicate no packet at all.  This function tests to see if a packet
 * handle is a real handle, not this special reserved value.
 *
 * @ingroup pktfuncs
 *
 * @param[in] handle Handle on which to operate.
 * @return One if the packet handle is valid, else zero.
 */
static __inline unsigned int
NETIO_PKT_HANDLE_IS_VALID(netio_pkt_handle_t handle)
{
  return handle.word != 0;
}



/** Return a pointer to the start of the packet's custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 * @ingroup ingress
 *
 * @param[in] handle Handle on which to operate.
 * @return A pointer to start of the packet.
 */
static __inline unsigned char*
NETIO_PKT_CUSTOM_DATA_H(netio_pkt_handle_t handle)
{
  return _NETIO_PKT_HANDLE_BASE(handle) + NETIO_PACKET_PADDING;
}


/** Return the length of the packet's custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 *
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet's custom header, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_CUSTOM_HEADER_LENGTH_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  /*
   * Note that we effectively need to extract a quantity from the flags word
   * which is measured in words, and then turn it into bytes by shifting
   * it left by 2.  We do this all at once by just shifting right two less
   * bits, and shifting the mask up two bits.
   */
  return ((mda->__flags >> (_NETIO_PKT_CUSTOM_LEN_SHIFT - 2)) &
          (_NETIO_PKT_CUSTOM_LEN_RMASK << 2));
}


/** Return the length of the packet, starting with the custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_CUSTOM_LENGTH_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (__NETIO_PKT_NOTIF_HEADER(pkt).bits.__transfer_size -
          NETIO_PACKET_PADDING);
}


/** Return a pointer to the start of the packet's custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to start of the packet.
 */
static __inline unsigned char*
NETIO_PKT_CUSTOM_DATA_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return NETIO_PKT_CUSTOM_DATA_H(NETIO_PKT_HANDLE(pkt));
}


/** Return the length of the packet's L2 (Ethernet plus VLAN or SNAP) header.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet's L2 header, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L2_HEADER_LENGTH_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  /*
   * Note that we effectively need to extract a quantity from the flags word
   * which is measured in words, and then turn it into bytes by shifting
   * it left by 2.  We do this all at once by just shifting right two less
   * bits, and shifting the mask up two bits.  We then add two bytes.
   */
  return ((mda->__flags >> (_NETIO_PKT_L2_LEN_SHIFT - 2)) &
          (_NETIO_PKT_L2_LEN_RMASK << 2)) + 2;
}


/** Return the length of the packet, starting with the L2 (Ethernet) header.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L2_LENGTH_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (NETIO_PKT_CUSTOM_LENGTH_M(mda, pkt) -
          NETIO_PKT_CUSTOM_HEADER_LENGTH_M(mda,pkt));
}


/** Return a pointer to the start of the packet's L2 (Ethernet) header.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to start of the packet.
 */
static __inline unsigned char*
NETIO_PKT_L2_DATA_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (NETIO_PKT_CUSTOM_DATA_M(mda, pkt) +
          NETIO_PKT_CUSTOM_HEADER_LENGTH_M(mda, pkt));
}


/** Retrieve the length of the packet, starting with the L3 (generally,
 *  the IP) header.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Length of the packet's L3 header and data, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L3_LENGTH_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (NETIO_PKT_L2_LENGTH_M(mda, pkt) -
          NETIO_PKT_L2_HEADER_LENGTH_M(mda,pkt));
}


/** Return a pointer to the packet's L3 (generally, the IP) header.
 * @ingroup ingress
 *
 * Note that we guarantee word alignment of the L3 header.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to the packet's L3 header.
 */
static __inline unsigned char*
NETIO_PKT_L3_DATA_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (NETIO_PKT_L2_DATA_M(mda, pkt) +
          NETIO_PKT_L2_HEADER_LENGTH_M(mda, pkt));
}


/** Return the ordinal of the packet.
 * @ingroup ingress
 *
 * Each packet is given an ordinal number when it is delivered by the IPP.
 * In the medium term, the ordinal is unique and monotonically increasing,
 * being incremented by 1 for each packet; the ordinal of the first packet
 * delivered after the IPP starts is zero.  (Since the ordinal is of finite
 * size, given enough input packets, it will eventually wrap around to zero;
 * in the long term, therefore, ordinals are not unique.)  The ordinals
 * handed out by different IPPs are not disjoint, so two packets from
 * different IPPs may have identical ordinals.  Packets dropped by the
 * IPP or by the I/O shim are not assigned ordinals.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's per-IPP packet ordinal.
 */
static __inline unsigned int
NETIO_PKT_ORDINAL_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return mda->__packet_ordinal;
}


/** Return the per-group ordinal of the packet.
 * @ingroup ingress
 *
 * Each packet is given a per-group ordinal number when it is
 * delivered by the IPP. By default, the group is the packet's VLAN,
 * although IPP can be recompiled to use different values.  In
 * the medium term, the ordinal is unique and monotonically
 * increasing, being incremented by 1 for each packet; the ordinal of
 * the first packet distributed to a particular group is zero.
 * (Since the ordinal is of finite size, given enough input packets,
 * it will eventually wrap around to zero; in the long term,
 * therefore, ordinals are not unique.)  The ordinals handed out by
 * different IPPs are not disjoint, so two packets from different IPPs
 * may have identical ordinals; similarly, packets distributed to
 * different groups may have identical ordinals.  Packets dropped by
 * the IPP or by the I/O shim are not assigned ordinals.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's per-IPP, per-group ordinal.
 */
static __inline unsigned int
NETIO_PKT_GROUP_ORDINAL_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return mda->__group_ordinal;
}


/** Return the VLAN ID assigned to the packet.
 * @ingroup ingress
 *
 * This value is usually contained within the packet header.
 *
 * This value will be zero if the packet does not have a VLAN tag, or if
 * this value was not extracted from the packet.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's VLAN ID.
 */
static __inline unsigned short
NETIO_PKT_VLAN_ID_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  int vl = (mda->__flags >> _NETIO_PKT_VLAN_SHIFT) & _NETIO_PKT_VLAN_RMASK;
  unsigned short* pkt_p;
  int index;
  unsigned short val;

  if (vl == _NETIO_PKT_VLAN_NONE)
    return 0;

  pkt_p = (unsigned short*) NETIO_PKT_L2_DATA_M(mda, pkt);
  index = (mda->__flags >> _NETIO_PKT_TYPE_SHIFT) & _NETIO_PKT_TYPE_RMASK;

  val = pkt_p[(_netio_pkt_info[index] >> _NETIO_PKT_INFO_VLAN_SHIFT) &
              _NETIO_PKT_INFO_VLAN_RMASK];

#ifdef __TILECC__
  return (__insn_bytex(val) >> 16) & 0xFFF;
#else
  return (__builtin_bswap32(val) >> 16) & 0xFFF;
#endif
}


/** Return the ethertype of the packet.
 * @ingroup ingress
 *
 * This value is usually contained within the packet header.
 *
 * This value is reliable if @ref NETIO_PKT_ETHERTYPE_RECOGNIZED_M()
 * returns true, and otherwise, may not be well defined.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's ethertype.
 */
static __inline unsigned short
NETIO_PKT_ETHERTYPE_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  unsigned short* pkt_p = (unsigned short*) NETIO_PKT_L2_DATA_M(mda, pkt);
  int index = (mda->__flags >> _NETIO_PKT_TYPE_SHIFT) & _NETIO_PKT_TYPE_RMASK;

  unsigned short val =
    pkt_p[(_netio_pkt_info[index] >> _NETIO_PKT_INFO_ETYPE_SHIFT) &
          _NETIO_PKT_INFO_ETYPE_RMASK];

  return __builtin_bswap32(val) >> 16;
}


/** Return the flow hash computed on the packet.
 * @ingroup ingress
 *
 * For TCP and UDP packets, this hash is calculated by hashing together
 * the "5-tuple" values, specifically the source IP address, destination
 * IP address, protocol type, source port and destination port.
 * The hash value is intended to be helpful for millions of distinct
 * flows.
 *
 * For IPv4 or IPv6 packets which are neither TCP nor UDP, the flow hash is
 * derived by hashing together the source and destination IP addresses.
 *
 * For MPLS-encapsulated packets, the flow hash is derived by hashing
 * the first MPLS label.
 *
 * For all other packets the flow hash is computed from the source
 * and destination Ethernet addresses.
 *
 * The hash is symmetric, meaning it produces the same value if the
 * source and destination are swapped. The only exceptions are
 * tunneling protocols 0x04 (IP in IP Encapsulation), 0x29 (Simple
 * Internet Protocol), 0x2F (General Routing Encapsulation) and 0x32
 * (Encap Security Payload), which use only the destination address
 * since the source address is not meaningful.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's 32-bit flow hash.
 */
static __inline unsigned int
NETIO_PKT_FLOW_HASH_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return mda->__flow_hash;
}


/** Return the first word of "user data" for the packet.
 *
 * The contents of the user data words depend on the IPP.
 *
 * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the first
 * word of user data contains the least significant bits of the 64-bit
 * arrival cycle count (see @c get_cycle_count_low()).
 *
 * See the <em>System Programmer's Guide</em> for details.
 *
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's first word of "user data".
 */
static __inline unsigned int
NETIO_PKT_USER_DATA_0_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return mda->__user_data_0;
}


/** Return the second word of "user data" for the packet.
 *
 * The contents of the user data words depend on the IPP.
 *
 * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the second
 * word of user data contains the most significant bits of the 64-bit
 * arrival cycle count (see @c get_cycle_count_high()).
 *
 * See the <em>System Programmer's Guide</em> for details.
 *
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's second word of "user data".
 */
static __inline unsigned int
NETIO_PKT_USER_DATA_1_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return mda->__user_data_1;
}


/** Determine whether the L4 (TCP/UDP) checksum was calculated.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the L4 checksum was calculated.
 */
static __inline unsigned int
NETIO_PKT_L4_CSUM_CALCULATED_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return !(mda->__flags & _NETIO_PKT_NO_L4_CSUM_MASK);
}


/** Determine whether the L4 (TCP/UDP) checksum was calculated and found to
 *  be correct.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the checksum was calculated and is correct.
 */
static __inline unsigned int
NETIO_PKT_L4_CSUM_CORRECT_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return !(mda->__flags &
           (_NETIO_PKT_BAD_L4_CSUM_MASK | _NETIO_PKT_NO_L4_CSUM_MASK));
}


/** Determine whether the L3 (IP) checksum was calculated.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the L3 (IP) checksum was calculated.
*/
static __inline unsigned int
NETIO_PKT_L3_CSUM_CALCULATED_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return !(mda->__flags & _NETIO_PKT_NO_L3_CSUM_MASK);
}


/** Determine whether the L3 (IP) checksum was calculated and found to be
 *  correct.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the checksum was calculated and is correct.
 */
static __inline unsigned int
NETIO_PKT_L3_CSUM_CORRECT_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return !(mda->__flags &
           (_NETIO_PKT_BAD_L3_CSUM_MASK | _NETIO_PKT_NO_L3_CSUM_MASK));
}


/** Determine whether the ethertype was recognized and L3 packet data was
 *  processed.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the ethertype was recognized and L3 packet data was
 *   processed.
 */
static __inline unsigned int
NETIO_PKT_ETHERTYPE_RECOGNIZED_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return !(mda->__flags & _NETIO_PKT_TYPE_UNRECOGNIZED_MASK);
}


/** Retrieve the status of a packet and any errors that may have occurred
 * during ingress processing (length mismatches, CRC errors, etc.).
 * @ingroup ingress
 *
 * Note that packets for which @ref NETIO_PKT_ETHERTYPE_RECOGNIZED()
 * returns zero are always reported as underlength, as there is no a priori
 * means to determine their length.  Normally, applications should use
 * @ref NETIO_PKT_BAD_M() instead of explicitly checking status with this
 * function.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The packet's status.
 */
static __inline netio_pkt_status_t
NETIO_PKT_STATUS_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (netio_pkt_status_t) __NETIO_PKT_NOTIF_HEADER(pkt).bits.__status;
}


/** Report whether a packet is bad (i.e., was shorter than expected based on
 *  its headers, or had a bad CRC).
 * @ingroup ingress
 *
 * Note that this function does not verify L3 or L4 checksums.
 *
 * @param[in] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the packet is bad and should be discarded.
 */
static __inline unsigned int
NETIO_PKT_BAD_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return ((NETIO_PKT_STATUS_M(mda, pkt) & 1) &&
          (NETIO_PKT_ETHERTYPE_RECOGNIZED_M(mda, pkt) ||
           NETIO_PKT_STATUS_M(mda, pkt) == NETIO_PKT_STATUS_BAD));
}


/** Return the length of the packet, starting with the L2 (Ethernet) header.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L2_LENGTH_MM(netio_pkt_minimal_metadata_t* mmd, netio_pkt_t* pkt)
{
  return mmd->l2_length;
}


/** Return the length of the L2 (Ethernet) header.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet's L2 header, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L2_HEADER_LENGTH_MM(netio_pkt_minimal_metadata_t* mmd,
                              netio_pkt_t* pkt)
{
  return mmd->l3_offset - mmd->l2_offset;
}


/** Return the length of the packet, starting with the L3 (IP) header.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @return Length of the packet's L3 header and data, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L3_LENGTH_MM(netio_pkt_minimal_metadata_t* mmd, netio_pkt_t* pkt)
{
  return (NETIO_PKT_L2_LENGTH_MM(mmd, pkt) -
          NETIO_PKT_L2_HEADER_LENGTH_MM(mmd, pkt));
}


/** Return a pointer to the packet's L3 (generally, the IP) header.
 * @ingroup egress
 *
 * Note that we guarantee word alignment of the L3 header.
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to the packet's L3 header.
 */
static __inline unsigned char*
NETIO_PKT_L3_DATA_MM(netio_pkt_minimal_metadata_t* mmd, netio_pkt_t* pkt)
{
  return _NETIO_PKT_BASE(pkt) + mmd->l3_offset;
}


/** Return a pointer to the packet's L2 (Ethernet) header.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to start of the packet.
 */
static __inline unsigned char*
NETIO_PKT_L2_DATA_MM(netio_pkt_minimal_metadata_t* mmd, netio_pkt_t* pkt)
{
  return _NETIO_PKT_BASE(pkt) + mmd->l2_offset;
}


/** Retrieve the status of a packet and any errors that may have occurred
 * during ingress processing (length mismatches, CRC errors, etc.).
 * @ingroup ingress
 *
 * Note that packets for which @ref NETIO_PKT_ETHERTYPE_RECOGNIZED()
 * returns zero are always reported as underlength, as there is no a priori
 * means to determine their length.  Normally, applications should use
 * @ref NETIO_PKT_BAD() instead of explicitly checking status with this
 * function.
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's status.
 */
static __inline netio_pkt_status_t
NETIO_PKT_STATUS(netio_pkt_t* pkt)
{
  netio_assert(!pkt->__packet.bits.__minimal);

  return (netio_pkt_status_t) __NETIO_PKT_NOTIF_HEADER(pkt).bits.__status;
}


/** Report whether a packet is bad (i.e., was shorter than expected based on
 *  its headers, or had a bad CRC).
 * @ingroup ingress
 *
 * Note that this function does not verify L3 or L4 checksums.
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the packet is bad and should be discarded.
 */
static __inline unsigned int
NETIO_PKT_BAD(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_BAD_M(mda, pkt);
}


/** Return the length of the packet's custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet's custom header, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_CUSTOM_HEADER_LENGTH(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_CUSTOM_HEADER_LENGTH_M(mda, pkt);
}


/** Return the length of the packet, starting with the custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return  The length of the packet, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_CUSTOM_LENGTH(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_CUSTOM_LENGTH_M(mda, pkt);
}


/** Return a pointer to the packet's custom header.
 *  A custom header may or may not be present, depending upon the IPP; its
 *  contents and alignment are also IPP-dependent.  Currently, none of the
 *  standard IPPs supplied by Tilera produce a custom header.  If present,
 *  the custom header precedes the L2 header in the packet buffer.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to start of the packet.
 */
static __inline unsigned char*
NETIO_PKT_CUSTOM_DATA(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_CUSTOM_DATA_M(mda, pkt);
}


/** Return the length of the packet's L2 (Ethernet plus VLAN or SNAP) header.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return The length of the packet's L2 header, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L2_HEADER_LENGTH(netio_pkt_t* pkt)
{
  if (NETIO_PKT_IS_MINIMAL(pkt))
  {
    netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

    return NETIO_PKT_L2_HEADER_LENGTH_MM(mmd, pkt);
  }
  else
  {
    netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

    return NETIO_PKT_L2_HEADER_LENGTH_M(mda, pkt);
  }
}


/** Return the length of the packet, starting with the L2 (Ethernet) header.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return  The length of the packet, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L2_LENGTH(netio_pkt_t* pkt)
{
  if (NETIO_PKT_IS_MINIMAL(pkt))
  {
    netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

    return NETIO_PKT_L2_LENGTH_MM(mmd, pkt);
  }
  else
  {
    netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

    return NETIO_PKT_L2_LENGTH_M(mda, pkt);
  }
}


/** Return a pointer to the packet's L2 (Ethernet) header.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to start of the packet.
 */
static __inline unsigned char*
NETIO_PKT_L2_DATA(netio_pkt_t* pkt)
{
  if (NETIO_PKT_IS_MINIMAL(pkt))
  {
    netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

    return NETIO_PKT_L2_DATA_MM(mmd, pkt);
  }
  else
  {
    netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

    return NETIO_PKT_L2_DATA_M(mda, pkt);
  }
}


/** Retrieve the length of the packet, starting with the L3 (generally, the IP)
 * header.
 * @ingroup pktfuncs
 *
 * @param[in] pkt Packet on which to operate.
 * @return Length of the packet's L3 header and data, in bytes.
 */
static __inline netio_size_t
NETIO_PKT_L3_LENGTH(netio_pkt_t* pkt)
{
  if (NETIO_PKT_IS_MINIMAL(pkt))
  {
    netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

    return NETIO_PKT_L3_LENGTH_MM(mmd, pkt);
  }
  else
  {
    netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

    return NETIO_PKT_L3_LENGTH_M(mda, pkt);
  }
}


/** Return a pointer to the packet's L3 (generally, the IP) header.
 * @ingroup pktfuncs
 *
 * Note that we guarantee word alignment of the L3 header.
 *
 * @param[in] pkt Packet on which to operate.
 * @return A pointer to the packet's L3 header.
 */
static __inline unsigned char*
NETIO_PKT_L3_DATA(netio_pkt_t* pkt)
{
  if (NETIO_PKT_IS_MINIMAL(pkt))
  {
    netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

    return NETIO_PKT_L3_DATA_MM(mmd, pkt);
  }
  else
  {
    netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

    return NETIO_PKT_L3_DATA_M(mda, pkt);
  }
}


/** Return the ordinal of the packet.
 * @ingroup ingress
 *
 * Each packet is given an ordinal number when it is delivered by the IPP.
 * In the medium term, the ordinal is unique and monotonically increasing,
 * being incremented by 1 for each packet; the ordinal of the first packet
 * delivered after the IPP starts is zero.  (Since the ordinal is of finite
 * size, given enough input packets, it will eventually wrap around to zero;
 * in the long term, therefore, ordinals are not unique.)  The ordinals
 * handed out by different IPPs are not disjoint, so two packets from
 * different IPPs may have identical ordinals.  Packets dropped by the
 * IPP or by the I/O shim are not assigned ordinals.
 *
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's per-IPP packet ordinal.
 */
static __inline unsigned int
NETIO_PKT_ORDINAL(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_ORDINAL_M(mda, pkt);
}


/** Return the per-group ordinal of the packet.
 * @ingroup ingress
 *
 * Each packet is given a per-group ordinal number when it is
 * delivered by the IPP. By default, the group is the packet's VLAN,
 * although IPP can be recompiled to use different values.  In
 * the medium term, the ordinal is unique and monotonically
 * increasing, being incremented by 1 for each packet; the ordinal of
 * the first packet distributed to a particular group is zero.
 * (Since the ordinal is of finite size, given enough input packets,
 * it will eventually wrap around to zero; in the long term,
 * therefore, ordinals are not unique.)  The ordinals handed out by
 * different IPPs are not disjoint, so two packets from different IPPs
 * may have identical ordinals; similarly, packets distributed to
 * different groups may have identical ordinals.  Packets dropped by
 * the IPP or by the I/O shim are not assigned ordinals.
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's per-IPP, per-group ordinal.
 */
static __inline unsigned int
NETIO_PKT_GROUP_ORDINAL(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_GROUP_ORDINAL_M(mda, pkt);
}


/** Return the VLAN ID assigned to the packet.
 * @ingroup ingress
 *
 * This is usually also contained within the packet header.  If the packet
 * does not have a VLAN tag, the VLAN ID returned by this function is zero.
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's VLAN ID.
 */
static __inline unsigned short
NETIO_PKT_VLAN_ID(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_VLAN_ID_M(mda, pkt);
}


/** Return the ethertype of the packet.
 * @ingroup ingress
 *
 * This value is reliable if @ref NETIO_PKT_ETHERTYPE_RECOGNIZED()
 * returns true, and otherwise, may not be well defined.
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's ethertype.
 */
static __inline unsigned short
NETIO_PKT_ETHERTYPE(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_ETHERTYPE_M(mda, pkt);
}


/** Return the flow hash computed on the packet.
 * @ingroup ingress
 *
 * For TCP and UDP packets, this hash is calculated by hashing together
 * the "5-tuple" values, specifically the source IP address, destination
 * IP address, protocol type, source port and destination port.
 * The hash value is intended to be helpful for millions of distinct
 * flows.
 *
 * For IPv4 or IPv6 packets which are neither TCP nor UDP, the flow hash is
 * derived by hashing together the source and destination IP addresses.
 *
 * For MPLS-encapsulated packets, the flow hash is derived by hashing
 * the first MPLS label.
 *
 * For all other packets the flow hash is computed from the source
 * and destination Ethernet addresses.
 *
 * The hash is symmetric, meaning it produces the same value if the
 * source and destination are swapped. The only exceptions are
 * tunneling protocols 0x04 (IP in IP Encapsulation), 0x29 (Simple
 * Internet Protocol), 0x2F (General Routing Encapsulation) and 0x32
 * (Encap Security Payload), which use only the destination address
 * since the source address is not meaningful.
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's 32-bit flow hash.
 */
static __inline unsigned int
NETIO_PKT_FLOW_HASH(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_FLOW_HASH_M(mda, pkt);
}


/** Return the first word of "user data" for the packet.
 *
 * The contents of the user data words depend on the IPP.
 *
 * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the first
 * word of user data contains the least significant bits of the 64-bit
 * arrival cycle count (see @c get_cycle_count_low()).
 *
 * See the <em>System Programmer's Guide</em> for details.
 *
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's first word of "user data".
 */
static __inline unsigned int
NETIO_PKT_USER_DATA_0(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_USER_DATA_0_M(mda, pkt);
}


/** Return the second word of "user data" for the packet.
 *
 * The contents of the user data words depend on the IPP.
 *
 * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the second
 * word of user data contains the most significant bits of the 64-bit
 * arrival cycle count (see @c get_cycle_count_high()).
 *
 * See the <em>System Programmer's Guide</em> for details.
 *
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return The packet's second word of "user data".
 */
static __inline unsigned int
NETIO_PKT_USER_DATA_1(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_USER_DATA_1_M(mda, pkt);
}


/** Determine whether the L4 (TCP/UDP) checksum was calculated.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the L4 checksum was calculated.
 */
static __inline unsigned int
NETIO_PKT_L4_CSUM_CALCULATED(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_L4_CSUM_CALCULATED_M(mda, pkt);
}


/** Determine whether the L4 (TCP/UDP) checksum was calculated and found to
 *  be correct.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the checksum was calculated and is correct.
 */
static __inline unsigned int
NETIO_PKT_L4_CSUM_CORRECT(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_L4_CSUM_CORRECT_M(mda, pkt);
}


/** Determine whether the L3 (IP) checksum was calculated.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the L3 (IP) checksum was calculated.
*/
static __inline unsigned int
NETIO_PKT_L3_CSUM_CALCULATED(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_L3_CSUM_CALCULATED_M(mda, pkt);
}


/** Determine whether the L3 (IP) checksum was calculated and found to be
 *  correct.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the checksum was calculated and is correct.
 */
static __inline unsigned int
NETIO_PKT_L3_CSUM_CORRECT(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_L3_CSUM_CORRECT_M(mda, pkt);
}


/** Determine whether the Ethertype was recognized and L3 packet data was
 *  processed.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 * @return Nonzero if the Ethertype was recognized and L3 packet data was
 *   processed.
 */
static __inline unsigned int
NETIO_PKT_ETHERTYPE_RECOGNIZED(netio_pkt_t* pkt)
{
  netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

  return NETIO_PKT_ETHERTYPE_RECOGNIZED_M(mda, pkt);
}


/** Set an egress packet's L2 length, using a metadata pointer to speed the
 * computation.
 * @ingroup egress
 *
 * @param[in,out] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @param[in] len Packet L2 length, in bytes.
 */
static __inline void
NETIO_PKT_SET_L2_LENGTH_MM(netio_pkt_minimal_metadata_t* mmd, netio_pkt_t* pkt,
                           int len)
{
  mmd->l2_length = len;
}


/** Set an egress packet's L2 length.
 * @ingroup egress
 *
 * @param[in,out] pkt Packet on which to operate.
 * @param[in] len Packet L2 length, in bytes.
 */
static __inline void
NETIO_PKT_SET_L2_LENGTH(netio_pkt_t* pkt, int len)
{
  netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

  NETIO_PKT_SET_L2_LENGTH_MM(mmd, pkt, len);
}


/** Set an egress packet's L2 header length, using a metadata pointer to
 *  speed the computation.
 * @ingroup egress
 *
 * It is not normally necessary to call this routine; only the L2 length,
 * not the header length, is needed to transmit a packet.  It may be useful if
 * the egress packet will later be processed by code which expects to use
 * functions like @ref NETIO_PKT_L3_DATA() to get a pointer to the L3 payload.
 *
 * @param[in,out] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @param[in] len Packet L2 header length, in bytes.
 */
static __inline void
NETIO_PKT_SET_L2_HEADER_LENGTH_MM(netio_pkt_minimal_metadata_t* mmd,
                                  netio_pkt_t* pkt, int len)
{
  mmd->l3_offset = mmd->l2_offset + len;
}


/** Set an egress packet's L2 header length.
 * @ingroup egress
 *
 * It is not normally necessary to call this routine; only the L2 length,
 * not the header length, is needed to transmit a packet.  It may be useful if
 * the egress packet will later be processed by code which expects to use
 * functions like @ref NETIO_PKT_L3_DATA() to get a pointer to the L3 payload.
 *
 * @param[in,out] pkt Packet on which to operate.
 * @param[in] len Packet L2 header length, in bytes.
 */
static __inline void
NETIO_PKT_SET_L2_HEADER_LENGTH(netio_pkt_t* pkt, int len)
{
  netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

  NETIO_PKT_SET_L2_HEADER_LENGTH_MM(mmd, pkt, len);
}


/** Set up an egress packet for hardware checksum computation, using a
 *  metadata pointer to speed the operation.
 * @ingroup egress
 *
 *  NetIO provides the ability to automatically calculate a standard
 *  16-bit Internet checksum on transmitted packets.  The application
 *  may specify the point in the packet where the checksum starts, the
 *  number of bytes to be checksummed, and the two bytes in the packet
 *  which will be replaced with the completed checksum.  (If the range
 *  of bytes to be checksummed includes the bytes to be replaced, the
 *  initial values of those bytes will be included in the checksum.)
 *
 *  For some protocols, the packet checksum covers data which is not present
 *  in the packet, or is at least not contiguous to the main data payload.
 *  For instance, the TCP checksum includes a "pseudo-header" which includes
 *  the source and destination IP addresses of the packet.  To accommodate
 *  this, the checksum engine may be "seeded" with an initial value, which
 *  the application would need to compute based on the specific protocol's
 *  requirements.  Note that the seed is given in host byte order (little-
 *  endian), not network byte order (big-endian); code written to compute a
 *  pseudo-header checksum in network byte order will need to byte-swap it
 *  before use as the seed.
 *
 *  Note that the checksum is computed as part of the transmission process,
 *  so it will not be present in the packet upon completion of this routine.
 *
 * @param[in,out] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 * @param[in] start Offset within L2 packet of the first byte to include in
 *   the checksum.
 * @param[in] length Number of bytes to include in the checksum.
 *   the checksum.
 * @param[in] location Offset within L2 packet of the first of the two bytes
 *   to be replaced with the calculated checksum.
 * @param[in] seed Initial value of the running checksum before any of the
 *   packet data is added.
 */
static __inline void
NETIO_PKT_DO_EGRESS_CSUM_MM(netio_pkt_minimal_metadata_t* mmd,
                            netio_pkt_t* pkt, int start, int length,
                            int location, uint16_t seed)
{
  mmd->csum_start = start;
  mmd->csum_length = length;
  mmd->csum_location = location;
  mmd->csum_seed = seed;
  mmd->flags |= _NETIO_PKT_NEED_EDMA_CSUM_MASK;
}


/** Set up an egress packet for hardware checksum computation.
 * @ingroup egress
 *
 *  NetIO provides the ability to automatically calculate a standard
 *  16-bit Internet checksum on transmitted packets.  The application
 *  may specify the point in the packet where the checksum starts, the
 *  number of bytes to be checksummed, and the two bytes in the packet
 *  which will be replaced with the completed checksum.  (If the range
 *  of bytes to be checksummed includes the bytes to be replaced, the
 *  initial values of those bytes will be included in the checksum.)
 *
 *  For some protocols, the packet checksum covers data which is not present
 *  in the packet, or is at least not contiguous to the main data payload.
 *  For instance, the TCP checksum includes a "pseudo-header" which includes
 *  the source and destination IP addresses of the packet.  To accommodate
 *  this, the checksum engine may be "seeded" with an initial value, which
 *  the application would need to compute based on the specific protocol's
 *  requirements.  Note that the seed is given in host byte order (little-
 *  endian), not network byte order (big-endian); code written to compute a
 *  pseudo-header checksum in network byte order will need to byte-swap it
 *  before use as the seed.
 *
 *  Note that the checksum is computed as part of the transmission process,
 *  so it will not be present in the packet upon completion of this routine.
 *
 * @param[in,out] pkt Packet on which to operate.
 * @param[in] start Offset within L2 packet of the first byte to include in
 *   the checksum.
 * @param[in] length Number of bytes to include in the checksum.
 *   the checksum.
 * @param[in] location Offset within L2 packet of the first of the two bytes
 *   to be replaced with the calculated checksum.
 * @param[in] seed Initial value of the running checksum before any of the
 *   packet data is added.
 */
static __inline void
NETIO_PKT_DO_EGRESS_CSUM(netio_pkt_t* pkt, int start, int length,
                         int location, uint16_t seed)
{
  netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

  NETIO_PKT_DO_EGRESS_CSUM_MM(mmd, pkt, start, length, location, seed);
}


/** Return the number of bytes which could be prepended to a packet, using a
 *  metadata pointer to speed the operation.
 *  See @ref netio_populate_prepend_buffer() to get a full description of
 *  prepending.
 *
 * @param[in,out] mda Pointer to packet's standard metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline int
NETIO_PKT_PREPEND_AVAIL_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
  return (pkt->__packet.bits.__offset << 6) +
         NETIO_PKT_CUSTOM_HEADER_LENGTH_M(mda, pkt);
}


/** Return the number of bytes which could be prepended to a packet, using a
 *  metadata pointer to speed the operation.
 *  See @ref netio_populate_prepend_buffer() to get a full description of
 *  prepending.
 * @ingroup egress
 *
 * @param[in,out] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline int
NETIO_PKT_PREPEND_AVAIL_MM(netio_pkt_minimal_metadata_t* mmd, netio_pkt_t* pkt)
{
  return (pkt->__packet.bits.__offset << 6) + mmd->l2_offset;
}


/** Return the number of bytes which could be prepended to a packet.
 *  See @ref netio_populate_prepend_buffer() to get a full description of
 *  prepending.
 * @ingroup egress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline int
NETIO_PKT_PREPEND_AVAIL(netio_pkt_t* pkt)
{
  if (NETIO_PKT_IS_MINIMAL(pkt))
  {
    netio_pkt_minimal_metadata_t* mmd = NETIO_PKT_MINIMAL_METADATA(pkt);

    return NETIO_PKT_PREPEND_AVAIL_MM(mmd, pkt);
  }
  else
  {
    netio_pkt_metadata_t* mda = NETIO_PKT_METADATA(pkt);

    return NETIO_PKT_PREPEND_AVAIL_M(mda, pkt);
  }
}


/** Flush a packet's minimal metadata from the cache, using a metadata pointer
 *  to speed the operation.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_MINIMAL_METADATA_MM(netio_pkt_minimal_metadata_t* mmd,
                                    netio_pkt_t* pkt)
{
}


/** Invalidate a packet's minimal metadata from the cache, using a metadata
 *  pointer to speed the operation.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_INV_MINIMAL_METADATA_MM(netio_pkt_minimal_metadata_t* mmd,
                                  netio_pkt_t* pkt)
{
}


/** Flush and then invalidate a packet's minimal metadata from the cache,
 *  using a metadata pointer to speed the operation.
 * @ingroup egress
 *
 * @param[in] mmd Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_INV_MINIMAL_METADATA_MM(netio_pkt_minimal_metadata_t* mmd,
                                        netio_pkt_t* pkt)
{
}


/** Flush a packet's metadata from the cache, using a metadata pointer
 *  to speed the operation.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's minimal metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_METADATA_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
}


/** Invalidate a packet's metadata from the cache, using a metadata
 *  pointer to speed the operation.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_INV_METADATA_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
}


/** Flush and then invalidate a packet's metadata from the cache,
 *  using a metadata pointer to speed the operation.
 * @ingroup ingress
 *
 * @param[in] mda Pointer to packet's metadata.
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_INV_METADATA_M(netio_pkt_metadata_t* mda, netio_pkt_t* pkt)
{
}


/** Flush a packet's minimal metadata from the cache.
 * @ingroup egress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_MINIMAL_METADATA(netio_pkt_t* pkt)
{
}


/** Invalidate a packet's minimal metadata from the cache.
 * @ingroup egress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_INV_MINIMAL_METADATA(netio_pkt_t* pkt)
{
}


/** Flush and then invalidate a packet's minimal metadata from the cache.
 * @ingroup egress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_INV_MINIMAL_METADATA(netio_pkt_t* pkt)
{
}


/** Flush a packet's metadata from the cache.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_METADATA(netio_pkt_t* pkt)
{
}


/** Invalidate a packet's metadata from the cache.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_INV_METADATA(netio_pkt_t* pkt)
{
}


/** Flush and then invalidate a packet's metadata from the cache.
 * @ingroup ingress
 *
 * @param[in] pkt Packet on which to operate.
 */
static __inline void
NETIO_PKT_FLUSH_INV_METADATA(netio_pkt_t* pkt)
{
}

/** Number of NUMA nodes we can distribute buffers to.
 * @ingroup setup */
#define NETIO_NUM_NODE_WEIGHTS  16

/**
 * @brief An object for specifying the characteristics of NetIO communication
 * endpoint.
 *
 * @ingroup setup
 *
 * The @ref netio_input_register() function uses this structure to define
 * how an application tile will communicate with an IPP.
 *
 *
 * Future updates to NetIO may add new members to this structure,
 * which can affect the success of the registration operation.  Thus,
 * if dynamically initializing the structure, applications are urged to
 * zero it out first, for example:
 *
 * @code
 * netio_input_config_t config;
 * memset(&config, 0, sizeof (config));
 * config.flags = NETIO_RECV | NETIO_XMIT_CSUM | NETIO_TAG_NONE;
 * config.num_receive_packets = NETIO_MAX_RECEIVE_PKTS;
 * config.queue_id = 0;
 *     .
 *     .
 *     .
 * @endcode
 *
 * since that guarantees that any unused structure members, including
 * members which did not exist when the application was first developed,
 * will not have unexpected values.
 *
 * If statically initializing the structure, we strongly recommend use of
 * C99-style named initializers, for example:
 *
 * @code
 * netio_input_config_t config = {
 *    .flags = NETIO_RECV | NETIO_XMIT_CSUM | NETIO_TAG_NONE,
 *    .num_receive_packets = NETIO_MAX_RECEIVE_PKTS,
 *    .queue_id = 0,
 * },
 * @endcode
 *
 * instead of the old-style structure initialization:
 *
 * @code
 * // Bad example! Currently equivalent to the above, but don't do this.
 * netio_input_config_t config = {
 *    NETIO_RECV | NETIO_XMIT_CSUM | NETIO_TAG_NONE, NETIO_MAX_RECEIVE_PKTS, 0
 * },
 * @endcode
 *
 * since the C99 style requires no changes to the code if elements of the
 * config structure are rearranged.  (It also makes the initialization much
 * easier to understand.)
 *
 * Except for items which address a particular tile's transmit or receive
 * characteristics, such as the ::NETIO_RECV flag, applications are advised
 * to specify the same set of configuration data on all registrations.
 * This prevents differing results if multiple tiles happen to do their
 * registration operations in a different order on different invocations of
 * the application.  This is particularly important for things like link
 * management flags, and buffer size and homing specifications.
 *
 * Unless the ::NETIO_FIXED_BUFFER_VA flag is specified in flags, the NetIO
 * buffer pool is automatically created and mapped into the application's
 * virtual address space at an address chosen by the operating system,
 * using the common memory (cmem) facility in the Tilera Multicore
 * Components library.  The cmem facility allows multiple processes to gain
 * access to shared memory which is mapped into each process at an
 * identical virtual address.  In order for this to work, the processes
 * must have a common ancestor, which must create the common memory using
 * tmc_cmem_init().
 *
 * In programs using the iLib process creation API, or in programs which use
 * only one process (which include programs using the pthreads library),
 * tmc_cmem_init() is called automatically.  All other applications
 * must call it explicitly, before any child processes which might call
 * netio_input_register() are created.
 */
typedef struct
{
  /** Registration characteristics.

      This value determines several characteristics of the registration;
      flags for different types of behavior are ORed together to make the
      final flag value.  Generally applications should specify exactly
      one flag from each of the following categories:

      - Whether the application will be receiving packets on this queue
        (::NETIO_RECV or ::NETIO_NO_RECV).

      - Whether the application will be transmitting packets on this queue,
        and if so, whether it will request egress checksum calculation
        (::NETIO_XMIT, ::NETIO_XMIT_CSUM, or ::NETIO_NO_XMIT).  It is
        legal to call netio_get_buffer() without one of the XMIT flags,
        as long as ::NETIO_RECV is specified; in this case, the retrieved
        buffers must be passed to another tile for transmission.

      - Whether the application expects any vendor-specific tags in
        its packets' L2 headers (::NETIO_TAG_NONE, ::NETIO_TAG_BRCM,
        or ::NETIO_TAG_MRVL).  This must match the configuration of the
        target IPP.

      To accommodate applications written to previous versions of the NetIO
      interface, none of the flags above are currently required; if omitted,
      NetIO behaves more or less as if ::NETIO_RECV | ::NETIO_XMIT_CSUM |
      ::NETIO_TAG_NONE were used.  However, explicit specification of
      the relevant flags allows NetIO to do a better job of resource
      allocation, allows earlier detection of certain configuration errors,
      and may enable advanced features or higher performance in the future,
      so their use is strongly recommended.

      Note that specifying ::NETIO_NO_RECV along with ::NETIO_NO_XMIT
      is a special case, intended primarily for use by programs which
      retrieve network statistics or do link management operations.
      When these flags are both specified, the resulting queue may not
      be used with NetIO routines other than netio_get(), netio_set(),
      and netio_input_unregister().  See @ref link for more information
      on link management.

      Other flags are optional; their use is described below.
  */
  int flags;

  /** Interface name.  This is a string which identifies the specific
      Ethernet controller hardware to be used.  The format of the string
      is a device type and a device index, separated by a slash; so,
      the first 10 Gigabit Ethernet controller is named "xgbe/0", while
      the second 10/100/1000 Megabit Ethernet controller is named "gbe/1".
   */
  const char* interface;

  /** Receive packet queue size.  This specifies the maximum number
      of ingress packets that can be received on this queue without
      being retrieved by @ref netio_get_packet().  If the IPP's distribution
      algorithm calls for a packet to be sent to this queue, and this
      number of packets are already pending there, the new packet
      will either be discarded, or sent to another tile registered
      for the same queue_id (see @ref drops).  This value must
      be at least ::NETIO_MIN_RECEIVE_PKTS, can always be at least
      ::NETIO_MAX_RECEIVE_PKTS, and may be larger than that on certain
      interfaces.
   */
  int num_receive_packets;

  /** The queue ID being requested.  Legal values for this range from 0
      to ::NETIO_MAX_QUEUE_ID, inclusive.  ::NETIO_MAX_QUEUE_ID is always
      greater than or equal to the number of tiles; this allows one queue
      for each tile, plus at least one additional queue.  Some applications
      may wish to use the additional queue as a destination for unwanted
      packets, since packets delivered to queues for which no tiles have
      registered are discarded.
   */
  unsigned int queue_id;

  /** Maximum number of small send buffers to be held in the local empty
      buffer cache.  This specifies the size of the area which holds
      empty small egress buffers requested from the IPP but not yet
      retrieved via @ref netio_get_buffer().  This value must be greater
      than zero if the application will ever use @ref netio_get_buffer()
      to allocate empty small egress buffers; it may be no larger than
      ::NETIO_MAX_SEND_BUFFERS.  See @ref epp for more details on empty
      buffer caching.
   */
  int num_send_buffers_small_total;

  /** Number of small send buffers to be preallocated at registration.
      If this value is nonzero, the specified number of empty small egress
      buffers will be requested from the IPP during the netio_input_register
      operation; this may speed the execution of @ref netio_get_buffer().
      This may be no larger than @ref num_send_buffers_small_total.  See @ref
      epp for more details on empty buffer caching.
   */
  int num_send_buffers_small_prealloc;

  /** Maximum number of large send buffers to be held in the local empty
      buffer cache.  This specifies the size of the area which holds empty
      large egress buffers requested from the IPP but not yet retrieved via
      @ref netio_get_buffer().  This value must be greater than zero if the
      application will ever use @ref netio_get_buffer() to allocate empty
      large egress buffers; it may be no larger than ::NETIO_MAX_SEND_BUFFERS.
      See @ref epp for more details on empty buffer caching.
   */
  int num_send_buffers_large_total;

  /** Number of large send buffers to be preallocated at registration.
      If this value is nonzero, the specified number of empty large egress
      buffers will be requested from the IPP during the netio_input_register
      operation; this may speed the execution of @ref netio_get_buffer().
      This may be no larger than @ref num_send_buffers_large_total.  See @ref
      epp for more details on empty buffer caching.
   */
  int num_send_buffers_large_prealloc;

  /** Maximum number of jumbo send buffers to be held in the local empty
      buffer cache.  This specifies the size of the area which holds empty
      jumbo egress buffers requested from the IPP but not yet retrieved via
      @ref netio_get_buffer().  This value must be greater than zero if the
      application will ever use @ref netio_get_buffer() to allocate empty
      jumbo egress buffers; it may be no larger than ::NETIO_MAX_SEND_BUFFERS.
      See @ref epp for more details on empty buffer caching.
   */
  int num_send_buffers_jumbo_total;

  /** Number of jumbo send buffers to be preallocated at registration.
      If this value is nonzero, the specified number of empty jumbo egress
      buffers will be requested from the IPP during the netio_input_register
      operation; this may speed the execution of @ref netio_get_buffer().
      This may be no larger than @ref num_send_buffers_jumbo_total.  See @ref
      epp for more details on empty buffer caching.
   */
  int num_send_buffers_jumbo_prealloc;

  /** Total packet buffer size.  This determines the total size, in bytes,
      of the NetIO buffer pool.  Note that the maximum number of available
      buffers of each size is determined during hypervisor configuration
      (see the <em>System Programmer's Guide</em> for details); this just
      influences how much host memory is allocated for those buffers.

      The buffer pool is allocated from common memory, which will be
      automatically initialized if needed.  If your buffer pool is larger
      than 240 MB, you might need to explicitly call @c tmc_cmem_init(),
      as described in the Application Libraries Reference Manual (UG227).

      Packet buffers are currently allocated in chunks of 16 MB; this
      value will be rounded up to the next larger multiple of 16 MB.
      If this value is zero, a default of 32 MB will be used; this was
      the value used by previous versions of NetIO.  Note that taking this
      default also affects the placement of buffers on Linux NUMA nodes.
      See @ref buffer_node_weights for an explanation of buffer placement.

      In order to successfully allocate packet buffers, Linux must have
      available huge pages on the relevant Linux NUMA nodes.  See the
      <em>System Programmer's Guide</em> for information on configuring
      huge page support in Linux.
   */
  uint64_t total_buffer_size;

  /** Buffer placement weighting factors.

      This array specifies the relative amount of buffering to place
      on each of the available Linux NUMA nodes.  This array is
      indexed by the NUMA node, and the values in the array are
      proportional to the amount of buffer space to allocate on that
      node.

      If memory striping is enabled in the Hypervisor, then there is
      only one logical NUMA node (node 0). In that case, NetIO will by
      default ignore the suggested buffer node weights, and buffers
      will be striped across the physical memory controllers. See
      UG209 System Programmer's Guide for a description of the
      hypervisor option that controls memory striping.

      If memory striping is disabled, then there are up to four NUMA
      nodes, corresponding to the four DDRAM controllers in the TILE
      processor architecture.  See UG100 Tile Processor Architecture
      Overview for a diagram showing the location of each of the DDRAM
      controllers relative to the tile array.

      For instance, if memory striping is disabled, the following
      configuration strucure:

      @code
      netio_input_config_t config = {
            .
            .
            .
        .total_buffer_size = 4 * 16 * 1024 * 1024;
        .buffer_node_weights = { 1, 0, 1, 0 },
      },
      @endcode

      would result in 32 MB of buffers being placed on controller 0, and
      32 MB on controller 2.  (Since buffers are allocated in units of
      16 MB, some sets of weights will not be able to be matched exactly.)

      For the weights to be effective, @ref total_buffer_size must be
      nonzero.  If @ref total_buffer_size is zero, causing the default
      32 MB of buffer space to be used, then any specified weights will
      be ignored, and buffers will positioned as they were in previous
      versions of NetIO:

      - For xgbe/0 and gbe/0, 16 MB of buffers will be placed on controller 1,
        and the other 16 MB will be placed on controller 2.

      - For xgbe/1 and gbe/1, 16 MB of buffers will be placed on controller 2,
        and the other 16 MB will be placed on controller 3.

      If @ref total_buffer_size is nonzero, but all weights are zero,
      then all buffer space will be allocated on Linux NUMA node zero.

      By default, the specified buffer placement is treated as a hint;
      if sufficient free memory is not available on the specified
      controllers, the buffers will be allocated elsewhere.  However,
      if the ::NETIO_STRICT_HOMING flag is specified in @ref flags, then a
      failure to allocate buffer space exactly as requested will cause the
      registration operation to fail with an error of ::NETIO_CANNOT_HOME.

      Note that maximal network performance cannot be achieved with
      only one memory controller.
   */
  uint8_t buffer_node_weights[NETIO_NUM_NODE_WEIGHTS];

  /** Fixed virtual address for packet buffers.  Only valid when
      ::NETIO_FIXED_BUFFER_VA is specified in @ref flags; see the
      description of that flag for details.
   */
  void* fixed_buffer_va;

  /**
      Maximum number of outstanding send packet requests.  This value is
      only relevant when an EPP is in use; it determines the number of
      slots in the EPP's outgoing packet queue which this tile is allowed
      to consume, and thus the number of packets which may be sent before
      the sending tile must wait for an acknowledgment from the EPP.
      Modifying this value is generally only helpful when using @ref
      netio_send_packet_vector(), where it can help improve performance by
      allowing a single vector send operation to process more packets.
      Typically it is not specified, and the default, which divides the
      outgoing packet slots evenly between all tiles on the chip, is used.

      If a registration asks for more outgoing packet queue slots than are
      available, ::NETIO_TOOMANY_XMIT will be returned.  The total number
      of packet queue slots which are available for all tiles for each EPP
      is subject to change, but is currently ::NETIO_TOTAL_SENDS_OUTSTANDING.


      This value is ignored if ::NETIO_XMIT is not specified in flags.
      If you want to specify a large value here for a specific tile, you are
      advised to specify NETIO_NO_XMIT on other, non-transmitting tiles so
      that they do not consume a default number of packet slots.  Any tile
      transmitting is required to have at least ::NETIO_MIN_SENDS_OUTSTANDING
      slots allocated to it; values less than that will be silently
      increased by the NetIO library.
   */
  int num_sends_outstanding;
}
netio_input_config_t;


/** Registration flags; used in the @ref netio_input_config_t structure.
 * @addtogroup setup
 */
/** @{ */

/** Fail a registration request if we can't put packet buffers
    on the specified memory controllers. */
#define NETIO_STRICT_HOMING   0x00000002

/** This application expects no tags on its L2 headers. */
#define NETIO_TAG_NONE        0x00000004

/** This application expects Marvell extended tags on its L2 headers. */
#define NETIO_TAG_MRVL        0x00000008

/** This application expects Broadcom tags on its L2 headers. */
#define NETIO_TAG_BRCM        0x00000010

/** This registration may call routines which receive packets. */
#define NETIO_RECV            0x00000020

/** This registration may not call routines which receive packets. */
#define NETIO_NO_RECV         0x00000040

/** This registration may call routines which transmit packets. */
#define NETIO_XMIT            0x00000080

/** This registration may call routines which transmit packets with
    checksum acceleration. */
#define NETIO_XMIT_CSUM       0x00000100

/** This registration may not call routines which transmit packets. */
#define NETIO_NO_XMIT         0x00000200

/** This registration wants NetIO buffers mapped at an application-specified
    virtual address.

    NetIO buffers are by default created by the TMC common memory facility,
    which must be configured by a common ancestor of all processes sharing
    a network interface.  When this flag is specified, NetIO buffers are
    instead mapped at an address chosen by the application (and specified
    in @ref netio_input_config_t::fixed_buffer_va).  This allows multiple
    unrelated but cooperating processes to share a NetIO interface.
    All processes sharing the same interface must specify this flag,
    and all must specify the same fixed virtual address.

    @ref netio_input_config_t::fixed_buffer_va must be a
    multiple of 16 MB, and the packet buffers will occupy @ref
    netio_input_config_t::total_buffer_size bytes of virtual address
    space, beginning at that address.  If any of those virtual addresses
    are currently occupied by other memory objects, like application or
    shared library code or data, @ref netio_input_register() will return
    ::NETIO_FAULT.  While it is impossible to provide a fixed_buffer_va
    which will work for all applications, a good first guess might be to
    use 0xb0000000 minus @ref netio_input_config_t::total_buffer_size.
    If that fails, it might be helpful to consult the running application's
    virtual address description file (/proc/<em>pid</em>/maps) to see
    which regions of virtual address space are available.
 */
#define NETIO_FIXED_BUFFER_VA 0x00000400

/** This registration call will not complete unless the network link
    is up.  The process will wait several seconds for this to happen (the
    precise interval is link-dependent), but if the link does not come up,
    ::NETIO_LINK_DOWN will be returned.  This flag is the default if
    ::NETIO_NOREQUIRE_LINK_UP is not specified.  Note that this flag by
    itself does not request that the link be brought up; that can be done
    with the ::NETIO_AUTO_LINK_UPDN or ::NETIO_AUTO_LINK_UP flags (the
    latter is the default if no NETIO_AUTO_LINK_xxx flags are specified),
    or by explicitly setting the link's desired state via netio_set().
    If the link is not brought up by one of those methods, and this flag
    is specified, the registration operation will return ::NETIO_LINK_DOWN.
    This flag is ignored if it is specified along with ::NETIO_NO_XMIT and
    ::NETIO_NO_RECV.  See @ref link for more information on link
    management.
 */
#define NETIO_REQUIRE_LINK_UP    0x00000800

/** This registration call will complete even if the network link is not up.
    Whenever the link is not up, packets will not be sent or received:
    netio_get_packet() will return ::NETIO_NOPKT once all queued packets
    have been drained, and netio_send_packet() and similar routines will
    return NETIO_QUEUE_FULL once the outgoing packet queue in the EPP
    or the I/O shim is full.  See @ref link for more information on link
    management.
 */
#define NETIO_NOREQUIRE_LINK_UP  0x00001000

#ifndef __DOXYGEN__
/*
 * These are part of the implementation of the NETIO_AUTO_LINK_xxx flags,
 * but should not be used directly by applications, and are thus not
 * documented.
 */
#define _NETIO_AUTO_UP        0x00002000
#define _NETIO_AUTO_DN        0x00004000
#define _NETIO_AUTO_PRESENT   0x00008000
#endif

/** Set the desired state of the link to up, allowing any speeds which are
    supported by the link hardware, as part of this registration operation.
    Do not take down the link automatically.  This is the default if
    no other NETIO_AUTO_LINK_xxx flags are specified.  This flag is ignored
    if it is specified along with ::NETIO_NO_XMIT and ::NETIO_NO_RECV.
    See @ref link for more information on link management.
 */
#define NETIO_AUTO_LINK_UP     (_NETIO_AUTO_PRESENT | _NETIO_AUTO_UP)

/** Set the desired state of the link to up, allowing any speeds which are
    supported by the link hardware, as part of this registration operation.
    Set the desired state of the link to down the next time no tiles are
    registered for packet reception or transmission.  This flag is ignored
    if it is specified along with ::NETIO_NO_XMIT and ::NETIO_NO_RECV.
    See @ref link for more information on link management.
 */
#define NETIO_AUTO_LINK_UPDN   (_NETIO_AUTO_PRESENT | _NETIO_AUTO_UP | \
                                _NETIO_AUTO_DN)

/** Set the desired state of the link to down the next time no tiles are
    registered for packet reception or transmission.  This flag is ignored
    if it is specified along with ::NETIO_NO_XMIT and ::NETIO_NO_RECV.
    See @ref link for more information on link management.
 */
#define NETIO_AUTO_LINK_DN     (_NETIO_AUTO_PRESENT | _NETIO_AUTO_DN)

/** Do not bring up the link automatically as part of this registration
    operation.  Do not take down the link automatically.  This flag
    is ignored if it is specified along with ::NETIO_NO_XMIT and
    ::NETIO_NO_RECV.  See @ref link for more information on link management.
  */
#define NETIO_AUTO_LINK_NONE   _NETIO_AUTO_PRESENT


/** Minimum number of receive packets. */
#define NETIO_MIN_RECEIVE_PKTS            16

/** Lower bound on the maximum number of receive packets; may be higher
    than this on some interfaces. */
#define NETIO_MAX_RECEIVE_PKTS           128

/** Maximum number of send buffers, per packet size. */
#define NETIO_MAX_SEND_BUFFERS            16

/** Number of EPP queue slots, and thus outstanding sends, per EPP. */
#define NETIO_TOTAL_SENDS_OUTSTANDING   2015

/** Minimum number of EPP queue slots, and thus outstanding sends, per
 *  transmitting tile. */
#define NETIO_MIN_SENDS_OUTSTANDING       16


/**@}*/

#ifndef __DOXYGEN__

/**
 * An object for providing Ethernet packets to a process.
 */
struct __netio_queue_impl_t;

/**
 * An object for managing the user end of a NetIO queue.
 */
struct __netio_queue_user_impl_t;

#endif /* !__DOXYGEN__ */


/** A netio_queue_t describes a NetIO communications endpoint.
 * @ingroup setup
 */
typedef struct
{
#ifdef __DOXYGEN__
  uint8_t opaque[8];                 /**< This is an opaque structure. */
#else
  struct __netio_queue_impl_t* __system_part;    /**< The system part. */
  struct __netio_queue_user_impl_t* __user_part; /**< The user part. */
#ifdef _NETIO_PTHREAD
  _netio_percpu_mutex_t lock;                    /**< Queue lock. */
#endif
#endif
}
netio_queue_t;


/**
 * @brief Packet send context.
 *
 * @ingroup egress
 *
 * Packet send context for use with netio_send_packet_prepare and _commit.
 */
typedef struct
{
#ifdef __DOXYGEN__
  uint8_t opaque[44];   /**< This is an opaque structure. */
#else
  uint8_t flags;        /**< Defined below */
  uint8_t datalen;      /**< Number of valid words pointed to by data. */
  uint32_t request[9];  /**< Request to be sent to the EPP or shim.  Note
                             that this is smaller than the 11-word maximum
                             request size, since some constant values are
                             not saved in the context. */
  uint32_t *data;       /**< Data to be sent to the EPP or shim via IDN. */
#endif
}
netio_send_pkt_context_t;


#ifndef __DOXYGEN__
#define SEND_PKT_CTX_USE_EPP   1  /**< We're sending to an EPP. */
#define SEND_PKT_CTX_SEND_CSUM 2  /**< Request includes a checksum. */
#endif

/**
 * @brief Packet vector entry.
 *
 * @ingroup egress
 *
 * This data structure is used with netio_send_packet_vector() to send multiple
 * packets with one NetIO call.  The structure should be initialized by
 * calling netio_pkt_vector_set(), rather than by setting the fields
 * directly.
 *
 * This structure is guaranteed to be a power of two in size, no
 * bigger than one L2 cache line, and to be aligned modulo its size.
 */
typedef struct
#ifndef __DOXYGEN__
__attribute__((aligned(8)))
#endif
{
  /** Reserved for use by the user application.  When initialized with
   *  the netio_set_pkt_vector_entry() function, this field is guaranteed
   *  to be visible to readers only after all other fields are already
   *  visible.  This way it can be used as a valid flag or generation
   *  counter. */
  uint8_t user_data;

  /* Structure members below this point should not be accessed directly by
   * applications, as they may change in the future. */

  /** Low 8 bits of the packet address to send.  The high bits are
   *  acquired from the 'handle' field. */
  uint8_t buffer_address_low;

  /** Number of bytes to transmit. */
  uint16_t size;

  /** The raw handle from a netio_pkt_t.  If this is NETIO_PKT_HANDLE_NONE,
   *  this vector entry will be skipped and no packet will be transmitted. */
  netio_pkt_handle_t handle;
}
netio_pkt_vector_entry_t;


/**
 * @brief Initialize fields in a packet vector entry.
 *
 * @ingroup egress
 *
 * @param[out] v Pointer to the vector entry to be initialized.
 * @param[in] pkt Packet to be transmitted when the vector entry is passed to
 *        netio_send_packet_vector().  Note that the packet's attributes
 *        (e.g., its L2 offset and length) are captured at the time this
 *        routine is called; subsequent changes in those attributes will not
 *        be reflected in the packet which is actually transmitted.
 *        Changes in the packet's contents, however, will be so reflected.
 *        If this is NULL, no packet will be transmitted.
 * @param[in] user_data User data to be set in the vector entry.
 *        This function guarantees that the "user_data" field will become
 *        visible to a reader only after all other fields have become visible.
 *        This allows a structure in a ring buffer to be written and read
 *        by a polling reader without any locks or other synchronization.
 */
static __inline void
netio_pkt_vector_set(volatile netio_pkt_vector_entry_t* v, netio_pkt_t* pkt,
                     uint8_t user_data)
{
  if (pkt)
  {
    if (NETIO_PKT_IS_MINIMAL(pkt))
    {
      netio_pkt_minimal_metadata_t* mmd =
        (netio_pkt_minimal_metadata_t*) &pkt->__metadata;
      v->buffer_address_low = (uintptr_t) NETIO_PKT_L2_DATA_MM(mmd, pkt) & 0xFF;
      v->size = NETIO_PKT_L2_LENGTH_MM(mmd, pkt);
    }
    else
    {
      netio_pkt_metadata_t* mda = &pkt->__metadata;
      v->buffer_address_low = (uintptr_t) NETIO_PKT_L2_DATA_M(mda, pkt) & 0xFF;
      v->size = NETIO_PKT_L2_LENGTH_M(mda, pkt);
    }
    v->handle.word = pkt->__packet.word;
  }
  else
  {
    v->handle.word = 0;   /* Set handle to NETIO_PKT_HANDLE_NONE. */
  }

  __asm__("" : : : "memory");

  v->user_data = user_data;
}


/**
 * Flags and structures for @ref netio_get() and @ref netio_set().
 * @ingroup config
 */

/** @{ */
/** Parameter class; addr is a NETIO_PARAM_xxx value. */
#define NETIO_PARAM       0
/** Interface MAC address. This address is only valid with @ref netio_get().
 *  The value is a 6-byte MAC address.  Depending upon the overall system
 *  design, a MAC address may or may not be available for each interface. */
#define NETIO_PARAM_MAC        0

/** Determine whether to suspend output on the receipt of pause frames.
 *  If the value is nonzero, the I/O shim will suspend output when a pause
 *  frame is received.  If the value is zero, pause frames will be ignored. */
#define NETIO_PARAM_PAUSE_IN   1

/** Determine whether to send pause frames if the I/O shim packet FIFOs are
 *  nearly full.  If the value is zero, pause frames are not sent.  If
 *  the value is nonzero, it is the delay value which will be sent in any
 *  pause frames which are output, in units of 512 bit times. */
#define NETIO_PARAM_PAUSE_OUT  2

/** Jumbo frame support.  The value is a 4-byte integer.  If the value is
 *  nonzero, the MAC will accept frames of up to 10240 bytes.  If the value
 *  is zero, the MAC will only accept frames of up to 1544 bytes. */
#define NETIO_PARAM_JUMBO      3

/** I/O shim's overflow statistics register.  The value is two 16-bit integers.
 *  The first 16-bit value (or the low 16 bits, if the value is treated as a
 *  32-bit number) is the count of packets which were completely dropped and
 *  not delivered by the shim.  The second 16-bit value (or the high 16 bits,
 *  if the value is treated as a 32-bit number) is the count of packets
 *  which were truncated and thus only partially delivered by the shim.  This
 *  register is automatically reset to zero after it has been read.
 */
#define NETIO_PARAM_OVERFLOW   4

/** IPP statistics.  This address is only valid with @ref netio_get().  The
 *  value is a netio_stat_t structure.  Unlike the I/O shim statistics, the
 *  IPP statistics are not all reset to zero on read; see the description
 *  of the netio_stat_t for details. */
#define NETIO_PARAM_STAT 5

/** Possible link state.  The value is a combination of "NETIO_LINK_xxx"
 *  flags.  With @ref netio_get(), this will indicate which flags are
 *  actually supported by the hardware.
 *
 *  For historical reasons, specifying this value to netio_set() will have
 *  the same behavior as using ::NETIO_PARAM_LINK_CONFIG, but this usage is
 *  discouraged.
 */
#define NETIO_PARAM_LINK_POSSIBLE_STATE 6

/** Link configuration. The value is a combination of "NETIO_LINK_xxx" flags.
 *  With @ref netio_set(), this will attempt to immediately bring up the
 *  link using whichever of the requested flags are supported by the
 *  hardware, or take down the link if the flags are zero; if this is
 *  not possible, an error will be returned.  Many programs will want
 *  to use ::NETIO_PARAM_LINK_DESIRED_STATE instead.
 *
 *  For historical reasons, specifying this value to netio_get() will
 *  have the same behavior as using ::NETIO_PARAM_LINK_POSSIBLE_STATE,
 *  but this usage is discouraged.
 */
#define NETIO_PARAM_LINK_CONFIG NETIO_PARAM_LINK_POSSIBLE_STATE

/** Current link state. This address is only valid with @ref netio_get().
 *  The value is zero or more of the "NETIO_LINK_xxx" flags, ORed together.
 *  If the link is down, the value ANDed with NETIO_LINK_SPEED will be
 *  zero; if the link is up, the value ANDed with NETIO_LINK_SPEED will
 *  result in exactly one of the NETIO_LINK_xxx values, indicating the
 *  current speed. */
#define NETIO_PARAM_LINK_CURRENT_STATE 7

/** Variant symbol for current state, retained for compatibility with
 *  pre-MDE-2.1 programs. */
#define NETIO_PARAM_LINK_STATUS NETIO_PARAM_LINK_CURRENT_STATE

/** Packet Coherence protocol. This address is only valid with @ref netio_get().
 *  The value is nonzero if the interface is configured for cache-coherent DMA.
 */
#define NETIO_PARAM_COHERENT 8

/** Desired link state. The value is a conbination of "NETIO_LINK_xxx"
 *  flags, which specify the desired state for the link.  With @ref
 *  netio_set(), this will, in the background, attempt to bring up the link
 *  using whichever of the requested flags are reasonable, or take down the
 *  link if the flags are zero.  The actual link up or down operation may
 *  happen after this call completes.  If the link state changes in the
 *  future, the system will continue to try to get back to the desired link
 *  state; for instance, if the link is brought up successfully, and then
 *  the network cable is disconnected, the link will go down.  However, the
 *  desired state of the link is still up, so if the cable is reconnected,
 *  the link will be brought up again.
 *
 *  With @ref netio_get(), this will indicate the desired state for the
 *  link, as set with a previous netio_set() call, or implicitly by a
 *  netio_input_register() or netio_input_unregister() operation.  This may
 *  not reflect the current state of the link; to get that, use
 *  ::NETIO_PARAM_LINK_CURRENT_STATE. */
#define NETIO_PARAM_LINK_DESIRED_STATE 9

/** NetIO statistics structure.  Retrieved using the ::NETIO_PARAM_STAT
 *  address passed to @ref netio_get(). */
typedef struct
{
  /** Number of packets which have been received by the IPP and forwarded
   *  to a tile's receive queue for processing.  This value wraps at its
   *  maximum, and is not cleared upon read. */
  uint32_t packets_received;

  /** Number of packets which have been dropped by the IPP, because they could
   *  not be received, or could not be forwarded to a tile.  The former happens
   *  when the IPP does not have a free packet buffer of suitable size for an
   *  incoming frame.  The latter happens when all potential destination tiles
   *  for a packet, as defined by the group, bucket, and queue configuration,
   *  have full receive queues.   This value wraps at its maximum, and is not
   *  cleared upon read. */
  uint32_t packets_dropped;

  /*
   * Note: the #defines after each of the following four one-byte values
   * denote their location within the third word of the netio_stat_t.  They
   * are intended for use only by the IPP implementation and are thus omitted
   * from the Doxygen output.
   */

  /** Number of packets dropped because no worker was able to accept a new
   *  packet.  This value saturates at its maximum, and is cleared upon
   *  read. */
  uint8_t drops_no_worker;
#ifndef __DOXYGEN__
#define NETIO_STAT_DROPS_NO_WORKER   0
#endif

  /** Number of packets dropped because no small buffers were available.
   *  This value saturates at its maximum, and is cleared upon read. */
  uint8_t drops_no_smallbuf;
#ifndef __DOXYGEN__
#define NETIO_STAT_DROPS_NO_SMALLBUF 1
#endif

  /** Number of packets dropped because no large buffers were available.
   *  This value saturates at its maximum, and is cleared upon read. */
  uint8_t drops_no_largebuf;
#ifndef __DOXYGEN__
#define NETIO_STAT_DROPS_NO_LARGEBUF 2
#endif

  /** Number of packets dropped because no jumbo buffers were available.
   *  This value saturates at its maximum, and is cleared upon read. */
  uint8_t drops_no_jumbobuf;
#ifndef __DOXYGEN__
#define NETIO_STAT_DROPS_NO_JUMBOBUF 3
#endif
}
netio_stat_t;


/** Link can run, should run, or is running at 10 Mbps. */
#define NETIO_LINK_10M         0x01

/** Link can run, should run, or is running at 100 Mbps. */
#define NETIO_LINK_100M        0x02

/** Link can run, should run, or is running at 1 Gbps. */
#define NETIO_LINK_1G          0x04

/** Link can run, should run, or is running at 10 Gbps. */
#define NETIO_LINK_10G         0x08

/** Link should run at the highest speed supported by the link and by
 *  the device connected to the link.  Only usable as a value for
 *  the link's desired state; never returned as a value for the current
 *  or possible states. */
#define NETIO_LINK_ANYSPEED    0x10

/** All legal link speeds. */
#define NETIO_LINK_SPEED  (NETIO_LINK_10M  | \
                           NETIO_LINK_100M | \
                           NETIO_LINK_1G   | \
                           NETIO_LINK_10G  | \
                           NETIO_LINK_ANYSPEED)


/** MAC register class.  Addr is a register offset within the MAC.
 *  Registers within the XGbE and GbE MACs are documented in the Tile
 *  Processor I/O Device Guide (UG104). MAC registers start at address
 *  0x4000, and do not include the MAC_INTERFACE registers. */
#define NETIO_MAC             1

/** MDIO register class (IEEE 802.3 clause 22 format).  Addr is the "addr"
 *  member of a netio_mdio_addr_t structure. */
#define NETIO_MDIO            2

/** MDIO register class (IEEE 802.3 clause 45 format).  Addr is the "addr"
 *  member of a netio_mdio_addr_t structure. */
#define NETIO_MDIO_CLAUSE45   3

/** NetIO MDIO address type.  Retrieved or provided using the ::NETIO_MDIO
 *  address passed to @ref netio_get() or @ref netio_set(). */
typedef union
{
  struct
  {
    unsigned int reg:16;  /**< MDIO register offset.  For clause 22 access,
                               must be less than 32. */
    unsigned int phy:5;   /**< Which MDIO PHY to access. */
    unsigned int dev:5;   /**< Which MDIO device to access within that PHY.
                               Applicable for clause 45 access only; ignored
                               for clause 22 access. */
  }
  bits;                   /**< Container for bitfields. */
  uint64_t addr;          /**< Value to pass to @ref netio_get() or
                           *   @ref netio_set(). */
}
netio_mdio_addr_t;

/** @} */

#endif /* __NETIO_INTF_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        config MIPS
	bool
	default y
	select ARCH_SUPPORTS_UPROBES
	select ARCH_MIGHT_HAVE_PC_PARPORT
	select ARCH_MIGHT_HAVE_PC_SERIO
	select ARCH_USE_CMPXCHG_LOCKREF if 64BIT
	select ARCH_USE_BUILTIN_BSWAP
	select HAVE_CONTEXT_TRACKING
	select HAVE_GENERIC_DMA_COHERENT
	select HAVE_IDE
	select HAVE_IRQ_EXIT_ON_IRQ_STACK
	select HAVE_OPROFILE
	select HAVE_PERF_EVENTS
	select PERF_USE_VMALLOC
	select HAVE_ARCH_KGDB
	select HAVE_ARCH_SECCOMP_FILTER
	select HAVE_ARCH_TRACEHOOK
	select HAVE_CBPF_JIT if !CPU_MICROMIPS
	select HAVE_FUNCTION_TRACER
	select HAVE_DYNAMIC_FTRACE
	select HAVE_FTRACE_MCOUNT_RECORD
	select HAVE_C_RECORDMCOUNT
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_KPROBES
	select HAVE_KRETPROBES
	select HAVE_SYSCALL_TRACEPOINTS
	select HAVE_DEBUG_KMEMLEAK
	select HAVE_SYSCALL_TRACEPOINTS
	select ARCH_HAS_ELF_RANDOMIZE
	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if CPU_SUPPORTS_HUGEPAGES && 64BIT
	select RTC_LIB if !MACH_LOONGSON64
	select GENERIC_ATOMIC64 if !64BIT
	select HAVE_DMA_CONTIGUOUS
	select HAVE_DMA_API_DEBUG
	select GENERIC_IRQ_PROBE
	select GENERIC_IRQ_SHOW
	select GENERIC_PCI_IOMAP
	select HAVE_ARCH_JUMP_LABEL
	select ARCH_WANT_IPC_PARSE_VERSION
	select IRQ_FORCED_THREADING
	select HAVE_MEMBLOCK
	select HAVE_MEMBLOCK_NODE_MAP
	select ARCH_DISCARD_MEMBLOCK
	select GENERIC_SMP_IDLE_THREAD
	select BUILDTIME_EXTABLE_SORT
	select GENERIC_CLOCKEVENTS
	select GENERIC_SCHED_CLOCK if !CAVIUM_OCTEON_SOC
	select GENERIC_CMOS_UPDATE
	select HAVE_MOD_ARCH_SPECIFIC
	select HAVE_NMI
	select VIRT_TO_BUS
	select MODULES_USE_ELF_REL if MODULES
	select MODULES_USE_ELF_RELA if MODULES && 64BIT
	select CLONE_BACKWARDS
	select HAVE_DEBUG_STACKOVERFLOW
	select HAVE_CC_STACKPROTECTOR
	select CPU_PM if CPU_IDLE
	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
	select ARCH_BINFMT_ELF_STATE
	select SYSCTL_EXCEPTION_TRACE
	select HAVE_VIRT_CPU_ACCOUNTING_GEN
	select HAVE_IRQ_TIME_ACCOUNTING
	select GENERIC_TIME_VSYSCALL
	select ARCH_CLOCKSOURCE_DATA
	select HANDLE_DOMAIN_IRQ
	select HAVE_EXIT_THREAD
	select HAVE_REGS_AND_STACK_ACCESS_API
	select HAVE_ARCH_HARDENED_USERCOPY

menu "Machine selection"

choice
	prompt "System type"
	default SGI_IP22

config MIPS_GENERIC
	bool "Generic board-agnostic MIPS kernel"
	select BOOT_RAW
	select BUILTIN_DTB
	select CEVT_R4K
	select CLKSRC_MIPS_GIC
	select COMMON_CLK
	select CPU_MIPSR2_IRQ_VI
	select CPU_MIPSR2_IRQ_EI
	select CSRC_R4K
	select DMA_PERDEV_COHERENT
	select HW_HAS_PCI
	select IRQ_MIPS_CPU
	select LIBFDT
	select MIPS_CPU_SCACHE
	select MIPS_GIC
	select MIPS_L1_CACHE_SHIFT_7
	select NO_EXCEPT_FILL
	select PCI_DRIVERS_GENERIC
	select PINCTRL
	select SMP_UP if SMP
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_CPU_MIPS32_R6
	select SYS_HAS_CPU_MIPS64_R1
	select SYS_HAS_CPU_MIPS64_R2
	select SYS_HAS_CPU_MIPS64_R6
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MICROMIPS
	select SYS_SUPPORTS_MIPS_CPS
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_SUPPORTS_RELOCATABLE
	select SYS_SUPPORTS_SMARTMIPS
	select USB_EHCI_BIG_ENDIAN_DESC if BIG_ENDIAN
	select USB_EHCI_BIG_ENDIAN_MMIO if BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_DESC if BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_MMIO if BIG_ENDIAN
	select USB_UHCI_BIG_ENDIAN_DESC if BIG_ENDIAN
	select USB_UHCI_BIG_ENDIAN_MMIO if BIG_ENDIAN
	select USE_OF
	help
	  Select this to build a kernel which aims to support multiple boards,
	  generally using a flattened device tree passed from the bootloader
	  using the boot protocol defined in the UHI (Unified Hosting
	  Interface) specification.

config MIPS_ALCHEMY
	bool "Alchemy processor based machines"
	select ARCH_PHYS_ADDR_T_64BIT
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_MIPS_CPU
	select DMA_MAYBE_COHERENT	# Au1000,1500,1100 aren't, rest is
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_APM_EMULATION
	select GPIOLIB
	select SYS_SUPPORTS_ZBOOT
	select COMMON_CLK

config AR7
	bool "Texas Instruments AR7"
	select BOOT_ELF32
	select DMA_NONCOHERENT
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_MIPS_CPU
	select NO_EXCEPT_FILL
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_ZBOOT_UART16550
	select GPIOLIB
	select VLYNQ
	select HAVE_CLK
	help
	  Support for the Texas Instruments AR7 System-on-a-Chip
	  family: TNETD7100, 7200 and 7300.

config ATH25
	bool "Atheros AR231x/AR531x SoC support"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select IRQ_DOMAIN
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_HAS_EARLY_PRINTK
	help
	  Support for Atheros AR231x and Atheros AR531x based boards

config ATH79
	bool "Atheros AR71XX/AR724X/AR913X based boards"
	select ARCH_HAS_RESET_CONTROLLER
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select GPIOLIB
	select HAVE_CLK
	select COMMON_CLK
	select CLKDEV_LOOKUP
	select IRQ_MIPS_CPU
	select MIPS_MACHINE
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_ZBOOT_UART_PROM
	select USE_OF
	help
	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.

config BMIPS_GENERIC
	bool "Broadcom Generic BMIPS kernel"
	select BOOT_RAW
	select NO_EXCEPT_FILL
	select USE_OF
	select CEVT_R4K
	select CSRC_R4K
	select SYNC_R4K
	select COMMON_CLK
	select BCM6345_L1_IRQ
	select BCM7038_L1_IRQ
	select BCM7120_L2_IRQ
	select BRCMSTB_L2_IRQ
	select IRQ_MIPS_CPU
	select DMA_NONCOHERENT
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_HAS_CPU_BMIPS32_3300
	select SYS_HAS_CPU_BMIPS4350
	select SYS_HAS_CPU_BMIPS4380
	select SYS_HAS_CPU_BMIPS5000
	select SWAP_IO_SPACE
	select USB_EHCI_BIG_ENDIAN_DESC if CPU_BIG_ENDIAN
	select USB_EHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_DESC if CPU_BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
	help
	  Build a generic DT-based kernel image that boots on select
	  BCM33xx cable modem chips, BCM63xx DSL chips, and BCM7xxx set-top
	  box chips.  Note that CONFIG_CPU_BIG_ENDIAN/CONFIG_CPU_LITTLE_ENDIAN
	  must be set appropriately for your board.

config BCM47XX
	bool "Broadcom BCM47XX based boards"
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select IRQ_MIPS_CPU
	select SYS_HAS_CPU_MIPS32_R1
	select NO_EXCEPT_FILL
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_HAS_EARLY_PRINTK
	select USE_GENERIC_EARLY_PRINTK_8250
	select GPIOLIB
	select LEDS_GPIO_REGISTER
	select BCM47XX_NVRAM
	select BCM47XX_SPROM
	help
	 Support for BCM47XX based boards

config BCM63XX
	bool "Broadcom BCM63XX based boards"
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select SYNC_R4K
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_HAS_EARLY_PRINTK
	select SWAP_IO_SPACE
	select GPIOLIB
	select HAVE_CLK
	select MIPS_L1_CACHE_SHIFT_4
	help
	 Support for BCM63XX based boards

config MIPS_COBALT
	bool "Cobalt Server"
	select CEVT_R4K
	select CSRC_R4K
	select CEVT_GT641XX
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select I8253
	select I8259
	select IRQ_MIPS_CPU
	select IRQ_GT641XX
	select PCI_GT64XXX_PCI0
	select PCI
	select SYS_HAS_CPU_NEVADA
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select USE_GENERIC_EARLY_PRINTK_8250

config MACH_DECSTATION
	bool "DECstations"
	select BOOT_ELF32
	select CEVT_DS1287
	select CEVT_R4K if CPU_R4X00
	select CSRC_IOASIC
	select CSRC_R4K if CPU_R4X00
	select CPU_DADDI_WORKAROUNDS if 64BIT
	select CPU_R4000_WORKAROUNDS if 64BIT
	select CPU_R4400_WORKAROUNDS if 64BIT
	select DMA_NONCOHERENT
	select NO_IOPORT_MAP
	select IRQ_MIPS_CPU
	select SYS_HAS_CPU_R3000
	select SYS_HAS_CPU_R4X00
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_128HZ
	select SYS_SUPPORTS_256HZ
	select SYS_SUPPORTS_1024HZ
	select MIPS_L1_CACHE_SHIFT_4
	help
	  This enables support for DEC's MIPS based workstations.  For details
	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
	  DECstation porting pages on <http://decstation.unix-ag.org/>.

	  If you have one of the following DECstation Models you definitely
	  want to choose R4xx0 for the CPU Type:

		DECstation 5000/50
		DECstation 5000/150
		DECstation 5000/260
		DECsystem 5900/260

	  otherwise choose R3000.

config MACH_JAZZ
	bool "Jazz family of machines"
	select FW_ARC
	select FW_ARC32
	select ARCH_MAY_HAVE_PC_FDC
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
	select GENERIC_ISA_DMA
	select HAVE_PCSPKR_PLATFORM
	select IRQ_MIPS_CPU
	select I8253
	select I8259
	select ISA
	select SYS_HAS_CPU_R4X00
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_100HZ
	help
	 This a family of machines based on the MIPS R4030 chipset which was
	 used by several vendors to build RISC/os and Windows NT workstations.
	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millennium and
	 Olivetti M700-10 workstations.

config MACH_INGENIC
	bool "Ingenic SoC based machines"
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_ZBOOT_UART16550
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select GPIOLIB
	select COMMON_CLK
	select GENERIC_IRQ_CHIP
	select BUILTIN_DTB
	select USE_OF
	select LIBFDT

config LANTIQ
	bool "Lantiq based platforms"
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select CEVT_R4K
	select CSRC_R4K
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_HAS_EARLY_PRINTK
	select GPIOLIB
	select SWAP_IO_SPACE
	select BOOT_RAW
	select CLKDEV_LOOKUP
	select USE_OF
	select PINCTRL
	select PINCTRL_LANTIQ
	select ARCH_HAS_RESET_CONTROLLER
	select RESET_CONTROLLER

config LASAT
	bool "LASAT Networks platforms"
	select CEVT_R4K
	select CRC32
	select CSRC_R4K
	select DMA_NONCOHERENT
	select SYS_HAS_EARLY_PRINTK
	select HW_HAS_PCI
	select IRQ_MIPS_CPU
	select PCI_GT64XXX_PCI0
	select MIPS_NILE4
	select R5000_CPU_SCACHE
	select SYS_HAS_CPU_R5000
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config MACH_LOONGSON32
	bool "Loongson-1 family of machines"
	select SYS_SUPPORTS_ZBOOT
	help
	  This enables support for the Loongson-1 family of machines.

	  Loongson-1 is a family of 32-bit MIPS-compatible SoCs developed by
	  the Institute of Computing Technology (ICT), Chinese Academy of
	  Sciences (CAS).

config MACH_LOONGSON64
	bool "Loongson-2/3 family of machines"
	select SYS_SUPPORTS_ZBOOT
	help
	  This enables the support of Loongson-2/3 family of machines.

	  Loongson-2 is a family of single-core CPUs and Loongson-3 is a
	  family of multi-core CPUs. They are both 64-bit general-purpose
	  MIPS-compatible CPUs. Loongson-2/3 are developed by the Institute
	  of Computing Technology (ICT), Chinese Academy of Sciences (CAS)
	  in the People's Republic of China. The chief architect is Professor
	  Weiwu Hu.

config MACH_PISTACHIO
	bool "IMG Pistachio SoC based boards"
	select BOOT_ELF32
	select BOOT_RAW
	select CEVT_R4K
	select CLKSRC_MIPS_GIC
	select COMMON_CLK
	select CSRC_R4K
	select DMA_NONCOHERENT
	select GPIOLIB
	select IRQ_MIPS_CPU
	select LIBFDT
	select MFD_SYSCON
	select MIPS_CPU_SCACHE
	select MIPS_GIC
	select PINCTRL
	select REGULATOR
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS_CPS
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_SUPPORTS_RELOCATABLE
	select SYS_SUPPORTS_ZBOOT
	select SYS_HAS_EARLY_PRINTK
	select USE_GENERIC_EARLY_PRINTK_8250
	select USE_OF
	help
	  This enables support for the IMG Pistachio SoC platform.

config MACH_XILFPGA
	bool "MIPSfpga Xilinx based boards"
	select BOOT_ELF32
	select BOOT_RAW
	select BUILTIN_DTB
	select CEVT_R4K
	select COMMON_CLK
	select CSRC_R4K
	select GPIOLIB
	select IRQ_MIPS_CPU
	select LIBFDT
	select MIPS_CPU_SCACHE
	select SYS_HAS_EARLY_PRINTK
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_ZBOOT_UART16550
	select USE_OF
	select USE_GENERIC_EARLY_PRINTK_8250
	help
	  This enables support for the IMG University Program MIPSfpga platform.

config MIPS_MALTA
	bool "MIPS Malta board"
	select ARCH_MAY_HAVE_PC_FDC
	select BOOT_ELF32
	select BOOT_RAW
	select BUILTIN_DTB
	select CEVT_R4K
	select CSRC_R4K
	select CLKSRC_MIPS_GIC
	select COMMON_CLK
	select DMA_MAYBE_COHERENT
	select GENERIC_ISA_DMA
	select HAVE_PCSPKR_PLATFORM
	select IRQ_MIPS_CPU
	select MIPS_GIC
	select HW_HAS_PCI
	select I8253
	select I8259
	select MIPS_BONITO64
	select MIPS_CPU_SCACHE
	select MIPS_L1_CACHE_SHIFT_6
	select PCI_GT64XXX_PCI0
	select MIPS_MSC
	select SMP_UP if SMP
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_CPU_MIPS32_R3_5
	select SYS_HAS_CPU_MIPS32_R5
	select SYS_HAS_CPU_MIPS32_R6
	select SYS_HAS_CPU_MIPS64_R1
	select SYS_HAS_CPU_MIPS64_R2
	select SYS_HAS_CPU_MIPS64_R6
	select SYS_HAS_CPU_NEVADA
	select SYS_HAS_CPU_RM7000
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MICROMIPS
	select SYS_SUPPORTS_MIPS_CMP
	select SYS_SUPPORTS_MIPS_CPS
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_SUPPORTS_SMARTMIPS
	select SYS_SUPPORTS_ZBOOT
	select SYS_SUPPORTS_RELOCATABLE
	select USE_OF
	select LIBFDT
	select ZONE_DMA32 if 64BIT
	select BUILTIN_DTB
	select LIBFDT
	help
	  This enables support for the MIPS Technologies Malta evaluation
	  board.

config MACH_PIC32
	bool "Microchip PIC32 Family"
	help
	  This enables support for the Microchip PIC32 family of platforms.

	  Microchip PIC32 is a family of general-purpose 32 bit MIPS core
	  microcontrollers.

config NEC_MARKEINS
	bool "NEC EMMA2RH Mark-eins board"
	select SOC_EMMA2RH
	select HW_HAS_PCI
	help
	  This enables support for the NEC Electronics Mark-eins boards.

config MACH_VR41XX
	bool "NEC VR4100 series based machines"
	select CEVT_R4K
	select CSRC_R4K
	select SYS_HAS_CPU_VR41XX
	select SYS_SUPPORTS_MIPS16
	select GPIOLIB

config NXP_STB220
	bool "NXP STB220 board"
	select SOC_PNX833X
	help
	 Support for NXP Semiconductors STB220 Development Board.

config NXP_STB225
	bool "NXP 225 board"
	select SOC_PNX833X
	select SOC_PNX8335
	help
	 Support for NXP Semiconductors STB225 Development Board.

config PMC_MSP
	bool "PMC-Sierra MSP chipsets"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select SWAP_IO_SPACE
	select NO_EXCEPT_FILL
	select BOOT_RAW
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select IRQ_MIPS_CPU
	select SERIAL_8250
	select SERIAL_8250_CONSOLE
	select USB_EHCI_BIG_ENDIAN_MMIO
	select USB_EHCI_BIG_ENDIAN_DESC
	help
	  This adds support for the PMC-Sierra family of Multi-Service
	  Processor System-On-A-Chips.  These parts include a number
	  of integrated peripherals, interfaces and DSPs in addition to
	  a variety of MIPS cores.

config RALINK
	bool "Ralink based machines"
	select CEVT_R4K
	select CSRC_R4K
	select BOOT_RAW
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select USE_OF
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_HAS_EARLY_PRINTK
	select CLKDEV_LOOKUP
	select ARCH_HAS_RESET_CONTROLLER
	select RESET_CONTROLLER

config SGI_IP22
	bool "SGI IP22 (Indy/Indigo2)"
	select FW_ARC
	select FW_ARC32
	select BOOT_ELF32
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION
	select DMA_NONCOHERENT
	select HW_HAS_EISA
	select I8253
	select I8259
	select IP22_CPU_SCACHE
	select IRQ_MIPS_CPU
	select GENERIC_ISA_DMA_SUPPORT_BROKEN
	select SGI_HAS_I8042
	select SGI_HAS_INDYDOG
	select SGI_HAS_HAL2
	select SGI_HAS_SEEQ
	select SGI_HAS_WD93
	select SGI_HAS_ZILOG
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_R4X00
	select SYS_HAS_CPU_R5000
	#
	# Disable EARLY_PRINTK for now since it leads to overwritten prom
	# memory during early boot on some machines.
	#
	# See http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=20091119164009.GA15038%40deprecation.cyrius.com
	# for a more details discussion
	#
	# select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select MIPS_L1_CACHE_SHIFT_7
	help
	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
	  that runs on these, say Y here.

config SGI_IP27
	bool "SGI IP27 (Origin200/2000)"
	select FW_ARC
	select FW_ARC64
	select BOOT_ELF64
	select DEFAULT_SGI_PARTITION
	select DMA_COHERENT
	select SYS_HAS_EARLY_PRINTK
	select HW_HAS_PCI
	select NR_CPUS_DEFAULT_64
	select SYS_HAS_CPU_R10000
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_NUMA
	select SYS_SUPPORTS_SMP
	select MIPS_L1_CACHE_SHIFT_7
	help
	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
	  workstations.  To compile a Linux kernel that runs on these, say Y
	  here.

config SGI_IP28
	bool "SGI IP28 (Indigo2 R10k)"
	select FW_ARC
	select FW_ARC64
	select BOOT_ELF64
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION
	select DMA_NONCOHERENT
	select GENERIC_ISA_DMA_SUPPORT_BROKEN
	select IRQ_MIPS_CPU
	select HW_HAS_EISA
	select I8253
	select I8259
	select SGI_HAS_I8042
	select SGI_HAS_INDYDOG
	select SGI_HAS_HAL2
	select SGI_HAS_SEEQ
	select SGI_HAS_WD93
	select SGI_HAS_ZILOG
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_R10000
	#
	# Disable EARLY_PRINTK for now since it leads to overwritten prom
	# memory during early boot on some machines.
	#
	# See http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=20091119164009.GA15038%40deprecation.cyrius.com
	# for a more details discussion
	#
	# select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select MIPS_L1_CACHE_SHIFT_7
      help
        This is the SGI Indigo2 with R10000 processor.  To compile a Linux
        kernel that runs on these, say Y here.

config SGI_IP32
	bool "SGI IP32 (O2)"
	select FW_ARC
	select FW_ARC32
	select BOOT_ELF32
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select IRQ_MIPS_CPU
	select R5000_CPU_SCACHE
	select RM7000_CPU_SCACHE
	select SYS_HAS_CPU_R5000
	select SYS_HAS_CPU_R10000 if BROKEN
	select SYS_HAS_CPU_RM7000
	select SYS_HAS_CPU_NEVADA
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	help
	  If you want this kernel to run on SGI O2 workstation, say Y here.

config SIBYTE_CRHINE
	bool "Sibyte BCM91120C-CRhine"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1120
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_CARMEL
	bool "Sibyte BCM91120x-Carmel"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1120
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_CRHONE
	bool "Sibyte BCM91125C-CRhone"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1125
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_RHONE
	bool "Sibyte BCM91125E-Rhone"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1125H
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_SWARM
	bool "Sibyte BCM91250A-SWARM"
	select BOOT_ELF32
	select DMA_COHERENT
	select HAVE_PATA_PLATFORM
	select SIBYTE_SB1250
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select ZONE_DMA32 if 64BIT

config SIBYTE_LITTLESUR
	bool "Sibyte BCM91250C2-LittleSur"
	select BOOT_ELF32
	select DMA_COHERENT
	select HAVE_PATA_PLATFORM
	select SIBYTE_SB1250
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_SENTOSA
	bool "Sibyte BCM91250E-Sentosa"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_SB1250
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_BIGSUR
	bool "Sibyte BCM91480B-BigSur"
	select BOOT_ELF32
	select DMA_COHERENT
	select NR_CPUS_DEFAULT_4
	select SIBYTE_BCM1x80
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select ZONE_DMA32 if 64BIT

config SNI_RM
	bool "SNI RM200/300/400"
	select FW_ARC if CPU_LITTLE_ENDIAN
	select FW_ARC32 if CPU_LITTLE_ENDIAN
	select FW_SNIPROM if CPU_BIG_ENDIAN
	select ARCH_MAY_HAVE_PC_FDC
	select BOOT_ELF32
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
	select DMA_NONCOHERENT
	select GENERIC_ISA_DMA
	select HAVE_PCSPKR_PLATFORM
	select HW_HAS_EISA
	select HW_HAS_PCI
	select IRQ_MIPS_CPU
	select I8253
	select I8259
	select ISA
	select SWAP_IO_SPACE if CPU_BIG_ENDIAN
	select SYS_HAS_CPU_R4X00
	select SYS_HAS_CPU_R5000
	select SYS_HAS_CPU_R10000
	select R5000_CPU_SCACHE
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	help
	  The SNI RM200/300/400 are MIPS-based machines manufactured by
	  Siemens Nixdorf Informationssysteme (SNI), parent company of Pyramid
	  Technology and now in turn merged with Fujitsu.  Say Y here to
	  support this machine type.

config MACH_TX39XX
	bool "Toshiba TX39 series based machines"

config MACH_TX49XX
	bool "Toshiba TX49 series based machines"

config MIKROTIK_RB532
	bool "Mikrotik RB532 boards"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select IRQ_MIPS_CPU
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SWAP_IO_SPACE
	select BOOT_RAW
	select GPIOLIB
	select MIPS_L1_CACHE_SHIFT_4
	help
	  Support the Mikrotik(tm) RouterBoard 532 series,
	  based on the IDT RC32434 SoC.

config CAVIUM_OCTEON_SOC
	bool "Cavium Networks Octeon SoC based boards"
	select CEVT_R4K
	select ARCH_PHYS_ADDR_T_64BIT
	select DMA_COHERENT
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select EDAC_SUPPORT
	select EDAC_ATOMIC_SCRUB
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_HOTPLUG_CPU if CPU_BIG_ENDIAN
	select SYS_HAS_EARLY_PRINTK
	select SYS_HAS_CPU_CAVIUM_OCTEON
	select HW_HAS_PCI
	select ZONE_DMA32
	select HOLES_IN_ZONE
	select GPIOLIB
	select LIBFDT
	select USE_OF
	select ARCH_SPARSEMEM_ENABLE
	select SYS_SUPPORTS_SMP
	select NR_CPUS_DEFAULT_16
	select BUILTIN_DTB
	select MTD_COMPLEX_MAPPINGS
	help
	  This option supports all of the Octeon reference boards from Cavium
	  Networks. It builds a kernel that dynamically determines the Octeon
	  CPU type and supports all known board reference implementations.
	  Some of the supported boards are:
		EBT3000
		EBH3000
		EBH3100
		Thunder
		Kodama
		Hikari
	  Say Y here for most Octeon reference boards.

config NLM_XLR_BOARD
	bool "Netlogic XLR/XLS based systems"
	select BOOT_ELF32
	select NLM_COMMON
	select SYS_HAS_CPU_XLR
	select SYS_SUPPORTS_SMP
	select HW_HAS_PCI
	select SWAP_IO_SPACE
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select ARCH_PHYS_ADDR_T_64BIT
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select DMA_COHERENT
	select NR_CPUS_DEFAULT_32
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_MIPS_CPU
	select ZONE_DMA32 if 64BIT
	select SYNC_R4K
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_ZBOOT
	select SYS_SUPPORTS_ZBOOT_UART16550
	help
	  Support for systems based on Netlogic XLR and XLS processors.
	  Say Y here if you have a XLR or XLS based board.

config NLM_XLP_BOARD
	bool "Netlogic XLP based systems"
	select BOOT_ELF32
	select NLM_COMMON
	select SYS_HAS_CPU_XLP
	select SYS_SUPPORTS_SMP
	select HW_HAS_PCI
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select ARCH_PHYS_ADDR_T_64BIT
	select GPIOLIB
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select DMA_COHERENT
	select NR_CPUS_DEFAULT_32
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_MIPS_CPU
	select ZONE_DMA32 if 64BIT
	select SYNC_R4K
	select SYS_HAS_EARLY_PRINTK
	select USE_OF
	select SYS_SUPPORTS_ZBOOT
	select SYS_SUPPORTS_ZBOOT_UART16550
	help
	  This board is based on Netlogic XLP Processor.
	  Say Y here if you have a XLP based board.

config MIPS_PARAVIRT
	bool "Para-Virtualized guest system"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_COHERENT
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_SMP
	select NR_CPUS_DEFAULT_4
	select SYS_HAS_EARLY_PRINTK
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_CPU_MIPS64_R2
	select SYS_HAS_CPU_CAVIUM_OCTEON
	select HW_HAS_PCI
	select SWAP_IO_SPACE
	help
	  This option supports guest running under ????

endchoice

source "arch/mips/alchemy/Kconfig"
source "arch/mips/ath25/Kconfig"
source "arch/mips/ath79/Kconfig"
source "arch/mips/bcm47xx/Kconfig"
source "arch/mips/bcm63xx/Kconfig"
source "arch/mips/bmips/Kconfig"
source "arch/mips/generic/Kconfig"
source "arch/mips/jazz/Kconfig"
source "arch/mips/jz4740/Kconfig"
source "arch/mips/lantiq/Kconfig"
source "arch/mips/lasat/Kconfig"
source "arch/mips/pic32/Kconfig"
source "arch/mips/pistachio/Kconfig"
source "arch/mips/pmcs-msp71xx/Kconfig"
source "arch/mips/ralink/Kconfig"
source "arch/mips/sgi-ip27/Kconfig"
source "arch/mips/sibyte/Kconfig"
source "arch/mips/txx9/Kconfig"
source "arch/mips/vr41xx/Kconfig"
source "arch/mips/cavium-octeon/Kconfig"
source "arch/mips/loongson32/Kconfig"
source "arch/mips/loongson64/Kconfig"
source "arch/mips/netlogic/Kconfig"
source "arch/mips/paravirt/Kconfig"
source "arch/mips/xilfpga/Kconfig"

endmenu

config RWSEM_GENERIC_SPINLOCK
	bool
	default y

config RWSEM_XCHGADD_ALGORITHM
	bool

config ARCH_HAS_ILOG2_U32
	bool
	default n

config ARCH_HAS_ILOG2_U64
	bool
	default n

config GENERIC_HWEIGHT
	bool
	default y

config GENERIC_CALIBRATE_DELAY
	bool
	default y

config SCHED_OMIT_FRAME_POINTER
	bool
	default y

#
# Select some configuration options automatically based on user selections.
#
config FW_ARC
	bool

config ARCH_MAY_HAVE_PC_FDC
	bool

config BOOT_RAW
	bool

config CEVT_BCM1480
	bool

config CEVT_DS1287
	bool

config CEVT_GT641XX
	bool

config CEVT_R4K
	bool

config CEVT_SB1250
	bool

config CEVT_TXX9
	bool

config CSRC_BCM1480
	bool

config CSRC_IOASIC
	bool

config CSRC_R4K
	bool

config CSRC_SB1250
	bool

config MIPS_CLOCK_VSYSCALL
	def_bool CSRC_R4K || CLKSRC_MIPS_GIC

config GPIO_TXX9
	select GPIOLIB
	bool

config FW_CFE
	bool

config ARCH_DMA_ADDR_T_64BIT
	def_bool (HIGHMEM && ARCH_PHYS_ADDR_T_64BIT) || 64BIT

config ARCH_SUPPORTS_UPROBES
	bool

config DMA_MAYBE_COHERENT
	select DMA_NONCOHERENT
	bool

config DMA_PERDEV_COHERENT
	bool
	select DMA_MAYBE_COHERENT

config DMA_COHERENT
	bool

config DMA_NONCOHERENT
	bool
	select NEED_DMA_MAP_STATE

config NEED_DMA_MAP_STATE
	bool

config SYS_HAS_EARLY_PRINTK
	bool

config SYS_SUPPORTS_HOTPLUG_CPU
	bool

config MIPS_BONITO64
	bool

config MIPS_MSC
	bool

config MIPS_NILE4
	bool

config SYNC_R4K
	bool

config MIPS_MACHINE
	def_bool n

config NO_IOPORT_MAP
	def_bool n

config GENERIC_CSUM
	bool

config GENERIC_ISA_DMA
	bool
	select ZONE_DMA if GENERIC_ISA_DMA_SUPPORT_BROKEN=n
	select ISA_DMA_API

config GENERIC_ISA_DMA_SUPPORT_BROKEN
	bool
	select GENERIC_ISA_DMA

config ISA_DMA_API
	bool

config HOLES_IN_ZONE
	bool

config SYS_SUPPORTS_RELOCATABLE
	bool
	help
	 Selected if the platform supports relocating the kernel.
	 The platform must provide plat_get_fdt() if it selects CONFIG_USE_OF
	 to allow access to command line and entropy sources.

#
# Endianness selection.  Sufficiently obscure so many users don't know what to
# answer,so we try hard to limit the available choices.  Also the use of a
# choice statement should be more obvious to the user.
#
choice
	prompt "Endianness selection"
	help
	  Some MIPS machines can be configured for either little or big endian
	  byte order. These modes require different kernels and a different
	  Linux distribution.  In general there is one preferred byteorder for a
	  particular system but some systems are just as commonly used in the
	  one or the other endianness.

config CPU_BIG_ENDIAN
	bool "Big endian"
	depends on SYS_SUPPORTS_BIG_ENDIAN

config CPU_LITTLE_ENDIAN
	bool "Little endian"
	depends on SYS_SUPPORTS_LITTLE_ENDIAN

endchoice

config EXPORT_UASM
	bool

config SYS_SUPPORTS_APM_EMULATION
	bool

config SYS_SUPPORTS_BIG_ENDIAN
	bool

config SYS_SUPPORTS_LITTLE_ENDIAN
	bool

config SYS_SUPPORTS_HUGETLBFS
	bool
	depends on CPU_SUPPORTS_HUGEPAGES && 64BIT
	default y

config MIPS_HUGE_TLB_SUPPORT
	def_bool HUGETLB_PAGE || TRANSPARENT_HUGEPAGE

config IRQ_CPU_RM7K
	bool

config IRQ_MSP_SLP
	bool

config IRQ_MSP_CIC
	bool

config IRQ_TXX9
	bool

config IRQ_GT641XX
	bool

config PCI_GT64XXX_PCI0
	bool

config NO_EXCEPT_FILL
	bool

config SOC_EMMA2RH
	bool
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_R5500
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN

config SOC_PNX833X
	bool
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_MIPS_CPU
	select DMA_NONCOHERENT
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select CPU_MIPSR2_IRQ_VI

config SOC_PNX8335
	bool
	select SOC_PNX833X

config MIPS_SPRAM
	bool

config SWAP_IO_SPACE
	bool

config SGI_HAS_INDYDOG
	bool

config SGI_HAS_HAL2
	bool

config SGI_HAS_SEEQ
	bool

config SGI_HAS_WD93
	bool

config SGI_HAS_ZILOG
	bool

config SGI_HAS_I8042
	bool

config DEFAULT_SGI_PARTITION
	bool

config FW_ARC32
	bool

config FW_SNIPROM
	bool

config BOOT_ELF32
	bool

config MIPS_L1_CACHE_SHIFT_4
	bool

config MIPS_L1_CACHE_SHIFT_5
	bool

config MIPS_L1_CACHE_SHIFT_6
	bool

config MIPS_L1_CACHE_SHIFT_7
	bool

config MIPS_L1_CACHE_SHIFT
	int
	default "7" if MIPS_L1_CACHE_SHIFT_7
	default "6" if MIPS_L1_CACHE_SHIFT_6
	default "5" if MIPS_L1_CACHE_SHIFT_5
	default "4" if MIPS_L1_CACHE_SHIFT_4
	default "5"

config HAVE_STD_PC_SERIAL_PORT
	bool

config ARC_CONSOLE
	bool "ARC console support"
	depends on SGI_IP22 || SGI_IP28 || (SNI_RM && CPU_LITTLE_ENDIAN)

config ARC_MEMORY
	bool
	depends on MACH_JAZZ || SNI_RM || SGI_IP32
	default y

config ARC_PROMLIB
	bool
	depends on MACH_JAZZ || SNI_RM || SGI_IP22 || SGI_IP28 || SGI_IP32
	default y

config FW_ARC64
	bool

config BOOT_ELF64
	bool

menu "CPU selection"

choice
	prompt "CPU type"
	default CPU_R4X00

config CPU_LOONGSON3
	bool "Loongson 3 CPU"
	depends on SYS_HAS_CPU_LOONGSON3
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select WEAK_ORDERING
	select WEAK_REORDERING_BEYOND_LLSC
	select MIPS_PGD_C0_CONTEXT
	select MIPS_L1_CACHE_SHIFT_6
	select GPIOLIB
	help
		The Loongson 3 processor implements the MIPS64R2 instruction
		set with many extensions.

config LOONGSON3_ENHANCEMENT
	bool "New Loongson 3 CPU Enhancements"
	default n
	select CPU_MIPSR2
	select CPU_HAS_PREFETCH
	depends on CPU_LOONGSON3
	help
	  New Loongson 3 CPU (since Loongson-3A R2, as opposed to Loongson-3A
	  R1, Loongson-3B R1 and Loongson-3B R2) has many enhancements, such as
	  FTLB, L1-VCache, EI/DI/Wait/Prefetch instruction, DSP/DSPv2 ASE, User
	  Local register, Read-Inhibit/Execute-Inhibit, SFB (Store Fill Buffer),
	  Fast TLB refill support, etc.

	  This option enable those enhancements which are not probed at run
	  time. If you want a generic kernel to run on all Loongson 3 machines,
	  please say 'N' here. If you want a high-performance kernel to run on
	  new Loongson 3 machines only, please say 'Y' here.

config CPU_LOONGSON2E
	bool "Loongson 2E"
	depends on SYS_HAS_CPU_LOONGSON2E
	select CPU_LOONGSON2
	help
	  The Loongson 2E processor implements the MIPS III instruction set
	  with many extensions.

	  It has an internal FPGA northbridge, which is compatible to
	  bonito64.

config CPU_LOONGSON2F
	bool "Loongson 2F"
	depends on SYS_HAS_CPU_LOONGSON2F
	select CPU_LOONGSON2
	select GPIOLIB
	help
	  The Loongson 2F processor implements the MIPS III instruction set
	  with many extensions.

	  Loongson2F have built-in DDR2 and PCIX controller. The PCIX controller
	  have a similar programming interface with FPGA northbridge used in
	  Loongson2E.

config CPU_LOONGSON1B
	bool "Loongson 1B"
	depends on SYS_HAS_CPU_LOONGSON1B
	select CPU_LOONGSON1
	select LEDS_GPIO_REGISTER
	help
	  The Loongson 1B is a 32-bit SoC, which implements the MIPS32
	  release 2 instruction set.

config CPU_LOONGSON1C
	bool "Loongson 1C"
	depends on SYS_HAS_CPU_LOONGSON1C
	select CPU_LOONGSON1
	select ARCH_WANT_OPTIONAL_GPIOLIB
	select LEDS_GPIO_REGISTER
	help
	  The Loongson 1C is a 32-bit SoC, which implements the MIPS32
	  release 2 instruction set.

config CPU_MIPS32_R1
	bool "MIPS32 Release 1"
	depends on SYS_HAS_CPU_MIPS32_R1
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	help
	  Choose this option to build a kernel for release 1 or later of the
	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
	  MIPS processor are based on a MIPS32 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
	  Release 2 of the MIPS32 architecture is available since several
	  years so chances are you even have a MIPS32 Release 2 processor
	  in which case you should choose CPU_MIPS32_R2 instead for better
	  performance.

config CPU_MIPS32_R2
	bool "MIPS32 Release 2"
	depends on SYS_HAS_CPU_MIPS32_R2
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_MSA
	select HAVE_KVM
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
	  MIPS processor are based on a MIPS32 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.

config CPU_MIPS32_R6
	bool "MIPS32 Release 6"
	depends on SYS_HAS_CPU_MIPS32_R6
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_MSA
	select GENERIC_CSUM
	select HAVE_KVM
	select MIPS_O32_FP64_SUPPORT
	help
	  Choose this option to build a kernel for release 6 or later of the
	  MIPS32 architecture.  New MIPS processors, starting with the Warrior
	  family, are based on a MIPS32r6 processor. If you own an older
	  processor, you probably need to select MIPS32r1 or MIPS32r2 instead.

config CPU_MIPS64_R1
	bool "MIPS64 Release 1"
	depends on SYS_HAS_CPU_MIPS64_R1
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	help
	  Choose this option to build a kernel for release 1 or later of the
	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
	  MIPS processor are based on a MIPS64 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.
	  Release 2 of the MIPS64 architecture is available since several
	  years so chances are you even have a MIPS64 Release 2 processor
	  in which case you should choose CPU_MIPS64_R2 instead for better
	  performance.

config CPU_MIPS64_R2
	bool "MIPS64 Release 2"
	depends on SYS_HAS_CPU_MIPS64_R2
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select CPU_SUPPORTS_MSA
	select HAVE_KVM
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
	  MIPS processor are based on a MIPS64 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.

config CPU_MIPS64_R6
	bool "MIPS64 Release 6"
	depends on SYS_HAS_CPU_MIPS64_R6
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_MSA
	select GENERIC_CSUM
	select MIPS_O32_FP64_SUPPORT if 32BIT || MIPS32_O32
	select HAVE_KVM
	help
	  Choose this option to build a kernel for release 6 or later of the
	  MIPS64 architecture.  New MIPS processors, starting with the Warrior
	  family, are based on a MIPS64r6 processor. If you own an older
	  processor, you probably need to select MIPS64r1 or MIPS64r2 instead.

config CPU_R3000
	bool "R3000"
	depends on SYS_HAS_CPU_R3000
	select CPU_HAS_WB
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	help
	  Please make sure to pick the right CPU type. Linux/MIPS is not
	  designed to be generic, i.e. Kernels compiled for R3000 CPUs will
	  *not* work on R4000 machines and vice versa.  However, since most
	  of the supported machines have an R4000 (or similar) CPU, R4x00
	  might be a safe bet.  If the resulting kernel does not work,
	  try to recompile with R3000.

config CPU_TX39XX
	bool "R39XX"
	depends on SYS_HAS_CPU_TX39XX
	select CPU_SUPPORTS_32BIT_KERNEL

config CPU_VR41XX
	bool "R41xx"
	depends on SYS_HAS_CPU_VR41XX
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	help
	  The options selects support for the NEC VR4100 series of processors.
	  Only choose this option if you have one of these processors as a
	  kernel built with this option will not run on any other type of
	  processor or vice versa.

config CPU_R4300
	bool "R4300"
	depends on SYS_HAS_CPU_R4300
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	help
	  MIPS Technologies R4300-series processors.

config CPU_R4X00
	bool "R4x00"
	depends on SYS_HAS_CPU_R4X00
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  MIPS Technologies R4000-series processors other than 4300, including
	  the R4000, R4400, R4600, and 4700.

config CPU_TX49XX
	bool "R49XX"
	depends on SYS_HAS_CPU_TX49XX
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES

config CPU_R5000
	bool "R5000"
	depends on SYS_HAS_CPU_R5000
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  MIPS Technologies R5000-series processors other than the Nevada.

config CPU_R5432
	bool "R5432"
	depends on SYS_HAS_CPU_R5432
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES

config CPU_R5500
	bool "R5500"
	depends on SYS_HAS_CPU_R5500
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  NEC VR5500 and VR5500A series processors implement 64-bit MIPS IV
	  instruction set.

config CPU_R6000
	bool "R6000"
	depends on SYS_HAS_CPU_R6000
	select CPU_SUPPORTS_32BIT_KERNEL
	help
	  MIPS Technologies R6000 and R6000A series processors.  Note these
	  processors are extremely rare and the support for them is incomplete.

config CPU_NEVADA
	bool "RM52xx"
	depends on SYS_HAS_CPU_NEVADA
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  QED / PMC-Sierra RM52xx-series ("Nevada") processors.

config CPU_R8000
	bool "R8000"
	depends on SYS_HAS_CPU_R8000
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_64BIT_KERNEL
	help
	  MIPS Technologies R8000 processors.  Note these processors are
	  uncommon and the support for them is incomplete.

config CPU_R10000
	bool "R10000"
	depends on SYS_HAS_CPU_R10000
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	help
	  MIPS Technologies R10000-series processors.

config CPU_RM7000
	bool "RM7000"
	depends on SYS_HAS_CPU_RM7000
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES

config CPU_SB1
	bool "SB1"
	depends on SYS_HAS_CPU_SB1
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select WEAK_ORDERING

config CPU_CAVIUM_OCTEON
	bool "Cavium Octeon processor"
	depends on SYS_HAS_CPU_CAVIUM_OCTEON
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_64BIT_KERNEL
	select WEAK_ORDERING
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select USB_EHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
	select MIPS_L1_CACHE_SHIFT_7
	help
	  The Cavium Octeon processor is a highly integrated chip containing
	  many ethernet hardware widgets for networking tasks. The processor
	  can have up to 16 Mips64v2 cores and 8 integrated gigabit ethernets.
	  Full details can be found at http://www.caviumnetworks.com.

config CPU_BMIPS
	bool "Broadcom BMIPS"
	depends on SYS_HAS_CPU_BMIPS
	select CPU_MIPS32
	select CPU_BMIPS32_3300 if SYS_HAS_CPU_BMIPS32_3300
	select CPU_BMIPS4350 if SYS_HAS_CPU_BMIPS4350
	select CPU_BMIPS4380 if SYS_HAS_CPU_BMIPS4380
	select CPU_BMIPS5000 if SYS_HAS_CPU_BMIPS5000
	select CPU_SUPPORTS_32BIT_KERNEL
	select DMA_NONCOHERENT
	select IRQ_MIPS_CPU
	select SWAP_IO_SPACE
	select WEAK_ORDERING
	select CPU_SUPPORTS_HIGHMEM
	select CPU_HAS_PREFETCH
	help
	  Support for BMIPS32/3300/4350/4380 and BMIPS5000 processors.

config CPU_XLR
	bool "Netlogic XLR SoC"
	depends on SYS_HAS_CPU_XLR
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select WEAK_ORDERING
	select WEAK_REORDERING_BEYOND_LLSC
	help
	  Netlogic Microsystems XLR/XLS processors.

config CPU_XLP
	bool "Netlogic XLP SoC"
	depends on SYS_HAS_CPU_XLP
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select WEAK_ORDERING
	select WEAK_REORDERING_BEYOND_LLSC
	select CPU_HAS_PREFETCH
	select CPU_MIPSR2
	select CPU_SUPPORTS_HUGEPAGES
	select MIPS_ASID_BITS_VARIABLE
	help
	  Netlogic Microsystems XLP processors.
endchoice

config CPU_MIPS32_3_5_FEATURES
	bool "MIPS32 Release 3.5 Features"
	depends on SYS_HAS_CPU_MIPS32_R3_5
	depends on CPU_MIPS32_R2 || CPU_MIPS32_R6
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS32 architecture including features from the 3.5 release such as
	  support for Enhanced Virtual Addressing (EVA).

config CPU_MIPS32_3_5_EVA
	bool "Enhanced Virtual Addressing (EVA)"
	depends on CPU_MIPS32_3_5_FEATURES
	select EVA
	default y
	help
	  Choose this option if you want to enable the Enhanced Virtual
	  Addressing (EVA) on your MIPS32 core (such as proAptiv).
	  One of its primary benefits is an increase in the maximum size
	  of lowmem (up to 3GB). If unsure, say 'N' here.

config CPU_MIPS32_R5_FEATURES
	bool "MIPS32 Release 5 Features"
	depends on SYS_HAS_CPU_MIPS32_R5
	depends on CPU_MIPS32_R2
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS32 architecture including features from release 5 such as
	  support for Extended Physical Addressing (XPA).

config CPU_MIPS32_R5_XPA
	bool "Extended Physical Addressing (XPA)"
	depends on CPU_MIPS32_R5_FEATURES
	depends on !EVA
	depends on !PAGE_SIZE_4KB
	depends on SYS_SUPPORTS_HIGHMEM
	select XPA
	select HIGHMEM
	select ARCH_PHYS_ADDR_T_64BIT
	default n
	help
	  Choose this option if you want to enable the Extended Physical
	  Addressing (XPA) on your MIPS32 core (such as P5600 series). The
	  benefit is to increase physical addressing equal to or greater
	  than 40 bits. Note that this has the side effect of turning on
	  64-bit addressing which in turn makes the PTEs 64-bit in size.
	  If unsure, say 'N' here.

if CPU_LOONGSON2F
config CPU_NOP_WORKAROUNDS
	bool

config CPU_JUMP_WORKAROUNDS
	bool

config CPU_LOONGSON2F_WORKAROUNDS
	bool "Loongson 2F Workarounds"
	default y
	select CPU_NOP_WORKAROUNDS
	select CPU_JUMP_WORKAROUNDS
	help
	  Loongson 2F01 / 2F02 processors have the NOP & JUMP issues which
	  require workarounds.  Without workarounds the system may hang
	  unexpectedly.  For more information please refer to the gas
	  -mfix-loongson2f-nop and -mfix-loongson2f-jump options.

	  Loongson 2F03 and later have fixed these issues and no workarounds
	  are needed.  The workarounds have no significant side effect on them
	  but may decrease the performance of the system so this option should
	  be disabled unless the kernel is intended to be run on 2F01 or 2F02
	  systems.

	  If unsure, please say Y.
endif # CPU_LOONGSON2F

config SYS_SUPPORTS_ZBOOT
	bool
	select HAVE_KERNEL_GZIP
	select HAVE_KERNEL_BZIP2
	select HAVE_KERNEL_LZ4
	select HAVE_KERNEL_LZMA
	select HAVE_KERNEL_LZO
	select HAVE_KERNEL_XZ

config SYS_SUPPORTS_ZBOOT_UART16550
	bool
	select SYS_SUPPORTS_ZBOOT

config SYS_SUPPORTS_ZBOOT_UART_PROM
	bool
	select SYS_SUPPORTS_ZBOOT

config CPU_LOONGSON2
	bool
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES

config CPU_LOONGSON1
	bool
	select CPU_MIPS32
	select CPU_MIPSR2
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_CPUFREQ

config CPU_BMIPS32_3300
	select SMP_UP if SMP
	bool

config CPU_BMIPS4350
	bool
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_HOTPLUG_CPU

config CPU_BMIPS4380
	bool
	select MIPS_L1_CACHE_SHIFT_6
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_HOTPLUG_CPU
	select CPU_HAS_RIXI

config CPU_BMIPS5000
	bool
	select MIPS_CPU_SCACHE
	select MIPS_L1_CACHE_SHIFT_7
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_HOTPLUG_CPU
	select CPU_HAS_RIXI

config SYS_HAS_CPU_LOONGSON3
	bool
	select CPU_SUPPORTS_CPUFREQ
	select CPU_HAS_RIXI

config SYS_HAS_CPU_LOONGSON2E
	bool

config SYS_HAS_CPU_LOONGSON2F
	bool
	select CPU_SUPPORTS_CPUFREQ
	select CPU_SUPPORTS_ADDRWINCFG if 64BIT
	select CPU_SUPPORTS_UNCACHED_ACCELERATED

config SYS_HAS_CPU_LOONGSON1B
	bool

config SYS_HAS_CPU_LOONGSON1C
	bool

config SYS_HAS_CPU_MIPS32_R1
	bool

config SYS_HAS_CPU_MIPS32_R2
	bool

config SYS_HAS_CPU_MIPS32_R3_5
	bool

config SYS_HAS_CPU_MIPS32_R5
	bool

config SYS_HAS_CPU_MIPS32_R6
	bool

config SYS_HAS_CPU_MIPS64_R1
	bool

config SYS_HAS_CPU_MIPS64_R2
	bool

config SYS_HAS_CPU_MIPS64_R6
	bool

config SYS_HAS_CPU_R3000
	bool

config SYS_HAS_CPU_TX39XX
	bool

config SYS_HAS_CPU_VR41XX
	bool

config SYS_HAS_CPU_R4300
	bool

config SYS_HAS_CPU_R4X00
	bool

config SYS_HAS_CPU_TX49XX
	bool

config SYS_HAS_CPU_R5000
	bool

config SYS_HAS_CPU_R5432
	bool

config SYS_HAS_CPU_R5500
	bool

config SYS_HAS_CPU_R6000
	bool

config SYS_HAS_CPU_NEVADA
	bool

config SYS_HAS_CPU_R8000
	bool

config SYS_HAS_CPU_R10000
	bool

config SYS_HAS_CPU_RM7000
	bool

config SYS_HAS_CPU_SB1
	bool

config SYS_HAS_CPU_CAVIUM_OCTEON
	bool

config SYS_HAS_CPU_BMIPS
	bool

config SYS_HAS_CPU_BMIPS32_3300
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_BMIPS4350
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_BMIPS4380
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_BMIPS5000
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_XLR
	bool

config SYS_HAS_CPU_XLP
	bool

config MIPS_MALTA_PM
	depends on MIPS_MALTA
	depends on PCI
	bool
	default y

#
# CPU may reorder R->R, R->W, W->R, W->W
# Reordering beyond LL and SC is handled in WEAK_REORDERING_BEYOND_LLSC
#
config WEAK_ORDERING
	bool

#
# CPU may reorder reads and writes beyond LL/SC
# CPU may reorder R->LL, R->LL, W->LL, W->LL, R->SC, R->SC, W->SC, W->SC
#
config WEAK_REORDERING_BEYOND_LLSC
	bool
endmenu

#
# These two indicate any level of the MIPS32 and MIPS64 architecture
#
config CPU_MIPS32
	bool
	default y if CPU_MIPS32_R1 || CPU_MIPS32_R2 || CPU_MIPS32_R6

config CPU_MIPS64
	bool
	default y if CPU_MIPS64_R1 || CPU_MIPS64_R2 || CPU_MIPS64_R6

#
# These two indicate the revision of the architecture, either Release 1 or Release 2
#
config CPU_MIPSR1
	bool
	default y if CPU_MIPS32_R1 || CPU_MIPS64_R1

config CPU_MIPSR2
	bool
	default y if CPU_MIPS32_R2 || CPU_MIPS64_R2 || CPU_CAVIUM_OCTEON
	select CPU_HAS_RIXI
	select MIPS_SPRAM

config CPU_MIPSR6
	bool
	default y if CPU_MIPS32_R6 || CPU_MIPS64_R6
	select CPU_HAS_RIXI
	select HAVE_ARCH_BITREVERSE
	select MIPS_ASID_BITS_VARIABLE
	select MIPS_SPRAM

config EVA
	bool

config XPA
	bool

config SYS_SUPPORTS_32BIT_KERNEL
	bool
config SYS_SUPPORTS_64BIT_KERNEL
	bool
config CPU_SUPPORTS_32BIT_KERNEL
	bool
config CPU_SUPPORTS_64BIT_KERNEL
	bool
config CPU_SUPPORTS_CPUFREQ
	bool
config CPU_SUPPORTS_ADDRWINCFG
	bool
config CPU_SUPPORTS_HUGEPAGES
	bool
config CPU_SUPPORTS_UNCACHED_ACCELERATED
	bool
config MIPS_PGD_C0_CONTEXT
	bool
	default y if 64BIT && CPU_MIPSR2 && !CPU_XLP

#
# Set to y for ptrace access to watch registers.
#
config HARDWARE_WATCHPOINTS
       bool
       default y if CPU_MIPSR1 || CPU_MIPSR2 || CPU_MIPSR6

menu "Kernel type"

choice
	prompt "Kernel code model"
	help
	  You should only select this option if you have a workload that
	  actually benefits from 64-bit processing or if your machine has
	  large memory.  You will only be presented a single option in this
	  menu if your system does not support both 32-bit and 64-bit kernels.

config 32BIT
	bool "32-bit kernel"
	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
	select TRAD_SIGNALS
	help
	  Select this option if you want to build a 32-bit kernel.

config 64BIT
	bool "64-bit kernel"
	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
	help
	  Select this option if you want to build a 64-bit kernel.

endchoice

config KVM_GUEST
	bool "KVM Guest Kernel"
	depends on BROKEN_ON_SMP
	help
	  Select this option if building a guest kernel for KVM (Trap & Emulate)
	  mode.

config KVM_GUEST_TIMER_FREQ
	int "Count/Compare Timer Frequency (MHz)"
	depends on KVM_GUEST
	default 100
	help
	  Set this to non-zero if building a guest kernel for KVM to skip RTC
	  emulation when determining guest CPU Frequency. Instead, the guest's
	  timer frequency is specified directly.

config MIPS_VA_BITS_48
	bool "48 bits virtual memory"
	depends on 64BIT
	help
	  Support a maximum at least 48 bits of application virtual memory.
	  Default is 40 bits or less, depending on the CPU.
	  This option result in a small memory overhead for page tables.
	  This option is only supported with 16k and 64k page sizes.
	  If unsure, say N.

choice
	prompt "Kernel page size"
	default PAGE_SIZE_4KB

config PAGE_SIZE_4KB
	bool "4kB"
	depends on !CPU_LOONGSON2 && !CPU_LOONGSON3
	depends on !MIPS_VA_BITS_48
	help
	 This option select the standard 4kB Linux page size.  On some
	 R3000-family processors this is the only available page size.  Using
	 4kB page size will minimize memory consumption and is therefore
	 recommended for low memory systems.

config PAGE_SIZE_8KB
	bool "8kB"
	depends on CPU_R8000 || CPU_CAVIUM_OCTEON
	depends on !MIPS_VA_BITS_48
	help
	  Using 8kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available
	  only on R8000 and cnMIPS processors.  Note that you will need a
	  suitable Linux distribution to support this.

config PAGE_SIZE_16KB
	bool "16kB"
	depends on !CPU_R3000 && !CPU_TX39XX
	help
	  Using 16kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available on
	  all non-R3000 family processors.  Note that you will need a suitable
	  Linux distribution to support this.

config PAGE_SIZE_32KB
	bool "32kB"
	depends on CPU_CAVIUM_OCTEON
	depends on !MIPS_VA_BITS_48
	help
	  Using 32kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available
	  only on cnMIPS cores.  Note that you will need a suitable Linux
	  distribution to support this.

config PAGE_SIZE_64KB
	bool "64kB"
	depends on !CPU_R3000 && !CPU_TX39XX && !CPU_R6000
	help
	  Using 64kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available on
	  all non-R3000 family processor.  Not that at the time of this
	  writing this option is still high experimental.

endchoice

config FORCE_MAX_ZONEORDER
	int "Maximum zone order"
	range 14 64 if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_64KB
	default "14" if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_64KB
	range 13 64 if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_32KB
	default "13" if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_32KB
	range 12 64 if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_16KB
	default "12" if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_16KB
	range 11 64
	default "11"
	help
	  The kernel memory allocator divides physically contiguous memory
	  blocks into "zones", where each zone is a power of two number of
	  pages.  This option selects the largest power of two that the kernel
	  keeps in the memory allocator.  If you need to allocate very large
	  blocks of physically contiguous memory, then you may need to
	  increase this value.

	  This config option is actually maximum order plus one. For example,
	  a value of 11 means that the largest free memory block is 2^10 pages.

	  The page size is not necessarily 4KB.  Keep this in mind
	  when choosing a value for this option.

config BOARD_SCACHE
	bool

config IP22_CPU_SCACHE
	bool
	select BOARD_SCACHE

#
# Support for a MIPS32 / MIPS64 style S-caches
#
config MIPS_CPU_SCACHE
	bool
	select BOARD_SCACHE

config R5000_CPU_SCACHE
	bool
	select BOARD_SCACHE

config RM7000_CPU_SCACHE
	bool
	select BOARD_SCACHE

config SIBYTE_DMA_PAGEOPS
	bool "Use DMA to clear/copy pages"
	depends on CPU_SB1
	help
	  Instead of using the CPU to zero and copy pages, use a Data Mover
	  channel.  These DMA channels are otherwise unused by the standard
	  SiByte Linux port.  Seems to give a small performance benefit.

config CPU_HAS_PREFETCH
	bool

config CPU_GENERIC_DUMP_TLB
	bool
	default y if !(CPU_R3000 || CPU_R6000 || CPU_R8000 || CPU_TX39XX)

config CPU_R4K_FPU
	bool
	default y if !(CPU_R3000 || CPU_R6000 || CPU_TX39XX || CPU_CAVIUM_OCTEON)

config CPU_R4K_CACHE_TLB
	bool
	default y if !(CPU_R3000 || CPU_R8000 || CPU_SB1 || CPU_TX39XX || CPU_CAVIUM_OCTEON)

config MIPS_MT_SMP
	bool "MIPS MT SMP support (1 TC on each available VPE)"
	depends on SYS_SUPPORTS_MULTITHREADING && !CPU_MIPSR6
	select CPU_MIPSR2_IRQ_VI
	select CPU_MIPSR2_IRQ_EI
	select SYNC_R4K
	select MIPS_MT
	select SMP
	select SMP_UP
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_SCHED_SMT
	select MIPS_PERF_SHARED_TC_COUNTERS
	help
	  This is a kernel model which is known as SMVP. This is supported
	  on cores with the MT ASE and uses the available VPEs to implement
	  virtual processors which supports SMP. This is equivalent to the
	  Intel Hyperthreading feature. For further information go to
	  <http://www.imgtec.com/mips/mips-multithreading.asp>.

config MIPS_MT
	bool

config SCHED_SMT
	bool "SMT (multithreading) scheduler support"
	depends on SYS_SUPPORTS_SCHED_SMT
	default n
	help
	  SMT scheduler support improves the CPU scheduler's decision making
	  when dealing with MIPS MT enabled cores at a cost of slightly
	  increased overhead in some places. If unsure say N here.

config SYS_SUPPORTS_SCHED_SMT
	bool

config SYS_SUPPORTS_MULTITHREADING
	bool

config MIPS_MT_FPAFF
	bool "Dynamic FPU affinity for FP-intensive threads"
	default y
	depends on MIPS_MT_SMP

config MIPSR2_TO_R6_EMULATOR
	bool "MIPS R2-to-R6 emulator"
	depends on CPU_MIPSR6 && !SMP
	default y
	help
	  Choose this option if you want to run non-R6 MIPS userland code.
	  Even if you say 'Y' here, the emulator will still be disabled by
	  default. You can enable it using the 'mipsr2emu' kernel option.
	  The only reason this is a build-time option is to save ~14K from the
	  final kernel image.
comment "MIPS R2-to-R6 emulator is only available for UP kernels"
	depends on SMP && CPU_MIPSR6

config MIPS_VPE_LOADER
	bool "VPE loader support."
	depends on SYS_SUPPORTS_MULTITHREADING && MODULES
	select CPU_MIPSR2_IRQ_VI
	select CPU_MIPSR2_IRQ_EI
	select MIPS_MT
	help
	  Includes a loader for loading an elf relocatable object
	  onto another VPE and running it.

config MIPS_VPE_LOADER_CMP
	bool
	default "y"
	depends on MIPS_VPE_LOADER && MIPS_CMP

config MIPS_VPE_LOADER_MT
	bool
	default "y"
	depends on MIPS_VPE_LOADER && !MIPS_CMP

config MIPS_VPE_LOADER_TOM
	bool "Load VPE program into memory hidden from linux"
	depends on MIPS_VPE_LOADER
	default y
	help
	  The loader can use memory that is present but has been hidden from
	  Linux using the kernel command line option "mem=xxMB". It's up to
	  you to ensure the amount you put in the option and the space your
	  program requires is less or equal to the amount physically present.

config MIPS_VPE_APSP_API
	bool "Enable support for AP/SP API (RTLX)"
	depends on MIPS_VPE_LOADER
	help

config MIPS_VPE_APSP_API_CMP
	bool
	default "y"
	depends on MIPS_VPE_APSP_API && MIPS_CMP

config MIPS_VPE_APSP_API_MT
	bool
	default "y"
	depends on MIPS_VPE_APSP_API && !MIPS_CMP

config MIPS_CMP
	bool "MIPS CMP framework support (DEPRECATED)"
	depends on SYS_SUPPORTS_MIPS_CMP && !CPU_MIPSR6
	select SMP
	select SYNC_R4K
	select SYS_SUPPORTS_SMP
	select WEAK_ORDERING
	default n
	help
	  Select this if you are using a bootloader which implements the "CMP
	  framework" protocol (ie. YAMON) and want your kernel to make use of
	  its ability to start secondary CPUs.

	  Unless you have a specific need, you should use CONFIG_MIPS_CPS
	  instead of this.

config MIPS_CPS
	bool "MIPS Coherent Processing System support"
	depends on SYS_SUPPORTS_MIPS_CPS
	select MIPS_CM
	select MIPS_CPC
	select MIPS_CPS_PM if HOTPLUG_CPU
	select SMP
	select SYNC_R4K if (CEVT_R4K || CSRC_R4K)
	select SYS_SUPPORTS_HOTPLUG_CPU
	select SYS_SUPPORTS_SMP
	select WEAK_ORDERING
	help
	  Select this if you wish to run an SMP kernel across multiple cores
	  within a MIPS Coherent Processing System. When this option is
	  enabled the kernel will probe for other cores and boot them with
	  no external assistance. It is safe to enable this when hardware
	  support is unavailable.

config MIPS_CPS_PM
	depends on MIPS_CPS
	select MIPS_CPC
	bool

config MIPS_CM
	bool

config MIPS_CPC
	bool

config SB1_PASS_2_WORKAROUNDS
	bool
	depends on CPU_SB1 && (CPU_SB1_PASS_2_2 || CPU_SB1_PASS_2)
	default y

config SB1_PASS_2_1_WORKAROUNDS
	bool
	depends on CPU_SB1 && CPU_SB1_PASS_2
	default y


config ARCH_PHYS_ADDR_T_64BIT
       bool

choice
	prompt "SmartMIPS or microMIPS ASE support"

config CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS
	bool "None"
	help
	  Select this if you want neither microMIPS nor SmartMIPS support

config CPU_HAS_SMARTMIPS
	depends on SYS_SUPPORTS_SMARTMIPS
	bool "SmartMIPS"
	help
	  SmartMIPS is a extension of the MIPS32 architecture aimed at
	  increased security at both hardware and software level for
	  smartcards.  Enabling this option will allow proper use of the
	  SmartMIPS instructions by Linux applications.  However a kernel with
	  this option will not work on a MIPS core without SmartMIPS core.  If
	  you don't know you probably don't have SmartMIPS and should say N
	  here.

config CPU_MICROMIPS
	depends on 32BIT && SYS_SUPPORTS_MICROMIPS && !CPU_MIPSR6
	bool "microMIPS"
	help
	  When this option is enabled the kernel will be built using the
	  microMIPS ISA

endchoice

config CPU_HAS_MSA
	bool "Support for the MIPS SIMD Architecture"
	depends on CPU_SUPPORTS_MSA
	depends on 64BIT || MIPS_O32_FP64_SUPPORT
	help
	  MIPS SIMD Architecture (MSA) introduces 128 bit wide vector registers
	  and a set of SIMD instructions to operate on them. When this option
	  is enabled the kernel will support allocating & switching MSA
	  vector register contexts. If you know that your kernel will only be
	  running on CPUs which do not support MSA or that your userland will
	  not be making use of it then you may wish to say N here to reduce
	  the size & complexity of your kernel.

	  If unsure, say Y.

config CPU_HAS_WB
	bool

config XKS01
	bool

config CPU_HAS_RIXI
	bool

#
# Vectored interrupt mode is an R2 feature
#
config CPU_MIPSR2_IRQ_VI
	bool

#
# Extended interrupt mode is an R2 feature
#
config CPU_MIPSR2_IRQ_EI
	bool

config CPU_HAS_SYNC
	bool
	depends on !CPU_R3000
	default y

#
# CPU non-features
#
config CPU_DADDI_WORKAROUNDS
	bool

config CPU_R4000_WORKAROUNDS
	bool
	select CPU_R4400_WORKAROUNDS

config CPU_R4400_WORKAROUNDS
	bool

config MIPS_ASID_SHIFT
	int
	default 6 if CPU_R3000 || CPU_TX39XX
	default 4 if CPU_R8000
	default 0

config MIPS_ASID_BITS
	int
	default 0 if MIPS_ASID_BITS_VARIABLE
	default 6 if CPU_R3000 || CPU_TX39XX
	default 8

config MIPS_ASID_BITS_VARIABLE
	bool

#
# - Highmem only makes sense for the 32-bit kernel.
# - The current highmem code will only work properly on physically indexed
#   caches such as R3000, SB1, R7000 or those that look like they're virtually
#   indexed such as R4000/R4400 SC and MC versions or R10000.  So for the
#   moment we protect the user and offer the highmem option only on machines
#   where it's known to be safe.  This will not offer highmem on a few systems
#   such as MIPS32 and MIPS64 CPUs which may have virtual and physically
#   indexed CPUs but we're playing safe.
# - We use SYS_SUPPORTS_HIGHMEM to offer highmem only for systems where we
#   know they might have memory configurations that could make use of highmem
#   support.
#
config HIGHMEM
	bool "High Memory Support"
	depends on 32BIT && CPU_SUPPORTS_HIGHMEM && SYS_SUPPORTS_HIGHMEM && !CPU_MIPS32_3_5_EVA

config CPU_SUPPORTS_HIGHMEM
	bool

config SYS_SUPPORTS_HIGHMEM
	bool

config SYS_SUPPORTS_SMARTMIPS
	bool

config SYS_SUPPORTS_MICROMIPS
	bool

config SYS_SUPPORTS_MIPS16
	bool
	help
	  This option must be set if a kernel might be executed on a MIPS16-
	  enabled CPU even if MIPS16 is not actually being used.  In other
	  words, it makes the kernel MIPS16-tolerant.

config CPU_SUPPORTS_MSA
	bool

config ARCH_FLATMEM_ENABLE
	def_bool y
	depends on !NUMA && !CPU_LOONGSON2

config ARCH_DISCONTIGMEM_ENABLE
	bool
	default y if SGI_IP27
	help
	  Say Y to support efficient handling of discontiguous physical memory,
	  for architectures which are either NUMA (Non-Uniform Memory Access)
	  or have huge holes in the physical address space for other reasons.
	  See <file:Documentation/vm/numa> for more.

config ARCH_SPARSEMEM_ENABLE
	bool
	select SPARSEMEM_STATIC

config NUMA
	bool "NUMA Support"
	depends on SYS_SUPPORTS_NUMA
	help
	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
	  Access).  This option improves performance on systems with more
	  than two nodes; on two node systems it is generally better to
	  leave it disabled; on single node systems disable this option
	  disabled.

config SYS_SUPPORTS_NUMA
	bool

config RELOCATABLE
	bool "Relocatable kernel"
	depends on SYS_SUPPORTS_RELOCATABLE && (CPU_MIPS32_R2 || CPU_MIPS64_R2 || CPU_MIPS32_R6 || CPU_MIPS64_R6)
	help
	  This builds a kernel image that retains relocation information
	  so it can be loaded someplace besides the default 1MB.
	  The relocations make the kernel binary about 15% larger,
	  but are discarded at runtime

config RELOCATION_TABLE_SIZE
	hex "Relocation table size"
	depends on RELOCATABLE
	range 0x0 0x01000000
	default "0x00100000"
	---help---
	  A table of relocation data will be appended to the kernel binary
	  and parsed at boot to fix up the relocated kernel.

	  This option allows the amount of space reserved for the table to be
	  adjusted, although the default of 1Mb should be ok in most cases.

	  The build will fail and a valid size suggested if this is too small.

	  If unsure, leave at the default value.

config RANDOMIZE_BASE
	bool "Randomize the address of the kernel image"
	depends on RELOCATABLE
	---help---
	   Randomizes the physical and virtual address at which the
	   kernel image is loaded, as a security feature that
	   deters exploit attempts relying on knowledge of the location
	   of kernel internals.

	   Entropy is generated using any coprocessor 0 registers available.

	   The kernel will be offset by up to RANDOMIZE_BASE_MAX_OFFSET.

	   If unsure, say N.

config RANDOMIZE_BASE_MAX_OFFSET
	hex "Maximum kASLR offset" if EXPERT
	depends on RANDOMIZE_BASE
	range 0x0 0x40000000 if EVA || 64BIT
	range 0x0 0x08000000
	default "0x01000000"
	---help---
	  When kASLR is active, this provides the maximum offset that will
	  be applied to the kernel image. It should be set according to the
	  amount of physical RAM available in the target system minus
	  PHYSICAL_START and must be a power of 2.

	  This is limited by the size of KSEG0, 256Mb on 32-bit or 1Gb with
	  EVA or 64-bit. The default is 16Mb.

config NODES_SHIFT
	int
	default "6"
	depends on NEED_MULTIPLE_NODES

config HW_PERF_EVENTS
	bool "Enable hardware performance counter support for perf events"
	depends on PERF_EVENTS && !OPROFILE && (CPU_MIPS32 || CPU_MIPS64 || CPU_R10000 || CPU_SB1 || CPU_CAVIUM_OCTEON || CPU_XLP || CPU_LOONGSON3)
	default y
	help
	  Enable hardware performance counter support for perf events. If
	  disabled, perf events will use software events only.

source "mm/Kconfig"

config SMP
	bool "Multi-Processing support"
	depends on SYS_SUPPORTS_SMP
	help
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, say N. If you have a system with more
	  than one CPU, say Y.

	  If you say N here, the kernel will run on uni- and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  uniprocessor machines. On a uniprocessor machine, the kernel
	  will run faster if you say N here.

	  People using multiprocessor machines who say Y here should also say
	  Y to "Enhanced Real Time Clock Support", below.

	  See also the SMP-HOWTO available at
	  <http://www.tldp.org/docs.html#howto>.

	  If you don't know what to do here, say N.

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs"
	depends on SMP && SYS_SUPPORTS_HOTPLUG_CPU
	help
	  Say Y here to allow turning CPUs off and on. CPUs can be
	  controlled through /sys/devices/system/cpu.
	  (Note: power management support will enable this option
	    automatically on SMP systems. )
	  Say N if you want to disable CPU hotplug.

config SMP_UP
	bool

config SYS_SUPPORTS_MIPS_CMP
	bool

config SYS_SUPPORTS_MIPS_CPS
	bool

config SYS_SUPPORTS_SMP
	bool

config NR_CPUS_DEFAULT_4
	bool

config NR_CPUS_DEFAULT_8
	bool

config NR_CPUS_DEFAULT_16
	bool

config NR_CPUS_DEFAULT_32
	bool

config NR_CPUS_DEFAULT_64
	bool

config NR_CPUS
	int "Maximum number of CPUs (2-256)"
	range 2 256
	depends on SMP
	default "4" if NR_CPUS_DEFAULT_4
	default "8" if NR_CPUS_DEFAULT_8
	default "16" if NR_CPUS_DEFAULT_16
	default "32" if NR_CPUS_DEFAULT_32
	default "64" if NR_CPUS_DEFAULT_64
	help
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support.  The maximum supported value is 32 for 32-bit
	  kernel and 64 for 64-bit kernels; the minimum value which makes
	  sense is 1 for Qemu (useful only for kernel debugging purposes)
	  and 2 for all others.

	  This is purely to save memory - each supported CPU adds
	  approximately eight kilobytes to the kernel image.  For best
	  performance should round up your number of processors to the next
	  power of two.

config MIPS_PERF_SHARED_TC_COUNTERS
	bool

#
# Timer Interrupt Frequency Configuration
#

choice
	prompt "Timer frequency"
	default HZ_250
	help
	 Allows the configuration of the timer frequency.

	config HZ_24
		bool "24 HZ" if SYS_SUPPORTS_24HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_48
		bool "48 HZ" if SYS_SUPPORTS_48HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_100
		bool "100 HZ" if SYS_SUPPORTS_100HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_128
		bool "128 HZ" if SYS_SUPPORTS_128HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_250
		bool "250 HZ" if SYS_SUPPORTS_250HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_256
		bool "256 HZ" if SYS_SUPPORTS_256HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_1000
		bool "1000 HZ" if SYS_SUPPORTS_1000HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_1024
		bool "1024 HZ" if SYS_SUPPORTS_1024HZ || SYS_SUPPORTS_ARBIT_HZ

endchoice

config SYS_SUPPORTS_24HZ
	bool

config SYS_SUPPORTS_48HZ
	bool

config SYS_SUPPORTS_100HZ
	bool

config SYS_SUPPORTS_128HZ
	bool

config SYS_SUPPORTS_250HZ
	bool

config SYS_SUPPORTS_256HZ
	bool

config SYS_SUPPORTS_1000HZ
	bool

config SYS_SUPPORTS_1024HZ
	bool

config SYS_SUPPORTS_ARBIT_HZ
	bool
	default y if !SYS_SUPPORTS_24HZ && \
		     !SYS_SUPPORTS_48HZ && \
		     !SYS_SUPPORTS_100HZ && \
		     !SYS_SUPPORTS_128HZ && \
		     !SYS_SUPPORTS_250HZ && \
		     !SYS_SUPPORTS_256HZ && \
		     !SYS_SUPPORTS_1000HZ && \
		     !SYS_SUPPORTS_1024HZ

config HZ
	int
	default 24 if HZ_24
	default 48 if HZ_48
	default 100 if HZ_100
	default 128 if HZ_128
	default 250 if HZ_250
	default 256 if HZ_256
	default 1000 if HZ_1000
	default 1024 if HZ_1024

config SCHED_HRTICK
	def_bool HIGH_RES_TIMERS

source "kernel/Kconfig.preempt"

config KEXEC
	bool "Kexec system call"
	select KEXEC_CORE
	help
	  kexec is a system call that implements the ability to shutdown your
	  current kernel, and to start another kernel.  It is like a reboot
	  but it is independent of the system firmware.   And like a reboot
	  you can start any kernel with it, not just Linux.

	  The name comes from the similarity to the exec system call.

	  It is an ongoing process to be certain the hardware in a machine
	  is properly shutdown, so do not be surprised if this code does not
	  initially work for you.  As of this writing the exact hardware
	  interface is strongly in flux, so no good recommendation can be
	  made.

config CRASH_DUMP
	  bool "Kernel crash dumps"
	  help
	  Generate crash dump after being started by kexec.
	  This should be normally only set in special crash dump kernels
	  which are loaded in the main kernel with kexec-tools into
	  a specially reserved region and then later executed after
	  a crash by kdump/kexec. The crash dump kernel must be compiled
	  to a memory address not used by the main kernel or firmware using
	  PHYSICAL_START.

config PHYSICAL_START
	  hex "Physical address where the kernel is loaded"
	  default "0xffffffff84000000" if 64BIT
	  default "0x84000000" if 32BIT
	  depends on CRASH_DUMP
	  help
	  This gives the CKSEG0 or KSEG0 address where the kernel is loaded.
	  If you plan to use kernel for capturing the crash dump change
	  this value to start of the reserved region (the "X" value as
	  specified in the "crashkernel=YM@XM" command line boot parameter
	  passed to the panic-ed kernel).

config SECCOMP
	bool "Enable seccomp to safely compute untrusted bytecode"
	depends on PROC_FS
	default y
	help
	  This kernel feature is useful for number crunching applications
	  that may need to compute untrusted bytecode during their
	  execution. By using pipes or other transports made available to
	  the process as file descriptors supporting the read/write
	  syscalls, it's possible to isolate those applications in
	  their own address space using seccomp. Once seccomp is
	  enabled via /proc/<pid>/seccomp, it cannot be disabled
	  and the task is only allowed to execute a few safe syscalls
	  defined by each seccomp mode.

	  If unsure, say Y. Only embedded should say N here.

config MIPS_O32_FP64_SUPPORT
	bool "Support for O32 binaries using 64-bit FP"
	depends on 32BIT || MIPS32_O32
	help
	  When this is enabled, the kernel will support use of 64-bit floating
	  point registers with binaries using the O32 ABI along with the
	  EF_MIPS_FP64 ELF header flag (typically built with -mfp64). On
	  32-bit MIPS systems this support is at the cost of increasing the
	  size and complexity of the compiled FPU emulator. Thus if you are
	  running a MIPS32 system and know that none of your userland binaries
	  will require 64-bit floating point, you may wish to reduce the size
	  of your kernel & potentially improve FP emulation performance by
	  saying N here.

	  Although binutils currently supports use of this flag the details
	  concerning its effect upon the O32 ABI in userland are still being
	  worked on. In order to avoid userland becoming dependant upon current
	  behaviour before the details have been finalised, this option should
	  be considered experimental and only enabled by those working upon
	  said details.

	  If unsure, say N.

config USE_OF
	bool
	select OF
	select OF_EARLY_FLATTREE
	select IRQ_DOMAIN

config BUILTIN_DTB
	bool

choice
	prompt "Kernel appended dtb support" if USE_OF
	default MIPS_NO_APPENDED_DTB

	config MIPS_NO_APPENDED_DTB
		bool "None"
		help
		  Do not enable appended dtb support.

	config MIPS_ELF_APPENDED_DTB
		bool "vmlinux"
		help
		  With this option, the boot code will look for a device tree binary
		  DTB) included in the vmlinux ELF section .appended_dtb. By default
		  it is empty and the DTB can be appended using binutils command
		  objcopy:

		    objcopy --update-section .appended_dtb=<filename>.dtb vmlinux

		  This is meant as a backward compatiblity convenience for those
		  systems with a bootloader that can't be upgraded to accommodate
		  the documented boot protocol using a device tree.

	config MIPS_RAW_APPENDED_DTB
		bool "vmlinux.bin or vmlinuz.bin"
		help
		  With this option, the boot code will look for a device tree binary
		  DTB) appended to raw vmlinux.bin or vmlinuz.bin.
		  (e.g. cat vmlinux.bin <filename>.dtb > vmlinux_w_dtb).

		  This is meant as a backward compatibility convenience for those
		  systems with a bootloader that can't be upgraded to accommodate
		  the documented boot protocol using a device tree.

		  Beware that there is very little in terms of protection against
		  this option being confused by leftover garbage in memory that might
		  look like a DTB header after a reboot if no actual DTB is appended
		  to vmlinux.bin.  Do not leave this option active in a production kernel
		  if you don't intend to always append a DTB.
endchoice

choice
	prompt "Kernel command line type" if !CMDLINE_OVERRIDE
	default MIPS_CMDLINE_FROM_DTB if USE_OF && !ATH79 && !MACH_INGENIC && \
					 !MIPS_MALTA && \
					 !CAVIUM_OCTEON_SOC
	default MIPS_CMDLINE_FROM_BOOTLOADER

	config MIPS_CMDLINE_FROM_DTB
		depends on USE_OF
		bool "Dtb kernel arguments if available"

	config MIPS_CMDLINE_DTB_EXTEND
		depends on USE_OF
		bool "Extend dtb kernel arguments with bootloader arguments"

	config MIPS_CMDLINE_FROM_BOOTLOADER
		bool "Bootloader kernel arguments if available"

	config MIPS_CMDLINE_BUILTIN_EXTEND
		depends on CMDLINE_BOOL
		bool "Extend builtin kernel arguments with bootloader arguments"
endchoice

endmenu

config LOCKDEP_SUPPORT
	bool
	default y

config STACKTRACE_SUPPORT
	bool
	default y

config HAVE_LATENCYTOP_SUPPORT
	bool
	default y

config PGTABLE_LEVELS
	int
	default 3 if 64BIT && !PAGE_SIZE_64KB
	default 2

source "init/Kconfig"

source "kernel/Kconfig.freezer"

menu "Bus options (PCI, PCMCIA, EISA, ISA, TC)"

config HW_HAS_EISA
	bool
config HW_HAS_PCI
	bool

config PCI
	bool "Support for PCI controller"
	depends on HW_HAS_PCI
	select PCI_DOMAINS
	help
	  Find out whether you have a PCI motherboard. PCI is the name of a
	  bus system, i.e. the way the CPU talks to the other stuff inside
	  your box. Other bus systems are ISA, EISA, or VESA. If you have PCI,
	  say Y, otherwise N.

config HT_PCI
	bool "Support for HT-linked PCI"
	default y
	depends on CPU_LOONGSON3
	select PCI
	select PCI_DOMAINS
	help
	  Loongson family machines use Hyper-Transport bus for inter-core
	  connection and device connection. The PCI bus is a subordinate
	  linked at HT. Choose Y for Loongson-3 based machines.

config PCI_DOMAINS
	bool

config PCI_DOMAINS_GENERIC
	bool

config PCI_DRIVERS_GENERIC
	select PCI_DOMAINS_GENERIC if PCI_DOMAINS
	bool

config PCI_DRIVERS_LEGACY
	def_bool !PCI_DRIVERS_GENERIC
	select NO_GENERIC_PCI_IOPORT_MAP

source "drivers/pci/Kconfig"

#
# ISA support is now enabled via select.  Too many systems still have the one
# or other ISA chip on the board that users don't know about so don't expect
# users to choose the right thing ...
#
config ISA
	bool

config EISA
	bool "EISA support"
	depends on HW_HAS_EISA
	select ISA
	select GENERIC_ISA_DMA
	---help---
	  The Extended Industry Standard Architecture (EISA) bus was
	  developed as an open alternative to the IBM MicroChannel bus.

	  The EISA bus provided some of the features of the IBM MicroChannel
	  bus while maintaining backward compatibility with cards made for
	  the older ISA bus.  The EISA bus saw limited use between 1988 and
	  1995 when it was made obsolete by the PCI bus.

	  Say Y here if you are building a kernel for an EISA-based machine.

	  Otherwise, say N.

source "drivers/eisa/Kconfig"

config TC
	bool "TURBOchannel support"
	depends on MACH_DECSTATION
	help
	  TURBOchannel is a DEC (now Compaq (now HP)) bus for Alpha and MIPS
	  processors.  TURBOchannel programming specifications are available
	  at:
	  <ftp://ftp.hp.com/pub/alphaserver/archive/triadd/>
	  and:
	  <http://www.computer-refuge.org/classiccmp/ftp.digital.com/pub/DEC/TriAdd/>
	  Linux driver support status is documented at:
	  <http://www.linux-mips.org/wiki/DECstation>

config MMU
	bool
	default y

config I8253
	bool
	select CLKSRC_I8253
	select CLKEVT_I8253
	select MIPS_EXTERNAL_TIMER

config ZONE_DMA
	bool

config ZONE_DMA32
	bool

source "drivers/pcmcia/Kconfig"

config RAPIDIO
	tristate "RapidIO support"
	depends on PCI
	default n
	help
	  If you say Y here, the kernel will include drivers and
	  infrastructure code to support RapidIO interconnect devices.

source "drivers/rapidio/Kconfig"

endmenu

menu "Executable file formats"

source "fs/Kconfig.binfmt"

config TRAD_SIGNALS
	bool

config MIPS32_COMPAT
	bool

config COMPAT
	bool

config SYSVIPC_COMPAT
	bool

config MIPS32_O32
	bool "Kernel support for o32 binaries"
	depends on 64BIT
	select ARCH_WANT_OLD_COMPAT_IPC
	select COMPAT
	select MIPS32_COMPAT
	select SYSVIPC_COMPAT if SYSVIPC
	help
	  Select this option if you want to run o32 binaries.  These are pure
	  32-bit binaries as used by the 32-bit Linux/MIPS port.  Most of
	  existing binaries are in this format.

	  If unsure, say Y.

config MIPS32_N32
	bool "Kernel support for n32 binaries"
	depends on 64BIT
	select COMPAT
	select MIPS32_COMPAT
	select SYSVIPC_COMPAT if SYSVIPC
	help
	  Select this option if you want to run n32 binaries.  These are
	  64-bit binaries using 32-bit quantities for addressing and certain
	  data that would normally be 64-bit.  They are used in special
	  cases.

	  If unsure, say N.

config BINFMT_ELF32
	bool
	default y if MIPS32_O32 || MIPS32_N32
	select ELFCORE

endmenu

menu "Power management options"

config ARCH_HIBERNATION_POSSIBLE
	def_bool y
	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP

config ARCH_SUSPEND_POSSIBLE
	def_bool y
	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP

source "kernel/power/Kconfig"

endmenu

config MIPS_EXTERNAL_TIMER
	bool

menu "CPU Power Management"

if CPU_SUPPORTS_CPUFREQ && MIPS_EXTERNAL_TIMER
source "drivers/cpufreq/Kconfig"
endif

source "drivers/cpuidle/Kconfig"

endmenu

source "net/Kconfig"

source "drivers/Kconfig"

source "drivers/firmware/Kconfig"

source "fs/Kconfig"

source "arch/mips/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"

source "arch/mips/kvm/Kconfig"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /***********************license start***************
 * Author: Cavium Networks
 *
 * Contact: support@caviumnetworks.com
 * This file is part of the OCTEON SDK
 *
 * Copyright (c) 2003-2012 Cavium Networks
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, Version 2, as
 * published by the Free Software Foundation.
 *
 * This file is distributed in the hope that it will be useful, but
 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
 * NONINFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 * or visit http://www.gnu.org/licenses/.
 *
 * This file may also be available under a different license from Cavium.
 * Contact Cavium Networks for more information
 ***********************license end**************************************/

#ifndef __CVMX_NPEI_DEFS_H__
#define __CVMX_NPEI_DEFS_H__

#define CVMX_NPEI_BAR1_INDEXX(offset) (0x0000000000000000ull + ((offset) & 31) * 16)
#define CVMX_NPEI_BIST_STATUS (0x0000000000000580ull)
#define CVMX_NPEI_BIST_STATUS2 (0x0000000000000680ull)
#define CVMX_NPEI_CTL_PORT0 (0x0000000000000250ull)
#define CVMX_NPEI_CTL_PORT1 (0x0000000000000260ull)
#define CVMX_NPEI_CTL_STATUS (0x0000000000000570ull)
#define CVMX_NPEI_CTL_STATUS2 (0x0000000000003C00ull)
#define CVMX_NPEI_DATA_OUT_CNT (0x00000000000005F0ull)
#define CVMX_NPEI_DBG_DATA (0x0000000000000510ull)
#define CVMX_NPEI_DBG_SELECT (0x0000000000000500ull)
#define CVMX_NPEI_DMA0_INT_LEVEL (0x00000000000005C0ull)
#define CVMX_NPEI_DMA1_INT_LEVEL (0x00000000000005D0ull)
#define CVMX_NPEI_DMAX_COUNTS(offset) (0x0000000000000450ull + ((offset) & 7) * 16)
#define CVMX_NPEI_DMAX_DBELL(offset) (0x00000000000003B0ull + ((offset) & 7) * 16)
#define CVMX_NPEI_DMAX_IBUFF_SADDR(offset) (0x0000000000000400ull + ((offset) & 7) * 16)
#define CVMX_NPEI_DMAX_NADDR(offset) (0x00000000000004A0ull + ((offset) & 7) * 16)
#define CVMX_NPEI_DMA_CNTS (0x00000000000005E0ull)
#define CVMX_NPEI_DMA_CONTROL (0x00000000000003A0ull)
#define CVMX_NPEI_DMA_PCIE_REQ_NUM (0x00000000000005B0ull)
#define CVMX_NPEI_DMA_STATE1 (0x00000000000006C0ull)
#define CVMX_NPEI_DMA_STATE1_P1 (0x0000000000000680ull)
#define CVMX_NPEI_DMA_STATE2 (0x00000000000006D0ull)
#define CVMX_NPEI_DMA_STATE2_P1 (0x0000000000000690ull)
#define CVMX_NPEI_DMA_STATE3_P1 (0x00000000000006A0ull)
#define CVMX_NPEI_DMA_STATE4_P1 (0x00000000000006B0ull)
#define CVMX_NPEI_DMA_STATE5_P1 (0x00000000000006C0ull)
#define CVMX_NPEI_INT_A_ENB (0x0000000000000560ull)
#define CVMX_NPEI_INT_A_ENB2 (0x0000000000003CE0ull)
#define CVMX_NPEI_INT_A_SUM (0x0000000000000550ull)
#define CVMX_NPEI_INT_ENB (0x0000000000000540ull)
#define CVMX_NPEI_INT_ENB2 (0x0000000000003CD0ull)
#define CVMX_NPEI_INT_INFO (0x0000000000000590ull)
#define CVMX_NPEI_INT_SUM (0x0000000000000530ull)
#define CVMX_NPEI_INT_SUM2 (0x0000000000003CC0ull)
#define CVMX_NPEI_LAST_WIN_RDATA0 (0x0000000000000600ull)
#define CVMX_NPEI_LAST_WIN_RDATA1 (0x0000000000000610ull)
#define CVMX_NPEI_MEM_ACCESS_CTL (0x00000000000004F0ull)
#define CVMX_NPEI_MEM_ACCESS_SUBIDX(offset) (0x0000000000000280ull + ((offset) & 31) * 16 - 16*12)
#define CVMX_NPEI_MSI_ENB0 (0x0000000000003C50ull)
#define CVMX_NPEI_MSI_ENB1 (0x0000000000003C60ull)
#define CVMX_NPEI_MSI_ENB2 (0x0000000000003C70ull)
#define CVMX_NPEI_MSI_ENB3 (0x0000000000003C80ull)
#define CVMX_NPEI_MSI_RCV0 (0x0000000000003C10ull)
#define CVMX_NPEI_MSI_RCV1 (0x0000000000003C20ull)
#define CVMX_NPEI_MSI_RCV2 (0x0000000000003C30ull)
#define CVMX_NPEI_MSI_RCV3 (0x0000000000003C40ull)
#define CVMX_NPEI_MSI_RD_MAP (0x0000000000003CA0ull)
#define CVMX_NPEI_MSI_W1C_ENB0 (0x0000000000003CF0ull)
#define CVMX_NPEI_MSI_W1C_ENB1 (0x0000000000003D00ull)
#define CVMX_NPEI_MSI_W1C_ENB2 (0x0000000000003D10ull)
#define CVMX_NPEI_MSI_W1C_ENB3 (0x0000000000003D20ull)
#define CVMX_NPEI_MSI_W1S_ENB0 (0x0000000000003D30ull)
#define CVMX_NPEI_MSI_W1S_ENB1 (0x0000000000003D40ull)
#define CVMX_NPEI_MSI_W1S_ENB2 (0x0000000000003D50ull)
#define CVMX_NPEI_MSI_W1S_ENB3 (0x0000000000003D60ull)
#define CVMX_NPEI_MSI_WR_MAP (0x0000000000003C90ull)
#define CVMX_NPEI_PCIE_CREDIT_CNT (0x0000000000003D70ull)
#define CVMX_NPEI_PCIE_MSI_RCV (0x0000000000003CB0ull)
#define CVMX_NPEI_PCIE_MSI_RCV_B1 (0x0000000000000650ull)
#define CVMX_NPEI_PCIE_MSI_RCV_B2 (0x0000000000000660ull)
#define CVMX_NPEI_PCIE_MSI_RCV_B3 (0x0000000000000670ull)
#define CVMX_NPEI_PKTX_CNTS(offset) (0x0000000000002400ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_INSTR_BADDR(offset) (0x0000000000002800ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_INSTR_BAOFF_DBELL(offset) (0x0000000000002C00ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_INSTR_FIFO_RSIZE(offset) (0x0000000000003000ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_INSTR_HEADER(offset) (0x0000000000003400ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_IN_BP(offset) (0x0000000000003800ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_SLIST_BADDR(offset) (0x0000000000001400ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_SLIST_BAOFF_DBELL(offset) (0x0000000000001800ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKTX_SLIST_FIFO_RSIZE(offset) (0x0000000000001C00ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKT_CNT_INT (0x0000000000001110ull)
#define CVMX_NPEI_PKT_CNT_INT_ENB (0x0000000000001130ull)
#define CVMX_NPEI_PKT_DATA_OUT_ES (0x00000000000010B0ull)
#define CVMX_NPEI_PKT_DATA_OUT_NS (0x00000000000010A0ull)
#define CVMX_NPEI_PKT_DATA_OUT_ROR (0x0000000000001090ull)
#define CVMX_NPEI_PKT_DPADDR (0x0000000000001080ull)
#define CVMX_NPEI_PKT_INPUT_CONTROL (0x0000000000001150ull)
#define CVMX_NPEI_PKT_INSTR_ENB (0x0000000000001000ull)
#define CVMX_NPEI_PKT_INSTR_RD_SIZE (0x0000000000001190ull)
#define CVMX_NPEI_PKT_INSTR_SIZE (0x0000000000001020ull)
#define CVMX_NPEI_PKT_INT_LEVELS (0x0000000000001100ull)
#define CVMX_NPEI_PKT_IN_BP (0x00000000000006B0ull)
#define CVMX_NPEI_PKT_IN_DONEX_CNTS(offset) (0x0000000000002000ull + ((offset) & 31) * 16)
#define CVMX_NPEI_PKT_IN_INSTR_COUNTS (0x00000000000006A0ull)
#define CVMX_NPEI_PKT_IN_PCIE_PORT (0x00000000000011A0ull)
#define CVMX_NPEI_PKT_IPTR (0x0000000000001070ull)
#define CVMX_NPEI_PKT_OUTPUT_WMARK (0x0000000000001160ull)
#define CVMX_NPEI_PKT_OUT_BMODE (0x00000000000010D0ull)
#define CVMX_NPEI_PKT_OUT_ENB (0x0000000000001010ull)
#define CVMX_NPEI_PKT_PCIE_PORT (0x00000000000010E0ull)
#define CVMX_NPEI_PKT_PORT_IN_RST (0x0000000000000690ull)
#define CVMX_NPEI_PKT_SLIST_ES (0x0000000000001050ull)
#define CVMX_NPEI_PKT_SLIST_ID_SIZE (0x0000000000001180ull)
#define CVMX_NPEI_PKT_SLIST_NS (0x0000000000001040ull)
#define CVMX_NPEI_PKT_SLIST_ROR (0x0000000000001030ull)
#define CVMX_NPEI_PKT_TIME_INT (0x0000000000001120ull)
#define CVMX_NPEI_PKT_TIME_INT_ENB (0x0000000000001140ull)
#define CVMX_NPEI_RSL_INT_BLOCKS (0x0000000000000520ull)
#define CVMX_NPEI_SCRATCH_1 (0x0000000000000270ull)
#define CVMX_NPEI_STATE1 (0x0000000000000620ull)
#define CVMX_NPEI_STATE2 (0x0000000000000630ull)
#define CVMX_NPEI_STATE3 (0x0000000000000640ull)
#define CVMX_NPEI_WINDOW_CTL (0x0000000000000380ull)
#define CVMX_NPEI_WIN_RD_ADDR (0x0000000000000210ull)
#define CVMX_NPEI_WIN_RD_DATA (0x0000000000000240ull)
#define CVMX_NPEI_WIN_WR_ADDR (0x0000000000000200ull)
#define CVMX_NPEI_WIN_WR_DATA (0x0000000000000220ull)
#define CVMX_NPEI_WIN_WR_MASK (0x0000000000000230ull)

union cvmx_npei_bar1_indexx {
	uint32_t u32;
	struct cvmx_npei_bar1_indexx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint32_t reserved_18_31:14;
		uint32_t addr_idx:14;
		uint32_t ca:1;
		uint32_t end_swp:2;
		uint32_t addr_v:1;
#else
		uint32_t addr_v:1;
		uint32_t end_swp:2;
		uint32_t ca:1;
		uint32_t addr_idx:14;
		uint32_t reserved_18_31:14;
#endif
	} s;
	struct cvmx_npei_bar1_indexx_s cn52xx;
	struct cvmx_npei_bar1_indexx_s cn52xxp1;
	struct cvmx_npei_bar1_indexx_s cn56xx;
	struct cvmx_npei_bar1_indexx_s cn56xxp1;
};

union cvmx_npei_bist_status {
	uint64_t u64;
	struct cvmx_npei_bist_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t pkt_rdf:1;
		uint64_t reserved_60_62:3;
		uint64_t pcr_gim:1;
		uint64_t pkt_pif:1;
		uint64_t pcsr_int:1;
		uint64_t pcsr_im:1;
		uint64_t pcsr_cnt:1;
		uint64_t pcsr_id:1;
		uint64_t pcsr_sl:1;
		uint64_t reserved_50_52:3;
		uint64_t pkt_ind:1;
		uint64_t pkt_slm:1;
		uint64_t reserved_36_47:12;
		uint64_t d0_pst:1;
		uint64_t d1_pst:1;
		uint64_t d2_pst:1;
		uint64_t d3_pst:1;
		uint64_t reserved_31_31:1;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p1_o:1;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t p2n1_po:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_co:1;
		uint64_t p2n0_po:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t csm0:1;
		uint64_t csm1:1;
		uint64_t dif0:1;
		uint64_t dif1:1;
		uint64_t dif2:1;
		uint64_t dif3:1;
		uint64_t reserved_2_2:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t reserved_2_2:1;
		uint64_t dif3:1;
		uint64_t dif2:1;
		uint64_t dif1:1;
		uint64_t dif0:1;
		uint64_t csm1:1;
		uint64_t csm0:1;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_po:1;
		uint64_t p2n1_co:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_po:1;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t n2p1_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t reserved_31_31:1;
		uint64_t d3_pst:1;
		uint64_t d2_pst:1;
		uint64_t d1_pst:1;
		uint64_t d0_pst:1;
		uint64_t reserved_36_47:12;
		uint64_t pkt_slm:1;
		uint64_t pkt_ind:1;
		uint64_t reserved_50_52:3;
		uint64_t pcsr_sl:1;
		uint64_t pcsr_id:1;
		uint64_t pcsr_cnt:1;
		uint64_t pcsr_im:1;
		uint64_t pcsr_int:1;
		uint64_t pkt_pif:1;
		uint64_t pcr_gim:1;
		uint64_t reserved_60_62:3;
		uint64_t pkt_rdf:1;
#endif
	} s;
	struct cvmx_npei_bist_status_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t pkt_rdf:1;
		uint64_t reserved_60_62:3;
		uint64_t pcr_gim:1;
		uint64_t pkt_pif:1;
		uint64_t pcsr_int:1;
		uint64_t pcsr_im:1;
		uint64_t pcsr_cnt:1;
		uint64_t pcsr_id:1;
		uint64_t pcsr_sl:1;
		uint64_t pkt_imem:1;
		uint64_t pkt_pfm:1;
		uint64_t pkt_pof:1;
		uint64_t reserved_48_49:2;
		uint64_t pkt_pop0:1;
		uint64_t pkt_pop1:1;
		uint64_t d0_mem:1;
		uint64_t d1_mem:1;
		uint64_t d2_mem:1;
		uint64_t d3_mem:1;
		uint64_t d4_mem:1;
		uint64_t ds_mem:1;
		uint64_t reserved_36_39:4;
		uint64_t d0_pst:1;
		uint64_t d1_pst:1;
		uint64_t d2_pst:1;
		uint64_t d3_pst:1;
		uint64_t d4_pst:1;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p1_o:1;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t p2n1_po:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_co:1;
		uint64_t p2n0_po:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t csm0:1;
		uint64_t csm1:1;
		uint64_t dif0:1;
		uint64_t dif1:1;
		uint64_t dif2:1;
		uint64_t dif3:1;
		uint64_t dif4:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t dif4:1;
		uint64_t dif3:1;
		uint64_t dif2:1;
		uint64_t dif1:1;
		uint64_t dif0:1;
		uint64_t csm1:1;
		uint64_t csm0:1;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_po:1;
		uint64_t p2n1_co:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_po:1;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t n2p1_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t d4_pst:1;
		uint64_t d3_pst:1;
		uint64_t d2_pst:1;
		uint64_t d1_pst:1;
		uint64_t d0_pst:1;
		uint64_t reserved_36_39:4;
		uint64_t ds_mem:1;
		uint64_t d4_mem:1;
		uint64_t d3_mem:1;
		uint64_t d2_mem:1;
		uint64_t d1_mem:1;
		uint64_t d0_mem:1;
		uint64_t pkt_pop1:1;
		uint64_t pkt_pop0:1;
		uint64_t reserved_48_49:2;
		uint64_t pkt_pof:1;
		uint64_t pkt_pfm:1;
		uint64_t pkt_imem:1;
		uint64_t pcsr_sl:1;
		uint64_t pcsr_id:1;
		uint64_t pcsr_cnt:1;
		uint64_t pcsr_im:1;
		uint64_t pcsr_int:1;
		uint64_t pkt_pif:1;
		uint64_t pcr_gim:1;
		uint64_t reserved_60_62:3;
		uint64_t pkt_rdf:1;
#endif
	} cn52xx;
	struct cvmx_npei_bist_status_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_46_63:18;
		uint64_t d0_mem0:1;
		uint64_t d1_mem1:1;
		uint64_t d2_mem2:1;
		uint64_t d3_mem3:1;
		uint64_t dr0_mem:1;
		uint64_t d0_mem:1;
		uint64_t d1_mem:1;
		uint64_t d2_mem:1;
		uint64_t d3_mem:1;
		uint64_t dr1_mem:1;
		uint64_t d0_pst:1;
		uint64_t d1_pst:1;
		uint64_t d2_pst:1;
		uint64_t d3_pst:1;
		uint64_t dr2_mem:1;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p1_o:1;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t p2n1_po:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_co:1;
		uint64_t p2n0_po:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t csm0:1;
		uint64_t csm1:1;
		uint64_t dif0:1;
		uint64_t dif1:1;
		uint64_t dif2:1;
		uint64_t dif3:1;
		uint64_t dr3_mem:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t dr3_mem:1;
		uint64_t dif3:1;
		uint64_t dif2:1;
		uint64_t dif1:1;
		uint64_t dif0:1;
		uint64_t csm1:1;
		uint64_t csm0:1;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_po:1;
		uint64_t p2n1_co:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_po:1;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t n2p1_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t dr2_mem:1;
		uint64_t d3_pst:1;
		uint64_t d2_pst:1;
		uint64_t d1_pst:1;
		uint64_t d0_pst:1;
		uint64_t dr1_mem:1;
		uint64_t d3_mem:1;
		uint64_t d2_mem:1;
		uint64_t d1_mem:1;
		uint64_t d0_mem:1;
		uint64_t dr0_mem:1;
		uint64_t d3_mem3:1;
		uint64_t d2_mem2:1;
		uint64_t d1_mem1:1;
		uint64_t d0_mem0:1;
		uint64_t reserved_46_63:18;
#endif
	} cn52xxp1;
	struct cvmx_npei_bist_status_cn52xx cn56xx;
	struct cvmx_npei_bist_status_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_58_63:6;
		uint64_t pcsr_int:1;
		uint64_t pcsr_im:1;
		uint64_t pcsr_cnt:1;
		uint64_t pcsr_id:1;
		uint64_t pcsr_sl:1;
		uint64_t pkt_pout:1;
		uint64_t pkt_imem:1;
		uint64_t pkt_cntm:1;
		uint64_t pkt_ind:1;
		uint64_t pkt_slm:1;
		uint64_t pkt_odf:1;
		uint64_t pkt_oif:1;
		uint64_t pkt_out:1;
		uint64_t pkt_i0:1;
		uint64_t pkt_i1:1;
		uint64_t pkt_s0:1;
		uint64_t pkt_s1:1;
		uint64_t d0_mem:1;
		uint64_t d1_mem:1;
		uint64_t d2_mem:1;
		uint64_t d3_mem:1;
		uint64_t d4_mem:1;
		uint64_t d0_pst:1;
		uint64_t d1_pst:1;
		uint64_t d2_pst:1;
		uint64_t d3_pst:1;
		uint64_t d4_pst:1;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p1_o:1;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t p2n1_po:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_co:1;
		uint64_t p2n0_po:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t csm0:1;
		uint64_t csm1:1;
		uint64_t dif0:1;
		uint64_t dif1:1;
		uint64_t dif2:1;
		uint64_t dif3:1;
		uint64_t dif4:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t dif4:1;
		uint64_t dif3:1;
		uint64_t dif2:1;
		uint64_t dif1:1;
		uint64_t dif0:1;
		uint64_t csm1:1;
		uint64_t csm0:1;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_co:1;
		uint64_t p2n0_no:1;
		uint64_t p2n0_po:1;
		uint64_t p2n1_co:1;
		uint64_t p2n1_no:1;
		uint64_t p2n1_po:1;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t n2p1_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t d4_pst:1;
		uint64_t d3_pst:1;
		uint64_t d2_pst:1;
		uint64_t d1_pst:1;
		uint64_t d0_pst:1;
		uint64_t d4_mem:1;
		uint64_t d3_mem:1;
		uint64_t d2_mem:1;
		uint64_t d1_mem:1;
		uint64_t d0_mem:1;
		uint64_t pkt_s1:1;
		uint64_t pkt_s0:1;
		uint64_t pkt_i1:1;
		uint64_t pkt_i0:1;
		uint64_t pkt_out:1;
		uint64_t pkt_oif:1;
		uint64_t pkt_odf:1;
		uint64_t pkt_slm:1;
		uint64_t pkt_ind:1;
		uint64_t pkt_cntm:1;
		uint64_t pkt_imem:1;
		uint64_t pkt_pout:1;
		uint64_t pcsr_sl:1;
		uint64_t pcsr_id:1;
		uint64_t pcsr_cnt:1;
		uint64_t pcsr_im:1;
		uint64_t pcsr_int:1;
		uint64_t reserved_58_63:6;
#endif
	} cn56xxp1;
};

union cvmx_npei_bist_status2 {
	uint64_t u64;
	struct cvmx_npei_bist_status2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t prd_tag:1;
		uint64_t prd_st0:1;
		uint64_t prd_st1:1;
		uint64_t prd_err:1;
		uint64_t nrd_st:1;
		uint64_t nwe_st:1;
		uint64_t nwe_wr0:1;
		uint64_t nwe_wr1:1;
		uint64_t pkt_rd:1;
		uint64_t psc_p0:1;
		uint64_t psc_p1:1;
		uint64_t pkt_gd:1;
		uint64_t pkt_gl:1;
		uint64_t pkt_blk:1;
#else
		uint64_t pkt_blk:1;
		uint64_t pkt_gl:1;
		uint64_t pkt_gd:1;
		uint64_t psc_p1:1;
		uint64_t psc_p0:1;
		uint64_t pkt_rd:1;
		uint64_t nwe_wr1:1;
		uint64_t nwe_wr0:1;
		uint64_t nwe_st:1;
		uint64_t nrd_st:1;
		uint64_t prd_err:1;
		uint64_t prd_st1:1;
		uint64_t prd_st0:1;
		uint64_t prd_tag:1;
		uint64_t reserved_14_63:50;
#endif
	} s;
	struct cvmx_npei_bist_status2_s cn52xx;
	struct cvmx_npei_bist_status2_s cn56xx;
};

union cvmx_npei_ctl_port0 {
	uint64_t u64;
	struct cvmx_npei_ctl_port0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_21_63:43;
		uint64_t waitl_com:1;
		uint64_t intd:1;
		uint64_t intc:1;
		uint64_t intb:1;
		uint64_t inta:1;
		uint64_t intd_map:2;
		uint64_t intc_map:2;
		uint64_t intb_map:2;
		uint64_t inta_map:2;
		uint64_t ctlp_ro:1;
		uint64_t reserved_6_6:1;
		uint64_t ptlp_ro:1;
		uint64_t bar2_enb:1;
		uint64_t bar2_esx:2;
		uint64_t bar2_cax:1;
		uint64_t wait_com:1;
#else
		uint64_t wait_com:1;
		uint64_t bar2_cax:1;
		uint64_t bar2_esx:2;
		uint64_t bar2_enb:1;
		uint64_t ptlp_ro:1;
		uint64_t reserved_6_6:1;
		uint64_t ctlp_ro:1;
		uint64_t inta_map:2;
		uint64_t intb_map:2;
		uint64_t intc_map:2;
		uint64_t intd_map:2;
		uint64_t inta:1;
		uint64_t intb:1;
		uint64_t intc:1;
		uint64_t intd:1;
		uint64_t waitl_com:1;
		uint64_t reserved_21_63:43;
#endif
	} s;
	struct cvmx_npei_ctl_port0_s cn52xx;
	struct cvmx_npei_ctl_port0_s cn52xxp1;
	struct cvmx_npei_ctl_port0_s cn56xx;
	struct cvmx_npei_ctl_port0_s cn56xxp1;
};

union cvmx_npei_ctl_port1 {
	uint64_t u64;
	struct cvmx_npei_ctl_port1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_21_63:43;
		uint64_t waitl_com:1;
		uint64_t intd:1;
		uint64_t intc:1;
		uint64_t intb:1;
		uint64_t inta:1;
		uint64_t intd_map:2;
		uint64_t intc_map:2;
		uint64_t intb_map:2;
		uint64_t inta_map:2;
		uint64_t ctlp_ro:1;
		uint64_t reserved_6_6:1;
		uint64_t ptlp_ro:1;
		uint64_t bar2_enb:1;
		uint64_t bar2_esx:2;
		uint64_t bar2_cax:1;
		uint64_t wait_com:1;
#else
		uint64_t wait_com:1;
		uint64_t bar2_cax:1;
		uint64_t bar2_esx:2;
		uint64_t bar2_enb:1;
		uint64_t ptlp_ro:1;
		uint64_t reserved_6_6:1;
		uint64_t ctlp_ro:1;
		uint64_t inta_map:2;
		uint64_t intb_map:2;
		uint64_t intc_map:2;
		uint64_t intd_map:2;
		uint64_t inta:1;
		uint64_t intb:1;
		uint64_t intc:1;
		uint64_t intd:1;
		uint64_t waitl_com:1;
		uint64_t reserved_21_63:43;
#endif
	} s;
	struct cvmx_npei_ctl_port1_s cn52xx;
	struct cvmx_npei_ctl_port1_s cn52xxp1;
	struct cvmx_npei_ctl_port1_s cn56xx;
	struct cvmx_npei_ctl_port1_s cn56xxp1;
};

union cvmx_npei_ctl_status {
	uint64_t u64;
	struct cvmx_npei_ctl_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t p1_ntags:6;
		uint64_t p0_ntags:6;
		uint64_t cfg_rtry:16;
		uint64_t ring_en:1;
		uint64_t lnk_rst:1;
		uint64_t arb:1;
		uint64_t pkt_bp:4;
		uint64_t host_mode:1;
		uint64_t chip_rev:8;
#else
		uint64_t chip_rev:8;
		uint64_t host_mode:1;
		uint64_t pkt_bp:4;
		uint64_t arb:1;
		uint64_t lnk_rst:1;
		uint64_t ring_en:1;
		uint64_t cfg_rtry:16;
		uint64_t p0_ntags:6;
		uint64_t p1_ntags:6;
		uint64_t reserved_44_63:20;
#endif
	} s;
	struct cvmx_npei_ctl_status_s cn52xx;
	struct cvmx_npei_ctl_status_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t p1_ntags:6;
		uint64_t p0_ntags:6;
		uint64_t cfg_rtry:16;
		uint64_t reserved_15_15:1;
		uint64_t lnk_rst:1;
		uint64_t arb:1;
		uint64_t reserved_9_12:4;
		uint64_t host_mode:1;
		uint64_t chip_rev:8;
#else
		uint64_t chip_rev:8;
		uint64_t host_mode:1;
		uint64_t reserved_9_12:4;
		uint64_t arb:1;
		uint64_t lnk_rst:1;
		uint64_t reserved_15_15:1;
		uint64_t cfg_rtry:16;
		uint64_t p0_ntags:6;
		uint64_t p1_ntags:6;
		uint64_t reserved_44_63:20;
#endif
	} cn52xxp1;
	struct cvmx_npei_ctl_status_s cn56xx;
	struct cvmx_npei_ctl_status_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_15_63:49;
		uint64_t lnk_rst:1;
		uint64_t arb:1;
		uint64_t pkt_bp:4;
		uint64_t host_mode:1;
		uint64_t chip_rev:8;
#else
		uint64_t chip_rev:8;
		uint64_t host_mode:1;
		uint64_t pkt_bp:4;
		uint64_t arb:1;
		uint64_t lnk_rst:1;
		uint64_t reserved_15_63:49;
#endif
	} cn56xxp1;
};

union cvmx_npei_ctl_status2 {
	uint64_t u64;
	struct cvmx_npei_ctl_status2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mps:1;
		uint64_t mrrs:3;
		uint64_t c1_w_flt:1;
		uint64_t c0_w_flt:1;
		uint64_t c1_b1_s:3;
		uint64_t c0_b1_s:3;
		uint64_t c1_wi_d:1;
		uint64_t c1_b0_d:1;
		uint64_t c0_wi_d:1;
		uint64_t c0_b0_d:1;
#else
		uint64_t c0_b0_d:1;
		uint64_t c0_wi_d:1;
		uint64_t c1_b0_d:1;
		uint64_t c1_wi_d:1;
		uint64_t c0_b1_s:3;
		uint64_t c1_b1_s:3;
		uint64_t c0_w_flt:1;
		uint64_t c1_w_flt:1;
		uint64_t mrrs:3;
		uint64_t mps:1;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_npei_ctl_status2_s cn52xx;
	struct cvmx_npei_ctl_status2_s cn52xxp1;
	struct cvmx_npei_ctl_status2_s cn56xx;
	struct cvmx_npei_ctl_status2_s cn56xxp1;
};

union cvmx_npei_data_out_cnt {
	uint64_t u64;
	struct cvmx_npei_data_out_cnt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t p1_ucnt:16;
		uint64_t p1_fcnt:6;
		uint64_t p0_ucnt:16;
		uint64_t p0_fcnt:6;
#else
		uint64_t p0_fcnt:6;
		uint64_t p0_ucnt:16;
		uint64_t p1_fcnt:6;
		uint64_t p1_ucnt:16;
		uint64_t reserved_44_63:20;
#endif
	} s;
	struct cvmx_npei_data_out_cnt_s cn52xx;
	struct cvmx_npei_data_out_cnt_s cn52xxp1;
	struct cvmx_npei_data_out_cnt_s cn56xx;
	struct cvmx_npei_data_out_cnt_s cn56xxp1;
};

union cvmx_npei_dbg_data {
	uint64_t u64;
	struct cvmx_npei_dbg_data_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_28_63:36;
		uint64_t qlm0_rev_lanes:1;
		uint64_t reserved_25_26:2;
		uint64_t qlm1_spd:2;
		uint64_t c_mul:5;
		uint64_t dsel_ext:1;
		uint64_t data:17;
#else
		uint64_t data:17;
		uint64_t dsel_ext:1;
		uint64_t c_mul:5;
		uint64_t qlm1_spd:2;
		uint64_t reserved_25_26:2;
		uint64_t qlm0_rev_lanes:1;
		uint64_t reserved_28_63:36;
#endif
	} s;
	struct cvmx_npei_dbg_data_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t qlm0_link_width:1;
		uint64_t qlm0_rev_lanes:1;
		uint64_t qlm1_mode:2;
		uint64_t qlm1_spd:2;
		uint64_t c_mul:5;
		uint64_t dsel_ext:1;
		uint64_t data:17;
#else
		uint64_t data:17;
		uint64_t dsel_ext:1;
		uint64_t c_mul:5;
		uint64_t qlm1_spd:2;
		uint64_t qlm1_mode:2;
		uint64_t qlm0_rev_lanes:1;
		uint64_t qlm0_link_width:1;
		uint64_t reserved_29_63:35;
#endif
	} cn52xx;
	struct cvmx_npei_dbg_data_cn52xx cn52xxp1;
	struct cvmx_npei_dbg_data_cn56xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t qlm2_rev_lanes:1;
		uint64_t qlm0_rev_lanes:1;
		uint64_t qlm3_spd:2;
		uint64_t qlm1_spd:2;
		uint64_t c_mul:5;
		uint64_t dsel_ext:1;
		uint64_t data:17;
#else
		uint64_t data:17;
		uint64_t dsel_ext:1;
		uint64_t c_mul:5;
		uint64_t qlm1_spd:2;
		uint64_t qlm3_spd:2;
		uint64_t qlm0_rev_lanes:1;
		uint64_t qlm2_rev_lanes:1;
		uint64_t reserved_29_63:35;
#endif
	} cn56xx;
	struct cvmx_npei_dbg_data_cn56xx cn56xxp1;
};

union cvmx_npei_dbg_select {
	uint64_t u64;
	struct cvmx_npei_dbg_select_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t dbg_sel:16;
#else
		uint64_t dbg_sel:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_npei_dbg_select_s cn52xx;
	struct cvmx_npei_dbg_select_s cn52xxp1;
	struct cvmx_npei_dbg_select_s cn56xx;
	struct cvmx_npei_dbg_select_s cn56xxp1;
};

union cvmx_npei_dmax_counts {
	uint64_t u64;
	struct cvmx_npei_dmax_counts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_39_63:25;
		uint64_t fcnt:7;
		uint64_t dbell:32;
#else
		uint64_t dbell:32;
		uint64_t fcnt:7;
		uint64_t reserved_39_63:25;
#endif
	} s;
	struct cvmx_npei_dmax_counts_s cn52xx;
	struct cvmx_npei_dmax_counts_s cn52xxp1;
	struct cvmx_npei_dmax_counts_s cn56xx;
	struct cvmx_npei_dmax_counts_s cn56xxp1;
};

union cvmx_npei_dmax_dbell {
	uint32_t u32;
	struct cvmx_npei_dmax_dbell_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint32_t reserved_16_31:16;
		uint32_t dbell:16;
#else
		uint32_t dbell:16;
		uint32_t reserved_16_31:16;
#endif
	} s;
	struct cvmx_npei_dmax_dbell_s cn52xx;
	struct cvmx_npei_dmax_dbell_s cn52xxp1;
	struct cvmx_npei_dmax_dbell_s cn56xx;
	struct cvmx_npei_dmax_dbell_s cn56xxp1;
};

union cvmx_npei_dmax_ibuff_saddr {
	uint64_t u64;
	struct cvmx_npei_dmax_ibuff_saddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_37_63:27;
		uint64_t idle:1;
		uint64_t saddr:29;
		uint64_t reserved_0_6:7;
#else
		uint64_t reserved_0_6:7;
		uint64_t saddr:29;
		uint64_t idle:1;
		uint64_t reserved_37_63:27;
#endif
	} s;
	struct cvmx_npei_dmax_ibuff_saddr_s cn52xx;
	struct cvmx_npei_dmax_ibuff_saddr_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_36_63:28;
		uint64_t saddr:29;
		uint64_t reserved_0_6:7;
#else
		uint64_t reserved_0_6:7;
		uint64_t saddr:29;
		uint64_t reserved_36_63:28;
#endif
	} cn52xxp1;
	struct cvmx_npei_dmax_ibuff_saddr_s cn56xx;
	struct cvmx_npei_dmax_ibuff_saddr_cn52xxp1 cn56xxp1;
};

union cvmx_npei_dmax_naddr {
	uint64_t u64;
	struct cvmx_npei_dmax_naddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_36_63:28;
		uint64_t addr:36;
#else
		uint64_t addr:36;
		uint64_t reserved_36_63:28;
#endif
	} s;
	struct cvmx_npei_dmax_naddr_s cn52xx;
	struct cvmx_npei_dmax_naddr_s cn52xxp1;
	struct cvmx_npei_dmax_naddr_s cn56xx;
	struct cvmx_npei_dmax_naddr_s cn56xxp1;
};

union cvmx_npei_dma0_int_level {
	uint64_t u64;
	struct cvmx_npei_dma0_int_level_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t time:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t time:32;
#endif
	} s;
	struct cvmx_npei_dma0_int_level_s cn52xx;
	struct cvmx_npei_dma0_int_level_s cn52xxp1;
	struct cvmx_npei_dma0_int_level_s cn56xx;
	struct cvmx_npei_dma0_int_level_s cn56xxp1;
};

union cvmx_npei_dma1_int_level {
	uint64_t u64;
	struct cvmx_npei_dma1_int_level_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t time:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t time:32;
#endif
	} s;
	struct cvmx_npei_dma1_int_level_s cn52xx;
	struct cvmx_npei_dma1_int_level_s cn52xxp1;
	struct cvmx_npei_dma1_int_level_s cn56xx;
	struct cvmx_npei_dma1_int_level_s cn56xxp1;
};

union cvmx_npei_dma_cnts {
	uint64_t u64;
	struct cvmx_npei_dma_cnts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dma1:32;
		uint64_t dma0:32;
#else
		uint64_t dma0:32;
		uint64_t dma1:32;
#endif
	} s;
	struct cvmx_npei_dma_cnts_s cn52xx;
	struct cvmx_npei_dma_cnts_s cn52xxp1;
	struct cvmx_npei_dma_cnts_s cn56xx;
	struct cvmx_npei_dma_cnts_s cn56xxp1;
};

union cvmx_npei_dma_control {
	uint64_t u64;
	struct cvmx_npei_dma_control_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_40_63:24;
		uint64_t p_32b_m:1;
		uint64_t dma4_enb:1;
		uint64_t dma3_enb:1;
		uint64_t dma2_enb:1;
		uint64_t dma1_enb:1;
		uint64_t dma0_enb:1;
		uint64_t b0_lend:1;
		uint64_t dwb_denb:1;
		uint64_t dwb_ichk:9;
		uint64_t fpa_que:3;
		uint64_t o_add1:1;
		uint64_t o_ro:1;
		uint64_t o_ns:1;
		uint64_t o_es:2;
		uint64_t o_mode:1;
		uint64_t csize:14;
#else
		uint64_t csize:14;
		uint64_t o_mode:1;
		uint64_t o_es:2;
		uint64_t o_ns:1;
		uint64_t o_ro:1;
		uint64_t o_add1:1;
		uint64_t fpa_que:3;
		uint64_t dwb_ichk:9;
		uint64_t dwb_denb:1;
		uint64_t b0_lend:1;
		uint64_t dma0_enb:1;
		uint64_t dma1_enb:1;
		uint64_t dma2_enb:1;
		uint64_t dma3_enb:1;
		uint64_t dma4_enb:1;
		uint64_t p_32b_m:1;
		uint64_t reserved_40_63:24;
#endif
	} s;
	struct cvmx_npei_dma_control_s cn52xx;
	struct cvmx_npei_dma_control_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_38_63:26;
		uint64_t dma3_enb:1;
		uint64_t dma2_enb:1;
		uint64_t dma1_enb:1;
		uint64_t dma0_enb:1;
		uint64_t b0_lend:1;
		uint64_t dwb_denb:1;
		uint64_t dwb_ichk:9;
		uint64_t fpa_que:3;
		uint64_t o_add1:1;
		uint64_t o_ro:1;
		uint64_t o_ns:1;
		uint64_t o_es:2;
		uint64_t o_mode:1;
		uint64_t csize:14;
#else
		uint64_t csize:14;
		uint64_t o_mode:1;
		uint64_t o_es:2;
		uint64_t o_ns:1;
		uint64_t o_ro:1;
		uint64_t o_add1:1;
		uint64_t fpa_que:3;
		uint64_t dwb_ichk:9;
		uint64_t dwb_denb:1;
		uint64_t b0_lend:1;
		uint64_t dma0_enb:1;
		uint64_t dma1_enb:1;
		uint64_t dma2_enb:1;
		uint64_t dma3_enb:1;
		uint64_t reserved_38_63:26;
#endif
	} cn52xxp1;
	struct cvmx_npei_dma_control_s cn56xx;
	struct cvmx_npei_dma_control_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_39_63:25;
		uint64_t dma4_enb:1;
		uint64_t dma3_enb:1;
		uint64_t dma2_enb:1;
		uint64_t dma1_enb:1;
		uint64_t dma0_enb:1;
		uint64_t b0_lend:1;
		uint64_t dwb_denb:1;
		uint64_t dwb_ichk:9;
		uint64_t fpa_que:3;
		uint64_t o_add1:1;
		uint64_t o_ro:1;
		uint64_t o_ns:1;
		uint64_t o_es:2;
		uint64_t o_mode:1;
		uint64_t csize:14;
#else
		uint64_t csize:14;
		uint64_t o_mode:1;
		uint64_t o_es:2;
		uint64_t o_ns:1;
		uint64_t o_ro:1;
		uint64_t o_add1:1;
		uint64_t fpa_que:3;
		uint64_t dwb_ichk:9;
		uint64_t dwb_denb:1;
		uint64_t b0_lend:1;
		uint64_t dma0_enb:1;
		uint64_t dma1_enb:1;
		uint64_t dma2_enb:1;
		uint64_t dma3_enb:1;
		uint64_t dma4_enb:1;
		uint64_t reserved_39_63:25;
#endif
	} cn56xxp1;
};

union cvmx_npei_dma_pcie_req_num {
	uint64_t u64;
	struct cvmx_npei_dma_pcie_req_num_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dma_arb:1;
		uint64_t reserved_53_62:10;
		uint64_t pkt_cnt:5;
		uint64_t reserved_45_47:3;
		uint64_t dma4_cnt:5;
		uint64_t reserved_37_39:3;
		uint64_t dma3_cnt:5;
		uint64_t reserved_29_31:3;
		uint64_t dma2_cnt:5;
		uint64_t reserved_21_23:3;
		uint64_t dma1_cnt:5;
		uint64_t reserved_13_15:3;
		uint64_t dma0_cnt:5;
		uint64_t reserved_5_7:3;
		uint64_t dma_cnt:5;
#else
		uint64_t dma_cnt:5;
		uint64_t reserved_5_7:3;
		uint64_t dma0_cnt:5;
		uint64_t reserved_13_15:3;
		uint64_t dma1_cnt:5;
		uint64_t reserved_21_23:3;
		uint64_t dma2_cnt:5;
		uint64_t reserved_29_31:3;
		uint64_t dma3_cnt:5;
		uint64_t reserved_37_39:3;
		uint64_t dma4_cnt:5;
		uint64_t reserved_45_47:3;
		uint64_t pkt_cnt:5;
		uint64_t reserved_53_62:10;
		uint64_t dma_arb:1;
#endif
	} s;
	struct cvmx_npei_dma_pcie_req_num_s cn52xx;
	struct cvmx_npei_dma_pcie_req_num_s cn56xx;
};

union cvmx_npei_dma_state1 {
	uint64_t u64;
	struct cvmx_npei_dma_state1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_40_63:24;
		uint64_t d4_dwe:8;
		uint64_t d3_dwe:8;
		uint64_t d2_dwe:8;
		uint64_t d1_dwe:8;
		uint64_t d0_dwe:8;
#else
		uint64_t d0_dwe:8;
		uint64_t d1_dwe:8;
		uint64_t d2_dwe:8;
		uint64_t d3_dwe:8;
		uint64_t d4_dwe:8;
		uint64_t reserved_40_63:24;
#endif
	} s;
	struct cvmx_npei_dma_state1_s cn52xx;
};

union cvmx_npei_dma_state1_p1 {
	uint64_t u64;
	struct cvmx_npei_dma_state1_p1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_60_63:4;
		uint64_t d0_difst:7;
		uint64_t d1_difst:7;
		uint64_t d2_difst:7;
		uint64_t d3_difst:7;
		uint64_t d4_difst:7;
		uint64_t d0_reqst:5;
		uint64_t d1_reqst:5;
		uint64_t d2_reqst:5;
		uint64_t d3_reqst:5;
		uint64_t d4_reqst:5;
#else
		uint64_t d4_reqst:5;
		uint64_t d3_reqst:5;
		uint64_t d2_reqst:5;
		uint64_t d1_reqst:5;
		uint64_t d0_reqst:5;
		uint64_t d4_difst:7;
		uint64_t d3_difst:7;
		uint64_t d2_difst:7;
		uint64_t d1_difst:7;
		uint64_t d0_difst:7;
		uint64_t reserved_60_63:4;
#endif
	} s;
	struct cvmx_npei_dma_state1_p1_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_60_63:4;
		uint64_t d0_difst:7;
		uint64_t d1_difst:7;
		uint64_t d2_difst:7;
		uint64_t d3_difst:7;
		uint64_t reserved_25_31:7;
		uint64_t d0_reqst:5;
		uint64_t d1_reqst:5;
		uint64_t d2_reqst:5;
		uint64_t d3_reqst:5;
		uint64_t reserved_0_4:5;
#else
		uint64_t reserved_0_4:5;
		uint64_t d3_reqst:5;
		uint64_t d2_reqst:5;
		uint64_t d1_reqst:5;
		uint64_t d0_reqst:5;
		uint64_t reserved_25_31:7;
		uint64_t d3_difst:7;
		uint64_t d2_difst:7;
		uint64_t d1_difst:7;
		uint64_t d0_difst:7;
		uint64_t reserved_60_63:4;
#endif
	} cn52xxp1;
	struct cvmx_npei_dma_state1_p1_s cn56xxp1;
};

union cvmx_npei_dma_state2 {
	uint64_t u64;
	struct cvmx_npei_dma_state2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_28_63:36;
		uint64_t ndwe:4;
		uint64_t reserved_21_23:3;
		uint64_t ndre:5;
		uint64_t reserved_10_15:6;
		uint64_t prd:10;
#else
		uint64_t prd:10;
		uint64_t reserved_10_15:6;
		uint64_t ndre:5;
		uint64_t reserved_21_23:3;
		uint64_t ndwe:4;
		uint64_t reserved_28_63:36;
#endif
	} s;
	struct cvmx_npei_dma_state2_s cn52xx;
};

union cvmx_npei_dma_state2_p1 {
	uint64_t u64;
	struct cvmx_npei_dma_state2_p1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_45_63:19;
		uint64_t d0_dffst:9;
		uint64_t d1_dffst:9;
		uint64_t d2_dffst:9;
		uint64_t d3_dffst:9;
		uint64_t d4_dffst:9;
#else
		uint64_t d4_dffst:9;
		uint64_t d3_dffst:9;
		uint64_t d2_dffst:9;
		uint64_t d1_dffst:9;
		uint64_t d0_dffst:9;
		uint64_t reserved_45_63:19;
#endif
	} s;
	struct cvmx_npei_dma_state2_p1_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_45_63:19;
		uint64_t d0_dffst:9;
		uint64_t d1_dffst:9;
		uint64_t d2_dffst:9;
		uint64_t d3_dffst:9;
		uint64_t reserved_0_8:9;
#else
		uint64_t reserved_0_8:9;
		uint64_t d3_dffst:9;
		uint64_t d2_dffst:9;
		uint64_t d1_dffst:9;
		uint64_t d0_dffst:9;
		uint64_t reserved_45_63:19;
#endif
	} cn52xxp1;
	struct cvmx_npei_dma_state2_p1_s cn56xxp1;
};

union cvmx_npei_dma_state3_p1 {
	uint64_t u64;
	struct cvmx_npei_dma_state3_p1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_60_63:4;
		uint64_t d0_drest:15;
		uint64_t d1_drest:15;
		uint64_t d2_drest:15;
		uint64_t d3_drest:15;
#else
		uint64_t d3_drest:15;
		uint64_t d2_drest:15;
		uint64_t d1_drest:15;
		uint64_t d0_drest:15;
		uint64_t reserved_60_63:4;
#endif
	} s;
	struct cvmx_npei_dma_state3_p1_s cn52xxp1;
	struct cvmx_npei_dma_state3_p1_s cn56xxp1;
};

union cvmx_npei_dma_state4_p1 {
	uint64_t u64;
	struct cvmx_npei_dma_state4_p1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_52_63:12;
		uint64_t d0_dwest:13;
		uint64_t d1_dwest:13;
		uint64_t d2_dwest:13;
		uint64_t d3_dwest:13;
#else
		uint64_t d3_dwest:13;
		uint64_t d2_dwest:13;
		uint64_t d1_dwest:13;
		uint64_t d0_dwest:13;
		uint64_t reserved_52_63:12;
#endif
	} s;
	struct cvmx_npei_dma_state4_p1_s cn52xxp1;
	struct cvmx_npei_dma_state4_p1_s cn56xxp1;
};

union cvmx_npei_dma_state5_p1 {
	uint64_t u64;
	struct cvmx_npei_dma_state5_p1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_28_63:36;
		uint64_t d4_drest:15;
		uint64_t d4_dwest:13;
#else
		uint64_t d4_dwest:13;
		uint64_t d4_drest:15;
		uint64_t reserved_28_63:36;
#endif
	} s;
	struct cvmx_npei_dma_state5_p1_s cn56xxp1;
};

union cvmx_npei_int_a_enb {
	uint64_t u64;
	struct cvmx_npei_int_a_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t p1_rdlk:1;
		uint64_t p0_rdlk:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t dma1_cpl:1;
		uint64_t dma0_cpl:1;
#else
		uint64_t dma0_cpl:1;
		uint64_t dma1_cpl:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t p0_rdlk:1;
		uint64_t p1_rdlk:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_npei_int_a_enb_s cn52xx;
	struct cvmx_npei_int_a_enb_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t dma1_cpl:1;
		uint64_t dma0_cpl:1;
#else
		uint64_t dma0_cpl:1;
		uint64_t dma1_cpl:1;
		uint64_t reserved_2_63:62;
#endif
	} cn52xxp1;
	struct cvmx_npei_int_a_enb_s cn56xx;
};

union cvmx_npei_int_a_enb2 {
	uint64_t u64;
	struct cvmx_npei_int_a_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t p1_rdlk:1;
		uint64_t p0_rdlk:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t dma1_cpl:1;
		uint64_t dma0_cpl:1;
#else
		uint64_t dma0_cpl:1;
		uint64_t dma1_cpl:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t p0_rdlk:1;
		uint64_t p1_rdlk:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_npei_int_a_enb2_s cn52xx;
	struct cvmx_npei_int_a_enb2_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t dma1_cpl:1;
		uint64_t dma0_cpl:1;
#else
		uint64_t dma0_cpl:1;
		uint64_t dma1_cpl:1;
		uint64_t reserved_2_63:62;
#endif
	} cn52xxp1;
	struct cvmx_npei_int_a_enb2_s cn56xx;
};

union cvmx_npei_int_a_sum {
	uint64_t u64;
	struct cvmx_npei_int_a_sum_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t p1_rdlk:1;
		uint64_t p0_rdlk:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t dma1_cpl:1;
		uint64_t dma0_cpl:1;
#else
		uint64_t dma0_cpl:1;
		uint64_t dma1_cpl:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t p0_rdlk:1;
		uint64_t p1_rdlk:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_npei_int_a_sum_s cn52xx;
	struct cvmx_npei_int_a_sum_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t dma1_cpl:1;
		uint64_t dma0_cpl:1;
#else
		uint64_t dma0_cpl:1;
		uint64_t dma1_cpl:1;
		uint64_t reserved_2_63:62;
#endif
	} cn52xxp1;
	struct cvmx_npei_int_a_sum_s cn56xx;
};

union cvmx_npei_int_enb {
	uint64_t u64;
	struct cvmx_npei_int_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_62_62:1;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t dma4dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma4dbo:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_62:1;
		uint64_t mio_inta:1;
#endif
	} s;
	struct cvmx_npei_int_enb_s cn52xx;
	struct cvmx_npei_int_enb_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_62_62:1;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t reserved_8_8:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t reserved_8_8:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_62:1;
		uint64_t mio_inta:1;
#endif
	} cn52xxp1;
	struct cvmx_npei_int_enb_s cn56xx;
	struct cvmx_npei_int_enb_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_61_62:2;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t reserved_29_29:1;
		uint64_t c1_se:1;
		uint64_t reserved_27_27:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t reserved_22_22:1;
		uint64_t c0_se:1;
		uint64_t reserved_20_20:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t dma4dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma4dbo:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t reserved_20_20:1;
		uint64_t c0_se:1;
		uint64_t reserved_22_22:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t reserved_27_27:1;
		uint64_t c1_se:1;
		uint64_t reserved_29_29:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t reserved_61_62:2;
		uint64_t mio_inta:1;
#endif
	} cn56xxp1;
};

union cvmx_npei_int_enb2 {
	uint64_t u64;
	struct cvmx_npei_int_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t dma4dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma4dbo:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_63:2;
#endif
	} s;
	struct cvmx_npei_int_enb2_s cn52xx;
	struct cvmx_npei_int_enb2_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t reserved_8_8:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t reserved_8_8:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_63:2;
#endif
	} cn52xxp1;
	struct cvmx_npei_int_enb2_s cn56xx;
	struct cvmx_npei_int_enb2_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t reserved_29_29:1;
		uint64_t c1_se:1;
		uint64_t reserved_27_27:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t reserved_22_22:1;
		uint64_t c0_se:1;
		uint64_t reserved_20_20:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t dma4dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma4dbo:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t reserved_20_20:1;
		uint64_t c0_se:1;
		uint64_t reserved_22_22:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t reserved_27_27:1;
		uint64_t c1_se:1;
		uint64_t reserved_29_29:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t reserved_61_63:3;
#endif
	} cn56xxp1;
};

union cvmx_npei_int_info {
	uint64_t u64;
	struct cvmx_npei_int_info_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_12_63:52;
		uint64_t pidbof:6;
		uint64_t psldbof:6;
#else
		uint64_t psldbof:6;
		uint64_t pidbof:6;
		uint64_t reserved_12_63:52;
#endif
	} s;
	struct cvmx_npei_int_info_s cn52xx;
	struct cvmx_npei_int_info_s cn56xx;
	struct cvmx_npei_int_info_s cn56xxp1;
};

union cvmx_npei_int_sum {
	uint64_t u64;
	struct cvmx_npei_int_sum_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_62_62:1;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t dma4dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma4dbo:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_62:1;
		uint64_t mio_inta:1;
#endif
	} s;
	struct cvmx_npei_int_sum_s cn52xx;
	struct cvmx_npei_int_sum_cn52xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_62_62:1;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t reserved_15_18:4;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t reserved_8_8:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t reserved_8_8:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t reserved_15_18:4;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_62:1;
		uint64_t mio_inta:1;
#endif
	} cn52xxp1;
	struct cvmx_npei_int_sum_s cn56xx;
	struct cvmx_npei_int_sum_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_61_62:2;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t reserved_29_29:1;
		uint64_t c1_se:1;
		uint64_t reserved_27_27:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t reserved_22_22:1;
		uint64_t c0_se:1;
		uint64_t reserved_20_20:1;
		uint64_t c0_aeri:1;
		uint64_t reserved_15_18:4;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t dma4dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t dma4dbo:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t reserved_15_18:4;
		uint64_t c0_aeri:1;
		uint64_t reserved_20_20:1;
		uint64_t c0_se:1;
		uint64_t reserved_22_22:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t reserved_27_27:1;
		uint64_t c1_se:1;
		uint64_t reserved_29_29:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t reserved_61_62:2;
		uint64_t mio_inta:1;
#endif
	} cn56xxp1;
};

union cvmx_npei_int_sum2 {
	uint64_t u64;
	struct cvmx_npei_int_sum2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mio_inta:1;
		uint64_t reserved_62_62:1;
		uint64_t int_a:1;
		uint64_t c1_ldwn:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_exc:1;
		uint64_t c0_exc:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_bx:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b0:1;
		uint64_t c0_un_bx:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b0:1;
		uint64_t c1_hpint:1;
		uint64_t c1_pmei:1;
		uint64_t c1_wake:1;
		uint64_t crs1_dr:1;
		uint64_t c1_se:1;
		uint64_t crs1_er:1;
		uint64_t c1_aeri:1;
		uint64_t c0_hpint:1;
		uint64_t c0_pmei:1;
		uint64_t c0_wake:1;
		uint64_t crs0_dr:1;
		uint64_t c0_se:1;
		uint64_t crs0_er:1;
		uint64_t c0_aeri:1;
		uint64_t reserved_15_18:4;
		uint64_t dtime1:1;
		uint64_t dtime0:1;
		uint64_t dcnt1:1;
		uint64_t dcnt0:1;
		uint64_t dma1fi:1;
		uint64_t dma0fi:1;
		uint64_t reserved_8_8:1;
		uint64_t dma3dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma0dbo:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t rml_wto:1;
		uint64_t rml_rto:1;
#else
		uint64_t rml_rto:1;
		uint64_t rml_wto:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t dma0dbo:1;
		uint64_t dma1dbo:1;
		uint64_t dma2dbo:1;
		uint64_t dma3dbo:1;
		uint64_t reserved_8_8:1;
		uint64_t dma0fi:1;
		uint64_t dma1fi:1;
		uint64_t dcnt0:1;
		uint64_t dcnt1:1;
		uint64_t dtime0:1;
		uint64_t dtime1:1;
		uint64_t reserved_15_18:4;
		uint64_t c0_aeri:1;
		uint64_t crs0_er:1;
		uint64_t c0_se:1;
		uint64_t crs0_dr:1;
		uint64_t c0_wake:1;
		uint64_t c0_pmei:1;
		uint64_t c0_hpint:1;
		uint64_t c1_aeri:1;
		uint64_t crs1_er:1;
		uint64_t c1_se:1;
		uint64_t crs1_dr:1;
		uint64_t c1_wake:1;
		uint64_t c1_pmei:1;
		uint64_t c1_hpint:1;
		uint64_t c0_up_b0:1;
		uint64_t c0_up_b1:1;
		uint64_t c0_up_b2:1;
		uint64_t c0_up_wi:1;
		uint64_t c0_up_bx:1;
		uint64_t c0_un_b0:1;
		uint64_t c0_un_b1:1;
		uint64_t c0_un_b2:1;
		uint64_t c0_un_wi:1;
		uint64_t c0_un_bx:1;
		uint64_t c1_up_b0:1;
		uint64_t c1_up_b1:1;
		uint64_t c1_up_b2:1;
		uint64_t c1_up_wi:1;
		uint64_t c1_up_bx:1;
		uint64_t c1_un_b0:1;
		uint64_t c1_un_b1:1;
		uint64_t c1_un_b2:1;
		uint64_t c1_un_wi:1;
		uint64_t c1_un_bx:1;
		uint64_t c0_un_wf:1;
		uint64_t c1_un_wf:1;
		uint64_t c0_up_wf:1;
		uint64_t c1_up_wf:1;
		uint64_t c0_exc:1;
		uint64_t c1_exc:1;
		uint64_t c0_ldwn:1;
		uint64_t c1_ldwn:1;
		uint64_t int_a:1;
		uint64_t reserved_62_62:1;
		uint64_t mio_inta:1;
#endif
	} s;
	struct cvmx_npei_int_sum2_s cn52xx;
	struct cvmx_npei_int_sum2_s cn52xxp1;
	struct cvmx_npei_int_sum2_s cn56xx;
};

union cvmx_npei_last_win_rdata0 {
	uint64_t u64;
	struct cvmx_npei_last_win_rdata0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_npei_last_win_rdata0_s cn52xx;
	struct cvmx_npei_last_win_rdata0_s cn52xxp1;
	struct cvmx_npei_last_win_rdata0_s cn56xx;
	struct cvmx_npei_last_win_rdata0_s cn56xxp1;
};

union cvmx_npei_last_win_rdata1 {
	uint64_t u64;
	struct cvmx_npei_last_win_rdata1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_npei_last_win_rdata1_s cn52xx;
	struct cvmx_npei_last_win_rdata1_s cn52xxp1;
	struct cvmx_npei_last_win_rdata1_s cn56xx;
	struct cvmx_npei_last_win_rdata1_s cn56xxp1;
};

union cvmx_npei_mem_access_ctl {
	uint64_t u64;
	struct cvmx_npei_mem_access_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t max_word:4;
		uint64_t timer:10;
#else
		uint64_t timer:10;
		uint64_t max_word:4;
		uint64_t reserved_14_63:50;
#endif
	} s;
	struct cvmx_npei_mem_access_ctl_s cn52xx;
	struct cvmx_npei_mem_access_ctl_s cn52xxp1;
	struct cvmx_npei_mem_access_ctl_s cn56xx;
	struct cvmx_npei_mem_access_ctl_s cn56xxp1;
};

union cvmx_npei_mem_access_subidx {
	uint64_t u64;
	struct cvmx_npei_mem_access_subidx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_42_63:22;
		uint64_t zero:1;
		uint64_t port:2;
		uint64_t nmerge:1;
		uint64_t esr:2;
		uint64_t esw:2;
		uint64_t nsr:1;
		uint64_t nsw:1;
		uint64_t ror:1;
		uint64_t row:1;
		uint64_t ba:30;
#else
		uint64_t ba:30;
		uint64_t row:1;
		uint64_t ror:1;
		uint64_t nsw:1;
		uint64_t nsr:1;
		uint64_t esw:2;
		uint64_t esr:2;
		uint64_t nmerge:1;
		uint64_t port:2;
		uint64_t zero:1;
		uint64_t reserved_42_63:22;
#endif
	} s;
	struct cvmx_npei_mem_access_subidx_s cn52xx;
	struct cvmx_npei_mem_access_subidx_s cn52xxp1;
	struct cvmx_npei_mem_access_subidx_s cn56xx;
	struct cvmx_npei_mem_access_subidx_s cn56xxp1;
};

union cvmx_npei_msi_enb0 {
	uint64_t u64;
	struct cvmx_npei_msi_enb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_npei_msi_enb0_s cn52xx;
	struct cvmx_npei_msi_enb0_s cn52xxp1;
	struct cvmx_npei_msi_enb0_s cn56xx;
	struct cvmx_npei_msi_enb0_s cn56xxp1;
};

union cvmx_npei_msi_enb1 {
	uint64_t u64;
	struct cvmx_npei_msi_enb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_npei_msi_enb1_s cn52xx;
	struct cvmx_npei_msi_enb1_s cn52xxp1;
	struct cvmx_npei_msi_enb1_s cn56xx;
	struct cvmx_npei_msi_enb1_s cn56xxp1;
};

union cvmx_npei_msi_enb2 {
	uint64_t u64;
	struct cvmx_npei_msi_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_npei_msi_enb2_s cn52xx;
	struct cvmx_npei_msi_enb2_s cn52xxp1;
	struct cvmx_npei_msi_enb2_s cn56xx;
	struct cvmx_npei_msi_enb2_s cn56xxp1;
};

union cvmx_npei_msi_enb3 {
	uint64_t u64;
	struct cvmx_npei_msi_enb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_npei_msi_enb3_s cn52xx;
	struct cvmx_npei_msi_enb3_s cn52xxp1;
	struct cvmx_npei_msi_enb3_s cn56xx;
	struct cvmx_npei_msi_enb3_s cn56xxp1;
};

union cvmx_npei_msi_rcv0 {
	uint64_t u64;
	struct cvmx_npei_msi_rcv0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_npei_msi_rcv0_s cn52xx;
	struct cvmx_npei_msi_rcv0_s cn52xxp1;
	struct cvmx_npei_msi_rcv0_s cn56xx;
	struct cvmx_npei_msi_rcv0_s cn56xxp1;
};

union cvmx_npei_msi_rcv1 {
	uint64_t u64;
	struct cvmx_npei_msi_rcv1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_npei_msi_rcv1_s cn52xx;
	struct cvmx_npei_msi_rcv1_s cn52xxp1;
	struct cvmx_npei_msi_rcv1_s cn56xx;
	struct cvmx_npei_msi_rcv1_s cn56xxp1;
};

union cvmx_npei_msi_rcv2 {
	uint64_t u64;
	struct cvmx_npei_msi_rcv2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_npei_msi_rcv2_s cn52xx;
	struct cvmx_npei_msi_rcv2_s cn52xxp1;
	struct cvmx_npei_msi_rcv2_s cn56xx;
	struct cvmx_npei_msi_rcv2_s cn56xxp1;
};

union cvmx_npei_msi_rcv3 {
	uint64_t u64;
	struct cvmx_npei_msi_rcv3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_npei_msi_rcv3_s cn52xx;
	struct cvmx_npei_msi_rcv3_s cn52xxp1;
	struct cvmx_npei_msi_rcv3_s cn56xx;
	struct cvmx_npei_msi_rcv3_s cn56xxp1;
};

union cvmx_npei_msi_rd_map {
	uint64_t u64;
	struct cvmx_npei_msi_rd_map_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t rd_int:8;
		uint64_t msi_int:8;
#else
		uint64_t msi_int:8;
		uint64_t rd_int:8;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_npei_msi_rd_map_s cn52xx;
	struct cvmx_npei_msi_rd_map_s cn52xxp1;
	struct cvmx_npei_msi_rd_map_s cn56xx;
	struct cvmx_npei_msi_rd_map_s cn56xxp1;
};

union cvmx_npei_msi_w1c_enb0 {
	uint64_t u64;
	struct cvmx_npei_msi_w1c_enb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_npei_msi_w1c_enb0_s cn52xx;
	struct cvmx_npei_msi_w1c_enb0_s cn56xx;
};

union cvmx_npei_msi_w1c_enb1 {
	uint64_t u64;
	struct cvmx_npei_msi_w1c_enb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_npei_msi_w1c_enb1_s cn52xx;
	struct cvmx_npei_msi_w1c_enb1_s cn56xx;
};

union cvmx_npei_msi_w1c_enb2 {
	uint64_t u64;
	struct cvmx_npei_msi_w1c_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_npei_msi_w1c_enb2_s cn52xx;
	struct cvmx_npei_msi_w1c_enb2_s cn56xx;
};

union cvmx_npei_msi_w1c_enb3 {
	uint64_t u64;
	struct cvmx_npei_msi_w1c_enb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_npei_msi_w1c_enb3_s cn52xx;
	struct cvmx_npei_msi_w1c_enb3_s cn56xx;
};

union cvmx_npei_msi_w1s_enb0 {
	uint64_t u64;
	struct cvmx_npei_msi_w1s_enb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_npei_msi_w1s_enb0_s cn52xx;
	struct cvmx_npei_msi_w1s_enb0_s cn56xx;
};

union cvmx_npei_msi_w1s_enb1 {
	uint64_t u64;
	struct cvmx_npei_msi_w1s_enb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_npei_msi_w1s_enb1_s cn52xx;
	struct cvmx_npei_msi_w1s_enb1_s cn56xx;
};

union cvmx_npei_msi_w1s_enb2 {
	uint64_t u64;
	struct cvmx_npei_msi_w1s_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_npei_msi_w1s_enb2_s cn52xx;
	struct cvmx_npei_msi_w1s_enb2_s cn56xx;
};

union cvmx_npei_msi_w1s_enb3 {
	uint64_t u64;
	struct cvmx_npei_msi_w1s_enb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_npei_msi_w1s_enb3_s cn52xx;
	struct cvmx_npei_msi_w1s_enb3_s cn56xx;
};

union cvmx_npei_msi_wr_map {
	uint64_t u64;
	struct cvmx_npei_msi_wr_map_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t ciu_int:8;
		uint64_t msi_int:8;
#else
		uint64_t msi_int:8;
		uint64_t ciu_int:8;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_npei_msi_wr_map_s cn52xx;
	struct cvmx_npei_msi_wr_map_s cn52xxp1;
	struct cvmx_npei_msi_wr_map_s cn56xx;
	struct cvmx_npei_msi_wr_map_s cn56xxp1;
};

union cvmx_npei_pcie_credit_cnt {
	uint64_t u64;
	struct cvmx_npei_pcie_credit_cnt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t p1_ccnt:8;
		uint64_t p1_ncnt:8;
		uint64_t p1_pcnt:8;
		uint64_t p0_ccnt:8;
		uint64_t p0_ncnt:8;
		uint64_t p0_pcnt:8;
#else
		uint64_t p0_pcnt:8;
		uint64_t p0_ncnt:8;
		uint64_t p0_ccnt:8;
		uint64_t p1_pcnt:8;
		uint64_t p1_ncnt:8;
		uint64_t p1_ccnt:8;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_npei_pcie_credit_cnt_s cn52xx;
	struct cvmx_npei_pcie_credit_cnt_s cn56xx;
};

union cvmx_npei_pcie_msi_rcv {
	uint64_t u64;
	struct cvmx_npei_pcie_msi_rcv_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t intr:8;
#else
		uint64_t intr:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_npei_pcie_msi_rcv_s cn52xx;
	struct cvmx_npei_pcie_msi_rcv_s cn52xxp1;
	struct cvmx_npei_pcie_msi_rcv_s cn56xx;
	struct cvmx_npei_pcie_msi_rcv_s cn56xxp1;
};

union cvmx_npei_pcie_msi_rcv_b1 {
	uint64_t u64;
	struct cvmx_npei_pcie_msi_rcv_b1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t intr:8;
		uint64_t reserved_0_7:8;
#else
		uint64_t reserved_0_7:8;
		uint64_t intr:8;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_npei_pcie_msi_rcv_b1_s cn52xx;
	struct cvmx_npei_pcie_msi_rcv_b1_s cn52xxp1;
	struct cvmx_npei_pcie_msi_rcv_b1_s cn56xx;
	struct cvmx_npei_pcie_msi_rcv_b1_s cn56xxp1;
};

union cvmx_npei_pcie_msi_rcv_b2 {
	uint64_t u64;
	struct cvmx_npei_pcie_msi_rcv_b2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t intr:8;
		uint64_t reserved_0_15:16;
#else
		uint64_t reserved_0_15:16;
		uint64_t intr:8;
		uint64_t reserved_24_63:40;
#endif
	} s;
	struct cvmx_npei_pcie_msi_rcv_b2_s cn52xx;
	struct cvmx_npei_pcie_msi_rcv_b2_s cn52xxp1;
	struct cvmx_npei_pcie_msi_rcv_b2_s cn56xx;
	struct cvmx_npei_pcie_msi_rcv_b2_s cn56xxp1;
};

union cvmx_npei_pcie_msi_rcv_b3 {
	uint64_t u64;
	struct cvmx_npei_pcie_msi_rcv_b3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t intr:8;
		uint64_t reserved_0_23:24;
#else
		uint64_t reserved_0_23:24;
		uint64_t intr:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pcie_msi_rcv_b3_s cn52xx;
	struct cvmx_npei_pcie_msi_rcv_b3_s cn52xxp1;
	struct cvmx_npei_pcie_msi_rcv_b3_s cn56xx;
	struct cvmx_npei_pcie_msi_rcv_b3_s cn56xxp1;
};

union cvmx_npei_pktx_cnts {
	uint64_t u64;
	struct cvmx_npei_pktx_cnts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_54_63:10;
		uint64_t timer:22;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t timer:22;
		uint64_t reserved_54_63:10;
#endif
	} s;
	struct cvmx_npei_pktx_cnts_s cn52xx;
	struct cvmx_npei_pktx_cnts_s cn56xx;
};

union cvmx_npei_pktx_in_bp {
	uint64_t u64;
	struct cvmx_npei_pktx_in_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wmark:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t wmark:32;
#endif
	} s;
	struct cvmx_npei_pktx_in_bp_s cn52xx;
	struct cvmx_npei_pktx_in_bp_s cn56xx;
};

union cvmx_npei_pktx_instr_baddr {
	uint64_t u64;
	struct cvmx_npei_pktx_instr_baddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t addr:61;
		uint64_t reserved_0_2:3;
#else
		uint64_t reserved_0_2:3;
		uint64_t addr:61;
#endif
	} s;
	struct cvmx_npei_pktx_instr_baddr_s cn52xx;
	struct cvmx_npei_pktx_instr_baddr_s cn56xx;
};

union cvmx_npei_pktx_instr_baoff_dbell {
	uint64_t u64;
	struct cvmx_npei_pktx_instr_baoff_dbell_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t aoff:32;
		uint64_t dbell:32;
#else
		uint64_t dbell:32;
		uint64_t aoff:32;
#endif
	} s;
	struct cvmx_npei_pktx_instr_baoff_dbell_s cn52xx;
	struct cvmx_npei_pktx_instr_baoff_dbell_s cn56xx;
};

union cvmx_npei_pktx_instr_fifo_rsize {
	uint64_t u64;
	struct cvmx_npei_pktx_instr_fifo_rsize_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t max:9;
		uint64_t rrp:9;
		uint64_t wrp:9;
		uint64_t fcnt:5;
		uint64_t rsize:32;
#else
		uint64_t rsize:32;
		uint64_t fcnt:5;
		uint64_t wrp:9;
		uint64_t rrp:9;
		uint64_t max:9;
#endif
	} s;
	struct cvmx_npei_pktx_instr_fifo_rsize_s cn52xx;
	struct cvmx_npei_pktx_instr_fifo_rsize_s cn56xx;
};

union cvmx_npei_pktx_instr_header {
	uint64_t u64;
	struct cvmx_npei_pktx_instr_header_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t pbp:1;
		uint64_t reserved_38_42:5;
		uint64_t rparmode:2;
		uint64_t reserved_35_35:1;
		uint64_t rskp_len:7;
		uint64_t reserved_22_27:6;
		uint64_t use_ihdr:1;
		uint64_t reserved_16_20:5;
		uint64_t par_mode:2;
		uint64_t reserved_13_13:1;
		uint64_t skp_len:7;
		uint64_t reserved_0_5:6;
#else
		uint64_t reserved_0_5:6;
		uint64_t skp_len:7;
		uint64_t reserved_13_13:1;
		uint64_t par_mode:2;
		uint64_t reserved_16_20:5;
		uint64_t use_ihdr:1;
		uint64_t reserved_22_27:6;
		uint64_t rskp_len:7;
		uint64_t reserved_35_35:1;
		uint64_t rparmode:2;
		uint64_t reserved_38_42:5;
		uint64_t pbp:1;
		uint64_t reserved_44_63:20;
#endif
	} s;
	struct cvmx_npei_pktx_instr_header_s cn52xx;
	struct cvmx_npei_pktx_instr_header_s cn56xx;
};

union cvmx_npei_pktx_slist_baddr {
	uint64_t u64;
	struct cvmx_npei_pktx_slist_baddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t addr:60;
		uint64_t reserved_0_3:4;
#else
		uint64_t reserved_0_3:4;
		uint64_t addr:60;
#endif
	} s;
	struct cvmx_npei_pktx_slist_baddr_s cn52xx;
	struct cvmx_npei_pktx_slist_baddr_s cn56xx;
};

union cvmx_npei_pktx_slist_baoff_dbell {
	uint64_t u64;
	struct cvmx_npei_pktx_slist_baoff_dbell_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t aoff:32;
		uint64_t dbell:32;
#else
		uint64_t dbell:32;
		uint64_t aoff:32;
#endif
	} s;
	struct cvmx_npei_pktx_slist_baoff_dbell_s cn52xx;
	struct cvmx_npei_pktx_slist_baoff_dbell_s cn56xx;
};

union cvmx_npei_pktx_slist_fifo_rsize {
	uint64_t u64;
	struct cvmx_npei_pktx_slist_fifo_rsize_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t rsize:32;
#else
		uint64_t rsize:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pktx_slist_fifo_rsize_s cn52xx;
	struct cvmx_npei_pktx_slist_fifo_rsize_s cn56xx;
};

union cvmx_npei_pkt_cnt_int {
	uint64_t u64;
	struct cvmx_npei_pkt_cnt_int_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_cnt_int_s cn52xx;
	struct cvmx_npei_pkt_cnt_int_s cn56xx;
};

union cvmx_npei_pkt_cnt_int_enb {
	uint64_t u64;
	struct cvmx_npei_pkt_cnt_int_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_cnt_int_enb_s cn52xx;
	struct cvmx_npei_pkt_cnt_int_enb_s cn56xx;
};

union cvmx_npei_pkt_data_out_es {
	uint64_t u64;
	struct cvmx_npei_pkt_data_out_es_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t es:64;
#else
		uint64_t es:64;
#endif
	} s;
	struct cvmx_npei_pkt_data_out_es_s cn52xx;
	struct cvmx_npei_pkt_data_out_es_s cn56xx;
};

union cvmx_npei_pkt_data_out_ns {
	uint64_t u64;
	struct cvmx_npei_pkt_data_out_ns_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t nsr:32;
#else
		uint64_t nsr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_data_out_ns_s cn52xx;
	struct cvmx_npei_pkt_data_out_ns_s cn56xx;
};

union cvmx_npei_pkt_data_out_ror {
	uint64_t u64;
	struct cvmx_npei_pkt_data_out_ror_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t ror:32;
#else
		uint64_t ror:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_data_out_ror_s cn52xx;
	struct cvmx_npei_pkt_data_out_ror_s cn56xx;
};

union cvmx_npei_pkt_dpaddr {
	uint64_t u64;
	struct cvmx_npei_pkt_dpaddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t dptr:32;
#else
		uint64_t dptr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_dpaddr_s cn52xx;
	struct cvmx_npei_pkt_dpaddr_s cn56xx;
};

union cvmx_npei_pkt_in_bp {
	uint64_t u64;
	struct cvmx_npei_pkt_in_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t bp:32;
#else
		uint64_t bp:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_in_bp_s cn52xx;
	struct cvmx_npei_pkt_in_bp_s cn56xx;
};

union cvmx_npei_pkt_in_donex_cnts {
	uint64_t u64;
	struct cvmx_npei_pkt_in_donex_cnts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_in_donex_cnts_s cn52xx;
	struct cvmx_npei_pkt_in_donex_cnts_s cn56xx;
};

union cvmx_npei_pkt_in_instr_counts {
	uint64_t u64;
	struct cvmx_npei_pkt_in_instr_counts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wr_cnt:32;
		uint64_t rd_cnt:32;
#else
		uint64_t rd_cnt:32;
		uint64_t wr_cnt:32;
#endif
	} s;
	struct cvmx_npei_pkt_in_instr_counts_s cn52xx;
	struct cvmx_npei_pkt_in_instr_counts_s cn56xx;
};

union cvmx_npei_pkt_in_pcie_port {
	uint64_t u64;
	struct cvmx_npei_pkt_in_pcie_port_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t pp:64;
#else
		uint64_t pp:64;
#endif
	} s;
	struct cvmx_npei_pkt_in_pcie_port_s cn52xx;
	struct cvmx_npei_pkt_in_pcie_port_s cn56xx;
};

union cvmx_npei_pkt_input_control {
	uint64_t u64;
	struct cvmx_npei_pkt_input_control_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t pkt_rr:1;
		uint64_t pbp_dhi:13;
		uint64_t d_nsr:1;
		uint64_t d_esr:2;
		uint64_t d_ror:1;
		uint64_t use_csr:1;
		uint64_t nsr:1;
		uint64_t esr:2;
		uint64_t ror:1;
#else
		uint64_t ror:1;
		uint64_t esr:2;
		uint64_t nsr:1;
		uint64_t use_csr:1;
		uint64_t d_ror:1;
		uint64_t d_esr:2;
		uint64_t d_nsr:1;
		uint64_t pbp_dhi:13;
		uint64_t pkt_rr:1;
		uint64_t reserved_23_63:41;
#endif
	} s;
	struct cvmx_npei_pkt_input_control_s cn52xx;
	struct cvmx_npei_pkt_input_control_s cn56xx;
};

union cvmx_npei_pkt_instr_enb {
	uint64_t u64;
	struct cvmx_npei_pkt_instr_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t enb:32;
#else
		uint64_t enb:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_instr_enb_s cn52xx;
	struct cvmx_npei_pkt_instr_enb_s cn56xx;
};

union cvmx_npei_pkt_instr_rd_size {
	uint64_t u64;
	struct cvmx_npei_pkt_instr_rd_size_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t rdsize:64;
#else
		uint64_t rdsize:64;
#endif
	} s;
	struct cvmx_npei_pkt_instr_rd_size_s cn52xx;
	struct cvmx_npei_pkt_instr_rd_size_s cn56xx;
};

union cvmx_npei_pkt_instr_size {
	uint64_t u64;
	struct cvmx_npei_pkt_instr_size_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t is_64b:32;
#else
		uint64_t is_64b:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_instr_size_s cn52xx;
	struct cvmx_npei_pkt_instr_size_s cn56xx;
};

union cvmx_npei_pkt_int_levels {
	uint64_t u64;
	struct cvmx_npei_pkt_int_levels_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_54_63:10;
		uint64_t time:22;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t time:22;
		uint64_t reserved_54_63:10;
#endif
	} s;
	struct cvmx_npei_pkt_int_levels_s cn52xx;
	struct cvmx_npei_pkt_int_levels_s cn56xx;
};

union cvmx_npei_pkt_iptr {
	uint64_t u64;
	struct cvmx_npei_pkt_iptr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t iptr:32;
#else
		uint64_t iptr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_iptr_s cn52xx;
	struct cvmx_npei_pkt_iptr_s cn56xx;
};

union cvmx_npei_pkt_out_bmode {
	uint64_t u64;
	struct cvmx_npei_pkt_out_bmode_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t bmode:32;
#else
		uint64_t bmode:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_out_bmode_s cn52xx;
	struct cvmx_npei_pkt_out_bmode_s cn56xx;
};

union cvmx_npei_pkt_out_enb {
	uint64_t u64;
	struct cvmx_npei_pkt_out_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t enb:32;
#else
		uint64_t enb:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_out_enb_s cn52xx;
	struct cvmx_npei_pkt_out_enb_s cn56xx;
};

union cvmx_npei_pkt_output_wmark {
	uint64_t u64;
	struct cvmx_npei_pkt_output_wmark_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t wmark:32;
#else
		uint64_t wmark:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_output_wmark_s cn52xx;
	struct cvmx_npei_pkt_output_wmark_s cn56xx;
};

union cvmx_npei_pkt_pcie_port {
	uint64_t u64;
	struct cvmx_npei_pkt_pcie_port_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t pp:64;
#else
		uint64_t pp:64;
#endif
	} s;
	struct cvmx_npei_pkt_pcie_port_s cn52xx;
	struct cvmx_npei_pkt_pcie_port_s cn56xx;
};

union cvmx_npei_pkt_port_in_rst {
	uint64_t u64;
	struct cvmx_npei_pkt_port_in_rst_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t in_rst:32;
		uint64_t out_rst:32;
#else
		uint64_t out_rst:32;
		uint64_t in_rst:32;
#endif
	} s;
	struct cvmx_npei_pkt_port_in_rst_s cn52xx;
	struct cvmx_npei_pkt_port_in_rst_s cn56xx;
};

union cvmx_npei_pkt_slist_es {
	uint64_t u64;
	struct cvmx_npei_pkt_slist_es_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t es:64;
#else
		uint64_t es:64;
#endif
	} s;
	struct cvmx_npei_pkt_slist_es_s cn52xx;
	struct cvmx_npei_pkt_slist_es_s cn56xx;
};

union cvmx_npei_pkt_slist_id_size {
	uint64_t u64;
	struct cvmx_npei_pkt_slist_id_size_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t isize:7;
		uint64_t bsize:16;
#else
		uint64_t bsize:16;
		uint64_t isize:7;
		uint64_t reserved_23_63:41;
#endif
	} s;
	struct cvmx_npei_pkt_slist_id_size_s cn52xx;
	struct cvmx_npei_pkt_slist_id_size_s cn56xx;
};

union cvmx_npei_pkt_slist_ns {
	uint64_t u64;
	struct cvmx_npei_pkt_slist_ns_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t nsr:32;
#else
		uint64_t nsr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_slist_ns_s cn52xx;
	struct cvmx_npei_pkt_slist_ns_s cn56xx;
};

union cvmx_npei_pkt_slist_ror {
	uint64_t u64;
	struct cvmx_npei_pkt_slist_ror_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t ror:32;
#else
		uint64_t ror:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_slist_ror_s cn52xx;
	struct cvmx_npei_pkt_slist_ror_s cn56xx;
};

union cvmx_npei_pkt_time_int {
	uint64_t u64;
	struct cvmx_npei_pkt_time_int_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_time_int_s cn52xx;
	struct cvmx_npei_pkt_time_int_s cn56xx;
};

union cvmx_npei_pkt_time_int_enb {
	uint64_t u64;
	struct cvmx_npei_pkt_time_int_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_pkt_time_int_enb_s cn52xx;
	struct cvmx_npei_pkt_time_int_enb_s cn56xx;
};

union cvmx_npei_rsl_int_blocks {
	uint64_t u64;
	struct cvmx_npei_rsl_int_blocks_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t iob:1;
		uint64_t lmc1:1;
		uint64_t agl:1;
		uint64_t reserved_24_27:4;
		uint64_t asxpcs1:1;
		uint64_t asxpcs0:1;
		uint64_t reserved_21_21:1;
		uint64_t pip:1;
		uint64_t spx1:1;
		uint64_t spx0:1;
		uint64_t lmc0:1;
		uint64_t l2c:1;
		uint64_t usb1:1;
		uint64_t rad:1;
		uint64_t usb:1;
		uint64_t pow:1;
		uint64_t tim:1;
		uint64_t pko:1;
		uint64_t ipd:1;
		uint64_t reserved_8_8:1;
		uint64_t zip:1;
		uint64_t dfa:1;
		uint64_t fpa:1;
		uint64_t key:1;
		uint64_t npei:1;
		uint64_t gmx1:1;
		uint64_t gmx0:1;
		uint64_t mio:1;
#else
		uint64_t mio:1;
		uint64_t gmx0:1;
		uint64_t gmx1:1;
		uint64_t npei:1;
		uint64_t key:1;
		uint64_t fpa:1;
		uint64_t dfa:1;
		uint64_t zip:1;
		uint64_t reserved_8_8:1;
		uint64_t ipd:1;
		uint64_t pko:1;
		uint64_t tim:1;
		uint64_t pow:1;
		uint64_t usb:1;
		uint64_t rad:1;
		uint64_t usb1:1;
		uint64_t l2c:1;
		uint64_t lmc0:1;
		uint64_t spx0:1;
		uint64_t spx1:1;
		uint64_t pip:1;
		uint64_t reserved_21_21:1;
		uint64_t asxpcs0:1;
		uint64_t asxpcs1:1;
		uint64_t reserved_24_27:4;
		uint64_t agl:1;
		uint64_t lmc1:1;
		uint64_t iob:1;
		uint64_t reserved_31_63:33;
#endif
	} s;
	struct cvmx_npei_rsl_int_blocks_s cn52xx;
	struct cvmx_npei_rsl_int_blocks_s cn52xxp1;
	struct cvmx_npei_rsl_int_blocks_s cn56xx;
	struct cvmx_npei_rsl_int_blocks_s cn56xxp1;
};

union cvmx_npei_scratch_1 {
	uint64_t u64;
	struct cvmx_npei_scratch_1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_npei_scratch_1_s cn52xx;
	struct cvmx_npei_scratch_1_s cn52xxp1;
	struct cvmx_npei_scratch_1_s cn56xx;
	struct cvmx_npei_scratch_1_s cn56xxp1;
};

union cvmx_npei_state1 {
	uint64_t u64;
	struct cvmx_npei_state1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t cpl1:12;
		uint64_t cpl0:12;
		uint64_t arb:1;
		uint64_t csr:39;
#else
		uint64_t csr:39;
		uint64_t arb:1;
		uint64_t cpl0:12;
		uint64_t cpl1:12;
#endif
	} s;
	struct cvmx_npei_state1_s cn52xx;
	struct cvmx_npei_state1_s cn52xxp1;
	struct cvmx_npei_state1_s cn56xx;
	struct cvmx_npei_state1_s cn56xxp1;
};

union cvmx_npei_state2 {
	uint64_t u64;
	struct cvmx_npei_state2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t npei:1;
		uint64_t rac:1;
		uint64_t csm1:15;
		uint64_t csm0:15;
		uint64_t nnp0:8;
		uint64_t nnd:8;
#else
		uint64_t nnd:8;
		uint64_t nnp0:8;
		uint64_t csm0:15;
		uint64_t csm1:15;
		uint64_t rac:1;
		uint64_t npei:1;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_npei_state2_s cn52xx;
	struct cvmx_npei_state2_s cn52xxp1;
	struct cvmx_npei_state2_s cn56xx;
	struct cvmx_npei_state2_s cn56xxp1;
};

union cvmx_npei_state3 {
	uint64_t u64;
	struct cvmx_npei_state3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_56_63:8;
		uint64_t psm1:15;
		uint64_t psm0:15;
		uint64_t nsm1:13;
		uint64_t nsm0:13;
#else
		uint64_t nsm0:13;
		uint64_t nsm1:13;
		uint64_t psm0:15;
		uint64_t psm1:15;
		uint64_t reserved_56_63:8;
#endif
	} s;
	struct cvmx_npei_state3_s cn52xx;
	struct cvmx_npei_state3_s cn52xxp1;
	struct cvmx_npei_state3_s cn56xx;
	struct cvmx_npei_state3_s cn56xxp1;
};

union cvmx_npei_win_rd_addr {
	uint64_t u64;
	struct cvmx_npei_win_rd_addr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_51_63:13;
		uint64_t ld_cmd:2;
		uint64_t iobit:1;
		uint64_t rd_addr:48;
#else
		uint64_t rd_addr:48;
		uint64_t iobit:1;
		uint64_t ld_cmd:2;
		uint64_t reserved_51_63:13;
#endif
	} s;
	struct cvmx_npei_win_rd_addr_s cn52xx;
	struct cvmx_npei_win_rd_addr_s cn52xxp1;
	struct cvmx_npei_win_rd_addr_s cn56xx;
	struct cvmx_npei_win_rd_addr_s cn56xxp1;
};

union cvmx_npei_win_rd_data {
	uint64_t u64;
	struct cvmx_npei_win_rd_data_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t rd_data:64;
#else
		uint64_t rd_data:64;
#endif
	} s;
	struct cvmx_npei_win_rd_data_s cn52xx;
	struct cvmx_npei_win_rd_data_s cn52xxp1;
	struct cvmx_npei_win_rd_data_s cn56xx;
	struct cvmx_npei_win_rd_data_s cn56xxp1;
};

union cvmx_npei_win_wr_addr {
	uint64_t u64;
	struct cvmx_npei_win_wr_addr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_49_63:15;
		uint64_t iobit:1;
		uint64_t wr_addr:46;
		uint64_t reserved_0_1:2;
#else
		uint64_t reserved_0_1:2;
		uint64_t wr_addr:46;
		uint64_t iobit:1;
		uint64_t reserved_49_63:15;
#endif
	} s;
	struct cvmx_npei_win_wr_addr_s cn52xx;
	struct cvmx_npei_win_wr_addr_s cn52xxp1;
	struct cvmx_npei_win_wr_addr_s cn56xx;
	struct cvmx_npei_win_wr_addr_s cn56xxp1;
};

union cvmx_npei_win_wr_data {
	uint64_t u64;
	struct cvmx_npei_win_wr_data_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wr_data:64;
#else
		uint64_t wr_data:64;
#endif
	} s;
	struct cvmx_npei_win_wr_data_s cn52xx;
	struct cvmx_npei_win_wr_data_s cn52xxp1;
	struct cvmx_npei_win_wr_data_s cn56xx;
	struct cvmx_npei_win_wr_data_s cn56xxp1;
};

union cvmx_npei_win_wr_mask {
	uint64_t u64;
	struct cvmx_npei_win_wr_mask_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t wr_mask:8;
#else
		uint64_t wr_mask:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_npei_win_wr_mask_s cn52xx;
	struct cvmx_npei_win_wr_mask_s cn52xxp1;
	struct cvmx_npei_win_wr_mask_s cn56xx;
	struct cvmx_npei_win_wr_mask_s cn56xxp1;
};

union cvmx_npei_window_ctl {
	uint64_t u64;
	struct cvmx_npei_window_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t time:32;
#else
		uint64_t time:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_npei_window_ctl_s cn52xx;
	struct cvmx_npei_window_ctl_s cn52xxp1;
	struct cvmx_npei_window_ctl_s cn56xx;
	struct cvmx_npei_window_ctl_s cn56xxp1;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /***********************license start***************
 * Author: Cavium Networks
 *
 * Contact: support@caviumnetworks.com
 * This file is part of the OCTEON SDK
 *
 * Copyright (c) 2003-2012 Cavium Networks
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, Version 2, as
 * published by the Free Software Foundation.
 *
 * This file is distributed in the hope that it will be useful, but
 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
 * NONINFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 * or visit http://www.gnu.org/licenses/.
 *
 * This file may also be available under a different license from Cavium.
 * Contact Cavium Networks for more information
 ***********************license end**************************************/

#ifndef __CVMX_GMXX_DEFS_H__
#define __CVMX_GMXX_DEFS_H__

static inline uint64_t CVMX_GMXX_BAD_REG(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000518ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_BIST(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000400ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_BPID_MAPX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000680ull) + (((offset) & 15) + ((block_id) & 7) * 0x200000ull) * 8)
#define CVMX_GMXX_BPID_MSK(block_id) (CVMX_ADD_IO_SEG(0x0001180008000700ull) + ((block_id) & 7) * 0x1000000ull)
static inline uint64_t CVMX_GMXX_CLK_EN(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080007F0ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_EBP_DIS(block_id) (CVMX_ADD_IO_SEG(0x0001180008000608ull) + ((block_id) & 7) * 0x1000000ull)
#define CVMX_GMXX_EBP_MSK(block_id) (CVMX_ADD_IO_SEG(0x0001180008000600ull) + ((block_id) & 7) * 0x1000000ull)
static inline uint64_t CVMX_GMXX_HG2_CONTROL(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000550ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_INF_MODE(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080007F8ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_NXA_ADR(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000510ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_PIPE_STATUS(block_id) (CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((block_id) & 7) * 0x1000000ull)
static inline uint64_t CVMX_GMXX_PRTX_CBFC_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000580ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000580ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000580ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000580ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_PRTX_CFG(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000010ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

#define CVMX_GMXX_RXAUI_CTL(block_id) (CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((block_id) & 7) * 0x1000000ull)
static inline uint64_t CVMX_GMXX_RXX_ADR_CAM0(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000180ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000180ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000180ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000180ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000180ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000180ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM1(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000188ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000188ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000188ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000188ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000188ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000188ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM2(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000190ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000190ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000190ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000190ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000190ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000190ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM3(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000198ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000198ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000198ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000198ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000198ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000198ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM4(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080001A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM5(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A8ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080001A8ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080001A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM_ALL_EN(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000110ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000110ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000110ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000110ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CAM_EN(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000108ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_ADR_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000100ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_DECISION(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000040ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_FRM_CHK(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000020ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_FRM_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000018ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

#define CVMX_GMXX_RXX_FRM_MAX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000030ull) + (((offset) & 3) + ((block_id) & 1) * 0x10000ull) * 2048)
#define CVMX_GMXX_RXX_FRM_MIN(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000028ull) + (((offset) & 3) + ((block_id) & 1) * 0x10000ull) * 2048)
static inline uint64_t CVMX_GMXX_RXX_IFG(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000058ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_INT_EN(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000008ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_INT_REG(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000000ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_JABBER(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000038ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_PAUSE_DROP_TIME(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000068ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

#define CVMX_GMXX_RXX_RX_INBND(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000060ull) + (((offset) & 3) + ((block_id) & 1) * 0x10000ull) * 2048)
static inline uint64_t CVMX_GMXX_RXX_STATS_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000050ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_OCTS(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000088ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_OCTS_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000098ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_OCTS_DMAC(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080000A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_OCTS_DRP(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080000B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_PKTS(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000080ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_PKTS_BAD(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080000C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_PKTS_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000090ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_PKTS_DMAC(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080000A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_STATS_PKTS_DRP(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080000B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RXX_UDD_SKP(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000048ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_RX_BP_DROPX(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x0ull) * 8;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x200000ull) * 8;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000420ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
}

static inline uint64_t CVMX_GMXX_RX_BP_OFFX(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x0ull) * 8;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x200000ull) * 8;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000460ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
}

static inline uint64_t CVMX_GMXX_RX_BP_ONX(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x0ull) * 8;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x200000ull) * 8;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000440ull) + ((offset) + (block_id) * 0x1000000ull) * 8;
}

static inline uint64_t CVMX_GMXX_RX_HG2_STATUS(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000548ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_RX_PASS_EN(block_id) (CVMX_ADD_IO_SEG(0x00011800080005F8ull) + ((block_id) & 1) * 0x8000000ull)
#define CVMX_GMXX_RX_PASS_MAPX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000600ull) + (((offset) & 15) + ((block_id) & 1) * 0x1000000ull) * 8)
static inline uint64_t CVMX_GMXX_RX_PRTS(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000410ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_RX_PRT_INFO(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004E8ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_RX_TX_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800080007E8ull))
static inline uint64_t CVMX_GMXX_RX_XAUI_BAD_COL(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000538ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_RX_XAUI_CTL(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000530ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_SMACX(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000230ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_SOFT_BIST(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080007E8ull) + (block_id) * 0x1000000ull;
}

static inline uint64_t CVMX_GMXX_STAT_BP(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000520ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TB_REG(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080007E0ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TXX_APPEND(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000218ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_BURST(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000228ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_CBFC_XOFF(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080005A0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080005A0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080005A0ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080005A0ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TXX_CBFC_XON(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080005C0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080005C0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080005C0ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080005C0ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_TXX_CLK(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000208ull) + (((offset) & 3) + ((block_id) & 1) * 0x10000ull) * 2048)
static inline uint64_t CVMX_GMXX_TXX_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000270ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_MIN_PKT(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000240ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000248ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_PAUSE_PKT_TIME(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000238ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_PAUSE_TOGO(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000258ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_PAUSE_ZERO(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000260ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

#define CVMX_GMXX_TXX_PIPE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000310ull) + (((offset) & 3) + ((block_id) & 7) * 0x2000ull) * 2048)
static inline uint64_t CVMX_GMXX_TXX_SGMII_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000300ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000300ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000300ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000300ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000300ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_SLOT(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000220ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_SOFT_PAUSE(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000250ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT0(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000280ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT1(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000288ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT2(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000290ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT3(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000298ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT4(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080002A0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT5(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080002A8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT6(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080002B0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT7(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080002B8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT8(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080002C0ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STAT9(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x00011800080002C8ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_STATS_CTL(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000268ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TXX_THRESH(unsigned long offset, unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x0ull) * 2048;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x2000ull) * 2048;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000210ull) + ((offset) + (block_id) * 0x10000ull) * 2048;
}

static inline uint64_t CVMX_GMXX_TX_BP(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004D0ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_TX_CLK_MSKX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000780ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
static inline uint64_t CVMX_GMXX_TX_COL_ATTEMPT(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000498ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_CORRUPT(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004D8ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_HG2_REG1(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000558ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_HG2_REG2(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000560ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_IFG(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000488ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_INT_EN(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000508ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_INT_REG(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000500ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_JAM(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000490ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_LFSR(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004F8ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_OVR_BP(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004C8ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_DMAC(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004A0ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_PAUSE_PKT_TYPE(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x00011800080004A8ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_TX_PRTS(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000480ull) + (block_id) * 0x8000000ull;
}

#define CVMX_GMXX_TX_SPI_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800080004C0ull) + ((block_id) & 1) * 0x8000000ull)
#define CVMX_GMXX_TX_SPI_DRAIN(block_id) (CVMX_ADD_IO_SEG(0x00011800080004E0ull) + ((block_id) & 1) * 0x8000000ull)
#define CVMX_GMXX_TX_SPI_MAX(block_id) (CVMX_ADD_IO_SEG(0x00011800080004B0ull) + ((block_id) & 1) * 0x8000000ull)
#define CVMX_GMXX_TX_SPI_ROUNDX(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180008000680ull) + (((offset) & 31) + ((block_id) & 1) * 0x1000000ull) * 8)
#define CVMX_GMXX_TX_SPI_THRESH(block_id) (CVMX_ADD_IO_SEG(0x00011800080004B8ull) + ((block_id) & 1) * 0x8000000ull)
static inline uint64_t CVMX_GMXX_TX_XAUI_CTL(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000528ull) + (block_id) * 0x8000000ull;
}

static inline uint64_t CVMX_GMXX_XAUI_EXT_LOOPBACK(unsigned long block_id)
{
	switch (cvmx_get_octeon_family()) {
	case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
	case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x8000000ull;
	case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
		return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x1000000ull;
	}
	return CVMX_ADD_IO_SEG(0x0001180008000540ull) + (block_id) * 0x8000000ull;
}

union cvmx_gmxx_bad_reg {
	uint64_t u64;
	struct cvmx_gmxx_bad_reg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t inb_nxa:4;
		uint64_t statovr:1;
		uint64_t loststat:4;
		uint64_t reserved_18_21:4;
		uint64_t out_ovr:16;
		uint64_t ncb_ovr:1;
		uint64_t out_col:1;
#else
		uint64_t out_col:1;
		uint64_t ncb_ovr:1;
		uint64_t out_ovr:16;
		uint64_t reserved_18_21:4;
		uint64_t loststat:4;
		uint64_t statovr:1;
		uint64_t inb_nxa:4;
		uint64_t reserved_31_63:33;
#endif
	} s;
	struct cvmx_gmxx_bad_reg_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t inb_nxa:4;
		uint64_t statovr:1;
		uint64_t reserved_25_25:1;
		uint64_t loststat:3;
		uint64_t reserved_5_21:17;
		uint64_t out_ovr:3;
		uint64_t reserved_0_1:2;
#else
		uint64_t reserved_0_1:2;
		uint64_t out_ovr:3;
		uint64_t reserved_5_21:17;
		uint64_t loststat:3;
		uint64_t reserved_25_25:1;
		uint64_t statovr:1;
		uint64_t inb_nxa:4;
		uint64_t reserved_31_63:33;
#endif
	} cn30xx;
	struct cvmx_gmxx_bad_reg_cn30xx cn31xx;
	struct cvmx_gmxx_bad_reg_s cn38xx;
	struct cvmx_gmxx_bad_reg_s cn38xxp2;
	struct cvmx_gmxx_bad_reg_cn30xx cn50xx;
	struct cvmx_gmxx_bad_reg_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t inb_nxa:4;
		uint64_t statovr:1;
		uint64_t loststat:4;
		uint64_t reserved_6_21:16;
		uint64_t out_ovr:4;
		uint64_t reserved_0_1:2;
#else
		uint64_t reserved_0_1:2;
		uint64_t out_ovr:4;
		uint64_t reserved_6_21:16;
		uint64_t loststat:4;
		uint64_t statovr:1;
		uint64_t inb_nxa:4;
		uint64_t reserved_31_63:33;
#endif
	} cn52xx;
	struct cvmx_gmxx_bad_reg_cn52xx cn52xxp1;
	struct cvmx_gmxx_bad_reg_cn52xx cn56xx;
	struct cvmx_gmxx_bad_reg_cn52xx cn56xxp1;
	struct cvmx_gmxx_bad_reg_s cn58xx;
	struct cvmx_gmxx_bad_reg_s cn58xxp1;
	struct cvmx_gmxx_bad_reg_cn52xx cn61xx;
	struct cvmx_gmxx_bad_reg_cn52xx cn63xx;
	struct cvmx_gmxx_bad_reg_cn52xx cn63xxp1;
	struct cvmx_gmxx_bad_reg_cn52xx cn66xx;
	struct cvmx_gmxx_bad_reg_cn52xx cn68xx;
	struct cvmx_gmxx_bad_reg_cn52xx cn68xxp1;
	struct cvmx_gmxx_bad_reg_cn52xx cnf71xx;
};

union cvmx_gmxx_bist {
	uint64_t u64;
	struct cvmx_gmxx_bist_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t status:25;
#else
		uint64_t status:25;
		uint64_t reserved_25_63:39;
#endif
	} s;
	struct cvmx_gmxx_bist_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t status:10;
#else
		uint64_t status:10;
		uint64_t reserved_10_63:54;
#endif
	} cn30xx;
	struct cvmx_gmxx_bist_cn30xx cn31xx;
	struct cvmx_gmxx_bist_cn30xx cn38xx;
	struct cvmx_gmxx_bist_cn30xx cn38xxp2;
	struct cvmx_gmxx_bist_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_12_63:52;
		uint64_t status:12;
#else
		uint64_t status:12;
		uint64_t reserved_12_63:52;
#endif
	} cn50xx;
	struct cvmx_gmxx_bist_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t status:16;
#else
		uint64_t status:16;
		uint64_t reserved_16_63:48;
#endif
	} cn52xx;
	struct cvmx_gmxx_bist_cn52xx cn52xxp1;
	struct cvmx_gmxx_bist_cn52xx cn56xx;
	struct cvmx_gmxx_bist_cn52xx cn56xxp1;
	struct cvmx_gmxx_bist_cn58xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_17_63:47;
		uint64_t status:17;
#else
		uint64_t status:17;
		uint64_t reserved_17_63:47;
#endif
	} cn58xx;
	struct cvmx_gmxx_bist_cn58xx cn58xxp1;
	struct cvmx_gmxx_bist_s cn61xx;
	struct cvmx_gmxx_bist_s cn63xx;
	struct cvmx_gmxx_bist_s cn63xxp1;
	struct cvmx_gmxx_bist_s cn66xx;
	struct cvmx_gmxx_bist_s cn68xx;
	struct cvmx_gmxx_bist_s cn68xxp1;
	struct cvmx_gmxx_bist_s cnf71xx;
};

union cvmx_gmxx_bpid_mapx {
	uint64_t u64;
	struct cvmx_gmxx_bpid_mapx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_17_63:47;
		uint64_t status:1;
		uint64_t reserved_9_15:7;
		uint64_t val:1;
		uint64_t reserved_6_7:2;
		uint64_t bpid:6;
#else
		uint64_t bpid:6;
		uint64_t reserved_6_7:2;
		uint64_t val:1;
		uint64_t reserved_9_15:7;
		uint64_t status:1;
		uint64_t reserved_17_63:47;
#endif
	} s;
	struct cvmx_gmxx_bpid_mapx_s cn68xx;
	struct cvmx_gmxx_bpid_mapx_s cn68xxp1;
};

union cvmx_gmxx_bpid_msk {
	uint64_t u64;
	struct cvmx_gmxx_bpid_msk_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t msk_or:16;
		uint64_t reserved_16_31:16;
		uint64_t msk_and:16;
#else
		uint64_t msk_and:16;
		uint64_t reserved_16_31:16;
		uint64_t msk_or:16;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_bpid_msk_s cn68xx;
	struct cvmx_gmxx_bpid_msk_s cn68xxp1;
};

union cvmx_gmxx_clk_en {
	uint64_t u64;
	struct cvmx_gmxx_clk_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t clk_en:1;
#else
		uint64_t clk_en:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_clk_en_s cn52xx;
	struct cvmx_gmxx_clk_en_s cn52xxp1;
	struct cvmx_gmxx_clk_en_s cn56xx;
	struct cvmx_gmxx_clk_en_s cn56xxp1;
	struct cvmx_gmxx_clk_en_s cn61xx;
	struct cvmx_gmxx_clk_en_s cn63xx;
	struct cvmx_gmxx_clk_en_s cn63xxp1;
	struct cvmx_gmxx_clk_en_s cn66xx;
	struct cvmx_gmxx_clk_en_s cn68xx;
	struct cvmx_gmxx_clk_en_s cn68xxp1;
	struct cvmx_gmxx_clk_en_s cnf71xx;
};

union cvmx_gmxx_ebp_dis {
	uint64_t u64;
	struct cvmx_gmxx_ebp_dis_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t dis:16;
#else
		uint64_t dis:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_ebp_dis_s cn68xx;
	struct cvmx_gmxx_ebp_dis_s cn68xxp1;
};

union cvmx_gmxx_ebp_msk {
	uint64_t u64;
	struct cvmx_gmxx_ebp_msk_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t msk:16;
#else
		uint64_t msk:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_ebp_msk_s cn68xx;
	struct cvmx_gmxx_ebp_msk_s cn68xxp1;
};

union cvmx_gmxx_hg2_control {
	uint64_t u64;
	struct cvmx_gmxx_hg2_control_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t hg2tx_en:1;
		uint64_t hg2rx_en:1;
		uint64_t phys_en:1;
		uint64_t logl_en:16;
#else
		uint64_t logl_en:16;
		uint64_t phys_en:1;
		uint64_t hg2rx_en:1;
		uint64_t hg2tx_en:1;
		uint64_t reserved_19_63:45;
#endif
	} s;
	struct cvmx_gmxx_hg2_control_s cn52xx;
	struct cvmx_gmxx_hg2_control_s cn52xxp1;
	struct cvmx_gmxx_hg2_control_s cn56xx;
	struct cvmx_gmxx_hg2_control_s cn61xx;
	struct cvmx_gmxx_hg2_control_s cn63xx;
	struct cvmx_gmxx_hg2_control_s cn63xxp1;
	struct cvmx_gmxx_hg2_control_s cn66xx;
	struct cvmx_gmxx_hg2_control_s cn68xx;
	struct cvmx_gmxx_hg2_control_s cn68xxp1;
	struct cvmx_gmxx_hg2_control_s cnf71xx;
};

union cvmx_gmxx_inf_mode {
	uint64_t u64;
	struct cvmx_gmxx_inf_mode_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t rate:4;
		uint64_t reserved_12_15:4;
		uint64_t speed:4;
		uint64_t reserved_7_7:1;
		uint64_t mode:3;
		uint64_t reserved_3_3:1;
		uint64_t p0mii:1;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t p0mii:1;
		uint64_t reserved_3_3:1;
		uint64_t mode:3;
		uint64_t reserved_7_7:1;
		uint64_t speed:4;
		uint64_t reserved_12_15:4;
		uint64_t rate:4;
		uint64_t reserved_20_63:44;
#endif
	} s;
	struct cvmx_gmxx_inf_mode_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_3_63:61;
		uint64_t p0mii:1;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t p0mii:1;
		uint64_t reserved_3_63:61;
#endif
	} cn30xx;
	struct cvmx_gmxx_inf_mode_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t reserved_2_63:62;
#endif
	} cn31xx;
	struct cvmx_gmxx_inf_mode_cn31xx cn38xx;
	struct cvmx_gmxx_inf_mode_cn31xx cn38xxp2;
	struct cvmx_gmxx_inf_mode_cn30xx cn50xx;
	struct cvmx_gmxx_inf_mode_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t speed:2;
		uint64_t reserved_6_7:2;
		uint64_t mode:2;
		uint64_t reserved_2_3:2;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t reserved_2_3:2;
		uint64_t mode:2;
		uint64_t reserved_6_7:2;
		uint64_t speed:2;
		uint64_t reserved_10_63:54;
#endif
	} cn52xx;
	struct cvmx_gmxx_inf_mode_cn52xx cn52xxp1;
	struct cvmx_gmxx_inf_mode_cn52xx cn56xx;
	struct cvmx_gmxx_inf_mode_cn52xx cn56xxp1;
	struct cvmx_gmxx_inf_mode_cn31xx cn58xx;
	struct cvmx_gmxx_inf_mode_cn31xx cn58xxp1;
	struct cvmx_gmxx_inf_mode_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_12_63:52;
		uint64_t speed:4;
		uint64_t reserved_5_7:3;
		uint64_t mode:1;
		uint64_t reserved_2_3:2;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t reserved_2_3:2;
		uint64_t mode:1;
		uint64_t reserved_5_7:3;
		uint64_t speed:4;
		uint64_t reserved_12_63:52;
#endif
	} cn61xx;
	struct cvmx_gmxx_inf_mode_cn61xx cn63xx;
	struct cvmx_gmxx_inf_mode_cn61xx cn63xxp1;
	struct cvmx_gmxx_inf_mode_cn66xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t rate:4;
		uint64_t reserved_12_15:4;
		uint64_t speed:4;
		uint64_t reserved_5_7:3;
		uint64_t mode:1;
		uint64_t reserved_2_3:2;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t reserved_2_3:2;
		uint64_t mode:1;
		uint64_t reserved_5_7:3;
		uint64_t speed:4;
		uint64_t reserved_12_15:4;
		uint64_t rate:4;
		uint64_t reserved_20_63:44;
#endif
	} cn66xx;
	struct cvmx_gmxx_inf_mode_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_12_63:52;
		uint64_t speed:4;
		uint64_t reserved_7_7:1;
		uint64_t mode:3;
		uint64_t reserved_2_3:2;
		uint64_t en:1;
		uint64_t type:1;
#else
		uint64_t type:1;
		uint64_t en:1;
		uint64_t reserved_2_3:2;
		uint64_t mode:3;
		uint64_t reserved_7_7:1;
		uint64_t speed:4;
		uint64_t reserved_12_63:52;
#endif
	} cn68xx;
	struct cvmx_gmxx_inf_mode_cn68xx cn68xxp1;
	struct cvmx_gmxx_inf_mode_cn61xx cnf71xx;
};

union cvmx_gmxx_nxa_adr {
	uint64_t u64;
	struct cvmx_gmxx_nxa_adr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t pipe:7;
		uint64_t reserved_6_15:10;
		uint64_t prt:6;
#else
		uint64_t prt:6;
		uint64_t reserved_6_15:10;
		uint64_t pipe:7;
		uint64_t reserved_23_63:41;
#endif
	} s;
	struct cvmx_gmxx_nxa_adr_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t prt:6;
#else
		uint64_t prt:6;
		uint64_t reserved_6_63:58;
#endif
	} cn30xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn31xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn38xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn38xxp2;
	struct cvmx_gmxx_nxa_adr_cn30xx cn50xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn52xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn52xxp1;
	struct cvmx_gmxx_nxa_adr_cn30xx cn56xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn56xxp1;
	struct cvmx_gmxx_nxa_adr_cn30xx cn58xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn58xxp1;
	struct cvmx_gmxx_nxa_adr_cn30xx cn61xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn63xx;
	struct cvmx_gmxx_nxa_adr_cn30xx cn63xxp1;
	struct cvmx_gmxx_nxa_adr_cn30xx cn66xx;
	struct cvmx_gmxx_nxa_adr_s cn68xx;
	struct cvmx_gmxx_nxa_adr_s cn68xxp1;
	struct cvmx_gmxx_nxa_adr_cn30xx cnf71xx;
};

union cvmx_gmxx_pipe_status {
	uint64_t u64;
	struct cvmx_gmxx_pipe_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t ovr:4;
		uint64_t reserved_12_15:4;
		uint64_t bp:4;
		uint64_t reserved_4_7:4;
		uint64_t stop:4;
#else
		uint64_t stop:4;
		uint64_t reserved_4_7:4;
		uint64_t bp:4;
		uint64_t reserved_12_15:4;
		uint64_t ovr:4;
		uint64_t reserved_20_63:44;
#endif
	} s;
	struct cvmx_gmxx_pipe_status_s cn68xx;
	struct cvmx_gmxx_pipe_status_s cn68xxp1;
};

union cvmx_gmxx_prtx_cbfc_ctl {
	uint64_t u64;
	struct cvmx_gmxx_prtx_cbfc_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t phys_en:16;
		uint64_t logl_en:16;
		uint64_t phys_bp:16;
		uint64_t reserved_4_15:12;
		uint64_t bck_en:1;
		uint64_t drp_en:1;
		uint64_t tx_en:1;
		uint64_t rx_en:1;
#else
		uint64_t rx_en:1;
		uint64_t tx_en:1;
		uint64_t drp_en:1;
		uint64_t bck_en:1;
		uint64_t reserved_4_15:12;
		uint64_t phys_bp:16;
		uint64_t logl_en:16;
		uint64_t phys_en:16;
#endif
	} s;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn52xx;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn56xx;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn61xx;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn63xx;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn63xxp1;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn66xx;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn68xx;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cn68xxp1;
	struct cvmx_gmxx_prtx_cbfc_ctl_s cnf71xx;
};

union cvmx_gmxx_prtx_cfg {
	uint64_t u64;
	struct cvmx_gmxx_prtx_cfg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_22_63:42;
		uint64_t pknd:6;
		uint64_t reserved_14_15:2;
		uint64_t tx_idle:1;
		uint64_t rx_idle:1;
		uint64_t reserved_9_11:3;
		uint64_t speed_msb:1;
		uint64_t reserved_4_7:4;
		uint64_t slottime:1;
		uint64_t duplex:1;
		uint64_t speed:1;
		uint64_t en:1;
#else
		uint64_t en:1;
		uint64_t speed:1;
		uint64_t duplex:1;
		uint64_t slottime:1;
		uint64_t reserved_4_7:4;
		uint64_t speed_msb:1;
		uint64_t reserved_9_11:3;
		uint64_t rx_idle:1;
		uint64_t tx_idle:1;
		uint64_t reserved_14_15:2;
		uint64_t pknd:6;
		uint64_t reserved_22_63:42;
#endif
	} s;
	struct cvmx_gmxx_prtx_cfg_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t slottime:1;
		uint64_t duplex:1;
		uint64_t speed:1;
		uint64_t en:1;
#else
		uint64_t en:1;
		uint64_t speed:1;
		uint64_t duplex:1;
		uint64_t slottime:1;
		uint64_t reserved_4_63:60;
#endif
	} cn30xx;
	struct cvmx_gmxx_prtx_cfg_cn30xx cn31xx;
	struct cvmx_gmxx_prtx_cfg_cn30xx cn38xx;
	struct cvmx_gmxx_prtx_cfg_cn30xx cn38xxp2;
	struct cvmx_gmxx_prtx_cfg_cn30xx cn50xx;
	struct cvmx_gmxx_prtx_cfg_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t tx_idle:1;
		uint64_t rx_idle:1;
		uint64_t reserved_9_11:3;
		uint64_t speed_msb:1;
		uint64_t reserved_4_7:4;
		uint64_t slottime:1;
		uint64_t duplex:1;
		uint64_t speed:1;
		uint64_t en:1;
#else
		uint64_t en:1;
		uint64_t speed:1;
		uint64_t duplex:1;
		uint64_t slottime:1;
		uint64_t reserved_4_7:4;
		uint64_t speed_msb:1;
		uint64_t reserved_9_11:3;
		uint64_t rx_idle:1;
		uint64_t tx_idle:1;
		uint64_t reserved_14_63:50;
#endif
	} cn52xx;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn52xxp1;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn56xx;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn56xxp1;
	struct cvmx_gmxx_prtx_cfg_cn30xx cn58xx;
	struct cvmx_gmxx_prtx_cfg_cn30xx cn58xxp1;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn61xx;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn63xx;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn63xxp1;
	struct cvmx_gmxx_prtx_cfg_cn52xx cn66xx;
	struct cvmx_gmxx_prtx_cfg_s cn68xx;
	struct cvmx_gmxx_prtx_cfg_s cn68xxp1;
	struct cvmx_gmxx_prtx_cfg_cn52xx cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam0 {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t adr:64;
#else
		uint64_t adr:64;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam0_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam0_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam0_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam0_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam0_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam0_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam0_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam0_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam1 {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t adr:64;
#else
		uint64_t adr:64;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam1_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam1_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam1_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam1_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam1_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam1_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam1_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam1_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam2 {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t adr:64;
#else
		uint64_t adr:64;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam2_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam2_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam2_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam2_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam2_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam2_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam2_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam2_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam3 {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t adr:64;
#else
		uint64_t adr:64;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam3_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam3_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam3_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam3_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam3_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam3_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam3_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam3_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam4 {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam4_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t adr:64;
#else
		uint64_t adr:64;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam4_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam4_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam4_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam4_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam4_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam4_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam4_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam4_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam5 {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam5_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t adr:64;
#else
		uint64_t adr:64;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam5_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam5_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam5_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam5_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam5_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam5_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam5_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam5_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam_all_en {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam_all_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t en:32;
#else
		uint64_t en:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam_all_en_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam_all_en_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam_all_en_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam_all_en_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_cam_en {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_cam_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t en:8;
#else
		uint64_t en:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn30xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn31xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn38xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn50xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn52xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn56xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn58xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn61xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn63xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn66xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn68xx;
	struct cvmx_gmxx_rxx_adr_cam_en_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_cam_en_s cnf71xx;
};

union cvmx_gmxx_rxx_adr_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rxx_adr_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t cam_mode:1;
		uint64_t mcst:2;
		uint64_t bcst:1;
#else
		uint64_t bcst:1;
		uint64_t mcst:2;
		uint64_t cam_mode:1;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_rxx_adr_ctl_s cn30xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn31xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn38xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn38xxp2;
	struct cvmx_gmxx_rxx_adr_ctl_s cn50xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn52xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn52xxp1;
	struct cvmx_gmxx_rxx_adr_ctl_s cn56xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn56xxp1;
	struct cvmx_gmxx_rxx_adr_ctl_s cn58xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn58xxp1;
	struct cvmx_gmxx_rxx_adr_ctl_s cn61xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn63xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn63xxp1;
	struct cvmx_gmxx_rxx_adr_ctl_s cn66xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn68xx;
	struct cvmx_gmxx_rxx_adr_ctl_s cn68xxp1;
	struct cvmx_gmxx_rxx_adr_ctl_s cnf71xx;
};

union cvmx_gmxx_rxx_decision {
	uint64_t u64;
	struct cvmx_gmxx_rxx_decision_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t cnt:5;
#else
		uint64_t cnt:5;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_gmxx_rxx_decision_s cn30xx;
	struct cvmx_gmxx_rxx_decision_s cn31xx;
	struct cvmx_gmxx_rxx_decision_s cn38xx;
	struct cvmx_gmxx_rxx_decision_s cn38xxp2;
	struct cvmx_gmxx_rxx_decision_s cn50xx;
	struct cvmx_gmxx_rxx_decision_s cn52xx;
	struct cvmx_gmxx_rxx_decision_s cn52xxp1;
	struct cvmx_gmxx_rxx_decision_s cn56xx;
	struct cvmx_gmxx_rxx_decision_s cn56xxp1;
	struct cvmx_gmxx_rxx_decision_s cn58xx;
	struct cvmx_gmxx_rxx_decision_s cn58xxp1;
	struct cvmx_gmxx_rxx_decision_s cn61xx;
	struct cvmx_gmxx_rxx_decision_s cn63xx;
	struct cvmx_gmxx_rxx_decision_s cn63xxp1;
	struct cvmx_gmxx_rxx_decision_s cn66xx;
	struct cvmx_gmxx_rxx_decision_s cn68xx;
	struct cvmx_gmxx_rxx_decision_s cn68xxp1;
	struct cvmx_gmxx_rxx_decision_s cnf71xx;
};

union cvmx_gmxx_rxx_frm_chk {
	uint64_t u64;
	struct cvmx_gmxx_rxx_frm_chk_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_gmxx_rxx_frm_chk_s cn30xx;
	struct cvmx_gmxx_rxx_frm_chk_s cn31xx;
	struct cvmx_gmxx_rxx_frm_chk_s cn38xx;
	struct cvmx_gmxx_rxx_frm_chk_s cn38xxp2;
	struct cvmx_gmxx_rxx_frm_chk_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_6_6:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t reserved_6_6:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t reserved_10_63:54;
#endif
	} cn50xx;
	struct cvmx_gmxx_rxx_frm_chk_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_63:55;
#endif
	} cn52xx;
	struct cvmx_gmxx_rxx_frm_chk_cn52xx cn52xxp1;
	struct cvmx_gmxx_rxx_frm_chk_cn52xx cn56xx;
	struct cvmx_gmxx_rxx_frm_chk_cn52xx cn56xxp1;
	struct cvmx_gmxx_rxx_frm_chk_s cn58xx;
	struct cvmx_gmxx_rxx_frm_chk_s cn58xxp1;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_63:55;
#endif
	} cn61xx;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx cn63xx;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx cn63xxp1;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx cn66xx;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx cn68xx;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx cn68xxp1;
	struct cvmx_gmxx_rxx_frm_chk_cn61xx cnf71xx;
};

union cvmx_gmxx_rxx_frm_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rxx_frm_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_13_63:51;
		uint64_t ptp_mode:1;
		uint64_t reserved_11_11:1;
		uint64_t null_dis:1;
		uint64_t pre_align:1;
		uint64_t pad_len:1;
		uint64_t vlan_len:1;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t vlan_len:1;
		uint64_t pad_len:1;
		uint64_t pre_align:1;
		uint64_t null_dis:1;
		uint64_t reserved_11_11:1;
		uint64_t ptp_mode:1;
		uint64_t reserved_13_63:51;
#endif
	} s;
	struct cvmx_gmxx_rxx_frm_ctl_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t pad_len:1;
		uint64_t vlan_len:1;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t vlan_len:1;
		uint64_t pad_len:1;
		uint64_t reserved_9_63:55;
#endif
	} cn30xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t vlan_len:1;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t vlan_len:1;
		uint64_t reserved_8_63:56;
#endif
	} cn31xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn30xx cn38xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn31xx cn38xxp2;
	struct cvmx_gmxx_rxx_frm_ctl_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_11_63:53;
		uint64_t null_dis:1;
		uint64_t pre_align:1;
		uint64_t reserved_7_8:2;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t reserved_7_8:2;
		uint64_t pre_align:1;
		uint64_t null_dis:1;
		uint64_t reserved_11_63:53;
#endif
	} cn50xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn50xx cn52xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn50xx cn52xxp1;
	struct cvmx_gmxx_rxx_frm_ctl_cn50xx cn56xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t pre_align:1;
		uint64_t reserved_7_8:2;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t reserved_7_8:2;
		uint64_t pre_align:1;
		uint64_t reserved_10_63:54;
#endif
	} cn56xxp1;
	struct cvmx_gmxx_rxx_frm_ctl_cn58xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_11_63:53;
		uint64_t null_dis:1;
		uint64_t pre_align:1;
		uint64_t pad_len:1;
		uint64_t vlan_len:1;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t vlan_len:1;
		uint64_t pad_len:1;
		uint64_t pre_align:1;
		uint64_t null_dis:1;
		uint64_t reserved_11_63:53;
#endif
	} cn58xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn30xx cn58xxp1;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_13_63:51;
		uint64_t ptp_mode:1;
		uint64_t reserved_11_11:1;
		uint64_t null_dis:1;
		uint64_t pre_align:1;
		uint64_t reserved_7_8:2;
		uint64_t pre_free:1;
		uint64_t ctl_smac:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_drp:1;
		uint64_t pre_strp:1;
		uint64_t pre_chk:1;
#else
		uint64_t pre_chk:1;
		uint64_t pre_strp:1;
		uint64_t ctl_drp:1;
		uint64_t ctl_bck:1;
		uint64_t ctl_mcst:1;
		uint64_t ctl_smac:1;
		uint64_t pre_free:1;
		uint64_t reserved_7_8:2;
		uint64_t pre_align:1;
		uint64_t null_dis:1;
		uint64_t reserved_11_11:1;
		uint64_t ptp_mode:1;
		uint64_t reserved_13_63:51;
#endif
	} cn61xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx cn63xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx cn63xxp1;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx cn66xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx cn68xx;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx cn68xxp1;
	struct cvmx_gmxx_rxx_frm_ctl_cn61xx cnf71xx;
};

union cvmx_gmxx_rxx_frm_max {
	uint64_t u64;
	struct cvmx_gmxx_rxx_frm_max_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t len:16;
#else
		uint64_t len:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_rxx_frm_max_s cn30xx;
	struct cvmx_gmxx_rxx_frm_max_s cn31xx;
	struct cvmx_gmxx_rxx_frm_max_s cn38xx;
	struct cvmx_gmxx_rxx_frm_max_s cn38xxp2;
	struct cvmx_gmxx_rxx_frm_max_s cn58xx;
	struct cvmx_gmxx_rxx_frm_max_s cn58xxp1;
};

union cvmx_gmxx_rxx_frm_min {
	uint64_t u64;
	struct cvmx_gmxx_rxx_frm_min_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t len:16;
#else
		uint64_t len:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_rxx_frm_min_s cn30xx;
	struct cvmx_gmxx_rxx_frm_min_s cn31xx;
	struct cvmx_gmxx_rxx_frm_min_s cn38xx;
	struct cvmx_gmxx_rxx_frm_min_s cn38xxp2;
	struct cvmx_gmxx_rxx_frm_min_s cn58xx;
	struct cvmx_gmxx_rxx_frm_min_s cn58xxp1;
};

union cvmx_gmxx_rxx_ifg {
	uint64_t u64;
	struct cvmx_gmxx_rxx_ifg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t ifg:4;
#else
		uint64_t ifg:4;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_rxx_ifg_s cn30xx;
	struct cvmx_gmxx_rxx_ifg_s cn31xx;
	struct cvmx_gmxx_rxx_ifg_s cn38xx;
	struct cvmx_gmxx_rxx_ifg_s cn38xxp2;
	struct cvmx_gmxx_rxx_ifg_s cn50xx;
	struct cvmx_gmxx_rxx_ifg_s cn52xx;
	struct cvmx_gmxx_rxx_ifg_s cn52xxp1;
	struct cvmx_gmxx_rxx_ifg_s cn56xx;
	struct cvmx_gmxx_rxx_ifg_s cn56xxp1;
	struct cvmx_gmxx_rxx_ifg_s cn58xx;
	struct cvmx_gmxx_rxx_ifg_s cn58xxp1;
	struct cvmx_gmxx_rxx_ifg_s cn61xx;
	struct cvmx_gmxx_rxx_ifg_s cn63xx;
	struct cvmx_gmxx_rxx_ifg_s cn63xxp1;
	struct cvmx_gmxx_rxx_ifg_s cn66xx;
	struct cvmx_gmxx_rxx_ifg_s cn68xx;
	struct cvmx_gmxx_rxx_ifg_s cn68xxp1;
	struct cvmx_gmxx_rxx_ifg_s cnf71xx;
};

union cvmx_gmxx_rxx_int_en {
	uint64_t u64;
	struct cvmx_gmxx_rxx_int_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t hg2cc:1;
		uint64_t hg2fld:1;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t hg2fld:1;
		uint64_t hg2cc:1;
		uint64_t reserved_29_63:35;
#endif
	} s;
	struct cvmx_gmxx_rxx_int_en_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t reserved_19_63:45;
#endif
	} cn30xx;
	struct cvmx_gmxx_rxx_int_en_cn30xx cn31xx;
	struct cvmx_gmxx_rxx_int_en_cn30xx cn38xx;
	struct cvmx_gmxx_rxx_int_en_cn30xx cn38xxp2;
	struct cvmx_gmxx_rxx_int_en_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t pause_drp:1;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_6_6:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t reserved_6_6:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t pause_drp:1;
		uint64_t reserved_20_63:44;
#endif
	} cn50xx;
	struct cvmx_gmxx_rxx_int_en_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t hg2cc:1;
		uint64_t hg2fld:1;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t reserved_16_18:3;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t reserved_9_9:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_9:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t reserved_16_18:3;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t hg2fld:1;
		uint64_t hg2cc:1;
		uint64_t reserved_29_63:35;
#endif
	} cn52xx;
	struct cvmx_gmxx_rxx_int_en_cn52xx cn52xxp1;
	struct cvmx_gmxx_rxx_int_en_cn52xx cn56xx;
	struct cvmx_gmxx_rxx_int_en_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t reserved_16_18:3;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t reserved_9_9:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_9:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t reserved_16_18:3;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t reserved_27_63:37;
#endif
	} cn56xxp1;
	struct cvmx_gmxx_rxx_int_en_cn58xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t pause_drp:1;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t pause_drp:1;
		uint64_t reserved_20_63:44;
#endif
	} cn58xx;
	struct cvmx_gmxx_rxx_int_en_cn58xx cn58xxp1;
	struct cvmx_gmxx_rxx_int_en_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t hg2cc:1;
		uint64_t hg2fld:1;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t reserved_16_18:3;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t reserved_9_9:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_9:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t reserved_16_18:3;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t hg2fld:1;
		uint64_t hg2cc:1;
		uint64_t reserved_29_63:35;
#endif
	} cn61xx;
	struct cvmx_gmxx_rxx_int_en_cn61xx cn63xx;
	struct cvmx_gmxx_rxx_int_en_cn61xx cn63xxp1;
	struct cvmx_gmxx_rxx_int_en_cn61xx cn66xx;
	struct cvmx_gmxx_rxx_int_en_cn61xx cn68xx;
	struct cvmx_gmxx_rxx_int_en_cn61xx cn68xxp1;
	struct cvmx_gmxx_rxx_int_en_cn61xx cnf71xx;
};

union cvmx_gmxx_rxx_int_reg {
	uint64_t u64;
	struct cvmx_gmxx_rxx_int_reg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t hg2cc:1;
		uint64_t hg2fld:1;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t hg2fld:1;
		uint64_t hg2cc:1;
		uint64_t reserved_29_63:35;
#endif
	} s;
	struct cvmx_gmxx_rxx_int_reg_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t reserved_19_63:45;
#endif
	} cn30xx;
	struct cvmx_gmxx_rxx_int_reg_cn30xx cn31xx;
	struct cvmx_gmxx_rxx_int_reg_cn30xx cn38xx;
	struct cvmx_gmxx_rxx_int_reg_cn30xx cn38xxp2;
	struct cvmx_gmxx_rxx_int_reg_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t pause_drp:1;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_6_6:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t reserved_6_6:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t pause_drp:1;
		uint64_t reserved_20_63:44;
#endif
	} cn50xx;
	struct cvmx_gmxx_rxx_int_reg_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t hg2cc:1;
		uint64_t hg2fld:1;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t reserved_16_18:3;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t reserved_9_9:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_9:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t reserved_16_18:3;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t hg2fld:1;
		uint64_t hg2cc:1;
		uint64_t reserved_29_63:35;
#endif
	} cn52xx;
	struct cvmx_gmxx_rxx_int_reg_cn52xx cn52xxp1;
	struct cvmx_gmxx_rxx_int_reg_cn52xx cn56xx;
	struct cvmx_gmxx_rxx_int_reg_cn56xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t reserved_16_18:3;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t reserved_9_9:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t reserved_0_0:1;
#else
		uint64_t reserved_0_0:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_9:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t reserved_16_18:3;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t reserved_27_63:37;
#endif
	} cn56xxp1;
	struct cvmx_gmxx_rxx_int_reg_cn58xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t pause_drp:1;
		uint64_t phy_dupx:1;
		uint64_t phy_spd:1;
		uint64_t phy_link:1;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t niberr:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t lenerr:1;
		uint64_t alnerr:1;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t maxerr:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t maxerr:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t alnerr:1;
		uint64_t lenerr:1;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t niberr:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t phy_link:1;
		uint64_t phy_spd:1;
		uint64_t phy_dupx:1;
		uint64_t pause_drp:1;
		uint64_t reserved_20_63:44;
#endif
	} cn58xx;
	struct cvmx_gmxx_rxx_int_reg_cn58xx cn58xxp1;
	struct cvmx_gmxx_rxx_int_reg_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t hg2cc:1;
		uint64_t hg2fld:1;
		uint64_t undat:1;
		uint64_t uneop:1;
		uint64_t unsop:1;
		uint64_t bad_term:1;
		uint64_t bad_seq:1;
		uint64_t rem_fault:1;
		uint64_t loc_fault:1;
		uint64_t pause_drp:1;
		uint64_t reserved_16_18:3;
		uint64_t ifgerr:1;
		uint64_t coldet:1;
		uint64_t falerr:1;
		uint64_t rsverr:1;
		uint64_t pcterr:1;
		uint64_t ovrerr:1;
		uint64_t reserved_9_9:1;
		uint64_t skperr:1;
		uint64_t rcverr:1;
		uint64_t reserved_5_6:2;
		uint64_t fcserr:1;
		uint64_t jabber:1;
		uint64_t reserved_2_2:1;
		uint64_t carext:1;
		uint64_t minerr:1;
#else
		uint64_t minerr:1;
		uint64_t carext:1;
		uint64_t reserved_2_2:1;
		uint64_t jabber:1;
		uint64_t fcserr:1;
		uint64_t reserved_5_6:2;
		uint64_t rcverr:1;
		uint64_t skperr:1;
		uint64_t reserved_9_9:1;
		uint64_t ovrerr:1;
		uint64_t pcterr:1;
		uint64_t rsverr:1;
		uint64_t falerr:1;
		uint64_t coldet:1;
		uint64_t ifgerr:1;
		uint64_t reserved_16_18:3;
		uint64_t pause_drp:1;
		uint64_t loc_fault:1;
		uint64_t rem_fault:1;
		uint64_t bad_seq:1;
		uint64_t bad_term:1;
		uint64_t unsop:1;
		uint64_t uneop:1;
		uint64_t undat:1;
		uint64_t hg2fld:1;
		uint64_t hg2cc:1;
		uint64_t reserved_29_63:35;
#endif
	} cn61xx;
	struct cvmx_gmxx_rxx_int_reg_cn61xx cn63xx;
	struct cvmx_gmxx_rxx_int_reg_cn61xx cn63xxp1;
	struct cvmx_gmxx_rxx_int_reg_cn61xx cn66xx;
	struct cvmx_gmxx_rxx_int_reg_cn61xx cn68xx;
	struct cvmx_gmxx_rxx_int_reg_cn61xx cn68xxp1;
	struct cvmx_gmxx_rxx_int_reg_cn61xx cnf71xx;
};

union cvmx_gmxx_rxx_jabber {
	uint64_t u64;
	struct cvmx_gmxx_rxx_jabber_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t cnt:16;
#else
		uint64_t cnt:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_rxx_jabber_s cn30xx;
	struct cvmx_gmxx_rxx_jabber_s cn31xx;
	struct cvmx_gmxx_rxx_jabber_s cn38xx;
	struct cvmx_gmxx_rxx_jabber_s cn38xxp2;
	struct cvmx_gmxx_rxx_jabber_s cn50xx;
	struct cvmx_gmxx_rxx_jabber_s cn52xx;
	struct cvmx_gmxx_rxx_jabber_s cn52xxp1;
	struct cvmx_gmxx_rxx_jabber_s cn56xx;
	struct cvmx_gmxx_rxx_jabber_s cn56xxp1;
	struct cvmx_gmxx_rxx_jabber_s cn58xx;
	struct cvmx_gmxx_rxx_jabber_s cn58xxp1;
	struct cvmx_gmxx_rxx_jabber_s cn61xx;
	struct cvmx_gmxx_rxx_jabber_s cn63xx;
	struct cvmx_gmxx_rxx_jabber_s cn63xxp1;
	struct cvmx_gmxx_rxx_jabber_s cn66xx;
	struct cvmx_gmxx_rxx_jabber_s cn68xx;
	struct cvmx_gmxx_rxx_jabber_s cn68xxp1;
	struct cvmx_gmxx_rxx_jabber_s cnf71xx;
};

union cvmx_gmxx_rxx_pause_drop_time {
	uint64_t u64;
	struct cvmx_gmxx_rxx_pause_drop_time_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t status:16;
#else
		uint64_t status:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn50xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn52xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn52xxp1;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn56xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn56xxp1;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn58xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn58xxp1;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn61xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn63xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn63xxp1;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn66xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn68xx;
	struct cvmx_gmxx_rxx_pause_drop_time_s cn68xxp1;
	struct cvmx_gmxx_rxx_pause_drop_time_s cnf71xx;
};

union cvmx_gmxx_rxx_rx_inbnd {
	uint64_t u64;
	struct cvmx_gmxx_rxx_rx_inbnd_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t duplex:1;
		uint64_t speed:2;
		uint64_t status:1;
#else
		uint64_t status:1;
		uint64_t speed:2;
		uint64_t duplex:1;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn30xx;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn31xx;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn38xx;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn38xxp2;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn50xx;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn58xx;
	struct cvmx_gmxx_rxx_rx_inbnd_s cn58xxp1;
};

union cvmx_gmxx_rxx_stats_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t rd_clr:1;
#else
		uint64_t rd_clr:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_ctl_s cn30xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn31xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn38xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_ctl_s cn50xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn52xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_ctl_s cn56xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_ctl_s cn58xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_ctl_s cn61xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn63xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_ctl_s cn66xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn68xx;
	struct cvmx_gmxx_rxx_stats_ctl_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_ctl_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_octs {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_octs_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t cnt:48;
#else
		uint64_t cnt:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_octs_s cn30xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn31xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn38xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_octs_s cn50xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn52xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_octs_s cn56xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_octs_s cn58xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_octs_s cn61xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn63xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_octs_s cn66xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn68xx;
	struct cvmx_gmxx_rxx_stats_octs_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_octs_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_octs_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t cnt:48;
#else
		uint64_t cnt:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn30xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn31xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn38xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn50xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn52xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn56xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn58xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn61xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn63xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn66xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn68xx;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_octs_ctl_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_octs_dmac {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t cnt:48;
#else
		uint64_t cnt:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn30xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn31xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn38xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn50xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn52xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn56xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn58xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn61xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn63xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn66xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn68xx;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_octs_dmac_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_octs_drp {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_octs_drp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t cnt:48;
#else
		uint64_t cnt:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn30xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn31xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn38xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn50xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn52xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn56xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn58xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn61xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn63xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn66xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn68xx;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_octs_drp_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_pkts {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_pkts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_pkts_s cn30xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn31xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn38xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_pkts_s cn50xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn52xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_s cn56xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_s cn58xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_s cn61xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn63xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_s cn66xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn68xx;
	struct cvmx_gmxx_rxx_stats_pkts_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_pkts_bad {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn30xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn31xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn38xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn50xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn52xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn56xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn58xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn61xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn63xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn66xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn68xx;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_bad_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_pkts_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn30xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn31xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn38xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn50xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn52xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn56xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn58xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn61xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn63xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn66xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn68xx;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_ctl_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_pkts_dmac {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn30xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn31xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn38xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn50xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn52xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn56xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn58xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn61xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn63xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn66xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn68xx;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_dmac_s cnf71xx;
};

union cvmx_gmxx_rxx_stats_pkts_drp {
	uint64_t u64;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn30xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn31xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn38xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn38xxp2;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn50xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn52xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn52xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn56xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn56xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn58xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn58xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn61xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn63xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn63xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn66xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn68xx;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cn68xxp1;
	struct cvmx_gmxx_rxx_stats_pkts_drp_s cnf71xx;
};

union cvmx_gmxx_rxx_udd_skp {
	uint64_t u64;
	struct cvmx_gmxx_rxx_udd_skp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t fcssel:1;
		uint64_t reserved_7_7:1;
		uint64_t len:7;
#else
		uint64_t len:7;
		uint64_t reserved_7_7:1;
		uint64_t fcssel:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_gmxx_rxx_udd_skp_s cn30xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn31xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn38xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn38xxp2;
	struct cvmx_gmxx_rxx_udd_skp_s cn50xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn52xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn52xxp1;
	struct cvmx_gmxx_rxx_udd_skp_s cn56xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn56xxp1;
	struct cvmx_gmxx_rxx_udd_skp_s cn58xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn58xxp1;
	struct cvmx_gmxx_rxx_udd_skp_s cn61xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn63xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn63xxp1;
	struct cvmx_gmxx_rxx_udd_skp_s cn66xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn68xx;
	struct cvmx_gmxx_rxx_udd_skp_s cn68xxp1;
	struct cvmx_gmxx_rxx_udd_skp_s cnf71xx;
};

union cvmx_gmxx_rx_bp_dropx {
	uint64_t u64;
	struct cvmx_gmxx_rx_bp_dropx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t mark:6;
#else
		uint64_t mark:6;
		uint64_t reserved_6_63:58;
#endif
	} s;
	struct cvmx_gmxx_rx_bp_dropx_s cn30xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn31xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn38xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn38xxp2;
	struct cvmx_gmxx_rx_bp_dropx_s cn50xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn52xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn52xxp1;
	struct cvmx_gmxx_rx_bp_dropx_s cn56xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn56xxp1;
	struct cvmx_gmxx_rx_bp_dropx_s cn58xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn58xxp1;
	struct cvmx_gmxx_rx_bp_dropx_s cn61xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn63xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn63xxp1;
	struct cvmx_gmxx_rx_bp_dropx_s cn66xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn68xx;
	struct cvmx_gmxx_rx_bp_dropx_s cn68xxp1;
	struct cvmx_gmxx_rx_bp_dropx_s cnf71xx;
};

union cvmx_gmxx_rx_bp_offx {
	uint64_t u64;
	struct cvmx_gmxx_rx_bp_offx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t mark:6;
#else
		uint64_t mark:6;
		uint64_t reserved_6_63:58;
#endif
	} s;
	struct cvmx_gmxx_rx_bp_offx_s cn30xx;
	struct cvmx_gmxx_rx_bp_offx_s cn31xx;
	struct cvmx_gmxx_rx_bp_offx_s cn38xx;
	struct cvmx_gmxx_rx_bp_offx_s cn38xxp2;
	struct cvmx_gmxx_rx_bp_offx_s cn50xx;
	struct cvmx_gmxx_rx_bp_offx_s cn52xx;
	struct cvmx_gmxx_rx_bp_offx_s cn52xxp1;
	struct cvmx_gmxx_rx_bp_offx_s cn56xx;
	struct cvmx_gmxx_rx_bp_offx_s cn56xxp1;
	struct cvmx_gmxx_rx_bp_offx_s cn58xx;
	struct cvmx_gmxx_rx_bp_offx_s cn58xxp1;
	struct cvmx_gmxx_rx_bp_offx_s cn61xx;
	struct cvmx_gmxx_rx_bp_offx_s cn63xx;
	struct cvmx_gmxx_rx_bp_offx_s cn63xxp1;
	struct cvmx_gmxx_rx_bp_offx_s cn66xx;
	struct cvmx_gmxx_rx_bp_offx_s cn68xx;
	struct cvmx_gmxx_rx_bp_offx_s cn68xxp1;
	struct cvmx_gmxx_rx_bp_offx_s cnf71xx;
};

union cvmx_gmxx_rx_bp_onx {
	uint64_t u64;
	struct cvmx_gmxx_rx_bp_onx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_11_63:53;
		uint64_t mark:11;
#else
		uint64_t mark:11;
		uint64_t reserved_11_63:53;
#endif
	} s;
	struct cvmx_gmxx_rx_bp_onx_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t mark:9;
#else
		uint64_t mark:9;
		uint64_t reserved_9_63:55;
#endif
	} cn30xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn31xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn38xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn38xxp2;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn50xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn52xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn52xxp1;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn56xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn56xxp1;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn58xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn58xxp1;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn61xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn63xx;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn63xxp1;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cn66xx;
	struct cvmx_gmxx_rx_bp_onx_s cn68xx;
	struct cvmx_gmxx_rx_bp_onx_s cn68xxp1;
	struct cvmx_gmxx_rx_bp_onx_cn30xx cnf71xx;
};

union cvmx_gmxx_rx_hg2_status {
	uint64_t u64;
	struct cvmx_gmxx_rx_hg2_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t phtim2go:16;
		uint64_t xof:16;
		uint64_t lgtim2go:16;
#else
		uint64_t lgtim2go:16;
		uint64_t xof:16;
		uint64_t phtim2go:16;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_rx_hg2_status_s cn52xx;
	struct cvmx_gmxx_rx_hg2_status_s cn52xxp1;
	struct cvmx_gmxx_rx_hg2_status_s cn56xx;
	struct cvmx_gmxx_rx_hg2_status_s cn61xx;
	struct cvmx_gmxx_rx_hg2_status_s cn63xx;
	struct cvmx_gmxx_rx_hg2_status_s cn63xxp1;
	struct cvmx_gmxx_rx_hg2_status_s cn66xx;
	struct cvmx_gmxx_rx_hg2_status_s cn68xx;
	struct cvmx_gmxx_rx_hg2_status_s cn68xxp1;
	struct cvmx_gmxx_rx_hg2_status_s cnf71xx;
};

union cvmx_gmxx_rx_pass_en {
	uint64_t u64;
	struct cvmx_gmxx_rx_pass_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t en:16;
#else
		uint64_t en:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_rx_pass_en_s cn38xx;
	struct cvmx_gmxx_rx_pass_en_s cn38xxp2;
	struct cvmx_gmxx_rx_pass_en_s cn58xx;
	struct cvmx_gmxx_rx_pass_en_s cn58xxp1;
};

union cvmx_gmxx_rx_pass_mapx {
	uint64_t u64;
	struct cvmx_gmxx_rx_pass_mapx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t dprt:4;
#else
		uint64_t dprt:4;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_rx_pass_mapx_s cn38xx;
	struct cvmx_gmxx_rx_pass_mapx_s cn38xxp2;
	struct cvmx_gmxx_rx_pass_mapx_s cn58xx;
	struct cvmx_gmxx_rx_pass_mapx_s cn58xxp1;
};

union cvmx_gmxx_rx_prt_info {
	uint64_t u64;
	struct cvmx_gmxx_rx_prt_info_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t drop:16;
		uint64_t commit:16;
#else
		uint64_t commit:16;
		uint64_t drop:16;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_rx_prt_info_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t drop:3;
		uint64_t reserved_3_15:13;
		uint64_t commit:3;
#else
		uint64_t commit:3;
		uint64_t reserved_3_15:13;
		uint64_t drop:3;
		uint64_t reserved_19_63:45;
#endif
	} cn30xx;
	struct cvmx_gmxx_rx_prt_info_cn30xx cn31xx;
	struct cvmx_gmxx_rx_prt_info_s cn38xx;
	struct cvmx_gmxx_rx_prt_info_cn30xx cn50xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t drop:4;
		uint64_t reserved_4_15:12;
		uint64_t commit:4;
#else
		uint64_t commit:4;
		uint64_t reserved_4_15:12;
		uint64_t drop:4;
		uint64_t reserved_20_63:44;
#endif
	} cn52xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn52xxp1;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn56xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn56xxp1;
	struct cvmx_gmxx_rx_prt_info_s cn58xx;
	struct cvmx_gmxx_rx_prt_info_s cn58xxp1;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn61xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn63xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn63xxp1;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn66xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn68xx;
	struct cvmx_gmxx_rx_prt_info_cn52xx cn68xxp1;
	struct cvmx_gmxx_rx_prt_info_cnf71xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_18_63:46;
		uint64_t drop:2;
		uint64_t reserved_2_15:14;
		uint64_t commit:2;
#else
		uint64_t commit:2;
		uint64_t reserved_2_15:14;
		uint64_t drop:2;
		uint64_t reserved_18_63:46;
#endif
	} cnf71xx;
};

union cvmx_gmxx_rx_prts {
	uint64_t u64;
	struct cvmx_gmxx_rx_prts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_3_63:61;
		uint64_t prts:3;
#else
		uint64_t prts:3;
		uint64_t reserved_3_63:61;
#endif
	} s;
	struct cvmx_gmxx_rx_prts_s cn30xx;
	struct cvmx_gmxx_rx_prts_s cn31xx;
	struct cvmx_gmxx_rx_prts_s cn38xx;
	struct cvmx_gmxx_rx_prts_s cn38xxp2;
	struct cvmx_gmxx_rx_prts_s cn50xx;
	struct cvmx_gmxx_rx_prts_s cn52xx;
	struct cvmx_gmxx_rx_prts_s cn52xxp1;
	struct cvmx_gmxx_rx_prts_s cn56xx;
	struct cvmx_gmxx_rx_prts_s cn56xxp1;
	struct cvmx_gmxx_rx_prts_s cn58xx;
	struct cvmx_gmxx_rx_prts_s cn58xxp1;
	struct cvmx_gmxx_rx_prts_s cn61xx;
	struct cvmx_gmxx_rx_prts_s cn63xx;
	struct cvmx_gmxx_rx_prts_s cn63xxp1;
	struct cvmx_gmxx_rx_prts_s cn66xx;
	struct cvmx_gmxx_rx_prts_s cn68xx;
	struct cvmx_gmxx_rx_prts_s cn68xxp1;
	struct cvmx_gmxx_rx_prts_s cnf71xx;
};

union cvmx_gmxx_rx_tx_status {
	uint64_t u64;
	struct cvmx_gmxx_rx_tx_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_7_63:57;
		uint64_t tx:3;
		uint64_t reserved_3_3:1;
		uint64_t rx:3;
#else
		uint64_t rx:3;
		uint64_t reserved_3_3:1;
		uint64_t tx:3;
		uint64_t reserved_7_63:57;
#endif
	} s;
	struct cvmx_gmxx_rx_tx_status_s cn30xx;
	struct cvmx_gmxx_rx_tx_status_s cn31xx;
	struct cvmx_gmxx_rx_tx_status_s cn50xx;
};

union cvmx_gmxx_rx_xaui_bad_col {
	uint64_t u64;
	struct cvmx_gmxx_rx_xaui_bad_col_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_40_63:24;
		uint64_t val:1;
		uint64_t state:3;
		uint64_t lane_rxc:4;
		uint64_t lane_rxd:32;
#else
		uint64_t lane_rxd:32;
		uint64_t lane_rxc:4;
		uint64_t state:3;
		uint64_t val:1;
		uint64_t reserved_40_63:24;
#endif
	} s;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn52xx;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn52xxp1;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn56xx;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn56xxp1;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn61xx;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn63xx;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn63xxp1;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn66xx;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn68xx;
	struct cvmx_gmxx_rx_xaui_bad_col_s cn68xxp1;
	struct cvmx_gmxx_rx_xaui_bad_col_s cnf71xx;
};

union cvmx_gmxx_rx_xaui_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rx_xaui_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t status:2;
#else
		uint64_t status:2;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_gmxx_rx_xaui_ctl_s cn52xx;
	struct cvmx_gmxx_rx_xaui_ctl_s cn52xxp1;
	struct cvmx_gmxx_rx_xaui_ctl_s cn56xx;
	struct cvmx_gmxx_rx_xaui_ctl_s cn56xxp1;
	struct cvmx_gmxx_rx_xaui_ctl_s cn61xx;
	struct cvmx_gmxx_rx_xaui_ctl_s cn63xx;
	struct cvmx_gmxx_rx_xaui_ctl_s cn63xxp1;
	struct cvmx_gmxx_rx_xaui_ctl_s cn66xx;
	struct cvmx_gmxx_rx_xaui_ctl_s cn68xx;
	struct cvmx_gmxx_rx_xaui_ctl_s cn68xxp1;
	struct cvmx_gmxx_rx_xaui_ctl_s cnf71xx;
};

union cvmx_gmxx_rxaui_ctl {
	uint64_t u64;
	struct cvmx_gmxx_rxaui_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t disparity:1;
#else
		uint64_t disparity:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_rxaui_ctl_s cn68xx;
	struct cvmx_gmxx_rxaui_ctl_s cn68xxp1;
};

union cvmx_gmxx_smacx {
	uint64_t u64;
	struct cvmx_gmxx_smacx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t smac:48;
#else
		uint64_t smac:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_smacx_s cn30xx;
	struct cvmx_gmxx_smacx_s cn31xx;
	struct cvmx_gmxx_smacx_s cn38xx;
	struct cvmx_gmxx_smacx_s cn38xxp2;
	struct cvmx_gmxx_smacx_s cn50xx;
	struct cvmx_gmxx_smacx_s cn52xx;
	struct cvmx_gmxx_smacx_s cn52xxp1;
	struct cvmx_gmxx_smacx_s cn56xx;
	struct cvmx_gmxx_smacx_s cn56xxp1;
	struct cvmx_gmxx_smacx_s cn58xx;
	struct cvmx_gmxx_smacx_s cn58xxp1;
	struct cvmx_gmxx_smacx_s cn61xx;
	struct cvmx_gmxx_smacx_s cn63xx;
	struct cvmx_gmxx_smacx_s cn63xxp1;
	struct cvmx_gmxx_smacx_s cn66xx;
	struct cvmx_gmxx_smacx_s cn68xx;
	struct cvmx_gmxx_smacx_s cn68xxp1;
	struct cvmx_gmxx_smacx_s cnf71xx;
};

union cvmx_gmxx_soft_bist {
	uint64_t u64;
	struct cvmx_gmxx_soft_bist_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t start_bist:1;
		uint64_t clear_bist:1;
#else
		uint64_t clear_bist:1;
		uint64_t start_bist:1;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_gmxx_soft_bist_s cn63xx;
	struct cvmx_gmxx_soft_bist_s cn63xxp1;
	struct cvmx_gmxx_soft_bist_s cn66xx;
	struct cvmx_gmxx_soft_bist_s cn68xx;
	struct cvmx_gmxx_soft_bist_s cn68xxp1;
};

union cvmx_gmxx_stat_bp {
	uint64_t u64;
	struct cvmx_gmxx_stat_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_17_63:47;
		uint64_t bp:1;
		uint64_t cnt:16;
#else
		uint64_t cnt:16;
		uint64_t bp:1;
		uint64_t reserved_17_63:47;
#endif
	} s;
	struct cvmx_gmxx_stat_bp_s cn30xx;
	struct cvmx_gmxx_stat_bp_s cn31xx;
	struct cvmx_gmxx_stat_bp_s cn38xx;
	struct cvmx_gmxx_stat_bp_s cn38xxp2;
	struct cvmx_gmxx_stat_bp_s cn50xx;
	struct cvmx_gmxx_stat_bp_s cn52xx;
	struct cvmx_gmxx_stat_bp_s cn52xxp1;
	struct cvmx_gmxx_stat_bp_s cn56xx;
	struct cvmx_gmxx_stat_bp_s cn56xxp1;
	struct cvmx_gmxx_stat_bp_s cn58xx;
	struct cvmx_gmxx_stat_bp_s cn58xxp1;
	struct cvmx_gmxx_stat_bp_s cn61xx;
	struct cvmx_gmxx_stat_bp_s cn63xx;
	struct cvmx_gmxx_stat_bp_s cn63xxp1;
	struct cvmx_gmxx_stat_bp_s cn66xx;
	struct cvmx_gmxx_stat_bp_s cn68xx;
	struct cvmx_gmxx_stat_bp_s cn68xxp1;
	struct cvmx_gmxx_stat_bp_s cnf71xx;
};

union cvmx_gmxx_tb_reg {
	uint64_t u64;
	struct cvmx_gmxx_tb_reg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t wr_magic:1;
#else
		uint64_t wr_magic:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_tb_reg_s cn61xx;
	struct cvmx_gmxx_tb_reg_s cn66xx;
	struct cvmx_gmxx_tb_reg_s cn68xx;
	struct cvmx_gmxx_tb_reg_s cnf71xx;
};

union cvmx_gmxx_txx_append {
	uint64_t u64;
	struct cvmx_gmxx_txx_append_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t force_fcs:1;
		uint64_t fcs:1;
		uint64_t pad:1;
		uint64_t preamble:1;
#else
		uint64_t preamble:1;
		uint64_t pad:1;
		uint64_t fcs:1;
		uint64_t force_fcs:1;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_txx_append_s cn30xx;
	struct cvmx_gmxx_txx_append_s cn31xx;
	struct cvmx_gmxx_txx_append_s cn38xx;
	struct cvmx_gmxx_txx_append_s cn38xxp2;
	struct cvmx_gmxx_txx_append_s cn50xx;
	struct cvmx_gmxx_txx_append_s cn52xx;
	struct cvmx_gmxx_txx_append_s cn52xxp1;
	struct cvmx_gmxx_txx_append_s cn56xx;
	struct cvmx_gmxx_txx_append_s cn56xxp1;
	struct cvmx_gmxx_txx_append_s cn58xx;
	struct cvmx_gmxx_txx_append_s cn58xxp1;
	struct cvmx_gmxx_txx_append_s cn61xx;
	struct cvmx_gmxx_txx_append_s cn63xx;
	struct cvmx_gmxx_txx_append_s cn63xxp1;
	struct cvmx_gmxx_txx_append_s cn66xx;
	struct cvmx_gmxx_txx_append_s cn68xx;
	struct cvmx_gmxx_txx_append_s cn68xxp1;
	struct cvmx_gmxx_txx_append_s cnf71xx;
};

union cvmx_gmxx_txx_burst {
	uint64_t u64;
	struct cvmx_gmxx_txx_burst_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t burst:16;
#else
		uint64_t burst:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_txx_burst_s cn30xx;
	struct cvmx_gmxx_txx_burst_s cn31xx;
	struct cvmx_gmxx_txx_burst_s cn38xx;
	struct cvmx_gmxx_txx_burst_s cn38xxp2;
	struct cvmx_gmxx_txx_burst_s cn50xx;
	struct cvmx_gmxx_txx_burst_s cn52xx;
	struct cvmx_gmxx_txx_burst_s cn52xxp1;
	struct cvmx_gmxx_txx_burst_s cn56xx;
	struct cvmx_gmxx_txx_burst_s cn56xxp1;
	struct cvmx_gmxx_txx_burst_s cn58xx;
	struct cvmx_gmxx_txx_burst_s cn58xxp1;
	struct cvmx_gmxx_txx_burst_s cn61xx;
	struct cvmx_gmxx_txx_burst_s cn63xx;
	struct cvmx_gmxx_txx_burst_s cn63xxp1;
	struct cvmx_gmxx_txx_burst_s cn66xx;
	struct cvmx_gmxx_txx_burst_s cn68xx;
	struct cvmx_gmxx_txx_burst_s cn68xxp1;
	struct cvmx_gmxx_txx_burst_s cnf71xx;
};

union cvmx_gmxx_txx_cbfc_xoff {
	uint64_t u64;
	struct cvmx_gmxx_txx_cbfc_xoff_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t xoff:16;
#else
		uint64_t xoff:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn52xx;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn56xx;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn61xx;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn63xx;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn63xxp1;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn66xx;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn68xx;
	struct cvmx_gmxx_txx_cbfc_xoff_s cn68xxp1;
	struct cvmx_gmxx_txx_cbfc_xoff_s cnf71xx;
};

union cvmx_gmxx_txx_cbfc_xon {
	uint64_t u64;
	struct cvmx_gmxx_txx_cbfc_xon_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t xon:16;
#else
		uint64_t xon:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_txx_cbfc_xon_s cn52xx;
	struct cvmx_gmxx_txx_cbfc_xon_s cn56xx;
	struct cvmx_gmxx_txx_cbfc_xon_s cn61xx;
	struct cvmx_gmxx_txx_cbfc_xon_s cn63xx;
	struct cvmx_gmxx_txx_cbfc_xon_s cn63xxp1;
	struct cvmx_gmxx_txx_cbfc_xon_s cn66xx;
	struct cvmx_gmxx_txx_cbfc_xon_s cn68xx;
	struct cvmx_gmxx_txx_cbfc_xon_s cn68xxp1;
	struct cvmx_gmxx_txx_cbfc_xon_s cnf71xx;
};

union cvmx_gmxx_txx_clk {
	uint64_t u64;
	struct cvmx_gmxx_txx_clk_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t clk_cnt:6;
#else
		uint64_t clk_cnt:6;
		uint64_t reserved_6_63:58;
#endif
	} s;
	struct cvmx_gmxx_txx_clk_s cn30xx;
	struct cvmx_gmxx_txx_clk_s cn31xx;
	struct cvmx_gmxx_txx_clk_s cn38xx;
	struct cvmx_gmxx_txx_clk_s cn38xxp2;
	struct cvmx_gmxx_txx_clk_s cn50xx;
	struct cvmx_gmxx_txx_clk_s cn58xx;
	struct cvmx_gmxx_txx_clk_s cn58xxp1;
};

union cvmx_gmxx_txx_ctl {
	uint64_t u64;
	struct cvmx_gmxx_txx_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t xsdef_en:1;
		uint64_t xscol_en:1;
#else
		uint64_t xscol_en:1;
		uint64_t xsdef_en:1;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_gmxx_txx_ctl_s cn30xx;
	struct cvmx_gmxx_txx_ctl_s cn31xx;
	struct cvmx_gmxx_txx_ctl_s cn38xx;
	struct cvmx_gmxx_txx_ctl_s cn38xxp2;
	struct cvmx_gmxx_txx_ctl_s cn50xx;
	struct cvmx_gmxx_txx_ctl_s cn52xx;
	struct cvmx_gmxx_txx_ctl_s cn52xxp1;
	struct cvmx_gmxx_txx_ctl_s cn56xx;
	struct cvmx_gmxx_txx_ctl_s cn56xxp1;
	struct cvmx_gmxx_txx_ctl_s cn58xx;
	struct cvmx_gmxx_txx_ctl_s cn58xxp1;
	struct cvmx_gmxx_txx_ctl_s cn61xx;
	struct cvmx_gmxx_txx_ctl_s cn63xx;
	struct cvmx_gmxx_txx_ctl_s cn63xxp1;
	struct cvmx_gmxx_txx_ctl_s cn66xx;
	struct cvmx_gmxx_txx_ctl_s cn68xx;
	struct cvmx_gmxx_txx_ctl_s cn68xxp1;
	struct cvmx_gmxx_txx_ctl_s cnf71xx;
};

union cvmx_gmxx_txx_min_pkt {
	uint64_t u64;
	struct cvmx_gmxx_txx_min_pkt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t min_size:8;
#else
		uint64_t min_size:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_gmxx_txx_min_pkt_s cn30xx;
	struct cvmx_gmxx_txx_min_pkt_s cn31xx;
	struct cvmx_gmxx_txx_min_pkt_s cn38xx;
	struct cvmx_gmxx_txx_min_pkt_s cn38xxp2;
	struct cvmx_gmxx_txx_min_pkt_s cn50xx;
	struct cvmx_gmxx_txx_min_pkt_s cn52xx;
	struct cvmx_gmxx_txx_min_pkt_s cn52xxp1;
	struct cvmx_gmxx_txx_min_pkt_s cn56xx;
	struct cvmx_gmxx_txx_min_pkt_s cn56xxp1;
	struct cvmx_gmxx_txx_min_pkt_s cn58xx;
	struct cvmx_gmxx_txx_min_pkt_s cn58xxp1;
	struct cvmx_gmxx_txx_min_pkt_s cn61xx;
	struct cvmx_gmxx_txx_min_pkt_s cn63xx;
	struct cvmx_gmxx_txx_min_pkt_s cn63xxp1;
	struct cvmx_gmxx_txx_min_pkt_s cn66xx;
	struct cvmx_gmxx_txx_min_pkt_s cn68xx;
	struct cvmx_gmxx_txx_min_pkt_s cn68xxp1;
	struct cvmx_gmxx_txx_min_pkt_s cnf71xx;
};

union cvmx_gmxx_txx_pause_pkt_interval {
	uint64_t u64;
	struct cvmx_gmxx_txx_pause_pkt_interval_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t interval:16;
#else
		uint64_t interval:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn30xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn31xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn38xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn38xxp2;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn50xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn52xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn52xxp1;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn56xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn56xxp1;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn58xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn58xxp1;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn61xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn63xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn63xxp1;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn66xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn68xx;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cn68xxp1;
	struct cvmx_gmxx_txx_pause_pkt_interval_s cnf71xx;
};

union cvmx_gmxx_txx_pause_pkt_time {
	uint64_t u64;
	struct cvmx_gmxx_txx_pause_pkt_time_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t time:16;
#else
		uint64_t time:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn30xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn31xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn38xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn38xxp2;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn50xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn52xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn52xxp1;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn56xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn56xxp1;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn58xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn58xxp1;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn61xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn63xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn63xxp1;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn66xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn68xx;
	struct cvmx_gmxx_txx_pause_pkt_time_s cn68xxp1;
	struct cvmx_gmxx_txx_pause_pkt_time_s cnf71xx;
};

union cvmx_gmxx_txx_pause_togo {
	uint64_t u64;
	struct cvmx_gmxx_txx_pause_togo_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t msg_time:16;
		uint64_t time:16;
#else
		uint64_t time:16;
		uint64_t msg_time:16;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_txx_pause_togo_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t time:16;
#else
		uint64_t time:16;
		uint64_t reserved_16_63:48;
#endif
	} cn30xx;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn31xx;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn38xx;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn38xxp2;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn50xx;
	struct cvmx_gmxx_txx_pause_togo_s cn52xx;
	struct cvmx_gmxx_txx_pause_togo_s cn52xxp1;
	struct cvmx_gmxx_txx_pause_togo_s cn56xx;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn56xxp1;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn58xx;
	struct cvmx_gmxx_txx_pause_togo_cn30xx cn58xxp1;
	struct cvmx_gmxx_txx_pause_togo_s cn61xx;
	struct cvmx_gmxx_txx_pause_togo_s cn63xx;
	struct cvmx_gmxx_txx_pause_togo_s cn63xxp1;
	struct cvmx_gmxx_txx_pause_togo_s cn66xx;
	struct cvmx_gmxx_txx_pause_togo_s cn68xx;
	struct cvmx_gmxx_txx_pause_togo_s cn68xxp1;
	struct cvmx_gmxx_txx_pause_togo_s cnf71xx;
};

union cvmx_gmxx_txx_pause_zero {
	uint64_t u64;
	struct cvmx_gmxx_txx_pause_zero_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t send:1;
#else
		uint64_t send:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_txx_pause_zero_s cn30xx;
	struct cvmx_gmxx_txx_pause_zero_s cn31xx;
	struct cvmx_gmxx_txx_pause_zero_s cn38xx;
	struct cvmx_gmxx_txx_pause_zero_s cn38xxp2;
	struct cvmx_gmxx_txx_pause_zero_s cn50xx;
	struct cvmx_gmxx_txx_pause_zero_s cn52xx;
	struct cvmx_gmxx_txx_pause_zero_s cn52xxp1;
	struct cvmx_gmxx_txx_pause_zero_s cn56xx;
	struct cvmx_gmxx_txx_pause_zero_s cn56xxp1;
	struct cvmx_gmxx_txx_pause_zero_s cn58xx;
	struct cvmx_gmxx_txx_pause_zero_s cn58xxp1;
	struct cvmx_gmxx_txx_pause_zero_s cn61xx;
	struct cvmx_gmxx_txx_pause_zero_s cn63xx;
	struct cvmx_gmxx_txx_pause_zero_s cn63xxp1;
	struct cvmx_gmxx_txx_pause_zero_s cn66xx;
	struct cvmx_gmxx_txx_pause_zero_s cn68xx;
	struct cvmx_gmxx_txx_pause_zero_s cn68xxp1;
	struct cvmx_gmxx_txx_pause_zero_s cnf71xx;
};

union cvmx_gmxx_txx_pipe {
	uint64_t u64;
	struct cvmx_gmxx_txx_pipe_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_33_63:31;
		uint64_t ign_bp:1;
		uint64_t reserved_21_31:11;
		uint64_t nump:5;
		uint64_t reserved_7_15:9;
		uint64_t base:7;
#else
		uint64_t base:7;
		uint64_t reserved_7_15:9;
		uint64_t nump:5;
		uint64_t reserved_21_31:11;
		uint64_t ign_bp:1;
		uint64_t reserved_33_63:31;
#endif
	} s;
	struct cvmx_gmxx_txx_pipe_s cn68xx;
	struct cvmx_gmxx_txx_pipe_s cn68xxp1;
};

union cvmx_gmxx_txx_sgmii_ctl {
	uint64_t u64;
	struct cvmx_gmxx_txx_sgmii_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t align:1;
#else
		uint64_t align:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn52xx;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn52xxp1;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn56xx;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn56xxp1;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn61xx;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn63xx;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn63xxp1;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn66xx;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn68xx;
	struct cvmx_gmxx_txx_sgmii_ctl_s cn68xxp1;
	struct cvmx_gmxx_txx_sgmii_ctl_s cnf71xx;
};

union cvmx_gmxx_txx_slot {
	uint64_t u64;
	struct cvmx_gmxx_txx_slot_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t slot:10;
#else
		uint64_t slot:10;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_gmxx_txx_slot_s cn30xx;
	struct cvmx_gmxx_txx_slot_s cn31xx;
	struct cvmx_gmxx_txx_slot_s cn38xx;
	struct cvmx_gmxx_txx_slot_s cn38xxp2;
	struct cvmx_gmxx_txx_slot_s cn50xx;
	struct cvmx_gmxx_txx_slot_s cn52xx;
	struct cvmx_gmxx_txx_slot_s cn52xxp1;
	struct cvmx_gmxx_txx_slot_s cn56xx;
	struct cvmx_gmxx_txx_slot_s cn56xxp1;
	struct cvmx_gmxx_txx_slot_s cn58xx;
	struct cvmx_gmxx_txx_slot_s cn58xxp1;
	struct cvmx_gmxx_txx_slot_s cn61xx;
	struct cvmx_gmxx_txx_slot_s cn63xx;
	struct cvmx_gmxx_txx_slot_s cn63xxp1;
	struct cvmx_gmxx_txx_slot_s cn66xx;
	struct cvmx_gmxx_txx_slot_s cn68xx;
	struct cvmx_gmxx_txx_slot_s cn68xxp1;
	struct cvmx_gmxx_txx_slot_s cnf71xx;
};

union cvmx_gmxx_txx_soft_pause {
	uint64_t u64;
	struct cvmx_gmxx_txx_soft_pause_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t time:16;
#else
		uint64_t time:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_txx_soft_pause_s cn30xx;
	struct cvmx_gmxx_txx_soft_pause_s cn31xx;
	struct cvmx_gmxx_txx_soft_pause_s cn38xx;
	struct cvmx_gmxx_txx_soft_pause_s cn38xxp2;
	struct cvmx_gmxx_txx_soft_pause_s cn50xx;
	struct cvmx_gmxx_txx_soft_pause_s cn52xx;
	struct cvmx_gmxx_txx_soft_pause_s cn52xxp1;
	struct cvmx_gmxx_txx_soft_pause_s cn56xx;
	struct cvmx_gmxx_txx_soft_pause_s cn56xxp1;
	struct cvmx_gmxx_txx_soft_pause_s cn58xx;
	struct cvmx_gmxx_txx_soft_pause_s cn58xxp1;
	struct cvmx_gmxx_txx_soft_pause_s cn61xx;
	struct cvmx_gmxx_txx_soft_pause_s cn63xx;
	struct cvmx_gmxx_txx_soft_pause_s cn63xxp1;
	struct cvmx_gmxx_txx_soft_pause_s cn66xx;
	struct cvmx_gmxx_txx_soft_pause_s cn68xx;
	struct cvmx_gmxx_txx_soft_pause_s cn68xxp1;
	struct cvmx_gmxx_txx_soft_pause_s cnf71xx;
};

union cvmx_gmxx_txx_stat0 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t xsdef:32;
		uint64_t xscol:32;
#else
		uint64_t xscol:32;
		uint64_t xsdef:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat0_s cn30xx;
	struct cvmx_gmxx_txx_stat0_s cn31xx;
	struct cvmx_gmxx_txx_stat0_s cn38xx;
	struct cvmx_gmxx_txx_stat0_s cn38xxp2;
	struct cvmx_gmxx_txx_stat0_s cn50xx;
	struct cvmx_gmxx_txx_stat0_s cn52xx;
	struct cvmx_gmxx_txx_stat0_s cn52xxp1;
	struct cvmx_gmxx_txx_stat0_s cn56xx;
	struct cvmx_gmxx_txx_stat0_s cn56xxp1;
	struct cvmx_gmxx_txx_stat0_s cn58xx;
	struct cvmx_gmxx_txx_stat0_s cn58xxp1;
	struct cvmx_gmxx_txx_stat0_s cn61xx;
	struct cvmx_gmxx_txx_stat0_s cn63xx;
	struct cvmx_gmxx_txx_stat0_s cn63xxp1;
	struct cvmx_gmxx_txx_stat0_s cn66xx;
	struct cvmx_gmxx_txx_stat0_s cn68xx;
	struct cvmx_gmxx_txx_stat0_s cn68xxp1;
	struct cvmx_gmxx_txx_stat0_s cnf71xx;
};

union cvmx_gmxx_txx_stat1 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t scol:32;
		uint64_t mcol:32;
#else
		uint64_t mcol:32;
		uint64_t scol:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat1_s cn30xx;
	struct cvmx_gmxx_txx_stat1_s cn31xx;
	struct cvmx_gmxx_txx_stat1_s cn38xx;
	struct cvmx_gmxx_txx_stat1_s cn38xxp2;
	struct cvmx_gmxx_txx_stat1_s cn50xx;
	struct cvmx_gmxx_txx_stat1_s cn52xx;
	struct cvmx_gmxx_txx_stat1_s cn52xxp1;
	struct cvmx_gmxx_txx_stat1_s cn56xx;
	struct cvmx_gmxx_txx_stat1_s cn56xxp1;
	struct cvmx_gmxx_txx_stat1_s cn58xx;
	struct cvmx_gmxx_txx_stat1_s cn58xxp1;
	struct cvmx_gmxx_txx_stat1_s cn61xx;
	struct cvmx_gmxx_txx_stat1_s cn63xx;
	struct cvmx_gmxx_txx_stat1_s cn63xxp1;
	struct cvmx_gmxx_txx_stat1_s cn66xx;
	struct cvmx_gmxx_txx_stat1_s cn68xx;
	struct cvmx_gmxx_txx_stat1_s cn68xxp1;
	struct cvmx_gmxx_txx_stat1_s cnf71xx;
};

union cvmx_gmxx_txx_stat2 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t octs:48;
#else
		uint64_t octs:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_txx_stat2_s cn30xx;
	struct cvmx_gmxx_txx_stat2_s cn31xx;
	struct cvmx_gmxx_txx_stat2_s cn38xx;
	struct cvmx_gmxx_txx_stat2_s cn38xxp2;
	struct cvmx_gmxx_txx_stat2_s cn50xx;
	struct cvmx_gmxx_txx_stat2_s cn52xx;
	struct cvmx_gmxx_txx_stat2_s cn52xxp1;
	struct cvmx_gmxx_txx_stat2_s cn56xx;
	struct cvmx_gmxx_txx_stat2_s cn56xxp1;
	struct cvmx_gmxx_txx_stat2_s cn58xx;
	struct cvmx_gmxx_txx_stat2_s cn58xxp1;
	struct cvmx_gmxx_txx_stat2_s cn61xx;
	struct cvmx_gmxx_txx_stat2_s cn63xx;
	struct cvmx_gmxx_txx_stat2_s cn63xxp1;
	struct cvmx_gmxx_txx_stat2_s cn66xx;
	struct cvmx_gmxx_txx_stat2_s cn68xx;
	struct cvmx_gmxx_txx_stat2_s cn68xxp1;
	struct cvmx_gmxx_txx_stat2_s cnf71xx;
};

union cvmx_gmxx_txx_stat3 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t pkts:32;
#else
		uint64_t pkts:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat3_s cn30xx;
	struct cvmx_gmxx_txx_stat3_s cn31xx;
	struct cvmx_gmxx_txx_stat3_s cn38xx;
	struct cvmx_gmxx_txx_stat3_s cn38xxp2;
	struct cvmx_gmxx_txx_stat3_s cn50xx;
	struct cvmx_gmxx_txx_stat3_s cn52xx;
	struct cvmx_gmxx_txx_stat3_s cn52xxp1;
	struct cvmx_gmxx_txx_stat3_s cn56xx;
	struct cvmx_gmxx_txx_stat3_s cn56xxp1;
	struct cvmx_gmxx_txx_stat3_s cn58xx;
	struct cvmx_gmxx_txx_stat3_s cn58xxp1;
	struct cvmx_gmxx_txx_stat3_s cn61xx;
	struct cvmx_gmxx_txx_stat3_s cn63xx;
	struct cvmx_gmxx_txx_stat3_s cn63xxp1;
	struct cvmx_gmxx_txx_stat3_s cn66xx;
	struct cvmx_gmxx_txx_stat3_s cn68xx;
	struct cvmx_gmxx_txx_stat3_s cn68xxp1;
	struct cvmx_gmxx_txx_stat3_s cnf71xx;
};

union cvmx_gmxx_txx_stat4 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat4_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t hist1:32;
		uint64_t hist0:32;
#else
		uint64_t hist0:32;
		uint64_t hist1:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat4_s cn30xx;
	struct cvmx_gmxx_txx_stat4_s cn31xx;
	struct cvmx_gmxx_txx_stat4_s cn38xx;
	struct cvmx_gmxx_txx_stat4_s cn38xxp2;
	struct cvmx_gmxx_txx_stat4_s cn50xx;
	struct cvmx_gmxx_txx_stat4_s cn52xx;
	struct cvmx_gmxx_txx_stat4_s cn52xxp1;
	struct cvmx_gmxx_txx_stat4_s cn56xx;
	struct cvmx_gmxx_txx_stat4_s cn56xxp1;
	struct cvmx_gmxx_txx_stat4_s cn58xx;
	struct cvmx_gmxx_txx_stat4_s cn58xxp1;
	struct cvmx_gmxx_txx_stat4_s cn61xx;
	struct cvmx_gmxx_txx_stat4_s cn63xx;
	struct cvmx_gmxx_txx_stat4_s cn63xxp1;
	struct cvmx_gmxx_txx_stat4_s cn66xx;
	struct cvmx_gmxx_txx_stat4_s cn68xx;
	struct cvmx_gmxx_txx_stat4_s cn68xxp1;
	struct cvmx_gmxx_txx_stat4_s cnf71xx;
};

union cvmx_gmxx_txx_stat5 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat5_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t hist3:32;
		uint64_t hist2:32;
#else
		uint64_t hist2:32;
		uint64_t hist3:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat5_s cn30xx;
	struct cvmx_gmxx_txx_stat5_s cn31xx;
	struct cvmx_gmxx_txx_stat5_s cn38xx;
	struct cvmx_gmxx_txx_stat5_s cn38xxp2;
	struct cvmx_gmxx_txx_stat5_s cn50xx;
	struct cvmx_gmxx_txx_stat5_s cn52xx;
	struct cvmx_gmxx_txx_stat5_s cn52xxp1;
	struct cvmx_gmxx_txx_stat5_s cn56xx;
	struct cvmx_gmxx_txx_stat5_s cn56xxp1;
	struct cvmx_gmxx_txx_stat5_s cn58xx;
	struct cvmx_gmxx_txx_stat5_s cn58xxp1;
	struct cvmx_gmxx_txx_stat5_s cn61xx;
	struct cvmx_gmxx_txx_stat5_s cn63xx;
	struct cvmx_gmxx_txx_stat5_s cn63xxp1;
	struct cvmx_gmxx_txx_stat5_s cn66xx;
	struct cvmx_gmxx_txx_stat5_s cn68xx;
	struct cvmx_gmxx_txx_stat5_s cn68xxp1;
	struct cvmx_gmxx_txx_stat5_s cnf71xx;
};

union cvmx_gmxx_txx_stat6 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat6_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t hist5:32;
		uint64_t hist4:32;
#else
		uint64_t hist4:32;
		uint64_t hist5:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat6_s cn30xx;
	struct cvmx_gmxx_txx_stat6_s cn31xx;
	struct cvmx_gmxx_txx_stat6_s cn38xx;
	struct cvmx_gmxx_txx_stat6_s cn38xxp2;
	struct cvmx_gmxx_txx_stat6_s cn50xx;
	struct cvmx_gmxx_txx_stat6_s cn52xx;
	struct cvmx_gmxx_txx_stat6_s cn52xxp1;
	struct cvmx_gmxx_txx_stat6_s cn56xx;
	struct cvmx_gmxx_txx_stat6_s cn56xxp1;
	struct cvmx_gmxx_txx_stat6_s cn58xx;
	struct cvmx_gmxx_txx_stat6_s cn58xxp1;
	struct cvmx_gmxx_txx_stat6_s cn61xx;
	struct cvmx_gmxx_txx_stat6_s cn63xx;
	struct cvmx_gmxx_txx_stat6_s cn63xxp1;
	struct cvmx_gmxx_txx_stat6_s cn66xx;
	struct cvmx_gmxx_txx_stat6_s cn68xx;
	struct cvmx_gmxx_txx_stat6_s cn68xxp1;
	struct cvmx_gmxx_txx_stat6_s cnf71xx;
};

union cvmx_gmxx_txx_stat7 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat7_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t hist7:32;
		uint64_t hist6:32;
#else
		uint64_t hist6:32;
		uint64_t hist7:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat7_s cn30xx;
	struct cvmx_gmxx_txx_stat7_s cn31xx;
	struct cvmx_gmxx_txx_stat7_s cn38xx;
	struct cvmx_gmxx_txx_stat7_s cn38xxp2;
	struct cvmx_gmxx_txx_stat7_s cn50xx;
	struct cvmx_gmxx_txx_stat7_s cn52xx;
	struct cvmx_gmxx_txx_stat7_s cn52xxp1;
	struct cvmx_gmxx_txx_stat7_s cn56xx;
	struct cvmx_gmxx_txx_stat7_s cn56xxp1;
	struct cvmx_gmxx_txx_stat7_s cn58xx;
	struct cvmx_gmxx_txx_stat7_s cn58xxp1;
	struct cvmx_gmxx_txx_stat7_s cn61xx;
	struct cvmx_gmxx_txx_stat7_s cn63xx;
	struct cvmx_gmxx_txx_stat7_s cn63xxp1;
	struct cvmx_gmxx_txx_stat7_s cn66xx;
	struct cvmx_gmxx_txx_stat7_s cn68xx;
	struct cvmx_gmxx_txx_stat7_s cn68xxp1;
	struct cvmx_gmxx_txx_stat7_s cnf71xx;
};

union cvmx_gmxx_txx_stat8 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat8_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mcst:32;
		uint64_t bcst:32;
#else
		uint64_t bcst:32;
		uint64_t mcst:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat8_s cn30xx;
	struct cvmx_gmxx_txx_stat8_s cn31xx;
	struct cvmx_gmxx_txx_stat8_s cn38xx;
	struct cvmx_gmxx_txx_stat8_s cn38xxp2;
	struct cvmx_gmxx_txx_stat8_s cn50xx;
	struct cvmx_gmxx_txx_stat8_s cn52xx;
	struct cvmx_gmxx_txx_stat8_s cn52xxp1;
	struct cvmx_gmxx_txx_stat8_s cn56xx;
	struct cvmx_gmxx_txx_stat8_s cn56xxp1;
	struct cvmx_gmxx_txx_stat8_s cn58xx;
	struct cvmx_gmxx_txx_stat8_s cn58xxp1;
	struct cvmx_gmxx_txx_stat8_s cn61xx;
	struct cvmx_gmxx_txx_stat8_s cn63xx;
	struct cvmx_gmxx_txx_stat8_s cn63xxp1;
	struct cvmx_gmxx_txx_stat8_s cn66xx;
	struct cvmx_gmxx_txx_stat8_s cn68xx;
	struct cvmx_gmxx_txx_stat8_s cn68xxp1;
	struct cvmx_gmxx_txx_stat8_s cnf71xx;
};

union cvmx_gmxx_txx_stat9 {
	uint64_t u64;
	struct cvmx_gmxx_txx_stat9_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t undflw:32;
		uint64_t ctl:32;
#else
		uint64_t ctl:32;
		uint64_t undflw:32;
#endif
	} s;
	struct cvmx_gmxx_txx_stat9_s cn30xx;
	struct cvmx_gmxx_txx_stat9_s cn31xx;
	struct cvmx_gmxx_txx_stat9_s cn38xx;
	struct cvmx_gmxx_txx_stat9_s cn38xxp2;
	struct cvmx_gmxx_txx_stat9_s cn50xx;
	struct cvmx_gmxx_txx_stat9_s cn52xx;
	struct cvmx_gmxx_txx_stat9_s cn52xxp1;
	struct cvmx_gmxx_txx_stat9_s cn56xx;
	struct cvmx_gmxx_txx_stat9_s cn56xxp1;
	struct cvmx_gmxx_txx_stat9_s cn58xx;
	struct cvmx_gmxx_txx_stat9_s cn58xxp1;
	struct cvmx_gmxx_txx_stat9_s cn61xx;
	struct cvmx_gmxx_txx_stat9_s cn63xx;
	struct cvmx_gmxx_txx_stat9_s cn63xxp1;
	struct cvmx_gmxx_txx_stat9_s cn66xx;
	struct cvmx_gmxx_txx_stat9_s cn68xx;
	struct cvmx_gmxx_txx_stat9_s cn68xxp1;
	struct cvmx_gmxx_txx_stat9_s cnf71xx;
};

union cvmx_gmxx_txx_stats_ctl {
	uint64_t u64;
	struct cvmx_gmxx_txx_stats_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t rd_clr:1;
#else
		uint64_t rd_clr:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_txx_stats_ctl_s cn30xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn31xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn38xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn38xxp2;
	struct cvmx_gmxx_txx_stats_ctl_s cn50xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn52xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn52xxp1;
	struct cvmx_gmxx_txx_stats_ctl_s cn56xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn56xxp1;
	struct cvmx_gmxx_txx_stats_ctl_s cn58xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn58xxp1;
	struct cvmx_gmxx_txx_stats_ctl_s cn61xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn63xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn63xxp1;
	struct cvmx_gmxx_txx_stats_ctl_s cn66xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn68xx;
	struct cvmx_gmxx_txx_stats_ctl_s cn68xxp1;
	struct cvmx_gmxx_txx_stats_ctl_s cnf71xx;
};

union cvmx_gmxx_txx_thresh {
	uint64_t u64;
	struct cvmx_gmxx_txx_thresh_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t cnt:10;
#else
		uint64_t cnt:10;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_gmxx_txx_thresh_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_7_63:57;
		uint64_t cnt:7;
#else
		uint64_t cnt:7;
		uint64_t reserved_7_63:57;
#endif
	} cn30xx;
	struct cvmx_gmxx_txx_thresh_cn30xx cn31xx;
	struct cvmx_gmxx_txx_thresh_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t cnt:9;
#else
		uint64_t cnt:9;
		uint64_t reserved_9_63:55;
#endif
	} cn38xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn38xxp2;
	struct cvmx_gmxx_txx_thresh_cn30xx cn50xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn52xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn52xxp1;
	struct cvmx_gmxx_txx_thresh_cn38xx cn56xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn56xxp1;
	struct cvmx_gmxx_txx_thresh_cn38xx cn58xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn58xxp1;
	struct cvmx_gmxx_txx_thresh_cn38xx cn61xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn63xx;
	struct cvmx_gmxx_txx_thresh_cn38xx cn63xxp1;
	struct cvmx_gmxx_txx_thresh_cn38xx cn66xx;
	struct cvmx_gmxx_txx_thresh_s cn68xx;
	struct cvmx_gmxx_txx_thresh_s cn68xxp1;
	struct cvmx_gmxx_txx_thresh_cn38xx cnf71xx;
};

union cvmx_gmxx_tx_bp {
	uint64_t u64;
	struct cvmx_gmxx_tx_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t bp:4;
#else
		uint64_t bp:4;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_tx_bp_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_3_63:61;
		uint64_t bp:3;
#else
		uint64_t bp:3;
		uint64_t reserved_3_63:61;
#endif
	} cn30xx;
	struct cvmx_gmxx_tx_bp_cn30xx cn31xx;
	struct cvmx_gmxx_tx_bp_s cn38xx;
	struct cvmx_gmxx_tx_bp_s cn38xxp2;
	struct cvmx_gmxx_tx_bp_cn30xx cn50xx;
	struct cvmx_gmxx_tx_bp_s cn52xx;
	struct cvmx_gmxx_tx_bp_s cn52xxp1;
	struct cvmx_gmxx_tx_bp_s cn56xx;
	struct cvmx_gmxx_tx_bp_s cn56xxp1;
	struct cvmx_gmxx_tx_bp_s cn58xx;
	struct cvmx_gmxx_tx_bp_s cn58xxp1;
	struct cvmx_gmxx_tx_bp_s cn61xx;
	struct cvmx_gmxx_tx_bp_s cn63xx;
	struct cvmx_gmxx_tx_bp_s cn63xxp1;
	struct cvmx_gmxx_tx_bp_s cn66xx;
	struct cvmx_gmxx_tx_bp_s cn68xx;
	struct cvmx_gmxx_tx_bp_s cn68xxp1;
	struct cvmx_gmxx_tx_bp_cnf71xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t bp:2;
#else
		uint64_t bp:2;
		uint64_t reserved_2_63:62;
#endif
	} cnf71xx;
};

union cvmx_gmxx_tx_clk_mskx {
	uint64_t u64;
	struct cvmx_gmxx_tx_clk_mskx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t msk:1;
#else
		uint64_t msk:1;
		uint64_t reserved_1_63:63;
#endif
	} s;
	struct cvmx_gmxx_tx_clk_mskx_s cn30xx;
	struct cvmx_gmxx_tx_clk_mskx_s cn50xx;
};

union cvmx_gmxx_tx_col_attempt {
	uint64_t u64;
	struct cvmx_gmxx_tx_col_attempt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t limit:5;
#else
		uint64_t limit:5;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_gmxx_tx_col_attempt_s cn30xx;
	struct cvmx_gmxx_tx_col_attempt_s cn31xx;
	struct cvmx_gmxx_tx_col_attempt_s cn38xx;
	struct cvmx_gmxx_tx_col_attempt_s cn38xxp2;
	struct cvmx_gmxx_tx_col_attempt_s cn50xx;
	struct cvmx_gmxx_tx_col_attempt_s cn52xx;
	struct cvmx_gmxx_tx_col_attempt_s cn52xxp1;
	struct cvmx_gmxx_tx_col_attempt_s cn56xx;
	struct cvmx_gmxx_tx_col_attempt_s cn56xxp1;
	struct cvmx_gmxx_tx_col_attempt_s cn58xx;
	struct cvmx_gmxx_tx_col_attempt_s cn58xxp1;
	struct cvmx_gmxx_tx_col_attempt_s cn61xx;
	struct cvmx_gmxx_tx_col_attempt_s cn63xx;
	struct cvmx_gmxx_tx_col_attempt_s cn63xxp1;
	struct cvmx_gmxx_tx_col_attempt_s cn66xx;
	struct cvmx_gmxx_tx_col_attempt_s cn68xx;
	struct cvmx_gmxx_tx_col_attempt_s cn68xxp1;
	struct cvmx_gmxx_tx_col_attempt_s cnf71xx;
};

union cvmx_gmxx_tx_corrupt {
	uint64_t u64;
	struct cvmx_gmxx_tx_corrupt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t corrupt:4;
#else
		uint64_t corrupt:4;
		uint64_t reserved_4_63:60;
#endif
	} s;
	struct cvmx_gmxx_tx_corrupt_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_3_63:61;
		uint64_t corrupt:3;
#else
		uint64_t corrupt:3;
		uint64_t reserved_3_63:61;
#endif
	} cn30xx;
	struct cvmx_gmxx_tx_corrupt_cn30xx cn31xx;
	struct cvmx_gmxx_tx_corrupt_s cn38xx;
	struct cvmx_gmxx_tx_corrupt_s cn38xxp2;
	struct cvmx_gmxx_tx_corrupt_cn30xx cn50xx;
	struct cvmx_gmxx_tx_corrupt_s cn52xx;
	struct cvmx_gmxx_tx_corrupt_s cn52xxp1;
	struct cvmx_gmxx_tx_corrupt_s cn56xx;
	struct cvmx_gmxx_tx_corrupt_s cn56xxp1;
	struct cvmx_gmxx_tx_corrupt_s cn58xx;
	struct cvmx_gmxx_tx_corrupt_s cn58xxp1;
	struct cvmx_gmxx_tx_corrupt_s cn61xx;
	struct cvmx_gmxx_tx_corrupt_s cn63xx;
	struct cvmx_gmxx_tx_corrupt_s cn63xxp1;
	struct cvmx_gmxx_tx_corrupt_s cn66xx;
	struct cvmx_gmxx_tx_corrupt_s cn68xx;
	struct cvmx_gmxx_tx_corrupt_s cn68xxp1;
	struct cvmx_gmxx_tx_corrupt_cnf71xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t corrupt:2;
#else
		uint64_t corrupt:2;
		uint64_t reserved_2_63:62;
#endif
	} cnf71xx;
};

union cvmx_gmxx_tx_hg2_reg1 {
	uint64_t u64;
	struct cvmx_gmxx_tx_hg2_reg1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t tx_xof:16;
#else
		uint64_t tx_xof:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_tx_hg2_reg1_s cn52xx;
	struct cvmx_gmxx_tx_hg2_reg1_s cn52xxp1;
	struct cvmx_gmxx_tx_hg2_reg1_s cn56xx;
	struct cvmx_gmxx_tx_hg2_reg1_s cn61xx;
	struct cvmx_gmxx_tx_hg2_reg1_s cn63xx;
	struct cvmx_gmxx_tx_hg2_reg1_s cn63xxp1;
	struct cvmx_gmxx_tx_hg2_reg1_s cn66xx;
	struct cvmx_gmxx_tx_hg2_reg1_s cn68xx;
	struct cvmx_gmxx_tx_hg2_reg1_s cn68xxp1;
	struct cvmx_gmxx_tx_hg2_reg1_s cnf71xx;
};

union cvmx_gmxx_tx_hg2_reg2 {
	uint64_t u64;
	struct cvmx_gmxx_tx_hg2_reg2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t tx_xon:16;
#else
		uint64_t tx_xon:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_tx_hg2_reg2_s cn52xx;
	struct cvmx_gmxx_tx_hg2_reg2_s cn52xxp1;
	struct cvmx_gmxx_tx_hg2_reg2_s cn56xx;
	struct cvmx_gmxx_tx_hg2_reg2_s cn61xx;
	struct cvmx_gmxx_tx_hg2_reg2_s cn63xx;
	struct cvmx_gmxx_tx_hg2_reg2_s cn63xxp1;
	struct cvmx_gmxx_tx_hg2_reg2_s cn66xx;
	struct cvmx_gmxx_tx_hg2_reg2_s cn68xx;
	struct cvmx_gmxx_tx_hg2_reg2_s cn68xxp1;
	struct cvmx_gmxx_tx_hg2_reg2_s cnf71xx;
};

union cvmx_gmxx_tx_ifg {
	uint64_t u64;
	struct cvmx_gmxx_tx_ifg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t ifg2:4;
		uint64_t ifg1:4;
#else
		uint64_t ifg1:4;
		uint64_t ifg2:4;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_gmxx_tx_ifg_s cn30xx;
	struct cvmx_gmxx_tx_ifg_s cn31xx;
	struct cvmx_gmxx_tx_ifg_s cn38xx;
	struct cvmx_gmxx_tx_ifg_s cn38xxp2;
	struct cvmx_gmxx_tx_ifg_s cn50xx;
	struct cvmx_gmxx_tx_ifg_s cn52xx;
	struct cvmx_gmxx_tx_ifg_s cn52xxp1;
	struct cvmx_gmxx_tx_ifg_s cn56xx;
	struct cvmx_gmxx_tx_ifg_s cn56xxp1;
	struct cvmx_gmxx_tx_ifg_s cn58xx;
	struct cvmx_gmxx_tx_ifg_s cn58xxp1;
	struct cvmx_gmxx_tx_ifg_s cn61xx;
	struct cvmx_gmxx_tx_ifg_s cn63xx;
	struct cvmx_gmxx_tx_ifg_s cn63xxp1;
	struct cvmx_gmxx_tx_ifg_s cn66xx;
	struct cvmx_gmxx_tx_ifg_s cn68xx;
	struct cvmx_gmxx_tx_ifg_s cn68xxp1;
	struct cvmx_gmxx_tx_ifg_s cnf71xx;
};

union cvmx_gmxx_tx_int_en {
	uint64_t u64;
	struct cvmx_gmxx_tx_int_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t xchange:1;
		uint64_t ptp_lost:4;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t ptp_lost:4;
		uint64_t xchange:1;
		uint64_t reserved_25_63:39;
#endif
	} s;
	struct cvmx_gmxx_tx_int_en_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t late_col:3;
		uint64_t reserved_15_15:1;
		uint64_t xsdef:3;
		uint64_t reserved_11_11:1;
		uint64_t xscol:3;
		uint64_t reserved_5_7:3;
		uint64_t undflw:3;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:3;
		uint64_t reserved_5_7:3;
		uint64_t xscol:3;
		uint64_t reserved_11_11:1;
		uint64_t xsdef:3;
		uint64_t reserved_15_15:1;
		uint64_t late_col:3;
		uint64_t reserved_19_63:45;
#endif
	} cn30xx;
	struct cvmx_gmxx_tx_int_en_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_15_63:49;
		uint64_t xsdef:3;
		uint64_t reserved_11_11:1;
		uint64_t xscol:3;
		uint64_t reserved_5_7:3;
		uint64_t undflw:3;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:3;
		uint64_t reserved_5_7:3;
		uint64_t xscol:3;
		uint64_t reserved_11_11:1;
		uint64_t xsdef:3;
		uint64_t reserved_15_63:49;
#endif
	} cn31xx;
	struct cvmx_gmxx_tx_int_en_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t ncb_nxa:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t ncb_nxa:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t reserved_20_63:44;
#endif
	} cn38xx;
	struct cvmx_gmxx_tx_int_en_cn38xxp2 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t ncb_nxa:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t ncb_nxa:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t reserved_16_63:48;
#endif
	} cn38xxp2;
	struct cvmx_gmxx_tx_int_en_cn30xx cn50xx;
	struct cvmx_gmxx_tx_int_en_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t reserved_20_63:44;
#endif
	} cn52xx;
	struct cvmx_gmxx_tx_int_en_cn52xx cn52xxp1;
	struct cvmx_gmxx_tx_int_en_cn52xx cn56xx;
	struct cvmx_gmxx_tx_int_en_cn52xx cn56xxp1;
	struct cvmx_gmxx_tx_int_en_cn38xx cn58xx;
	struct cvmx_gmxx_tx_int_en_cn38xx cn58xxp1;
	struct cvmx_gmxx_tx_int_en_s cn61xx;
	struct cvmx_gmxx_tx_int_en_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t ptp_lost:4;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t ptp_lost:4;
		uint64_t reserved_24_63:40;
#endif
	} cn63xx;
	struct cvmx_gmxx_tx_int_en_cn63xx cn63xxp1;
	struct cvmx_gmxx_tx_int_en_s cn66xx;
	struct cvmx_gmxx_tx_int_en_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t xchange:1;
		uint64_t ptp_lost:4;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t pko_nxp:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t pko_nxp:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t ptp_lost:4;
		uint64_t xchange:1;
		uint64_t reserved_25_63:39;
#endif
	} cn68xx;
	struct cvmx_gmxx_tx_int_en_cn68xx cn68xxp1;
	struct cvmx_gmxx_tx_int_en_cnf71xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t xchange:1;
		uint64_t reserved_22_23:2;
		uint64_t ptp_lost:2;
		uint64_t reserved_18_19:2;
		uint64_t late_col:2;
		uint64_t reserved_14_15:2;
		uint64_t xsdef:2;
		uint64_t reserved_10_11:2;
		uint64_t xscol:2;
		uint64_t reserved_4_7:4;
		uint64_t undflw:2;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:2;
		uint64_t reserved_4_7:4;
		uint64_t xscol:2;
		uint64_t reserved_10_11:2;
		uint64_t xsdef:2;
		uint64_t reserved_14_15:2;
		uint64_t late_col:2;
		uint64_t reserved_18_19:2;
		uint64_t ptp_lost:2;
		uint64_t reserved_22_23:2;
		uint64_t xchange:1;
		uint64_t reserved_25_63:39;
#endif
	} cnf71xx;
};

union cvmx_gmxx_tx_int_reg {
	uint64_t u64;
	struct cvmx_gmxx_tx_int_reg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t xchange:1;
		uint64_t ptp_lost:4;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t ptp_lost:4;
		uint64_t xchange:1;
		uint64_t reserved_25_63:39;
#endif
	} s;
	struct cvmx_gmxx_tx_int_reg_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t late_col:3;
		uint64_t reserved_15_15:1;
		uint64_t xsdef:3;
		uint64_t reserved_11_11:1;
		uint64_t xscol:3;
		uint64_t reserved_5_7:3;
		uint64_t undflw:3;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:3;
		uint64_t reserved_5_7:3;
		uint64_t xscol:3;
		uint64_t reserved_11_11:1;
		uint64_t xsdef:3;
		uint64_t reserved_15_15:1;
		uint64_t late_col:3;
		uint64_t reserved_19_63:45;
#endif
	} cn30xx;
	struct cvmx_gmxx_tx_int_reg_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_15_63:49;
		uint64_t xsdef:3;
		uint64_t reserved_11_11:1;
		uint64_t xscol:3;
		uint64_t reserved_5_7:3;
		uint64_t undflw:3;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:3;
		uint64_t reserved_5_7:3;
		uint64_t xscol:3;
		uint64_t reserved_11_11:1;
		uint64_t xsdef:3;
		uint64_t reserved_15_63:49;
#endif
	} cn31xx;
	struct cvmx_gmxx_tx_int_reg_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t ncb_nxa:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t ncb_nxa:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t reserved_20_63:44;
#endif
	} cn38xx;
	struct cvmx_gmxx_tx_int_reg_cn38xxp2 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t ncb_nxa:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t ncb_nxa:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t reserved_16_63:48;
#endif
	} cn38xxp2;
	struct cvmx_gmxx_tx_int_reg_cn30xx cn50xx;
	struct cvmx_gmxx_tx_int_reg_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t reserved_20_63:44;
#endif
	} cn52xx;
	struct cvmx_gmxx_tx_int_reg_cn52xx cn52xxp1;
	struct cvmx_gmxx_tx_int_reg_cn52xx cn56xx;
	struct cvmx_gmxx_tx_int_reg_cn52xx cn56xxp1;
	struct cvmx_gmxx_tx_int_reg_cn38xx cn58xx;
	struct cvmx_gmxx_tx_int_reg_cn38xx cn58xxp1;
	struct cvmx_gmxx_tx_int_reg_s cn61xx;
	struct cvmx_gmxx_tx_int_reg_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t ptp_lost:4;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t ptp_lost:4;
		uint64_t reserved_24_63:40;
#endif
	} cn63xx;
	struct cvmx_gmxx_tx_int_reg_cn63xx cn63xxp1;
	struct cvmx_gmxx_tx_int_reg_s cn66xx;
	struct cvmx_gmxx_tx_int_reg_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t xchange:1;
		uint64_t ptp_lost:4;
		uint64_t late_col:4;
		uint64_t xsdef:4;
		uint64_t xscol:4;
		uint64_t reserved_6_7:2;
		uint64_t undflw:4;
		uint64_t pko_nxp:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t pko_nxp:1;
		uint64_t undflw:4;
		uint64_t reserved_6_7:2;
		uint64_t xscol:4;
		uint64_t xsdef:4;
		uint64_t late_col:4;
		uint64_t ptp_lost:4;
		uint64_t xchange:1;
		uint64_t reserved_25_63:39;
#endif
	} cn68xx;
	struct cvmx_gmxx_tx_int_reg_cn68xx cn68xxp1;
	struct cvmx_gmxx_tx_int_reg_cnf71xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t xchange:1;
		uint64_t reserved_22_23:2;
		uint64_t ptp_lost:2;
		uint64_t reserved_18_19:2;
		uint64_t late_col:2;
		uint64_t reserved_14_15:2;
		uint64_t xsdef:2;
		uint64_t reserved_10_11:2;
		uint64_t xscol:2;
		uint64_t reserved_4_7:4;
		uint64_t undflw:2;
		uint64_t reserved_1_1:1;
		uint64_t pko_nxa:1;
#else
		uint64_t pko_nxa:1;
		uint64_t reserved_1_1:1;
		uint64_t undflw:2;
		uint64_t reserved_4_7:4;
		uint64_t xscol:2;
		uint64_t reserved_10_11:2;
		uint64_t xsdef:2;
		uint64_t reserved_14_15:2;
		uint64_t late_col:2;
		uint64_t reserved_18_19:2;
		uint64_t ptp_lost:2;
		uint64_t reserved_22_23:2;
		uint64_t xchange:1;
		uint64_t reserved_25_63:39;
#endif
	} cnf71xx;
};

union cvmx_gmxx_tx_jam {
	uint64_t u64;
	struct cvmx_gmxx_tx_jam_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t jam:8;
#else
		uint64_t jam:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_gmxx_tx_jam_s cn30xx;
	struct cvmx_gmxx_tx_jam_s cn31xx;
	struct cvmx_gmxx_tx_jam_s cn38xx;
	struct cvmx_gmxx_tx_jam_s cn38xxp2;
	struct cvmx_gmxx_tx_jam_s cn50xx;
	struct cvmx_gmxx_tx_jam_s cn52xx;
	struct cvmx_gmxx_tx_jam_s cn52xxp1;
	struct cvmx_gmxx_tx_jam_s cn56xx;
	struct cvmx_gmxx_tx_jam_s cn56xxp1;
	struct cvmx_gmxx_tx_jam_s cn58xx;
	struct cvmx_gmxx_tx_jam_s cn58xxp1;
	struct cvmx_gmxx_tx_jam_s cn61xx;
	struct cvmx_gmxx_tx_jam_s cn63xx;
	struct cvmx_gmxx_tx_jam_s cn63xxp1;
	struct cvmx_gmxx_tx_jam_s cn66xx;
	struct cvmx_gmxx_tx_jam_s cn68xx;
	struct cvmx_gmxx_tx_jam_s cn68xxp1;
	struct cvmx_gmxx_tx_jam_s cnf71xx;
};

union cvmx_gmxx_tx_lfsr {
	uint64_t u64;
	struct cvmx_gmxx_tx_lfsr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t lfsr:16;
#else
		uint64_t lfsr:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_tx_lfsr_s cn30xx;
	struct cvmx_gmxx_tx_lfsr_s cn31xx;
	struct cvmx_gmxx_tx_lfsr_s cn38xx;
	struct cvmx_gmxx_tx_lfsr_s cn38xxp2;
	struct cvmx_gmxx_tx_lfsr_s cn50xx;
	struct cvmx_gmxx_tx_lfsr_s cn52xx;
	struct cvmx_gmxx_tx_lfsr_s cn52xxp1;
	struct cvmx_gmxx_tx_lfsr_s cn56xx;
	struct cvmx_gmxx_tx_lfsr_s cn56xxp1;
	struct cvmx_gmxx_tx_lfsr_s cn58xx;
	struct cvmx_gmxx_tx_lfsr_s cn58xxp1;
	struct cvmx_gmxx_tx_lfsr_s cn61xx;
	struct cvmx_gmxx_tx_lfsr_s cn63xx;
	struct cvmx_gmxx_tx_lfsr_s cn63xxp1;
	struct cvmx_gmxx_tx_lfsr_s cn66xx;
	struct cvmx_gmxx_tx_lfsr_s cn68xx;
	struct cvmx_gmxx_tx_lfsr_s cn68xxp1;
	struct cvmx_gmxx_tx_lfsr_s cnf71xx;
};

union cvmx_gmxx_tx_ovr_bp {
	uint64_t u64;
	struct cvmx_gmxx_tx_ovr_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t tx_prt_bp:16;
		uint64_t reserved_12_31:20;
		uint64_t en:4;
		uint64_t bp:4;
		uint64_t ign_full:4;
#else
		uint64_t ign_full:4;
		uint64_t bp:4;
		uint64_t en:4;
		uint64_t reserved_12_31:20;
		uint64_t tx_prt_bp:16;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_tx_ovr_bp_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_11_63:53;
		uint64_t en:3;
		uint64_t reserved_7_7:1;
		uint64_t bp:3;
		uint64_t reserved_3_3:1;
		uint64_t ign_full:3;
#else
		uint64_t ign_full:3;
		uint64_t reserved_3_3:1;
		uint64_t bp:3;
		uint64_t reserved_7_7:1;
		uint64_t en:3;
		uint64_t reserved_11_63:53;
#endif
	} cn30xx;
	struct cvmx_gmxx_tx_ovr_bp_cn30xx cn31xx;
	struct cvmx_gmxx_tx_ovr_bp_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_12_63:52;
		uint64_t en:4;
		uint64_t bp:4;
		uint64_t ign_full:4;
#else
		uint64_t ign_full:4;
		uint64_t bp:4;
		uint64_t en:4;
		uint64_t reserved_12_63:52;
#endif
	} cn38xx;
	struct cvmx_gmxx_tx_ovr_bp_cn38xx cn38xxp2;
	struct cvmx_gmxx_tx_ovr_bp_cn30xx cn50xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn52xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn52xxp1;
	struct cvmx_gmxx_tx_ovr_bp_s cn56xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn56xxp1;
	struct cvmx_gmxx_tx_ovr_bp_cn38xx cn58xx;
	struct cvmx_gmxx_tx_ovr_bp_cn38xx cn58xxp1;
	struct cvmx_gmxx_tx_ovr_bp_s cn61xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn63xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn63xxp1;
	struct cvmx_gmxx_tx_ovr_bp_s cn66xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn68xx;
	struct cvmx_gmxx_tx_ovr_bp_s cn68xxp1;
	struct cvmx_gmxx_tx_ovr_bp_cnf71xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t tx_prt_bp:16;
		uint64_t reserved_10_31:22;
		uint64_t en:2;
		uint64_t reserved_6_7:2;
		uint64_t bp:2;
		uint64_t reserved_2_3:2;
		uint64_t ign_full:2;
#else
		uint64_t ign_full:2;
		uint64_t reserved_2_3:2;
		uint64_t bp:2;
		uint64_t reserved_6_7:2;
		uint64_t en:2;
		uint64_t reserved_10_31:22;
		uint64_t tx_prt_bp:16;
		uint64_t reserved_48_63:16;
#endif
	} cnf71xx;
};

union cvmx_gmxx_tx_pause_pkt_dmac {
	uint64_t u64;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t dmac:48;
#else
		uint64_t dmac:48;
		uint64_t reserved_48_63:16;
#endif
	} s;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn30xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn31xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn38xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn38xxp2;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn50xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn52xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn52xxp1;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn56xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn56xxp1;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn58xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn58xxp1;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn61xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn63xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn63xxp1;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn66xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn68xx;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cn68xxp1;
	struct cvmx_gmxx_tx_pause_pkt_dmac_s cnf71xx;
};

union cvmx_gmxx_tx_pause_pkt_type {
	uint64_t u64;
	struct cvmx_gmxx_tx_pause_pkt_type_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t type:16;
#else
		uint64_t type:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn30xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn31xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn38xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn38xxp2;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn50xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn52xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn52xxp1;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn56xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn56xxp1;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn58xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn58xxp1;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn61xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn63xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn63xxp1;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn66xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn68xx;
	struct cvmx_gmxx_tx_pause_pkt_type_s cn68xxp1;
	struct cvmx_gmxx_tx_pause_pkt_type_s cnf71xx;
};

union cvmx_gmxx_tx_prts {
	uint64_t u64;
	struct cvmx_gmxx_tx_prts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t prts:5;
#else
		uint64_t prts:5;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_gmxx_tx_prts_s cn30xx;
	struct cvmx_gmxx_tx_prts_s cn31xx;
	struct cvmx_gmxx_tx_prts_s cn38xx;
	struct cvmx_gmxx_tx_prts_s cn38xxp2;
	struct cvmx_gmxx_tx_prts_s cn50xx;
	struct cvmx_gmxx_tx_prts_s cn52xx;
	struct cvmx_gmxx_tx_prts_s cn52xxp1;
	struct cvmx_gmxx_tx_prts_s cn56xx;
	struct cvmx_gmxx_tx_prts_s cn56xxp1;
	struct cvmx_gmxx_tx_prts_s cn58xx;
	struct cvmx_gmxx_tx_prts_s cn58xxp1;
	struct cvmx_gmxx_tx_prts_s cn61xx;
	struct cvmx_gmxx_tx_prts_s cn63xx;
	struct cvmx_gmxx_tx_prts_s cn63xxp1;
	struct cvmx_gmxx_tx_prts_s cn66xx;
	struct cvmx_gmxx_tx_prts_s cn68xx;
	struct cvmx_gmxx_tx_prts_s cn68xxp1;
	struct cvmx_gmxx_tx_prts_s cnf71xx;
};

union cvmx_gmxx_tx_spi_ctl {
	uint64_t u64;
	struct cvmx_gmxx_tx_spi_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t tpa_clr:1;
		uint64_t cont_pkt:1;
#else
		uint64_t cont_pkt:1;
		uint64_t tpa_clr:1;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_gmxx_tx_spi_ctl_s cn38xx;
	struct cvmx_gmxx_tx_spi_ctl_s cn38xxp2;
	struct cvmx_gmxx_tx_spi_ctl_s cn58xx;
	struct cvmx_gmxx_tx_spi_ctl_s cn58xxp1;
};

union cvmx_gmxx_tx_spi_drain {
	uint64_t u64;
	struct cvmx_gmxx_tx_spi_drain_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t drain:16;
#else
		uint64_t drain:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_tx_spi_drain_s cn38xx;
	struct cvmx_gmxx_tx_spi_drain_s cn58xx;
	struct cvmx_gmxx_tx_spi_drain_s cn58xxp1;
};

union cvmx_gmxx_tx_spi_max {
	uint64_t u64;
	struct cvmx_gmxx_tx_spi_max_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t slice:7;
		uint64_t max2:8;
		uint64_t max1:8;
#else
		uint64_t max1:8;
		uint64_t max2:8;
		uint64_t slice:7;
		uint64_t reserved_23_63:41;
#endif
	} s;
	struct cvmx_gmxx_tx_spi_max_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t max2:8;
		uint64_t max1:8;
#else
		uint64_t max1:8;
		uint64_t max2:8;
		uint64_t reserved_16_63:48;
#endif
	} cn38xx;
	struct cvmx_gmxx_tx_spi_max_cn38xx cn38xxp2;
	struct cvmx_gmxx_tx_spi_max_s cn58xx;
	struct cvmx_gmxx_tx_spi_max_s cn58xxp1;
};

union cvmx_gmxx_tx_spi_roundx {
	uint64_t u64;
	struct cvmx_gmxx_tx_spi_roundx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t round:16;
#else
		uint64_t round:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_gmxx_tx_spi_roundx_s cn58xx;
	struct cvmx_gmxx_tx_spi_roundx_s cn58xxp1;
};

union cvmx_gmxx_tx_spi_thresh {
	uint64_t u64;
	struct cvmx_gmxx_tx_spi_thresh_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t thresh:6;
#else
		uint64_t thresh:6;
		uint64_t reserved_6_63:58;
#endif
	} s;
	struct cvmx_gmxx_tx_spi_thresh_s cn38xx;
	struct cvmx_gmxx_tx_spi_thresh_s cn38xxp2;
	struct cvmx_gmxx_tx_spi_thresh_s cn58xx;
	struct cvmx_gmxx_tx_spi_thresh_s cn58xxp1;
};

union cvmx_gmxx_tx_xaui_ctl {
	uint64_t u64;
	struct cvmx_gmxx_tx_xaui_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_11_63:53;
		uint64_t hg_pause_hgi:2;
		uint64_t hg_en:1;
		uint64_t reserved_7_7:1;
		uint64_t ls_byp:1;
		uint64_t ls:2;
		uint64_t reserved_2_3:2;
		uint64_t uni_en:1;
		uint64_t dic_en:1;
#else
		uint64_t dic_en:1;
		uint64_t uni_en:1;
		uint64_t reserved_2_3:2;
		uint64_t ls:2;
		uint64_t ls_byp:1;
		uint64_t reserved_7_7:1;
		uint64_t hg_en:1;
		uint64_t hg_pause_hgi:2;
		uint64_t reserved_11_63:53;
#endif
	} s;
	struct cvmx_gmxx_tx_xaui_ctl_s cn52xx;
	struct cvmx_gmxx_tx_xaui_ctl_s cn52xxp1;
	struct cvmx_gmxx_tx_xaui_ctl_s cn56xx;
	struct cvmx_gmxx_tx_xaui_ctl_s cn56xxp1;
	struct cvmx_gmxx_tx_xaui_ctl_s cn61xx;
	struct cvmx_gmxx_tx_xaui_ctl_s cn63xx;
	struct cvmx_gmxx_tx_xaui_ctl_s cn63xxp1;
	struct cvmx_gmxx_tx_xaui_ctl_s cn66xx;
	struct cvmx_gmxx_tx_xaui_ctl_s cn68xx;
	struct cvmx_gmxx_tx_xaui_ctl_s cn68xxp1;
	struct cvmx_gmxx_tx_xaui_ctl_s cnf71xx;
};

union cvmx_gmxx_xaui_ext_loopback {
	uint64_t u64;
	struct cvmx_gmxx_xaui_ext_loopback_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t en:1;
		uint64_t thresh:4;
#else
		uint64_t thresh:4;
		uint64_t en:1;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_gmxx_xaui_ext_loopback_s cn52xx;
	struct cvmx_gmxx_xaui_ext_loopback_s cn52xxp1;
	struct cvmx_gmxx_xaui_ext_loopback_s cn56xx;
	struct cvmx_gmxx_xaui_ext_loopback_s cn56xxp1;
	struct cvmx_gmxx_xaui_ext_loopback_s cn61xx;
	struct cvmx_gmxx_xaui_ext_loopback_s cn63xx;
	struct cvmx_gmxx_xaui_ext_loopback_s cn63xxp1;
	struct cvmx_gmxx_xaui_ext_loopback_s cn66xx;
	struct cvmx_gmxx_xaui_ext_loopback_s cn68xx;
	struct cvmx_gmxx_xaui_ext_loopback_s cn68xxp1;
	struct cvmx_gmxx_xaui_ext_loopback_s cnf71xx;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /***********************license start***************
 * Author: Cavium Networks
 *
 * Contact: support@caviumnetworks.com
 * This file is part of the OCTEON SDK
 *
 * Copyright (c) 2003-2012 Cavium Networks
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, Version 2, as
 * published by the Free Software Foundation.
 *
 * This file is distributed in the hope that it will be useful, but
 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
 * NONINFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 * or visit http://www.gnu.org/licenses/.
 *
 * This file may also be available under a different license from Cavium.
 * Contact Cavium Networks for more information
 ***********************license end**************************************/

#ifndef __CVMX_SLI_DEFS_H__
#define __CVMX_SLI_DEFS_H__

#define CVMX_SLI_BIST_STATUS (0x0000000000000580ull)
#define CVMX_SLI_CTL_PORTX(offset) (0x0000000000000050ull + ((offset) & 3) * 16)
#define CVMX_SLI_CTL_STATUS (0x0000000000000570ull)
#define CVMX_SLI_DATA_OUT_CNT (0x00000000000005F0ull)
#define CVMX_SLI_DBG_DATA (0x0000000000000310ull)
#define CVMX_SLI_DBG_SELECT (0x0000000000000300ull)
#define CVMX_SLI_DMAX_CNT(offset) (0x0000000000000400ull + ((offset) & 1) * 16)
#define CVMX_SLI_DMAX_INT_LEVEL(offset) (0x00000000000003E0ull + ((offset) & 1) * 16)
#define CVMX_SLI_DMAX_TIM(offset) (0x0000000000000420ull + ((offset) & 1) * 16)
#define CVMX_SLI_INT_ENB_CIU (0x0000000000003CD0ull)
#define CVMX_SLI_INT_ENB_PORTX(offset) (0x0000000000000340ull + ((offset) & 1) * 16)
#define CVMX_SLI_INT_SUM (0x0000000000000330ull)
#define CVMX_SLI_LAST_WIN_RDATA0 (0x0000000000000600ull)
#define CVMX_SLI_LAST_WIN_RDATA1 (0x0000000000000610ull)
#define CVMX_SLI_LAST_WIN_RDATA2 (0x00000000000006C0ull)
#define CVMX_SLI_LAST_WIN_RDATA3 (0x00000000000006D0ull)
#define CVMX_SLI_MAC_CREDIT_CNT (0x0000000000003D70ull)
#define CVMX_SLI_MAC_CREDIT_CNT2 (0x0000000000003E10ull)
#define CVMX_SLI_MAC_NUMBER (0x0000000000003E00ull)
#define CVMX_SLI_MEM_ACCESS_CTL (0x00000000000002F0ull)
#define CVMX_SLI_MEM_ACCESS_SUBIDX(offset) (0x00000000000000E0ull + ((offset) & 31) * 16 - 16*12)
#define CVMX_SLI_MSI_ENB0 (0x0000000000003C50ull)
#define CVMX_SLI_MSI_ENB1 (0x0000000000003C60ull)
#define CVMX_SLI_MSI_ENB2 (0x0000000000003C70ull)
#define CVMX_SLI_MSI_ENB3 (0x0000000000003C80ull)
#define CVMX_SLI_MSI_RCV0 (0x0000000000003C10ull)
#define CVMX_SLI_MSI_RCV1 (0x0000000000003C20ull)
#define CVMX_SLI_MSI_RCV2 (0x0000000000003C30ull)
#define CVMX_SLI_MSI_RCV3 (0x0000000000003C40ull)
#define CVMX_SLI_MSI_RD_MAP (0x0000000000003CA0ull)
#define CVMX_SLI_MSI_W1C_ENB0 (0x0000000000003CF0ull)
#define CVMX_SLI_MSI_W1C_ENB1 (0x0000000000003D00ull)
#define CVMX_SLI_MSI_W1C_ENB2 (0x0000000000003D10ull)
#define CVMX_SLI_MSI_W1C_ENB3 (0x0000000000003D20ull)
#define CVMX_SLI_MSI_W1S_ENB0 (0x0000000000003D30ull)
#define CVMX_SLI_MSI_W1S_ENB1 (0x0000000000003D40ull)
#define CVMX_SLI_MSI_W1S_ENB2 (0x0000000000003D50ull)
#define CVMX_SLI_MSI_W1S_ENB3 (0x0000000000003D60ull)
#define CVMX_SLI_MSI_WR_MAP (0x0000000000003C90ull)
#define CVMX_SLI_PCIE_MSI_RCV (0x0000000000003CB0ull)
#define CVMX_SLI_PCIE_MSI_RCV_B1 (0x0000000000000650ull)
#define CVMX_SLI_PCIE_MSI_RCV_B2 (0x0000000000000660ull)
#define CVMX_SLI_PCIE_MSI_RCV_B3 (0x0000000000000670ull)
#define CVMX_SLI_PKTX_CNTS(offset) (0x0000000000002400ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_INSTR_BADDR(offset) (0x0000000000002800ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (0x0000000000002C00ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (0x0000000000003000ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_INSTR_HEADER(offset) (0x0000000000003400ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_IN_BP(offset) (0x0000000000003800ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_OUT_SIZE(offset) (0x0000000000000C00ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_SLIST_BADDR(offset) (0x0000000000001400ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (0x0000000000001800ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (0x0000000000001C00ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKT_CNT_INT (0x0000000000001130ull)
#define CVMX_SLI_PKT_CNT_INT_ENB (0x0000000000001150ull)
#define CVMX_SLI_PKT_CTL (0x0000000000001220ull)
#define CVMX_SLI_PKT_DATA_OUT_ES (0x00000000000010B0ull)
#define CVMX_SLI_PKT_DATA_OUT_NS (0x00000000000010A0ull)
#define CVMX_SLI_PKT_DATA_OUT_ROR (0x0000000000001090ull)
#define CVMX_SLI_PKT_DPADDR (0x0000000000001080ull)
#define CVMX_SLI_PKT_INPUT_CONTROL (0x0000000000001170ull)
#define CVMX_SLI_PKT_INSTR_ENB (0x0000000000001000ull)
#define CVMX_SLI_PKT_INSTR_RD_SIZE (0x00000000000011A0ull)
#define CVMX_SLI_PKT_INSTR_SIZE (0x0000000000001020ull)
#define CVMX_SLI_PKT_INT_LEVELS (0x0000000000001120ull)
#define CVMX_SLI_PKT_IN_BP (0x0000000000001210ull)
#define CVMX_SLI_PKT_IN_DONEX_CNTS(offset) (0x0000000000002000ull + ((offset) & 31) * 16)
#define CVMX_SLI_PKT_IN_INSTR_COUNTS (0x0000000000001200ull)
#define CVMX_SLI_PKT_IN_PCIE_PORT (0x00000000000011B0ull)
#define CVMX_SLI_PKT_IPTR (0x0000000000001070ull)
#define CVMX_SLI_PKT_OUTPUT_WMARK (0x0000000000001180ull)
#define CVMX_SLI_PKT_OUT_BMODE (0x00000000000010D0ull)
#define CVMX_SLI_PKT_OUT_BP_EN (0x0000000000001240ull)
#define CVMX_SLI_PKT_OUT_ENB (0x0000000000001010ull)
#define CVMX_SLI_PKT_PCIE_PORT (0x00000000000010E0ull)
#define CVMX_SLI_PKT_PORT_IN_RST (0x00000000000011F0ull)
#define CVMX_SLI_PKT_SLIST_ES (0x0000000000001050ull)
#define CVMX_SLI_PKT_SLIST_NS (0x0000000000001040ull)
#define CVMX_SLI_PKT_SLIST_ROR (0x0000000000001030ull)
#define CVMX_SLI_PKT_TIME_INT (0x0000000000001140ull)
#define CVMX_SLI_PKT_TIME_INT_ENB (0x0000000000001160ull)
#define CVMX_SLI_PORTX_PKIND(offset) (0x0000000000000800ull + ((offset) & 31) * 16)
#define CVMX_SLI_S2M_PORTX_CTL(offset) (0x0000000000003D80ull + ((offset) & 3) * 16)
#define CVMX_SLI_SCRATCH_1 (0x00000000000003C0ull)
#define CVMX_SLI_SCRATCH_2 (0x00000000000003D0ull)
#define CVMX_SLI_STATE1 (0x0000000000000620ull)
#define CVMX_SLI_STATE2 (0x0000000000000630ull)
#define CVMX_SLI_STATE3 (0x0000000000000640ull)
#define CVMX_SLI_TX_PIPE (0x0000000000001230ull)
#define CVMX_SLI_WINDOW_CTL (0x00000000000002E0ull)
#define CVMX_SLI_WIN_RD_ADDR (0x0000000000000010ull)
#define CVMX_SLI_WIN_RD_DATA (0x0000000000000040ull)
#define CVMX_SLI_WIN_WR_ADDR (0x0000000000000000ull)
#define CVMX_SLI_WIN_WR_DATA (0x0000000000000020ull)
#define CVMX_SLI_WIN_WR_MASK (0x0000000000000030ull)

union cvmx_sli_bist_status {
	uint64_t u64;
	struct cvmx_sli_bist_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t ncb_req:1;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p1_o:1;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t reserved_19_24:6;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t reserved_6_8:3;
		uint64_t dsi1_1:1;
		uint64_t dsi1_0:1;
		uint64_t dsi0_1:1;
		uint64_t dsi0_0:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t dsi0_0:1;
		uint64_t dsi0_1:1;
		uint64_t dsi1_0:1;
		uint64_t dsi1_1:1;
		uint64_t reserved_6_8:3;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t reserved_19_24:6;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t n2p1_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t ncb_req:1;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_bist_status_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t reserved_27_28:2;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t reserved_19_24:6;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t reserved_6_8:3;
		uint64_t dsi1_1:1;
		uint64_t dsi1_0:1;
		uint64_t dsi0_1:1;
		uint64_t dsi0_0:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t dsi0_0:1;
		uint64_t dsi0_1:1;
		uint64_t dsi1_0:1;
		uint64_t dsi1_1:1;
		uint64_t reserved_6_8:3;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t reserved_19_24:6;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t reserved_27_28:2;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t reserved_31_63:33;
#endif
	} cn61xx;
	struct cvmx_sli_bist_status_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t n2p0_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p1_o:1;
		uint64_t cpl_p0:1;
		uint64_t cpl_p1:1;
		uint64_t reserved_19_24:6;
		uint64_t p2n0_c0:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_p1:1;
		uint64_t reserved_6_8:3;
		uint64_t dsi1_1:1;
		uint64_t dsi1_0:1;
		uint64_t dsi0_1:1;
		uint64_t dsi0_0:1;
		uint64_t msi:1;
		uint64_t ncb_cmd:1;
#else
		uint64_t ncb_cmd:1;
		uint64_t msi:1;
		uint64_t dsi0_0:1;
		uint64_t dsi0_1:1;
		uint64_t dsi1_0:1;
		uint64_t dsi1_1:1;
		uint64_t reserved_6_8:3;
		uint64_t p2n1_p1:1;
		uint64_t p2n1_p0:1;
		uint64_t p2n1_n:1;
		uint64_t p2n1_c1:1;
		uint64_t p2n1_c0:1;
		uint64_t p2n0_p1:1;
		uint64_t p2n0_p0:1;
		uint64_t p2n0_n:1;
		uint64_t p2n0_c1:1;
		uint64_t p2n0_c0:1;
		uint64_t reserved_19_24:6;
		uint64_t cpl_p1:1;
		uint64_t cpl_p0:1;
		uint64_t n2p1_o:1;
		uint64_t n2p1_c:1;
		uint64_t n2p0_o:1;
		uint64_t n2p0_c:1;
		uint64_t reserved_31_63:33;
#endif
	} cn63xx;
	struct cvmx_sli_bist_status_cn63xx cn63xxp1;
	struct cvmx_sli_bist_status_cn61xx cn66xx;
	struct cvmx_sli_bist_status_s cn68xx;
	struct cvmx_sli_bist_status_s cn68xxp1;
	struct cvmx_sli_bist_status_cn61xx cnf71xx;
};

union cvmx_sli_ctl_portx {
	uint64_t u64;
	struct cvmx_sli_ctl_portx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_22_63:42;
		uint64_t intd:1;
		uint64_t intc:1;
		uint64_t intb:1;
		uint64_t inta:1;
		uint64_t dis_port:1;
		uint64_t waitl_com:1;
		uint64_t intd_map:2;
		uint64_t intc_map:2;
		uint64_t intb_map:2;
		uint64_t inta_map:2;
		uint64_t ctlp_ro:1;
		uint64_t reserved_6_6:1;
		uint64_t ptlp_ro:1;
		uint64_t reserved_1_4:4;
		uint64_t wait_com:1;
#else
		uint64_t wait_com:1;
		uint64_t reserved_1_4:4;
		uint64_t ptlp_ro:1;
		uint64_t reserved_6_6:1;
		uint64_t ctlp_ro:1;
		uint64_t inta_map:2;
		uint64_t intb_map:2;
		uint64_t intc_map:2;
		uint64_t intd_map:2;
		uint64_t waitl_com:1;
		uint64_t dis_port:1;
		uint64_t inta:1;
		uint64_t intb:1;
		uint64_t intc:1;
		uint64_t intd:1;
		uint64_t reserved_22_63:42;
#endif
	} s;
	struct cvmx_sli_ctl_portx_s cn61xx;
	struct cvmx_sli_ctl_portx_s cn63xx;
	struct cvmx_sli_ctl_portx_s cn63xxp1;
	struct cvmx_sli_ctl_portx_s cn66xx;
	struct cvmx_sli_ctl_portx_s cn68xx;
	struct cvmx_sli_ctl_portx_s cn68xxp1;
	struct cvmx_sli_ctl_portx_s cnf71xx;
};

union cvmx_sli_ctl_status {
	uint64_t u64;
	struct cvmx_sli_ctl_status_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t p1_ntags:6;
		uint64_t p0_ntags:6;
		uint64_t chip_rev:8;
#else
		uint64_t chip_rev:8;
		uint64_t p0_ntags:6;
		uint64_t p1_ntags:6;
		uint64_t reserved_20_63:44;
#endif
	} s;
	struct cvmx_sli_ctl_status_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t p0_ntags:6;
		uint64_t chip_rev:8;
#else
		uint64_t chip_rev:8;
		uint64_t p0_ntags:6;
		uint64_t reserved_14_63:50;
#endif
	} cn61xx;
	struct cvmx_sli_ctl_status_s cn63xx;
	struct cvmx_sli_ctl_status_s cn63xxp1;
	struct cvmx_sli_ctl_status_cn61xx cn66xx;
	struct cvmx_sli_ctl_status_s cn68xx;
	struct cvmx_sli_ctl_status_s cn68xxp1;
	struct cvmx_sli_ctl_status_cn61xx cnf71xx;
};

union cvmx_sli_data_out_cnt {
	uint64_t u64;
	struct cvmx_sli_data_out_cnt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t p1_ucnt:16;
		uint64_t p1_fcnt:6;
		uint64_t p0_ucnt:16;
		uint64_t p0_fcnt:6;
#else
		uint64_t p0_fcnt:6;
		uint64_t p0_ucnt:16;
		uint64_t p1_fcnt:6;
		uint64_t p1_ucnt:16;
		uint64_t reserved_44_63:20;
#endif
	} s;
	struct cvmx_sli_data_out_cnt_s cn61xx;
	struct cvmx_sli_data_out_cnt_s cn63xx;
	struct cvmx_sli_data_out_cnt_s cn63xxp1;
	struct cvmx_sli_data_out_cnt_s cn66xx;
	struct cvmx_sli_data_out_cnt_s cn68xx;
	struct cvmx_sli_data_out_cnt_s cn68xxp1;
	struct cvmx_sli_data_out_cnt_s cnf71xx;
};

union cvmx_sli_dbg_data {
	uint64_t u64;
	struct cvmx_sli_dbg_data_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_18_63:46;
		uint64_t dsel_ext:1;
		uint64_t data:17;
#else
		uint64_t data:17;
		uint64_t dsel_ext:1;
		uint64_t reserved_18_63:46;
#endif
	} s;
	struct cvmx_sli_dbg_data_s cn61xx;
	struct cvmx_sli_dbg_data_s cn63xx;
	struct cvmx_sli_dbg_data_s cn63xxp1;
	struct cvmx_sli_dbg_data_s cn66xx;
	struct cvmx_sli_dbg_data_s cn68xx;
	struct cvmx_sli_dbg_data_s cn68xxp1;
	struct cvmx_sli_dbg_data_s cnf71xx;
};

union cvmx_sli_dbg_select {
	uint64_t u64;
	struct cvmx_sli_dbg_select_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_33_63:31;
		uint64_t adbg_sel:1;
		uint64_t dbg_sel:32;
#else
		uint64_t dbg_sel:32;
		uint64_t adbg_sel:1;
		uint64_t reserved_33_63:31;
#endif
	} s;
	struct cvmx_sli_dbg_select_s cn61xx;
	struct cvmx_sli_dbg_select_s cn63xx;
	struct cvmx_sli_dbg_select_s cn63xxp1;
	struct cvmx_sli_dbg_select_s cn66xx;
	struct cvmx_sli_dbg_select_s cn68xx;
	struct cvmx_sli_dbg_select_s cn68xxp1;
	struct cvmx_sli_dbg_select_s cnf71xx;
};

union cvmx_sli_dmax_cnt {
	uint64_t u64;
	struct cvmx_sli_dmax_cnt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_dmax_cnt_s cn61xx;
	struct cvmx_sli_dmax_cnt_s cn63xx;
	struct cvmx_sli_dmax_cnt_s cn63xxp1;
	struct cvmx_sli_dmax_cnt_s cn66xx;
	struct cvmx_sli_dmax_cnt_s cn68xx;
	struct cvmx_sli_dmax_cnt_s cn68xxp1;
	struct cvmx_sli_dmax_cnt_s cnf71xx;
};

union cvmx_sli_dmax_int_level {
	uint64_t u64;
	struct cvmx_sli_dmax_int_level_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t time:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t time:32;
#endif
	} s;
	struct cvmx_sli_dmax_int_level_s cn61xx;
	struct cvmx_sli_dmax_int_level_s cn63xx;
	struct cvmx_sli_dmax_int_level_s cn63xxp1;
	struct cvmx_sli_dmax_int_level_s cn66xx;
	struct cvmx_sli_dmax_int_level_s cn68xx;
	struct cvmx_sli_dmax_int_level_s cn68xxp1;
	struct cvmx_sli_dmax_int_level_s cnf71xx;
};

union cvmx_sli_dmax_tim {
	uint64_t u64;
	struct cvmx_sli_dmax_tim_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t tim:32;
#else
		uint64_t tim:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_dmax_tim_s cn61xx;
	struct cvmx_sli_dmax_tim_s cn63xx;
	struct cvmx_sli_dmax_tim_s cn63xxp1;
	struct cvmx_sli_dmax_tim_s cn66xx;
	struct cvmx_sli_dmax_tim_s cn68xx;
	struct cvmx_sli_dmax_tim_s cn68xxp1;
	struct cvmx_sli_dmax_tim_s cnf71xx;
};

union cvmx_sli_int_enb_ciu {
	uint64_t u64;
	struct cvmx_sli_int_enb_ciu_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t pipe_err:1;
		uint64_t ill_pad:1;
		uint64_t sprt3_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_28_31:4;
		uint64_t m3_un_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_up_b0:1;
		uint64_t reserved_18_19:2;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t reserved_18_19:2;
		uint64_t m2_up_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_un_wi:1;
		uint64_t reserved_28_31:4;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt3_err:1;
		uint64_t ill_pad:1;
		uint64_t pipe_err:1;
		uint64_t reserved_62_63:2;
#endif
	} s;
	struct cvmx_sli_int_enb_ciu_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t ill_pad:1;
		uint64_t sprt3_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_28_31:4;
		uint64_t m3_un_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_up_b0:1;
		uint64_t reserved_18_19:2;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t reserved_18_19:2;
		uint64_t m2_up_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_un_wi:1;
		uint64_t reserved_28_31:4;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt3_err:1;
		uint64_t ill_pad:1;
		uint64_t reserved_61_63:3;
#endif
	} cn61xx;
	struct cvmx_sli_int_enb_ciu_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t ill_pad:1;
		uint64_t reserved_58_59:2;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_18_31:14;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t reserved_18_31:14;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t reserved_58_59:2;
		uint64_t ill_pad:1;
		uint64_t reserved_61_63:3;
#endif
	} cn63xx;
	struct cvmx_sli_int_enb_ciu_cn63xx cn63xxp1;
	struct cvmx_sli_int_enb_ciu_cn61xx cn66xx;
	struct cvmx_sli_int_enb_ciu_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t pipe_err:1;
		uint64_t ill_pad:1;
		uint64_t reserved_58_59:2;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t reserved_51_51:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_18_31:14;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t reserved_18_31:14;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t reserved_51_51:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t reserved_58_59:2;
		uint64_t ill_pad:1;
		uint64_t pipe_err:1;
		uint64_t reserved_62_63:2;
#endif
	} cn68xx;
	struct cvmx_sli_int_enb_ciu_cn68xx cn68xxp1;
	struct cvmx_sli_int_enb_ciu_cn61xx cnf71xx;
};

union cvmx_sli_int_enb_portx {
	uint64_t u64;
	struct cvmx_sli_int_enb_portx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t pipe_err:1;
		uint64_t ill_pad:1;
		uint64_t sprt3_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_28_31:4;
		uint64_t m3_un_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_up_b0:1;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t m2_up_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_un_wi:1;
		uint64_t reserved_28_31:4;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt3_err:1;
		uint64_t ill_pad:1;
		uint64_t pipe_err:1;
		uint64_t reserved_62_63:2;
#endif
	} s;
	struct cvmx_sli_int_enb_portx_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t ill_pad:1;
		uint64_t sprt3_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_28_31:4;
		uint64_t m3_un_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_up_b0:1;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t m2_up_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_un_wi:1;
		uint64_t reserved_28_31:4;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt3_err:1;
		uint64_t ill_pad:1;
		uint64_t reserved_61_63:3;
#endif
	} cn61xx;
	struct cvmx_sli_int_enb_portx_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t ill_pad:1;
		uint64_t reserved_58_59:2;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_20_31:12;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t reserved_20_31:12;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t reserved_58_59:2;
		uint64_t ill_pad:1;
		uint64_t reserved_61_63:3;
#endif
	} cn63xx;
	struct cvmx_sli_int_enb_portx_cn63xx cn63xxp1;
	struct cvmx_sli_int_enb_portx_cn61xx cn66xx;
	struct cvmx_sli_int_enb_portx_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t pipe_err:1;
		uint64_t ill_pad:1;
		uint64_t reserved_58_59:2;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t reserved_51_51:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_20_31:12;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t reserved_20_31:12;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t reserved_51_51:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t reserved_58_59:2;
		uint64_t ill_pad:1;
		uint64_t pipe_err:1;
		uint64_t reserved_62_63:2;
#endif
	} cn68xx;
	struct cvmx_sli_int_enb_portx_cn68xx cn68xxp1;
	struct cvmx_sli_int_enb_portx_cn61xx cnf71xx;
};

union cvmx_sli_int_sum {
	uint64_t u64;
	struct cvmx_sli_int_sum_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t pipe_err:1;
		uint64_t ill_pad:1;
		uint64_t sprt3_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_28_31:4;
		uint64_t m3_un_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_up_b0:1;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t m2_up_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_un_wi:1;
		uint64_t reserved_28_31:4;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt3_err:1;
		uint64_t ill_pad:1;
		uint64_t pipe_err:1;
		uint64_t reserved_62_63:2;
#endif
	} s;
	struct cvmx_sli_int_sum_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t ill_pad:1;
		uint64_t sprt3_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_28_31:4;
		uint64_t m3_un_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_up_b0:1;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t m2_up_b0:1;
		uint64_t m2_up_wi:1;
		uint64_t m2_un_b0:1;
		uint64_t m2_un_wi:1;
		uint64_t m3_up_b0:1;
		uint64_t m3_up_wi:1;
		uint64_t m3_un_b0:1;
		uint64_t m3_un_wi:1;
		uint64_t reserved_28_31:4;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t sprt2_err:1;
		uint64_t sprt3_err:1;
		uint64_t ill_pad:1;
		uint64_t reserved_61_63:3;
#endif
	} cn61xx;
	struct cvmx_sli_int_sum_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_61_63:3;
		uint64_t ill_pad:1;
		uint64_t reserved_58_59:2;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t pin_bp:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_20_31:12;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t reserved_20_31:12;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t pin_bp:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t reserved_58_59:2;
		uint64_t ill_pad:1;
		uint64_t reserved_61_63:3;
#endif
	} cn63xx;
	struct cvmx_sli_int_sum_cn63xx cn63xxp1;
	struct cvmx_sli_int_sum_cn61xx cn66xx;
	struct cvmx_sli_int_sum_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t pipe_err:1;
		uint64_t ill_pad:1;
		uint64_t reserved_58_59:2;
		uint64_t sprt1_err:1;
		uint64_t sprt0_err:1;
		uint64_t pins_err:1;
		uint64_t pop_err:1;
		uint64_t pdi_err:1;
		uint64_t pgl_err:1;
		uint64_t reserved_51_51:1;
		uint64_t pout_err:1;
		uint64_t psldbof:1;
		uint64_t pidbof:1;
		uint64_t reserved_38_47:10;
		uint64_t dtime:2;
		uint64_t dcnt:2;
		uint64_t dmafi:2;
		uint64_t reserved_20_31:12;
		uint64_t mac1_int:1;
		uint64_t mac0_int:1;
		uint64_t mio_int1:1;
		uint64_t mio_int0:1;
		uint64_t m1_un_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_up_b0:1;
		uint64_t reserved_6_7:2;
		uint64_t ptime:1;
		uint64_t pcnt:1;
		uint64_t iob2big:1;
		uint64_t bar0_to:1;
		uint64_t reserved_1_1:1;
		uint64_t rml_to:1;
#else
		uint64_t rml_to:1;
		uint64_t reserved_1_1:1;
		uint64_t bar0_to:1;
		uint64_t iob2big:1;
		uint64_t pcnt:1;
		uint64_t ptime:1;
		uint64_t reserved_6_7:2;
		uint64_t m0_up_b0:1;
		uint64_t m0_up_wi:1;
		uint64_t m0_un_b0:1;
		uint64_t m0_un_wi:1;
		uint64_t m1_up_b0:1;
		uint64_t m1_up_wi:1;
		uint64_t m1_un_b0:1;
		uint64_t m1_un_wi:1;
		uint64_t mio_int0:1;
		uint64_t mio_int1:1;
		uint64_t mac0_int:1;
		uint64_t mac1_int:1;
		uint64_t reserved_20_31:12;
		uint64_t dmafi:2;
		uint64_t dcnt:2;
		uint64_t dtime:2;
		uint64_t reserved_38_47:10;
		uint64_t pidbof:1;
		uint64_t psldbof:1;
		uint64_t pout_err:1;
		uint64_t reserved_51_51:1;
		uint64_t pgl_err:1;
		uint64_t pdi_err:1;
		uint64_t pop_err:1;
		uint64_t pins_err:1;
		uint64_t sprt0_err:1;
		uint64_t sprt1_err:1;
		uint64_t reserved_58_59:2;
		uint64_t ill_pad:1;
		uint64_t pipe_err:1;
		uint64_t reserved_62_63:2;
#endif
	} cn68xx;
	struct cvmx_sli_int_sum_cn68xx cn68xxp1;
	struct cvmx_sli_int_sum_cn61xx cnf71xx;
};

union cvmx_sli_last_win_rdata0 {
	uint64_t u64;
	struct cvmx_sli_last_win_rdata0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_sli_last_win_rdata0_s cn61xx;
	struct cvmx_sli_last_win_rdata0_s cn63xx;
	struct cvmx_sli_last_win_rdata0_s cn63xxp1;
	struct cvmx_sli_last_win_rdata0_s cn66xx;
	struct cvmx_sli_last_win_rdata0_s cn68xx;
	struct cvmx_sli_last_win_rdata0_s cn68xxp1;
	struct cvmx_sli_last_win_rdata0_s cnf71xx;
};

union cvmx_sli_last_win_rdata1 {
	uint64_t u64;
	struct cvmx_sli_last_win_rdata1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_sli_last_win_rdata1_s cn61xx;
	struct cvmx_sli_last_win_rdata1_s cn63xx;
	struct cvmx_sli_last_win_rdata1_s cn63xxp1;
	struct cvmx_sli_last_win_rdata1_s cn66xx;
	struct cvmx_sli_last_win_rdata1_s cn68xx;
	struct cvmx_sli_last_win_rdata1_s cn68xxp1;
	struct cvmx_sli_last_win_rdata1_s cnf71xx;
};

union cvmx_sli_last_win_rdata2 {
	uint64_t u64;
	struct cvmx_sli_last_win_rdata2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_sli_last_win_rdata2_s cn61xx;
	struct cvmx_sli_last_win_rdata2_s cn66xx;
	struct cvmx_sli_last_win_rdata2_s cnf71xx;
};

union cvmx_sli_last_win_rdata3 {
	uint64_t u64;
	struct cvmx_sli_last_win_rdata3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_sli_last_win_rdata3_s cn61xx;
	struct cvmx_sli_last_win_rdata3_s cn66xx;
	struct cvmx_sli_last_win_rdata3_s cnf71xx;
};

union cvmx_sli_mac_credit_cnt {
	uint64_t u64;
	struct cvmx_sli_mac_credit_cnt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_54_63:10;
		uint64_t p1_c_d:1;
		uint64_t p1_n_d:1;
		uint64_t p1_p_d:1;
		uint64_t p0_c_d:1;
		uint64_t p0_n_d:1;
		uint64_t p0_p_d:1;
		uint64_t p1_ccnt:8;
		uint64_t p1_ncnt:8;
		uint64_t p1_pcnt:8;
		uint64_t p0_ccnt:8;
		uint64_t p0_ncnt:8;
		uint64_t p0_pcnt:8;
#else
		uint64_t p0_pcnt:8;
		uint64_t p0_ncnt:8;
		uint64_t p0_ccnt:8;
		uint64_t p1_pcnt:8;
		uint64_t p1_ncnt:8;
		uint64_t p1_ccnt:8;
		uint64_t p0_p_d:1;
		uint64_t p0_n_d:1;
		uint64_t p0_c_d:1;
		uint64_t p1_p_d:1;
		uint64_t p1_n_d:1;
		uint64_t p1_c_d:1;
		uint64_t reserved_54_63:10;
#endif
	} s;
	struct cvmx_sli_mac_credit_cnt_s cn61xx;
	struct cvmx_sli_mac_credit_cnt_s cn63xx;
	struct cvmx_sli_mac_credit_cnt_cn63xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_48_63:16;
		uint64_t p1_ccnt:8;
		uint64_t p1_ncnt:8;
		uint64_t p1_pcnt:8;
		uint64_t p0_ccnt:8;
		uint64_t p0_ncnt:8;
		uint64_t p0_pcnt:8;
#else
		uint64_t p0_pcnt:8;
		uint64_t p0_ncnt:8;
		uint64_t p0_ccnt:8;
		uint64_t p1_pcnt:8;
		uint64_t p1_ncnt:8;
		uint64_t p1_ccnt:8;
		uint64_t reserved_48_63:16;
#endif
	} cn63xxp1;
	struct cvmx_sli_mac_credit_cnt_s cn66xx;
	struct cvmx_sli_mac_credit_cnt_s cn68xx;
	struct cvmx_sli_mac_credit_cnt_s cn68xxp1;
	struct cvmx_sli_mac_credit_cnt_s cnf71xx;
};

union cvmx_sli_mac_credit_cnt2 {
	uint64_t u64;
	struct cvmx_sli_mac_credit_cnt2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_54_63:10;
		uint64_t p3_c_d:1;
		uint64_t p3_n_d:1;
		uint64_t p3_p_d:1;
		uint64_t p2_c_d:1;
		uint64_t p2_n_d:1;
		uint64_t p2_p_d:1;
		uint64_t p3_ccnt:8;
		uint64_t p3_ncnt:8;
		uint64_t p3_pcnt:8;
		uint64_t p2_ccnt:8;
		uint64_t p2_ncnt:8;
		uint64_t p2_pcnt:8;
#else
		uint64_t p2_pcnt:8;
		uint64_t p2_ncnt:8;
		uint64_t p2_ccnt:8;
		uint64_t p3_pcnt:8;
		uint64_t p3_ncnt:8;
		uint64_t p3_ccnt:8;
		uint64_t p2_p_d:1;
		uint64_t p2_n_d:1;
		uint64_t p2_c_d:1;
		uint64_t p3_p_d:1;
		uint64_t p3_n_d:1;
		uint64_t p3_c_d:1;
		uint64_t reserved_54_63:10;
#endif
	} s;
	struct cvmx_sli_mac_credit_cnt2_s cn61xx;
	struct cvmx_sli_mac_credit_cnt2_s cn66xx;
	struct cvmx_sli_mac_credit_cnt2_s cnf71xx;
};

union cvmx_sli_mac_number {
	uint64_t u64;
	struct cvmx_sli_mac_number_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t a_mode:1;
		uint64_t num:8;
#else
		uint64_t num:8;
		uint64_t a_mode:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_sli_mac_number_s cn61xx;
	struct cvmx_sli_mac_number_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t num:8;
#else
		uint64_t num:8;
		uint64_t reserved_8_63:56;
#endif
	} cn63xx;
	struct cvmx_sli_mac_number_s cn66xx;
	struct cvmx_sli_mac_number_cn63xx cn68xx;
	struct cvmx_sli_mac_number_cn63xx cn68xxp1;
	struct cvmx_sli_mac_number_s cnf71xx;
};

union cvmx_sli_mem_access_ctl {
	uint64_t u64;
	struct cvmx_sli_mem_access_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t max_word:4;
		uint64_t timer:10;
#else
		uint64_t timer:10;
		uint64_t max_word:4;
		uint64_t reserved_14_63:50;
#endif
	} s;
	struct cvmx_sli_mem_access_ctl_s cn61xx;
	struct cvmx_sli_mem_access_ctl_s cn63xx;
	struct cvmx_sli_mem_access_ctl_s cn63xxp1;
	struct cvmx_sli_mem_access_ctl_s cn66xx;
	struct cvmx_sli_mem_access_ctl_s cn68xx;
	struct cvmx_sli_mem_access_ctl_s cn68xxp1;
	struct cvmx_sli_mem_access_ctl_s cnf71xx;
};

union cvmx_sli_mem_access_subidx {
	uint64_t u64;
	struct cvmx_sli_mem_access_subidx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_43_63:21;
		uint64_t zero:1;
		uint64_t port:3;
		uint64_t nmerge:1;
		uint64_t esr:2;
		uint64_t esw:2;
		uint64_t wtype:2;
		uint64_t rtype:2;
		uint64_t reserved_0_29:30;
#else
		uint64_t reserved_0_29:30;
		uint64_t rtype:2;
		uint64_t wtype:2;
		uint64_t esw:2;
		uint64_t esr:2;
		uint64_t nmerge:1;
		uint64_t port:3;
		uint64_t zero:1;
		uint64_t reserved_43_63:21;
#endif
	} s;
	struct cvmx_sli_mem_access_subidx_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_43_63:21;
		uint64_t zero:1;
		uint64_t port:3;
		uint64_t nmerge:1;
		uint64_t esr:2;
		uint64_t esw:2;
		uint64_t wtype:2;
		uint64_t rtype:2;
		uint64_t ba:30;
#else
		uint64_t ba:30;
		uint64_t rtype:2;
		uint64_t wtype:2;
		uint64_t esw:2;
		uint64_t esr:2;
		uint64_t nmerge:1;
		uint64_t port:3;
		uint64_t zero:1;
		uint64_t reserved_43_63:21;
#endif
	} cn61xx;
	struct cvmx_sli_mem_access_subidx_cn61xx cn63xx;
	struct cvmx_sli_mem_access_subidx_cn61xx cn63xxp1;
	struct cvmx_sli_mem_access_subidx_cn61xx cn66xx;
	struct cvmx_sli_mem_access_subidx_cn68xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_43_63:21;
		uint64_t zero:1;
		uint64_t port:3;
		uint64_t nmerge:1;
		uint64_t esr:2;
		uint64_t esw:2;
		uint64_t wtype:2;
		uint64_t rtype:2;
		uint64_t ba:28;
		uint64_t reserved_0_1:2;
#else
		uint64_t reserved_0_1:2;
		uint64_t ba:28;
		uint64_t rtype:2;
		uint64_t wtype:2;
		uint64_t esw:2;
		uint64_t esr:2;
		uint64_t nmerge:1;
		uint64_t port:3;
		uint64_t zero:1;
		uint64_t reserved_43_63:21;
#endif
	} cn68xx;
	struct cvmx_sli_mem_access_subidx_cn68xx cn68xxp1;
	struct cvmx_sli_mem_access_subidx_cn61xx cnf71xx;
};

union cvmx_sli_msi_enb0 {
	uint64_t u64;
	struct cvmx_sli_msi_enb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_sli_msi_enb0_s cn61xx;
	struct cvmx_sli_msi_enb0_s cn63xx;
	struct cvmx_sli_msi_enb0_s cn63xxp1;
	struct cvmx_sli_msi_enb0_s cn66xx;
	struct cvmx_sli_msi_enb0_s cn68xx;
	struct cvmx_sli_msi_enb0_s cn68xxp1;
	struct cvmx_sli_msi_enb0_s cnf71xx;
};

union cvmx_sli_msi_enb1 {
	uint64_t u64;
	struct cvmx_sli_msi_enb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_sli_msi_enb1_s cn61xx;
	struct cvmx_sli_msi_enb1_s cn63xx;
	struct cvmx_sli_msi_enb1_s cn63xxp1;
	struct cvmx_sli_msi_enb1_s cn66xx;
	struct cvmx_sli_msi_enb1_s cn68xx;
	struct cvmx_sli_msi_enb1_s cn68xxp1;
	struct cvmx_sli_msi_enb1_s cnf71xx;
};

union cvmx_sli_msi_enb2 {
	uint64_t u64;
	struct cvmx_sli_msi_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_sli_msi_enb2_s cn61xx;
	struct cvmx_sli_msi_enb2_s cn63xx;
	struct cvmx_sli_msi_enb2_s cn63xxp1;
	struct cvmx_sli_msi_enb2_s cn66xx;
	struct cvmx_sli_msi_enb2_s cn68xx;
	struct cvmx_sli_msi_enb2_s cn68xxp1;
	struct cvmx_sli_msi_enb2_s cnf71xx;
};

union cvmx_sli_msi_enb3 {
	uint64_t u64;
	struct cvmx_sli_msi_enb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t enb:64;
#else
		uint64_t enb:64;
#endif
	} s;
	struct cvmx_sli_msi_enb3_s cn61xx;
	struct cvmx_sli_msi_enb3_s cn63xx;
	struct cvmx_sli_msi_enb3_s cn63xxp1;
	struct cvmx_sli_msi_enb3_s cn66xx;
	struct cvmx_sli_msi_enb3_s cn68xx;
	struct cvmx_sli_msi_enb3_s cn68xxp1;
	struct cvmx_sli_msi_enb3_s cnf71xx;
};

union cvmx_sli_msi_rcv0 {
	uint64_t u64;
	struct cvmx_sli_msi_rcv0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_sli_msi_rcv0_s cn61xx;
	struct cvmx_sli_msi_rcv0_s cn63xx;
	struct cvmx_sli_msi_rcv0_s cn63xxp1;
	struct cvmx_sli_msi_rcv0_s cn66xx;
	struct cvmx_sli_msi_rcv0_s cn68xx;
	struct cvmx_sli_msi_rcv0_s cn68xxp1;
	struct cvmx_sli_msi_rcv0_s cnf71xx;
};

union cvmx_sli_msi_rcv1 {
	uint64_t u64;
	struct cvmx_sli_msi_rcv1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_sli_msi_rcv1_s cn61xx;
	struct cvmx_sli_msi_rcv1_s cn63xx;
	struct cvmx_sli_msi_rcv1_s cn63xxp1;
	struct cvmx_sli_msi_rcv1_s cn66xx;
	struct cvmx_sli_msi_rcv1_s cn68xx;
	struct cvmx_sli_msi_rcv1_s cn68xxp1;
	struct cvmx_sli_msi_rcv1_s cnf71xx;
};

union cvmx_sli_msi_rcv2 {
	uint64_t u64;
	struct cvmx_sli_msi_rcv2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_sli_msi_rcv2_s cn61xx;
	struct cvmx_sli_msi_rcv2_s cn63xx;
	struct cvmx_sli_msi_rcv2_s cn63xxp1;
	struct cvmx_sli_msi_rcv2_s cn66xx;
	struct cvmx_sli_msi_rcv2_s cn68xx;
	struct cvmx_sli_msi_rcv2_s cn68xxp1;
	struct cvmx_sli_msi_rcv2_s cnf71xx;
};

union cvmx_sli_msi_rcv3 {
	uint64_t u64;
	struct cvmx_sli_msi_rcv3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t intr:64;
#else
		uint64_t intr:64;
#endif
	} s;
	struct cvmx_sli_msi_rcv3_s cn61xx;
	struct cvmx_sli_msi_rcv3_s cn63xx;
	struct cvmx_sli_msi_rcv3_s cn63xxp1;
	struct cvmx_sli_msi_rcv3_s cn66xx;
	struct cvmx_sli_msi_rcv3_s cn68xx;
	struct cvmx_sli_msi_rcv3_s cn68xxp1;
	struct cvmx_sli_msi_rcv3_s cnf71xx;
};

union cvmx_sli_msi_rd_map {
	uint64_t u64;
	struct cvmx_sli_msi_rd_map_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t rd_int:8;
		uint64_t msi_int:8;
#else
		uint64_t msi_int:8;
		uint64_t rd_int:8;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_sli_msi_rd_map_s cn61xx;
	struct cvmx_sli_msi_rd_map_s cn63xx;
	struct cvmx_sli_msi_rd_map_s cn63xxp1;
	struct cvmx_sli_msi_rd_map_s cn66xx;
	struct cvmx_sli_msi_rd_map_s cn68xx;
	struct cvmx_sli_msi_rd_map_s cn68xxp1;
	struct cvmx_sli_msi_rd_map_s cnf71xx;
};

union cvmx_sli_msi_w1c_enb0 {
	uint64_t u64;
	struct cvmx_sli_msi_w1c_enb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_sli_msi_w1c_enb0_s cn61xx;
	struct cvmx_sli_msi_w1c_enb0_s cn63xx;
	struct cvmx_sli_msi_w1c_enb0_s cn63xxp1;
	struct cvmx_sli_msi_w1c_enb0_s cn66xx;
	struct cvmx_sli_msi_w1c_enb0_s cn68xx;
	struct cvmx_sli_msi_w1c_enb0_s cn68xxp1;
	struct cvmx_sli_msi_w1c_enb0_s cnf71xx;
};

union cvmx_sli_msi_w1c_enb1 {
	uint64_t u64;
	struct cvmx_sli_msi_w1c_enb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_sli_msi_w1c_enb1_s cn61xx;
	struct cvmx_sli_msi_w1c_enb1_s cn63xx;
	struct cvmx_sli_msi_w1c_enb1_s cn63xxp1;
	struct cvmx_sli_msi_w1c_enb1_s cn66xx;
	struct cvmx_sli_msi_w1c_enb1_s cn68xx;
	struct cvmx_sli_msi_w1c_enb1_s cn68xxp1;
	struct cvmx_sli_msi_w1c_enb1_s cnf71xx;
};

union cvmx_sli_msi_w1c_enb2 {
	uint64_t u64;
	struct cvmx_sli_msi_w1c_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_sli_msi_w1c_enb2_s cn61xx;
	struct cvmx_sli_msi_w1c_enb2_s cn63xx;
	struct cvmx_sli_msi_w1c_enb2_s cn63xxp1;
	struct cvmx_sli_msi_w1c_enb2_s cn66xx;
	struct cvmx_sli_msi_w1c_enb2_s cn68xx;
	struct cvmx_sli_msi_w1c_enb2_s cn68xxp1;
	struct cvmx_sli_msi_w1c_enb2_s cnf71xx;
};

union cvmx_sli_msi_w1c_enb3 {
	uint64_t u64;
	struct cvmx_sli_msi_w1c_enb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t clr:64;
#else
		uint64_t clr:64;
#endif
	} s;
	struct cvmx_sli_msi_w1c_enb3_s cn61xx;
	struct cvmx_sli_msi_w1c_enb3_s cn63xx;
	struct cvmx_sli_msi_w1c_enb3_s cn63xxp1;
	struct cvmx_sli_msi_w1c_enb3_s cn66xx;
	struct cvmx_sli_msi_w1c_enb3_s cn68xx;
	struct cvmx_sli_msi_w1c_enb3_s cn68xxp1;
	struct cvmx_sli_msi_w1c_enb3_s cnf71xx;
};

union cvmx_sli_msi_w1s_enb0 {
	uint64_t u64;
	struct cvmx_sli_msi_w1s_enb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_sli_msi_w1s_enb0_s cn61xx;
	struct cvmx_sli_msi_w1s_enb0_s cn63xx;
	struct cvmx_sli_msi_w1s_enb0_s cn63xxp1;
	struct cvmx_sli_msi_w1s_enb0_s cn66xx;
	struct cvmx_sli_msi_w1s_enb0_s cn68xx;
	struct cvmx_sli_msi_w1s_enb0_s cn68xxp1;
	struct cvmx_sli_msi_w1s_enb0_s cnf71xx;
};

union cvmx_sli_msi_w1s_enb1 {
	uint64_t u64;
	struct cvmx_sli_msi_w1s_enb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_sli_msi_w1s_enb1_s cn61xx;
	struct cvmx_sli_msi_w1s_enb1_s cn63xx;
	struct cvmx_sli_msi_w1s_enb1_s cn63xxp1;
	struct cvmx_sli_msi_w1s_enb1_s cn66xx;
	struct cvmx_sli_msi_w1s_enb1_s cn68xx;
	struct cvmx_sli_msi_w1s_enb1_s cn68xxp1;
	struct cvmx_sli_msi_w1s_enb1_s cnf71xx;
};

union cvmx_sli_msi_w1s_enb2 {
	uint64_t u64;
	struct cvmx_sli_msi_w1s_enb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_sli_msi_w1s_enb2_s cn61xx;
	struct cvmx_sli_msi_w1s_enb2_s cn63xx;
	struct cvmx_sli_msi_w1s_enb2_s cn63xxp1;
	struct cvmx_sli_msi_w1s_enb2_s cn66xx;
	struct cvmx_sli_msi_w1s_enb2_s cn68xx;
	struct cvmx_sli_msi_w1s_enb2_s cn68xxp1;
	struct cvmx_sli_msi_w1s_enb2_s cnf71xx;
};

union cvmx_sli_msi_w1s_enb3 {
	uint64_t u64;
	struct cvmx_sli_msi_w1s_enb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t set:64;
#else
		uint64_t set:64;
#endif
	} s;
	struct cvmx_sli_msi_w1s_enb3_s cn61xx;
	struct cvmx_sli_msi_w1s_enb3_s cn63xx;
	struct cvmx_sli_msi_w1s_enb3_s cn63xxp1;
	struct cvmx_sli_msi_w1s_enb3_s cn66xx;
	struct cvmx_sli_msi_w1s_enb3_s cn68xx;
	struct cvmx_sli_msi_w1s_enb3_s cn68xxp1;
	struct cvmx_sli_msi_w1s_enb3_s cnf71xx;
};

union cvmx_sli_msi_wr_map {
	uint64_t u64;
	struct cvmx_sli_msi_wr_map_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t ciu_int:8;
		uint64_t msi_int:8;
#else
		uint64_t msi_int:8;
		uint64_t ciu_int:8;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_sli_msi_wr_map_s cn61xx;
	struct cvmx_sli_msi_wr_map_s cn63xx;
	struct cvmx_sli_msi_wr_map_s cn63xxp1;
	struct cvmx_sli_msi_wr_map_s cn66xx;
	struct cvmx_sli_msi_wr_map_s cn68xx;
	struct cvmx_sli_msi_wr_map_s cn68xxp1;
	struct cvmx_sli_msi_wr_map_s cnf71xx;
};

union cvmx_sli_pcie_msi_rcv {
	uint64_t u64;
	struct cvmx_sli_pcie_msi_rcv_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t intr:8;
#else
		uint64_t intr:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_sli_pcie_msi_rcv_s cn61xx;
	struct cvmx_sli_pcie_msi_rcv_s cn63xx;
	struct cvmx_sli_pcie_msi_rcv_s cn63xxp1;
	struct cvmx_sli_pcie_msi_rcv_s cn66xx;
	struct cvmx_sli_pcie_msi_rcv_s cn68xx;
	struct cvmx_sli_pcie_msi_rcv_s cn68xxp1;
	struct cvmx_sli_pcie_msi_rcv_s cnf71xx;
};

union cvmx_sli_pcie_msi_rcv_b1 {
	uint64_t u64;
	struct cvmx_sli_pcie_msi_rcv_b1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t intr:8;
		uint64_t reserved_0_7:8;
#else
		uint64_t reserved_0_7:8;
		uint64_t intr:8;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_sli_pcie_msi_rcv_b1_s cn61xx;
	struct cvmx_sli_pcie_msi_rcv_b1_s cn63xx;
	struct cvmx_sli_pcie_msi_rcv_b1_s cn63xxp1;
	struct cvmx_sli_pcie_msi_rcv_b1_s cn66xx;
	struct cvmx_sli_pcie_msi_rcv_b1_s cn68xx;
	struct cvmx_sli_pcie_msi_rcv_b1_s cn68xxp1;
	struct cvmx_sli_pcie_msi_rcv_b1_s cnf71xx;
};

union cvmx_sli_pcie_msi_rcv_b2 {
	uint64_t u64;
	struct cvmx_sli_pcie_msi_rcv_b2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t intr:8;
		uint64_t reserved_0_15:16;
#else
		uint64_t reserved_0_15:16;
		uint64_t intr:8;
		uint64_t reserved_24_63:40;
#endif
	} s;
	struct cvmx_sli_pcie_msi_rcv_b2_s cn61xx;
	struct cvmx_sli_pcie_msi_rcv_b2_s cn63xx;
	struct cvmx_sli_pcie_msi_rcv_b2_s cn63xxp1;
	struct cvmx_sli_pcie_msi_rcv_b2_s cn66xx;
	struct cvmx_sli_pcie_msi_rcv_b2_s cn68xx;
	struct cvmx_sli_pcie_msi_rcv_b2_s cn68xxp1;
	struct cvmx_sli_pcie_msi_rcv_b2_s cnf71xx;
};

union cvmx_sli_pcie_msi_rcv_b3 {
	uint64_t u64;
	struct cvmx_sli_pcie_msi_rcv_b3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t intr:8;
		uint64_t reserved_0_23:24;
#else
		uint64_t reserved_0_23:24;
		uint64_t intr:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pcie_msi_rcv_b3_s cn61xx;
	struct cvmx_sli_pcie_msi_rcv_b3_s cn63xx;
	struct cvmx_sli_pcie_msi_rcv_b3_s cn63xxp1;
	struct cvmx_sli_pcie_msi_rcv_b3_s cn66xx;
	struct cvmx_sli_pcie_msi_rcv_b3_s cn68xx;
	struct cvmx_sli_pcie_msi_rcv_b3_s cn68xxp1;
	struct cvmx_sli_pcie_msi_rcv_b3_s cnf71xx;
};

union cvmx_sli_pktx_cnts {
	uint64_t u64;
	struct cvmx_sli_pktx_cnts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_54_63:10;
		uint64_t timer:22;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t timer:22;
		uint64_t reserved_54_63:10;
#endif
	} s;
	struct cvmx_sli_pktx_cnts_s cn61xx;
	struct cvmx_sli_pktx_cnts_s cn63xx;
	struct cvmx_sli_pktx_cnts_s cn63xxp1;
	struct cvmx_sli_pktx_cnts_s cn66xx;
	struct cvmx_sli_pktx_cnts_s cn68xx;
	struct cvmx_sli_pktx_cnts_s cn68xxp1;
	struct cvmx_sli_pktx_cnts_s cnf71xx;
};

union cvmx_sli_pktx_in_bp {
	uint64_t u64;
	struct cvmx_sli_pktx_in_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wmark:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t wmark:32;
#endif
	} s;
	struct cvmx_sli_pktx_in_bp_s cn61xx;
	struct cvmx_sli_pktx_in_bp_s cn63xx;
	struct cvmx_sli_pktx_in_bp_s cn63xxp1;
	struct cvmx_sli_pktx_in_bp_s cn66xx;
	struct cvmx_sli_pktx_in_bp_s cnf71xx;
};

union cvmx_sli_pktx_instr_baddr {
	uint64_t u64;
	struct cvmx_sli_pktx_instr_baddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t addr:61;
		uint64_t reserved_0_2:3;
#else
		uint64_t reserved_0_2:3;
		uint64_t addr:61;
#endif
	} s;
	struct cvmx_sli_pktx_instr_baddr_s cn61xx;
	struct cvmx_sli_pktx_instr_baddr_s cn63xx;
	struct cvmx_sli_pktx_instr_baddr_s cn63xxp1;
	struct cvmx_sli_pktx_instr_baddr_s cn66xx;
	struct cvmx_sli_pktx_instr_baddr_s cn68xx;
	struct cvmx_sli_pktx_instr_baddr_s cn68xxp1;
	struct cvmx_sli_pktx_instr_baddr_s cnf71xx;
};

union cvmx_sli_pktx_instr_baoff_dbell {
	uint64_t u64;
	struct cvmx_sli_pktx_instr_baoff_dbell_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t aoff:32;
		uint64_t dbell:32;
#else
		uint64_t dbell:32;
		uint64_t aoff:32;
#endif
	} s;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cn61xx;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cn63xx;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cn63xxp1;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cn66xx;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cn68xx;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cn68xxp1;
	struct cvmx_sli_pktx_instr_baoff_dbell_s cnf71xx;
};

union cvmx_sli_pktx_instr_fifo_rsize {
	uint64_t u64;
	struct cvmx_sli_pktx_instr_fifo_rsize_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t max:9;
		uint64_t rrp:9;
		uint64_t wrp:9;
		uint64_t fcnt:5;
		uint64_t rsize:32;
#else
		uint64_t rsize:32;
		uint64_t fcnt:5;
		uint64_t wrp:9;
		uint64_t rrp:9;
		uint64_t max:9;
#endif
	} s;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cn61xx;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cn63xx;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cn63xxp1;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cn66xx;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cn68xx;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cn68xxp1;
	struct cvmx_sli_pktx_instr_fifo_rsize_s cnf71xx;
};

union cvmx_sli_pktx_instr_header {
	uint64_t u64;
	struct cvmx_sli_pktx_instr_header_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t pbp:1;
		uint64_t reserved_38_42:5;
		uint64_t rparmode:2;
		uint64_t reserved_35_35:1;
		uint64_t rskp_len:7;
		uint64_t rngrpext:2;
		uint64_t rnqos:1;
		uint64_t rngrp:1;
		uint64_t rntt:1;
		uint64_t rntag:1;
		uint64_t use_ihdr:1;
		uint64_t reserved_16_20:5;
		uint64_t par_mode:2;
		uint64_t reserved_13_13:1;
		uint64_t skp_len:7;
		uint64_t ngrpext:2;
		uint64_t nqos:1;
		uint64_t ngrp:1;
		uint64_t ntt:1;
		uint64_t ntag:1;
#else
		uint64_t ntag:1;
		uint64_t ntt:1;
		uint64_t ngrp:1;
		uint64_t nqos:1;
		uint64_t ngrpext:2;
		uint64_t skp_len:7;
		uint64_t reserved_13_13:1;
		uint64_t par_mode:2;
		uint64_t reserved_16_20:5;
		uint64_t use_ihdr:1;
		uint64_t rntag:1;
		uint64_t rntt:1;
		uint64_t rngrp:1;
		uint64_t rnqos:1;
		uint64_t rngrpext:2;
		uint64_t rskp_len:7;
		uint64_t reserved_35_35:1;
		uint64_t rparmode:2;
		uint64_t reserved_38_42:5;
		uint64_t pbp:1;
		uint64_t reserved_44_63:20;
#endif
	} s;
	struct cvmx_sli_pktx_instr_header_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_44_63:20;
		uint64_t pbp:1;
		uint64_t reserved_38_42:5;
		uint64_t rparmode:2;
		uint64_t reserved_35_35:1;
		uint64_t rskp_len:7;
		uint64_t reserved_26_27:2;
		uint64_t rnqos:1;
		uint64_t rngrp:1;
		uint64_t rntt:1;
		uint64_t rntag:1;
		uint64_t use_ihdr:1;
		uint64_t reserved_16_20:5;
		uint64_t par_mode:2;
		uint64_t reserved_13_13:1;
		uint64_t skp_len:7;
		uint64_t reserved_4_5:2;
		uint64_t nqos:1;
		uint64_t ngrp:1;
		uint64_t ntt:1;
		uint64_t ntag:1;
#else
		uint64_t ntag:1;
		uint64_t ntt:1;
		uint64_t ngrp:1;
		uint64_t nqos:1;
		uint64_t reserved_4_5:2;
		uint64_t skp_len:7;
		uint64_t reserved_13_13:1;
		uint64_t par_mode:2;
		uint64_t reserved_16_20:5;
		uint64_t use_ihdr:1;
		uint64_t rntag:1;
		uint64_t rntt:1;
		uint64_t rngrp:1;
		uint64_t rnqos:1;
		uint64_t reserved_26_27:2;
		uint64_t rskp_len:7;
		uint64_t reserved_35_35:1;
		uint64_t rparmode:2;
		uint64_t reserved_38_42:5;
		uint64_t pbp:1;
		uint64_t reserved_44_63:20;
#endif
	} cn61xx;
	struct cvmx_sli_pktx_instr_header_cn61xx cn63xx;
	struct cvmx_sli_pktx_instr_header_cn61xx cn63xxp1;
	struct cvmx_sli_pktx_instr_header_cn61xx cn66xx;
	struct cvmx_sli_pktx_instr_header_s cn68xx;
	struct cvmx_sli_pktx_instr_header_cn61xx cn68xxp1;
	struct cvmx_sli_pktx_instr_header_cn61xx cnf71xx;
};

union cvmx_sli_pktx_out_size {
	uint64_t u64;
	struct cvmx_sli_pktx_out_size_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t isize:7;
		uint64_t bsize:16;
#else
		uint64_t bsize:16;
		uint64_t isize:7;
		uint64_t reserved_23_63:41;
#endif
	} s;
	struct cvmx_sli_pktx_out_size_s cn61xx;
	struct cvmx_sli_pktx_out_size_s cn63xx;
	struct cvmx_sli_pktx_out_size_s cn63xxp1;
	struct cvmx_sli_pktx_out_size_s cn66xx;
	struct cvmx_sli_pktx_out_size_s cn68xx;
	struct cvmx_sli_pktx_out_size_s cn68xxp1;
	struct cvmx_sli_pktx_out_size_s cnf71xx;
};

union cvmx_sli_pktx_slist_baddr {
	uint64_t u64;
	struct cvmx_sli_pktx_slist_baddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t addr:60;
		uint64_t reserved_0_3:4;
#else
		uint64_t reserved_0_3:4;
		uint64_t addr:60;
#endif
	} s;
	struct cvmx_sli_pktx_slist_baddr_s cn61xx;
	struct cvmx_sli_pktx_slist_baddr_s cn63xx;
	struct cvmx_sli_pktx_slist_baddr_s cn63xxp1;
	struct cvmx_sli_pktx_slist_baddr_s cn66xx;
	struct cvmx_sli_pktx_slist_baddr_s cn68xx;
	struct cvmx_sli_pktx_slist_baddr_s cn68xxp1;
	struct cvmx_sli_pktx_slist_baddr_s cnf71xx;
};

union cvmx_sli_pktx_slist_baoff_dbell {
	uint64_t u64;
	struct cvmx_sli_pktx_slist_baoff_dbell_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t aoff:32;
		uint64_t dbell:32;
#else
		uint64_t dbell:32;
		uint64_t aoff:32;
#endif
	} s;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cn61xx;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cn63xx;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cn63xxp1;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cn66xx;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cn68xx;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cn68xxp1;
	struct cvmx_sli_pktx_slist_baoff_dbell_s cnf71xx;
};

union cvmx_sli_pktx_slist_fifo_rsize {
	uint64_t u64;
	struct cvmx_sli_pktx_slist_fifo_rsize_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t rsize:32;
#else
		uint64_t rsize:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cn61xx;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cn63xx;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cn63xxp1;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cn66xx;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cn68xx;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cn68xxp1;
	struct cvmx_sli_pktx_slist_fifo_rsize_s cnf71xx;
};

union cvmx_sli_pkt_cnt_int {
	uint64_t u64;
	struct cvmx_sli_pkt_cnt_int_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_cnt_int_s cn61xx;
	struct cvmx_sli_pkt_cnt_int_s cn63xx;
	struct cvmx_sli_pkt_cnt_int_s cn63xxp1;
	struct cvmx_sli_pkt_cnt_int_s cn66xx;
	struct cvmx_sli_pkt_cnt_int_s cn68xx;
	struct cvmx_sli_pkt_cnt_int_s cn68xxp1;
	struct cvmx_sli_pkt_cnt_int_s cnf71xx;
};

union cvmx_sli_pkt_cnt_int_enb {
	uint64_t u64;
	struct cvmx_sli_pkt_cnt_int_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_cnt_int_enb_s cn61xx;
	struct cvmx_sli_pkt_cnt_int_enb_s cn63xx;
	struct cvmx_sli_pkt_cnt_int_enb_s cn63xxp1;
	struct cvmx_sli_pkt_cnt_int_enb_s cn66xx;
	struct cvmx_sli_pkt_cnt_int_enb_s cn68xx;
	struct cvmx_sli_pkt_cnt_int_enb_s cn68xxp1;
	struct cvmx_sli_pkt_cnt_int_enb_s cnf71xx;
};

union cvmx_sli_pkt_ctl {
	uint64_t u64;
	struct cvmx_sli_pkt_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t ring_en:1;
		uint64_t pkt_bp:4;
#else
		uint64_t pkt_bp:4;
		uint64_t ring_en:1;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_sli_pkt_ctl_s cn61xx;
	struct cvmx_sli_pkt_ctl_s cn63xx;
	struct cvmx_sli_pkt_ctl_s cn63xxp1;
	struct cvmx_sli_pkt_ctl_s cn66xx;
	struct cvmx_sli_pkt_ctl_s cn68xx;
	struct cvmx_sli_pkt_ctl_s cn68xxp1;
	struct cvmx_sli_pkt_ctl_s cnf71xx;
};

union cvmx_sli_pkt_data_out_es {
	uint64_t u64;
	struct cvmx_sli_pkt_data_out_es_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t es:64;
#else
		uint64_t es:64;
#endif
	} s;
	struct cvmx_sli_pkt_data_out_es_s cn61xx;
	struct cvmx_sli_pkt_data_out_es_s cn63xx;
	struct cvmx_sli_pkt_data_out_es_s cn63xxp1;
	struct cvmx_sli_pkt_data_out_es_s cn66xx;
	struct cvmx_sli_pkt_data_out_es_s cn68xx;
	struct cvmx_sli_pkt_data_out_es_s cn68xxp1;
	struct cvmx_sli_pkt_data_out_es_s cnf71xx;
};

union cvmx_sli_pkt_data_out_ns {
	uint64_t u64;
	struct cvmx_sli_pkt_data_out_ns_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t nsr:32;
#else
		uint64_t nsr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_data_out_ns_s cn61xx;
	struct cvmx_sli_pkt_data_out_ns_s cn63xx;
	struct cvmx_sli_pkt_data_out_ns_s cn63xxp1;
	struct cvmx_sli_pkt_data_out_ns_s cn66xx;
	struct cvmx_sli_pkt_data_out_ns_s cn68xx;
	struct cvmx_sli_pkt_data_out_ns_s cn68xxp1;
	struct cvmx_sli_pkt_data_out_ns_s cnf71xx;
};

union cvmx_sli_pkt_data_out_ror {
	uint64_t u64;
	struct cvmx_sli_pkt_data_out_ror_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t ror:32;
#else
		uint64_t ror:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_data_out_ror_s cn61xx;
	struct cvmx_sli_pkt_data_out_ror_s cn63xx;
	struct cvmx_sli_pkt_data_out_ror_s cn63xxp1;
	struct cvmx_sli_pkt_data_out_ror_s cn66xx;
	struct cvmx_sli_pkt_data_out_ror_s cn68xx;
	struct cvmx_sli_pkt_data_out_ror_s cn68xxp1;
	struct cvmx_sli_pkt_data_out_ror_s cnf71xx;
};

union cvmx_sli_pkt_dpaddr {
	uint64_t u64;
	struct cvmx_sli_pkt_dpaddr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t dptr:32;
#else
		uint64_t dptr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_dpaddr_s cn61xx;
	struct cvmx_sli_pkt_dpaddr_s cn63xx;
	struct cvmx_sli_pkt_dpaddr_s cn63xxp1;
	struct cvmx_sli_pkt_dpaddr_s cn66xx;
	struct cvmx_sli_pkt_dpaddr_s cn68xx;
	struct cvmx_sli_pkt_dpaddr_s cn68xxp1;
	struct cvmx_sli_pkt_dpaddr_s cnf71xx;
};

union cvmx_sli_pkt_in_bp {
	uint64_t u64;
	struct cvmx_sli_pkt_in_bp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t bp:32;
#else
		uint64_t bp:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_in_bp_s cn61xx;
	struct cvmx_sli_pkt_in_bp_s cn63xx;
	struct cvmx_sli_pkt_in_bp_s cn63xxp1;
	struct cvmx_sli_pkt_in_bp_s cn66xx;
	struct cvmx_sli_pkt_in_bp_s cnf71xx;
};

union cvmx_sli_pkt_in_donex_cnts {
	uint64_t u64;
	struct cvmx_sli_pkt_in_donex_cnts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_in_donex_cnts_s cn61xx;
	struct cvmx_sli_pkt_in_donex_cnts_s cn63xx;
	struct cvmx_sli_pkt_in_donex_cnts_s cn63xxp1;
	struct cvmx_sli_pkt_in_donex_cnts_s cn66xx;
	struct cvmx_sli_pkt_in_donex_cnts_s cn68xx;
	struct cvmx_sli_pkt_in_donex_cnts_s cn68xxp1;
	struct cvmx_sli_pkt_in_donex_cnts_s cnf71xx;
};

union cvmx_sli_pkt_in_instr_counts {
	uint64_t u64;
	struct cvmx_sli_pkt_in_instr_counts_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wr_cnt:32;
		uint64_t rd_cnt:32;
#else
		uint64_t rd_cnt:32;
		uint64_t wr_cnt:32;
#endif
	} s;
	struct cvmx_sli_pkt_in_instr_counts_s cn61xx;
	struct cvmx_sli_pkt_in_instr_counts_s cn63xx;
	struct cvmx_sli_pkt_in_instr_counts_s cn63xxp1;
	struct cvmx_sli_pkt_in_instr_counts_s cn66xx;
	struct cvmx_sli_pkt_in_instr_counts_s cn68xx;
	struct cvmx_sli_pkt_in_instr_counts_s cn68xxp1;
	struct cvmx_sli_pkt_in_instr_counts_s cnf71xx;
};

union cvmx_sli_pkt_in_pcie_port {
	uint64_t u64;
	struct cvmx_sli_pkt_in_pcie_port_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t pp:64;
#else
		uint64_t pp:64;
#endif
	} s;
	struct cvmx_sli_pkt_in_pcie_port_s cn61xx;
	struct cvmx_sli_pkt_in_pcie_port_s cn63xx;
	struct cvmx_sli_pkt_in_pcie_port_s cn63xxp1;
	struct cvmx_sli_pkt_in_pcie_port_s cn66xx;
	struct cvmx_sli_pkt_in_pcie_port_s cn68xx;
	struct cvmx_sli_pkt_in_pcie_port_s cn68xxp1;
	struct cvmx_sli_pkt_in_pcie_port_s cnf71xx;
};

union cvmx_sli_pkt_input_control {
	uint64_t u64;
	struct cvmx_sli_pkt_input_control_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t prd_erst:1;
		uint64_t prd_rds:7;
		uint64_t gii_erst:1;
		uint64_t gii_rds:7;
		uint64_t reserved_41_47:7;
		uint64_t prc_idle:1;
		uint64_t reserved_24_39:16;
		uint64_t pin_rst:1;
		uint64_t pkt_rr:1;
		uint64_t pbp_dhi:13;
		uint64_t d_nsr:1;
		uint64_t d_esr:2;
		uint64_t d_ror:1;
		uint64_t use_csr:1;
		uint64_t nsr:1;
		uint64_t esr:2;
		uint64_t ror:1;
#else
		uint64_t ror:1;
		uint64_t esr:2;
		uint64_t nsr:1;
		uint64_t use_csr:1;
		uint64_t d_ror:1;
		uint64_t d_esr:2;
		uint64_t d_nsr:1;
		uint64_t pbp_dhi:13;
		uint64_t pkt_rr:1;
		uint64_t pin_rst:1;
		uint64_t reserved_24_39:16;
		uint64_t prc_idle:1;
		uint64_t reserved_41_47:7;
		uint64_t gii_rds:7;
		uint64_t gii_erst:1;
		uint64_t prd_rds:7;
		uint64_t prd_erst:1;
#endif
	} s;
	struct cvmx_sli_pkt_input_control_s cn61xx;
	struct cvmx_sli_pkt_input_control_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t pkt_rr:1;
		uint64_t pbp_dhi:13;
		uint64_t d_nsr:1;
		uint64_t d_esr:2;
		uint64_t d_ror:1;
		uint64_t use_csr:1;
		uint64_t nsr:1;
		uint64_t esr:2;
		uint64_t ror:1;
#else
		uint64_t ror:1;
		uint64_t esr:2;
		uint64_t nsr:1;
		uint64_t use_csr:1;
		uint64_t d_ror:1;
		uint64_t d_esr:2;
		uint64_t d_nsr:1;
		uint64_t pbp_dhi:13;
		uint64_t pkt_rr:1;
		uint64_t reserved_23_63:41;
#endif
	} cn63xx;
	struct cvmx_sli_pkt_input_control_cn63xx cn63xxp1;
	struct cvmx_sli_pkt_input_control_s cn66xx;
	struct cvmx_sli_pkt_input_control_s cn68xx;
	struct cvmx_sli_pkt_input_control_s cn68xxp1;
	struct cvmx_sli_pkt_input_control_s cnf71xx;
};

union cvmx_sli_pkt_instr_enb {
	uint64_t u64;
	struct cvmx_sli_pkt_instr_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t enb:32;
#else
		uint64_t enb:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_instr_enb_s cn61xx;
	struct cvmx_sli_pkt_instr_enb_s cn63xx;
	struct cvmx_sli_pkt_instr_enb_s cn63xxp1;
	struct cvmx_sli_pkt_instr_enb_s cn66xx;
	struct cvmx_sli_pkt_instr_enb_s cn68xx;
	struct cvmx_sli_pkt_instr_enb_s cn68xxp1;
	struct cvmx_sli_pkt_instr_enb_s cnf71xx;
};

union cvmx_sli_pkt_instr_rd_size {
	uint64_t u64;
	struct cvmx_sli_pkt_instr_rd_size_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t rdsize:64;
#else
		uint64_t rdsize:64;
#endif
	} s;
	struct cvmx_sli_pkt_instr_rd_size_s cn61xx;
	struct cvmx_sli_pkt_instr_rd_size_s cn63xx;
	struct cvmx_sli_pkt_instr_rd_size_s cn63xxp1;
	struct cvmx_sli_pkt_instr_rd_size_s cn66xx;
	struct cvmx_sli_pkt_instr_rd_size_s cn68xx;
	struct cvmx_sli_pkt_instr_rd_size_s cn68xxp1;
	struct cvmx_sli_pkt_instr_rd_size_s cnf71xx;
};

union cvmx_sli_pkt_instr_size {
	uint64_t u64;
	struct cvmx_sli_pkt_instr_size_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t is_64b:32;
#else
		uint64_t is_64b:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_instr_size_s cn61xx;
	struct cvmx_sli_pkt_instr_size_s cn63xx;
	struct cvmx_sli_pkt_instr_size_s cn63xxp1;
	struct cvmx_sli_pkt_instr_size_s cn66xx;
	struct cvmx_sli_pkt_instr_size_s cn68xx;
	struct cvmx_sli_pkt_instr_size_s cn68xxp1;
	struct cvmx_sli_pkt_instr_size_s cnf71xx;
};

union cvmx_sli_pkt_int_levels {
	uint64_t u64;
	struct cvmx_sli_pkt_int_levels_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_54_63:10;
		uint64_t time:22;
		uint64_t cnt:32;
#else
		uint64_t cnt:32;
		uint64_t time:22;
		uint64_t reserved_54_63:10;
#endif
	} s;
	struct cvmx_sli_pkt_int_levels_s cn61xx;
	struct cvmx_sli_pkt_int_levels_s cn63xx;
	struct cvmx_sli_pkt_int_levels_s cn63xxp1;
	struct cvmx_sli_pkt_int_levels_s cn66xx;
	struct cvmx_sli_pkt_int_levels_s cn68xx;
	struct cvmx_sli_pkt_int_levels_s cn68xxp1;
	struct cvmx_sli_pkt_int_levels_s cnf71xx;
};

union cvmx_sli_pkt_iptr {
	uint64_t u64;
	struct cvmx_sli_pkt_iptr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t iptr:32;
#else
		uint64_t iptr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_iptr_s cn61xx;
	struct cvmx_sli_pkt_iptr_s cn63xx;
	struct cvmx_sli_pkt_iptr_s cn63xxp1;
	struct cvmx_sli_pkt_iptr_s cn66xx;
	struct cvmx_sli_pkt_iptr_s cn68xx;
	struct cvmx_sli_pkt_iptr_s cn68xxp1;
	struct cvmx_sli_pkt_iptr_s cnf71xx;
};

union cvmx_sli_pkt_out_bmode {
	uint64_t u64;
	struct cvmx_sli_pkt_out_bmode_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t bmode:32;
#else
		uint64_t bmode:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_out_bmode_s cn61xx;
	struct cvmx_sli_pkt_out_bmode_s cn63xx;
	struct cvmx_sli_pkt_out_bmode_s cn63xxp1;
	struct cvmx_sli_pkt_out_bmode_s cn66xx;
	struct cvmx_sli_pkt_out_bmode_s cn68xx;
	struct cvmx_sli_pkt_out_bmode_s cn68xxp1;
	struct cvmx_sli_pkt_out_bmode_s cnf71xx;
};

union cvmx_sli_pkt_out_bp_en {
	uint64_t u64;
	struct cvmx_sli_pkt_out_bp_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t bp_en:32;
#else
		uint64_t bp_en:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_out_bp_en_s cn68xx;
	struct cvmx_sli_pkt_out_bp_en_s cn68xxp1;
};

union cvmx_sli_pkt_out_enb {
	uint64_t u64;
	struct cvmx_sli_pkt_out_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t enb:32;
#else
		uint64_t enb:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_out_enb_s cn61xx;
	struct cvmx_sli_pkt_out_enb_s cn63xx;
	struct cvmx_sli_pkt_out_enb_s cn63xxp1;
	struct cvmx_sli_pkt_out_enb_s cn66xx;
	struct cvmx_sli_pkt_out_enb_s cn68xx;
	struct cvmx_sli_pkt_out_enb_s cn68xxp1;
	struct cvmx_sli_pkt_out_enb_s cnf71xx;
};

union cvmx_sli_pkt_output_wmark {
	uint64_t u64;
	struct cvmx_sli_pkt_output_wmark_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t wmark:32;
#else
		uint64_t wmark:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_output_wmark_s cn61xx;
	struct cvmx_sli_pkt_output_wmark_s cn63xx;
	struct cvmx_sli_pkt_output_wmark_s cn63xxp1;
	struct cvmx_sli_pkt_output_wmark_s cn66xx;
	struct cvmx_sli_pkt_output_wmark_s cn68xx;
	struct cvmx_sli_pkt_output_wmark_s cn68xxp1;
	struct cvmx_sli_pkt_output_wmark_s cnf71xx;
};

union cvmx_sli_pkt_pcie_port {
	uint64_t u64;
	struct cvmx_sli_pkt_pcie_port_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t pp:64;
#else
		uint64_t pp:64;
#endif
	} s;
	struct cvmx_sli_pkt_pcie_port_s cn61xx;
	struct cvmx_sli_pkt_pcie_port_s cn63xx;
	struct cvmx_sli_pkt_pcie_port_s cn63xxp1;
	struct cvmx_sli_pkt_pcie_port_s cn66xx;
	struct cvmx_sli_pkt_pcie_port_s cn68xx;
	struct cvmx_sli_pkt_pcie_port_s cn68xxp1;
	struct cvmx_sli_pkt_pcie_port_s cnf71xx;
};

union cvmx_sli_pkt_port_in_rst {
	uint64_t u64;
	struct cvmx_sli_pkt_port_in_rst_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t in_rst:32;
		uint64_t out_rst:32;
#else
		uint64_t out_rst:32;
		uint64_t in_rst:32;
#endif
	} s;
	struct cvmx_sli_pkt_port_in_rst_s cn61xx;
	struct cvmx_sli_pkt_port_in_rst_s cn63xx;
	struct cvmx_sli_pkt_port_in_rst_s cn63xxp1;
	struct cvmx_sli_pkt_port_in_rst_s cn66xx;
	struct cvmx_sli_pkt_port_in_rst_s cn68xx;
	struct cvmx_sli_pkt_port_in_rst_s cn68xxp1;
	struct cvmx_sli_pkt_port_in_rst_s cnf71xx;
};

union cvmx_sli_pkt_slist_es {
	uint64_t u64;
	struct cvmx_sli_pkt_slist_es_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t es:64;
#else
		uint64_t es:64;
#endif
	} s;
	struct cvmx_sli_pkt_slist_es_s cn61xx;
	struct cvmx_sli_pkt_slist_es_s cn63xx;
	struct cvmx_sli_pkt_slist_es_s cn63xxp1;
	struct cvmx_sli_pkt_slist_es_s cn66xx;
	struct cvmx_sli_pkt_slist_es_s cn68xx;
	struct cvmx_sli_pkt_slist_es_s cn68xxp1;
	struct cvmx_sli_pkt_slist_es_s cnf71xx;
};

union cvmx_sli_pkt_slist_ns {
	uint64_t u64;
	struct cvmx_sli_pkt_slist_ns_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t nsr:32;
#else
		uint64_t nsr:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_slist_ns_s cn61xx;
	struct cvmx_sli_pkt_slist_ns_s cn63xx;
	struct cvmx_sli_pkt_slist_ns_s cn63xxp1;
	struct cvmx_sli_pkt_slist_ns_s cn66xx;
	struct cvmx_sli_pkt_slist_ns_s cn68xx;
	struct cvmx_sli_pkt_slist_ns_s cn68xxp1;
	struct cvmx_sli_pkt_slist_ns_s cnf71xx;
};

union cvmx_sli_pkt_slist_ror {
	uint64_t u64;
	struct cvmx_sli_pkt_slist_ror_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t ror:32;
#else
		uint64_t ror:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_slist_ror_s cn61xx;
	struct cvmx_sli_pkt_slist_ror_s cn63xx;
	struct cvmx_sli_pkt_slist_ror_s cn63xxp1;
	struct cvmx_sli_pkt_slist_ror_s cn66xx;
	struct cvmx_sli_pkt_slist_ror_s cn68xx;
	struct cvmx_sli_pkt_slist_ror_s cn68xxp1;
	struct cvmx_sli_pkt_slist_ror_s cnf71xx;
};

union cvmx_sli_pkt_time_int {
	uint64_t u64;
	struct cvmx_sli_pkt_time_int_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_time_int_s cn61xx;
	struct cvmx_sli_pkt_time_int_s cn63xx;
	struct cvmx_sli_pkt_time_int_s cn63xxp1;
	struct cvmx_sli_pkt_time_int_s cn66xx;
	struct cvmx_sli_pkt_time_int_s cn68xx;
	struct cvmx_sli_pkt_time_int_s cn68xxp1;
	struct cvmx_sli_pkt_time_int_s cnf71xx;
};

union cvmx_sli_pkt_time_int_enb {
	uint64_t u64;
	struct cvmx_sli_pkt_time_int_enb_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t port:32;
#else
		uint64_t port:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_pkt_time_int_enb_s cn61xx;
	struct cvmx_sli_pkt_time_int_enb_s cn63xx;
	struct cvmx_sli_pkt_time_int_enb_s cn63xxp1;
	struct cvmx_sli_pkt_time_int_enb_s cn66xx;
	struct cvmx_sli_pkt_time_int_enb_s cn68xx;
	struct cvmx_sli_pkt_time_int_enb_s cn68xxp1;
	struct cvmx_sli_pkt_time_int_enb_s cnf71xx;
};

union cvmx_sli_portx_pkind {
	uint64_t u64;
	struct cvmx_sli_portx_pkind_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t rpk_enb:1;
		uint64_t reserved_22_23:2;
		uint64_t pkindr:6;
		uint64_t reserved_14_15:2;
		uint64_t bpkind:6;
		uint64_t reserved_6_7:2;
		uint64_t pkind:6;
#else
		uint64_t pkind:6;
		uint64_t reserved_6_7:2;
		uint64_t bpkind:6;
		uint64_t reserved_14_15:2;
		uint64_t pkindr:6;
		uint64_t reserved_22_23:2;
		uint64_t rpk_enb:1;
		uint64_t reserved_25_63:39;
#endif
	} s;
	struct cvmx_sli_portx_pkind_s cn68xx;
	struct cvmx_sli_portx_pkind_cn68xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t bpkind:6;
		uint64_t reserved_6_7:2;
		uint64_t pkind:6;
#else
		uint64_t pkind:6;
		uint64_t reserved_6_7:2;
		uint64_t bpkind:6;
		uint64_t reserved_14_63:50;
#endif
	} cn68xxp1;
};

union cvmx_sli_s2m_portx_ctl {
	uint64_t u64;
	struct cvmx_sli_s2m_portx_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t wind_d:1;
		uint64_t bar0_d:1;
		uint64_t mrrs:3;
#else
		uint64_t mrrs:3;
		uint64_t bar0_d:1;
		uint64_t wind_d:1;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_sli_s2m_portx_ctl_s cn61xx;
	struct cvmx_sli_s2m_portx_ctl_s cn63xx;
	struct cvmx_sli_s2m_portx_ctl_s cn63xxp1;
	struct cvmx_sli_s2m_portx_ctl_s cn66xx;
	struct cvmx_sli_s2m_portx_ctl_s cn68xx;
	struct cvmx_sli_s2m_portx_ctl_s cn68xxp1;
	struct cvmx_sli_s2m_portx_ctl_s cnf71xx;
};

union cvmx_sli_scratch_1 {
	uint64_t u64;
	struct cvmx_sli_scratch_1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_sli_scratch_1_s cn61xx;
	struct cvmx_sli_scratch_1_s cn63xx;
	struct cvmx_sli_scratch_1_s cn63xxp1;
	struct cvmx_sli_scratch_1_s cn66xx;
	struct cvmx_sli_scratch_1_s cn68xx;
	struct cvmx_sli_scratch_1_s cn68xxp1;
	struct cvmx_sli_scratch_1_s cnf71xx;
};

union cvmx_sli_scratch_2 {
	uint64_t u64;
	struct cvmx_sli_scratch_2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_sli_scratch_2_s cn61xx;
	struct cvmx_sli_scratch_2_s cn63xx;
	struct cvmx_sli_scratch_2_s cn63xxp1;
	struct cvmx_sli_scratch_2_s cn66xx;
	struct cvmx_sli_scratch_2_s cn68xx;
	struct cvmx_sli_scratch_2_s cn68xxp1;
	struct cvmx_sli_scratch_2_s cnf71xx;
};

union cvmx_sli_state1 {
	uint64_t u64;
	struct cvmx_sli_state1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t cpl1:12;
		uint64_t cpl0:12;
		uint64_t arb:1;
		uint64_t csr:39;
#else
		uint64_t csr:39;
		uint64_t arb:1;
		uint64_t cpl0:12;
		uint64_t cpl1:12;
#endif
	} s;
	struct cvmx_sli_state1_s cn61xx;
	struct cvmx_sli_state1_s cn63xx;
	struct cvmx_sli_state1_s cn63xxp1;
	struct cvmx_sli_state1_s cn66xx;
	struct cvmx_sli_state1_s cn68xx;
	struct cvmx_sli_state1_s cn68xxp1;
	struct cvmx_sli_state1_s cnf71xx;
};

union cvmx_sli_state2 {
	uint64_t u64;
	struct cvmx_sli_state2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_56_63:8;
		uint64_t nnp1:8;
		uint64_t reserved_47_47:1;
		uint64_t rac:1;
		uint64_t csm1:15;
		uint64_t csm0:15;
		uint64_t nnp0:8;
		uint64_t nnd:8;
#else
		uint64_t nnd:8;
		uint64_t nnp0:8;
		uint64_t csm0:15;
		uint64_t csm1:15;
		uint64_t rac:1;
		uint64_t reserved_47_47:1;
		uint64_t nnp1:8;
		uint64_t reserved_56_63:8;
#endif
	} s;
	struct cvmx_sli_state2_s cn61xx;
	struct cvmx_sli_state2_s cn63xx;
	struct cvmx_sli_state2_s cn63xxp1;
	struct cvmx_sli_state2_s cn66xx;
	struct cvmx_sli_state2_s cn68xx;
	struct cvmx_sli_state2_s cn68xxp1;
	struct cvmx_sli_state2_s cnf71xx;
};

union cvmx_sli_state3 {
	uint64_t u64;
	struct cvmx_sli_state3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_56_63:8;
		uint64_t psm1:15;
		uint64_t psm0:15;
		uint64_t nsm1:13;
		uint64_t nsm0:13;
#else
		uint64_t nsm0:13;
		uint64_t nsm1:13;
		uint64_t psm0:15;
		uint64_t psm1:15;
		uint64_t reserved_56_63:8;
#endif
	} s;
	struct cvmx_sli_state3_s cn61xx;
	struct cvmx_sli_state3_s cn63xx;
	struct cvmx_sli_state3_s cn63xxp1;
	struct cvmx_sli_state3_s cn66xx;
	struct cvmx_sli_state3_s cn68xx;
	struct cvmx_sli_state3_s cn68xxp1;
	struct cvmx_sli_state3_s cnf71xx;
};

union cvmx_sli_tx_pipe {
	uint64_t u64;
	struct cvmx_sli_tx_pipe_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t nump:8;
		uint64_t reserved_7_15:9;
		uint64_t base:7;
#else
		uint64_t base:7;
		uint64_t reserved_7_15:9;
		uint64_t nump:8;
		uint64_t reserved_24_63:40;
#endif
	} s;
	struct cvmx_sli_tx_pipe_s cn68xx;
	struct cvmx_sli_tx_pipe_s cn68xxp1;
};

union cvmx_sli_win_rd_addr {
	uint64_t u64;
	struct cvmx_sli_win_rd_addr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_51_63:13;
		uint64_t ld_cmd:2;
		uint64_t iobit:1;
		uint64_t rd_addr:48;
#else
		uint64_t rd_addr:48;
		uint64_t iobit:1;
		uint64_t ld_cmd:2;
		uint64_t reserved_51_63:13;
#endif
	} s;
	struct cvmx_sli_win_rd_addr_s cn61xx;
	struct cvmx_sli_win_rd_addr_s cn63xx;
	struct cvmx_sli_win_rd_addr_s cn63xxp1;
	struct cvmx_sli_win_rd_addr_s cn66xx;
	struct cvmx_sli_win_rd_addr_s cn68xx;
	struct cvmx_sli_win_rd_addr_s cn68xxp1;
	struct cvmx_sli_win_rd_addr_s cnf71xx;
};

union cvmx_sli_win_rd_data {
	uint64_t u64;
	struct cvmx_sli_win_rd_data_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t rd_data:64;
#else
		uint64_t rd_data:64;
#endif
	} s;
	struct cvmx_sli_win_rd_data_s cn61xx;
	struct cvmx_sli_win_rd_data_s cn63xx;
	struct cvmx_sli_win_rd_data_s cn63xxp1;
	struct cvmx_sli_win_rd_data_s cn66xx;
	struct cvmx_sli_win_rd_data_s cn68xx;
	struct cvmx_sli_win_rd_data_s cn68xxp1;
	struct cvmx_sli_win_rd_data_s cnf71xx;
};

union cvmx_sli_win_wr_addr {
	uint64_t u64;
	struct cvmx_sli_win_wr_addr_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_49_63:15;
		uint64_t iobit:1;
		uint64_t wr_addr:45;
		uint64_t reserved_0_2:3;
#else
		uint64_t reserved_0_2:3;
		uint64_t wr_addr:45;
		uint64_t iobit:1;
		uint64_t reserved_49_63:15;
#endif
	} s;
	struct cvmx_sli_win_wr_addr_s cn61xx;
	struct cvmx_sli_win_wr_addr_s cn63xx;
	struct cvmx_sli_win_wr_addr_s cn63xxp1;
	struct cvmx_sli_win_wr_addr_s cn66xx;
	struct cvmx_sli_win_wr_addr_s cn68xx;
	struct cvmx_sli_win_wr_addr_s cn68xxp1;
	struct cvmx_sli_win_wr_addr_s cnf71xx;
};

union cvmx_sli_win_wr_data {
	uint64_t u64;
	struct cvmx_sli_win_wr_data_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wr_data:64;
#else
		uint64_t wr_data:64;
#endif
	} s;
	struct cvmx_sli_win_wr_data_s cn61xx;
	struct cvmx_sli_win_wr_data_s cn63xx;
	struct cvmx_sli_win_wr_data_s cn63xxp1;
	struct cvmx_sli_win_wr_data_s cn66xx;
	struct cvmx_sli_win_wr_data_s cn68xx;
	struct cvmx_sli_win_wr_data_s cn68xxp1;
	struct cvmx_sli_win_wr_data_s cnf71xx;
};

union cvmx_sli_win_wr_mask {
	uint64_t u64;
	struct cvmx_sli_win_wr_mask_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t wr_mask:8;
#else
		uint64_t wr_mask:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_sli_win_wr_mask_s cn61xx;
	struct cvmx_sli_win_wr_mask_s cn63xx;
	struct cvmx_sli_win_wr_mask_s cn63xxp1;
	struct cvmx_sli_win_wr_mask_s cn66xx;
	struct cvmx_sli_win_wr_mask_s cn68xx;
	struct cvmx_sli_win_wr_mask_s cn68xxp1;
	struct cvmx_sli_win_wr_mask_s cnf71xx;
};

union cvmx_sli_window_ctl {
	uint64_t u64;
	struct cvmx_sli_window_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t time:32;
#else
		uint64_t time:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_sli_window_ctl_s cn61xx;
	struct cvmx_sli_window_ctl_s cn63xx;
	struct cvmx_sli_window_ctl_s cn63xxp1;
	struct cvmx_sli_window_ctl_s cn66xx;
	struct cvmx_sli_window_ctl_s cn68xx;
	struct cvmx_sli_window_ctl_s cn68xxp1;
	struct cvmx_sli_window_ctl_s cnf71xx;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /***********************license start***************
 * Author: Cavium Networks
 *
 * Contact: support@caviumnetworks.com
 * This file is part of the OCTEON SDK
 *
 * Copyright (c) 2003-2012 Cavium Networks
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, Version 2, as
 * published by the Free Software Foundation.
 *
 * This file is distributed in the hope that it will be useful, but
 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
 * NONINFRINGEMENT.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 * or visit http://www.gnu.org/licenses/.
 *
 * This file may also be available under a different license from Cavium.
 * Contact Cavium Networks for more information
 ***********************license end**************************************/

#ifndef __CVMX_L2C_DEFS_H__
#define __CVMX_L2C_DEFS_H__

#define CVMX_L2C_BIG_CTL (CVMX_ADD_IO_SEG(0x0001180080800030ull))
#define CVMX_L2C_BST (CVMX_ADD_IO_SEG(0x00011800808007F8ull))
#define CVMX_L2C_BST0 (CVMX_ADD_IO_SEG(0x00011800800007F8ull))
#define CVMX_L2C_BST1 (CVMX_ADD_IO_SEG(0x00011800800007F0ull))
#define CVMX_L2C_BST2 (CVMX_ADD_IO_SEG(0x00011800800007E8ull))
#define CVMX_L2C_BST_MEMX(block_id) (CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_BST_TDTX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_BST_TTGX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_CFG (CVMX_ADD_IO_SEG(0x0001180080000000ull))
#define CVMX_L2C_COP0_MAPX(offset) (CVMX_ADD_IO_SEG(0x0001180080940000ull) + ((offset) & 16383) * 8)
#define CVMX_L2C_CTL (CVMX_ADD_IO_SEG(0x0001180080800000ull))
#define CVMX_L2C_DBG (CVMX_ADD_IO_SEG(0x0001180080000030ull))
#define CVMX_L2C_DUT (CVMX_ADD_IO_SEG(0x0001180080000050ull))
#define CVMX_L2C_DUT_MAPX(offset) (CVMX_ADD_IO_SEG(0x0001180080E00000ull) + ((offset) & 8191) * 8)
#define CVMX_L2C_ERR_TDTX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_ERR_TTGX(block_id) (CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_ERR_VBFX(block_id) (CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_ERR_XMC (CVMX_ADD_IO_SEG(0x00011800808007D8ull))
#define CVMX_L2C_GRPWRR0 (CVMX_ADD_IO_SEG(0x00011800800000C8ull))
#define CVMX_L2C_GRPWRR1 (CVMX_ADD_IO_SEG(0x00011800800000D0ull))
#define CVMX_L2C_INT_EN (CVMX_ADD_IO_SEG(0x0001180080000100ull))
#define CVMX_L2C_INT_ENA (CVMX_ADD_IO_SEG(0x0001180080800020ull))
#define CVMX_L2C_INT_REG (CVMX_ADD_IO_SEG(0x0001180080800018ull))
#define CVMX_L2C_INT_STAT (CVMX_ADD_IO_SEG(0x00011800800000F8ull))
#define CVMX_L2C_IOCX_PFC(block_id) (CVMX_ADD_IO_SEG(0x0001180080800420ull))
#define CVMX_L2C_IORX_PFC(block_id) (CVMX_ADD_IO_SEG(0x0001180080800428ull))
#define CVMX_L2C_LCKBASE (CVMX_ADD_IO_SEG(0x0001180080000058ull))
#define CVMX_L2C_LCKOFF (CVMX_ADD_IO_SEG(0x0001180080000060ull))
#define CVMX_L2C_LFB0 (CVMX_ADD_IO_SEG(0x0001180080000038ull))
#define CVMX_L2C_LFB1 (CVMX_ADD_IO_SEG(0x0001180080000040ull))
#define CVMX_L2C_LFB2 (CVMX_ADD_IO_SEG(0x0001180080000048ull))
#define CVMX_L2C_LFB3 (CVMX_ADD_IO_SEG(0x00011800800000B8ull))
#define CVMX_L2C_OOB (CVMX_ADD_IO_SEG(0x00011800800000D8ull))
#define CVMX_L2C_OOB1 (CVMX_ADD_IO_SEG(0x00011800800000E0ull))
#define CVMX_L2C_OOB2 (CVMX_ADD_IO_SEG(0x00011800800000E8ull))
#define CVMX_L2C_OOB3 (CVMX_ADD_IO_SEG(0x00011800800000F0ull))
#define CVMX_L2C_PFC0 CVMX_L2C_PFCX(0)
#define CVMX_L2C_PFC1 CVMX_L2C_PFCX(1)
#define CVMX_L2C_PFC2 CVMX_L2C_PFCX(2)
#define CVMX_L2C_PFC3 CVMX_L2C_PFCX(3)
#define CVMX_L2C_PFCTL (CVMX_ADD_IO_SEG(0x0001180080000090ull))
#define CVMX_L2C_PFCX(offset) (CVMX_ADD_IO_SEG(0x0001180080000098ull) + ((offset) & 3) * 8)
#define CVMX_L2C_PPGRP (CVMX_ADD_IO_SEG(0x00011800800000C0ull))
#define CVMX_L2C_QOS_IOBX(offset) (CVMX_ADD_IO_SEG(0x0001180080880200ull) + ((offset) & 1) * 8)
#define CVMX_L2C_QOS_PPX(offset) (CVMX_ADD_IO_SEG(0x0001180080880000ull) + ((offset) & 31) * 8)
#define CVMX_L2C_QOS_WGT (CVMX_ADD_IO_SEG(0x0001180080800008ull))
#define CVMX_L2C_RSCX_PFC(offset) (CVMX_ADD_IO_SEG(0x0001180080800410ull) + ((offset) & 3) * 64)
#define CVMX_L2C_RSDX_PFC(offset) (CVMX_ADD_IO_SEG(0x0001180080800418ull) + ((offset) & 3) * 64)
#define CVMX_L2C_SPAR0 (CVMX_ADD_IO_SEG(0x0001180080000068ull))
#define CVMX_L2C_SPAR1 (CVMX_ADD_IO_SEG(0x0001180080000070ull))
#define CVMX_L2C_SPAR2 (CVMX_ADD_IO_SEG(0x0001180080000078ull))
#define CVMX_L2C_SPAR3 (CVMX_ADD_IO_SEG(0x0001180080000080ull))
#define CVMX_L2C_SPAR4 (CVMX_ADD_IO_SEG(0x0001180080000088ull))
#define CVMX_L2C_TADX_ECC0(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_ECC1(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_IEN(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_INT(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_PFC0(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00400ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_PFC1(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00408ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_PFC2(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00410ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_PFC3(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00418ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_PRF(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_TADX_TAG(block_id) (CVMX_ADD_IO_SEG(0x0001180080A00010ull) + ((block_id) & 3) * 0x40000ull)
#define CVMX_L2C_VER_ID (CVMX_ADD_IO_SEG(0x00011800808007E0ull))
#define CVMX_L2C_VER_IOB (CVMX_ADD_IO_SEG(0x00011800808007F0ull))
#define CVMX_L2C_VER_MSC (CVMX_ADD_IO_SEG(0x00011800808007D0ull))
#define CVMX_L2C_VER_PP (CVMX_ADD_IO_SEG(0x00011800808007E8ull))
#define CVMX_L2C_VIRTID_IOBX(offset) (CVMX_ADD_IO_SEG(0x00011800808C0200ull) + ((offset) & 1) * 8)
#define CVMX_L2C_VIRTID_PPX(offset) (CVMX_ADD_IO_SEG(0x00011800808C0000ull) + ((offset) & 31) * 8)
#define CVMX_L2C_VRT_CTL (CVMX_ADD_IO_SEG(0x0001180080800010ull))
#define CVMX_L2C_VRT_MEMX(offset) (CVMX_ADD_IO_SEG(0x0001180080900000ull) + ((offset) & 1023) * 8)
#define CVMX_L2C_WPAR_IOBX(offset) (CVMX_ADD_IO_SEG(0x0001180080840200ull) + ((offset) & 1) * 8)
#define CVMX_L2C_WPAR_PPX(offset) (CVMX_ADD_IO_SEG(0x0001180080840000ull) + ((offset) & 31) * 8)
#define CVMX_L2C_XMCX_PFC(offset) (CVMX_ADD_IO_SEG(0x0001180080800400ull) + ((offset) & 3) * 64)
#define CVMX_L2C_XMC_CMD (CVMX_ADD_IO_SEG(0x0001180080800028ull))
#define CVMX_L2C_XMDX_PFC(offset) (CVMX_ADD_IO_SEG(0x0001180080800408ull) + ((offset) & 3) * 64)

union cvmx_l2c_big_ctl {
	uint64_t u64;
	struct cvmx_l2c_big_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t maxdram:4;
		uint64_t reserved_1_3:3;
		uint64_t disable:1;
#else
		uint64_t disable:1;
		uint64_t reserved_1_3:3;
		uint64_t maxdram:4;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_l2c_big_ctl_s cn61xx;
	struct cvmx_l2c_big_ctl_s cn63xx;
	struct cvmx_l2c_big_ctl_s cn66xx;
	struct cvmx_l2c_big_ctl_s cn68xx;
	struct cvmx_l2c_big_ctl_s cn68xxp1;
	struct cvmx_l2c_big_ctl_s cnf71xx;
};

union cvmx_l2c_bst {
	uint64_t u64;
	struct cvmx_l2c_bst_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dutfl:32;
		uint64_t rbffl:4;
		uint64_t xbffl:4;
		uint64_t tdpfl:4;
		uint64_t ioccmdfl:4;
		uint64_t iocdatfl:4;
		uint64_t dutresfl:4;
		uint64_t vrtfl:4;
		uint64_t tdffl:4;
#else
		uint64_t tdffl:4;
		uint64_t vrtfl:4;
		uint64_t dutresfl:4;
		uint64_t iocdatfl:4;
		uint64_t ioccmdfl:4;
		uint64_t tdpfl:4;
		uint64_t xbffl:4;
		uint64_t rbffl:4;
		uint64_t dutfl:32;
#endif
	} s;
	struct cvmx_l2c_bst_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_36_63:28;
		uint64_t dutfl:4;
		uint64_t reserved_17_31:15;
		uint64_t ioccmdfl:1;
		uint64_t reserved_13_15:3;
		uint64_t iocdatfl:1;
		uint64_t reserved_9_11:3;
		uint64_t dutresfl:1;
		uint64_t reserved_5_7:3;
		uint64_t vrtfl:1;
		uint64_t reserved_1_3:3;
		uint64_t tdffl:1;
#else
		uint64_t tdffl:1;
		uint64_t reserved_1_3:3;
		uint64_t vrtfl:1;
		uint64_t reserved_5_7:3;
		uint64_t dutresfl:1;
		uint64_t reserved_9_11:3;
		uint64_t iocdatfl:1;
		uint64_t reserved_13_15:3;
		uint64_t ioccmdfl:1;
		uint64_t reserved_17_31:15;
		uint64_t dutfl:4;
		uint64_t reserved_36_63:28;
#endif
	} cn61xx;
	struct cvmx_l2c_bst_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_38_63:26;
		uint64_t dutfl:6;
		uint64_t reserved_17_31:15;
		uint64_t ioccmdfl:1;
		uint64_t reserved_13_15:3;
		uint64_t iocdatfl:1;
		uint64_t reserved_9_11:3;
		uint64_t dutresfl:1;
		uint64_t reserved_5_7:3;
		uint64_t vrtfl:1;
		uint64_t reserved_1_3:3;
		uint64_t tdffl:1;
#else
		uint64_t tdffl:1;
		uint64_t reserved_1_3:3;
		uint64_t vrtfl:1;
		uint64_t reserved_5_7:3;
		uint64_t dutresfl:1;
		uint64_t reserved_9_11:3;
		uint64_t iocdatfl:1;
		uint64_t reserved_13_15:3;
		uint64_t ioccmdfl:1;
		uint64_t reserved_17_31:15;
		uint64_t dutfl:6;
		uint64_t reserved_38_63:26;
#endif
	} cn63xx;
	struct cvmx_l2c_bst_cn63xx cn63xxp1;
	struct cvmx_l2c_bst_cn66xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_42_63:22;
		uint64_t dutfl:10;
		uint64_t reserved_17_31:15;
		uint64_t ioccmdfl:1;
		uint64_t reserved_13_15:3;
		uint64_t iocdatfl:1;
		uint64_t reserved_9_11:3;
		uint64_t dutresfl:1;
		uint64_t reserved_5_7:3;
		uint64_t vrtfl:1;
		uint64_t reserved_1_3:3;
		uint64_t tdffl:1;
#else
		uint64_t tdffl:1;
		uint64_t reserved_1_3:3;
		uint64_t vrtfl:1;
		uint64_t reserved_5_7:3;
		uint64_t dutresfl:1;
		uint64_t reserved_9_11:3;
		uint64_t iocdatfl:1;
		uint64_t reserved_13_15:3;
		uint64_t ioccmdfl:1;
		uint64_t reserved_17_31:15;
		uint64_t dutfl:10;
		uint64_t reserved_42_63:22;
#endif
	} cn66xx;
	struct cvmx_l2c_bst_s cn68xx;
	struct cvmx_l2c_bst_s cn68xxp1;
	struct cvmx_l2c_bst_cn61xx cnf71xx;
};

union cvmx_l2c_bst0 {
	uint64_t u64;
	struct cvmx_l2c_bst0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t dtbnk:1;
		uint64_t wlb_msk:4;
		uint64_t dtcnt:13;
		uint64_t dt:1;
		uint64_t stin_msk:1;
		uint64_t wlb_dat:4;
#else
		uint64_t wlb_dat:4;
		uint64_t stin_msk:1;
		uint64_t dt:1;
		uint64_t dtcnt:13;
		uint64_t wlb_msk:4;
		uint64_t dtbnk:1;
		uint64_t reserved_24_63:40;
#endif
	} s;
	struct cvmx_l2c_bst0_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t wlb_msk:4;
		uint64_t reserved_15_18:4;
		uint64_t dtcnt:9;
		uint64_t dt:1;
		uint64_t reserved_4_4:1;
		uint64_t wlb_dat:4;
#else
		uint64_t wlb_dat:4;
		uint64_t reserved_4_4:1;
		uint64_t dt:1;
		uint64_t dtcnt:9;
		uint64_t reserved_15_18:4;
		uint64_t wlb_msk:4;
		uint64_t reserved_23_63:41;
#endif
	} cn30xx;
	struct cvmx_l2c_bst0_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_23_63:41;
		uint64_t wlb_msk:4;
		uint64_t reserved_16_18:3;
		uint64_t dtcnt:10;
		uint64_t dt:1;
		uint64_t stin_msk:1;
		uint64_t wlb_dat:4;
#else
		uint64_t wlb_dat:4;
		uint64_t stin_msk:1;
		uint64_t dt:1;
		uint64_t dtcnt:10;
		uint64_t reserved_16_18:3;
		uint64_t wlb_msk:4;
		uint64_t reserved_23_63:41;
#endif
	} cn31xx;
	struct cvmx_l2c_bst0_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t dtcnt:13;
		uint64_t dt:1;
		uint64_t stin_msk:1;
		uint64_t wlb_dat:4;
#else
		uint64_t wlb_dat:4;
		uint64_t stin_msk:1;
		uint64_t dt:1;
		uint64_t dtcnt:13;
		uint64_t reserved_19_63:45;
#endif
	} cn38xx;
	struct cvmx_l2c_bst0_cn38xx cn38xxp2;
	struct cvmx_l2c_bst0_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t dtbnk:1;
		uint64_t wlb_msk:4;
		uint64_t reserved_16_18:3;
		uint64_t dtcnt:10;
		uint64_t dt:1;
		uint64_t stin_msk:1;
		uint64_t wlb_dat:4;
#else
		uint64_t wlb_dat:4;
		uint64_t stin_msk:1;
		uint64_t dt:1;
		uint64_t dtcnt:10;
		uint64_t reserved_16_18:3;
		uint64_t wlb_msk:4;
		uint64_t dtbnk:1;
		uint64_t reserved_24_63:40;
#endif
	} cn50xx;
	struct cvmx_l2c_bst0_cn50xx cn52xx;
	struct cvmx_l2c_bst0_cn50xx cn52xxp1;
	struct cvmx_l2c_bst0_s cn56xx;
	struct cvmx_l2c_bst0_s cn56xxp1;
	struct cvmx_l2c_bst0_s cn58xx;
	struct cvmx_l2c_bst0_s cn58xxp1;
};

union cvmx_l2c_bst1 {
	uint64_t u64;
	struct cvmx_l2c_bst1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t l2t:9;
#else
		uint64_t l2t:9;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_l2c_bst1_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t vwdf:4;
		uint64_t lrf:2;
		uint64_t vab_vwcf:1;
		uint64_t reserved_5_8:4;
		uint64_t l2t:5;
#else
		uint64_t l2t:5;
		uint64_t reserved_5_8:4;
		uint64_t vab_vwcf:1;
		uint64_t lrf:2;
		uint64_t vwdf:4;
		uint64_t reserved_16_63:48;
#endif
	} cn30xx;
	struct cvmx_l2c_bst1_cn30xx cn31xx;
	struct cvmx_l2c_bst1_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t vwdf:4;
		uint64_t lrf:2;
		uint64_t vab_vwcf:1;
		uint64_t l2t:9;
#else
		uint64_t l2t:9;
		uint64_t vab_vwcf:1;
		uint64_t lrf:2;
		uint64_t vwdf:4;
		uint64_t reserved_16_63:48;
#endif
	} cn38xx;
	struct cvmx_l2c_bst1_cn38xx cn38xxp2;
	struct cvmx_l2c_bst1_cn38xx cn50xx;
	struct cvmx_l2c_bst1_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t plc2:1;
		uint64_t plc1:1;
		uint64_t plc0:1;
		uint64_t vwdf:4;
		uint64_t reserved_11_11:1;
		uint64_t ilc:1;
		uint64_t vab_vwcf:1;
		uint64_t l2t:9;
#else
		uint64_t l2t:9;
		uint64_t vab_vwcf:1;
		uint64_t ilc:1;
		uint64_t reserved_11_11:1;
		uint64_t vwdf:4;
		uint64_t plc0:1;
		uint64_t plc1:1;
		uint64_t plc2:1;
		uint64_t reserved_19_63:45;
#endif
	} cn52xx;
	struct cvmx_l2c_bst1_cn52xx cn52xxp1;
	struct cvmx_l2c_bst1_cn56xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t plc2:1;
		uint64_t plc1:1;
		uint64_t plc0:1;
		uint64_t ilc:1;
		uint64_t vwdf1:4;
		uint64_t vwdf0:4;
		uint64_t vab_vwcf1:1;
		uint64_t reserved_10_10:1;
		uint64_t vab_vwcf0:1;
		uint64_t l2t:9;
#else
		uint64_t l2t:9;
		uint64_t vab_vwcf0:1;
		uint64_t reserved_10_10:1;
		uint64_t vab_vwcf1:1;
		uint64_t vwdf0:4;
		uint64_t vwdf1:4;
		uint64_t ilc:1;
		uint64_t plc0:1;
		uint64_t plc1:1;
		uint64_t plc2:1;
		uint64_t reserved_24_63:40;
#endif
	} cn56xx;
	struct cvmx_l2c_bst1_cn56xx cn56xxp1;
	struct cvmx_l2c_bst1_cn38xx cn58xx;
	struct cvmx_l2c_bst1_cn38xx cn58xxp1;
};

union cvmx_l2c_bst2 {
	uint64_t u64;
	struct cvmx_l2c_bst2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mrb:4;
		uint64_t reserved_4_11:8;
		uint64_t ipcbst:1;
		uint64_t picbst:1;
		uint64_t xrdmsk:1;
		uint64_t xrddat:1;
#else
		uint64_t xrddat:1;
		uint64_t xrdmsk:1;
		uint64_t picbst:1;
		uint64_t ipcbst:1;
		uint64_t reserved_4_11:8;
		uint64_t mrb:4;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_l2c_bst2_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mrb:4;
		uint64_t rmdf:4;
		uint64_t reserved_4_7:4;
		uint64_t ipcbst:1;
		uint64_t reserved_2_2:1;
		uint64_t xrdmsk:1;
		uint64_t xrddat:1;
#else
		uint64_t xrddat:1;
		uint64_t xrdmsk:1;
		uint64_t reserved_2_2:1;
		uint64_t ipcbst:1;
		uint64_t reserved_4_7:4;
		uint64_t rmdf:4;
		uint64_t mrb:4;
		uint64_t reserved_16_63:48;
#endif
	} cn30xx;
	struct cvmx_l2c_bst2_cn30xx cn31xx;
	struct cvmx_l2c_bst2_cn38xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mrb:4;
		uint64_t rmdf:4;
		uint64_t rhdf:4;
		uint64_t ipcbst:1;
		uint64_t picbst:1;
		uint64_t xrdmsk:1;
		uint64_t xrddat:1;
#else
		uint64_t xrddat:1;
		uint64_t xrdmsk:1;
		uint64_t picbst:1;
		uint64_t ipcbst:1;
		uint64_t rhdf:4;
		uint64_t rmdf:4;
		uint64_t mrb:4;
		uint64_t reserved_16_63:48;
#endif
	} cn38xx;
	struct cvmx_l2c_bst2_cn38xx cn38xxp2;
	struct cvmx_l2c_bst2_cn30xx cn50xx;
	struct cvmx_l2c_bst2_cn30xx cn52xx;
	struct cvmx_l2c_bst2_cn30xx cn52xxp1;
	struct cvmx_l2c_bst2_cn56xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mrb:4;
		uint64_t rmdb:4;
		uint64_t rhdb:4;
		uint64_t ipcbst:1;
		uint64_t picbst:1;
		uint64_t xrdmsk:1;
		uint64_t xrddat:1;
#else
		uint64_t xrddat:1;
		uint64_t xrdmsk:1;
		uint64_t picbst:1;
		uint64_t ipcbst:1;
		uint64_t rhdb:4;
		uint64_t rmdb:4;
		uint64_t mrb:4;
		uint64_t reserved_16_63:48;
#endif
	} cn56xx;
	struct cvmx_l2c_bst2_cn56xx cn56xxp1;
	struct cvmx_l2c_bst2_cn56xx cn58xx;
	struct cvmx_l2c_bst2_cn56xx cn58xxp1;
};

union cvmx_l2c_bst_memx {
	uint64_t u64;
	struct cvmx_l2c_bst_memx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t start_bist:1;
		uint64_t clear_bist:1;
		uint64_t reserved_5_61:57;
		uint64_t rdffl:1;
		uint64_t vbffl:4;
#else
		uint64_t vbffl:4;
		uint64_t rdffl:1;
		uint64_t reserved_5_61:57;
		uint64_t clear_bist:1;
		uint64_t start_bist:1;
#endif
	} s;
	struct cvmx_l2c_bst_memx_s cn61xx;
	struct cvmx_l2c_bst_memx_s cn63xx;
	struct cvmx_l2c_bst_memx_s cn63xxp1;
	struct cvmx_l2c_bst_memx_s cn66xx;
	struct cvmx_l2c_bst_memx_s cn68xx;
	struct cvmx_l2c_bst_memx_s cn68xxp1;
	struct cvmx_l2c_bst_memx_s cnf71xx;
};

union cvmx_l2c_bst_tdtx {
	uint64_t u64;
	struct cvmx_l2c_bst_tdtx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t fbfrspfl:8;
		uint64_t sbffl:8;
		uint64_t fbffl:8;
		uint64_t l2dfl:8;
#else
		uint64_t l2dfl:8;
		uint64_t fbffl:8;
		uint64_t sbffl:8;
		uint64_t fbfrspfl:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_bst_tdtx_s cn61xx;
	struct cvmx_l2c_bst_tdtx_s cn63xx;
	struct cvmx_l2c_bst_tdtx_cn63xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t sbffl:8;
		uint64_t fbffl:8;
		uint64_t l2dfl:8;
#else
		uint64_t l2dfl:8;
		uint64_t fbffl:8;
		uint64_t sbffl:8;
		uint64_t reserved_24_63:40;
#endif
	} cn63xxp1;
	struct cvmx_l2c_bst_tdtx_s cn66xx;
	struct cvmx_l2c_bst_tdtx_s cn68xx;
	struct cvmx_l2c_bst_tdtx_s cn68xxp1;
	struct cvmx_l2c_bst_tdtx_s cnf71xx;
};

union cvmx_l2c_bst_ttgx {
	uint64_t u64;
	struct cvmx_l2c_bst_ttgx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_17_63:47;
		uint64_t lrufl:1;
		uint64_t tagfl:16;
#else
		uint64_t tagfl:16;
		uint64_t lrufl:1;
		uint64_t reserved_17_63:47;
#endif
	} s;
	struct cvmx_l2c_bst_ttgx_s cn61xx;
	struct cvmx_l2c_bst_ttgx_s cn63xx;
	struct cvmx_l2c_bst_ttgx_s cn63xxp1;
	struct cvmx_l2c_bst_ttgx_s cn66xx;
	struct cvmx_l2c_bst_ttgx_s cn68xx;
	struct cvmx_l2c_bst_ttgx_s cn68xxp1;
	struct cvmx_l2c_bst_ttgx_s cnf71xx;
};

union cvmx_l2c_cfg {
	uint64_t u64;
	struct cvmx_l2c_cfg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t bstrun:1;
		uint64_t lbist:1;
		uint64_t xor_bank:1;
		uint64_t dpres1:1;
		uint64_t dpres0:1;
		uint64_t dfill_dis:1;
		uint64_t fpexp:4;
		uint64_t fpempty:1;
		uint64_t fpen:1;
		uint64_t idxalias:1;
		uint64_t mwf_crd:4;
		uint64_t rsp_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t lrf_arb_mode:1;
#else
		uint64_t lrf_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t mwf_crd:4;
		uint64_t idxalias:1;
		uint64_t fpen:1;
		uint64_t fpempty:1;
		uint64_t fpexp:4;
		uint64_t dfill_dis:1;
		uint64_t dpres0:1;
		uint64_t dpres1:1;
		uint64_t xor_bank:1;
		uint64_t lbist:1;
		uint64_t bstrun:1;
		uint64_t reserved_20_63:44;
#endif
	} s;
	struct cvmx_l2c_cfg_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t fpexp:4;
		uint64_t fpempty:1;
		uint64_t fpen:1;
		uint64_t idxalias:1;
		uint64_t mwf_crd:4;
		uint64_t rsp_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t lrf_arb_mode:1;
#else
		uint64_t lrf_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t mwf_crd:4;
		uint64_t idxalias:1;
		uint64_t fpen:1;
		uint64_t fpempty:1;
		uint64_t fpexp:4;
		uint64_t reserved_14_63:50;
#endif
	} cn30xx;
	struct cvmx_l2c_cfg_cn30xx cn31xx;
	struct cvmx_l2c_cfg_cn30xx cn38xx;
	struct cvmx_l2c_cfg_cn30xx cn38xxp2;
	struct cvmx_l2c_cfg_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t bstrun:1;
		uint64_t lbist:1;
		uint64_t reserved_14_17:4;
		uint64_t fpexp:4;
		uint64_t fpempty:1;
		uint64_t fpen:1;
		uint64_t idxalias:1;
		uint64_t mwf_crd:4;
		uint64_t rsp_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t lrf_arb_mode:1;
#else
		uint64_t lrf_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t mwf_crd:4;
		uint64_t idxalias:1;
		uint64_t fpen:1;
		uint64_t fpempty:1;
		uint64_t fpexp:4;
		uint64_t reserved_14_17:4;
		uint64_t lbist:1;
		uint64_t bstrun:1;
		uint64_t reserved_20_63:44;
#endif
	} cn50xx;
	struct cvmx_l2c_cfg_cn50xx cn52xx;
	struct cvmx_l2c_cfg_cn50xx cn52xxp1;
	struct cvmx_l2c_cfg_s cn56xx;
	struct cvmx_l2c_cfg_s cn56xxp1;
	struct cvmx_l2c_cfg_cn58xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t bstrun:1;
		uint64_t lbist:1;
		uint64_t reserved_15_17:3;
		uint64_t dfill_dis:1;
		uint64_t fpexp:4;
		uint64_t fpempty:1;
		uint64_t fpen:1;
		uint64_t idxalias:1;
		uint64_t mwf_crd:4;
		uint64_t rsp_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t lrf_arb_mode:1;
#else
		uint64_t lrf_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t mwf_crd:4;
		uint64_t idxalias:1;
		uint64_t fpen:1;
		uint64_t fpempty:1;
		uint64_t fpexp:4;
		uint64_t dfill_dis:1;
		uint64_t reserved_15_17:3;
		uint64_t lbist:1;
		uint64_t bstrun:1;
		uint64_t reserved_20_63:44;
#endif
	} cn58xx;
	struct cvmx_l2c_cfg_cn58xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_15_63:49;
		uint64_t dfill_dis:1;
		uint64_t fpexp:4;
		uint64_t fpempty:1;
		uint64_t fpen:1;
		uint64_t idxalias:1;
		uint64_t mwf_crd:4;
		uint64_t rsp_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t lrf_arb_mode:1;
#else
		uint64_t lrf_arb_mode:1;
		uint64_t rfb_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t mwf_crd:4;
		uint64_t idxalias:1;
		uint64_t fpen:1;
		uint64_t fpempty:1;
		uint64_t fpexp:4;
		uint64_t dfill_dis:1;
		uint64_t reserved_15_63:49;
#endif
	} cn58xxp1;
};

union cvmx_l2c_cop0_mapx {
	uint64_t u64;
	struct cvmx_l2c_cop0_mapx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t data:64;
#else
		uint64_t data:64;
#endif
	} s;
	struct cvmx_l2c_cop0_mapx_s cn61xx;
	struct cvmx_l2c_cop0_mapx_s cn63xx;
	struct cvmx_l2c_cop0_mapx_s cn63xxp1;
	struct cvmx_l2c_cop0_mapx_s cn66xx;
	struct cvmx_l2c_cop0_mapx_s cn68xx;
	struct cvmx_l2c_cop0_mapx_s cn68xxp1;
	struct cvmx_l2c_cop0_mapx_s cnf71xx;
};

union cvmx_l2c_ctl {
	uint64_t u64;
	struct cvmx_l2c_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_30_63:34;
		uint64_t sepcmt:1;
		uint64_t rdf_fast:1;
		uint64_t disstgl2i:1;
		uint64_t l2dfsbe:1;
		uint64_t l2dfdbe:1;
		uint64_t discclk:1;
		uint64_t maxvab:4;
		uint64_t maxlfb:4;
		uint64_t rsp_arb_mode:1;
		uint64_t xmc_arb_mode:1;
		uint64_t ef_ena:1;
		uint64_t ef_cnt:7;
		uint64_t vab_thresh:4;
		uint64_t disecc:1;
		uint64_t disidxalias:1;
#else
		uint64_t disidxalias:1;
		uint64_t disecc:1;
		uint64_t vab_thresh:4;
		uint64_t ef_cnt:7;
		uint64_t ef_ena:1;
		uint64_t xmc_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t maxlfb:4;
		uint64_t maxvab:4;
		uint64_t discclk:1;
		uint64_t l2dfdbe:1;
		uint64_t l2dfsbe:1;
		uint64_t disstgl2i:1;
		uint64_t rdf_fast:1;
		uint64_t sepcmt:1;
		uint64_t reserved_30_63:34;
#endif
	} s;
	struct cvmx_l2c_ctl_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_29_63:35;
		uint64_t rdf_fast:1;
		uint64_t disstgl2i:1;
		uint64_t l2dfsbe:1;
		uint64_t l2dfdbe:1;
		uint64_t discclk:1;
		uint64_t maxvab:4;
		uint64_t maxlfb:4;
		uint64_t rsp_arb_mode:1;
		uint64_t xmc_arb_mode:1;
		uint64_t ef_ena:1;
		uint64_t ef_cnt:7;
		uint64_t vab_thresh:4;
		uint64_t disecc:1;
		uint64_t disidxalias:1;
#else
		uint64_t disidxalias:1;
		uint64_t disecc:1;
		uint64_t vab_thresh:4;
		uint64_t ef_cnt:7;
		uint64_t ef_ena:1;
		uint64_t xmc_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t maxlfb:4;
		uint64_t maxvab:4;
		uint64_t discclk:1;
		uint64_t l2dfdbe:1;
		uint64_t l2dfsbe:1;
		uint64_t disstgl2i:1;
		uint64_t rdf_fast:1;
		uint64_t reserved_29_63:35;
#endif
	} cn61xx;
	struct cvmx_l2c_ctl_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_28_63:36;
		uint64_t disstgl2i:1;
		uint64_t l2dfsbe:1;
		uint64_t l2dfdbe:1;
		uint64_t discclk:1;
		uint64_t maxvab:4;
		uint64_t maxlfb:4;
		uint64_t rsp_arb_mode:1;
		uint64_t xmc_arb_mode:1;
		uint64_t ef_ena:1;
		uint64_t ef_cnt:7;
		uint64_t vab_thresh:4;
		uint64_t disecc:1;
		uint64_t disidxalias:1;
#else
		uint64_t disidxalias:1;
		uint64_t disecc:1;
		uint64_t vab_thresh:4;
		uint64_t ef_cnt:7;
		uint64_t ef_ena:1;
		uint64_t xmc_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t maxlfb:4;
		uint64_t maxvab:4;
		uint64_t discclk:1;
		uint64_t l2dfdbe:1;
		uint64_t l2dfsbe:1;
		uint64_t disstgl2i:1;
		uint64_t reserved_28_63:36;
#endif
	} cn63xx;
	struct cvmx_l2c_ctl_cn63xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_25_63:39;
		uint64_t discclk:1;
		uint64_t maxvab:4;
		uint64_t maxlfb:4;
		uint64_t rsp_arb_mode:1;
		uint64_t xmc_arb_mode:1;
		uint64_t ef_ena:1;
		uint64_t ef_cnt:7;
		uint64_t vab_thresh:4;
		uint64_t disecc:1;
		uint64_t disidxalias:1;
#else
		uint64_t disidxalias:1;
		uint64_t disecc:1;
		uint64_t vab_thresh:4;
		uint64_t ef_cnt:7;
		uint64_t ef_ena:1;
		uint64_t xmc_arb_mode:1;
		uint64_t rsp_arb_mode:1;
		uint64_t maxlfb:4;
		uint64_t maxvab:4;
		uint64_t discclk:1;
		uint64_t reserved_25_63:39;
#endif
	} cn63xxp1;
	struct cvmx_l2c_ctl_cn61xx cn66xx;
	struct cvmx_l2c_ctl_s cn68xx;
	struct cvmx_l2c_ctl_cn63xx cn68xxp1;
	struct cvmx_l2c_ctl_cn61xx cnf71xx;
};

union cvmx_l2c_dbg {
	uint64_t u64;
	struct cvmx_l2c_dbg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_15_63:49;
		uint64_t lfb_enum:4;
		uint64_t lfb_dmp:1;
		uint64_t ppnum:4;
		uint64_t set:3;
		uint64_t finv:1;
		uint64_t l2d:1;
		uint64_t l2t:1;
#else
		uint64_t l2t:1;
		uint64_t l2d:1;
		uint64_t finv:1;
		uint64_t set:3;
		uint64_t ppnum:4;
		uint64_t lfb_dmp:1;
		uint64_t lfb_enum:4;
		uint64_t reserved_15_63:49;
#endif
	} s;
	struct cvmx_l2c_dbg_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_13_63:51;
		uint64_t lfb_enum:2;
		uint64_t lfb_dmp:1;
		uint64_t reserved_7_9:3;
		uint64_t ppnum:1;
		uint64_t reserved_5_5:1;
		uint64_t set:2;
		uint64_t finv:1;
		uint64_t l2d:1;
		uint64_t l2t:1;
#else
		uint64_t l2t:1;
		uint64_t l2d:1;
		uint64_t finv:1;
		uint64_t set:2;
		uint64_t reserved_5_5:1;
		uint64_t ppnum:1;
		uint64_t reserved_7_9:3;
		uint64_t lfb_dmp:1;
		uint64_t lfb_enum:2;
		uint64_t reserved_13_63:51;
#endif
	} cn30xx;
	struct cvmx_l2c_dbg_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t lfb_enum:3;
		uint64_t lfb_dmp:1;
		uint64_t reserved_7_9:3;
		uint64_t ppnum:1;
		uint64_t reserved_5_5:1;
		uint64_t set:2;
		uint64_t finv:1;
		uint64_t l2d:1;
		uint64_t l2t:1;
#else
		uint64_t l2t:1;
		uint64_t l2d:1;
		uint64_t finv:1;
		uint64_t set:2;
		uint64_t reserved_5_5:1;
		uint64_t ppnum:1;
		uint64_t reserved_7_9:3;
		uint64_t lfb_dmp:1;
		uint64_t lfb_enum:3;
		uint64_t reserved_14_63:50;
#endif
	} cn31xx;
	struct cvmx_l2c_dbg_s cn38xx;
	struct cvmx_l2c_dbg_s cn38xxp2;
	struct cvmx_l2c_dbg_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t lfb_enum:3;
		uint64_t lfb_dmp:1;
		uint64_t reserved_7_9:3;
		uint64_t ppnum:1;
		uint64_t set:3;
		uint64_t finv:1;
		uint64_t l2d:1;
		uint64_t l2t:1;
#else
		uint64_t l2t:1;
		uint64_t l2d:1;
		uint64_t finv:1;
		uint64_t set:3;
		uint64_t ppnum:1;
		uint64_t reserved_7_9:3;
		uint64_t lfb_dmp:1;
		uint64_t lfb_enum:3;
		uint64_t reserved_14_63:50;
#endif
	} cn50xx;
	struct cvmx_l2c_dbg_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t lfb_enum:3;
		uint64_t lfb_dmp:1;
		uint64_t reserved_8_9:2;
		uint64_t ppnum:2;
		uint64_t set:3;
		uint64_t finv:1;
		uint64_t l2d:1;
		uint64_t l2t:1;
#else
		uint64_t l2t:1;
		uint64_t l2d:1;
		uint64_t finv:1;
		uint64_t set:3;
		uint64_t ppnum:2;
		uint64_t reserved_8_9:2;
		uint64_t lfb_dmp:1;
		uint64_t lfb_enum:3;
		uint64_t reserved_14_63:50;
#endif
	} cn52xx;
	struct cvmx_l2c_dbg_cn52xx cn52xxp1;
	struct cvmx_l2c_dbg_s cn56xx;
	struct cvmx_l2c_dbg_s cn56xxp1;
	struct cvmx_l2c_dbg_s cn58xx;
	struct cvmx_l2c_dbg_s cn58xxp1;
};

union cvmx_l2c_dut {
	uint64_t u64;
	struct cvmx_l2c_dut_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t dtena:1;
		uint64_t reserved_30_30:1;
		uint64_t dt_vld:1;
		uint64_t dt_tag:29;
#else
		uint64_t dt_tag:29;
		uint64_t dt_vld:1;
		uint64_t reserved_30_30:1;
		uint64_t dtena:1;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_dut_s cn30xx;
	struct cvmx_l2c_dut_s cn31xx;
	struct cvmx_l2c_dut_s cn38xx;
	struct cvmx_l2c_dut_s cn38xxp2;
	struct cvmx_l2c_dut_s cn50xx;
	struct cvmx_l2c_dut_s cn52xx;
	struct cvmx_l2c_dut_s cn52xxp1;
	struct cvmx_l2c_dut_s cn56xx;
	struct cvmx_l2c_dut_s cn56xxp1;
	struct cvmx_l2c_dut_s cn58xx;
	struct cvmx_l2c_dut_s cn58xxp1;
};

union cvmx_l2c_dut_mapx {
	uint64_t u64;
	struct cvmx_l2c_dut_mapx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_38_63:26;
		uint64_t tag:28;
		uint64_t reserved_1_9:9;
		uint64_t valid:1;
#else
		uint64_t valid:1;
		uint64_t reserved_1_9:9;
		uint64_t tag:28;
		uint64_t reserved_38_63:26;
#endif
	} s;
	struct cvmx_l2c_dut_mapx_s cn61xx;
	struct cvmx_l2c_dut_mapx_s cn63xx;
	struct cvmx_l2c_dut_mapx_s cn63xxp1;
	struct cvmx_l2c_dut_mapx_s cn66xx;
	struct cvmx_l2c_dut_mapx_s cn68xx;
	struct cvmx_l2c_dut_mapx_s cn68xxp1;
	struct cvmx_l2c_dut_mapx_s cnf71xx;
};

union cvmx_l2c_err_tdtx {
	uint64_t u64;
	struct cvmx_l2c_err_tdtx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dbe:1;
		uint64_t sbe:1;
		uint64_t vdbe:1;
		uint64_t vsbe:1;
		uint64_t syn:10;
		uint64_t reserved_22_49:28;
		uint64_t wayidx:18;
		uint64_t reserved_2_3:2;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_3:2;
		uint64_t wayidx:18;
		uint64_t reserved_22_49:28;
		uint64_t syn:10;
		uint64_t vsbe:1;
		uint64_t vdbe:1;
		uint64_t sbe:1;
		uint64_t dbe:1;
#endif
	} s;
	struct cvmx_l2c_err_tdtx_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dbe:1;
		uint64_t sbe:1;
		uint64_t vdbe:1;
		uint64_t vsbe:1;
		uint64_t syn:10;
		uint64_t reserved_20_49:30;
		uint64_t wayidx:16;
		uint64_t reserved_2_3:2;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_3:2;
		uint64_t wayidx:16;
		uint64_t reserved_20_49:30;
		uint64_t syn:10;
		uint64_t vsbe:1;
		uint64_t vdbe:1;
		uint64_t sbe:1;
		uint64_t dbe:1;
#endif
	} cn61xx;
	struct cvmx_l2c_err_tdtx_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dbe:1;
		uint64_t sbe:1;
		uint64_t vdbe:1;
		uint64_t vsbe:1;
		uint64_t syn:10;
		uint64_t reserved_21_49:29;
		uint64_t wayidx:17;
		uint64_t reserved_2_3:2;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_3:2;
		uint64_t wayidx:17;
		uint64_t reserved_21_49:29;
		uint64_t syn:10;
		uint64_t vsbe:1;
		uint64_t vdbe:1;
		uint64_t sbe:1;
		uint64_t dbe:1;
#endif
	} cn63xx;
	struct cvmx_l2c_err_tdtx_cn63xx cn63xxp1;
	struct cvmx_l2c_err_tdtx_cn63xx cn66xx;
	struct cvmx_l2c_err_tdtx_s cn68xx;
	struct cvmx_l2c_err_tdtx_s cn68xxp1;
	struct cvmx_l2c_err_tdtx_cn61xx cnf71xx;
};

union cvmx_l2c_err_ttgx {
	uint64_t u64;
	struct cvmx_l2c_err_ttgx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dbe:1;
		uint64_t sbe:1;
		uint64_t noway:1;
		uint64_t reserved_56_60:5;
		uint64_t syn:6;
		uint64_t reserved_22_49:28;
		uint64_t wayidx:15;
		uint64_t reserved_2_6:5;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_6:5;
		uint64_t wayidx:15;
		uint64_t reserved_22_49:28;
		uint64_t syn:6;
		uint64_t reserved_56_60:5;
		uint64_t noway:1;
		uint64_t sbe:1;
		uint64_t dbe:1;
#endif
	} s;
	struct cvmx_l2c_err_ttgx_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dbe:1;
		uint64_t sbe:1;
		uint64_t noway:1;
		uint64_t reserved_56_60:5;
		uint64_t syn:6;
		uint64_t reserved_20_49:30;
		uint64_t wayidx:13;
		uint64_t reserved_2_6:5;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_6:5;
		uint64_t wayidx:13;
		uint64_t reserved_20_49:30;
		uint64_t syn:6;
		uint64_t reserved_56_60:5;
		uint64_t noway:1;
		uint64_t sbe:1;
		uint64_t dbe:1;
#endif
	} cn61xx;
	struct cvmx_l2c_err_ttgx_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t dbe:1;
		uint64_t sbe:1;
		uint64_t noway:1;
		uint64_t reserved_56_60:5;
		uint64_t syn:6;
		uint64_t reserved_21_49:29;
		uint64_t wayidx:14;
		uint64_t reserved_2_6:5;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_6:5;
		uint64_t wayidx:14;
		uint64_t reserved_21_49:29;
		uint64_t syn:6;
		uint64_t reserved_56_60:5;
		uint64_t noway:1;
		uint64_t sbe:1;
		uint64_t dbe:1;
#endif
	} cn63xx;
	struct cvmx_l2c_err_ttgx_cn63xx cn63xxp1;
	struct cvmx_l2c_err_ttgx_cn63xx cn66xx;
	struct cvmx_l2c_err_ttgx_s cn68xx;
	struct cvmx_l2c_err_ttgx_s cn68xxp1;
	struct cvmx_l2c_err_ttgx_cn61xx cnf71xx;
};

union cvmx_l2c_err_vbfx {
	uint64_t u64;
	struct cvmx_l2c_err_vbfx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_62_63:2;
		uint64_t vdbe:1;
		uint64_t vsbe:1;
		uint64_t vsyn:10;
		uint64_t reserved_2_49:48;
		uint64_t type:2;
#else
		uint64_t type:2;
		uint64_t reserved_2_49:48;
		uint64_t vsyn:10;
		uint64_t vsbe:1;
		uint64_t vdbe:1;
		uint64_t reserved_62_63:2;
#endif
	} s;
	struct cvmx_l2c_err_vbfx_s cn61xx;
	struct cvmx_l2c_err_vbfx_s cn63xx;
	struct cvmx_l2c_err_vbfx_s cn63xxp1;
	struct cvmx_l2c_err_vbfx_s cn66xx;
	struct cvmx_l2c_err_vbfx_s cn68xx;
	struct cvmx_l2c_err_vbfx_s cn68xxp1;
	struct cvmx_l2c_err_vbfx_s cnf71xx;
};

union cvmx_l2c_err_xmc {
	uint64_t u64;
	struct cvmx_l2c_err_xmc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t cmd:6;
		uint64_t reserved_54_57:4;
		uint64_t sid:6;
		uint64_t reserved_38_47:10;
		uint64_t addr:38;
#else
		uint64_t addr:38;
		uint64_t reserved_38_47:10;
		uint64_t sid:6;
		uint64_t reserved_54_57:4;
		uint64_t cmd:6;
#endif
	} s;
	struct cvmx_l2c_err_xmc_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t cmd:6;
		uint64_t reserved_52_57:6;
		uint64_t sid:4;
		uint64_t reserved_38_47:10;
		uint64_t addr:38;
#else
		uint64_t addr:38;
		uint64_t reserved_38_47:10;
		uint64_t sid:4;
		uint64_t reserved_52_57:6;
		uint64_t cmd:6;
#endif
	} cn61xx;
	struct cvmx_l2c_err_xmc_cn61xx cn63xx;
	struct cvmx_l2c_err_xmc_cn61xx cn63xxp1;
	struct cvmx_l2c_err_xmc_cn66xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t cmd:6;
		uint64_t reserved_53_57:5;
		uint64_t sid:5;
		uint64_t reserved_38_47:10;
		uint64_t addr:38;
#else
		uint64_t addr:38;
		uint64_t reserved_38_47:10;
		uint64_t sid:5;
		uint64_t reserved_53_57:5;
		uint64_t cmd:6;
#endif
	} cn66xx;
	struct cvmx_l2c_err_xmc_s cn68xx;
	struct cvmx_l2c_err_xmc_s cn68xxp1;
	struct cvmx_l2c_err_xmc_cn61xx cnf71xx;
};

union cvmx_l2c_grpwrr0 {
	uint64_t u64;
	struct cvmx_l2c_grpwrr0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t plc1rmsk:32;
		uint64_t plc0rmsk:32;
#else
		uint64_t plc0rmsk:32;
		uint64_t plc1rmsk:32;
#endif
	} s;
	struct cvmx_l2c_grpwrr0_s cn52xx;
	struct cvmx_l2c_grpwrr0_s cn52xxp1;
	struct cvmx_l2c_grpwrr0_s cn56xx;
	struct cvmx_l2c_grpwrr0_s cn56xxp1;
};

union cvmx_l2c_grpwrr1 {
	uint64_t u64;
	struct cvmx_l2c_grpwrr1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t ilcrmsk:32;
		uint64_t plc2rmsk:32;
#else
		uint64_t plc2rmsk:32;
		uint64_t ilcrmsk:32;
#endif
	} s;
	struct cvmx_l2c_grpwrr1_s cn52xx;
	struct cvmx_l2c_grpwrr1_s cn52xxp1;
	struct cvmx_l2c_grpwrr1_s cn56xx;
	struct cvmx_l2c_grpwrr1_s cn56xxp1;
};

union cvmx_l2c_int_en {
	uint64_t u64;
	struct cvmx_l2c_int_en_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t lck2ena:1;
		uint64_t lckena:1;
		uint64_t l2ddeden:1;
		uint64_t l2dsecen:1;
		uint64_t l2tdeden:1;
		uint64_t l2tsecen:1;
		uint64_t oob3en:1;
		uint64_t oob2en:1;
		uint64_t oob1en:1;
#else
		uint64_t oob1en:1;
		uint64_t oob2en:1;
		uint64_t oob3en:1;
		uint64_t l2tsecen:1;
		uint64_t l2tdeden:1;
		uint64_t l2dsecen:1;
		uint64_t l2ddeden:1;
		uint64_t lckena:1;
		uint64_t lck2ena:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_l2c_int_en_s cn52xx;
	struct cvmx_l2c_int_en_s cn52xxp1;
	struct cvmx_l2c_int_en_s cn56xx;
	struct cvmx_l2c_int_en_s cn56xxp1;
};

union cvmx_l2c_int_ena {
	uint64_t u64;
	struct cvmx_l2c_int_ena_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t bigrd:1;
		uint64_t bigwr:1;
		uint64_t vrtpe:1;
		uint64_t vrtadrng:1;
		uint64_t vrtidrng:1;
		uint64_t vrtwr:1;
		uint64_t holewr:1;
		uint64_t holerd:1;
#else
		uint64_t holerd:1;
		uint64_t holewr:1;
		uint64_t vrtwr:1;
		uint64_t vrtidrng:1;
		uint64_t vrtadrng:1;
		uint64_t vrtpe:1;
		uint64_t bigwr:1;
		uint64_t bigrd:1;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_l2c_int_ena_s cn61xx;
	struct cvmx_l2c_int_ena_s cn63xx;
	struct cvmx_l2c_int_ena_cn63xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t vrtpe:1;
		uint64_t vrtadrng:1;
		uint64_t vrtidrng:1;
		uint64_t vrtwr:1;
		uint64_t holewr:1;
		uint64_t holerd:1;
#else
		uint64_t holerd:1;
		uint64_t holewr:1;
		uint64_t vrtwr:1;
		uint64_t vrtidrng:1;
		uint64_t vrtadrng:1;
		uint64_t vrtpe:1;
		uint64_t reserved_6_63:58;
#endif
	} cn63xxp1;
	struct cvmx_l2c_int_ena_s cn66xx;
	struct cvmx_l2c_int_ena_s cn68xx;
	struct cvmx_l2c_int_ena_s cn68xxp1;
	struct cvmx_l2c_int_ena_s cnf71xx;
};

union cvmx_l2c_int_reg {
	uint64_t u64;
	struct cvmx_l2c_int_reg_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_20_63:44;
		uint64_t tad3:1;
		uint64_t tad2:1;
		uint64_t tad1:1;
		uint64_t tad0:1;
		uint64_t reserved_8_15:8;
		uint64_t bigrd:1;
		uint64_t bigwr:1;
		uint64_t vrtpe:1;
		uint64_t vrtadrng:1;
		uint64_t vrtidrng:1;
		uint64_t vrtwr:1;
		uint64_t holewr:1;
		uint64_t holerd:1;
#else
		uint64_t holerd:1;
		uint64_t holewr:1;
		uint64_t vrtwr:1;
		uint64_t vrtidrng:1;
		uint64_t vrtadrng:1;
		uint64_t vrtpe:1;
		uint64_t bigwr:1;
		uint64_t bigrd:1;
		uint64_t reserved_8_15:8;
		uint64_t tad0:1;
		uint64_t tad1:1;
		uint64_t tad2:1;
		uint64_t tad3:1;
		uint64_t reserved_20_63:44;
#endif
	} s;
	struct cvmx_l2c_int_reg_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_17_63:47;
		uint64_t tad0:1;
		uint64_t reserved_8_15:8;
		uint64_t bigrd:1;
		uint64_t bigwr:1;
		uint64_t vrtpe:1;
		uint64_t vrtadrng:1;
		uint64_t vrtidrng:1;
		uint64_t vrtwr:1;
		uint64_t holewr:1;
		uint64_t holerd:1;
#else
		uint64_t holerd:1;
		uint64_t holewr:1;
		uint64_t vrtwr:1;
		uint64_t vrtidrng:1;
		uint64_t vrtadrng:1;
		uint64_t vrtpe:1;
		uint64_t bigwr:1;
		uint64_t bigrd:1;
		uint64_t reserved_8_15:8;
		uint64_t tad0:1;
		uint64_t reserved_17_63:47;
#endif
	} cn61xx;
	struct cvmx_l2c_int_reg_cn61xx cn63xx;
	struct cvmx_l2c_int_reg_cn63xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_17_63:47;
		uint64_t tad0:1;
		uint64_t reserved_6_15:10;
		uint64_t vrtpe:1;
		uint64_t vrtadrng:1;
		uint64_t vrtidrng:1;
		uint64_t vrtwr:1;
		uint64_t holewr:1;
		uint64_t holerd:1;
#else
		uint64_t holerd:1;
		uint64_t holewr:1;
		uint64_t vrtwr:1;
		uint64_t vrtidrng:1;
		uint64_t vrtadrng:1;
		uint64_t vrtpe:1;
		uint64_t reserved_6_15:10;
		uint64_t tad0:1;
		uint64_t reserved_17_63:47;
#endif
	} cn63xxp1;
	struct cvmx_l2c_int_reg_cn61xx cn66xx;
	struct cvmx_l2c_int_reg_s cn68xx;
	struct cvmx_l2c_int_reg_s cn68xxp1;
	struct cvmx_l2c_int_reg_cn61xx cnf71xx;
};

union cvmx_l2c_int_stat {
	uint64_t u64;
	struct cvmx_l2c_int_stat_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t lck2:1;
		uint64_t lck:1;
		uint64_t l2dded:1;
		uint64_t l2dsec:1;
		uint64_t l2tded:1;
		uint64_t l2tsec:1;
		uint64_t oob3:1;
		uint64_t oob2:1;
		uint64_t oob1:1;
#else
		uint64_t oob1:1;
		uint64_t oob2:1;
		uint64_t oob3:1;
		uint64_t l2tsec:1;
		uint64_t l2tded:1;
		uint64_t l2dsec:1;
		uint64_t l2dded:1;
		uint64_t lck:1;
		uint64_t lck2:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_l2c_int_stat_s cn52xx;
	struct cvmx_l2c_int_stat_s cn52xxp1;
	struct cvmx_l2c_int_stat_s cn56xx;
	struct cvmx_l2c_int_stat_s cn56xxp1;
};

union cvmx_l2c_iocx_pfc {
	uint64_t u64;
	struct cvmx_l2c_iocx_pfc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_iocx_pfc_s cn61xx;
	struct cvmx_l2c_iocx_pfc_s cn63xx;
	struct cvmx_l2c_iocx_pfc_s cn63xxp1;
	struct cvmx_l2c_iocx_pfc_s cn66xx;
	struct cvmx_l2c_iocx_pfc_s cn68xx;
	struct cvmx_l2c_iocx_pfc_s cn68xxp1;
	struct cvmx_l2c_iocx_pfc_s cnf71xx;
};

union cvmx_l2c_iorx_pfc {
	uint64_t u64;
	struct cvmx_l2c_iorx_pfc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_iorx_pfc_s cn61xx;
	struct cvmx_l2c_iorx_pfc_s cn63xx;
	struct cvmx_l2c_iorx_pfc_s cn63xxp1;
	struct cvmx_l2c_iorx_pfc_s cn66xx;
	struct cvmx_l2c_iorx_pfc_s cn68xx;
	struct cvmx_l2c_iorx_pfc_s cn68xxp1;
	struct cvmx_l2c_iorx_pfc_s cnf71xx;
};

union cvmx_l2c_lckbase {
	uint64_t u64;
	struct cvmx_l2c_lckbase_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_31_63:33;
		uint64_t lck_base:27;
		uint64_t reserved_1_3:3;
		uint64_t lck_ena:1;
#else
		uint64_t lck_ena:1;
		uint64_t reserved_1_3:3;
		uint64_t lck_base:27;
		uint64_t reserved_31_63:33;
#endif
	} s;
	struct cvmx_l2c_lckbase_s cn30xx;
	struct cvmx_l2c_lckbase_s cn31xx;
	struct cvmx_l2c_lckbase_s cn38xx;
	struct cvmx_l2c_lckbase_s cn38xxp2;
	struct cvmx_l2c_lckbase_s cn50xx;
	struct cvmx_l2c_lckbase_s cn52xx;
	struct cvmx_l2c_lckbase_s cn52xxp1;
	struct cvmx_l2c_lckbase_s cn56xx;
	struct cvmx_l2c_lckbase_s cn56xxp1;
	struct cvmx_l2c_lckbase_s cn58xx;
	struct cvmx_l2c_lckbase_s cn58xxp1;
};

union cvmx_l2c_lckoff {
	uint64_t u64;
	struct cvmx_l2c_lckoff_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t lck_offset:10;
#else
		uint64_t lck_offset:10;
		uint64_t reserved_10_63:54;
#endif
	} s;
	struct cvmx_l2c_lckoff_s cn30xx;
	struct cvmx_l2c_lckoff_s cn31xx;
	struct cvmx_l2c_lckoff_s cn38xx;
	struct cvmx_l2c_lckoff_s cn38xxp2;
	struct cvmx_l2c_lckoff_s cn50xx;
	struct cvmx_l2c_lckoff_s cn52xx;
	struct cvmx_l2c_lckoff_s cn52xxp1;
	struct cvmx_l2c_lckoff_s cn56xx;
	struct cvmx_l2c_lckoff_s cn56xxp1;
	struct cvmx_l2c_lckoff_s cn58xx;
	struct cvmx_l2c_lckoff_s cn58xxp1;
};

union cvmx_l2c_lfb0 {
	uint64_t u64;
	struct cvmx_l2c_lfb0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t stcpnd:1;
		uint64_t stpnd:1;
		uint64_t stinv:1;
		uint64_t stcfl:1;
		uint64_t vam:1;
		uint64_t inxt:4;
		uint64_t itl:1;
		uint64_t ihd:1;
		uint64_t set:3;
		uint64_t vabnum:4;
		uint64_t sid:9;
		uint64_t cmd:4;
		uint64_t vld:1;
#else
		uint64_t vld:1;
		uint64_t cmd:4;
		uint64_t sid:9;
		uint64_t vabnum:4;
		uint64_t set:3;
		uint64_t ihd:1;
		uint64_t itl:1;
		uint64_t inxt:4;
		uint64_t vam:1;
		uint64_t stcfl:1;
		uint64_t stinv:1;
		uint64_t stpnd:1;
		uint64_t stcpnd:1;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_lfb0_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t stcpnd:1;
		uint64_t stpnd:1;
		uint64_t stinv:1;
		uint64_t stcfl:1;
		uint64_t vam:1;
		uint64_t reserved_25_26:2;
		uint64_t inxt:2;
		uint64_t itl:1;
		uint64_t ihd:1;
		uint64_t reserved_20_20:1;
		uint64_t set:2;
		uint64_t reserved_16_17:2;
		uint64_t vabnum:2;
		uint64_t sid:9;
		uint64_t cmd:4;
		uint64_t vld:1;
#else
		uint64_t vld:1;
		uint64_t cmd:4;
		uint64_t sid:9;
		uint64_t vabnum:2;
		uint64_t reserved_16_17:2;
		uint64_t set:2;
		uint64_t reserved_20_20:1;
		uint64_t ihd:1;
		uint64_t itl:1;
		uint64_t inxt:2;
		uint64_t reserved_25_26:2;
		uint64_t vam:1;
		uint64_t stcfl:1;
		uint64_t stinv:1;
		uint64_t stpnd:1;
		uint64_t stcpnd:1;
		uint64_t reserved_32_63:32;
#endif
	} cn30xx;
	struct cvmx_l2c_lfb0_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t stcpnd:1;
		uint64_t stpnd:1;
		uint64_t stinv:1;
		uint64_t stcfl:1;
		uint64_t vam:1;
		uint64_t reserved_26_26:1;
		uint64_t inxt:3;
		uint64_t itl:1;
		uint64_t ihd:1;
		uint64_t reserved_20_20:1;
		uint64_t set:2;
		uint64_t reserved_17_17:1;
		uint64_t vabnum:3;
		uint64_t sid:9;
		uint64_t cmd:4;
		uint64_t vld:1;
#else
		uint64_t vld:1;
		uint64_t cmd:4;
		uint64_t sid:9;
		uint64_t vabnum:3;
		uint64_t reserved_17_17:1;
		uint64_t set:2;
		uint64_t reserved_20_20:1;
		uint64_t ihd:1;
		uint64_t itl:1;
		uint64_t inxt:3;
		uint64_t reserved_26_26:1;
		uint64_t vam:1;
		uint64_t stcfl:1;
		uint64_t stinv:1;
		uint64_t stpnd:1;
		uint64_t stcpnd:1;
		uint64_t reserved_32_63:32;
#endif
	} cn31xx;
	struct cvmx_l2c_lfb0_s cn38xx;
	struct cvmx_l2c_lfb0_s cn38xxp2;
	struct cvmx_l2c_lfb0_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t stcpnd:1;
		uint64_t stpnd:1;
		uint64_t stinv:1;
		uint64_t stcfl:1;
		uint64_t vam:1;
		uint64_t reserved_26_26:1;
		uint64_t inxt:3;
		uint64_t itl:1;
		uint64_t ihd:1;
		uint64_t set:3;
		uint64_t reserved_17_17:1;
		uint64_t vabnum:3;
		uint64_t sid:9;
		uint64_t cmd:4;
		uint64_t vld:1;
#else
		uint64_t vld:1;
		uint64_t cmd:4;
		uint64_t sid:9;
		uint64_t vabnum:3;
		uint64_t reserved_17_17:1;
		uint64_t set:3;
		uint64_t ihd:1;
		uint64_t itl:1;
		uint64_t inxt:3;
		uint64_t reserved_26_26:1;
		uint64_t vam:1;
		uint64_t stcfl:1;
		uint64_t stinv:1;
		uint64_t stpnd:1;
		uint64_t stcpnd:1;
		uint64_t reserved_32_63:32;
#endif
	} cn50xx;
	struct cvmx_l2c_lfb0_cn50xx cn52xx;
	struct cvmx_l2c_lfb0_cn50xx cn52xxp1;
	struct cvmx_l2c_lfb0_s cn56xx;
	struct cvmx_l2c_lfb0_s cn56xxp1;
	struct cvmx_l2c_lfb0_s cn58xx;
	struct cvmx_l2c_lfb0_s cn58xxp1;
};

union cvmx_l2c_lfb1 {
	uint64_t u64;
	struct cvmx_l2c_lfb1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_19_63:45;
		uint64_t dsgoing:1;
		uint64_t bid:2;
		uint64_t wtrsp:1;
		uint64_t wtdw:1;
		uint64_t wtdq:1;
		uint64_t wtwhp:1;
		uint64_t wtwhf:1;
		uint64_t wtwrm:1;
		uint64_t wtstm:1;
		uint64_t wtrda:1;
		uint64_t wtstdt:1;
		uint64_t wtstrsp:1;
		uint64_t wtstrsc:1;
		uint64_t wtvtm:1;
		uint64_t wtmfl:1;
		uint64_t prbrty:1;
		uint64_t wtprb:1;
		uint64_t vld:1;
#else
		uint64_t vld:1;
		uint64_t wtprb:1;
		uint64_t prbrty:1;
		uint64_t wtmfl:1;
		uint64_t wtvtm:1;
		uint64_t wtstrsc:1;
		uint64_t wtstrsp:1;
		uint64_t wtstdt:1;
		uint64_t wtrda:1;
		uint64_t wtstm:1;
		uint64_t wtwrm:1;
		uint64_t wtwhf:1;
		uint64_t wtwhp:1;
		uint64_t wtdq:1;
		uint64_t wtdw:1;
		uint64_t wtrsp:1;
		uint64_t bid:2;
		uint64_t dsgoing:1;
		uint64_t reserved_19_63:45;
#endif
	} s;
	struct cvmx_l2c_lfb1_s cn30xx;
	struct cvmx_l2c_lfb1_s cn31xx;
	struct cvmx_l2c_lfb1_s cn38xx;
	struct cvmx_l2c_lfb1_s cn38xxp2;
	struct cvmx_l2c_lfb1_s cn50xx;
	struct cvmx_l2c_lfb1_s cn52xx;
	struct cvmx_l2c_lfb1_s cn52xxp1;
	struct cvmx_l2c_lfb1_s cn56xx;
	struct cvmx_l2c_lfb1_s cn56xxp1;
	struct cvmx_l2c_lfb1_s cn58xx;
	struct cvmx_l2c_lfb1_s cn58xxp1;
};

union cvmx_l2c_lfb2 {
	uint64_t u64;
	struct cvmx_l2c_lfb2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_0_63:64;
#else
		uint64_t reserved_0_63:64;
#endif
	} s;
	struct cvmx_l2c_lfb2_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t lfb_tag:19;
		uint64_t lfb_idx:8;
#else
		uint64_t lfb_idx:8;
		uint64_t lfb_tag:19;
		uint64_t reserved_27_63:37;
#endif
	} cn30xx;
	struct cvmx_l2c_lfb2_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t lfb_tag:17;
		uint64_t lfb_idx:10;
#else
		uint64_t lfb_idx:10;
		uint64_t lfb_tag:17;
		uint64_t reserved_27_63:37;
#endif
	} cn31xx;
	struct cvmx_l2c_lfb2_cn31xx cn38xx;
	struct cvmx_l2c_lfb2_cn31xx cn38xxp2;
	struct cvmx_l2c_lfb2_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t lfb_tag:20;
		uint64_t lfb_idx:7;
#else
		uint64_t lfb_idx:7;
		uint64_t lfb_tag:20;
		uint64_t reserved_27_63:37;
#endif
	} cn50xx;
	struct cvmx_l2c_lfb2_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t lfb_tag:18;
		uint64_t lfb_idx:9;
#else
		uint64_t lfb_idx:9;
		uint64_t lfb_tag:18;
		uint64_t reserved_27_63:37;
#endif
	} cn52xx;
	struct cvmx_l2c_lfb2_cn52xx cn52xxp1;
	struct cvmx_l2c_lfb2_cn56xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_27_63:37;
		uint64_t lfb_tag:16;
		uint64_t lfb_idx:11;
#else
		uint64_t lfb_idx:11;
		uint64_t lfb_tag:16;
		uint64_t reserved_27_63:37;
#endif
	} cn56xx;
	struct cvmx_l2c_lfb2_cn56xx cn56xxp1;
	struct cvmx_l2c_lfb2_cn56xx cn58xx;
	struct cvmx_l2c_lfb2_cn56xx cn58xxp1;
};

union cvmx_l2c_lfb3 {
	uint64_t u64;
	struct cvmx_l2c_lfb3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t stpartdis:1;
		uint64_t lfb_hwm:4;
#else
		uint64_t lfb_hwm:4;
		uint64_t stpartdis:1;
		uint64_t reserved_5_63:59;
#endif
	} s;
	struct cvmx_l2c_lfb3_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t stpartdis:1;
		uint64_t reserved_2_3:2;
		uint64_t lfb_hwm:2;
#else
		uint64_t lfb_hwm:2;
		uint64_t reserved_2_3:2;
		uint64_t stpartdis:1;
		uint64_t reserved_5_63:59;
#endif
	} cn30xx;
	struct cvmx_l2c_lfb3_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_5_63:59;
		uint64_t stpartdis:1;
		uint64_t reserved_3_3:1;
		uint64_t lfb_hwm:3;
#else
		uint64_t lfb_hwm:3;
		uint64_t reserved_3_3:1;
		uint64_t stpartdis:1;
		uint64_t reserved_5_63:59;
#endif
	} cn31xx;
	struct cvmx_l2c_lfb3_s cn38xx;
	struct cvmx_l2c_lfb3_s cn38xxp2;
	struct cvmx_l2c_lfb3_cn31xx cn50xx;
	struct cvmx_l2c_lfb3_cn31xx cn52xx;
	struct cvmx_l2c_lfb3_cn31xx cn52xxp1;
	struct cvmx_l2c_lfb3_s cn56xx;
	struct cvmx_l2c_lfb3_s cn56xxp1;
	struct cvmx_l2c_lfb3_s cn58xx;
	struct cvmx_l2c_lfb3_s cn58xxp1;
};

union cvmx_l2c_oob {
	uint64_t u64;
	struct cvmx_l2c_oob_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t dwbena:1;
		uint64_t stena:1;
#else
		uint64_t stena:1;
		uint64_t dwbena:1;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_l2c_oob_s cn52xx;
	struct cvmx_l2c_oob_s cn52xxp1;
	struct cvmx_l2c_oob_s cn56xx;
	struct cvmx_l2c_oob_s cn56xxp1;
};

union cvmx_l2c_oob1 {
	uint64_t u64;
	struct cvmx_l2c_oob1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t fadr:27;
		uint64_t fsrc:1;
		uint64_t reserved_34_35:2;
		uint64_t sadr:14;
		uint64_t reserved_14_19:6;
		uint64_t size:14;
#else
		uint64_t size:14;
		uint64_t reserved_14_19:6;
		uint64_t sadr:14;
		uint64_t reserved_34_35:2;
		uint64_t fsrc:1;
		uint64_t fadr:27;
#endif
	} s;
	struct cvmx_l2c_oob1_s cn52xx;
	struct cvmx_l2c_oob1_s cn52xxp1;
	struct cvmx_l2c_oob1_s cn56xx;
	struct cvmx_l2c_oob1_s cn56xxp1;
};

union cvmx_l2c_oob2 {
	uint64_t u64;
	struct cvmx_l2c_oob2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t fadr:27;
		uint64_t fsrc:1;
		uint64_t reserved_34_35:2;
		uint64_t sadr:14;
		uint64_t reserved_14_19:6;
		uint64_t size:14;
#else
		uint64_t size:14;
		uint64_t reserved_14_19:6;
		uint64_t sadr:14;
		uint64_t reserved_34_35:2;
		uint64_t fsrc:1;
		uint64_t fadr:27;
#endif
	} s;
	struct cvmx_l2c_oob2_s cn52xx;
	struct cvmx_l2c_oob2_s cn52xxp1;
	struct cvmx_l2c_oob2_s cn56xx;
	struct cvmx_l2c_oob2_s cn56xxp1;
};

union cvmx_l2c_oob3 {
	uint64_t u64;
	struct cvmx_l2c_oob3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t fadr:27;
		uint64_t fsrc:1;
		uint64_t reserved_34_35:2;
		uint64_t sadr:14;
		uint64_t reserved_14_19:6;
		uint64_t size:14;
#else
		uint64_t size:14;
		uint64_t reserved_14_19:6;
		uint64_t sadr:14;
		uint64_t reserved_34_35:2;
		uint64_t fsrc:1;
		uint64_t fadr:27;
#endif
	} s;
	struct cvmx_l2c_oob3_s cn52xx;
	struct cvmx_l2c_oob3_s cn52xxp1;
	struct cvmx_l2c_oob3_s cn56xx;
	struct cvmx_l2c_oob3_s cn56xxp1;
};

union cvmx_l2c_pfcx {
	uint64_t u64;
	struct cvmx_l2c_pfcx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_36_63:28;
		uint64_t pfcnt0:36;
#else
		uint64_t pfcnt0:36;
		uint64_t reserved_36_63:28;
#endif
	} s;
	struct cvmx_l2c_pfcx_s cn30xx;
	struct cvmx_l2c_pfcx_s cn31xx;
	struct cvmx_l2c_pfcx_s cn38xx;
	struct cvmx_l2c_pfcx_s cn38xxp2;
	struct cvmx_l2c_pfcx_s cn50xx;
	struct cvmx_l2c_pfcx_s cn52xx;
	struct cvmx_l2c_pfcx_s cn52xxp1;
	struct cvmx_l2c_pfcx_s cn56xx;
	struct cvmx_l2c_pfcx_s cn56xxp1;
	struct cvmx_l2c_pfcx_s cn58xx;
	struct cvmx_l2c_pfcx_s cn58xxp1;
};

union cvmx_l2c_pfctl {
	uint64_t u64;
	struct cvmx_l2c_pfctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_36_63:28;
		uint64_t cnt3rdclr:1;
		uint64_t cnt2rdclr:1;
		uint64_t cnt1rdclr:1;
		uint64_t cnt0rdclr:1;
		uint64_t cnt3ena:1;
		uint64_t cnt3clr:1;
		uint64_t cnt3sel:6;
		uint64_t cnt2ena:1;
		uint64_t cnt2clr:1;
		uint64_t cnt2sel:6;
		uint64_t cnt1ena:1;
		uint64_t cnt1clr:1;
		uint64_t cnt1sel:6;
		uint64_t cnt0ena:1;
		uint64_t cnt0clr:1;
		uint64_t cnt0sel:6;
#else
		uint64_t cnt0sel:6;
		uint64_t cnt0clr:1;
		uint64_t cnt0ena:1;
		uint64_t cnt1sel:6;
		uint64_t cnt1clr:1;
		uint64_t cnt1ena:1;
		uint64_t cnt2sel:6;
		uint64_t cnt2clr:1;
		uint64_t cnt2ena:1;
		uint64_t cnt3sel:6;
		uint64_t cnt3clr:1;
		uint64_t cnt3ena:1;
		uint64_t cnt0rdclr:1;
		uint64_t cnt1rdclr:1;
		uint64_t cnt2rdclr:1;
		uint64_t cnt3rdclr:1;
		uint64_t reserved_36_63:28;
#endif
	} s;
	struct cvmx_l2c_pfctl_s cn30xx;
	struct cvmx_l2c_pfctl_s cn31xx;
	struct cvmx_l2c_pfctl_s cn38xx;
	struct cvmx_l2c_pfctl_s cn38xxp2;
	struct cvmx_l2c_pfctl_s cn50xx;
	struct cvmx_l2c_pfctl_s cn52xx;
	struct cvmx_l2c_pfctl_s cn52xxp1;
	struct cvmx_l2c_pfctl_s cn56xx;
	struct cvmx_l2c_pfctl_s cn56xxp1;
	struct cvmx_l2c_pfctl_s cn58xx;
	struct cvmx_l2c_pfctl_s cn58xxp1;
};

union cvmx_l2c_ppgrp {
	uint64_t u64;
	struct cvmx_l2c_ppgrp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_24_63:40;
		uint64_t pp11grp:2;
		uint64_t pp10grp:2;
		uint64_t pp9grp:2;
		uint64_t pp8grp:2;
		uint64_t pp7grp:2;
		uint64_t pp6grp:2;
		uint64_t pp5grp:2;
		uint64_t pp4grp:2;
		uint64_t pp3grp:2;
		uint64_t pp2grp:2;
		uint64_t pp1grp:2;
		uint64_t pp0grp:2;
#else
		uint64_t pp0grp:2;
		uint64_t pp1grp:2;
		uint64_t pp2grp:2;
		uint64_t pp3grp:2;
		uint64_t pp4grp:2;
		uint64_t pp5grp:2;
		uint64_t pp6grp:2;
		uint64_t pp7grp:2;
		uint64_t pp8grp:2;
		uint64_t pp9grp:2;
		uint64_t pp10grp:2;
		uint64_t pp11grp:2;
		uint64_t reserved_24_63:40;
#endif
	} s;
	struct cvmx_l2c_ppgrp_cn52xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t pp3grp:2;
		uint64_t pp2grp:2;
		uint64_t pp1grp:2;
		uint64_t pp0grp:2;
#else
		uint64_t pp0grp:2;
		uint64_t pp1grp:2;
		uint64_t pp2grp:2;
		uint64_t pp3grp:2;
		uint64_t reserved_8_63:56;
#endif
	} cn52xx;
	struct cvmx_l2c_ppgrp_cn52xx cn52xxp1;
	struct cvmx_l2c_ppgrp_s cn56xx;
	struct cvmx_l2c_ppgrp_s cn56xxp1;
};

union cvmx_l2c_qos_iobx {
	uint64_t u64;
	struct cvmx_l2c_qos_iobx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_7_63:57;
		uint64_t dwblvl:3;
		uint64_t reserved_3_3:1;
		uint64_t lvl:3;
#else
		uint64_t lvl:3;
		uint64_t reserved_3_3:1;
		uint64_t dwblvl:3;
		uint64_t reserved_7_63:57;
#endif
	} s;
	struct cvmx_l2c_qos_iobx_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t dwblvl:2;
		uint64_t reserved_2_3:2;
		uint64_t lvl:2;
#else
		uint64_t lvl:2;
		uint64_t reserved_2_3:2;
		uint64_t dwblvl:2;
		uint64_t reserved_6_63:58;
#endif
	} cn61xx;
	struct cvmx_l2c_qos_iobx_cn61xx cn63xx;
	struct cvmx_l2c_qos_iobx_cn61xx cn63xxp1;
	struct cvmx_l2c_qos_iobx_cn61xx cn66xx;
	struct cvmx_l2c_qos_iobx_s cn68xx;
	struct cvmx_l2c_qos_iobx_s cn68xxp1;
	struct cvmx_l2c_qos_iobx_cn61xx cnf71xx;
};

union cvmx_l2c_qos_ppx {
	uint64_t u64;
	struct cvmx_l2c_qos_ppx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_3_63:61;
		uint64_t lvl:3;
#else
		uint64_t lvl:3;
		uint64_t reserved_3_63:61;
#endif
	} s;
	struct cvmx_l2c_qos_ppx_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t lvl:2;
#else
		uint64_t lvl:2;
		uint64_t reserved_2_63:62;
#endif
	} cn61xx;
	struct cvmx_l2c_qos_ppx_cn61xx cn63xx;
	struct cvmx_l2c_qos_ppx_cn61xx cn63xxp1;
	struct cvmx_l2c_qos_ppx_cn61xx cn66xx;
	struct cvmx_l2c_qos_ppx_s cn68xx;
	struct cvmx_l2c_qos_ppx_s cn68xxp1;
	struct cvmx_l2c_qos_ppx_cn61xx cnf71xx;
};

union cvmx_l2c_qos_wgt {
	uint64_t u64;
	struct cvmx_l2c_qos_wgt_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t wgt7:8;
		uint64_t wgt6:8;
		uint64_t wgt5:8;
		uint64_t wgt4:8;
		uint64_t wgt3:8;
		uint64_t wgt2:8;
		uint64_t wgt1:8;
		uint64_t wgt0:8;
#else
		uint64_t wgt0:8;
		uint64_t wgt1:8;
		uint64_t wgt2:8;
		uint64_t wgt3:8;
		uint64_t wgt4:8;
		uint64_t wgt5:8;
		uint64_t wgt6:8;
		uint64_t wgt7:8;
#endif
	} s;
	struct cvmx_l2c_qos_wgt_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t wgt3:8;
		uint64_t wgt2:8;
		uint64_t wgt1:8;
		uint64_t wgt0:8;
#else
		uint64_t wgt0:8;
		uint64_t wgt1:8;
		uint64_t wgt2:8;
		uint64_t wgt3:8;
		uint64_t reserved_32_63:32;
#endif
	} cn61xx;
	struct cvmx_l2c_qos_wgt_cn61xx cn63xx;
	struct cvmx_l2c_qos_wgt_cn61xx cn63xxp1;
	struct cvmx_l2c_qos_wgt_cn61xx cn66xx;
	struct cvmx_l2c_qos_wgt_s cn68xx;
	struct cvmx_l2c_qos_wgt_s cn68xxp1;
	struct cvmx_l2c_qos_wgt_cn61xx cnf71xx;
};

union cvmx_l2c_rscx_pfc {
	uint64_t u64;
	struct cvmx_l2c_rscx_pfc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_rscx_pfc_s cn61xx;
	struct cvmx_l2c_rscx_pfc_s cn63xx;
	struct cvmx_l2c_rscx_pfc_s cn63xxp1;
	struct cvmx_l2c_rscx_pfc_s cn66xx;
	struct cvmx_l2c_rscx_pfc_s cn68xx;
	struct cvmx_l2c_rscx_pfc_s cn68xxp1;
	struct cvmx_l2c_rscx_pfc_s cnf71xx;
};

union cvmx_l2c_rsdx_pfc {
	uint64_t u64;
	struct cvmx_l2c_rsdx_pfc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_rsdx_pfc_s cn61xx;
	struct cvmx_l2c_rsdx_pfc_s cn63xx;
	struct cvmx_l2c_rsdx_pfc_s cn63xxp1;
	struct cvmx_l2c_rsdx_pfc_s cn66xx;
	struct cvmx_l2c_rsdx_pfc_s cn68xx;
	struct cvmx_l2c_rsdx_pfc_s cn68xxp1;
	struct cvmx_l2c_rsdx_pfc_s cnf71xx;
};

union cvmx_l2c_spar0 {
	uint64_t u64;
	struct cvmx_l2c_spar0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t umsk3:8;
		uint64_t umsk2:8;
		uint64_t umsk1:8;
		uint64_t umsk0:8;
#else
		uint64_t umsk0:8;
		uint64_t umsk1:8;
		uint64_t umsk2:8;
		uint64_t umsk3:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_spar0_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t umsk0:4;
#else
		uint64_t umsk0:4;
		uint64_t reserved_4_63:60;
#endif
	} cn30xx;
	struct cvmx_l2c_spar0_cn31xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_12_63:52;
		uint64_t umsk1:4;
		uint64_t reserved_4_7:4;
		uint64_t umsk0:4;
#else
		uint64_t umsk0:4;
		uint64_t reserved_4_7:4;
		uint64_t umsk1:4;
		uint64_t reserved_12_63:52;
#endif
	} cn31xx;
	struct cvmx_l2c_spar0_s cn38xx;
	struct cvmx_l2c_spar0_s cn38xxp2;
	struct cvmx_l2c_spar0_cn50xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t umsk1:8;
		uint64_t umsk0:8;
#else
		uint64_t umsk0:8;
		uint64_t umsk1:8;
		uint64_t reserved_16_63:48;
#endif
	} cn50xx;
	struct cvmx_l2c_spar0_s cn52xx;
	struct cvmx_l2c_spar0_s cn52xxp1;
	struct cvmx_l2c_spar0_s cn56xx;
	struct cvmx_l2c_spar0_s cn56xxp1;
	struct cvmx_l2c_spar0_s cn58xx;
	struct cvmx_l2c_spar0_s cn58xxp1;
};

union cvmx_l2c_spar1 {
	uint64_t u64;
	struct cvmx_l2c_spar1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t umsk7:8;
		uint64_t umsk6:8;
		uint64_t umsk5:8;
		uint64_t umsk4:8;
#else
		uint64_t umsk4:8;
		uint64_t umsk5:8;
		uint64_t umsk6:8;
		uint64_t umsk7:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_spar1_s cn38xx;
	struct cvmx_l2c_spar1_s cn38xxp2;
	struct cvmx_l2c_spar1_s cn56xx;
	struct cvmx_l2c_spar1_s cn56xxp1;
	struct cvmx_l2c_spar1_s cn58xx;
	struct cvmx_l2c_spar1_s cn58xxp1;
};

union cvmx_l2c_spar2 {
	uint64_t u64;
	struct cvmx_l2c_spar2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t umsk11:8;
		uint64_t umsk10:8;
		uint64_t umsk9:8;
		uint64_t umsk8:8;
#else
		uint64_t umsk8:8;
		uint64_t umsk9:8;
		uint64_t umsk10:8;
		uint64_t umsk11:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_spar2_s cn38xx;
	struct cvmx_l2c_spar2_s cn38xxp2;
	struct cvmx_l2c_spar2_s cn56xx;
	struct cvmx_l2c_spar2_s cn56xxp1;
	struct cvmx_l2c_spar2_s cn58xx;
	struct cvmx_l2c_spar2_s cn58xxp1;
};

union cvmx_l2c_spar3 {
	uint64_t u64;
	struct cvmx_l2c_spar3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t umsk15:8;
		uint64_t umsk14:8;
		uint64_t umsk13:8;
		uint64_t umsk12:8;
#else
		uint64_t umsk12:8;
		uint64_t umsk13:8;
		uint64_t umsk14:8;
		uint64_t umsk15:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_spar3_s cn38xx;
	struct cvmx_l2c_spar3_s cn38xxp2;
	struct cvmx_l2c_spar3_s cn58xx;
	struct cvmx_l2c_spar3_s cn58xxp1;
};

union cvmx_l2c_spar4 {
	uint64_t u64;
	struct cvmx_l2c_spar4_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_8_63:56;
		uint64_t umskiob:8;
#else
		uint64_t umskiob:8;
		uint64_t reserved_8_63:56;
#endif
	} s;
	struct cvmx_l2c_spar4_cn30xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t umskiob:4;
#else
		uint64_t umskiob:4;
		uint64_t reserved_4_63:60;
#endif
	} cn30xx;
	struct cvmx_l2c_spar4_cn30xx cn31xx;
	struct cvmx_l2c_spar4_s cn38xx;
	struct cvmx_l2c_spar4_s cn38xxp2;
	struct cvmx_l2c_spar4_s cn50xx;
	struct cvmx_l2c_spar4_s cn52xx;
	struct cvmx_l2c_spar4_s cn52xxp1;
	struct cvmx_l2c_spar4_s cn56xx;
	struct cvmx_l2c_spar4_s cn56xxp1;
	struct cvmx_l2c_spar4_s cn58xx;
	struct cvmx_l2c_spar4_s cn58xxp1;
};

union cvmx_l2c_tadx_ecc0 {
	uint64_t u64;
	struct cvmx_l2c_tadx_ecc0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_58_63:6;
		uint64_t ow3ecc:10;
		uint64_t reserved_42_47:6;
		uint64_t ow2ecc:10;
		uint64_t reserved_26_31:6;
		uint64_t ow1ecc:10;
		uint64_t reserved_10_15:6;
		uint64_t ow0ecc:10;
#else
		uint64_t ow0ecc:10;
		uint64_t reserved_10_15:6;
		uint64_t ow1ecc:10;
		uint64_t reserved_26_31:6;
		uint64_t ow2ecc:10;
		uint64_t reserved_42_47:6;
		uint64_t ow3ecc:10;
		uint64_t reserved_58_63:6;
#endif
	} s;
	struct cvmx_l2c_tadx_ecc0_s cn61xx;
	struct cvmx_l2c_tadx_ecc0_s cn63xx;
	struct cvmx_l2c_tadx_ecc0_s cn63xxp1;
	struct cvmx_l2c_tadx_ecc0_s cn66xx;
	struct cvmx_l2c_tadx_ecc0_s cn68xx;
	struct cvmx_l2c_tadx_ecc0_s cn68xxp1;
	struct cvmx_l2c_tadx_ecc0_s cnf71xx;
};

union cvmx_l2c_tadx_ecc1 {
	uint64_t u64;
	struct cvmx_l2c_tadx_ecc1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_58_63:6;
		uint64_t ow7ecc:10;
		uint64_t reserved_42_47:6;
		uint64_t ow6ecc:10;
		uint64_t reserved_26_31:6;
		uint64_t ow5ecc:10;
		uint64_t reserved_10_15:6;
		uint64_t ow4ecc:10;
#else
		uint64_t ow4ecc:10;
		uint64_t reserved_10_15:6;
		uint64_t ow5ecc:10;
		uint64_t reserved_26_31:6;
		uint64_t ow6ecc:10;
		uint64_t reserved_42_47:6;
		uint64_t ow7ecc:10;
		uint64_t reserved_58_63:6;
#endif
	} s;
	struct cvmx_l2c_tadx_ecc1_s cn61xx;
	struct cvmx_l2c_tadx_ecc1_s cn63xx;
	struct cvmx_l2c_tadx_ecc1_s cn63xxp1;
	struct cvmx_l2c_tadx_ecc1_s cn66xx;
	struct cvmx_l2c_tadx_ecc1_s cn68xx;
	struct cvmx_l2c_tadx_ecc1_s cn68xxp1;
	struct cvmx_l2c_tadx_ecc1_s cnf71xx;
};

union cvmx_l2c_tadx_ien {
	uint64_t u64;
	struct cvmx_l2c_tadx_ien_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t wrdislmc:1;
		uint64_t rddislmc:1;
		uint64_t noway:1;
		uint64_t vbfdbe:1;
		uint64_t vbfsbe:1;
		uint64_t tagdbe:1;
		uint64_t tagsbe:1;
		uint64_t l2ddbe:1;
		uint64_t l2dsbe:1;
#else
		uint64_t l2dsbe:1;
		uint64_t l2ddbe:1;
		uint64_t tagsbe:1;
		uint64_t tagdbe:1;
		uint64_t vbfsbe:1;
		uint64_t vbfdbe:1;
		uint64_t noway:1;
		uint64_t rddislmc:1;
		uint64_t wrdislmc:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_l2c_tadx_ien_s cn61xx;
	struct cvmx_l2c_tadx_ien_s cn63xx;
	struct cvmx_l2c_tadx_ien_cn63xxp1 {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_7_63:57;
		uint64_t noway:1;
		uint64_t vbfdbe:1;
		uint64_t vbfsbe:1;
		uint64_t tagdbe:1;
		uint64_t tagsbe:1;
		uint64_t l2ddbe:1;
		uint64_t l2dsbe:1;
#else
		uint64_t l2dsbe:1;
		uint64_t l2ddbe:1;
		uint64_t tagsbe:1;
		uint64_t tagdbe:1;
		uint64_t vbfsbe:1;
		uint64_t vbfdbe:1;
		uint64_t noway:1;
		uint64_t reserved_7_63:57;
#endif
	} cn63xxp1;
	struct cvmx_l2c_tadx_ien_s cn66xx;
	struct cvmx_l2c_tadx_ien_s cn68xx;
	struct cvmx_l2c_tadx_ien_s cn68xxp1;
	struct cvmx_l2c_tadx_ien_s cnf71xx;
};

union cvmx_l2c_tadx_int {
	uint64_t u64;
	struct cvmx_l2c_tadx_int_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t wrdislmc:1;
		uint64_t rddislmc:1;
		uint64_t noway:1;
		uint64_t vbfdbe:1;
		uint64_t vbfsbe:1;
		uint64_t tagdbe:1;
		uint64_t tagsbe:1;
		uint64_t l2ddbe:1;
		uint64_t l2dsbe:1;
#else
		uint64_t l2dsbe:1;
		uint64_t l2ddbe:1;
		uint64_t tagsbe:1;
		uint64_t tagdbe:1;
		uint64_t vbfsbe:1;
		uint64_t vbfdbe:1;
		uint64_t noway:1;
		uint64_t rddislmc:1;
		uint64_t wrdislmc:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_l2c_tadx_int_s cn61xx;
	struct cvmx_l2c_tadx_int_s cn63xx;
	struct cvmx_l2c_tadx_int_s cn66xx;
	struct cvmx_l2c_tadx_int_s cn68xx;
	struct cvmx_l2c_tadx_int_s cn68xxp1;
	struct cvmx_l2c_tadx_int_s cnf71xx;
};

union cvmx_l2c_tadx_pfc0 {
	uint64_t u64;
	struct cvmx_l2c_tadx_pfc0_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_tadx_pfc0_s cn61xx;
	struct cvmx_l2c_tadx_pfc0_s cn63xx;
	struct cvmx_l2c_tadx_pfc0_s cn63xxp1;
	struct cvmx_l2c_tadx_pfc0_s cn66xx;
	struct cvmx_l2c_tadx_pfc0_s cn68xx;
	struct cvmx_l2c_tadx_pfc0_s cn68xxp1;
	struct cvmx_l2c_tadx_pfc0_s cnf71xx;
};

union cvmx_l2c_tadx_pfc1 {
	uint64_t u64;
	struct cvmx_l2c_tadx_pfc1_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_tadx_pfc1_s cn61xx;
	struct cvmx_l2c_tadx_pfc1_s cn63xx;
	struct cvmx_l2c_tadx_pfc1_s cn63xxp1;
	struct cvmx_l2c_tadx_pfc1_s cn66xx;
	struct cvmx_l2c_tadx_pfc1_s cn68xx;
	struct cvmx_l2c_tadx_pfc1_s cn68xxp1;
	struct cvmx_l2c_tadx_pfc1_s cnf71xx;
};

union cvmx_l2c_tadx_pfc2 {
	uint64_t u64;
	struct cvmx_l2c_tadx_pfc2_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_tadx_pfc2_s cn61xx;
	struct cvmx_l2c_tadx_pfc2_s cn63xx;
	struct cvmx_l2c_tadx_pfc2_s cn63xxp1;
	struct cvmx_l2c_tadx_pfc2_s cn66xx;
	struct cvmx_l2c_tadx_pfc2_s cn68xx;
	struct cvmx_l2c_tadx_pfc2_s cn68xxp1;
	struct cvmx_l2c_tadx_pfc2_s cnf71xx;
};

union cvmx_l2c_tadx_pfc3 {
	uint64_t u64;
	struct cvmx_l2c_tadx_pfc3_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_tadx_pfc3_s cn61xx;
	struct cvmx_l2c_tadx_pfc3_s cn63xx;
	struct cvmx_l2c_tadx_pfc3_s cn63xxp1;
	struct cvmx_l2c_tadx_pfc3_s cn66xx;
	struct cvmx_l2c_tadx_pfc3_s cn68xx;
	struct cvmx_l2c_tadx_pfc3_s cn68xxp1;
	struct cvmx_l2c_tadx_pfc3_s cnf71xx;
};

union cvmx_l2c_tadx_prf {
	uint64_t u64;
	struct cvmx_l2c_tadx_prf_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t cnt3sel:8;
		uint64_t cnt2sel:8;
		uint64_t cnt1sel:8;
		uint64_t cnt0sel:8;
#else
		uint64_t cnt0sel:8;
		uint64_t cnt1sel:8;
		uint64_t cnt2sel:8;
		uint64_t cnt3sel:8;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_tadx_prf_s cn61xx;
	struct cvmx_l2c_tadx_prf_s cn63xx;
	struct cvmx_l2c_tadx_prf_s cn63xxp1;
	struct cvmx_l2c_tadx_prf_s cn66xx;
	struct cvmx_l2c_tadx_prf_s cn68xx;
	struct cvmx_l2c_tadx_prf_s cn68xxp1;
	struct cvmx_l2c_tadx_prf_s cnf71xx;
};

union cvmx_l2c_tadx_tag {
	uint64_t u64;
	struct cvmx_l2c_tadx_tag_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_46_63:18;
		uint64_t ecc:6;
		uint64_t reserved_36_39:4;
		uint64_t tag:19;
		uint64_t reserved_4_16:13;
		uint64_t use:1;
		uint64_t valid:1;
		uint64_t dirty:1;
		uint64_t lock:1;
#else
		uint64_t lock:1;
		uint64_t dirty:1;
		uint64_t valid:1;
		uint64_t use:1;
		uint64_t reserved_4_16:13;
		uint64_t tag:19;
		uint64_t reserved_36_39:4;
		uint64_t ecc:6;
		uint64_t reserved_46_63:18;
#endif
	} s;
	struct cvmx_l2c_tadx_tag_s cn61xx;
	struct cvmx_l2c_tadx_tag_s cn63xx;
	struct cvmx_l2c_tadx_tag_s cn63xxp1;
	struct cvmx_l2c_tadx_tag_s cn66xx;
	struct cvmx_l2c_tadx_tag_s cn68xx;
	struct cvmx_l2c_tadx_tag_s cn68xxp1;
	struct cvmx_l2c_tadx_tag_s cnf71xx;
};

union cvmx_l2c_ver_id {
	uint64_t u64;
	struct cvmx_l2c_ver_id_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t mask:64;
#else
		uint64_t mask:64;
#endif
	} s;
	struct cvmx_l2c_ver_id_s cn61xx;
	struct cvmx_l2c_ver_id_s cn63xx;
	struct cvmx_l2c_ver_id_s cn63xxp1;
	struct cvmx_l2c_ver_id_s cn66xx;
	struct cvmx_l2c_ver_id_s cn68xx;
	struct cvmx_l2c_ver_id_s cn68xxp1;
	struct cvmx_l2c_ver_id_s cnf71xx;
};

union cvmx_l2c_ver_iob {
	uint64_t u64;
	struct cvmx_l2c_ver_iob_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t mask:2;
#else
		uint64_t mask:2;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_l2c_ver_iob_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_1_63:63;
		uint64_t mask:1;
#else
		uint64_t mask:1;
		uint64_t reserved_1_63:63;
#endif
	} cn61xx;
	struct cvmx_l2c_ver_iob_cn61xx cn63xx;
	struct cvmx_l2c_ver_iob_cn61xx cn63xxp1;
	struct cvmx_l2c_ver_iob_cn61xx cn66xx;
	struct cvmx_l2c_ver_iob_s cn68xx;
	struct cvmx_l2c_ver_iob_s cn68xxp1;
	struct cvmx_l2c_ver_iob_cn61xx cnf71xx;
};

union cvmx_l2c_ver_msc {
	uint64_t u64;
	struct cvmx_l2c_ver_msc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_2_63:62;
		uint64_t invl2:1;
		uint64_t dwb:1;
#else
		uint64_t dwb:1;
		uint64_t invl2:1;
		uint64_t reserved_2_63:62;
#endif
	} s;
	struct cvmx_l2c_ver_msc_s cn61xx;
	struct cvmx_l2c_ver_msc_s cn63xx;
	struct cvmx_l2c_ver_msc_s cn66xx;
	struct cvmx_l2c_ver_msc_s cn68xx;
	struct cvmx_l2c_ver_msc_s cn68xxp1;
	struct cvmx_l2c_ver_msc_s cnf71xx;
};

union cvmx_l2c_ver_pp {
	uint64_t u64;
	struct cvmx_l2c_ver_pp_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_32_63:32;
		uint64_t mask:32;
#else
		uint64_t mask:32;
		uint64_t reserved_32_63:32;
#endif
	} s;
	struct cvmx_l2c_ver_pp_cn61xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_4_63:60;
		uint64_t mask:4;
#else
		uint64_t mask:4;
		uint64_t reserved_4_63:60;
#endif
	} cn61xx;
	struct cvmx_l2c_ver_pp_cn63xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t mask:6;
#else
		uint64_t mask:6;
		uint64_t reserved_6_63:58;
#endif
	} cn63xx;
	struct cvmx_l2c_ver_pp_cn63xx cn63xxp1;
	struct cvmx_l2c_ver_pp_cn66xx {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_10_63:54;
		uint64_t mask:10;
#else
		uint64_t mask:10;
		uint64_t reserved_10_63:54;
#endif
	} cn66xx;
	struct cvmx_l2c_ver_pp_s cn68xx;
	struct cvmx_l2c_ver_pp_s cn68xxp1;
	struct cvmx_l2c_ver_pp_cn61xx cnf71xx;
};

union cvmx_l2c_virtid_iobx {
	uint64_t u64;
	struct cvmx_l2c_virtid_iobx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_14_63:50;
		uint64_t dwbid:6;
		uint64_t reserved_6_7:2;
		uint64_t id:6;
#else
		uint64_t id:6;
		uint64_t reserved_6_7:2;
		uint64_t dwbid:6;
		uint64_t reserved_14_63:50;
#endif
	} s;
	struct cvmx_l2c_virtid_iobx_s cn61xx;
	struct cvmx_l2c_virtid_iobx_s cn63xx;
	struct cvmx_l2c_virtid_iobx_s cn63xxp1;
	struct cvmx_l2c_virtid_iobx_s cn66xx;
	struct cvmx_l2c_virtid_iobx_s cn68xx;
	struct cvmx_l2c_virtid_iobx_s cn68xxp1;
	struct cvmx_l2c_virtid_iobx_s cnf71xx;
};

union cvmx_l2c_virtid_ppx {
	uint64_t u64;
	struct cvmx_l2c_virtid_ppx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_6_63:58;
		uint64_t id:6;
#else
		uint64_t id:6;
		uint64_t reserved_6_63:58;
#endif
	} s;
	struct cvmx_l2c_virtid_ppx_s cn61xx;
	struct cvmx_l2c_virtid_ppx_s cn63xx;
	struct cvmx_l2c_virtid_ppx_s cn63xxp1;
	struct cvmx_l2c_virtid_ppx_s cn66xx;
	struct cvmx_l2c_virtid_ppx_s cn68xx;
	struct cvmx_l2c_virtid_ppx_s cn68xxp1;
	struct cvmx_l2c_virtid_ppx_s cnf71xx;
};

union cvmx_l2c_vrt_ctl {
	uint64_t u64;
	struct cvmx_l2c_vrt_ctl_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_9_63:55;
		uint64_t ooberr:1;
		uint64_t reserved_7_7:1;
		uint64_t memsz:3;
		uint64_t numid:3;
		uint64_t enable:1;
#else
		uint64_t enable:1;
		uint64_t numid:3;
		uint64_t memsz:3;
		uint64_t reserved_7_7:1;
		uint64_t ooberr:1;
		uint64_t reserved_9_63:55;
#endif
	} s;
	struct cvmx_l2c_vrt_ctl_s cn61xx;
	struct cvmx_l2c_vrt_ctl_s cn63xx;
	struct cvmx_l2c_vrt_ctl_s cn63xxp1;
	struct cvmx_l2c_vrt_ctl_s cn66xx;
	struct cvmx_l2c_vrt_ctl_s cn68xx;
	struct cvmx_l2c_vrt_ctl_s cn68xxp1;
	struct cvmx_l2c_vrt_ctl_s cnf71xx;
};

union cvmx_l2c_vrt_memx {
	uint64_t u64;
	struct cvmx_l2c_vrt_memx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_36_63:28;
		uint64_t parity:4;
		uint64_t data:32;
#else
		uint64_t data:32;
		uint64_t parity:4;
		uint64_t reserved_36_63:28;
#endif
	} s;
	struct cvmx_l2c_vrt_memx_s cn61xx;
	struct cvmx_l2c_vrt_memx_s cn63xx;
	struct cvmx_l2c_vrt_memx_s cn63xxp1;
	struct cvmx_l2c_vrt_memx_s cn66xx;
	struct cvmx_l2c_vrt_memx_s cn68xx;
	struct cvmx_l2c_vrt_memx_s cn68xxp1;
	struct cvmx_l2c_vrt_memx_s cnf71xx;
};

union cvmx_l2c_wpar_iobx {
	uint64_t u64;
	struct cvmx_l2c_wpar_iobx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mask:16;
#else
		uint64_t mask:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_l2c_wpar_iobx_s cn61xx;
	struct cvmx_l2c_wpar_iobx_s cn63xx;
	struct cvmx_l2c_wpar_iobx_s cn63xxp1;
	struct cvmx_l2c_wpar_iobx_s cn66xx;
	struct cvmx_l2c_wpar_iobx_s cn68xx;
	struct cvmx_l2c_wpar_iobx_s cn68xxp1;
	struct cvmx_l2c_wpar_iobx_s cnf71xx;
};

union cvmx_l2c_wpar_ppx {
	uint64_t u64;
	struct cvmx_l2c_wpar_ppx_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t reserved_16_63:48;
		uint64_t mask:16;
#else
		uint64_t mask:16;
		uint64_t reserved_16_63:48;
#endif
	} s;
	struct cvmx_l2c_wpar_ppx_s cn61xx;
	struct cvmx_l2c_wpar_ppx_s cn63xx;
	struct cvmx_l2c_wpar_ppx_s cn63xxp1;
	struct cvmx_l2c_wpar_ppx_s cn66xx;
	struct cvmx_l2c_wpar_ppx_s cn68xx;
	struct cvmx_l2c_wpar_ppx_s cn68xxp1;
	struct cvmx_l2c_wpar_ppx_s cnf71xx;
};

union cvmx_l2c_xmcx_pfc {
	uint64_t u64;
	struct cvmx_l2c_xmcx_pfc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_xmcx_pfc_s cn61xx;
	struct cvmx_l2c_xmcx_pfc_s cn63xx;
	struct cvmx_l2c_xmcx_pfc_s cn63xxp1;
	struct cvmx_l2c_xmcx_pfc_s cn66xx;
	struct cvmx_l2c_xmcx_pfc_s cn68xx;
	struct cvmx_l2c_xmcx_pfc_s cn68xxp1;
	struct cvmx_l2c_xmcx_pfc_s cnf71xx;
};

union cvmx_l2c_xmc_cmd {
	uint64_t u64;
	struct cvmx_l2c_xmc_cmd_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t inuse:1;
		uint64_t cmd:6;
		uint64_t reserved_38_56:19;
		uint64_t addr:38;
#else
		uint64_t addr:38;
		uint64_t reserved_38_56:19;
		uint64_t cmd:6;
		uint64_t inuse:1;
#endif
	} s;
	struct cvmx_l2c_xmc_cmd_s cn61xx;
	struct cvmx_l2c_xmc_cmd_s cn63xx;
	struct cvmx_l2c_xmc_cmd_s cn63xxp1;
	struct cvmx_l2c_xmc_cmd_s cn66xx;
	struct cvmx_l2c_xmc_cmd_s cn68xx;
	struct cvmx_l2c_xmc_cmd_s cn68xxp1;
	struct cvmx_l2c_xmc_cmd_s cnf71xx;
};

union cvmx_l2c_xmdx_pfc {
	uint64_t u64;
	struct cvmx_l2c_xmdx_pfc_s {
#ifdef __BIG_ENDIAN_BITFIELD
		uint64_t count:64;
#else
		uint64_t count:64;
#endif
	} s;
	struct cvmx_l2c_xmdx_pfc_s cn61xx;
	struct cvmx_l2c_xmdx_pfc_s cn63xx;
	struct cvmx_l2c_xmdx_pfc_s cn63xxp1;
	struct cvmx_l2c_xmdx_pfc_s cn66xx;
	struct cvmx_l2c_xmdx_pfc_s cn68xx;
	struct cvmx_l2c_xmdx_pfc_s cn68xxp1;
	struct cvmx_l2c_xmdx_pfc_s cnf71xx;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              