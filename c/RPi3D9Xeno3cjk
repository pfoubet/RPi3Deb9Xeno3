#
# fbdev configuration
#

menuconfig FB
	tristate "Support for frame buffer devices"
	select FB_CMDLINE
	select FB_NOTIFY
	---help---
	  The frame buffer device provides an abstraction for the graphics
	  hardware. It represents the frame buffer of some video hardware and
	  allows application software to access the graphics hardware through
	  a well-defined interface, so the software doesn't need to know
	  anything about the low-level (hardware register) stuff.

	  Frame buffer devices work identically across the different
	  architectures supported by Linux and make the implementation of
	  application programs easier and more portable; at this point, an X
	  server exists which uses the frame buffer device exclusively.
	  On several non-X86 architectures, the frame buffer device is the
	  only way to use the graphics hardware.

	  The device is accessed through special device nodes, usually located
	  in the /dev directory, i.e. /dev/fb*.

	  You need an utility program called fbset to make full use of frame
	  buffer devices. Please read <file:Documentation/fb/framebuffer.txt>
	  and the Framebuffer-HOWTO at
	  <http://www.munted.org.uk/programming/Framebuffer-HOWTO-1.3.html> for more
	  information.

	  Say Y here and to the driver for your graphics board below if you
	  are compiling a kernel for a non-x86 architecture.

	  If you are compiling for the x86 architecture, you can say Y if you
	  want to play with it, but it is not essential. Please note that
	  running graphical applications that directly touch the hardware
	  (e.g. an accelerated X server) and that are not frame buffer
	  device-aware may cause unexpected results. If unsure, say N.

config FIRMWARE_EDID
       bool "Enable firmware EDID"
       depends on FB
       default n
       ---help---
         This enables access to the EDID transferred from the firmware.
	 On the i386, this is from the Video BIOS. Enable this if DDC/I2C
	 transfers do not work for your driver and if you are using
	 nvidiafb, i810fb or savagefb.

	 In general, choosing Y for this option is safe.  If you
	 experience extremely long delays while booting before you get
	 something on your display, try setting this to N.  Matrox cards in
	 combination with certain motherboards and monitors are known to
	 suffer from this problem.

config FB_CMDLINE
	bool

config FB_NOTIFY
	bool

config FB_DDC
       tristate
       depends on FB
       select I2C_ALGOBIT
       select I2C
       default n

config FB_BOOT_VESA_SUPPORT
	bool
	depends on FB
	default n
	---help---
	  If true, at least one selected framebuffer driver can take advantage
	  of VESA video modes set at an early boot stage via the vga= parameter.

config FB_CFB_FILLRECT
	tristate
	depends on FB
	default n
	---help---
	  Include the cfb_fillrect function for generic software rectangle
	  filling. This is used by drivers that don't provide their own
	  (accelerated) version.

config FB_CFB_COPYAREA
	tristate
	depends on FB
	default n
	---help---
	  Include the cfb_copyarea function for generic software area copying.
	  This is used by drivers that don't provide their own (accelerated)
	  version.

config FB_CFB_IMAGEBLIT
	tristate
	depends on FB
	default n
	---help---
	  Include the cfb_imageblit function for generic software image
	  blitting. This is used by drivers that don't provide their own
	  (accelerated) version.

config FB_CFB_REV_PIXELS_IN_BYTE
	bool
	depends on FB
	default n
	---help---
	  Allow generic frame-buffer functions to work on displays with 1, 2
	  and 4 bits per pixel depths which has opposite order of pixels in
	  byte order to bytes in long order.

config FB_SYS_FILLRECT
	tristate
	depends on FB
	default n
	---help---
	  Include the sys_fillrect function for generic software rectangle
	  filling. This is used by drivers that don't provide their own
	  (accelerated) version and the framebuffer is in system RAM.

config FB_SYS_COPYAREA
	tristate
	depends on FB
	default n
	---help---
	  Include the sys_copyarea function for generic software area copying.
	  This is used by drivers that don't provide their own (accelerated)
	  version and the framebuffer is in system RAM.

config FB_SYS_IMAGEBLIT
	tristate
	depends on FB
	default n
	---help---
	  Include the sys_imageblit function for generic software image
	  blitting. This is used by drivers that don't provide their own
	  (accelerated) version and the framebuffer is in system RAM.

menuconfig FB_FOREIGN_ENDIAN
	bool "Framebuffer foreign endianness support"
	depends on FB
	---help---
	  This menu will let you enable support for the framebuffers with
	  non-native endianness (e.g. Little-Endian framebuffer on a
	  Big-Endian machine). Most probably you don't have such hardware,
	  so it's safe to say "n" here.

choice
	prompt "Choice endianness support"
	depends on FB_FOREIGN_ENDIAN

config FB_BOTH_ENDIAN
	bool "Support for Big- and Little-Endian framebuffers"

config FB_BIG_ENDIAN
	bool "Support for Big-Endian framebuffers only"

config FB_LITTLE_ENDIAN
	bool "Support for Little-Endian framebuffers only"

endchoice

config FB_SYS_FOPS
       tristate
       depends on FB
       default n

config FB_DEFERRED_IO
	bool
	depends on FB

config FB_HECUBA
	tristate
	depends on FB
	depends on FB_DEFERRED_IO

config FB_SVGALIB
	tristate
	depends on FB
	default n
	---help---
	  Common utility functions useful to fbdev drivers of VGA-based
	  cards.

config FB_MACMODES
       tristate
       depends on FB
       default n

config FB_BACKLIGHT
	bool
	depends on FB
	select BACKLIGHT_LCD_SUPPORT
	select BACKLIGHT_CLASS_DEVICE
	default n

config FB_MODE_HELPERS
        bool "Enable Video Mode Handling Helpers"
        depends on FB
	default n
	---help---
	  This enables functions for handling video modes using the
	  Generalized Timing Formula and the EDID parser. A few drivers rely
          on this feature such as the radeonfb, rivafb, and the i810fb. If
	  your driver does not take advantage of this feature, choosing Y will
	  just increase the kernel size by about 5K.

config FB_TILEBLITTING
       bool "Enable Tile Blitting Support"
       depends on FB
       default n
       ---help---
         This enables tile blitting.  Tile blitting is a drawing technique
	 where the screen is divided into rectangular sections (tiles), whereas
	 the standard blitting divides the screen into pixels. Because the
	 default drawing element is a tile, drawing functions will be passed
	 parameters in terms of number of tiles instead of number of pixels.
	 For example, to draw a single character, instead of using bitmaps,
	 an index to an array of bitmaps will be used.  To clear or move a
	 rectangular section of a screen, the rectangle will be described in
	 terms of number of tiles in the x- and y-axis.

	 This is particularly important to one driver, matroxfb.  If
	 unsure, say N.

comment "Frame buffer hardware drivers"
	depends on FB

config FB_BCM2708
	tristate "BCM2708 framebuffer support"
	depends on FB && RASPBERRYPI_FIRMWARE
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This framebuffer device driver is for the BCM2708 framebuffer.

	  If you want to compile this as a module (=code which can be
	  inserted into and removed from the running kernel), say M
	  here and read <file:Documentation/kbuild/modules.txt>.  The module
	  will be called bcm2708_fb.

config FB_GRVGA
	tristate "Aeroflex Gaisler framebuffer support"
	depends on FB && SPARC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	This enables support for the SVGACTRL framebuffer in the GRLIB IP library from Aeroflex Gaisler.

config FB_CIRRUS
	tristate "Cirrus Logic support"
	depends on FB && (ZORRO || PCI)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  This enables support for Cirrus Logic GD542x/543x based boards on
	  Amiga: SD64, Piccolo, Picasso II/II+, Picasso IV, or EGS Spectrum.

	  If you have a PCI-based system, this enables support for these
	  chips: GD-543x, GD-544x, GD-5480.

	  Please read the file <file:Documentation/fb/cirrusfb.txt>.

	  Say N unless you have such a graphics board or plan to get one
	  before you next recompile the kernel.

config FB_PM2
	tristate "Permedia2 support"
	depends on FB && ((AMIGA && BROKEN) || PCI)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for cards based on
	  the 3D Labs Permedia, Permedia 2 and Permedia 2V chips.
	  The driver was tested on the following cards:
		Diamond FireGL 1000 PRO AGP
		ELSA Gloria Synergy PCI
		Appian Jeronimo PRO (both heads) PCI
		3DLabs Oxygen ACX aka EONtronics Picasso P2 PCI
		Techsource Raptor GFX-8P (aka Sun PGX-32) on SPARC
		ASK Graphic Blaster Exxtreme AGP

	  To compile this driver as a module, choose M here: the
	  module will be called pm2fb.

config FB_PM2_FIFO_DISCONNECT
	bool "enable FIFO disconnect feature"
	depends on FB_PM2 && PCI
	help
	  Support the Permedia2 FIFO disconnect feature.

config FB_ARMCLCD
	tristate "ARM PrimeCell PL110 support"
	depends on ARM || ARM64 || COMPILE_TEST
	depends on FB && ARM_AMBA && HAS_IOMEM
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS if OF
	select VIDEOMODE_HELPERS if OF
	select BACKLIGHT_LCD_SUPPORT if OF
	select BACKLIGHT_CLASS_DEVICE if OF
	help
	  This framebuffer device driver is for the ARM PrimeCell PL110
	  Colour LCD controller.  ARM PrimeCells provide the building
	  blocks for System on a Chip devices.

	  If you want to compile this as a module (=code which can be
	  inserted into and removed from the running kernel), say M
	  here and read <file:Documentation/kbuild/modules.txt>.  The module
	  will be called amba-clcd.

# Helper logic selected only by the ARM Versatile platform family.
config PLAT_VERSATILE_CLCD
	def_bool ARCH_VERSATILE || ARCH_REALVIEW || ARCH_VEXPRESS || ARCH_INTEGRATOR
	depends on ARM
	depends on FB_ARMCLCD && FB=y
	select REGMAP
	select MFD_SYSCON

config FB_ACORN
	bool "Acorn VIDC support"
	depends on (FB = y) && ARM && ARCH_ACORN
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Acorn VIDC graphics
	  hardware found in Acorn RISC PCs and other ARM-based machines.  If
	  unsure, say N.

config FB_CLPS711X_OLD
	tristate
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT

config FB_CLPS711X
	tristate "CLPS711X LCD support"
	depends on FB && (ARCH_CLPS711X || COMPILE_TEST)
	select FB_CLPS711X_OLD if ARCH_CLPS711X && !ARCH_MULTIPLATFORM
	select BACKLIGHT_LCD_SUPPORT
	select FB_MODE_HELPERS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select LCD_CLASS_DEVICE
	select VIDEOMODE_HELPERS
	help
	  Say Y to enable the Framebuffer driver for the Cirrus Logic
	  CLPS711X CPUs.

config FB_SA1100
	bool "SA-1100 LCD support"
	depends on (FB = y) && ARM && ARCH_SA1100
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is a framebuffer device for the SA-1100 LCD Controller.
	  See <http://www.linux-fbdev.org/> for information on framebuffer
	  devices.

	  If you plan to use the LCD display with your SA-1100 system, say
	  Y here.

config FB_IMX
	tristate "Freescale i.MX1/21/25/27 LCD support"
	depends on FB && ARCH_MXC
	select BACKLIGHT_LCD_SUPPORT
	select LCD_CLASS_DEVICE
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS

config FB_CYBER2000
	tristate "CyberPro 2000/2010/5000 support"
	depends on FB && PCI && (BROKEN || !SPARC64)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This enables support for the Integraphics CyberPro 20x0 and 5000
	  VGA chips used in the Rebel.com Netwinder and other machines.
	  Say Y if you have a NetWinder or a graphics card containing this
	  device, otherwise say N.

config FB_CYBER2000_DDC
	bool "DDC for CyberPro support"
	depends on FB_CYBER2000
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC support for your CyberPro graphics
	  card. This is only I2C bus support, driver does not use EDID.

config FB_CYBER2000_I2C
	bool "CyberPro 2000/2010/5000 I2C support"
	depends on FB_CYBER2000 && I2C && ARCH_NETWINDER
	depends on I2C=y || FB_CYBER2000=m
	select I2C_ALGOBIT
	help
	  Enable support for the I2C video decoder interface on the
	  Integraphics CyberPro 20x0 and 5000 VGA chips.  This is used
	  on the Netwinder machines for the SAA7111 video capture.

config FB_APOLLO
	bool
	depends on (FB = y) && APOLLO
	default y
	select FB_CFB_FILLRECT
	select FB_CFB_IMAGEBLIT

config FB_Q40
	bool
	depends on (FB = y) && Q40
	default y
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT

config FB_AMIGA
	tristate "Amiga native chipset support"
	depends on FB && AMIGA
	help
	  This is the frame buffer device driver for the builtin graphics
	  chipset found in Amigas.

	  To compile this driver as a module, choose M here: the
	  module will be called amifb.

config FB_AMIGA_OCS
	bool "Amiga OCS chipset support"
	depends on FB_AMIGA
	help
	  This enables support for the original Agnus and Denise video chips,
	  found in the Amiga 1000 and most A500's and A2000's. If you intend
	  to run Linux on any of these systems, say Y; otherwise say N.

config FB_AMIGA_ECS
	bool "Amiga ECS chipset support"
	depends on FB_AMIGA
	help
	  This enables support for the Enhanced Chip Set, found in later
	  A500's, later A2000's, the A600, the A3000, the A3000T and CDTV. If
	  you intend to run Linux on any of these systems, say Y; otherwise
	  say N.

config FB_AMIGA_AGA
	bool "Amiga AGA chipset support"
	depends on FB_AMIGA
	help
	  This enables support for the Advanced Graphics Architecture (also
	  known as the AGA or AA) Chip Set, found in the A1200, A4000, A4000T
	  and CD32. If you intend to run Linux on any of these systems, say Y;
	  otherwise say N.

config FB_FM2
	bool "Amiga FrameMaster II/Rainbow II support"
	depends on (FB = y) && ZORRO
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Amiga FrameMaster
	  card from BSC (exhibited 1992 but not shipped as a CBM product).

config FB_ARC
	tristate "Arc Monochrome LCD board support"
	depends on FB && X86
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	help
	  This enables support for the Arc Monochrome LCD board. The board
	  is based on the KS-108 lcd controller and is typically a matrix
	  of 2*n chips. This driver was tested with a 128x64 panel. This
	  driver supports it for use with x86 SBCs through a 16 bit GPIO
	  interface (8 bit data, 8 bit control). If you anticipate using
	  this driver, say Y or M; otherwise say N. You must specify the
	  GPIO IO address to be used for setting control and data.

config FB_ATARI
	bool "Atari native chipset support"
	depends on (FB = y) && ATARI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the builtin graphics
	  chipset found in Ataris.

config FB_OF
	bool "Open Firmware frame buffer device support"
	depends on (FB = y) && PPC && (!PPC_PSERIES || PCI)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  Say Y if you want support with Open Firmware for your graphics
	  board.

config FB_CONTROL
	bool "Apple \"control\" display support"
	depends on (FB = y) && PPC_PMAC && PPC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  This driver supports a frame buffer for the graphics adapter in the
	  Power Macintosh 7300 and others.

config FB_PLATINUM
	bool "Apple \"platinum\" display support"
	depends on (FB = y) && PPC_PMAC && PPC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  This driver supports a frame buffer for the "platinum" graphics
	  adapter in some Power Macintoshes.

config FB_VALKYRIE
	bool "Apple \"valkyrie\" display support"
	depends on (FB = y) && (MAC || (PPC_PMAC && PPC32))
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  This driver supports a frame buffer for the "valkyrie" graphics
	  adapter in some Power Macintoshes.

config FB_CT65550
	bool "Chips 65550 display support"
	depends on (FB = y) && PPC32 && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Chips & Technologies
	  65550 graphics chip in PowerBooks.

config FB_ASILIANT
	bool "Asiliant (Chips) 69000 display support"
	depends on (FB = y) && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Asiliant 69030 chipset

config FB_IMSTT
	bool "IMS Twin Turbo display support"
	depends on (FB = y) && PCI
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES if PPC
	help
	  The IMS Twin Turbo is a PCI-based frame buffer card bundled with
	  many Macintosh and compatible computers.

config FB_VGA16
	tristate "VGA 16-color graphics support"
	depends on FB && (X86 || PPC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	help
	  This is the frame buffer device driver for VGA 16 color graphic
	  cards. Say Y if you have such a card.

	  To compile this driver as a module, choose M here: the
	  module will be called vga16fb.

config FB_BF54X_LQ043
	tristate "SHARP LQ043 TFT LCD (BF548 EZKIT)"
	depends on FB && (BF54x) && !BF542
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	 This is the framebuffer device driver for a SHARP LQ043T1DG01 TFT LCD

config FB_BFIN_T350MCQB
	tristate "Varitronix COG-T350MCQB TFT LCD display (BF527 EZKIT)"
	depends on FB && BLACKFIN
	select BFIN_GPTIMERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	 This is the framebuffer device driver for a Varitronix VL-PS-COG-T350MCQB-01 display TFT LCD
	 This display is a QVGA 320x240 24-bit RGB display interfaced by an 8-bit wide PPI
	 It uses PPI[0..7] PPI_FS1, PPI_FS2 and PPI_CLK.

config FB_BFIN_LQ035Q1
	tristate "SHARP LQ035Q1DH02 TFT LCD"
	depends on FB && BLACKFIN && SPI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BFIN_GPTIMERS
	help
	  This is the framebuffer device driver for a SHARP LQ035Q1DH02 TFT display found on
	  the Blackfin Landscape LCD EZ-Extender Card.
	  This display is a QVGA 320x240 18-bit RGB display interfaced by an 16-bit wide PPI
	  It uses PPI[0..15] PPI_FS1, PPI_FS2 and PPI_CLK.

	  To compile this driver as a module, choose M here: the
	  module will be called bfin-lq035q1-fb.

config FB_BF537_LQ035
	tristate "SHARP LQ035 TFT LCD (BF537 STAMP)"
	depends on FB && (BF534 || BF536 || BF537) && I2C_BLACKFIN_TWI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BFIN_GPTIMERS
	help
	  This is the framebuffer device for a SHARP LQ035Q7DB03 TFT LCD
	  attached to a BF537.

	  To compile this driver as a module, choose M here: the
	  module will be called bf537-lq035.

config FB_BFIN_7393
	tristate "Blackfin ADV7393 Video encoder"
	depends on FB && BLACKFIN
	select I2C
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for a ADV7393 video encoder
	  attached to a Blackfin on the PPI port.
	  If your Blackfin board has a ADV7393 select Y.

	  To compile this driver as a module, choose M here: the
	  module will be called bfin_adv7393fb.

choice
	prompt  "Video mode support"
	depends on FB_BFIN_7393
	default NTSC

config NTSC
	bool 'NTSC 720x480'

config PAL
	bool 'PAL 720x576'

config NTSC_640x480
	bool 'NTSC 640x480 (Experimental)'

config PAL_640x480
	bool 'PAL 640x480 (Experimental)'

config NTSC_YCBCR
	bool 'NTSC 720x480 YCbCR input'

config PAL_YCBCR
	bool 'PAL 720x576 YCbCR input'

endchoice

choice
	prompt  "Size of ADV7393 frame buffer memory Single/Double Size"
	depends on (FB_BFIN_7393)
	default ADV7393_1XMEM

config ADV7393_1XMEM
	bool 'Single'

config ADV7393_2XMEM
	bool 'Double'
endchoice

config FB_STI
	tristate "HP STI frame buffer device support"
	depends on FB && PARISC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select STI_CONSOLE
	select VT
	default y
	---help---
	  STI refers to the HP "Standard Text Interface" which is a set of
	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
	  Enabling this option will implement the linux framebuffer device
	  using calls to the STI BIOS routines for initialisation.
	
	  If you enable this option, you will get a planar framebuffer device
	  /dev/fb which will work on the most common HP graphic cards of the
	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
	  HCRX, HCRX24, CRX, CRX24 and VisEG series.

	  It is safe to enable this option, so you should probably say "Y".

config FB_MAC
	bool "Generic Macintosh display support"
	depends on (FB = y) && MAC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES

config FB_HP300
	bool
	depends on (FB = y) && DIO
	select FB_CFB_IMAGEBLIT
	default y

config FB_TGA
	tristate "TGA/SFB+ framebuffer support"
	depends on FB && (ALPHA || TC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BITREVERSE
	---help---
	  This is the frame buffer device driver for generic TGA and SFB+
	  graphic cards.  These include DEC ZLXp-E1, -E2 and -E3 PCI cards,
	  also known as PBXGA-A, -B and -C, and DEC ZLX-E1, -E2 and -E3
	  TURBOchannel cards, also known as PMAGD-A, -B and -C.

	  Due to hardware limitations ZLX-E2 and E3 cards are not supported
	  for DECstation 5000/200 systems.  Additionally due to firmware
	  limitations these cards may cause troubles with booting DECstation
	  5000/240 and /260 systems, but are fully supported under Linux if
	  you manage to get it going. ;-)

	  Say Y if you have one of those.

config FB_UVESA
	tristate "Userspace VESA VGA graphics support"
	depends on FB && CONNECTOR
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	help
	  This is the frame buffer driver for generic VBE 2.0 compliant
	  graphic cards. It can also take advantage of VBE 3.0 features,
	  such as refresh rate adjustment.

	  This driver generally provides more features than vesafb but
	  requires a userspace helper application called 'v86d'. See
	  <file:Documentation/fb/uvesafb.txt> for more information.

	  If unsure, say N.

config FB_VESA
	bool "VESA VGA graphics support"
	depends on (FB = y) && X86
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BOOT_VESA_SUPPORT
	help
	  This is the frame buffer device driver for generic VESA 2.0
	  compliant graphic cards. The older VESA 1.2 cards are not supported.
	  You will get a boot time penguin logo at no additional cost. Please
	  read <file:Documentation/fb/vesafb.txt>. If unsure, say Y.

config FB_EFI
	bool "EFI-based Framebuffer Support"
	depends on (FB = y) && !IA64 && EFI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the EFI frame buffer device driver. If the firmware on
	  your platform is EFI 1.10 or UEFI 2.0, select Y to add support for
	  using the EFI framebuffer as your console.

config FB_N411
       tristate "N411 Apollo/Hecuba devkit support"
       depends on FB && X86 && MMU
       select FB_SYS_FILLRECT
       select FB_SYS_COPYAREA
       select FB_SYS_IMAGEBLIT
       select FB_SYS_FOPS
       select FB_DEFERRED_IO
       select FB_HECUBA
       help
         This enables support for the Apollo display controller in its
         Hecuba form using the n411 devkit.

config FB_HGA
	tristate "Hercules mono graphics support"
	depends on FB && X86
	help
	  Say Y here if you have a Hercules mono graphics card.

	  To compile this driver as a module, choose M here: the
	  module will be called hgafb.

	  As this card technology is at least 25 years old,
	  most people will answer N here.

config FB_GBE
	bool "SGI Graphics Backend frame buffer support"
	depends on (FB = y) && SGI_IP32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
 	help
	  This is the frame buffer device driver for SGI Graphics Backend.
	  This chip is used in SGI O2 and Visual Workstation 320/540.

config FB_GBE_MEM
	int "Video memory size in MB"
	depends on FB_GBE
	default 4
	help
	  This is the amount of memory reserved for the framebuffer,
	  which can be any value between 1MB and 8MB.

config FB_SBUS
	bool "SBUS and UPA framebuffers"
	depends on (FB = y) && SPARC
	help
	  Say Y if you want support for SBUS or UPA based frame buffer device.

config FB_BW2
	bool "BWtwo support"
	depends on (FB = y) && (SPARC && FB_SBUS)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the BWtwo frame buffer.

config FB_CG3
	bool "CGthree support"
	depends on (FB = y) && (SPARC && FB_SBUS)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the CGthree frame buffer.

config FB_CG6
	bool "CGsix (GX,TurboGX) support"
	depends on (FB = y) && (SPARC && FB_SBUS)
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the CGsix (GX, TurboGX)
	  frame buffer.

config FB_FFB
	bool "Creator/Creator3D/Elite3D support"
	depends on FB_SBUS && SPARC64
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Creator, Creator3D,
	  and Elite3D graphics boards.

config FB_TCX
	bool "TCX (SS4/SS5 only) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the TCX 24/8bit frame
	  buffer.

config FB_CG14
	bool "CGfourteen (SX) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the CGfourteen frame
	  buffer on Desktop SPARCsystems with the SX graphics option.

config FB_P9100
	bool "P9100 (Sparcbook 3 only) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the P9100 card
	  supported on Sparcbook 3 machines.

config FB_LEO
	bool "Leo (ZX) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the SBUS-based Sun ZX
	  (leo) frame buffer cards.

config FB_IGA
	bool "IGA 168x display support"
	depends on (FB = y) && SPARC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the INTERGRAPHICS 1680 and
	  successor frame buffer cards.

config FB_XVR500
	bool "Sun XVR-500 3DLABS Wildcat support"
	depends on (FB = y) && PCI && SPARC64
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the Sun XVR-500 and similar
	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
	  only works on sparc64 systems where the system firmware has
	  mostly initialized the card already.  It is treated as a
	  completely dumb framebuffer device.

config FB_XVR2500
	bool "Sun XVR-2500 3DLABS Wildcat support"
	depends on (FB = y) && PCI && SPARC64
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the Sun XVR-2500 and similar
	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
	  only works on sparc64 systems where the system firmware has
	  mostly initialized the card already.  It is treated as a
	  completely dumb framebuffer device.

config FB_XVR1000
	bool "Sun XVR-1000 support"
	depends on (FB = y) && SPARC64
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the Sun XVR-1000 and similar
	  graphics cards.  The driver only works on sparc64 systems where
	  the system firmware has mostly initialized the card already.  It
	  is treated as a completely dumb framebuffer device.

config FB_PVR2
	tristate "NEC PowerVR 2 display support"
	depends on FB && SH_DREAMCAST
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Say Y here if you have a PowerVR 2 card in your box.  If you plan to
	  run linux on your Dreamcast, you will have to say Y here.
	  This driver may or may not work on other PowerVR 2 cards, but is
	  totally untested.  Use at your own risk.  If unsure, say N.

	  To compile this driver as a module, choose M here: the
	  module will be called pvr2fb.

	  You can pass several parameters to the driver at boot time or at
	  module load time.  The parameters look like "video=pvr2:XXX", where
	  the meaning of XXX can be found at the end of the main source file
	  (<file:drivers/video/pvr2fb.c>). Please see the file
	  <file:Documentation/fb/pvr2fb.txt>.

config FB_OPENCORES
	tristate "OpenCores VGA/LCD core 2.0 framebuffer support"
	depends on FB && HAS_DMA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This enables support for the OpenCores VGA/LCD core.

	  The OpenCores VGA/LCD core is typically used together with
	  softcore CPUs (e.g. OpenRISC or Microblaze) or hard processor
	  systems (e.g. Altera socfpga or Xilinx Zynq) on FPGAs.

	  The source code and specification for the core is available at
	  <http://opencores.org/project,vga_lcd>

config FB_S1D13XXX
	tristate "Epson S1D13XXX framebuffer support"
	depends on FB
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Support for S1D13XXX framebuffer device family (currently only
	  working with S1D13806). Product specs at
	  <http://vdc.epson.com/>

config FB_ATMEL
	tristate "AT91/AT32 LCD Controller support"
	depends on FB && HAVE_FB_ATMEL
	select FB_BACKLIGHT
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  This enables support for the AT91/AT32 LCD Controller.

config FB_NVIDIA
	tristate "nVidia Framebuffer Support"
	depends on FB && PCI
	select FB_BACKLIGHT if FB_NVIDIA_BACKLIGHT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BITREVERSE
	select VGASTATE
	help
	  This driver supports graphics boards with the nVidia chips, TNT
	  and newer. For very old chipsets, such as the RIVA128, then use
	  the rivafb.
	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called nvidiafb.

config FB_NVIDIA_I2C
       bool "Enable DDC Support"
       depends on FB_NVIDIA
       select FB_DDC
       help
	  This enables I2C support for nVidia Chipsets.  This is used
	  only for getting EDID information from the attached display
	  allowing for robust video mode handling and switching.

	  Because fbdev-2.6 requires that drivers must be able to
	  independently validate video mode parameters, you should say Y
	  here.

config FB_NVIDIA_DEBUG
	bool "Lots of debug output"
	depends on FB_NVIDIA
	default n
	help
	  Say Y here if you want the nVidia driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_NVIDIA_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_NVIDIA
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_RIVA
	tristate "nVidia Riva support"
	depends on FB && PCI
	select FB_BACKLIGHT if FB_RIVA_BACKLIGHT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BITREVERSE
	select VGASTATE
	help
	  This driver supports graphics boards with the nVidia Riva/Geforce
	  chips.
	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called rivafb.

config FB_RIVA_I2C
       bool "Enable DDC Support"
       depends on FB_RIVA
       select FB_DDC
       help
	  This enables I2C support for nVidia Chipsets.  This is used
	  only for getting EDID information from the attached display
	  allowing for robust video mode handling and switching.

	  Because fbdev-2.6 requires that drivers must be able to
	  independently validate video mode parameters, you should say Y
	  here.

config FB_RIVA_DEBUG
	bool "Lots of debug output"
	depends on FB_RIVA
	default n
	help
	  Say Y here if you want the Riva driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_RIVA_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_RIVA
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_I740
	tristate "Intel740 support"
	depends on FB && PCI
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	select FB_DDC
	help
	  This driver supports graphics cards based on Intel740 chip.

config FB_I810
	tristate "Intel 810/815 support"
	depends on FB && PCI && X86_32 && AGP_INTEL
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	help
	  This driver supports the on-board graphics built in to the Intel 810 
          and 815 chipsets.  Say Y if you have and plan to use such a board.

          To compile this driver as a module, choose M here: the
	  module will be called i810fb.

          For more information, please read 
	  <file:Documentation/fb/intel810.txt>

config FB_I810_GTF
	bool "use VESA Generalized Timing Formula"
	depends on FB_I810
	help
	  If you say Y, then the VESA standard, Generalized Timing Formula 
          or GTF, will be used to calculate the required video timing values
	  per video mode.  Since the GTF allows nondiscrete timings 
          (nondiscrete being a range of values as opposed to discrete being a
          set of values), you'll be able to use any combination of horizontal 
	  and vertical resolutions, and vertical refresh rates without having
	  to specify your own timing parameters.  This is especially useful
	  to maximize the performance of an aging display, or if you just 
          have a display with nonstandard dimensions. A VESA compliant 
	  monitor is recommended, but can still work with non-compliant ones.
	  If you need or want this, then select this option. The timings may 
	  not be compliant with Intel's recommended values. Use at your own 
	  risk.

          If you say N, the driver will revert to discrete video timings 
	  using a set recommended by Intel in their documentation.
  
          If unsure, say N.

config FB_I810_I2C
	bool "Enable DDC Support"
	depends on FB_I810 && FB_I810_GTF
	select FB_DDC
	help

config FB_LE80578
	tristate "Intel LE80578 (Vermilion) support"
	depends on FB && PCI && X86
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This driver supports the LE80578 (Vermilion Range) chipset

config FB_CARILLO_RANCH
	tristate "Intel Carillo Ranch support"
	depends on FB_LE80578 && FB && PCI && X86
	help
	  This driver supports the LE80578 (Carillo Ranch) board

config FB_INTEL
	tristate "Intel 830M/845G/852GM/855GM/865G/915G/945G/945GM/965G/965GM support"
	depends on FB && PCI && X86 && AGP_INTEL && EXPERT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BOOT_VESA_SUPPORT if FB_INTEL = y
	depends on !DRM_I915
	help
	  This driver supports the on-board graphics built in to the Intel
          830M/845G/852GM/855GM/865G/915G/915GM/945G/945GM/965G/965GM chipsets.
          Say Y if you have and plan to use such a board.

	  To make FB_INTELFB=Y work you need to say AGP_INTEL=y too.

	  To compile this driver as a module, choose M here: the
	  module will be called intelfb.

	  For more information, please read <file:Documentation/fb/intelfb.txt>

config FB_INTEL_DEBUG
	bool "Intel driver Debug Messages"
	depends on FB_INTEL
	---help---
	  Say Y here if you want the Intel driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_INTEL_I2C
	bool "DDC/I2C for Intel framebuffer support"
	depends on FB_INTEL
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC/I2C support for your on-board Intel graphics.

config FB_MATROX
	tristate "Matrox acceleration"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_MACMODES if PPC_PMAC
	---help---
	  Say Y here if you have a Matrox Millennium, Matrox Millennium II,
	  Matrox Mystique, Matrox Mystique 220, Matrox Productiva G100, Matrox
	  Mystique G200, Matrox Millennium G200, Matrox Marvel G200 video,
	  Matrox G400, G450 or G550 card in your box.

	  To compile this driver as a module, choose M here: the
	  module will be called matroxfb.

	  You can pass several parameters to the driver at boot time or at
	  module load time. The parameters look like "video=matroxfb:XXX", and
	  are described in <file:Documentation/fb/matroxfb.txt>.

config FB_MATROX_MILLENIUM
	bool "Millennium I/II support"
	depends on FB_MATROX
	help
	  Say Y here if you have a Matrox Millennium or Matrox Millennium II
	  video card. If you select "Advanced lowlevel driver options" below,
	  you should check 4 bpp packed pixel, 8 bpp packed pixel, 16 bpp
	  packed pixel, 24 bpp packed pixel and 32 bpp packed pixel. You can
	  also use font widths different from 8.

config FB_MATROX_MYSTIQUE
	bool "Mystique support"
	depends on FB_MATROX
	help
	  Say Y here if you have a Matrox Mystique or Matrox Mystique 220
	  video card. If you select "Advanced lowlevel driver options" below,
	  you should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp
	  packed pixel and 32 bpp packed pixel. You can also use font widths
	  different from 8.

config FB_MATROX_G
	bool "G100/G200/G400/G450/G550 support"
	depends on FB_MATROX
	---help---
	  Say Y here if you have a Matrox G100, G200, G400, G450 or G550 based
	  video card. If you select "Advanced lowlevel driver options", you
	  should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp packed
	  pixel and 32 bpp packed pixel. You can also use font widths
	  different from 8.

	  If you need support for G400 secondary head, you must say Y to
	  "Matrox I2C support" and "G400 second head support" right below.
	  G450/G550 secondary head and digital output are supported without
	  additional modules.

	  The driver starts in monitor mode. You must use the matroxset tool 
	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
	  swap primary and secondary head outputs, or to change output mode.  
	  Secondary head driver always start in 640x480 resolution and you 
	  must use fbset to change it.

	  Do not forget that second head supports only 16 and 32 bpp
	  packed pixels, so it is a good idea to compile them into the kernel
	  too. You can use only some font widths, as the driver uses generic
	  painting procedures (the secondary head does not use acceleration
	  engine).

	  G450/G550 hardware can display TV picture only from secondary CRTC,
	  and it performs no scaling, so picture must have 525 or 625 lines.

config FB_MATROX_I2C
	tristate "Matrox I2C support"
	depends on FB_MATROX
	select FB_DDC
	---help---
	  This drivers creates I2C buses which are needed for accessing the
	  DDC (I2C) bus present on all Matroxes, an I2C bus which
	  interconnects Matrox optional devices, like MGA-TVO on G200 and
	  G400, and the secondary head DDC bus, present on G400 only.

	  You can say Y or M here if you want to experiment with monitor
	  detection code. You must say Y or M here if you want to use either
	  second head of G400 or MGA-TVO on G200 or G400.

	  If you compile it as module, it will create a module named
	  i2c-matroxfb.

config FB_MATROX_MAVEN
	tristate "G400 second head support"
	depends on FB_MATROX_G && FB_MATROX_I2C
	---help---
	  WARNING !!! This support does not work with G450 !!!

	  Say Y or M here if you want to use a secondary head (meaning two
	  monitors in parallel) on G400 or MGA-TVO add-on on G200. Secondary
	  head is not compatible with accelerated XFree 3.3.x SVGA servers -
	  secondary head output is blanked while you are in X. With XFree
	  3.9.17 preview you can use both heads if you use SVGA over fbdev or
	  the fbdev driver on first head and the fbdev driver on second head.

	  If you compile it as module, two modules are created,
	  matroxfb_crtc2 and matroxfb_maven. Matroxfb_maven is needed for
	  both G200 and G400, matroxfb_crtc2 is needed only by G400. You must
	  also load i2c-matroxfb to get it to run.

	  The driver starts in monitor mode and you must use the matroxset
	  tool (available at
	  <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to switch it to
	  PAL or NTSC or to swap primary and secondary head outputs.
	  Secondary head driver also always start in 640x480 resolution, you
	  must use fbset to change it.

	  Also do not forget that second head supports only 16 and 32 bpp
	  packed pixels, so it is a good idea to compile them into the kernel
	  too.  You can use only some font widths, as the driver uses generic
	  painting procedures (the secondary head does not use acceleration
	  engine).

config FB_RADEON
	tristate "ATI Radeon display support"
	depends on FB && PCI
	select FB_BACKLIGHT if FB_RADEON_BACKLIGHT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES if PPC
	help
	  Choose this option if you want to use an ATI Radeon graphics card as
	  a framebuffer device.  There are both PCI and AGP versions.  You
	  don't need to choose this to run the Radeon in plain VGA mode.

	  There is a product page at
	  http://products.amd.com/en-us/GraphicCardResult.aspx

config FB_RADEON_I2C
	bool "DDC/I2C for ATI Radeon support"
	depends on FB_RADEON
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC/I2C support for your Radeon board. 

config FB_RADEON_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_RADEON
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_RADEON_DEBUG
	bool "Lots of debug output from Radeon driver"
	depends on FB_RADEON
	default n
	help
	  Say Y here if you want the Radeon driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_ATY128
	tristate "ATI Rage128 display support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BACKLIGHT if FB_ATY128_BACKLIGHT
	select FB_MACMODES if PPC_PMAC
	help
	  This driver supports graphics boards with the ATI Rage128 chips.
	  Say Y if you have such a graphics board and read
	  <file:Documentation/fb/aty128fb.txt>.

	  To compile this driver as a module, choose M here: the
	  module will be called aty128fb.

config FB_ATY128_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_ATY128
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_ATY
	tristate "ATI Mach64 display support" if PCI || ATARI
	depends on FB && !SPARC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BACKLIGHT if FB_ATY_BACKLIGHT
	select FB_MACMODES if PPC
	help
	  This driver supports graphics boards with the ATI Mach64 chips.
	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called atyfb.

config FB_ATY_CT
	bool "Mach64 CT/VT/GT/LT (incl. 3D RAGE) support"
	depends on PCI && FB_ATY
	default y if SPARC64 && PCI
	help
	  Say Y here to support use of ATI's 64-bit Rage boards (or other
	  boards based on the Mach64 CT, VT, GT, and LT chipsets) as a
	  framebuffer device.  The ATI product support page for these boards
	  is at <http://support.ati.com/products/pc/mach64/mach64.html>.

config FB_ATY_GENERIC_LCD
	bool "Mach64 generic LCD support"
	depends on FB_ATY_CT
	help
	  Say Y if you have a laptop with an ATI Rage LT PRO, Rage Mobility,
	  Rage XC, or Rage XL chipset.

config FB_ATY_GX
	bool "Mach64 GX support" if PCI
	depends on FB_ATY
	default y if ATARI
	help
	  Say Y here to support use of the ATI Mach64 Graphics Expression
	  board (or other boards based on the Mach64 GX chipset) as a
	  framebuffer device.  The ATI product support page for these boards
	  is at
	  <http://support.ati.com/products/pc/mach64/graphics_xpression.html>.

config FB_ATY_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_ATY
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_S3
	tristate "S3 Trio/Virge support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_SVGALIB
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	---help---
	  Driver for graphics boards with S3 Trio / S3 Virge chip.

config FB_S3_DDC
	bool "DDC for S3 support"
	depends on FB_S3
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC support for your S3 graphics card.

config FB_SAVAGE
	tristate "S3 Savage support"
	depends on FB && PCI
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	help
	  This driver supports notebooks and computers with S3 Savage PCI/AGP
	  chips.

	  Say Y if you have such a graphics card.

	  To compile this driver as a module, choose M here; the module
	  will be called savagefb.

config FB_SAVAGE_I2C
       bool "Enable DDC2 Support"
       depends on FB_SAVAGE
       select FB_DDC
       help
	  This enables I2C support for S3 Savage Chipsets.  This is used
	  only for getting EDID information from the attached display
	  allowing for robust video mode handling and switching.

	  Because fbdev-2.6 requires that drivers must be able to
	  independently validate video mode parameters, you should say Y
	  here.

config FB_SAVAGE_ACCEL
       bool "Enable Console Acceleration"
       depends on FB_SAVAGE
       default n
       help
          This option will compile in console acceleration support. If
          the resulting framebuffer console has bothersome glitches, then
          choose N here.

config FB_SIS
	tristate "SiS/XGI display support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BOOT_VESA_SUPPORT if FB_SIS = y
	select FB_SIS_300 if !FB_SIS_315
	help
	  This is the frame buffer device driver for the SiS 300, 315, 330
	  and 340 series as well as XGI V3XT, V5, V8, Z7 graphics chipsets.
	  Specs available at <http://www.sis.com> and <http://www.xgitech.com>.

	  To compile this driver as a module, choose M here; the module
	  will be called sisfb.

config FB_SIS_300
	bool "SiS 300 series support"
	depends on FB_SIS
	help
	  Say Y here to support use of the SiS 300/305, 540, 630 and 730.

config FB_SIS_315
	bool "SiS 315/330/340 series and XGI support"
	depends on FB_SIS
	help
	  Say Y here to support use of the SiS 315, 330 and 340 series
	  (315/H/PRO, 55x, 650, 651, 740, 330, 661, 741, 760, 761) as well
	  as XGI V3XT, V5, V8 and Z7.

config FB_VIA
       tristate "VIA UniChrome (Pro) and Chrome9 display support"
       depends on FB && PCI && X86 && GPIOLIB && I2C
       select FB_CFB_FILLRECT
       select FB_CFB_COPYAREA
       select FB_CFB_IMAGEBLIT
       select I2C_ALGOBIT
       help
	  This is the frame buffer device driver for Graphics chips of VIA
	  UniChrome (Pro) Family (CLE266,PM800/CN400,P4M800CE/P4M800Pro/
	  CN700/VN800,CX700/VX700,P4M890) and Chrome9 Family (K8M890,CN896
 	  /P4M900,VX800)
	  Say Y if you have a VIA UniChrome graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called viafb.

if FB_VIA

config FB_VIA_DIRECT_PROCFS
	bool "direct hardware access via procfs (DEPRECATED)(DANGEROUS)"
	depends on FB_VIA
	default n
	help
	  Allow direct hardware access to some output registers via procfs.
	  This is dangerous but may provide the only chance to get the
	  correct output device configuration.
	  Its use is strongly discouraged.

config FB_VIA_X_COMPATIBILITY
	bool "X server compatibility"
	depends on FB_VIA
	default n
	help
	  This option reduces the functionality (power saving, ...) of the
	  framebuffer to avoid negative impact on the OpenChrome X server.
	  If you use any X server other than fbdev you should enable this
	  otherwise it should be safe to disable it and allow using all
	  features.

endif

config FB_NEOMAGIC
	tristate "NeoMagic display support"
	depends on FB && PCI
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	help
	  This driver supports notebooks with NeoMagic PCI chips.
	  Say Y if you have such a graphics card. 

	  To compile this driver as a module, choose M here: the
	  module will be called neofb.

config FB_KYRO
	tristate "IMG Kyro support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Say Y here if you have a STG4000 / Kyro / PowerVR 3 based
	  graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called kyrofb.

config FB_3DFX
	tristate "3Dfx Banshee/Voodoo3/Voodoo5 display support"
	depends on FB && PCI
	select FB_CFB_IMAGEBLIT
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_MODE_HELPERS
	help
	  This driver supports graphics boards with the 3Dfx Banshee,
	  Voodoo3 or VSA-100 (aka Voodoo4/5) chips. Say Y if you have
	  such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called tdfxfb.

config FB_3DFX_ACCEL
	bool "3Dfx Acceleration functions"
	depends on FB_3DFX
	---help---
	This will compile the 3Dfx Banshee/Voodoo3/VSA-100 frame buffer
	device driver with acceleration functions.

config FB_3DFX_I2C
	bool "Enable DDC/I2C support"
	depends on FB_3DFX
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC/I2C support for your 3dfx Voodoo3.

config FB_VOODOO1
	tristate "3Dfx Voodoo Graphics (sst1) support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
	  Voodoo2 (cvg) based graphics card.

	  To compile this driver as a module, choose M here: the
	  module will be called sstfb.

	  WARNING: Do not use any application that uses the 3D engine
	  (namely glide) while using this driver.
	  Please read the <file:Documentation/fb/sstfb.txt> for supported
	  options and other important info  support.

config FB_VT8623
	tristate "VIA VT8623 support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_SVGALIB
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	---help---
	  Driver for CastleRock integrated graphics core in the
	  VIA VT8623 [Apollo CLE266] chipset.

config FB_TRIDENT
	tristate "Trident/CyberXXX/CyberBlade support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_DDC
	select FB_MODE_HELPERS
	---help---
	  This is the frame buffer device driver for Trident PCI/AGP chipsets.
	  Supported chipset families are TGUI 9440/96XX, 3DImage, Blade3D
	  and Blade XP.
	  There are also integrated versions of these chips called CyberXXXX,
	  CyberImage or CyberBlade. These chips are mostly found in laptops
	  but also on some motherboards including early VIA EPIA motherboards.
	  For more information, read <file:Documentation/fb/tridentfb.txt>

	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called tridentfb.

config FB_ARK
	tristate "ARK 2000PV support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_SVGALIB
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	---help---
	  Driver for PCI graphics boards with ARK 2000PV chip
	  and ICS 5342 RAMDAC.

config FB_PM3
	tristate "Permedia3 support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the 3DLabs Permedia3
	  chipset, used in Formac ProFormance III, 3DLabs Oxygen VX1 &
	  similar boards, 3DLabs Permedia3 Create!, Appian Jeronimo 2000
	  and maybe other boards.

config FB_CARMINE
	tristate "Fujitsu carmine frame buffer support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Fujitsu Carmine chip.
	  The driver provides two independent frame buffer devices.

choice
	depends on FB_CARMINE
	prompt "DRAM timing"
	default FB_CARMINE_DRAM_EVAL

config FB_CARMINE_DRAM_EVAL
	bool "Eval board timings"
	help
	  Use timings which work on the eval card.

config CARMINE_DRAM_CUSTOM
	bool "Custom board timings"
	help
	  Use custom board timings.
endchoice

config FB_AU1100
	bool "Au1100 LCD Driver"
	depends on (FB = y) && MIPS_ALCHEMY
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer driver for the AMD Au1100 SOC.  It can drive
	  various panels and CRTs by passing in kernel cmd line option
	  au1100fb:panel=<name>.

config FB_AU1200
	bool "Au1200/Au1300 LCD Driver"
	depends on (FB = y) && MIPS_ALCHEMY
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	help
	  This is the framebuffer driver for the Au1200/Au1300 SOCs.
	  It can drive various panels and CRTs by passing in kernel cmd line
	  option au1200fb:panel=<name>.

config FB_VT8500
	bool "VIA VT8500 framebuffer support"
	depends on (FB = y) && ARM && ARCH_VT8500
	select FB_SYS_FILLRECT if (!FB_WMT_GE_ROPS)
	select FB_SYS_COPYAREA if (!FB_WMT_GE_ROPS)
	select FB_SYS_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  This is the framebuffer driver for VIA VT8500 integrated LCD
	  controller.

config FB_WM8505
	bool "Wondermedia WM8xxx-series frame buffer support"
	depends on (FB = y) && ARM && ARCH_VT8500
	select FB_SYS_FILLRECT if (!FB_WMT_GE_ROPS)
	select FB_SYS_COPYAREA if (!FB_WMT_GE_ROPS)
	select FB_SYS_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  This is the framebuffer driver for WonderMedia WM8xxx-series
	  integrated LCD controller. This driver covers the WM8505, WM8650
	  and WM8850 SoCs.

config FB_WMT_GE_ROPS
	bool "VT8500/WM8xxx accelerated raster ops support"
	depends on (FB = y) && (FB_VT8500 || FB_WM8505)
	default n
	help
	  This adds support for accelerated raster operations on the
	  VIA VT8500 and Wondermedia 85xx series SoCs.

source "drivers/video/fbdev/geode/Kconfig"

config FB_HIT
	tristate "HD64461 Frame Buffer support"
	depends on FB && HD64461
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Hitachi HD64461 LCD
	  frame buffer card.

config FB_PMAG_AA
	tristate "PMAG-AA TURBOchannel framebuffer support"
	depends on FB && TC
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the PMAG-AA TURBOchannel framebuffer card (1280x1024x1)
	  used mainly in the MIPS-based DECstation series.

config FB_PMAG_BA
	tristate "PMAG-BA TURBOchannel framebuffer support"
	depends on FB && TC
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the PMAG-BA TURBOchannel framebuffer card (1024x864x8)
	  used mainly in the MIPS-based DECstation series.

config FB_PMAGB_B
	tristate "PMAGB-B TURBOchannel framebuffer support"
	depends on FB && TC
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the PMAGB-B TURBOchannel framebuffer card used mainly
	  in the MIPS-based DECstation series. The card is currently only
	  supported in 1280x1024x8 mode.

config FB_MAXINE
	bool "Maxine (Personal DECstation) onboard framebuffer support"
	depends on (FB = y) && MACH_DECSTATION
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the onboard framebuffer (1024x768x8) in the Personal
	  DECstation series (Personal DECstation 5000/20, /25, /33, /50,
	  Codename "Maxine").

config FB_G364
	bool "G364 frame buffer support"
	depends on (FB = y) && (MIPS_MAGNUM_4000 || OLIVETTI_M700)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  The G364 driver is the framebuffer used in MIPS Magnum 4000 and
	  Olivetti M700-10 systems.

config FB_68328
	bool "Motorola 68328 native frame buffer support"
	depends on (FB = y) && (M68328 || M68EZ328 || M68VZ328)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Say Y here if you want to support the built-in frame buffer of
	  the Motorola 68328 CPU family.

config FB_PXA168
	tristate "PXA168/910 LCD framebuffer support"
	depends on FB && (CPU_PXA168 || CPU_PXA910)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in LCD controller in the Marvell
	  MMP processor.

config FB_PXA
	tristate "PXA LCD framebuffer support"
	depends on FB && ARCH_PXA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VIDEOMODE_HELPERS if OF
	select FB_MODE_HELPERS if OF
	---help---
	  Frame buffer driver for the built-in LCD controller in the Intel
	  PXA2x0 processor.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called pxafb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_PXA_OVERLAY
	bool "Support PXA27x/PXA3xx Overlay(s) as framebuffer"
	default n
	depends on FB_PXA && (PXA27x || PXA3xx)

config FB_PXA_SMARTPANEL
	bool "PXA Smartpanel LCD support"
	default n
	depends on FB_PXA

config FB_PXA_PARAMETERS
	bool "PXA LCD command line parameters"
	default n
	depends on FB_PXA
	---help---
	  Enable the use of kernel command line or module parameters
	  to configure the physical properties of the LCD panel when
	  using the PXA LCD driver.

	  This option allows you to override the panel parameters
	  supplied by the platform in order to support multiple
	  different models of flatpanel. If you will only be using a
	  single model of flatpanel then you can safely leave this
	  option disabled.

	  <file:Documentation/fb/pxafb.txt> describes the available parameters.

config PXA3XX_GCU
	tristate "PXA3xx 2D graphics accelerator driver"
	depends on FB_PXA
	help
	  Kernelspace driver for the 2D graphics controller unit (GCU)
	  found on PXA3xx processors. There is a counterpart driver in the
	  DirectFB suite, see http://www.directfb.org/

	  If you compile this as a module, it will be called pxa3xx_gcu.

config FB_MBX
	tristate "2700G LCD framebuffer support"
	depends on FB && ARCH_PXA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Framebuffer driver for the Intel 2700G (Marathon) Graphics
	  Accelerator

config FB_MBX_DEBUG
       bool "Enable debugging info via debugfs"
       depends on FB_MBX && DEBUG_FS
       default n
       ---help---
         Enable this if you want debugging information using the debug
         filesystem (debugfs)

         If unsure, say N.

config FB_FSL_DIU
	tristate "Freescale DIU framebuffer support"
	depends on FB && FSL_SOC
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select PPC_LIB_RHEAP
	---help---
	  Framebuffer driver for the Freescale SoC DIU

config FB_W100
	tristate "W100 frame buffer support"
	depends on FB && ARCH_PXA
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the w100 as found on the Sharp SL-Cxx series.
	  It can also drive the w3220 chip found on iPAQ hx4700.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called w100fb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_SH_MOBILE_LCDC
	tristate "SuperH Mobile LCDC framebuffer support"
	depends on FB && (SUPERH || ARCH_RENESAS) && HAVE_CLK
	depends on FB_SH_MOBILE_MERAM || !FB_SH_MOBILE_MERAM
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	select FB_BACKLIGHT
	---help---
	  Frame buffer driver for the on-chip SH-Mobile LCD controller.

config FB_TMIO
	tristate "Toshiba Mobile IO FrameBuffer support"
	depends on FB && (MFD_TMIO || COMPILE_TEST)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the Toshiba Mobile IO integrated as found
	  on the Sharp SL-6000 series

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called tmiofb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_TMIO_ACCELL
	bool "tmiofb acceleration"
	depends on FB_TMIO
	default y

config FB_S3C
	tristate "Samsung S3C framebuffer support"
	depends on FB && (CPU_S3C2416 || ARCH_S3C64XX || \
		ARCH_S5PV210 || ARCH_EXYNOS)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in FB controller in the Samsung
	  SoC line from the S3C2443 onwards, including the S3C2416, S3C2450,
	  and the S3C64XX series such as the S3C6400 and S3C6410.

	  These chips all have the same basic framebuffer design with the
	  actual capabilities depending on the chip. For instance the S3C6400
	  and S3C6410 support 4 hardware windows whereas the S3C24XX series
	  currently only have two.

	  Currently the support is only for the S3C6400 and S3C6410 SoCs.

config FB_S3C_DEBUG_REGWRITE
       bool "Debug register writes"
       depends on FB_S3C
       ---help---
         Show all register writes via pr_debug()

config FB_S3C2410
	tristate "S3C2410 LCD framebuffer support"
	depends on FB && ARCH_S3C24XX
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in LCD controller in the Samsung
	  S3C2410 processor.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called s3c2410fb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.
config FB_S3C2410_DEBUG
	bool "S3C2410 lcd debug messages"
	depends on FB_S3C2410
	help
	  Turn on debugging messages. Note that you can set/unset at run time
	  through sysfs

config FB_NUC900
        tristate "NUC900 LCD framebuffer support"
        depends on FB && ARCH_W90X900
        select FB_CFB_FILLRECT
        select FB_CFB_COPYAREA
        select FB_CFB_IMAGEBLIT
        ---help---
          Frame buffer driver for the built-in LCD controller in the Nuvoton
          NUC900 processor

config GPM1040A0_320X240
        bool "Giantplus Technology GPM1040A0 320x240 Color TFT LCD"
        depends on FB_NUC900

config FB_SM501
	tristate "Silicon Motion SM501 framebuffer support"
	depends on FB && MFD_SM501
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the CRT and LCD controllers in the Silicon
	  Motion SM501.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called sm501fb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_SMSCUFX
	tristate "SMSC UFX6000/7000 USB Framebuffer support"
	depends on FB && USB
	select FB_MODE_HELPERS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	---help---
	  This is a kernel framebuffer driver for SMSC UFX USB devices.
	  Supports fbdev clients like xf86-video-fbdev, kdrive, fbi, and
	  mplayer -vo fbdev. Supports both UFX6000 (USB 2.0) and UFX7000
	  (USB 3.0) devices.
	  To compile as a module, choose M here: the module name is smscufx.

config FB_UDL
	tristate "Displaylink USB Framebuffer support"
	depends on FB && USB
	select FB_MODE_HELPERS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	---help---
	  This is a kernel framebuffer driver for DisplayLink USB devices.
	  Supports fbdev clients like xf86-video-fbdev, kdrive, fbi, and
	  mplayer -vo fbdev. Supports all USB 2.0 era DisplayLink devices.
	  To compile as a module, choose M here: the module name is udlfb.

config FB_IBM_GXT4500
	tristate "Framebuffer support for IBM GXT4000P/4500P/6000P/6500P adaptors"
	depends on FB
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Say Y here to enable support for the IBM GXT4000P/6000P and
	  GXT4500P/6500P display adaptor based on Raster Engine RC1000,
	  found on some IBM System P (pSeries) machines. This driver
	  doesn't use Geometry Engine GT1000. This driver also supports
	  AGP Fire GL2/3/4 cards on x86.

config FB_PS3
	tristate "PS3 GPU framebuffer driver"
	depends on FB && PS3_PS3AV
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	---help---
	  Include support for the virtual frame buffer in the PS3 platform.

config FB_PS3_DEFAULT_SIZE_M
	int "PS3 default frame buffer size (in MiB)"
	depends on FB_PS3
	default 9
	---help---
	  This is the default size (in MiB) of the virtual frame buffer in
	  the PS3.
	  The default value can be overridden on the kernel command line
	  using the "ps3fb" option (e.g. "ps3fb=9M");

config FB_XILINX
	tristate "Xilinx frame buffer support"
	depends on FB && (XILINX_VIRTEX || MICROBLAZE || ARCH_ZYNQ)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Include support for the Xilinx ML300/ML403 reference design
	  framebuffer. ML300 carries a 640*480 LCD display on the board,
	  ML403 uses a standard DB15 VGA connector.

config FB_GOLDFISH
	tristate "Goldfish Framebuffer"
	depends on FB && HAS_DMA && (GOLDFISH || COMPILE_TEST)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Framebuffer driver for Goldfish Virtual Platform

config FB_COBALT
	tristate "Cobalt server LCD frame buffer support"
	depends on FB && MIPS_COBALT

config FB_SH7760
	bool "SH7760/SH7763/SH7720/SH7721 LCDC support"
	depends on FB && (CPU_SUBTYPE_SH7760 || CPU_SUBTYPE_SH7763 \
		|| CPU_SUBTYPE_SH7720 || CPU_SUBTYPE_SH7721)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Support for the SH7760/SH7763/SH7720/SH7721 integrated
	  (D)STN/TFT LCD Controller.
	  Supports display resolutions up to 1024x1024 pixel, grayscale and
	  color operation, with depths ranging from 1 bpp to 8 bpp monochrome
	  and 8, 15 or 16 bpp color; 90 degrees clockwise display rotation for
	  panels <= 320 pixel horizontal resolution.

config FB_DA8XX
	tristate "DA8xx/OMAP-L1xx/AM335x Framebuffer support"
	depends on FB && (ARCH_DAVINCI_DA8XX || SOC_AM33XX)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_CFB_REV_PIXELS_IN_BYTE
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	---help---
	  This is the frame buffer device driver for the TI LCD controller
	  found on DA8xx/OMAP-L1xx/AM335x SoCs.
	  If unsure, say N.

config FB_VIRTUAL
	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	---help---
	  This is a `virtual' frame buffer device. It operates on a chunk of
	  unswappable kernel memory instead of on the memory of a graphics
	  board. This means you cannot see any output sent to this frame
	  buffer device, while it does consume precious memory. The main use
	  of this frame buffer device is testing and debugging the frame
	  buffer subsystem. Do NOT enable it for normal systems! To protect
	  the innocent, it has to be enabled explicitly at boot time using the
	  kernel option `video=vfb:'.

	  To compile this driver as a module, choose M here: the
	  module will be called vfb. In order to load it, you must use
	  the vfb_enable=1 option.

	  If unsure, say N.

config XEN_FBDEV_FRONTEND
	tristate "Xen virtual frame buffer support"
	depends on FB && XEN
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	select XEN_XENBUS_FRONTEND
	default y
	help
	  This driver implements the front-end of the Xen virtual
	  frame buffer driver.  It communicates with a back-end
	  in another domain.

config FB_METRONOME
	tristate "E-Ink Metronome/8track controller support"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	help
	  This driver implements support for the E-Ink Metronome
	  controller. The pre-release name for this device was 8track
	  and could also have been called by some vendors as PVI-nnnn.

config FB_MB862XX
	tristate "Fujitsu MB862xx GDC support"
	depends on FB
	depends on PCI || (OF && PPC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for Fujitsu Carmine/Coral-P(A)/Lime controllers.

choice
	prompt "GDC variant"
	depends on FB_MB862XX

config FB_MB862XX_PCI_GDC
	bool "Carmine/Coral-P(A) GDC"
	depends on PCI
	---help---
	  This enables framebuffer support for Fujitsu Carmine/Coral-P(A)
	  PCI graphics controller devices.

config FB_MB862XX_LIME
	bool "Lime GDC"
	depends on OF && PPC
	select FB_FOREIGN_ENDIAN
	select FB_LITTLE_ENDIAN
	---help---
	  Framebuffer support for Fujitsu Lime GDC on host CPU bus.

endchoice

config FB_MB862XX_I2C
	bool "Support I2C bus on MB862XX GDC"
	depends on FB_MB862XX && I2C
	depends on FB_MB862XX=m || I2C=y
	default y
	help
	  Selecting this option adds Coral-P(A)/Lime GDC I2C bus adapter
	  driver to support accessing I2C devices on controller's I2C bus.
	  These are usually some video decoder chips.

config FB_EP93XX
	tristate "EP93XX frame buffer support"
	depends on FB && ARCH_EP93XX
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Framebuffer driver for the Cirrus Logic EP93XX series of processors.
	  This driver is also available as a module. The module will be called
	  ep93xx-fb.

config FB_PRE_INIT_FB
	bool "Don't reinitialize, use bootloader's GDC/Display configuration"
	depends on FB && FB_MB862XX_LIME
	---help---
	  Select this option if display contents should be inherited as set by
	  the bootloader.

config FB_MX3
	tristate "MX3 Framebuffer support"
	depends on FB && MX3_IPU
	select BACKLIGHT_CLASS_DEVICE
	select BACKLIGHT_LCD_SUPPORT
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	default y
	help
	  This is a framebuffer device for the i.MX31 LCD Controller. So
	  far only synchronous displays are supported. If you plan to use
	  an LCD display with your i.MX31 system, say Y here.

config FB_BROADSHEET
	tristate "E-Ink Broadsheet/Epson S1D13521 controller support"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	help
	  This driver implements support for the E-Ink Broadsheet
	  controller. The release name for this device was Epson S1D13521
	  and could also have been called by other names when coupled with
	  a bridge adapter.

config FB_AUO_K190X
	tristate "AUO-K190X EPD controller support"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	help
	  Provides support for epaper controllers from the K190X series
	  of AUO. These controllers can be used to drive epaper displays
	  from Sipix.

	  This option enables the common support, shared by the individual
	  controller drivers. You will also have to enable the driver
	  for the controller type used in your device.

config FB_AUO_K1900
	tristate "AUO-K1900 EPD controller support"
	depends on FB && FB_AUO_K190X
	help
	  This driver implements support for the AUO K1900 epd-controller.
	  This controller can drive Sipix epaper displays but can only do
	  serial updates, reducing the number of possible frames per second.

config FB_AUO_K1901
	tristate "AUO-K1901 EPD controller support"
	depends on FB && FB_AUO_K190X
	help
	  This driver implements support for the AUO K1901 epd-controller.
	  This controller can drive Sipix epaper displays and supports
	  concurrent updates, making higher frames per second possible.

config FB_JZ4740
	tristate "JZ4740 LCD framebuffer support"
	depends on FB && MACH_JZ4740
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	help
	  Framebuffer support for the JZ4740 SoC.

config FB_MXS
	tristate "MXS LCD framebuffer support"
	depends on FB && (ARCH_MXS || ARCH_MXC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  Framebuffer support for the MXS SoC.

config FB_PUV3_UNIGFX
	tristate "PKUnity v3 Unigfx framebuffer support"
	depends on FB && UNICORE32 && ARCH_PUV3
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	help
	  Choose this option if you want to use the Unigfx device as a
	  framebuffer device. Without the support of PCI & AGP.

config FB_HYPERV
	tristate "Microsoft Hyper-V Synthetic Video support"
	depends on FB && HYPERV
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This framebuffer driver supports Microsoft Hyper-V Synthetic Video.

config FB_SIMPLE
	bool "Simple framebuffer support"
	depends on (FB = y)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Say Y if you want support for a simple frame-buffer.

	  This driver assumes that the display hardware has been initialized
	  before the kernel boots, and the kernel will simply render to the
	  pre-allocated frame buffer surface.

	  Configuration re: surface address, size, and format must be provided
	  through device tree, or plain old platform data.

source "drivers/video/fbdev/omap/Kconfig"
source "drivers/video/fbdev/omap2/Kconfig"
source "drivers/video/fbdev/mmp/Kconfig"

config FB_SH_MOBILE_MERAM
	tristate "SuperH Mobile MERAM read ahead support"
	depends on (SUPERH || ARCH_SHMOBILE)
	select GENERIC_ALLOCATOR
	---help---
	  Enable MERAM support for the SuperH controller.

	  This will allow for caching of the framebuffer to provide more
	  reliable access under heavy main memory bus traffic situations.
	  Up to 4 memory channels can be configured, allowing 4 RGB or
	  2 YCbCr framebuffers to be configured.

config FB_SSD1307
	tristate "Solomon SSD1307 framebuffer support"
	depends on FB && I2C
	depends on OF
	depends on GPIOLIB || COMPILE_TEST
	select FB_SYS_FOPS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_DEFERRED_IO
	select PWM
	select FB_BACKLIGHT
	help
	  This driver implements support for the Solomon SSD1307
	  OLED controller over I2C.

config FB_SM712
	tristate "Silicon Motion SM712 framebuffer support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Frame buffer driver for the Silicon Motion SM710, SM712, SM721
	  and SM722 chips.

	  This driver is also available as a module. The module will be
	  called sm712fb. If you want to compile it as a module, say M
	  here and read <file:Documentation/kbuild/modules.txt>.

config FB_RPISENSE
	tristate "Raspberry Pi Sense HAT framebuffer"
	depends on FB
	select MFD_RPISENSE_CORE
	select FB_SYS_FOPS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_DEFERRED_IO

	help
	  This is the framebuffer driver for the Raspberry Pi Sense HAT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.
 * Copyright (c) 2004 Infinicon Corporation.  All rights reserved.
 * Copyright (c) 2004 Intel Corporation.  All rights reserved.
 * Copyright (c) 2004 Topspin Corporation.  All rights reserved.
 * Copyright (c) 2004 Voltaire Corporation.  All rights reserved.
 * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.
 * Copyright (c) 2005, 2006, 2007 Cisco Systems.  All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directory of this source tree, or the
 * OpenIB.org BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#if !defined(IB_VERBS_H)
#define IB_VERBS_H

#include <linux/types.h>
#include <linux/device.h>
#include <linux/mm.h>
#include <linux/dma-mapping.h>
#include <linux/kref.h>
#include <linux/list.h>
#include <linux/rwsem.h>
#include <linux/scatterlist.h>
#include <linux/workqueue.h>
#include <linux/socket.h>
#include <linux/irq_poll.h>
#include <uapi/linux/if_ether.h>
#include <net/ipv6.h>
#include <net/ip.h>
#include <linux/string.h>
#include <linux/slab.h>

#include <linux/if_link.h>
#include <linux/atomic.h>
#include <linux/mmu_notifier.h>
#include <asm/uaccess.h>

extern struct workqueue_struct *ib_wq;
extern struct workqueue_struct *ib_comp_wq;

union ib_gid {
	u8	raw[16];
	struct {
		__be64	subnet_prefix;
		__be64	interface_id;
	} global;
};

extern union ib_gid zgid;

enum ib_gid_type {
	/* If link layer is Ethernet, this is RoCE V1 */
	IB_GID_TYPE_IB        = 0,
	IB_GID_TYPE_ROCE      = 0,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 1,
	IB_GID_TYPE_SIZE
};

#define ROCE_V2_UDP_DPORT      4791
struct ib_gid_attr {
	enum ib_gid_type	gid_type;
	struct net_device	*ndev;
};

enum rdma_node_type {
	/* IB values map to NodeInfo:NodeType. */
	RDMA_NODE_IB_CA 	= 1,
	RDMA_NODE_IB_SWITCH,
	RDMA_NODE_IB_ROUTER,
	RDMA_NODE_RNIC,
	RDMA_NODE_USNIC,
	RDMA_NODE_USNIC_UDP,
};

enum {
	/* set the local administered indication */
	IB_SA_WELL_KNOWN_GUID	= BIT_ULL(57) | 2,
};

enum rdma_transport_type {
	RDMA_TRANSPORT_IB,
	RDMA_TRANSPORT_IWARP,
	RDMA_TRANSPORT_USNIC,
	RDMA_TRANSPORT_USNIC_UDP
};

enum rdma_protocol_type {
	RDMA_PROTOCOL_IB,
	RDMA_PROTOCOL_IBOE,
	RDMA_PROTOCOL_IWARP,
	RDMA_PROTOCOL_USNIC_UDP
};

__attribute_const__ enum rdma_transport_type
rdma_node_get_transport(enum rdma_node_type node_type);

enum rdma_network_type {
	RDMA_NETWORK_IB,
	RDMA_NETWORK_ROCE_V1 = RDMA_NETWORK_IB,
	RDMA_NETWORK_IPV4,
	RDMA_NETWORK_IPV6
};

static inline enum ib_gid_type ib_network_to_gid_type(enum rdma_network_type network_type)
{
	if (network_type == RDMA_NETWORK_IPV4 ||
	    network_type == RDMA_NETWORK_IPV6)
		return IB_GID_TYPE_ROCE_UDP_ENCAP;

	/* IB_GID_TYPE_IB same as RDMA_NETWORK_ROCE_V1 */
	return IB_GID_TYPE_IB;
}

static inline enum rdma_network_type ib_gid_to_network_type(enum ib_gid_type gid_type,
							    union ib_gid *gid)
{
	if (gid_type == IB_GID_TYPE_IB)
		return RDMA_NETWORK_IB;

	if (ipv6_addr_v4mapped((struct in6_addr *)gid))
		return RDMA_NETWORK_IPV4;
	else
		return RDMA_NETWORK_IPV6;
}

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED,
	IB_LINK_LAYER_INFINIBAND,
	IB_LINK_LAYER_ETHERNET,
};

enum ib_device_cap_flags {
	IB_DEVICE_RESIZE_MAX_WR			= (1 << 0),
	IB_DEVICE_BAD_PKEY_CNTR			= (1 << 1),
	IB_DEVICE_BAD_QKEY_CNTR			= (1 << 2),
	IB_DEVICE_RAW_MULTI			= (1 << 3),
	IB_DEVICE_AUTO_PATH_MIG			= (1 << 4),
	IB_DEVICE_CHANGE_PHY_PORT		= (1 << 5),
	IB_DEVICE_UD_AV_PORT_ENFORCE		= (1 << 6),
	IB_DEVICE_CURR_QP_STATE_MOD		= (1 << 7),
	IB_DEVICE_SHUTDOWN_PORT			= (1 << 8),
	IB_DEVICE_INIT_TYPE			= (1 << 9),
	IB_DEVICE_PORT_ACTIVE_EVENT		= (1 << 10),
	IB_DEVICE_SYS_IMAGE_GUID		= (1 << 11),
	IB_DEVICE_RC_RNR_NAK_GEN		= (1 << 12),
	IB_DEVICE_SRQ_RESIZE			= (1 << 13),
	IB_DEVICE_N_NOTIFY_CQ			= (1 << 14),

	/*
	 * This device supports a per-device lkey or stag that can be
	 * used without performing a memory registration for the local
	 * memory.  Note that ULPs should never check this flag, but
	 * instead of use the local_dma_lkey flag in the ib_pd structure,
	 * which will always contain a usable lkey.
	 */
	IB_DEVICE_LOCAL_DMA_LKEY		= (1 << 15),
	IB_DEVICE_RESERVED /* old SEND_W_INV */	= (1 << 16),
	IB_DEVICE_MEM_WINDOW			= (1 << 17),
	/*
	 * Devices should set IB_DEVICE_UD_IP_SUM if they support
	 * insertion of UDP and TCP checksum on outgoing UD IPoIB
	 * messages and can verify the validity of checksum for
	 * incoming messages.  Setting this flag implies that the
	 * IPoIB driver may set NETIF_F_IP_CSUM for datagram mode.
	 */
	IB_DEVICE_UD_IP_CSUM			= (1 << 18),
	IB_DEVICE_UD_TSO			= (1 << 19),
	IB_DEVICE_XRC				= (1 << 20),

	/*
	 * This device supports the IB "base memory management extension",
	 * which includes support for fast registrations (IB_WR_REG_MR,
	 * IB_WR_LOCAL_INV and IB_WR_SEND_WITH_INV verbs).  This flag should
	 * also be set by any iWarp device which must support FRs to comply
	 * to the iWarp verbs spec.  iWarp devices also support the
	 * IB_WR_RDMA_READ_WITH_INV verb for RDMA READs that invalidate the
	 * stag.
	 */
	IB_DEVICE_MEM_MGT_EXTENSIONS		= (1 << 21),
	IB_DEVICE_BLOCK_MULTICAST_LOOPBACK	= (1 << 22),
	IB_DEVICE_MEM_WINDOW_TYPE_2A		= (1 << 23),
	IB_DEVICE_MEM_WINDOW_TYPE_2B		= (1 << 24),
	IB_DEVICE_RC_IP_CSUM			= (1 << 25),
	IB_DEVICE_RAW_IP_CSUM			= (1 << 26),
	/*
	 * Devices should set IB_DEVICE_CROSS_CHANNEL if they
	 * support execution of WQEs that involve synchronization
	 * of I/O operations with single completion queue managed
	 * by hardware.
	 */
	IB_DEVICE_CROSS_CHANNEL		= (1 << 27),
	IB_DEVICE_MANAGED_FLOW_STEERING		= (1 << 29),
	IB_DEVICE_SIGNATURE_HANDOVER		= (1 << 30),
	IB_DEVICE_ON_DEMAND_PAGING		= (1ULL << 31),
	IB_DEVICE_SG_GAPS_REG			= (1ULL << 32),
	IB_DEVICE_VIRTUAL_FUNCTION		= (1ULL << 33),
	IB_DEVICE_RAW_SCATTER_FCS		= (1ULL << 34),
};

enum ib_signature_prot_cap {
	IB_PROT_T10DIF_TYPE_1 = 1,
	IB_PROT_T10DIF_TYPE_2 = 1 << 1,
	IB_PROT_T10DIF_TYPE_3 = 1 << 2,
};

enum ib_signature_guard_cap {
	IB_GUARD_T10DIF_CRC	= 1,
	IB_GUARD_T10DIF_CSUM	= 1 << 1,
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE,
	IB_ATOMIC_HCA,
	IB_ATOMIC_GLOB
};

enum ib_odp_general_cap_bits {
	IB_ODP_SUPPORT = 1 << 0,
};

enum ib_odp_transport_cap_bits {
	IB_ODP_SUPPORT_SEND	= 1 << 0,
	IB_ODP_SUPPORT_RECV	= 1 << 1,
	IB_ODP_SUPPORT_WRITE	= 1 << 2,
	IB_ODP_SUPPORT_READ	= 1 << 3,
	IB_ODP_SUPPORT_ATOMIC	= 1 << 4,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t  rc_odp_caps;
		uint32_t  uc_odp_caps;
		uint32_t  ud_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	/* Corresponding bit will be set if qp type from
	 * 'enum ib_qp_type' is supported, e.g.
	 * supported_qpts |= 1 << IB_QPT_UD
	 */
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

enum ib_cq_creation_flags {
	IB_CQ_FLAGS_TIMESTAMP_COMPLETION   = 1 << 0,
	IB_CQ_FLAGS_IGNORE_OVERRUN	   = 1 << 1,
};

struct ib_cq_init_attr {
	unsigned int	cqe;
	int		comp_vector;
	u32		flags;
};

struct ib_device_attr {
	u64			fw_ver;
	__be64			sys_image_guid;
	u64			max_mr_size;
	u64			page_size_cap;
	u32			vendor_id;
	u32			vendor_part_id;
	u32			hw_ver;
	int			max_qp;
	int			max_qp_wr;
	u64			device_cap_flags;
	int			max_sge;
	int			max_sge_rd;
	int			max_cq;
	int			max_cqe;
	int			max_mr;
	int			max_pd;
	int			max_qp_rd_atom;
	int			max_ee_rd_atom;
	int			max_res_rd_atom;
	int			max_qp_init_rd_atom;
	int			max_ee_init_rd_atom;
	enum ib_atomic_cap	atomic_cap;
	enum ib_atomic_cap	masked_atomic_cap;
	int			max_ee;
	int			max_rdd;
	int			max_mw;
	int			max_raw_ipv6_qp;
	int			max_raw_ethy_qp;
	int			max_mcast_grp;
	int			max_mcast_qp_attach;
	int			max_total_mcast_qp_attach;
	int			max_ah;
	int			max_fmr;
	int			max_map_per_fmr;
	int			max_srq;
	int			max_srq_wr;
	int			max_srq_sge;
	unsigned int		max_fast_reg_page_list_len;
	u16			max_pkeys;
	u8			local_ca_ack_delay;
	int			sig_prot_cap;
	int			sig_guard_cap;
	struct ib_odp_caps	odp_caps;
	uint64_t		timestamp_mask;
	uint64_t		hca_core_clock; /* in KHZ */
	struct ib_rss_caps	rss_caps;
	u32			max_wq_type_rq;
};

enum ib_mtu {
	IB_MTU_256  = 1,
	IB_MTU_512  = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5
};

static inline int ib_mtu_enum_to_int(enum ib_mtu mtu)
{
	switch (mtu) {
	case IB_MTU_256:  return  256;
	case IB_MTU_512:  return  512;
	case IB_MTU_1024: return 1024;
	case IB_MTU_2048: return 2048;
	case IB_MTU_4096: return 4096;
	default: 	  return -1;
	}
}

enum ib_port_state {
	IB_PORT_NOP		= 0,
	IB_PORT_DOWN		= 1,
	IB_PORT_INIT		= 2,
	IB_PORT_ARMED		= 3,
	IB_PORT_ACTIVE		= 4,
	IB_PORT_ACTIVE_DEFER	= 5
};

enum ib_port_cap_flags {
	IB_PORT_SM				= 1 <<  1,
	IB_PORT_NOTICE_SUP			= 1 <<  2,
	IB_PORT_TRAP_SUP			= 1 <<  3,
	IB_PORT_OPT_IPD_SUP                     = 1 <<  4,
	IB_PORT_AUTO_MIGR_SUP			= 1 <<  5,
	IB_PORT_SL_MAP_SUP			= 1 <<  6,
	IB_PORT_MKEY_NVRAM			= 1 <<  7,
	IB_PORT_PKEY_NVRAM			= 1 <<  8,
	IB_PORT_LED_INFO_SUP			= 1 <<  9,
	IB_PORT_SM_DISABLED			= 1 << 10,
	IB_PORT_SYS_IMAGE_GUID_SUP		= 1 << 11,
	IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP	= 1 << 12,
	IB_PORT_EXTENDED_SPEEDS_SUP             = 1 << 14,
	IB_PORT_CM_SUP				= 1 << 16,
	IB_PORT_SNMP_TUNNEL_SUP			= 1 << 17,
	IB_PORT_REINIT_SUP			= 1 << 18,
	IB_PORT_DEVICE_MGMT_SUP			= 1 << 19,
	IB_PORT_VENDOR_CLASS_SUP		= 1 << 20,
	IB_PORT_DR_NOTICE_SUP			= 1 << 21,
	IB_PORT_CAP_MASK_NOTICE_SUP		= 1 << 22,
	IB_PORT_BOOT_MGMT_SUP			= 1 << 23,
	IB_PORT_LINK_LATENCY_SUP		= 1 << 24,
	IB_PORT_CLIENT_REG_SUP			= 1 << 25,
	IB_PORT_IP_BASED_GIDS			= 1 << 26,
};

enum ib_port_width {
	IB_WIDTH_1X	= 1,
	IB_WIDTH_4X	= 2,
	IB_WIDTH_8X	= 4,
	IB_WIDTH_12X	= 8
};

static inline int ib_width_enum_to_int(enum ib_port_width width)
{
	switch (width) {
	case IB_WIDTH_1X:  return  1;
	case IB_WIDTH_4X:  return  4;
	case IB_WIDTH_8X:  return  8;
	case IB_WIDTH_12X: return 12;
	default: 	  return -1;
	}
}

enum ib_port_speed {
	IB_SPEED_SDR	= 1,
	IB_SPEED_DDR	= 2,
	IB_SPEED_QDR	= 4,
	IB_SPEED_FDR10	= 8,
	IB_SPEED_FDR	= 16,
	IB_SPEED_EDR	= 32
};

/**
 * struct rdma_hw_stats
 * @timestamp - Used by the core code to track when the last update was
 * @lifespan - Used by the core code to determine how old the counters
 *   should be before being updated again.  Stored in jiffies, defaults
 *   to 10 milliseconds, drivers can override the default be specifying
 *   their own value during their allocation routine.
 * @name - Array of pointers to static names used for the counters in
 *   directory.
 * @num_counters - How many hardware counters there are.  If name is
 *   shorter than this number, a kernel oops will result.  Driver authors
 *   are encouraged to leave BUILD_BUG_ON(ARRAY_SIZE(@name) < num_counters)
 *   in their code to prevent this.
 * @value - Array of u64 counters that are accessed by the sysfs code and
 *   filled in by the drivers get_stats routine
 */
struct rdma_hw_stats {
	unsigned long	timestamp;
	unsigned long	lifespan;
	const char * const *names;
	int		num_counters;
	u64		value[];
};

#define RDMA_HW_STATS_DEFAULT_LIFESPAN 10
/**
 * rdma_alloc_hw_stats_struct - Helper function to allocate dynamic struct
 *   for drivers.
 * @names - Array of static const char *
 * @num_counters - How many elements in array
 * @lifespan - How many milliseconds between updates
 */
static inline struct rdma_hw_stats *rdma_alloc_hw_stats_struct(
		const char * const *names, int num_counters,
		unsigned long lifespan)
{
	struct rdma_hw_stats *stats;

	stats = kzalloc(sizeof(*stats) + num_counters * sizeof(u64),
			GFP_KERNEL);
	if (!stats)
		return NULL;
	stats->names = names;
	stats->num_counters = num_counters;
	stats->lifespan = msecs_to_jiffies(lifespan);

	return stats;
}


/* Define bits for the various functionality this port needs to be supported by
 * the core.
 */
/* Management                           0x00000FFF */
#define RDMA_CORE_CAP_IB_MAD            0x00000001
#define RDMA_CORE_CAP_IB_SMI            0x00000002
#define RDMA_CORE_CAP_IB_CM             0x00000004
#define RDMA_CORE_CAP_IW_CM             0x00000008
#define RDMA_CORE_CAP_IB_SA             0x00000010
#define RDMA_CORE_CAP_OPA_MAD           0x00000020

/* Address format                       0x000FF000 */
#define RDMA_CORE_CAP_AF_IB             0x00001000
#define RDMA_CORE_CAP_ETH_AH            0x00002000

/* Protocol                             0xFFF00000 */
#define RDMA_CORE_CAP_PROT_IB           0x00100000
#define RDMA_CORE_CAP_PROT_ROCE         0x00200000
#define RDMA_CORE_CAP_PROT_IWARP        0x00400000
#define RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP 0x00800000

#define RDMA_CORE_PORT_IBA_IB          (RDMA_CORE_CAP_PROT_IB  \
					| RDMA_CORE_CAP_IB_MAD \
					| RDMA_CORE_CAP_IB_SMI \
					| RDMA_CORE_CAP_IB_CM  \
					| RDMA_CORE_CAP_IB_SA  \
					| RDMA_CORE_CAP_AF_IB)
#define RDMA_CORE_PORT_IBA_ROCE        (RDMA_CORE_CAP_PROT_ROCE \
					| RDMA_CORE_CAP_IB_MAD  \
					| RDMA_CORE_CAP_IB_CM   \
					| RDMA_CORE_CAP_AF_IB   \
					| RDMA_CORE_CAP_ETH_AH)
#define RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP			\
					(RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP \
					| RDMA_CORE_CAP_IB_MAD  \
					| RDMA_CORE_CAP_IB_CM   \
					| RDMA_CORE_CAP_AF_IB   \
					| RDMA_CORE_CAP_ETH_AH)
#define RDMA_CORE_PORT_IWARP           (RDMA_CORE_CAP_PROT_IWARP \
					| RDMA_CORE_CAP_IW_CM)
#define RDMA_CORE_PORT_INTEL_OPA       (RDMA_CORE_PORT_IBA_IB  \
					| RDMA_CORE_CAP_OPA_MAD)

struct ib_port_attr {
	u64			subnet_prefix;
	enum ib_port_state	state;
	enum ib_mtu		max_mtu;
	enum ib_mtu		active_mtu;
	int			gid_tbl_len;
	u32			port_cap_flags;
	u32			max_msg_sz;
	u32			bad_pkey_cntr;
	u32			qkey_viol_cntr;
	u16			pkey_tbl_len;
	u16			lid;
	u16			sm_lid;
	u8			lmc;
	u8			max_vl_num;
	u8			sm_sl;
	u8			subnet_timeout;
	u8			init_type_reply;
	u8			active_width;
	u8			active_speed;
	u8                      phys_state;
	bool			grh_required;
};

enum ib_device_modify_flags {
	IB_DEVICE_MODIFY_SYS_IMAGE_GUID	= 1 << 0,
	IB_DEVICE_MODIFY_NODE_DESC	= 1 << 1
};

#define IB_DEVICE_NODE_DESC_MAX 64

struct ib_device_modify {
	u64	sys_image_guid;
	char	node_desc[IB_DEVICE_NODE_DESC_MAX];
};

enum ib_port_modify_flags {
	IB_PORT_SHUTDOWN		= 1,
	IB_PORT_INIT_TYPE		= (1<<2),
	IB_PORT_RESET_QKEY_CNTR		= (1<<3)
};

struct ib_port_modify {
	u32	set_port_cap_mask;
	u32	clr_port_cap_mask;
	u8	init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR,
	IB_EVENT_QP_FATAL,
	IB_EVENT_QP_REQ_ERR,
	IB_EVENT_QP_ACCESS_ERR,
	IB_EVENT_COMM_EST,
	IB_EVENT_SQ_DRAINED,
	IB_EVENT_PATH_MIG,
	IB_EVENT_PATH_MIG_ERR,
	IB_EVENT_DEVICE_FATAL,
	IB_EVENT_PORT_ACTIVE,
	IB_EVENT_PORT_ERR,
	IB_EVENT_LID_CHANGE,
	IB_EVENT_PKEY_CHANGE,
	IB_EVENT_SM_CHANGE,
	IB_EVENT_SRQ_ERR,
	IB_EVENT_SRQ_LIMIT_REACHED,
	IB_EVENT_QP_LAST_WQE_REACHED,
	IB_EVENT_CLIENT_REREGISTER,
	IB_EVENT_GID_CHANGE,
	IB_EVENT_WQ_FATAL,
};

const char *__attribute_const__ ib_event_msg(enum ib_event_type event);

struct ib_event {
	struct ib_device	*device;
	union {
		struct ib_cq	*cq;
		struct ib_qp	*qp;
		struct ib_srq	*srq;
		struct ib_wq	*wq;
		u8		port_num;
	} element;
	enum ib_event_type	event;
};

struct ib_event_handler {
	struct ib_device *device;
	void            (*handler)(struct ib_event_handler *, struct ib_event *);
	struct list_head  list;
};

#define INIT_IB_EVENT_HANDLER(_ptr, _device, _handler)		\
	do {							\
		(_ptr)->device  = _device;			\
		(_ptr)->handler = _handler;			\
		INIT_LIST_HEAD(&(_ptr)->list);			\
	} while (0)

struct ib_global_route {
	union ib_gid	dgid;
	u32		flow_label;
	u8		sgid_index;
	u8		hop_limit;
	u8		traffic_class;
};

struct ib_grh {
	__be32		version_tclass_flow;
	__be16		paylen;
	u8		next_hdr;
	u8		hop_limit;
	union ib_gid	sgid;
	union ib_gid	dgid;
};

union rdma_network_hdr {
	struct ib_grh ibgrh;
	struct {
		/* The IB spec states that if it's IPv4, the header
		 * is located in the last 20 bytes of the header.
		 */
		u8		reserved[20];
		struct iphdr	roce4grh;
	};
};

enum {
	IB_MULTICAST_QPN = 0xffffff
};

#define IB_LID_PERMISSIVE	cpu_to_be16(0xFFFF)
#define IB_MULTICAST_LID_BASE	cpu_to_be16(0xC000)

enum ib_ah_flags {
	IB_AH_GRH	= 1
};

enum ib_rate {
	IB_RATE_PORT_CURRENT = 0,
	IB_RATE_2_5_GBPS = 2,
	IB_RATE_5_GBPS   = 5,
	IB_RATE_10_GBPS  = 3,
	IB_RATE_20_GBPS  = 6,
	IB_RATE_30_GBPS  = 4,
	IB_RATE_40_GBPS  = 7,
	IB_RATE_60_GBPS  = 8,
	IB_RATE_80_GBPS  = 9,
	IB_RATE_120_GBPS = 10,
	IB_RATE_14_GBPS  = 11,
	IB_RATE_56_GBPS  = 12,
	IB_RATE_112_GBPS = 13,
	IB_RATE_168_GBPS = 14,
	IB_RATE_25_GBPS  = 15,
	IB_RATE_100_GBPS = 16,
	IB_RATE_200_GBPS = 17,
	IB_RATE_300_GBPS = 18
};

/**
 * ib_rate_to_mult - Convert the IB rate enum to a multiple of the
 * base rate of 2.5 Gbit/sec.  For example, IB_RATE_5_GBPS will be
 * converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.
 * @rate: rate to convert.
 */
__attribute_const__ int ib_rate_to_mult(enum ib_rate rate);

/**
 * ib_rate_to_mbps - Convert the IB rate enum to Mbps.
 * For example, IB_RATE_2_5_GBPS will be converted to 2500.
 * @rate: rate to convert.
 */
__attribute_const__ int ib_rate_to_mbps(enum ib_rate rate);


/**
 * enum ib_mr_type - memory region type
 * @IB_MR_TYPE_MEM_REG:       memory region that is used for
 *                            normal registration
 * @IB_MR_TYPE_SIGNATURE:     memory region that is used for
 *                            signature operations (data-integrity
 *                            capable regions)
 * @IB_MR_TYPE_SG_GAPS:       memory region that is capable to
 *                            register any arbitrary sg lists (without
 *                            the normal mr constraints - see
 *                            ib_map_mr_sg)
 */
enum ib_mr_type {
	IB_MR_TYPE_MEM_REG,
	IB_MR_TYPE_SIGNATURE,
	IB_MR_TYPE_SG_GAPS,
};

/**
 * Signature types
 * IB_SIG_TYPE_NONE: Unprotected.
 * IB_SIG_TYPE_T10_DIF: Type T10-DIF
 */
enum ib_signature_type {
	IB_SIG_TYPE_NONE,
	IB_SIG_TYPE_T10_DIF,
};

/**
 * Signature T10-DIF block-guard types
 * IB_T10DIF_CRC: Corresponds to T10-PI mandated CRC checksum rules.
 * IB_T10DIF_CSUM: Corresponds to IP checksum rules.
 */
enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC,
	IB_T10DIF_CSUM
};

/**
 * struct ib_t10_dif_domain - Parameters specific for T10-DIF
 *     domain.
 * @bg_type: T10-DIF block guard type (CRC|CSUM)
 * @pi_interval: protection information interval.
 * @bg: seed of guard computation.
 * @app_tag: application tag of guard block
 * @ref_tag: initial guard block reference tag.
 * @ref_remap: Indicate wethear the reftag increments each block
 * @app_escape: Indicate to skip block check if apptag=0xffff
 * @ref_escape: Indicate to skip block check if reftag=0xffffffff
 * @apptag_check_mask: check bitmask of application tag.
 */
struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16			pi_interval;
	u16			bg;
	u16			app_tag;
	u32			ref_tag;
	bool			ref_remap;
	bool			app_escape;
	bool			ref_escape;
	u16			apptag_check_mask;
};

/**
 * struct ib_sig_domain - Parameters for signature domain
 * @sig_type: specific signauture type
 * @sig: union of all signature domain attributes that may
 *     be used to set domain layout.
 */
struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

/**
 * struct ib_sig_attrs - Parameters for signature handover operation
 * @check_mask: bitmask for signature byte check (8 bytes)
 * @mem: memory domain layout desciptor.
 * @wire: wire domain layout desciptor.
 */
struct ib_sig_attrs {
	u8			check_mask;
	struct ib_sig_domain	mem;
	struct ib_sig_domain	wire;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD,
	IB_SIG_BAD_REFTAG,
	IB_SIG_BAD_APPTAG,
};

/**
 * struct ib_sig_err - signature error descriptor
 */
struct ib_sig_err {
	enum ib_sig_err_type	err_type;
	u32			expected;
	u32			actual;
	u64			sig_err_offset;
	u32			key;
};

enum ib_mr_status_check {
	IB_MR_CHECK_SIG_STATUS = 1,
};

/**
 * struct ib_mr_status - Memory region status container
 *
 * @fail_status: Bitmask of MR checks status. For each
 *     failed check a corresponding status bit is set.
 * @sig_err: Additional info for IB_MR_CEHCK_SIG_STATUS
 *     failure.
 */
struct ib_mr_status {
	u32		    fail_status;
	struct ib_sig_err   sig_err;
};

/**
 * mult_to_ib_rate - Convert a multiple of 2.5 Gbit/sec to an IB rate
 * enum.
 * @mult: multiple to convert.
 */
__attribute_const__ enum ib_rate mult_to_ib_rate(int mult);

struct ib_ah_attr {
	struct ib_global_route	grh;
	u16			dlid;
	u8			sl;
	u8			src_path_bits;
	u8			static_rate;
	u8			ah_flags;
	u8			port_num;
	u8			dmac[ETH_ALEN];
};

enum ib_wc_status {
	IB_WC_SUCCESS,
	IB_WC_LOC_LEN_ERR,
	IB_WC_LOC_QP_OP_ERR,
	IB_WC_LOC_EEC_OP_ERR,
	IB_WC_LOC_PROT_ERR,
	IB_WC_WR_FLUSH_ERR,
	IB_WC_MW_BIND_ERR,
	IB_WC_BAD_RESP_ERR,
	IB_WC_LOC_ACCESS_ERR,
	IB_WC_REM_INV_REQ_ERR,
	IB_WC_REM_ACCESS_ERR,
	IB_WC_REM_OP_ERR,
	IB_WC_RETRY_EXC_ERR,
	IB_WC_RNR_RETRY_EXC_ERR,
	IB_WC_LOC_RDD_VIOL_ERR,
	IB_WC_REM_INV_RD_REQ_ERR,
	IB_WC_REM_ABORT_ERR,
	IB_WC_INV_EECN_ERR,
	IB_WC_INV_EEC_STATE_ERR,
	IB_WC_FATAL_ERR,
	IB_WC_RESP_TIMEOUT_ERR,
	IB_WC_GENERAL_ERR
};

const char *__attribute_const__ ib_wc_status_msg(enum ib_wc_status status);

enum ib_wc_opcode {
	IB_WC_SEND,
	IB_WC_RDMA_WRITE,
	IB_WC_RDMA_READ,
	IB_WC_COMP_SWAP,
	IB_WC_FETCH_ADD,
	IB_WC_LSO,
	IB_WC_LOCAL_INV,
	IB_WC_REG_MR,
	IB_WC_MASKED_COMP_SWAP,
	IB_WC_MASKED_FETCH_ADD,
/*
 * Set value of IB_WC_RECV so consumers can test if a completion is a
 * receive by testing (opcode & IB_WC_RECV).
 */
	IB_WC_RECV			= 1 << 7,
	IB_WC_RECV_RDMA_WITH_IMM
};

enum ib_wc_flags {
	IB_WC_GRH		= 1,
	IB_WC_WITH_IMM		= (1<<1),
	IB_WC_WITH_INVALIDATE	= (1<<2),
	IB_WC_IP_CSUM_OK	= (1<<3),
	IB_WC_WITH_SMAC		= (1<<4),
	IB_WC_WITH_VLAN		= (1<<5),
	IB_WC_WITH_NETWORK_HDR_TYPE	= (1<<6),
};

struct ib_wc {
	union {
		u64		wr_id;
		struct ib_cqe	*wr_cqe;
	};
	enum ib_wc_status	status;
	enum ib_wc_opcode	opcode;
	u32			vendor_err;
	u32			byte_len;
	struct ib_qp	       *qp;
	union {
		__be32		imm_data;
		u32		invalidate_rkey;
	} ex;
	u32			src_qp;
	int			wc_flags;
	u16			pkey_index;
	u16			slid;
	u8			sl;
	u8			dlid_path_bits;
	u8			port_num;	/* valid only for DR SMPs on switches */
	u8			smac[ETH_ALEN];
	u16			vlan_id;
	u8			network_hdr_type;
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED			= 1 << 0,
	IB_CQ_NEXT_COMP			= 1 << 1,
	IB_CQ_SOLICITED_MASK		= IB_CQ_SOLICITED | IB_CQ_NEXT_COMP,
	IB_CQ_REPORT_MISSED_EVENTS	= 1 << 2,
};

enum ib_srq_type {
	IB_SRQT_BASIC,
	IB_SRQT_XRC
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR	= 1 << 0,
	IB_SRQ_LIMIT	= 1 << 1,
};

struct ib_srq_attr {
	u32	max_wr;
	u32	max_sge;
	u32	srq_limit;
};

struct ib_srq_init_attr {
	void		      (*event_handler)(struct ib_event *, void *);
	void		       *srq_context;
	struct ib_srq_attr	attr;
	enum ib_srq_type	srq_type;

	union {
		struct {
			struct ib_xrcd *xrcd;
			struct ib_cq   *cq;
		} xrc;
	} ext;
};

struct ib_qp_cap {
	u32	max_send_wr;
	u32	max_recv_wr;
	u32	max_send_sge;
	u32	max_recv_sge;
	u32	max_inline_data;

	/*
	 * Maximum number of rdma_rw_ctx structures in flight at a time.
	 * ib_create_qp() will calculate the right amount of neededed WRs
	 * and MRs based on this.
	 */
	u32	max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR,
	IB_SIGNAL_REQ_WR
};

enum ib_qp_type {
	/*
	 * IB_QPT_SMI and IB_QPT_GSI have to be the first two entries
	 * here (and in that order) since the MAD layer uses them as
	 * indices into a 2-entry table.
	 */
	IB_QPT_SMI,
	IB_QPT_GSI,

	IB_QPT_RC,
	IB_QPT_UC,
	IB_QPT_UD,
	IB_QPT_RAW_IPV6,
	IB_QPT_RAW_ETHERTYPE,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT,
	IB_QPT_MAX,
	/* Reserve a range for qp types internal to the low level driver.
	 * These qp types will not be visible at the IB core layer, so the
	 * IB_QPT_MAX usages should not be affected in the core layer
	 */
	IB_QPT_RESERVED1 = 0x1000,
	IB_QPT_RESERVED2,
	IB_QPT_RESERVED3,
	IB_QPT_RESERVED4,
	IB_QPT_RESERVED5,
	IB_QPT_RESERVED6,
	IB_QPT_RESERVED7,
	IB_QPT_RESERVED8,
	IB_QPT_RESERVED9,
	IB_QPT_RESERVED10,
};

enum ib_qp_create_flags {
	IB_QP_CREATE_IPOIB_UD_LSO		= 1 << 0,
	IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK	= 1 << 1,
	IB_QP_CREATE_CROSS_CHANNEL              = 1 << 2,
	IB_QP_CREATE_MANAGED_SEND               = 1 << 3,
	IB_QP_CREATE_MANAGED_RECV               = 1 << 4,
	IB_QP_CREATE_NETIF_QP			= 1 << 5,
	IB_QP_CREATE_SIGNATURE_EN		= 1 << 6,
	IB_QP_CREATE_USE_GFP_NOIO		= 1 << 7,
	IB_QP_CREATE_SCATTER_FCS		= 1 << 8,
	/* reserve bits 26-31 for low level drivers' internal use */
	IB_QP_CREATE_RESERVED_START		= 1 << 26,
	IB_QP_CREATE_RESERVED_END		= 1 << 31,
};

/*
 * Note: users may not call ib_close_qp or ib_destroy_qp from the event_handler
 * callback to destroy the passed in QP.
 */

struct ib_qp_init_attr {
	void                  (*event_handler)(struct ib_event *, void *);
	void		       *qp_context;
	struct ib_cq	       *send_cq;
	struct ib_cq	       *recv_cq;
	struct ib_srq	       *srq;
	struct ib_xrcd	       *xrcd;     /* XRC TGT QPs only */
	struct ib_qp_cap	cap;
	enum ib_sig_type	sq_sig_type;
	enum ib_qp_type		qp_type;
	enum ib_qp_create_flags	create_flags;

	/*
	 * Only needed for special QP types, or when using the RW API.
	 */
	u8			port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
};

struct ib_qp_open_attr {
	void                  (*event_handler)(struct ib_event *, void *);
	void		       *qp_context;
	u32			qp_num;
	enum ib_qp_type		qp_type;
};

enum ib_rnr_timeout {
	IB_RNR_TIMER_655_36 =  0,
	IB_RNR_TIMER_000_01 =  1,
	IB_RNR_TIMER_000_02 =  2,
	IB_RNR_TIMER_000_03 =  3,
	IB_RNR_TIMER_000_04 =  4,
	IB_RNR_TIMER_000_06 =  5,
	IB_RNR_TIMER_000_08 =  6,
	IB_RNR_TIMER_000_12 =  7,
	IB_RNR_TIMER_000_16 =  8,
	IB_RNR_TIMER_000_24 =  9,
	IB_RNR_TIMER_000_32 = 10,
	IB_RNR_TIMER_000_48 = 11,
	IB_RNR_TIMER_000_64 = 12,
	IB_RNR_TIMER_000_96 = 13,
	IB_RNR_TIMER_001_28 = 14,
	IB_RNR_TIMER_001_92 = 15,
	IB_RNR_TIMER_002_56 = 16,
	IB_RNR_TIMER_003_84 = 17,
	IB_RNR_TIMER_005_12 = 18,
	IB_RNR_TIMER_007_68 = 19,
	IB_RNR_TIMER_010_24 = 20,
	IB_RNR_TIMER_015_36 = 21,
	IB_RNR_TIMER_020_48 = 22,
	IB_RNR_TIMER_030_72 = 23,
	IB_RNR_TIMER_040_96 = 24,
	IB_RNR_TIMER_061_44 = 25,
	IB_RNR_TIMER_081_92 = 26,
	IB_RNR_TIMER_122_88 = 27,
	IB_RNR_TIMER_163_84 = 28,
	IB_RNR_TIMER_245_76 = 29,
	IB_RNR_TIMER_327_68 = 30,
	IB_RNR_TIMER_491_52 = 31
};

enum ib_qp_attr_mask {
	IB_QP_STATE			= 1,
	IB_QP_CUR_STATE			= (1<<1),
	IB_QP_EN_SQD_ASYNC_NOTIFY	= (1<<2),
	IB_QP_ACCESS_FLAGS		= (1<<3),
	IB_QP_PKEY_INDEX		= (1<<4),
	IB_QP_PORT			= (1<<5),
	IB_QP_QKEY			= (1<<6),
	IB_QP_AV			= (1<<7),
	IB_QP_PATH_MTU			= (1<<8),
	IB_QP_TIMEOUT			= (1<<9),
	IB_QP_RETRY_CNT			= (1<<10),
	IB_QP_RNR_RETRY			= (1<<11),
	IB_QP_RQ_PSN			= (1<<12),
	IB_QP_MAX_QP_RD_ATOMIC		= (1<<13),
	IB_QP_ALT_PATH			= (1<<14),
	IB_QP_MIN_RNR_TIMER		= (1<<15),
	IB_QP_SQ_PSN			= (1<<16),
	IB_QP_MAX_DEST_RD_ATOMIC	= (1<<17),
	IB_QP_PATH_MIG_STATE		= (1<<18),
	IB_QP_CAP			= (1<<19),
	IB_QP_DEST_QPN			= (1<<20),
	IB_QP_RESERVED1			= (1<<21),
	IB_QP_RESERVED2			= (1<<22),
	IB_QP_RESERVED3			= (1<<23),
	IB_QP_RESERVED4			= (1<<24),
};

enum ib_qp_state {
	IB_QPS_RESET,
	IB_QPS_INIT,
	IB_QPS_RTR,
	IB_QPS_RTS,
	IB_QPS_SQD,
	IB_QPS_SQE,
	IB_QPS_ERR
};

enum ib_mig_state {
	IB_MIG_MIGRATED,
	IB_MIG_REARM,
	IB_MIG_ARMED
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2
};

struct ib_qp_attr {
	enum ib_qp_state	qp_state;
	enum ib_qp_state	cur_qp_state;
	enum ib_mtu		path_mtu;
	enum ib_mig_state	path_mig_state;
	u32			qkey;
	u32			rq_psn;
	u32			sq_psn;
	u32			dest_qp_num;
	int			qp_access_flags;
	struct ib_qp_cap	cap;
	struct ib_ah_attr	ah_attr;
	struct ib_ah_attr	alt_ah_attr;
	u16			pkey_index;
	u16			alt_pkey_index;
	u8			en_sqd_async_notify;
	u8			sq_draining;
	u8			max_rd_atomic;
	u8			max_dest_rd_atomic;
	u8			min_rnr_timer;
	u8			port_num;
	u8			timeout;
	u8			retry_cnt;
	u8			rnr_retry;
	u8			alt_port_num;
	u8			alt_timeout;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE,
	IB_WR_RDMA_WRITE_WITH_IMM,
	IB_WR_SEND,
	IB_WR_SEND_WITH_IMM,
	IB_WR_RDMA_READ,
	IB_WR_ATOMIC_CMP_AND_SWP,
	IB_WR_ATOMIC_FETCH_AND_ADD,
	IB_WR_LSO,
	IB_WR_SEND_WITH_INV,
	IB_WR_RDMA_READ_WITH_INV,
	IB_WR_LOCAL_INV,
	IB_WR_REG_MR,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD,
	IB_WR_REG_SIG_MR,
	/* reserve values for low level drivers' internal use.
	 * These values will not be used at all in the ib core layer.
	 */
	IB_WR_RESERVED1 = 0xf0,
	IB_WR_RESERVED2,
	IB_WR_RESERVED3,
	IB_WR_RESERVED4,
	IB_WR_RESERVED5,
	IB_WR_RESERVED6,
	IB_WR_RESERVED7,
	IB_WR_RESERVED8,
	IB_WR_RESERVED9,
	IB_WR_RESERVED10,
};

enum ib_send_flags {
	IB_SEND_FENCE		= 1,
	IB_SEND_SIGNALED	= (1<<1),
	IB_SEND_SOLICITED	= (1<<2),
	IB_SEND_INLINE		= (1<<3),
	IB_SEND_IP_CSUM		= (1<<4),

	/* reserve bits 26-31 for low level drivers' internal use */
	IB_SEND_RESERVED_START	= (1 << 26),
	IB_SEND_RESERVED_END	= (1 << 31),
};

struct ib_sge {
	u64	addr;
	u32	length;
	u32	lkey;
};

struct ib_cqe {
	void (*done)(struct ib_cq *cq, struct ib_wc *wc);
};

struct ib_send_wr {
	struct ib_send_wr      *next;
	union {
		u64		wr_id;
		struct ib_cqe	*wr_cqe;
	};
	struct ib_sge	       *sg_list;
	int			num_sge;
	enum ib_wr_opcode	opcode;
	int			send_flags;
	union {
		__be32		imm_data;
		u32		invalidate_rkey;
	} ex;
};

struct ib_rdma_wr {
	struct ib_send_wr	wr;
	u64			remote_addr;
	u32			rkey;
};

static inline struct ib_rdma_wr *rdma_wr(struct ib_send_wr *wr)
{
	return container_of(wr, struct ib_rdma_wr, wr);
}

struct ib_atomic_wr {
	struct ib_send_wr	wr;
	u64			remote_addr;
	u64			compare_add;
	u64			swap;
	u64			compare_add_mask;
	u64			swap_mask;
	u32			rkey;
};

static inline struct ib_atomic_wr *atomic_wr(struct ib_send_wr *wr)
{
	return container_of(wr, struct ib_atomic_wr, wr);
}

struct ib_ud_wr {
	struct ib_send_wr	wr;
	struct ib_ah		*ah;
	void			*header;
	int			hlen;
	int			mss;
	u32			remote_qpn;
	u32			remote_qkey;
	u16			pkey_index; /* valid for GSI only */
	u8			port_num;   /* valid for DR SMPs on switch only */
};

static inline struct ib_ud_wr *ud_wr(struct ib_send_wr *wr)
{
	return container_of(wr, struct ib_ud_wr, wr);
}

struct ib_reg_wr {
	struct ib_send_wr	wr;
	struct ib_mr		*mr;
	u32			key;
	int			access;
};

static inline struct ib_reg_wr *reg_wr(struct ib_send_wr *wr)
{
	return container_of(wr, struct ib_reg_wr, wr);
}

struct ib_sig_handover_wr {
	struct ib_send_wr	wr;
	struct ib_sig_attrs    *sig_attrs;
	struct ib_mr	       *sig_mr;
	int			access_flags;
	struct ib_sge	       *prot;
};

static inline struct ib_sig_handover_wr *sig_handover_wr(struct ib_send_wr *wr)
{
	return container_of(wr, struct ib_sig_handover_wr, wr);
}

struct ib_recv_wr {
	struct ib_recv_wr      *next;
	union {
		u64		wr_id;
		struct ib_cqe	*wr_cqe;
	};
	struct ib_sge	       *sg_list;
	int			num_sge;
};

enum ib_access_flags {
	IB_ACCESS_LOCAL_WRITE	= 1,
	IB_ACCESS_REMOTE_WRITE	= (1<<1),
	IB_ACCESS_REMOTE_READ	= (1<<2),
	IB_ACCESS_REMOTE_ATOMIC	= (1<<3),
	IB_ACCESS_MW_BIND	= (1<<4),
	IB_ZERO_BASED		= (1<<5),
	IB_ACCESS_ON_DEMAND     = (1<<6),
};

/*
 * XXX: these are apparently used for ->rereg_user_mr, no idea why they
 * are hidden here instead of a uapi header!
 */
enum ib_mr_rereg_flags {
	IB_MR_REREG_TRANS	= 1,
	IB_MR_REREG_PD		= (1<<1),
	IB_MR_REREG_ACCESS	= (1<<2),
	IB_MR_REREG_SUPPORTED	= ((IB_MR_REREG_ACCESS << 1) - 1)
};

struct ib_fmr_attr {
	int	max_pages;
	int	max_maps;
	u8	page_shift;
};

struct ib_umem;

struct ib_ucontext {
	struct ib_device       *device;
	struct list_head	pd_list;
	struct list_head	mr_list;
	struct list_head	mw_list;
	struct list_head	cq_list;
	struct list_head	qp_list;
	struct list_head	srq_list;
	struct list_head	ah_list;
	struct list_head	xrcd_list;
	struct list_head	rule_list;
	struct list_head	wq_list;
	struct list_head	rwq_ind_tbl_list;
	int			closing;

	struct pid             *tgid;
#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
	struct rb_root      umem_tree;
	/*
	 * Protects .umem_rbroot and tree, as well as odp_mrs_count and
	 * mmu notifiers registration.
	 */
	struct rw_semaphore	umem_rwsem;
	void (*invalidate_range)(struct ib_umem *umem,
				 unsigned long start, unsigned long end);

	struct mmu_notifier	mn;
	atomic_t		notifier_count;
	/* A list of umems that don't have private mmu notifier counters yet. */
	struct list_head	no_private_counters;
	int                     odp_mrs_count;
#endif
};

struct ib_uobject {
	u64			user_handle;	/* handle given to us by userspace */
	struct ib_ucontext     *context;	/* associated user context */
	void		       *object;		/* containing object */
	struct list_head	list;		/* link to context's list */
	int			id;		/* index into kernel idr */
	struct kref		ref;
	struct rw_semaphore	mutex;		/* protects .live */
	struct rcu_head		rcu;		/* kfree_rcu() overhead */
	int			live;
};

struct ib_udata {
	const void __user *inbuf;
	void __user *outbuf;
	size_t       inlen;
	size_t       outlen;
};

struct ib_pd {
	u32			local_dma_lkey;
	u32			flags;
	struct ib_device       *device;
	struct ib_uobject      *uobject;
	atomic_t          	usecnt; /* count all resources */

	u32			unsafe_global_rkey;

	/*
	 * Implementation details of the RDMA core, don't use in drivers:
	 */
	struct ib_mr	       *__internal_mr;
};

struct ib_xrcd {
	struct ib_device       *device;
	atomic_t		usecnt; /* count all exposed resources */
	struct inode	       *inode;

	struct mutex		tgt_qp_mutex;
	struct list_head	tgt_qp_list;
};

struct ib_ah {
	struct ib_device	*device;
	struct ib_pd		*pd;
	struct ib_uobject	*uobject;
};

typedef void (*ib_comp_handler)(struct ib_cq *cq, void *cq_context);

enum ib_poll_context {
	IB_POLL_DIRECT,		/* caller context, no hw completions */
	IB_POLL_SOFTIRQ,	/* poll from softirq context */
	IB_POLL_WORKQUEUE,	/* poll from workqueue */
};

struct ib_cq {
	struct ib_device       *device;
	struct ib_uobject      *uobject;
	ib_comp_handler   	comp_handler;
	void                  (*event_handler)(struct ib_event *, void *);
	void                   *cq_context;
	int               	cqe;
	atomic_t          	usecnt; /* count number of work queues */
	enum ib_poll_context	poll_ctx;
	struct ib_wc		*wc;
	union {
		struct irq_poll		iop;
		struct work_struct	work;
	};
};

struct ib_srq {
	struct ib_device       *device;
	struct ib_pd	       *pd;
	struct ib_uobject      *uobject;
	void		      (*event_handler)(struct ib_event *, void *);
	void		       *srq_context;
	enum ib_srq_type	srq_type;
	atomic_t		usecnt;

	union {
		struct {
			struct ib_xrcd *xrcd;
			struct ib_cq   *cq;
			u32		srq_num;
		} xrc;
	} ext;
};

enum ib_wq_type {
	IB_WQT_RQ
};

enum ib_wq_state {
	IB_WQS_RESET,
	IB_WQS_RDY,
	IB_WQS_ERR
};

struct ib_wq {
	struct ib_device       *device;
	struct ib_uobject      *uobject;
	void		    *wq_context;
	void		    (*event_handler)(struct ib_event *, void *);
	struct ib_pd	       *pd;
	struct ib_cq	       *cq;
	u32		wq_num;
	enum ib_wq_state       state;
	enum ib_wq_type	wq_type;
	atomic_t		usecnt;
};

struct ib_wq_init_attr {
	void		       *wq_context;
	enum ib_wq_type	wq_type;
	u32		max_wr;
	u32		max_sge;
	struct	ib_cq	       *cq;
	void		    (*event_handler)(struct ib_event *, void *);
};

enum ib_wq_attr_mask {
	IB_WQ_STATE	= 1 << 0,
	IB_WQ_CUR_STATE	= 1 << 1,
};

struct ib_wq_attr {
	enum	ib_wq_state	wq_state;
	enum	ib_wq_state	curr_wq_state;
};

struct ib_rwq_ind_table {
	struct ib_device	*device;
	struct ib_uobject      *uobject;
	atomic_t		usecnt;
	u32		ind_tbl_num;
	u32		log_ind_tbl_size;
	struct ib_wq	**ind_tbl;
};

struct ib_rwq_ind_table_init_attr {
	u32		log_ind_tbl_size;
	/* Each entry is a pointer to Receive Work Queue */
	struct ib_wq	**ind_tbl;
};

/*
 * @max_write_sge: Maximum SGE elements per RDMA WRITE request.
 * @max_read_sge:  Maximum SGE elements per RDMA READ request.
 */
struct ib_qp {
	struct ib_device       *device;
	struct ib_pd	       *pd;
	struct ib_cq	       *send_cq;
	struct ib_cq	       *recv_cq;
	spinlock_t		mr_lock;
	int			mrs_used;
	struct list_head	rdma_mrs;
	struct list_head	sig_mrs;
	struct ib_srq	       *srq;
	struct ib_xrcd	       *xrcd; /* XRC TGT QPs only */
	struct list_head	xrcd_list;

	/* count times opened, mcast attaches, flow attaches */
	atomic_t		usecnt;
	struct list_head	open_list;
	struct ib_qp           *real_qp;
	struct ib_uobject      *uobject;
	void                  (*event_handler)(struct ib_event *, void *);
	void		       *qp_context;
	u32			qp_num;
	u32			max_write_sge;
	u32			max_read_sge;
	enum ib_qp_type		qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
};

struct ib_mr {
	struct ib_device  *device;
	struct ib_pd	  *pd;
	u32		   lkey;
	u32		   rkey;
	u64		   iova;
	u32		   length;
	unsigned int	   page_size;
	bool		   need_inval;
	union {
		struct ib_uobject	*uobject;	/* user */
		struct list_head	qp_entry;	/* FR */
	};
};

struct ib_mw {
	struct ib_device	*device;
	struct ib_pd		*pd;
	struct ib_uobject	*uobject;
	u32			rkey;
	enum ib_mw_type         type;
};

struct ib_fmr {
	struct ib_device	*device;
	struct ib_pd		*pd;
	struct list_head	list;
	u32			lkey;
	u32			rkey;
};

/* Supported steering options */
enum ib_flow_attr_type {
	/* steering according to rule specifications */
	IB_FLOW_ATTR_NORMAL		= 0x0,
	/* default unicast and multicast rule -
	 * receive all Eth traffic which isn't steered to any QP
	 */
	IB_FLOW_ATTR_ALL_DEFAULT	= 0x1,
	/* default multicast rule -
	 * receive all Eth multicast traffic which isn't steered to any QP
	 */
	IB_FLOW_ATTR_MC_DEFAULT		= 0x2,
	/* sniffer rule - receive all port traffic */
	IB_FLOW_ATTR_SNIFFER		= 0x3
};

/* Supported steering header types */
enum ib_flow_spec_type {
	/* L2 headers*/
	IB_FLOW_SPEC_ETH	= 0x20,
	IB_FLOW_SPEC_IB		= 0x22,
	/* L3 header*/
	IB_FLOW_SPEC_IPV4	= 0x30,
	IB_FLOW_SPEC_IPV6	= 0x31,
	/* L4 headers*/
	IB_FLOW_SPEC_TCP	= 0x40,
	IB_FLOW_SPEC_UDP	= 0x41
};
#define IB_FLOW_SPEC_LAYER_MASK	0xF0
#define IB_FLOW_SPEC_SUPPORT_LAYERS 4

/* Flow steering rule priority is set according to it's domain.
 * Lower domain value means higher priority.
 */
enum ib_flow_domain {
	IB_FLOW_DOMAIN_USER,
	IB_FLOW_DOMAIN_ETHTOOL,
	IB_FLOW_DOMAIN_RFS,
	IB_FLOW_DOMAIN_NIC,
	IB_FLOW_DOMAIN_NUM /* Must be last */
};

enum ib_flow_flags {
	IB_FLOW_ATTR_FLAGS_DONT_TRAP = 1UL << 1, /* Continue match, no steal */
	IB_FLOW_ATTR_FLAGS_RESERVED  = 1UL << 2  /* Must be last */
};

struct ib_flow_eth_filter {
	u8	dst_mac[6];
	u8	src_mac[6];
	__be16	ether_type;
	__be16	vlan_tag;
	/* Must be last */
	u8	real_sz[0];
};

struct ib_flow_spec_eth {
	enum ib_flow_spec_type	  type;
	u16			  size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8   sl;
	/* Must be last */
	u8	real_sz[0];
};

struct ib_flow_spec_ib {
	enum ib_flow_spec_type	 type;
	u16			 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

/* IPv4 header flags */
enum ib_ipv4_flags {
	IB_IPV4_DONT_FRAG = 0x2, /* Don't enable packet fragmentation */
	IB_IPV4_MORE_FRAG = 0X4  /* For All fragmented packets except the
				    last have this flag set */
};

struct ib_flow_ipv4_filter {
	__be32	src_ip;
	__be32	dst_ip;
	u8	proto;
	u8	tos;
	u8	ttl;
	u8	flags;
	/* Must be last */
	u8	real_sz[0];
};

struct ib_flow_spec_ipv4 {
	enum ib_flow_spec_type	   type;
	u16			   size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8	src_ip[16];
	u8	dst_ip[16];
	__be32	flow_label;
	u8	next_hdr;
	u8	traffic_class;
	u8	hop_limit;
	/* Must be last */
	u8	real_sz[0];
};

struct ib_flow_spec_ipv6 {
	enum ib_flow_spec_type	   type;
	u16			   size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16	dst_port;
	__be16	src_port;
	/* Must be last */
	u8	real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	enum ib_flow_spec_type	      type;
	u16			      size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

union ib_flow_spec {
	struct {
		enum ib_flow_spec_type	type;
		u16			size;
	};
	struct ib_flow_spec_eth		eth;
	struct ib_flow_spec_ib		ib;
	struct ib_flow_spec_ipv4        ipv4;
	struct ib_flow_spec_tcp_udp	tcp_udp;
	struct ib_flow_spec_ipv6        ipv6;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16	     size;
	u16	     priority;
	u32	     flags;
	u8	     num_of_specs;
	u8	     port;
	/* Following are the optional layers according to user request
	 * struct ib_flow_spec_xxx
	 * struct ib_flow_spec_yyy
	 */
};

struct ib_flow {
	struct ib_qp		*qp;
	struct ib_uobject	*uobject;
};

struct ib_mad_hdr;
struct ib_grh;

enum ib_process_mad_flags {
	IB_MAD_IGNORE_MKEY	= 1,
	IB_MAD_IGNORE_BKEY	= 2,
	IB_MAD_IGNORE_ALL	= IB_MAD_IGNORE_MKEY | IB_MAD_IGNORE_BKEY
};

enum ib_mad_result {
	IB_MAD_RESULT_FAILURE  = 0,      /* (!SUCCESS is the important flag) */
	IB_MAD_RESULT_SUCCESS  = 1 << 0, /* MAD was successfully processed   */
	IB_MAD_RESULT_REPLY    = 1 << 1, /* Reply packet needs to be sent    */
	IB_MAD_RESULT_CONSUMED = 1 << 2  /* Packet consumed: stop processing */
};

#define IB_DEVICE_NAME_MAX 64

struct ib_cache {
	rwlock_t                lock;
	struct ib_event_handler event_handler;
	struct ib_pkey_cache  **pkey_cache;
	struct ib_gid_table   **gid_cache;
	u8                     *lmc_cache;
};

struct ib_dma_mapping_ops {
	int		(*mapping_error)(struct ib_device *dev,
					 u64 dma_addr);
	u64		(*map_single)(struct ib_device *dev,
				      void *ptr, size_t size,
				      enum dma_data_direction direction);
	void		(*unmap_single)(struct ib_device *dev,
					u64 addr, size_t size,
					enum dma_data_direction direction);
	u64		(*map_page)(struct ib_device *dev,
				    struct page *page, unsigned long offset,
				    size_t size,
				    enum dma_data_direction direction);
	void		(*unmap_page)(struct ib_device *dev,
				      u64 addr, size_t size,
				      enum dma_data_direction direction);
	int		(*map_sg)(struct ib_device *dev,
				  struct scatterlist *sg, int nents,
				  enum dma_data_direction direction);
	void		(*unmap_sg)(struct ib_device *dev,
				    struct scatterlist *sg, int nents,
				    enum dma_data_direction direction);
	int		(*map_sg_attrs)(struct ib_device *dev,
					struct scatterlist *sg, int nents,
					enum dma_data_direction direction,
					unsigned long attrs);
	void		(*unmap_sg_attrs)(struct ib_device *dev,
					  struct scatterlist *sg, int nents,
					  enum dma_data_direction direction,
					  unsigned long attrs);
	void		(*sync_single_for_cpu)(struct ib_device *dev,
					       u64 dma_handle,
					       size_t size,
					       enum dma_data_direction dir);
	void		(*sync_single_for_device)(struct ib_device *dev,
						  u64 dma_handle,
						  size_t size,
						  enum dma_data_direction dir);
	void		*(*alloc_coherent)(struct ib_device *dev,
					   size_t size,
					   u64 *dma_handle,
					   gfp_t flag);
	void		(*free_coherent)(struct ib_device *dev,
					 size_t size, void *cpu_addr,
					 u64 dma_handle);
};

struct iw_cm_verbs;

struct ib_port_immutable {
	int                           pkey_tbl_len;
	int                           gid_tbl_len;
	u32                           core_cap_flags;
	u32                           max_mad_size;
};

struct ib_device {
	struct device                *dma_device;

	char                          name[IB_DEVICE_NAME_MAX];

	struct list_head              event_handler_list;
	spinlock_t                    event_handler_lock;

	spinlock_t                    client_data_lock;
	struct list_head              core_list;
	/* Access to the client_data_list is protected by the client_data_lock
	 * spinlock and the lists_rwsem read-write semaphore */
	struct list_head              client_data_list;

	struct ib_cache               cache;
	/**
	 * port_immutable is indexed by port number
	 */
	struct ib_port_immutable     *port_immutable;

	int			      num_comp_vectors;

	struct iw_cm_verbs	     *iwcm;

	/**
	 * alloc_hw_stats - Allocate a struct rdma_hw_stats and fill in the
	 *   driver initialized data.  The struct is kfree()'ed by the sysfs
	 *   core when the device is removed.  A lifespan of -1 in the return
	 *   struct tells the core to set a default lifespan.
	 */
	struct rdma_hw_stats      *(*alloc_hw_stats)(struct ib_device *device,
						     u8 port_num);
	/**
	 * get_hw_stats - Fill in the counter value(s) in the stats struct.
	 * @index - The index in the value array we wish to have updated, or
	 *   num_counters if we want all stats updated
	 * Return codes -
	 *   < 0 - Error, no counters updated
	 *   index - Updated the single counter pointed to by index
	 *   num_counters - Updated all counters (will reset the timestamp
	 *     and prevent further calls for lifespan milliseconds)
	 * Drivers are allowed to update all counters in leiu of just the
	 *   one given in index at their option
	 */
	int		           (*get_hw_stats)(struct ib_device *device,
						   struct rdma_hw_stats *stats,
						   u8 port, int index);
	int		           (*query_device)(struct ib_device *device,
						   struct ib_device_attr *device_attr,
						   struct ib_udata *udata);
	int		           (*query_port)(struct ib_device *device,
						 u8 port_num,
						 struct ib_port_attr *port_attr);
	enum rdma_link_layer	   (*get_link_layer)(struct ib_device *device,
						     u8 port_num);
	/* When calling get_netdev, the HW vendor's driver should return the
	 * net device of device @device at port @port_num or NULL if such
	 * a net device doesn't exist. The vendor driver should call dev_hold
	 * on this net device. The HW vendor's device driver must guarantee
	 * that this function returns NULL before the net device reaches
	 * NETDEV_UNREGISTER_FINAL state.
	 */
	struct net_device	  *(*get_netdev)(struct ib_device *device,
						 u8 port_num);
	int		           (*query_gid)(struct ib_device *device,
						u8 port_num, int index,
						union ib_gid *gid);
	/* When calling add_gid, the HW vendor's driver should
	 * add the gid of device @device at gid index @index of
	 * port @port_num to be @gid. Meta-info of that gid (for example,
	 * the network device related to this gid is available
	 * at @attr. @context allows the HW vendor driver to store extra
	 * information together with a GID entry. The HW vendor may allocate
	 * memory to contain this information and store it in @context when a
	 * new GID entry is written to. Params are consistent until the next
	 * call of add_gid or delete_gid. The function should return 0 on
	 * success or error otherwise. The function could be called
	 * concurrently for different ports. This function is only called
	 * when roce_gid_table is used.
	 */
	int		           (*add_gid)(struct ib_device *device,
					      u8 port_num,
					      unsigned int index,
					      const union ib_gid *gid,
					      const struct ib_gid_attr *attr,
					      void **context);
	/* When calling del_gid, the HW vendor's driver should delete the
	 * gid of device @device at gid index @index of port @port_num.
	 * Upon the deletion of a GID entry, the HW vendor must free any
	 * allocated memory. The caller will clear @context afterwards.
	 * This function is only called when roce_gid_table is used.
	 */
	int		           (*del_gid)(struct ib_device *device,
					      u8 port_num,
					      unsigned int index,
					      void **context);
	int		           (*query_pkey)(struct ib_device *device,
						 u8 port_num, u16 index, u16 *pkey);
	int		           (*modify_device)(struct ib_device *device,
						    int device_modify_mask,
						    struct ib_device_modify *device_modify);
	int		           (*modify_port)(struct ib_device *device,
						  u8 port_num, int port_modify_mask,
						  struct ib_port_modify *port_modify);
	struct ib_ucontext *       (*alloc_ucontext)(struct ib_device *device,
						     struct ib_udata *udata);
	int                        (*dealloc_ucontext)(struct ib_ucontext *context);
	int                        (*mmap)(struct ib_ucontext *context,
					   struct vm_area_struct *vma);
	struct ib_pd *             (*alloc_pd)(struct ib_device *device,
					       struct ib_ucontext *context,
					       struct ib_udata *udata);
	int                        (*dealloc_pd)(struct ib_pd *pd);
	struct ib_ah *             (*create_ah)(struct ib_pd *pd,
						struct ib_ah_attr *ah_attr);
	int                        (*modify_ah)(struct ib_ah *ah,
						struct ib_ah_attr *ah_attr);
	int                        (*query_ah)(struct ib_ah *ah,
					       struct ib_ah_attr *ah_attr);
	int                        (*destroy_ah)(struct ib_ah *ah);
	struct ib_srq *            (*create_srq)(struct ib_pd *pd,
						 struct ib_srq_init_attr *srq_init_attr,
						 struct ib_udata *udata);
	int                        (*modify_srq)(struct ib_srq *srq,
						 struct ib_srq_attr *srq_attr,
						 enum ib_srq_attr_mask srq_attr_mask,
						 struct ib_udata *udata);
	int                        (*query_srq)(struct ib_srq *srq,
						struct ib_srq_attr *srq_attr);
	int                        (*destroy_srq)(struct ib_srq *srq);
	int                        (*post_srq_recv)(struct ib_srq *srq,
						    struct ib_recv_wr *recv_wr,
						    struct ib_recv_wr **bad_recv_wr);
	struct ib_qp *             (*create_qp)(struct ib_pd *pd,
						struct ib_qp_init_attr *qp_init_attr,
						struct ib_udata *udata);
	int                        (*modify_qp)(struct ib_qp *qp,
						struct ib_qp_attr *qp_attr,
						int qp_attr_mask,
						struct ib_udata *udata);
	int                        (*query_qp)(struct ib_qp *qp,
					       struct ib_qp_attr *qp_attr,
					       int qp_attr_mask,
					       struct ib_qp_init_attr *qp_init_attr);
	int                        (*destroy_qp)(struct ib_qp *qp);
	int                        (*post_send)(struct ib_qp *qp,
						struct ib_send_wr *send_wr,
						struct ib_send_wr **bad_send_wr);
	int                        (*post_recv)(struct ib_qp *qp,
						struct ib_recv_wr *recv_wr,
						struct ib_recv_wr **bad_recv_wr);
	struct ib_cq *             (*create_cq)(struct ib_device *device,
						const struct ib_cq_init_attr *attr,
						struct ib_ucontext *context,
						struct ib_udata *udata);
	int                        (*modify_cq)(struct ib_cq *cq, u16 cq_count,
						u16 cq_period);
	int                        (*destroy_cq)(struct ib_cq *cq);
	int                        (*resize_cq)(struct ib_cq *cq, int cqe,
						struct ib_udata *udata);
	int                        (*poll_cq)(struct ib_cq *cq, int num_entries,
					      struct ib_wc *wc);
	int                        (*peek_cq)(struct ib_cq *cq, int wc_cnt);
	int                        (*req_notify_cq)(struct ib_cq *cq,
						    enum ib_cq_notify_flags flags);
	int                        (*req_ncomp_notif)(struct ib_cq *cq,
						      int wc_cnt);
	struct ib_mr *             (*get_dma_mr)(struct ib_pd *pd,
						 int mr_access_flags);
	struct ib_mr *             (*reg_user_mr)(struct ib_pd *pd,
						  u64 start, u64 length,
						  u64 virt_addr,
						  int mr_access_flags,
						  struct ib_udata *udata);
	int			   (*rereg_user_mr)(struct ib_mr *mr,
						    int flags,
						    u64 start, u64 length,
						    u64 virt_addr,
						    int mr_access_flags,
						    struct ib_pd *pd,
						    struct ib_udata *udata);
	int                        (*dereg_mr)(struct ib_mr *mr);
	struct ib_mr *		   (*alloc_mr)(struct ib_pd *pd,
					       enum ib_mr_type mr_type,
					       u32 max_num_sg);
	int                        (*map_mr_sg)(struct ib_mr *mr,
						struct scatterlist *sg,
						int sg_nents,
						unsigned int *sg_offset);
	struct ib_mw *             (*alloc_mw)(struct ib_pd *pd,
					       enum ib_mw_type type,
					       struct ib_udata *udata);
	int                        (*dealloc_mw)(struct ib_mw *mw);
	struct ib_fmr *	           (*alloc_fmr)(struct ib_pd *pd,
						int mr_access_flags,
						struct ib_fmr_attr *fmr_attr);
	int		           (*map_phys_fmr)(struct ib_fmr *fmr,
						   u64 *page_list, int list_len,
						   u64 iova);
	int		           (*unmap_fmr)(struct list_head *fmr_list);
	int		           (*dealloc_fmr)(struct ib_fmr *fmr);
	int                        (*attach_mcast)(struct ib_qp *qp,
						   union ib_gid *gid,
						   u16 lid);
	int                        (*detach_mcast)(struct ib_qp *qp,
						   union ib_gid *gid,
						   u16 lid);
	int                        (*process_mad)(struct ib_device *device,
						  int process_mad_flags,
						  u8 port_num,
						  const struct ib_wc *in_wc,
						  const struct ib_grh *in_grh,
						  const struct ib_mad_hdr *in_mad,
						  size_t in_mad_size,
						  struct ib_mad_hdr *out_mad,
						  size_t *out_mad_size,
						  u16 *out_mad_pkey_index);
	struct ib_xrcd *	   (*alloc_xrcd)(struct ib_device *device,
						 struct ib_ucontext *ucontext,
						 struct ib_udata *udata);
	int			   (*dealloc_xrcd)(struct ib_xrcd *xrcd);
	struct ib_flow *	   (*create_flow)(struct ib_qp *qp,
						  struct ib_flow_attr
						  *flow_attr,
						  int domain);
	int			   (*destroy_flow)(struct ib_flow *flow_id);
	int			   (*check_mr_status)(struct ib_mr *mr, u32 check_mask,
						      struct ib_mr_status *mr_status);
	void			   (*disassociate_ucontext)(struct ib_ucontext *ibcontext);
	void			   (*drain_rq)(struct ib_qp *qp);
	void			   (*drain_sq)(struct ib_qp *qp);
	int			   (*set_vf_link_state)(struct ib_device *device, int vf, u8 port,
							int state);
	int			   (*get_vf_config)(struct ib_device *device, int vf, u8 port,
						   struct ifla_vf_info *ivf);
	int			   (*get_vf_stats)(struct ib_device *device, int vf, u8 port,
						   struct ifla_vf_stats *stats);
	int			   (*set_vf_guid)(struct ib_device *device, int vf, u8 port, u64 guid,
						  int type);
	struct ib_wq *		   (*create_wq)(struct ib_pd *pd,
						struct ib_wq_init_attr *init_attr,
						struct ib_udata *udata);
	int			   (*destroy_wq)(struct ib_wq *wq);
	int			   (*modify_wq)(struct ib_wq *wq,
						struct ib_wq_attr *attr,
						u32 wq_attr_mask,
						struct ib_udata *udata);
	struct ib_rwq_ind_table *  (*create_rwq_ind_table)(struct ib_device *device,
							   struct ib_rwq_ind_table_init_attr *init_attr,
							   struct ib_udata *udata);
	int                        (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *wq_ind_table);
	struct ib_dma_mapping_ops   *dma_ops;

	struct module               *owner;
	struct device                dev;
	struct kobject               *ports_parent;
	struct list_head             port_list;

	enum {
		IB_DEV_UNINITIALIZED,
		IB_DEV_REGISTERED,
		IB_DEV_UNREGISTERED
	}                            reg_state;

	int			     uverbs_abi_ver;
	u64			     uverbs_cmd_mask;
	u64			     uverbs_ex_cmd_mask;

	char			     node_desc[IB_DEVICE_NODE_DESC_MAX];
	__be64			     node_guid;
	u32			     local_dma_lkey;
	u16                          is_switch:1;
	u8                           node_type;
	u8                           phys_port_cnt;
	struct ib_device_attr        attrs;
	struct attribute_group	     *hw_stats_ag;
	struct rdma_hw_stats         *hw_stats;

	/**
	 * The following mandatory functions are used only at device
	 * registration.  Keep functions such as these at the end of this
	 * structure to avoid cache line misses when accessing struct ib_device
	 * in fast paths.
	 */
	int (*get_port_immutable)(struct ib_device *, u8, struct ib_port_immutable *);
	void (*get_dev_fw_str)(struct ib_device *, char *str, size_t str_len);
};

struct ib_client {
	char  *name;
	void (*add)   (struct ib_device *);
	void (*remove)(struct ib_device *, void *client_data);

	/* Returns the net_dev belonging to this ib_client and matching the
	 * given parameters.
	 * @dev:	 An RDMA device that the net_dev use for communication.
	 * @port:	 A physical port number on the RDMA device.
	 * @pkey:	 P_Key that the net_dev uses if applicable.
	 * @gid:	 A GID that the net_dev uses to communicate.
	 * @addr:	 An IP address the net_dev is configured with.
	 * @client_data: The device's client data set by ib_set_client_data().
	 *
	 * An ib_client that implements a net_dev on top of RDMA devices
	 * (such as IP over IB) should implement this callback, allowing the
	 * rdma_cm module to find the right net_dev for a given request.
	 *
	 * The caller is responsible for calling dev_put on the returned
	 * netdev. */
	struct net_device *(*get_net_dev_by_params)(
			struct ib_device *dev,
			u8 port,
			u16 pkey,
			const union ib_gid *gid,
			const struct sockaddr *addr,
			void *client_data);
	struct list_head list;
};

struct ib_device *ib_alloc_device(size_t size);
void ib_dealloc_device(struct ib_device *device);

void ib_get_device_fw_str(struct ib_device *device, char *str, size_t str_len);

int ib_register_device(struct ib_device *device,
		       int (*port_callback)(struct ib_device *,
					    u8, struct kobject *));
void ib_unregister_device(struct ib_device *device);

int ib_register_client   (struct ib_client *client);
void ib_unregister_client(struct ib_client *client);

void *ib_get_client_data(struct ib_device *device, struct ib_client *client);
void  ib_set_client_data(struct ib_device *device, struct ib_client *client,
			 void *data);

static inline int ib_copy_from_udata(void *dest, struct ib_udata *udata, size_t len)
{
	return copy_from_user(dest, udata->inbuf, len) ? -EFAULT : 0;
}

static inline int ib_copy_to_udata(struct ib_udata *udata, void *src, size_t len)
{
	return copy_to_user(udata->outbuf, src, len) ? -EFAULT : 0;
}

static inline bool ib_is_udata_cleared(struct ib_udata *udata,
				       size_t offset,
				       size_t len)
{
	const void __user *p = udata->inbuf + offset;
	bool ret;
	u8 *buf;

	if (len > USHRT_MAX)
		return false;

	buf = memdup_user(p, len);
	if (IS_ERR(buf))
		return false;

	ret = !memchr_inv(buf, 0, len);
	kfree(buf);
	return ret;
}

/**
 * ib_modify_qp_is_ok - Check that the supplied attribute mask
 * contains all required attributes and no attributes not allowed for
 * the given QP state transition.
 * @cur_state: Current QP state
 * @next_state: Next QP state
 * @type: QP type
 * @mask: Mask of supplied QP attributes
 * @ll : link layer of port
 *
 * This function is a helper function that a low-level driver's
 * modify_qp method can use to validate the consumer's input.  It
 * checks that cur_state and next_state are valid QP states, that a
 * transition from cur_state to next_state is allowed by the IB spec,
 * and that the attribute mask supplied is allowed for the transition.
 */
int ib_modify_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state next_state,
		       enum ib_qp_type type, enum ib_qp_attr_mask mask,
		       enum rdma_link_layer ll);

int ib_register_event_handler  (struct ib_event_handler *event_handler);
int ib_unregister_event_handler(struct ib_event_handler *event_handler);
void ib_dispatch_event(struct ib_event *event);

int ib_query_port(struct ib_device *device,
		  u8 port_num, struct ib_port_attr *port_attr);

enum rdma_link_layer rdma_port_get_link_layer(struct ib_device *device,
					       u8 port_num);

/**
 * rdma_cap_ib_switch - Check if the device is IB switch
 * @device: Device to check
 *
 * Device driver is responsible for setting is_switch bit on
 * in ib_device structure at init time.
 *
 * Return: true if the device is IB switch.
 */
static inline bool rdma_cap_ib_switch(const struct ib_device *device)
{
	return device->is_switch;
}

/**
 * rdma_start_port - Return the first valid port number for the device
 * specified
 *
 * @device: Device to be checked
 *
 * Return start port number
 */
static inline u8 rdma_start_port(const struct ib_device *device)
{
	return rdma_cap_ib_switch(device) ? 0 : 1;
}

/**
 * rdma_end_port - Return the last valid port number for the device
 * specified
 *
 * @device: Device to be checked
 *
 * Return last port number
 */
static inline u8 rdma_end_port(const struct ib_device *device)
{
	return rdma_cap_ib_switch(device) ? 0 : device->phys_port_cnt;
}

static inline bool rdma_protocol_ib(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_PROT_IB;
}

static inline bool rdma_protocol_roce(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags &
		(RDMA_CORE_CAP_PROT_ROCE | RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP);
}

static inline bool rdma_protocol_roce_udp_encap(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP;
}

static inline bool rdma_protocol_roce_eth_encap(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_PROT_ROCE;
}

static inline bool rdma_protocol_iwarp(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_PROT_IWARP;
}

static inline bool rdma_ib_or_roce(const struct ib_device *device, u8 port_num)
{
	return rdma_protocol_ib(device, port_num) ||
		rdma_protocol_roce(device, port_num);
}

/**
 * rdma_cap_ib_mad - Check if the port of a device supports Infiniband
 * Management Datagrams.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * Management Datagrams (MAD) are a required part of the InfiniBand
 * specification and are supported on all InfiniBand devices.  A slightly
 * extended version are also supported on OPA interfaces.
 *
 * Return: true if the port supports sending/receiving of MAD packets.
 */
static inline bool rdma_cap_ib_mad(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_IB_MAD;
}

/**
 * rdma_cap_opa_mad - Check if the port of device provides support for OPA
 * Management Datagrams.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * Intel OmniPath devices extend and/or replace the InfiniBand Management
 * datagrams with their own versions.  These OPA MADs share many but not all of
 * the characteristics of InfiniBand MADs.
 *
 * OPA MADs differ in the following ways:
 *
 *    1) MADs are variable size up to 2K
 *       IBTA defined MADs remain fixed at 256 bytes
 *    2) OPA SMPs must carry valid PKeys
 *    3) OPA SMP packets are a different format
 *
 * Return: true if the port supports OPA MAD packet formats.
 */
static inline bool rdma_cap_opa_mad(struct ib_device *device, u8 port_num)
{
	return (device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_OPA_MAD)
		== RDMA_CORE_CAP_OPA_MAD;
}

/**
 * rdma_cap_ib_smi - Check if the port of a device provides an Infiniband
 * Subnet Management Agent (SMA) on the Subnet Management Interface (SMI).
 * @device: Device to check
 * @port_num: Port number to check
 *
 * Each InfiniBand node is required to provide a Subnet Management Agent
 * that the subnet manager can access.  Prior to the fabric being fully
 * configured by the subnet manager, the SMA is accessed via a well known
 * interface called the Subnet Management Interface (SMI).  This interface
 * uses directed route packets to communicate with the SM to get around the
 * chicken and egg problem of the SM needing to know what's on the fabric
 * in order to configure the fabric, and needing to configure the fabric in
 * order to send packets to the devices on the fabric.  These directed
 * route packets do not need the fabric fully configured in order to reach
 * their destination.  The SMI is the only method allowed to send
 * directed route packets on an InfiniBand fabric.
 *
 * Return: true if the port provides an SMI.
 */
static inline bool rdma_cap_ib_smi(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_IB_SMI;
}

/**
 * rdma_cap_ib_cm - Check if the port of device has the capability Infiniband
 * Communication Manager.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * The InfiniBand Communication Manager is one of many pre-defined General
 * Service Agents (GSA) that are accessed via the General Service
 * Interface (GSI).  It's role is to facilitate establishment of connections
 * between nodes as well as other management related tasks for established
 * connections.
 *
 * Return: true if the port supports an IB CM (this does not guarantee that
 * a CM is actually running however).
 */
static inline bool rdma_cap_ib_cm(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_IB_CM;
}

/**
 * rdma_cap_iw_cm - Check if the port of device has the capability IWARP
 * Communication Manager.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * Similar to above, but specific to iWARP connections which have a different
 * managment protocol than InfiniBand.
 *
 * Return: true if the port supports an iWARP CM (this does not guarantee that
 * a CM is actually running however).
 */
static inline bool rdma_cap_iw_cm(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_IW_CM;
}

/**
 * rdma_cap_ib_sa - Check if the port of device has the capability Infiniband
 * Subnet Administration.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * An InfiniBand Subnet Administration (SA) service is a pre-defined General
 * Service Agent (GSA) provided by the Subnet Manager (SM).  On InfiniBand
 * fabrics, devices should resolve routes to other hosts by contacting the
 * SA to query the proper route.
 *
 * Return: true if the port should act as a client to the fabric Subnet
 * Administration interface.  This does not imply that the SA service is
 * running locally.
 */
static inline bool rdma_cap_ib_sa(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_IB_SA;
}

/**
 * rdma_cap_ib_mcast - Check if the port of device has the capability Infiniband
 * Multicast.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * InfiniBand multicast registration is more complex than normal IPv4 or
 * IPv6 multicast registration.  Each Host Channel Adapter must register
 * with the Subnet Manager when it wishes to join a multicast group.  It
 * should do so only once regardless of how many queue pairs it subscribes
 * to this group.  And it should leave the group only after all queue pairs
 * attached to the group have been detached.
 *
 * Return: true if the port must undertake the additional adminstrative
 * overhead of registering/unregistering with the SM and tracking of the
 * total number of queue pairs attached to the multicast group.
 */
static inline bool rdma_cap_ib_mcast(const struct ib_device *device, u8 port_num)
{
	return rdma_cap_ib_sa(device, port_num);
}

/**
 * rdma_cap_af_ib - Check if the port of device has the capability
 * Native Infiniband Address.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * InfiniBand addressing uses a port's GUID + Subnet Prefix to make a default
 * GID.  RoCE uses a different mechanism, but still generates a GID via
 * a prescribed mechanism and port specific data.
 *
 * Return: true if the port uses a GID address to identify devices on the
 * network.
 */
static inline bool rdma_cap_af_ib(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_AF_IB;
}

/**
 * rdma_cap_eth_ah - Check if the port of device has the capability
 * Ethernet Address Handle.
 * @device: Device to check
 * @port_num: Port number to check
 *
 * RoCE is InfiniBand over Ethernet, and it uses a well defined technique
 * to fabricate GIDs over Ethernet/IP specific addresses native to the
 * port.  Normally, packet headers are generated by the sending host
 * adapter, but when sending connectionless datagrams, we must manually
 * inject the proper headers for the fabric we are communicating over.
 *
 * Return: true if we are running as a RoCE port and must force the
 * addition of a Global Route Header built from our Ethernet Address
 * Handle into our header list for connectionless packets.
 */
static inline bool rdma_cap_eth_ah(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].core_cap_flags & RDMA_CORE_CAP_ETH_AH;
}

/**
 * rdma_max_mad_size - Return the max MAD size required by this RDMA Port.
 *
 * @device: Device
 * @port_num: Port number
 *
 * This MAD size includes the MAD headers and MAD payload.  No other headers
 * are included.
 *
 * Return the max MAD size required by the Port.  Will return 0 if the port
 * does not support MADs
 */
static inline size_t rdma_max_mad_size(const struct ib_device *device, u8 port_num)
{
	return device->port_immutable[port_num].max_mad_size;
}

/**
 * rdma_cap_roce_gid_table - Check if the port of device uses roce_gid_table
 * @device: Device to check
 * @port_num: Port number to check
 *
 * RoCE GID table mechanism manages the various GIDs for a device.
 *
 * NOTE: if allocating the port's GID table has failed, this call will still
 * return true, but any RoCE GID table API will fail.
 *
 * Return: true if the port uses RoCE GID table mechanism in order to manage
 * its GIDs.
 */
static inline bool rdma_cap_roce_gid_table(const struct ib_device *device,
					   u8 port_num)
{
	return rdma_protocol_roce(device, port_num) &&
		device->add_gid && device->del_gid;
}

/*
 * Check if the device supports READ W/ INVALIDATE.
 */
static inline bool rdma_cap_read_inv(struct ib_device *dev, u32 port_num)
{
	/*
	 * iWarp drivers must support READ W/ INVALIDATE.  No other protocol
	 * has support for it yet.
	 */
	return rdma_protocol_iwarp(dev, port_num);
}

int ib_query_gid(struct ib_device *device,
		 u8 port_num, int index, union ib_gid *gid,
		 struct ib_gid_attr *attr);

int ib_set_vf_link_state(struct ib_device *device, int vf, u8 port,
			 int state);
int ib_get_vf_config(struct ib_device *device, int vf, u8 port,
		     struct ifla_vf_info *info);
int ib_get_vf_stats(struct ib_device *device, int vf, u8 port,
		    struct ifla_vf_stats *stats);
int ib_set_vf_guid(struct ib_device *device, int vf, u8 port, u64 guid,
		   int type);

int ib_query_pkey(struct ib_device *device,
		  u8 port_num, u16 index, u16 *pkey);

int ib_modify_device(struct ib_device *device,
		     int device_modify_mask,
		     struct ib_device_modify *device_modify);

int ib_modify_port(struct ib_device *device,
		   u8 port_num, int port_modify_mask,
		   struct ib_port_modify *port_modify);

int ib_find_gid(struct ib_device *device, union ib_gid *gid,
		enum ib_gid_type gid_type, struct net_device *ndev,
		u8 *port_num, u16 *index);

int ib_find_pkey(struct ib_device *device,
		 u8 port_num, u16 pkey, u16 *index);

enum ib_pd_flags {
	/*
	 * Create a memory registration for all memory in the system and place
	 * the rkey for it into pd->unsafe_global_rkey.  This can be used by
	 * ULPs to avoid the overhead of dynamic MRs.
	 *
	 * This flag is generally considered unsafe and must only be used in
	 * extremly trusted environments.  Every use of it will log a warning
	 * in the kernel log.
	 */
	IB_PD_UNSAFE_GLOBAL_RKEY	= 0x01,
};

struct ib_pd *__ib_alloc_pd(struct ib_device *device, unsigned int flags,
		const char *caller);
#define ib_alloc_pd(device, flags) \
	__ib_alloc_pd((device), (flags), __func__)
void ib_dealloc_pd(struct ib_pd *pd);

/**
 * ib_create_ah - Creates an address handle for the given address vector.
 * @pd: The protection domain associated with the address handle.
 * @ah_attr: The attributes of the address vector.
 *
 * The address handle is used to reference a local or global destination
 * in all UD QP post sends.
 */
struct ib_ah *ib_create_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr);

/**
 * ib_init_ah_from_wc - Initializes address handle attributes from a
 *   work completion.
 * @device: Device on which the received message arrived.
 * @port_num: Port on which the received message arrived.
 * @wc: Work completion associated with the received message.
 * @grh: References the received global route header.  This parameter is
 *   ignored unless the work completion indicates that the GRH is valid.
 * @ah_attr: Returned attributes that can be used when creating an address
 *   handle for replying to the message.
 */
int ib_init_ah_from_wc(struct ib_device *device, u8 port_num,
		       const struct ib_wc *wc, const struct ib_grh *grh,
		       struct ib_ah_attr *ah_attr);

/**
 * ib_create_ah_from_wc - Creates an address handle associated with the
 *   sender of the specified work completion.
 * @pd: The protection domain associated with the address handle.
 * @wc: Work completion information associated with a received message.
 * @grh: References the received global route header.  This parameter is
 *   ignored unless the work completion indicates that the GRH is valid.
 * @port_num: The outbound port number to associate with the address.
 *
 * The address handle is used to reference a local or global destination
 * in all UD QP post sends.
 */
struct ib_ah *ib_create_ah_from_wc(struct ib_pd *pd, const struct ib_wc *wc,
				   const struct ib_grh *grh, u8 port_num);

/**
 * ib_modify_ah - Modifies the address vector associated with an address
 *   handle.
 * @ah: The address handle to modify.
 * @ah_attr: The new address vector attributes to associate with the
 *   address handle.
 */
int ib_modify_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr);

/**
 * ib_query_ah - Queries the address vector associated with an address
 *   handle.
 * @ah: The address handle to query.
 * @ah_attr: The address vector attributes associated with the address
 *   handle.
 */
int ib_query_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr);

/**
 * ib_destroy_ah - Destroys an address handle.
 * @ah: The address handle to destroy.
 */
int ib_destroy_ah(struct ib_ah *ah);

/**
 * ib_create_srq - Creates a SRQ associated with the specified protection
 *   domain.
 * @pd: The protection domain associated with the SRQ.
 * @srq_init_attr: A list of initial attributes required to create the
 *   SRQ.  If SRQ creation succeeds, then the attributes are updated to
 *   the actual capabilities of the created SRQ.
 *
 * srq_attr->max_wr and srq_attr->max_sge are read the determine the
 * requested size of the SRQ, and set to the actual values allocated
 * on return.  If ib_create_srq() succeeds, then max_wr and max_sge
 * will always be at least as large as the requested values.
 */
struct ib_srq *ib_create_srq(struct ib_pd *pd,
			     struct ib_srq_init_attr *srq_init_attr);

/**
 * ib_modify_srq - Modifies the attributes for the specified SRQ.
 * @srq: The SRQ to modify.
 * @srq_attr: On input, specifies the SRQ attributes to modify.  On output,
 *   the current values of selected SRQ attributes are returned.
 * @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ
 *   are being modified.
 *
 * The mask may contain IB_SRQ_MAX_WR to resize the SRQ and/or
 * IB_SRQ_LIMIT to set the SRQ's limit and request notification when
 * the number of receives queued drops below the limit.
 */
int ib_modify_srq(struct ib_srq *srq,
		  struct ib_srq_attr *srq_attr,
		  enum ib_srq_attr_mask srq_attr_mask);

/**
 * ib_query_srq - Returns the attribute list and current values for the
 *   specified SRQ.
 * @srq: The SRQ to query.
 * @srq_attr: The attributes of the specified SRQ.
 */
int ib_query_srq(struct ib_srq *srq,
		 struct ib_srq_attr *srq_attr);

/**
 * ib_destroy_srq - Destroys the specified SRQ.
 * @srq: The SRQ to destroy.
 */
int ib_destroy_srq(struct ib_srq *srq);

/**
 * ib_post_srq_recv - Posts a list of work requests to the specified SRQ.
 * @srq: The SRQ to post the work request on.
 * @recv_wr: A list of work requests to post on the receive queue.
 * @bad_recv_wr: On an immediate failure, this parameter will reference
 *   the work request that failed to be posted on the QP.
 */
static inline int ib_post_srq_recv(struct ib_srq *srq,
				   struct ib_recv_wr *recv_wr,
				   struct ib_recv_wr **bad_recv_wr)
{
	return srq->device->post_srq_recv(srq, recv_wr, bad_recv_wr);
}

/**
 * ib_create_qp - Creates a QP associated with the specified protection
 *   domain.
 * @pd: The protection domain associated with the QP.
 * @qp_init_attr: A list of initial attributes required to create the
 *   QP.  If QP creation succeeds, then the attributes are updated to
 *   the actual capabilities of the created QP.
 */
struct ib_qp *ib_create_qp(struct ib_pd *pd,
			   struct ib_qp_init_attr *qp_init_attr);

/**
 * ib_modify_qp - Modifies the attributes for the specified QP and then
 *   transitions the QP to the given state.
 * @qp: The QP to modify.
 * @qp_attr: On input, specifies the QP attributes to modify.  On output,
 *   the current values of selected QP attributes are returned.
 * @qp_attr_mask: A bit-mask used to specify which attributes of the QP
 *   are being modified.
 */
int ib_modify_qp(struct ib_qp *qp,
		 struct ib_qp_attr *qp_attr,
		 int qp_attr_mask);

/**
 * ib_query_qp - Returns the attribute list and current values for the
 *   specified QP.
 * @qp: The QP to query.
 * @qp_attr: The attributes of the specified QP.
 * @qp_attr_mask: A bit-mask used to select specific attributes to query.
 * @qp_init_attr: Additional attributes of the selected QP.
 *
 * The qp_attr_mask may be used to limit the query to gathering only the
 * selected attributes.
 */
int ib_query_qp(struct ib_qp *qp,
		struct ib_qp_attr *qp_attr,
		int qp_attr_mask,
		struct ib_qp_init_attr *qp_init_attr);

/**
 * ib_destroy_qp - Destroys the specified QP.
 * @qp: The QP to destroy.
 */
int ib_destroy_qp(struct ib_qp *qp);

/**
 * ib_open_qp - Obtain a reference to an existing sharable QP.
 * @xrcd - XRC domain
 * @qp_open_attr: Attributes identifying the QP to open.
 *
 * Returns a reference to a sharable QP.
 */
struct ib_qp *ib_open_qp(struct ib_xrcd *xrcd,
			 struct ib_qp_open_attr *qp_open_attr);

/**
 * ib_close_qp - Release an external reference to a QP.
 * @qp: The QP handle to release
 *
 * The opened QP handle is released by the caller.  The underlying
 * shared QP is not destroyed until all internal references are released.
 */
int ib_close_qp(struct ib_qp *qp);

/**
 * ib_post_send - Posts a list of work requests to the send queue of
 *   the specified QP.
 * @qp: The QP to post the work request on.
 * @send_wr: A list of work requests to post on the send queue.
 * @bad_send_wr: On an immediate failure, this parameter will reference
 *   the work request that failed to be posted on the QP.
 *
 * While IBA Vol. 1 section 11.4.1.1 specifies that if an immediate
 * error is returned, the QP state shall not be affected,
 * ib_post_send() will return an immediate error after queueing any
 * earlier work requests in the list.
 */
static inline int ib_post_send(struct ib_qp *qp,
			       struct ib_send_wr *send_wr,
			       struct ib_send_wr **bad_send_wr)
{
	return qp->device->post_send(qp, send_wr, bad_send_wr);
}

/**
 * ib_post_recv - Posts a list of work requests to the receive queue of
 *   the specified QP.
 * @qp: The QP to post the work request on.
 * @recv_wr: A list of work requests to post on the receive queue.
 * @bad_recv_wr: On an immediate failure, this parameter will reference
 *   the work request that failed to be posted on the QP.
 */
static inline int ib_post_recv(struct ib_qp *qp,
			       struct ib_recv_wr *recv_wr,
			       struct ib_recv_wr **bad_recv_wr)
{
	return qp->device->post_recv(qp, recv_wr, bad_recv_wr);
}

struct ib_cq *ib_alloc_cq(struct ib_device *dev, void *private,
		int nr_cqe, int comp_vector, enum ib_poll_context poll_ctx);
void ib_free_cq(struct ib_cq *cq);
int ib_process_cq_direct(struct ib_cq *cq, int budget);

/**
 * ib_create_cq - Creates a CQ on the specified device.
 * @device: The device on which to create the CQ.
 * @comp_handler: A user-specified callback that is invoked when a
 *   completion event occurs on the CQ.
 * @event_handler: A user-specified callback that is invoked when an
 *   asynchronous event not associated with a completion occurs on the CQ.
 * @cq_context: Context associated with the CQ returned to the user via
 *   the associated completion and event handlers.
 * @cq_attr: The attributes the CQ should be created upon.
 *
 * Users can examine the cq structure to determine the actual CQ size.
 */
struct ib_cq *ib_create_cq(struct ib_device *device,
			   ib_comp_handler comp_handler,
			   void (*event_handler)(struct ib_event *, void *),
			   void *cq_context,
			   const struct ib_cq_init_attr *cq_attr);

/**
 * ib_resize_cq - Modifies the capacity of the CQ.
 * @cq: The CQ to resize.
 * @cqe: The minimum size of the CQ.
 *
 * Users can examine the cq structure to determine the actual CQ size.
 */
int ib_resize_cq(struct ib_cq *cq, int cqe);

/**
 * ib_modify_cq - Modifies moderation params of the CQ
 * @cq: The CQ to modify.
 * @cq_count: number of CQEs that will trigger an event
 * @cq_period: max period of time in usec before triggering an event
 *
 */
int ib_modify_cq(struct ib_cq *cq, u16 cq_count, u16 cq_period);

/**
 * ib_destroy_cq - Destroys the specified CQ.
 * @cq: The CQ to destroy.
 */
int ib_destroy_cq(struct ib_cq *cq);

/**
 * ib_poll_cq - poll a CQ for completion(s)
 * @cq:the CQ being polled
 * @num_entries:maximum number of completions to return
 * @wc:array of at least @num_entries &struct ib_wc where completions
 *   will be returned
 *
 * Poll a CQ for (possibly multiple) completions.  If the return value
 * is < 0, an error occurred.  If the return value is >= 0, it is the
 * number of completions returned.  If the return value is
 * non-negative and < num_entries, then the CQ was emptied.
 */
static inline int ib_poll_cq(struct ib_cq *cq, int num_entries,
			     struct ib_wc *wc)
{
	return cq->device->poll_cq(cq, num_entries, wc);
}

/**
 * ib_peek_cq - Returns the number of unreaped completions currently
 *   on the specified CQ.
 * @cq: The CQ to peek.
 * @wc_cnt: A minimum number of unreaped completions to check for.
 *
 * If the number of unreaped completions is greater than or equal to wc_cnt,
 * this function returns wc_cnt, otherwise, it returns the actual number of
 * unreaped completions.
 */
int ib_peek_cq(struct ib_cq *cq, int wc_cnt);

/**
 * ib_req_notify_cq - Request completion notification on a CQ.
 * @cq: The CQ to generate an event for.
 * @flags:
 *   Must contain exactly one of %IB_CQ_SOLICITED or %IB_CQ_NEXT_COMP
 *   to request an event on the next solicited event or next work
 *   completion at any type, respectively. %IB_CQ_REPORT_MISSED_EVENTS
 *   may also be |ed in to request a hint about missed events, as
 *   described below.
 *
 * Return Value:
 *    < 0 means an error occurred while requesting notification
 *   == 0 means notification was requested successfully, and if
 *        IB_CQ_REPORT_MISSED_EVENTS was passed in, then no events
 *        were missed and it is safe to wait for another event.  In
 *        this case is it guaranteed that any work completions added
 *        to the CQ since the last CQ poll will trigger a completion
 *        notification event.
 *    > 0 is only returned if IB_CQ_REPORT_MISSED_EVENTS was passed
 *        in.  It means that the consumer must poll the CQ again to
 *        make sure it is empty to avoid missing an event because of a
 *        race between requesting notification and an entry being
 *        added to the CQ.  This return value means it is possible
 *        (but not guaranteed) that a work completion has been added
 *        to the CQ since the last poll without triggering a
 *        completion notification event.
 */
static inline int ib_req_notify_cq(struct ib_cq *cq,
				   enum ib_cq_notify_flags flags)
{
	return cq->device->req_notify_cq(cq, flags);
}

/**
 * ib_req_ncomp_notif - Request completion notification when there are
 *   at least the specified number of unreaped completions on the CQ.
 * @cq: The CQ to generate an event for.
 * @wc_cnt: The number of unreaped completions that should be on the
 *   CQ before an event is generated.
 */
static inline int ib_req_ncomp_notif(struct ib_cq *cq, int wc_cnt)
{
	return cq->device->req_ncomp_notif ?
		cq->device->req_ncomp_notif(cq, wc_cnt) :
		-ENOSYS;
}

/**
 * ib_dma_mapping_error - check a DMA addr for error
 * @dev: The device for which the dma_addr was created
 * @dma_addr: The DMA address to check
 */
static inline int ib_dma_mapping_error(struct ib_device *dev, u64 dma_addr)
{
	if (dev->dma_ops)
		return dev->dma_ops->mapping_error(dev, dma_addr);
	return dma_mapping_error(dev->dma_device, dma_addr);
}

/**
 * ib_dma_map_single - Map a kernel virtual address to DMA address
 * @dev: The device for which the dma_addr is to be created
 * @cpu_addr: The kernel virtual address
 * @size: The size of the region in bytes
 * @direction: The direction of the DMA
 */
static inline u64 ib_dma_map_single(struct ib_device *dev,
				    void *cpu_addr, size_t size,
				    enum dma_data_direction direction)
{
	if (dev->dma_ops)
		return dev->dma_ops->map_single(dev, cpu_addr, size, direction);
	return dma_map_single(dev->dma_device, cpu_addr, size, direction);
}

/**
 * ib_dma_unmap_single - Destroy a mapping created by ib_dma_map_single()
 * @dev: The device for which the DMA address was created
 * @addr: The DMA address
 * @size: The size of the region in bytes
 * @direction: The direction of the DMA
 */
static inline void ib_dma_unmap_single(struct ib_device *dev,
				       u64 addr, size_t size,
				       enum dma_data_direction direction)
{
	if (dev->dma_ops)
		dev->dma_ops->unmap_single(dev, addr, size, direction);
	else
		dma_unmap_single(dev->dma_device, addr, size, direction);
}

static inline u64 ib_dma_map_single_attrs(struct ib_device *dev,
					  void *cpu_addr, size_t size,
					  enum dma_data_direction direction,
					  unsigned long dma_attrs)
{
	return dma_map_single_attrs(dev->dma_device, cpu_addr, size,
				    direction, dma_attrs);
}

static inline void ib_dma_unmap_single_attrs(struct ib_device *dev,
					     u64 addr, size_t size,
					     enum dma_data_direction direction,
					     unsigned long dma_attrs)
{
	return dma_unmap_single_attrs(dev->dma_device, addr, size,
				      direction, dma_attrs);
}

/**
 * ib_dma_map_page - Map a physical page to DMA address
 * @dev: The device for which the dma_addr is to be created
 * @page: The page to be mapped
 * @offset: The offset within the page
 * @size: The size of the region in bytes
 * @direction: The direction of the DMA
 */
static inline u64 ib_dma_map_page(struct ib_device *dev,
				  struct page *page,
				  unsigned long offset,
				  size_t size,
					 enum dma_data_direction direction)
{
	if (dev->dma_ops)
		return dev->dma_ops->map_page(dev, page, offset, size, direction);
	return dma_map_page(dev->dma_device, page, offset, size, direction);
}

/**
 * ib_dma_unmap_page - Destroy a mapping created by ib_dma_map_page()
 * @dev: The device for which the DMA address was created
 * @addr: The DMA address
 * @size: The size of the region in bytes
 * @direction: The direction of the DMA
 */
static inline void ib_dma_unmap_page(struct ib_device *dev,
				     u64 addr, size_t size,
				     enum dma_data_direction direction)
{
	if (dev->dma_ops)
		dev->dma_ops->unmap_page(dev, addr, size, direction);
	else
		dma_unmap_page(dev->dma_device, addr, size, direction);
}

/**
 * ib_dma_map_sg - Map a scatter/gather list to DMA addresses
 * @dev: The device for which the DMA addresses are to be created
 * @sg: The array of scatter/gather entries
 * @nents: The number of scatter/gather entries
 * @direction: The direction of the DMA
 */
static inline int ib_dma_map_sg(struct ib_device *dev,
				struct scatterlist *sg, int nents,
				enum dma_data_direction direction)
{
	if (dev->dma_ops)
		return dev->dma_ops->map_sg(dev, sg, nents, direction);
	return dma_map_sg(dev->dma_device, sg, nents, direction);
}

/**
 * ib_dma_unmap_sg - Unmap a scatter/gather list of DMA addresses
 * @dev: The device for which the DMA addresses were created
 * @sg: The array of scatter/gather entries
 * @nents: The number of scatter/gather entries
 * @direction: The direction of the DMA
 */
static inline void ib_dma_unmap_sg(struct ib_device *dev,
				   struct scatterlist *sg, int nents,
				   enum dma_data_direction direction)
{
	if (dev->dma_ops)
		dev->dma_ops->unmap_sg(dev, sg, nents, direction);
	else
		dma_unmap_sg(dev->dma_device, sg, nents, direction);
}

static inline int ib_dma_map_sg_attrs(struct ib_device *dev,
				      struct scatterlist *sg, int nents,
				      enum dma_data_direction direction,
				      unsigned long dma_attrs)
{
	if (dev->dma_ops)
		return dev->dma_ops->map_sg_attrs(dev, sg, nents, direction,
						  dma_attrs);
	else
		return dma_map_sg_attrs(dev->dma_device, sg, nents, direction,
					dma_attrs);
}

static inline void ib_dma_unmap_sg_attrs(struct ib_device *dev,
					 struct scatterlist *sg, int nents,
					 enum dma_data_direction direction,
					 unsigned long dma_attrs)
{
	if (dev->dma_ops)
		return dev->dma_ops->unmap_sg_attrs(dev, sg, nents, direction,
						  dma_attrs);
	else
		dma_unmap_sg_attrs(dev->dma_device, sg, nents, direction,
				   dma_attrs);
}
/**
 * ib_sg_dma_address - Return the DMA address from a scatter/gather entry
 * @dev: The device for which the DMA addresses were created
 * @sg: The scatter/gather entry
 *
 * Note: this function is obsolete. To do: change all occurrences of
 * ib_sg_dma_address() into sg_dma_address().
 */
static inline u64 ib_sg_dma_address(struct ib_device *dev,
				    struct scatterlist *sg)
{
	return sg_dma_address(sg);
}

/**
 * ib_sg_dma_len - Return the DMA length from a scatter/gather entry
 * @dev: The device for which the DMA addresses were created
 * @sg: The scatter/gather entry
 *
 * Note: this function is obsolete. To do: change all occurrences of
 * ib_sg_dma_len() into sg_dma_len().
 */
static inline unsigned int ib_sg_dma_len(struct ib_device *dev,
					 struct scatterlist *sg)
{
	return sg_dma_len(sg);
}

/**
 * ib_dma_sync_single_for_cpu - Prepare DMA region to be accessed by CPU
 * @dev: The device for which the DMA address was created
 * @addr: The DMA address
 * @size: The size of the region in bytes
 * @dir: The direction of the DMA
 */
static inline void ib_dma_sync_single_for_cpu(struct ib_device *dev,
					      u64 addr,
					      size_t size,
					      enum dma_data_direction dir)
{
	if (dev->dma_ops)
		dev->dma_ops->sync_single_for_cpu(dev, addr, size, dir);
	else
		dma_sync_single_for_cpu(dev->dma_device, addr, size, dir);
}

/**
 * ib_dma_sync_single_for_device - Prepare DMA region to be accessed by device
 * @dev: The device for which the DMA address was created
 * @addr: The DMA address
 * @size: The size of the region in bytes
 * @dir: The direction of the DMA
 */
static inline void ib_dma_sync_single_for_device(struct ib_device *dev,
						 u64 addr,
						 size_t size,
						 enum dma_data_direction dir)
{
	if (dev->dma_ops)
		dev->dma_ops->sync_single_for_device(dev, addr, size, dir);
	else
		dma_sync_single_for_device(dev->dma_device, addr, size, dir);
}

/**
 * ib_dma_alloc_coherent - Allocate memory and map it for DMA
 * @dev: The device for which the DMA address is requested
 * @size: The size of the region to allocate in bytes
 * @dma_handle: A pointer for returning the DMA address of the region
 * @flag: memory allocator flags
 */
static inline void *ib_dma_alloc_coherent(struct ib_device *dev,
					   size_t size,
					   u64 *dma_handle,
					   gfp_t flag)
{
	if (dev->dma_ops)
		return dev->dma_ops->alloc_coherent(dev, size, dma_handle, flag);
	else {
		dma_addr_t handle;
		void *ret;

		ret = dma_alloc_coherent(dev->dma_device, size, &handle, flag);
		*dma_handle = handle;
		return ret;
	}
}

/**
 * ib_dma_free_coherent - Free memory allocated by ib_dma_alloc_coherent()
 * @dev: The device for which the DMA addresses were allocated
 * @size: The size of the region
 * @cpu_addr: the address returned by ib_dma_alloc_coherent()
 * @dma_handle: the DMA address returned by ib_dma_alloc_coherent()
 */
static inline void ib_dma_free_coherent(struct ib_device *dev,
					size_t size, void *cpu_addr,
					u64 dma_handle)
{
	if (dev->dma_ops)
		dev->dma_ops->free_coherent(dev, size, cpu_addr, dma_handle);
	else
		dma_free_coherent(dev->dma_device, size, cpu_addr, dma_handle);
}

/**
 * ib_dereg_mr - Deregisters a memory region and removes it from the
 *   HCA translation table.
 * @mr: The memory region to deregister.
 *
 * This function can fail, if the memory region has memory windows bound to it.
 */
int ib_dereg_mr(struct ib_mr *mr);

struct ib_mr *ib_alloc_mr(struct ib_pd *pd,
			  enum ib_mr_type mr_type,
			  u32 max_num_sg);

/**
 * ib_update_fast_reg_key - updates the key portion of the fast_reg MR
 *   R_Key and L_Key.
 * @mr - struct ib_mr pointer to be updated.
 * @newkey - new key to be used.
 */
static inline void ib_update_fast_reg_key(struct ib_mr *mr, u8 newkey)
{
	mr->lkey = (mr->lkey & 0xffffff00) | newkey;
	mr->rkey = (mr->rkey & 0xffffff00) | newkey;
}

/**
 * ib_inc_rkey - increments the key portion of the given rkey. Can be used
 * for calculating a new rkey for type 2 memory windows.
 * @rkey - the rkey to increment.
 */
static inline u32 ib_inc_rkey(u32 rkey)
{
	const u32 mask = 0x000000ff;
	return ((rkey + 1) & mask) | (rkey & ~mask);
}

/**
 * ib_alloc_fmr - Allocates a unmapped fast memory region.
 * @pd: The protection domain associated with the unmapped region.
 * @mr_access_flags: Specifies the memory access rights.
 * @fmr_attr: Attributes of the unmapped region.
 *
 * A fast memory region must be mapped before it can be used as part of
 * a work request.
 */
struct ib_fmr *ib_alloc_fmr(struct ib_pd *pd,
			    int mr_access_flags,
			    struct ib_fmr_attr *fmr_attr);

/**
 * ib_map_phys_fmr - Maps a list of physical pages to a fast memory region.
 * @fmr: The fast memory region to associate with the pages.
 * @page_list: An array of physical pages to map to the fast memory region.
 * @list_len: The number of pages in page_list.
 * @iova: The I/O virtual address to use with the mapped region.
 */
static inline int ib_map_phys_fmr(struct ib_fmr *fmr,
				  u64 *page_list, int list_len,
				  u64 iova)
{
	return fmr->device->map_phys_fmr(fmr, page_list, list_len, iova);
}

/**
 * ib_unmap_fmr - Removes the mapping from a list of fast memory regions.
 * @fmr_list: A linked list of fast memory regions to unmap.
 */
int ib_unmap_fmr(struct list_head *fmr_list);

/**
 * ib_dealloc_fmr - Deallocates a fast memory region.
 * @fmr: The fast memory region to deallocate.
 */
int ib_dealloc_fmr(struct ib_fmr *fmr);

/**
 * ib_attach_mcast - Attaches the specified QP to a multicast group.
 * @qp: QP to attach to the multicast group.  The QP must be type
 *   IB_QPT_UD.
 * @gid: Multicast group GID.
 * @lid: Multicast group LID in host byte order.
 *
 * In order to send and receive multicast packets, subnet
 * administration must have created the multicast group and configured
 * the fabric appropriately.  The port associated with the specified
 * QP must also be a member of the multicast group.
 */
int ib_attach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid);

/**
 * ib_detach_mcast - Detaches the specified QP from a multicast group.
 * @qp: QP to detach from the multicast group.
 * @gid: Multicast group GID.
 * @lid: Multicast group LID in host byte order.
 */
int ib_detach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid);

/**
 * ib_alloc_xrcd - Allocates an XRC domain.
 * @device: The device on which to allocate the XRC domain.
 */
struct ib_xrcd *ib_alloc_xrcd(struct ib_device *device);

/**
 * ib_dealloc_xrcd - Deallocates an XRC domain.
 * @xrcd: The XRC domain to deallocate.
 */
int ib_dealloc_xrcd(struct ib_xrcd *xrcd);

struct ib_flow *ib_create_flow(struct ib_qp *qp,
			       struct ib_flow_attr *flow_attr, int domain);
int ib_destroy_flow(struct ib_flow *flow_id);

static inline int ib_check_mr_access(int flags)
{
	/*
	 * Local write permission is required if remote write or
	 * remote atomic permission is also requested.
	 */
	if (flags & (IB_ACCESS_REMOTE_ATOMIC | IB_ACCESS_REMOTE_WRITE) &&
	    !(flags & IB_ACCESS_LOCAL_WRITE))
		return -EINVAL;

	return 0;
}

/**
 * ib_check_mr_status: lightweight check of MR status.
 *     This routine may provide status checks on a selected
 *     ib_mr. first use is for signature status check.
 *
 * @mr: A memory region.
 * @check_mask: Bitmask of which checks to perform from
 *     ib_mr_status_check enumeration.
 * @mr_status: The container of relevant status checks.
 *     failed checks will be indicated in the status bitmask
 *     and the relevant info shall be in the error item.
 */
int ib_check_mr_status(struct ib_mr *mr, u32 check_mask,
		       struct ib_mr_status *mr_status);

struct net_device *ib_get_net_dev_by_params(struct ib_device *dev, u8 port,
					    u16 pkey, const union ib_gid *gid,
					    const struct sockaddr *addr);
struct ib_wq *ib_create_wq(struct ib_pd *pd,
			   struct ib_wq_init_attr *init_attr);
int ib_destroy_wq(struct ib_wq *wq);
int ib_modify_wq(struct ib_wq *wq, struct ib_wq_attr *attr,
		 u32 wq_attr_mask);
struct ib_rwq_ind_table *ib_create_rwq_ind_table(struct ib_device *device,
						 struct ib_rwq_ind_table_init_attr*
						 wq_ind_table_init_attr);
int ib_destroy_rwq_ind_table(struct ib_rwq_ind_table *wq_ind_table);

int ib_map_mr_sg(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,
		 unsigned int *sg_offset, unsigned int page_size);

static inline int
ib_map_mr_sg_zbva(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,
		  unsigned int *sg_offset, unsigned int page_size)
{
	int n;

	n = ib_map_mr_sg(mr, sg, sg_nents, sg_offset, page_size);
	mr->iova = 0;

	return n;
}

int ib_sg_to_pages(struct ib_mr *mr, struct scatterlist *sgl, int sg_nents,
		unsigned int *sg_offset, int (*set_page)(struct ib_mr *, u64));

void ib_drain_rq(struct ib_qp *qp);
void ib_drain_sq(struct ib_qp *qp);
void ib_drain_qp(struct ib_qp *qp);
#endif /* IB_VERBS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * mac80211 <-> driver interface
 *
 * Copyright 2002-2005, Devicescape Software, Inc.
 * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
 * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
 * Copyright 2013-2014  Intel Mobile Communications GmbH
 * Copyright (C) 2015 - 2016 Intel Deutschland GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef MAC80211_H
#define MAC80211_H

#include <linux/bug.h>
#include <linux/kernel.h>
#include <linux/if_ether.h>
#include <linux/skbuff.h>
#include <linux/ieee80211.h>
#include <net/cfg80211.h>
#include <net/codel.h>
#include <asm/unaligned.h>

/**
 * DOC: Introduction
 *
 * mac80211 is the Linux stack for 802.11 hardware that implements
 * only partial functionality in hard- or firmware. This document
 * defines the interface between mac80211 and low-level hardware
 * drivers.
 */

/**
 * DOC: Calling mac80211 from interrupts
 *
 * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be
 * called in hardware interrupt context. The low-level driver must not call any
 * other functions in hardware interrupt context. If there is a need for such
 * call, the low-level driver should first ACK the interrupt and perform the
 * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
 * tasklet function.
 *
 * NOTE: If the driver opts to use the _irqsafe() functions, it may not also
 *	 use the non-IRQ-safe functions!
 */

/**
 * DOC: Warning
 *
 * If you're reading this document and not the header file itself, it will
 * be incomplete because not all documentation has been converted yet.
 */

/**
 * DOC: Frame format
 *
 * As a general rule, when frames are passed between mac80211 and the driver,
 * they start with the IEEE 802.11 header and include the same octets that are
 * sent over the air except for the FCS which should be calculated by the
 * hardware.
 *
 * There are, however, various exceptions to this rule for advanced features:
 *
 * The first exception is for hardware encryption and decryption offload
 * where the IV/ICV may or may not be generated in hardware.
 *
 * Secondly, when the hardware handles fragmentation, the frame handed to
 * the driver from mac80211 is the MSDU, not the MPDU.
 */

/**
 * DOC: mac80211 workqueue
 *
 * mac80211 provides its own workqueue for drivers and internal mac80211 use.
 * The workqueue is a single threaded workqueue and can only be accessed by
 * helpers for sanity checking. Drivers must ensure all work added onto the
 * mac80211 workqueue should be cancelled on the driver stop() callback.
 *
 * mac80211 will flushed the workqueue upon interface removal and during
 * suspend.
 *
 * All work performed on the mac80211 workqueue must not acquire the RTNL lock.
 *
 */

/**
 * DOC: mac80211 software tx queueing
 *
 * mac80211 provides an optional intermediate queueing implementation designed
 * to allow the driver to keep hardware queues short and provide some fairness
 * between different stations/interfaces.
 * In this model, the driver pulls data frames from the mac80211 queue instead
 * of letting mac80211 push them via drv_tx().
 * Other frames (e.g. control or management) are still pushed using drv_tx().
 *
 * Drivers indicate that they use this model by implementing the .wake_tx_queue
 * driver operation.
 *
 * Intermediate queues (struct ieee80211_txq) are kept per-sta per-tid, with a
 * single per-vif queue for multicast data frames.
 *
 * The driver is expected to initialize its private per-queue data for stations
 * and interfaces in the .add_interface and .sta_add ops.
 *
 * The driver can't access the queue directly. To dequeue a frame, it calls
 * ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a queue, it
 * calls the .wake_tx_queue driver op.
 *
 * For AP powersave TIM handling, the driver only needs to indicate if it has
 * buffered packets in the driver specific data structures by calling
 * ieee80211_sta_set_buffered(). For frames buffered in the ieee80211_txq
 * struct, mac80211 sets the appropriate TIM PVB bits and calls
 * .release_buffered_frames().
 * In that callback the driver is therefore expected to release its own
 * buffered frames and afterwards also frames from the ieee80211_txq (obtained
 * via the usual ieee80211_tx_dequeue).
 */

struct device;

/**
 * enum ieee80211_max_queues - maximum number of queues
 *
 * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.
 * @IEEE80211_MAX_QUEUE_MAP: bitmap with maximum queues set
 */
enum ieee80211_max_queues {
	IEEE80211_MAX_QUEUES =		16,
	IEEE80211_MAX_QUEUE_MAP =	BIT(IEEE80211_MAX_QUEUES) - 1,
};

#define IEEE80211_INVAL_HW_QUEUE	0xff

/**
 * enum ieee80211_ac_numbers - AC numbers as used in mac80211
 * @IEEE80211_AC_VO: voice
 * @IEEE80211_AC_VI: video
 * @IEEE80211_AC_BE: best effort
 * @IEEE80211_AC_BK: background
 */
enum ieee80211_ac_numbers {
	IEEE80211_AC_VO		= 0,
	IEEE80211_AC_VI		= 1,
	IEEE80211_AC_BE		= 2,
	IEEE80211_AC_BK		= 3,
};
#define IEEE80211_NUM_ACS	4

/**
 * struct ieee80211_tx_queue_params - transmit queue configuration
 *
 * The information provided in this structure is required for QoS
 * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.
 *
 * @aifs: arbitration interframe space [0..255]
 * @cw_min: minimum contention window [a value of the form
 *	2^n-1 in the range 1..32767]
 * @cw_max: maximum contention window [like @cw_min]
 * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled
 * @acm: is mandatory admission control required for the access category
 * @uapsd: is U-APSD mode enabled for the queue
 */
struct ieee80211_tx_queue_params {
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool acm;
	bool uapsd;
};

struct ieee80211_low_level_stats {
	unsigned int dot11ACKFailureCount;
	unsigned int dot11RTSFailureCount;
	unsigned int dot11FCSErrorCount;
	unsigned int dot11RTSSuccessCount;
};

/**
 * enum ieee80211_chanctx_change - change flag for channel context
 * @IEEE80211_CHANCTX_CHANGE_WIDTH: The channel width changed
 * @IEEE80211_CHANCTX_CHANGE_RX_CHAINS: The number of RX chains changed
 * @IEEE80211_CHANCTX_CHANGE_RADAR: radar detection flag changed
 * @IEEE80211_CHANCTX_CHANGE_CHANNEL: switched to another operating channel,
 *	this is used only with channel switching with CSA
 * @IEEE80211_CHANCTX_CHANGE_MIN_WIDTH: The min required channel width changed
 */
enum ieee80211_chanctx_change {
	IEEE80211_CHANCTX_CHANGE_WIDTH		= BIT(0),
	IEEE80211_CHANCTX_CHANGE_RX_CHAINS	= BIT(1),
	IEEE80211_CHANCTX_CHANGE_RADAR		= BIT(2),
	IEEE80211_CHANCTX_CHANGE_CHANNEL	= BIT(3),
	IEEE80211_CHANCTX_CHANGE_MIN_WIDTH	= BIT(4),
};

/**
 * struct ieee80211_chanctx_conf - channel context that vifs may be tuned to
 *
 * This is the driver-visible part. The ieee80211_chanctx
 * that contains it is visible in mac80211 only.
 *
 * @def: the channel definition
 * @min_def: the minimum channel definition currently required.
 * @rx_chains_static: The number of RX chains that must always be
 *	active on the channel to receive MIMO transmissions
 * @rx_chains_dynamic: The number of RX chains that must be enabled
 *	after RTS/CTS handshake to receive SMPS MIMO transmissions;
 *	this will always be >= @rx_chains_static.
 * @radar_enabled: whether radar detection is enabled on this channel.
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void *), size is determined in hw information.
 */
struct ieee80211_chanctx_conf {
	struct cfg80211_chan_def def;
	struct cfg80211_chan_def min_def;

	u8 rx_chains_static, rx_chains_dynamic;

	bool radar_enabled;

	u8 drv_priv[0] __aligned(sizeof(void *));
};

/**
 * enum ieee80211_chanctx_switch_mode - channel context switch mode
 * @CHANCTX_SWMODE_REASSIGN_VIF: Both old and new contexts already
 *	exist (and will continue to exist), but the virtual interface
 *	needs to be switched from one to the other.
 * @CHANCTX_SWMODE_SWAP_CONTEXTS: The old context exists but will stop
 *      to exist with this call, the new context doesn't exist but
 *      will be active after this call, the virtual interface switches
 *      from the old to the new (note that the driver may of course
 *      implement this as an on-the-fly chandef switch of the existing
 *      hardware context, but the mac80211 pointer for the old context
 *      will cease to exist and only the new one will later be used
 *      for changes/removal.)
 */
enum ieee80211_chanctx_switch_mode {
	CHANCTX_SWMODE_REASSIGN_VIF,
	CHANCTX_SWMODE_SWAP_CONTEXTS,
};

/**
 * struct ieee80211_vif_chanctx_switch - vif chanctx switch information
 *
 * This is structure is used to pass information about a vif that
 * needs to switch from one chanctx to another.  The
 * &ieee80211_chanctx_switch_mode defines how the switch should be
 * done.
 *
 * @vif: the vif that should be switched from old_ctx to new_ctx
 * @old_ctx: the old context to which the vif was assigned
 * @new_ctx: the new context to which the vif must be assigned
 */
struct ieee80211_vif_chanctx_switch {
	struct ieee80211_vif *vif;
	struct ieee80211_chanctx_conf *old_ctx;
	struct ieee80211_chanctx_conf *new_ctx;
};

/**
 * enum ieee80211_bss_change - BSS change notification flags
 *
 * These flags are used with the bss_info_changed() callback
 * to indicate which BSS parameter changed.
 *
 * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),
 *	also implies a change in the AID.
 * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed
 * @BSS_CHANGED_ERP_PREAMBLE: preamble changed
 * @BSS_CHANGED_ERP_SLOT: slot timing changed
 * @BSS_CHANGED_HT: 802.11n parameters changed
 * @BSS_CHANGED_BASIC_RATES: Basic rateset changed
 * @BSS_CHANGED_BEACON_INT: Beacon interval changed
 * @BSS_CHANGED_BSSID: BSSID changed, for whatever
 *	reason (IBSS and managed mode)
 * @BSS_CHANGED_BEACON: Beacon data changed, retrieve
 *	new beacon (beaconing modes)
 * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be
 *	enabled/disabled (beaconing modes)
 * @BSS_CHANGED_CQM: Connection quality monitor config changed
 * @BSS_CHANGED_IBSS: IBSS join status changed
 * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.
 * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note
 *	that it is only ever disabled for station mode.
 * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.
 * @BSS_CHANGED_SSID: SSID changed for this BSS (AP and IBSS mode)
 * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)
 * @BSS_CHANGED_PS: PS changed for this BSS (STA mode)
 * @BSS_CHANGED_TXPOWER: TX power setting changed for this interface
 * @BSS_CHANGED_P2P_PS: P2P powersave settings (CTWindow, opportunistic PS)
 *	changed
 * @BSS_CHANGED_BEACON_INFO: Data from the AP's beacon became available:
 *	currently dtim_period only is under consideration.
 * @BSS_CHANGED_BANDWIDTH: The bandwidth used by this interface changed,
 *	note that this is only called when it changes after the channel
 *	context had been assigned.
 * @BSS_CHANGED_OCB: OCB join status changed
 * @BSS_CHANGED_MU_GROUPS: VHT MU-MIMO group id or user position changed
 */
enum ieee80211_bss_change {
	BSS_CHANGED_ASSOC		= 1<<0,
	BSS_CHANGED_ERP_CTS_PROT	= 1<<1,
	BSS_CHANGED_ERP_PREAMBLE	= 1<<2,
	BSS_CHANGED_ERP_SLOT		= 1<<3,
	BSS_CHANGED_HT			= 1<<4,
	BSS_CHANGED_BASIC_RATES		= 1<<5,
	BSS_CHANGED_BEACON_INT		= 1<<6,
	BSS_CHANGED_BSSID		= 1<<7,
	BSS_CHANGED_BEACON		= 1<<8,
	BSS_CHANGED_BEACON_ENABLED	= 1<<9,
	BSS_CHANGED_CQM			= 1<<10,
	BSS_CHANGED_IBSS		= 1<<11,
	BSS_CHANGED_ARP_FILTER		= 1<<12,
	BSS_CHANGED_QOS			= 1<<13,
	BSS_CHANGED_IDLE		= 1<<14,
	BSS_CHANGED_SSID		= 1<<15,
	BSS_CHANGED_AP_PROBE_RESP	= 1<<16,
	BSS_CHANGED_PS			= 1<<17,
	BSS_CHANGED_TXPOWER		= 1<<18,
	BSS_CHANGED_P2P_PS		= 1<<19,
	BSS_CHANGED_BEACON_INFO		= 1<<20,
	BSS_CHANGED_BANDWIDTH		= 1<<21,
	BSS_CHANGED_OCB                 = 1<<22,
	BSS_CHANGED_MU_GROUPS		= 1<<23,

	/* when adding here, make sure to change ieee80211_reconfig */
};

/*
 * The maximum number of IPv4 addresses listed for ARP filtering. If the number
 * of addresses for an interface increase beyond this value, hardware ARP
 * filtering will be disabled.
 */
#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4

/**
 * enum ieee80211_event_type - event to be notified to the low level driver
 * @RSSI_EVENT: AP's rssi crossed the a threshold set by the driver.
 * @MLME_EVENT: event related to MLME
 * @BAR_RX_EVENT: a BAR was received
 * @BA_FRAME_TIMEOUT: Frames were released from the reordering buffer because
 *	they timed out. This won't be called for each frame released, but only
 *	once each time the timeout triggers.
 */
enum ieee80211_event_type {
	RSSI_EVENT,
	MLME_EVENT,
	BAR_RX_EVENT,
	BA_FRAME_TIMEOUT,
};

/**
 * enum ieee80211_rssi_event_data - relevant when event type is %RSSI_EVENT
 * @RSSI_EVENT_HIGH: AP's rssi went below the threshold set by the driver.
 * @RSSI_EVENT_LOW: AP's rssi went above the threshold set by the driver.
 */
enum ieee80211_rssi_event_data {
	RSSI_EVENT_HIGH,
	RSSI_EVENT_LOW,
};

/**
 * struct ieee80211_rssi_event - data attached to an %RSSI_EVENT
 * @data: See &enum ieee80211_rssi_event_data
 */
struct ieee80211_rssi_event {
	enum ieee80211_rssi_event_data data;
};

/**
 * enum ieee80211_mlme_event_data - relevant when event type is %MLME_EVENT
 * @AUTH_EVENT: the MLME operation is authentication
 * @ASSOC_EVENT: the MLME operation is association
 * @DEAUTH_RX_EVENT: deauth received..
 * @DEAUTH_TX_EVENT: deauth sent.
 */
enum ieee80211_mlme_event_data {
	AUTH_EVENT,
	ASSOC_EVENT,
	DEAUTH_RX_EVENT,
	DEAUTH_TX_EVENT,
};

/**
 * enum ieee80211_mlme_event_status - relevant when event type is %MLME_EVENT
 * @MLME_SUCCESS: the MLME operation completed successfully.
 * @MLME_DENIED: the MLME operation was denied by the peer.
 * @MLME_TIMEOUT: the MLME operation timed out.
 */
enum ieee80211_mlme_event_status {
	MLME_SUCCESS,
	MLME_DENIED,
	MLME_TIMEOUT,
};

/**
 * struct ieee80211_mlme_event - data attached to an %MLME_EVENT
 * @data: See &enum ieee80211_mlme_event_data
 * @status: See &enum ieee80211_mlme_event_status
 * @reason: the reason code if applicable
 */
struct ieee80211_mlme_event {
	enum ieee80211_mlme_event_data data;
	enum ieee80211_mlme_event_status status;
	u16 reason;
};

/**
 * struct ieee80211_ba_event - data attached for BlockAck related events
 * @sta: pointer to the &ieee80211_sta to which this event relates
 * @tid: the tid
 * @ssn: the starting sequence number (for %BAR_RX_EVENT)
 */
struct ieee80211_ba_event {
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
};

/**
 * struct ieee80211_event - event to be sent to the driver
 * @type: The event itself. See &enum ieee80211_event_type.
 * @rssi: relevant if &type is %RSSI_EVENT
 * @mlme: relevant if &type is %AUTH_EVENT
 * @ba: relevant if &type is %BAR_RX_EVENT or %BA_FRAME_TIMEOUT
 * @u:union holding the fields above
 */
struct ieee80211_event {
	enum ieee80211_event_type type;
	union {
		struct ieee80211_rssi_event rssi;
		struct ieee80211_mlme_event mlme;
		struct ieee80211_ba_event ba;
	} u;
};

/**
 * struct ieee80211_mu_group_data - STA's VHT MU-MIMO group data
 *
 * This structure describes the group id data of VHT MU-MIMO
 *
 * @membership: 64 bits array - a bit is set if station is member of the group
 * @position: 2 bits per group id indicating the position in the group
 */
struct ieee80211_mu_group_data {
	u8 membership[WLAN_MEMBERSHIP_LEN];
	u8 position[WLAN_USER_POSITION_LEN];
};

/**
 * struct ieee80211_bss_conf - holds the BSS's changing parameters
 *
 * This structure keeps information about a BSS (and an association
 * to that BSS) that can change during the lifetime of the BSS.
 *
 * @assoc: association status
 * @ibss_joined: indicates whether this station is part of an IBSS
 *	or not
 * @ibss_creator: indicates if a new IBSS network is being created
 * @aid: association ID number, valid only when @assoc is true
 * @use_cts_prot: use CTS protection
 * @use_short_preamble: use 802.11b short preamble
 * @use_short_slot: use short slot time (only relevant for ERP)
 * @dtim_period: num of beacons before the next DTIM, for beaconing,
 *	valid in station mode only if after the driver was notified
 *	with the %BSS_CHANGED_BEACON_INFO flag, will be non-zero then.
 * @sync_tsf: last beacon's/probe response's TSF timestamp (could be old
 *	as it may have been received during scanning long ago). If the
 *	HW flag %IEEE80211_HW_TIMING_BEACON_ONLY is set, then this can
 *	only come from a beacon, but might not become valid until after
 *	association when a beacon is received (which is notified with the
 *	%BSS_CHANGED_DTIM flag.). See also sync_dtim_count important notice.
 * @sync_device_ts: the device timestamp corresponding to the sync_tsf,
 *	the driver/device can use this to calculate synchronisation
 *	(see @sync_tsf). See also sync_dtim_count important notice.
 * @sync_dtim_count: Only valid when %IEEE80211_HW_TIMING_BEACON_ONLY
 *	is requested, see @sync_tsf/@sync_device_ts.
 *	IMPORTANT: These three sync_* parameters would possibly be out of sync
 *	by the time the driver will use them. The synchronized view is currently
 *	guaranteed only in certain callbacks.
 * @beacon_int: beacon interval
 * @assoc_capability: capabilities taken from assoc resp
 * @basic_rates: bitmap of basic rates, each bit stands for an
 *	index into the rate table configured by the driver in
 *	the current band.
 * @beacon_rate: associated AP's beacon TX rate
 * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
 * @bssid: The BSSID for this BSS
 * @enable_beacon: whether beaconing should be enabled or not
 * @chandef: Channel definition for this BSS -- the hardware might be
 *	configured a higher bandwidth than this BSS uses, for example.
 * @mu_group: VHT MU-MIMO group membership data
 * @ht_operation_mode: HT operation mode like in &struct ieee80211_ht_operation.
 *	This field is only valid when the channel is a wide HT/VHT channel.
 *	Note that with TDLS this can be the case (channel is HT, protection must
 *	be used from this field) even when the BSS association isn't using HT.
 * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value
 *	implies disabled. As with the cfg80211 callback, a change here should
 *	cause an event to be sent indicating where the current value is in
 *	relation to the newly configured threshold.
 * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis
 * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The
 *	may filter ARP queries targeted for other addresses than listed here.
 *	The driver must allow ARP queries targeted for all address listed here
 *	to pass through. An empty list implies no ARP queries need to pass.
 * @arp_addr_cnt: Number of addresses currently on the list. Note that this
 *	may be larger than %IEEE80211_BSS_ARP_ADDR_LIST_LEN (the arp_addr_list
 *	array size), it's up to the driver what to do in that case.
 * @qos: This is a QoS-enabled BSS.
 * @idle: This interface is idle. There's also a global idle flag in the
 *	hardware config which may be more appropriate depending on what
 *	your driver/device needs to do.
 * @ps: power-save mode (STA only). This flag is NOT affected by
 *	offchannel/dynamic_ps operations.
 * @ssid: The SSID of the current vif. Valid in AP and IBSS mode.
 * @ssid_len: Length of SSID given in @ssid.
 * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.
 * @txpower: TX power in dBm
 * @txpower_type: TX power adjustment used to control per packet Transmit
 *	Power Control (TPC) in lower driver for the current vif. In particular
 *	TPC is enabled if value passed in %txpower_type is
 *	NL80211_TX_POWER_LIMITED (allow using less than specified from
 *	userspace), whereas TPC is disabled if %txpower_type is set to
 *	NL80211_TX_POWER_FIXED (use value configured from userspace)
 * @p2p_noa_attr: P2P NoA attribute for P2P powersave
 * @allow_p2p_go_ps: indication for AP or P2P GO interface, whether it's allowed
 *	to use P2P PS mechanism or not. AP/P2P GO is not allowed to use P2P PS
 *	if it has associated clients without P2P PS support.
 */
struct ieee80211_bss_conf {
	const u8 *bssid;
	/* association related data */
	bool assoc, ibss_joined;
	bool ibss_creator;
	u16 aid;
	/* erp related data */
	bool use_cts_prot;
	bool use_short_preamble;
	bool use_short_slot;
	bool enable_beacon;
	u8 dtim_period;
	u16 beacon_int;
	u16 assoc_capability;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	struct ieee80211_rate *beacon_rate;
	int mcast_rate[NUM_NL80211_BANDS];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	u32 cqm_rssi_hyst;
	struct cfg80211_chan_def chandef;
	struct ieee80211_mu_group_data mu_group;
	__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];
	int arp_addr_cnt;
	bool qos;
	bool idle;
	bool ps;
	u8 ssid[IEEE80211_MAX_SSID_LEN];
	size_t ssid_len;
	bool hidden_ssid;
	int txpower;
	enum nl80211_tx_power_setting txpower_type;
	struct ieee80211_p2p_noa_attr p2p_noa_attr;
	bool allow_p2p_go_ps;
};

/**
 * enum mac80211_tx_info_flags - flags to describe transmission information/status
 *
 * These flags are used with the @flags member of &ieee80211_tx_info.
 *
 * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.
 * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence
 *	number to this frame, taking care of not overwriting the fragment
 *	number and increasing the sequence number only when the
 *	IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
 *	assign sequence numbers to QoS-data frames but cannot do so correctly
 *	for non-QoS-data and management frames because beacons need them from
 *	that counter as well and mac80211 cannot guarantee proper sequencing.
 *	If this flag is set, the driver should instruct the hardware to
 *	assign a sequence number to the frame or assign one itself. Cf. IEEE
 *	802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
 *	beacons and always be clear for frames without a sequence number field.
 * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack
 * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination
 *	station
 * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame
 * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon
 * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU
 * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.
 * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted
 *	because the destination STA was in powersave mode. Note that to
 *	avoid race conditions, the filter must be set by the hardware or
 *	firmware upon receiving a frame that indicates that the station
 *	went to sleep (must be done on device to filter frames already on
 *	the queue) and may only be unset after mac80211 gives the OK for
 *	that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
 *	since only then is it guaranteed that no more frames are in the
 *	hardware queue.
 * @IEEE80211_TX_STAT_ACK: Frame was acknowledged
 * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status
 * 	is for the whole aggregation.
 * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,
 * 	so consider using block ack request (BAR).
 * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be
 *	set by rate control algorithms to indicate probe rate, will
 *	be cleared for fragmented frames (except on the last fragment)
 * @IEEE80211_TX_INTFL_OFFCHAN_TX_OK: Internal to mac80211. Used to indicate
 *	that a frame can be transmitted while the queues are stopped for
 *	off-channel operation.
 * @IEEE80211_TX_INTFL_NEED_TXPROCESSING: completely internal to mac80211,
 *	used to indicate that a pending frame requires TX processing before
 *	it can be sent out.
 * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,
 *	used to indicate that a frame was already retried due to PS
 * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,
 *	used to indicate frame should not be encrypted
 * @IEEE80211_TX_CTL_NO_PS_BUFFER: This frame is a response to a poll
 *	frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
 *	be sent although the station is in powersave mode.
 * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the
 *	transmit function after the current frame, this can be used
 *	by drivers to kick the DMA queue only if unset or when the
 *	queue gets full.
 * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted
 *	after TX status because the destination was asleep, it must not
 *	be modified again (no seqno assignment, crypto, etc.)
 * @IEEE80211_TX_INTFL_MLME_CONN_TX: This frame was transmitted by the MLME
 *	code for connection establishment, this indicates that its status
 *	should kick the MLME state machine.
 * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211
 *	MLME command (internal to mac80211 to figure out whether to send TX
 *	status to user space)
 * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame
 * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this
 *	frame and selects the maximum number of streams that it can use.
 * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on
 *	the off-channel channel when a remain-on-channel offload is done
 *	in hardware -- normal packets still flow and are expected to be
 *	handled properly by the device.
 * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP
 *	testing. It will be sent out with incorrect Michael MIC key to allow
 *	TKIP countermeasures to be tested.
 * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
 *	This flag is actually used for management frame especially for P2P
 *	frames not being sent at CCK rate in 2GHz band.
 * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,
 *	when its status is reported the service period ends. For frames in
 *	an SP that mac80211 transmits, it is already set; for driver frames
 *	the driver may set this flag. It is also used to do the same for
 *	PS-Poll responses.
 * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.
 *	This flag is used to send nullfunc frame at minimum rate when
 *	the nullfunc is used for connection monitoring purpose.
 * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it
 *	would be fragmented by size (this is optional, only used for
 *	monitor injection).
 * @IEEE80211_TX_STAT_NOACK_TRANSMITTED: A frame that was marked with
 *	IEEE80211_TX_CTL_NO_ACK has been successfully transmitted without
 *	any errors (like issues specific to the driver/HW).
 *	This flag must not be set for frames that don't request no-ack
 *	behaviour with IEEE80211_TX_CTL_NO_ACK.
 *
 * Note: If you have to add new flags to the enumeration, then don't
 *	 forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.
 */
enum mac80211_tx_info_flags {
	IEEE80211_TX_CTL_REQ_TX_STATUS		= BIT(0),
	IEEE80211_TX_CTL_ASSIGN_SEQ		= BIT(1),
	IEEE80211_TX_CTL_NO_ACK			= BIT(2),
	IEEE80211_TX_CTL_CLEAR_PS_FILT		= BIT(3),
	IEEE80211_TX_CTL_FIRST_FRAGMENT		= BIT(4),
	IEEE80211_TX_CTL_SEND_AFTER_DTIM	= BIT(5),
	IEEE80211_TX_CTL_AMPDU			= BIT(6),
	IEEE80211_TX_CTL_INJECTED		= BIT(7),
	IEEE80211_TX_STAT_TX_FILTERED		= BIT(8),
	IEEE80211_TX_STAT_ACK			= BIT(9),
	IEEE80211_TX_STAT_AMPDU			= BIT(10),
	IEEE80211_TX_STAT_AMPDU_NO_BACK		= BIT(11),
	IEEE80211_TX_CTL_RATE_CTRL_PROBE	= BIT(12),
	IEEE80211_TX_INTFL_OFFCHAN_TX_OK	= BIT(13),
	IEEE80211_TX_INTFL_NEED_TXPROCESSING	= BIT(14),
	IEEE80211_TX_INTFL_RETRIED		= BIT(15),
	IEEE80211_TX_INTFL_DONT_ENCRYPT		= BIT(16),
	IEEE80211_TX_CTL_NO_PS_BUFFER		= BIT(17),
	IEEE80211_TX_CTL_MORE_FRAMES		= BIT(18),
	IEEE80211_TX_INTFL_RETRANSMISSION	= BIT(19),
	IEEE80211_TX_INTFL_MLME_CONN_TX		= BIT(20),
	IEEE80211_TX_INTFL_NL80211_FRAME_TX	= BIT(21),
	IEEE80211_TX_CTL_LDPC			= BIT(22),
	IEEE80211_TX_CTL_STBC			= BIT(23) | BIT(24),
	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
	IEEE80211_TX_STATUS_EOSP		= BIT(28),
	IEEE80211_TX_CTL_USE_MINRATE		= BIT(29),
	IEEE80211_TX_CTL_DONTFRAG		= BIT(30),
	IEEE80211_TX_STAT_NOACK_TRANSMITTED	= BIT(31),
};

#define IEEE80211_TX_CTL_STBC_SHIFT		23

/**
 * enum mac80211_tx_control_flags - flags to describe transmit control
 *
 * @IEEE80211_TX_CTRL_PORT_CTRL_PROTO: this frame is a port control
 *	protocol frame (e.g. EAP)
 * @IEEE80211_TX_CTRL_PS_RESPONSE: This frame is a response to a poll
 *	frame (PS-Poll or uAPSD).
 * @IEEE80211_TX_CTRL_RATE_INJECT: This frame is injected with rate information
 * @IEEE80211_TX_CTRL_AMSDU: This frame is an A-MSDU frame
 * @IEEE80211_TX_CTRL_FAST_XMIT: This frame is going through the fast_xmit path
 *
 * These flags are used in tx_info->control.flags.
 */
enum mac80211_tx_control_flags {
	IEEE80211_TX_CTRL_PORT_CTRL_PROTO	= BIT(0),
	IEEE80211_TX_CTRL_PS_RESPONSE		= BIT(1),
	IEEE80211_TX_CTRL_RATE_INJECT		= BIT(2),
	IEEE80211_TX_CTRL_AMSDU			= BIT(3),
	IEEE80211_TX_CTRL_FAST_XMIT		= BIT(4),
};

/*
 * This definition is used as a mask to clear all temporary flags, which are
 * set by the tx handlers for each transmission attempt by the mac80211 stack.
 */
#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |		      \
	IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \
	IEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |	      \
	IEEE80211_TX_STAT_TX_FILTERED |	IEEE80211_TX_STAT_ACK |		      \
	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \
	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)

/**
 * enum mac80211_rate_control_flags - per-rate flags set by the
 *	Rate Control algorithm.
 *
 * These flags are set by the Rate control algorithm for each rate during tx,
 * in the @flags member of struct ieee80211_tx_rate.
 *
 * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.
 * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.
 *	This is set if the current BSS requires ERP protection.
 * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.
 * @IEEE80211_TX_RC_MCS: HT rate.
 * @IEEE80211_TX_RC_VHT_MCS: VHT MCS rate, in this case the idx field is split
 *	into a higher 4 bits (Nss) and lower 4 bits (MCS number)
 * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in
 *	Greenfield mode.
 * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.
 * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission
 * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission
 *	(80+80 isn't supported yet)
 * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the
 *	adjacent 20 MHz channels, if the current channel type is
 *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
 * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.
 */
enum mac80211_rate_control_flags {
	IEEE80211_TX_RC_USE_RTS_CTS		= BIT(0),
	IEEE80211_TX_RC_USE_CTS_PROTECT		= BIT(1),
	IEEE80211_TX_RC_USE_SHORT_PREAMBLE	= BIT(2),

	/* rate index is an HT/VHT MCS instead of an index */
	IEEE80211_TX_RC_MCS			= BIT(3),
	IEEE80211_TX_RC_GREEN_FIELD		= BIT(4),
	IEEE80211_TX_RC_40_MHZ_WIDTH		= BIT(5),
	IEEE80211_TX_RC_DUP_DATA		= BIT(6),
	IEEE80211_TX_RC_SHORT_GI		= BIT(7),
	IEEE80211_TX_RC_VHT_MCS			= BIT(8),
	IEEE80211_TX_RC_80_MHZ_WIDTH		= BIT(9),
	IEEE80211_TX_RC_160_MHZ_WIDTH		= BIT(10),
};


/* there are 40 bytes if you don't need the rateset to be kept */
#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40

/* if you do need the rateset, then you have less space */
#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24

/* maximum number of rate stages */
#define IEEE80211_TX_MAX_RATES	4

/* maximum number of rate table entries */
#define IEEE80211_TX_RATE_TABLE_SIZE	4

/**
 * struct ieee80211_tx_rate - rate selection/status
 *
 * @idx: rate index to attempt to send with
 * @flags: rate control flags (&enum mac80211_rate_control_flags)
 * @count: number of tries in this rate before going to the next rate
 *
 * A value of -1 for @idx indicates an invalid rate and, if used
 * in an array of retry rates, that no more rates should be tried.
 *
 * When used for transmit status reporting, the driver should
 * always report the rate along with the flags it used.
 *
 * &struct ieee80211_tx_info contains an array of these structs
 * in the control information, and it will be filled by the rate
 * control algorithm according to what should be sent. For example,
 * if this array contains, in the format { <idx>, <count> } the
 * information::
 *
 *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
 *
 * then this means that the frame should be transmitted
 * up to twice at rate 3, up to twice at rate 2, and up to four
 * times at rate 1 if it doesn't get acknowledged. Say it gets
 * acknowledged by the peer after the fifth attempt, the status
 * information should then contain::
 *
 *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
 *
 * since it was transmitted twice at rate 3, twice at rate 2
 * and once at rate 1 after which we received an acknowledgement.
 */
struct ieee80211_tx_rate {
	s8 idx;
	u16 count:5,
	    flags:11;
} __packed;

#define IEEE80211_MAX_TX_RETRY		31

static inline void ieee80211_rate_set_vht(struct ieee80211_tx_rate *rate,
					  u8 mcs, u8 nss)
{
	WARN_ON(mcs & ~0xF);
	WARN_ON((nss - 1) & ~0x7);
	rate->idx = ((nss - 1) << 4) | mcs;
}

static inline u8
ieee80211_rate_get_vht_mcs(const struct ieee80211_tx_rate *rate)
{
	return rate->idx & 0xF;
}

static inline u8
ieee80211_rate_get_vht_nss(const struct ieee80211_tx_rate *rate)
{
	return (rate->idx >> 4) + 1;
}

/**
 * struct ieee80211_tx_info - skb transmit information
 *
 * This structure is placed in skb->cb for three uses:
 *  (1) mac80211 TX control - mac80211 tells the driver what to do
 *  (2) driver internal use (if applicable)
 *  (3) TX status information - driver tells mac80211 what happened
 *
 * @flags: transmit info flags, defined above
 * @band: the band to transmit on (use for checking for races)
 * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC
 * @ack_frame_id: internal frame ID for TX status, used internally
 * @control: union for control data
 * @status: union for status data
 * @driver_data: array of driver_data pointers
 * @ampdu_ack_len: number of acked aggregated frames.
 * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
 * @ampdu_len: number of aggregated frames.
 * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
 * @ack_signal: signal strength of the ACK frame
 */
struct ieee80211_tx_info {
	/* common information */
	u32 flags;
	u8 band;

	u8 hw_queue;

	u16 ack_frame_id;

	union {
		struct {
			union {
				/* rate control */
				struct {
					struct ieee80211_tx_rate rates[
						IEEE80211_TX_MAX_RATES];
					s8 rts_cts_rate_idx;
					u8 use_rts:1;
					u8 use_cts_prot:1;
					u8 short_preamble:1;
					u8 skip_table:1;
					/* 2 bytes free */
				};
				/* only needed before rate control */
				unsigned long jiffies;
			};
			/* NB: vif can be NULL for injected frames */
			struct ieee80211_vif *vif;
			struct ieee80211_key_conf *hw_key;
			u32 flags;
			codel_time_t enqueue_time;
		} control;
		struct {
			u64 cookie;
		} ack;
		struct {
			struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];
			s32 ack_signal;
			u8 ampdu_ack_len;
			u8 ampdu_len;
			u8 antenna;
			u16 tx_time;
			void *status_driver_data[19 / sizeof(void *)];
		} status;
		struct {
			struct ieee80211_tx_rate driver_rates[
				IEEE80211_TX_MAX_RATES];
			u8 pad[4];

			void *rate_driver_data[
				IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];
		};
		void *driver_data[
			IEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];
	};
};

/**
 * struct ieee80211_scan_ies - descriptors for different blocks of IEs
 *
 * This structure is used to point to different blocks of IEs in HW scan
 * and scheduled scan. These blocks contain the IEs passed by userspace
 * and the ones generated by mac80211.
 *
 * @ies: pointers to band specific IEs.
 * @len: lengths of band_specific IEs.
 * @common_ies: IEs for all bands (especially vendor specific ones)
 * @common_ie_len: length of the common_ies
 */
struct ieee80211_scan_ies {
	const u8 *ies[NUM_NL80211_BANDS];
	size_t len[NUM_NL80211_BANDS];
	const u8 *common_ies;
	size_t common_ie_len;
};


static inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)
{
	return (struct ieee80211_tx_info *)skb->cb;
}

static inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)
{
	return (struct ieee80211_rx_status *)skb->cb;
}

/**
 * ieee80211_tx_info_clear_status - clear TX status
 *
 * @info: The &struct ieee80211_tx_info to be cleared.
 *
 * When the driver passes an skb back to mac80211, it must report
 * a number of things in TX status. This function clears everything
 * in the TX status but the rate control information (it does clear
 * the count since you need to fill that in anyway).
 *
 * NOTE: You can only use this function if you do NOT use
 *	 info->driver_data! Use info->rate_driver_data
 *	 instead if you need only the less space that allows.
 */
static inline void
ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
{
	int i;

	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=
		     offsetof(struct ieee80211_tx_info, control.rates));
	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=
		     offsetof(struct ieee80211_tx_info, driver_rates));
	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);
	/* clear the rate counts */
	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
		info->status.rates[i].count = 0;

	BUILD_BUG_ON(
	    offsetof(struct ieee80211_tx_info, status.ack_signal) != 20);
	memset(&info->status.ampdu_ack_len, 0,
	       sizeof(struct ieee80211_tx_info) -
	       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));
}


/**
 * enum mac80211_rx_flags - receive flags
 *
 * These flags are used with the @flag member of &struct ieee80211_rx_status.
 * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.
 *	Use together with %RX_FLAG_MMIC_STRIPPED.
 * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.
 * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,
 *	verification has been done by the hardware.
 * @RX_FLAG_IV_STRIPPED: The IV and ICV are stripped from this frame.
 *	If this flag is set, the stack cannot do any replay detection
 *	hence the driver or hardware will have to do that.
 * @RX_FLAG_PN_VALIDATED: Currently only valid for CCMP/GCMP frames, this
 *	flag indicates that the PN was verified for replay protection.
 *	Note that this flag is also currently only supported when a frame
 *	is also decrypted (ie. @RX_FLAG_DECRYPTED must be set)
 * @RX_FLAG_DUP_VALIDATED: The driver should set this flag if it did
 *	de-duplication by itself.
 * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on
 *	the frame.
 * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on
 *	the frame.
 * @RX_FLAG_MACTIME_START: The timestamp passed in the RX status (@mactime
 *	field) is valid and contains the time the first symbol of the MPDU
 *	was received. This is useful in monitor mode and for proper IBSS
 *	merging.
 * @RX_FLAG_MACTIME_END: The timestamp passed in the RX status (@mactime
 *	field) is valid and contains the time the last symbol of the MPDU
 *	(including FCS) was received.
 * @RX_FLAG_MACTIME_PLCP_START: The timestamp passed in the RX status (@mactime
 *	field) is valid and contains the time the SYNC preamble was received.
 * @RX_FLAG_SHORTPRE: Short preamble was used for this frame
 * @RX_FLAG_HT: HT MCS was used and rate_idx is MCS index
 * @RX_FLAG_VHT: VHT MCS was used and rate_index is MCS index
 * @RX_FLAG_40MHZ: HT40 (40 MHz) was used
 * @RX_FLAG_SHORT_GI: Short guard interval was used
 * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.
 *	Valid only for data frames (mainly A-MPDU)
 * @RX_FLAG_HT_GF: This frame was received in a HT-greenfield transmission, if
 *	the driver fills this value it should add %IEEE80211_RADIOTAP_MCS_HAVE_FMT
 *	to hw.radiotap_mcs_details to advertise that fact
 * @RX_FLAG_AMPDU_DETAILS: A-MPDU details are known, in particular the reference
 *	number (@ampdu_reference) must be populated and be a distinct number for
 *	each A-MPDU
 * @RX_FLAG_AMPDU_LAST_KNOWN: last subframe is known, should be set on all
 *	subframes of a single A-MPDU
 * @RX_FLAG_AMPDU_IS_LAST: this subframe is the last subframe of the A-MPDU
 * @RX_FLAG_AMPDU_DELIM_CRC_ERROR: A delimiter CRC error has been detected
 *	on this subframe
 * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC
 *	is stored in the @ampdu_delimiter_crc field)
 * @RX_FLAG_MIC_STRIPPED: The mic was stripped of this packet. Decryption was
 *	done by the hardware
 * @RX_FLAG_LDPC: LDPC was used
 * @RX_FLAG_ONLY_MONITOR: Report frame only to monitor interfaces without
 *	processing it in any regular way.
 *	This is useful if drivers offload some frames but still want to report
 *	them for sniffing purposes.
 * @RX_FLAG_SKIP_MONITOR: Process and report frame to all interfaces except
 *	monitor interfaces.
 *	This is useful if drivers offload some frames but still want to report
 *	them for sniffing purposes.
 * @RX_FLAG_STBC_MASK: STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3
 * @RX_FLAG_10MHZ: 10 MHz (half channel) was used
 * @RX_FLAG_5MHZ: 5 MHz (quarter channel) was used
 * @RX_FLAG_AMSDU_MORE: Some drivers may prefer to report separate A-MSDU
 *	subframes instead of a one huge frame for performance reasons.
 *	All, but the last MSDU from an A-MSDU should have this flag set. E.g.
 *	if an A-MSDU has 3 frames, the first 2 must have the flag set, while
 *	the 3rd (last) one must not have this flag set. The flag is used to
 *	deal with retransmission/duplication recovery properly since A-MSDU
 *	subframes share the same sequence number. Reported subframes can be
 *	either regular MSDU or singly A-MSDUs. Subframes must not be
 *	interleaved with other frames.
 * @RX_FLAG_RADIOTAP_VENDOR_DATA: This frame contains vendor-specific
 *	radiotap data in the skb->data (before the frame) as described by
 *	the &struct ieee80211_vendor_radiotap.
 * @RX_FLAG_ALLOW_SAME_PN: Allow the same PN as same packet before.
 *	This is used for AMSDU subframes which can have the same PN as
 *	the first subframe.
 * @RX_FLAG_ICV_STRIPPED: The ICV is stripped from this frame. CRC checking must
 *	be done in the hardware.
 */
enum mac80211_rx_flags {
	RX_FLAG_MMIC_ERROR		= BIT(0),
	RX_FLAG_DECRYPTED		= BIT(1),
	RX_FLAG_MACTIME_PLCP_START	= BIT(2),
	RX_FLAG_MMIC_STRIPPED		= BIT(3),
	RX_FLAG_IV_STRIPPED		= BIT(4),
	RX_FLAG_FAILED_FCS_CRC		= BIT(5),
	RX_FLAG_FAILED_PLCP_CRC 	= BIT(6),
	RX_FLAG_MACTIME_START		= BIT(7),
	RX_FLAG_SHORTPRE		= BIT(8),
	RX_FLAG_HT			= BIT(9),
	RX_FLAG_40MHZ			= BIT(10),
	RX_FLAG_SHORT_GI		= BIT(11),
	RX_FLAG_NO_SIGNAL_VAL		= BIT(12),
	RX_FLAG_HT_GF			= BIT(13),
	RX_FLAG_AMPDU_DETAILS		= BIT(14),
	RX_FLAG_PN_VALIDATED		= BIT(15),
	RX_FLAG_DUP_VALIDATED		= BIT(16),
	RX_FLAG_AMPDU_LAST_KNOWN	= BIT(17),
	RX_FLAG_AMPDU_IS_LAST		= BIT(18),
	RX_FLAG_AMPDU_DELIM_CRC_ERROR	= BIT(19),
	RX_FLAG_AMPDU_DELIM_CRC_KNOWN	= BIT(20),
	RX_FLAG_MACTIME_END		= BIT(21),
	RX_FLAG_VHT			= BIT(22),
	RX_FLAG_LDPC			= BIT(23),
	RX_FLAG_ONLY_MONITOR		= BIT(24),
	RX_FLAG_SKIP_MONITOR		= BIT(25),
	RX_FLAG_STBC_MASK		= BIT(26) | BIT(27),
	RX_FLAG_10MHZ			= BIT(28),
	RX_FLAG_5MHZ			= BIT(29),
	RX_FLAG_AMSDU_MORE		= BIT(30),
	RX_FLAG_RADIOTAP_VENDOR_DATA	= BIT(31),
	RX_FLAG_MIC_STRIPPED		= BIT_ULL(32),
	RX_FLAG_ALLOW_SAME_PN		= BIT_ULL(33),
	RX_FLAG_ICV_STRIPPED		= BIT_ULL(34),
};

#define RX_FLAG_STBC_SHIFT		26

/**
 * enum mac80211_rx_vht_flags - receive VHT flags
 *
 * These flags are used with the @vht_flag member of
 *	&struct ieee80211_rx_status.
 * @RX_VHT_FLAG_80MHZ: 80 MHz was used
 * @RX_VHT_FLAG_160MHZ: 160 MHz was used
 * @RX_VHT_FLAG_BF: packet was beamformed
 */

enum mac80211_rx_vht_flags {
	RX_VHT_FLAG_80MHZ		= BIT(0),
	RX_VHT_FLAG_160MHZ		= BIT(1),
	RX_VHT_FLAG_BF			= BIT(2),
};

/**
 * struct ieee80211_rx_status - receive status
 *
 * The low-level driver should provide this information (the subset
 * supported by hardware) to the 802.11 code with each received
 * frame, in the skb's control buffer (cb).
 *
 * @mactime: value in microseconds of the 64-bit Time Synchronization Function
 * 	(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
 * @boottime_ns: CLOCK_BOOTTIME timestamp the frame was received at, this is
 *	needed only for beacons and probe responses that update the scan cache.
 * @device_timestamp: arbitrary timestamp for the device, mac80211 doesn't use
 *	it but can store it and pass it back to the driver for synchronisation
 * @band: the active band when this frame was received
 * @freq: frequency the radio was tuned to when receiving this frame, in MHz
 *	This field must be set for management frames, but isn't strictly needed
 *	for data (other) frames - for those it only affects radiotap reporting.
 * @signal: signal strength when receiving this frame, either in dBm, in dB or
 *	unspecified depending on the hardware capabilities flags
 *	@IEEE80211_HW_SIGNAL_*
 * @chains: bitmask of receive chains for which separate signal strength
 *	values were filled.
 * @chain_signal: per-chain signal strength, in dBm (unlike @signal, doesn't
 *	support dB or unspecified units)
 * @antenna: antenna used
 * @rate_idx: index of data rate into band's supported rates or MCS index if
 *	HT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)
 * @vht_nss: number of streams (VHT only)
 * @flag: %RX_FLAG_\*
 * @vht_flag: %RX_VHT_FLAG_\*
 * @rx_flags: internal RX flags for mac80211
 * @ampdu_reference: A-MPDU reference number, must be a different value for
 *	each A-MPDU but the same for each subframe within one A-MPDU
 * @ampdu_delimiter_crc: A-MPDU delimiter CRC
 */
struct ieee80211_rx_status {
	u64 mactime;
	u64 boottime_ns;
	u32 device_timestamp;
	u32 ampdu_reference;
	u64 flag;
	u16 freq;
	u8 vht_flag;
	u8 rate_idx;
	u8 vht_nss;
	u8 rx_flags;
	u8 band;
	u8 antenna;
	s8 signal;
	u8 chains;
	s8 chain_signal[IEEE80211_MAX_CHAINS];
	u8 ampdu_delimiter_crc;
};

/**
 * struct ieee80211_vendor_radiotap - vendor radiotap data information
 * @present: presence bitmap for this vendor namespace
 *	(this could be extended in the future if any vendor needs more
 *	 bits, the radiotap spec does allow for that)
 * @align: radiotap vendor namespace alignment. This defines the needed
 *	alignment for the @data field below, not for the vendor namespace
 *	description itself (which has a fixed 2-byte alignment)
 *	Must be a power of two, and be set to at least 1!
 * @oui: radiotap vendor namespace OUI
 * @subns: radiotap vendor sub namespace
 * @len: radiotap vendor sub namespace skip length, if alignment is done
 *	then that's added to this, i.e. this is only the length of the
 *	@data field.
 * @pad: number of bytes of padding after the @data, this exists so that
 *	the skb data alignment can be preserved even if the data has odd
 *	length
 * @data: the actual vendor namespace data
 *
 * This struct, including the vendor data, goes into the skb->data before
 * the 802.11 header. It's split up in mac80211 using the align/oui/subns
 * data.
 */
struct ieee80211_vendor_radiotap {
	u32 present;
	u8 align;
	u8 oui[3];
	u8 subns;
	u8 pad;
	u16 len;
	u8 data[];
} __packed;

/**
 * enum ieee80211_conf_flags - configuration flags
 *
 * Flags to define PHY configuration options
 *
 * @IEEE80211_CONF_MONITOR: there's a monitor interface present -- use this
 *	to determine for example whether to calculate timestamps for packets
 *	or not, do not use instead of filter flags!
 * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).
 *	This is the power save mode defined by IEEE 802.11-2007 section 11.2,
 *	meaning that the hardware still wakes up for beacons, is able to
 *	transmit frames and receive the possible acknowledgment frames.
 *	Not to be confused with hardware specific wakeup/sleep states,
 *	driver is responsible for that. See the section "Powersave support"
 *	for more.
 * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set
 *	the driver should be prepared to handle configuration requests but
 *	may turn the device off as much as possible. Typically, this flag will
 *	be set when an interface is set UP but not associated or scanning, but
 *	it can also be unset in that case when monitor interfaces are active.
 * @IEEE80211_CONF_OFFCHANNEL: The device is currently not on its main
 *	operating channel.
 */
enum ieee80211_conf_flags {
	IEEE80211_CONF_MONITOR		= (1<<0),
	IEEE80211_CONF_PS		= (1<<1),
	IEEE80211_CONF_IDLE		= (1<<2),
	IEEE80211_CONF_OFFCHANNEL	= (1<<3),
};


/**
 * enum ieee80211_conf_changed - denotes which configuration changed
 *
 * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed
 * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed
 * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed
 * @IEEE80211_CONF_CHANGE_POWER: the TX power changed
 * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed
 * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed
 * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed
 * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed
 *	Note that this is only valid if channel contexts are not used,
 *	otherwise each channel context has the number of chains listed.
 */
enum ieee80211_conf_changed {
	IEEE80211_CONF_CHANGE_SMPS		= BIT(1),
	IEEE80211_CONF_CHANGE_LISTEN_INTERVAL	= BIT(2),
	IEEE80211_CONF_CHANGE_MONITOR		= BIT(3),
	IEEE80211_CONF_CHANGE_PS		= BIT(4),
	IEEE80211_CONF_CHANGE_POWER		= BIT(5),
	IEEE80211_CONF_CHANGE_CHANNEL		= BIT(6),
	IEEE80211_CONF_CHANGE_RETRY_LIMITS	= BIT(7),
	IEEE80211_CONF_CHANGE_IDLE		= BIT(8),
};

/**
 * enum ieee80211_smps_mode - spatial multiplexing power save mode
 *
 * @IEEE80211_SMPS_AUTOMATIC: automatic
 * @IEEE80211_SMPS_OFF: off
 * @IEEE80211_SMPS_STATIC: static
 * @IEEE80211_SMPS_DYNAMIC: dynamic
 * @IEEE80211_SMPS_NUM_MODES: internal, don't use
 */
enum ieee80211_smps_mode {
	IEEE80211_SMPS_AUTOMATIC,
	IEEE80211_SMPS_OFF,
	IEEE80211_SMPS_STATIC,
	IEEE80211_SMPS_DYNAMIC,

	/* keep last */
	IEEE80211_SMPS_NUM_MODES,
};

/**
 * struct ieee80211_conf - configuration of the device
 *
 * This struct indicates how the driver shall configure the hardware.
 *
 * @flags: configuration flags defined above
 *
 * @listen_interval: listen interval in units of beacon interval
 * @ps_dtim_period: The DTIM period of the AP we're connected to, for use
 *	in power saving. Power saving will not be enabled until a beacon
 *	has been received and the DTIM period is known.
 * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the
 *	powersave documentation below. This variable is valid only when
 *	the CONF_PS flag is set.
 *
 * @power_level: requested transmit power (in dBm), backward compatibility
 *	value only that is set to the minimum of all interfaces
 *
 * @chandef: the channel definition to tune to
 * @radar_enabled: whether radar detection is enabled
 *
 * @long_frame_max_tx_count: Maximum number of transmissions for a "long" frame
 *	(a frame not RTS protected), called "dot11LongRetryLimit" in 802.11,
 *	but actually means the number of transmissions not the number of retries
 * @short_frame_max_tx_count: Maximum number of transmissions for a "short"
 *	frame, called "dot11ShortRetryLimit" in 802.11, but actually means the
 *	number of transmissions not the number of retries
 *
 * @smps_mode: spatial multiplexing powersave mode; note that
 *	%IEEE80211_SMPS_STATIC is used when the device is not
 *	configured for an HT channel.
 *	Note that this is only valid if channel contexts are not used,
 *	otherwise each channel context has the number of chains listed.
 */
struct ieee80211_conf {
	u32 flags;
	int power_level, dynamic_ps_timeout;

	u16 listen_interval;
	u8 ps_dtim_period;

	u8 long_frame_max_tx_count, short_frame_max_tx_count;

	struct cfg80211_chan_def chandef;
	bool radar_enabled;
	enum ieee80211_smps_mode smps_mode;
};

/**
 * struct ieee80211_channel_switch - holds the channel switch data
 *
 * The information provided in this structure is required for channel switch
 * operation.
 *
 * @timestamp: value in microseconds of the 64-bit Time Synchronization
 *	Function (TSF) timer when the frame containing the channel switch
 *	announcement was received. This is simply the rx.mactime parameter
 *	the driver passed into mac80211.
 * @device_timestamp: arbitrary timestamp for the device, this is the
 *	rx.device_timestamp parameter the driver passed to mac80211.
 * @block_tx: Indicates whether transmission must be blocked before the
 *	scheduled channel switch, as indicated by the AP.
 * @chandef: the new channel to switch to
 * @count: the number of TBTT's until the channel switch event
 */
struct ieee80211_channel_switch {
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	struct cfg80211_chan_def chandef;
	u8 count;
};

/**
 * enum ieee80211_vif_flags - virtual interface flags
 *
 * @IEEE80211_VIF_BEACON_FILTER: the device performs beacon filtering
 *	on this virtual interface to avoid unnecessary CPU wakeups
 * @IEEE80211_VIF_SUPPORTS_CQM_RSSI: the device can do connection quality
 *	monitoring on this virtual interface -- i.e. it can monitor
 *	connection quality related parameters, such as the RSSI level and
 *	provide notifications if configured trigger levels are reached.
 * @IEEE80211_VIF_SUPPORTS_UAPSD: The device can do U-APSD for this
 *	interface. This flag should be set during interface addition,
 *	but may be set/cleared as late as authentication to an AP. It is
 *	only valid for managed/station mode interfaces.
 * @IEEE80211_VIF_GET_NOA_UPDATE: request to handle NOA attributes
 *	and send P2P_PS notification to the driver if NOA changed, even
 *	this is not pure P2P vif.
 */
enum ieee80211_vif_flags {
	IEEE80211_VIF_BEACON_FILTER		= BIT(0),
	IEEE80211_VIF_SUPPORTS_CQM_RSSI		= BIT(1),
	IEEE80211_VIF_SUPPORTS_UAPSD		= BIT(2),
	IEEE80211_VIF_GET_NOA_UPDATE		= BIT(3),
};

/**
 * struct ieee80211_vif - per-interface data
 *
 * Data in this structure is continually present for driver
 * use during the life of a virtual interface.
 *
 * @type: type of this virtual interface
 * @bss_conf: BSS configuration for this interface, either our own
 *	or the BSS we're associated to
 * @addr: address of this interface
 * @p2p: indicates whether this AP or STA interface is a p2p
 *	interface, i.e. a GO or p2p-sta respectively
 * @csa_active: marks whether a channel switch is going on. Internally it is
 *	write-protected by sdata_lock and local->mtx so holding either is fine
 *	for read access.
 * @mu_mimo_owner: indicates interface owns MU-MIMO capability
 * @driver_flags: flags/capabilities the driver has for this interface,
 *	these need to be set (or cleared) when the interface is added
 *	or, if supported by the driver, the interface type is changed
 *	at runtime, mac80211 will never touch this field
 * @hw_queue: hardware queue for each AC
 * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only
 * @chanctx_conf: The channel context this interface is assigned to, or %NULL
 *	when it is not assigned. This pointer is RCU-protected due to the TX
 *	path needing to access it; even though the netdev carrier will always
 *	be off when it is %NULL there can still be races and packets could be
 *	processed after it switches back to %NULL.
 * @debugfs_dir: debugfs dentry, can be used by drivers to create own per
 *	interface debug files. Note that it will be NULL for the virtual
 *	monitor interface (if that is requested.)
 * @probe_req_reg: probe requests should be reported to mac80211 for this
 *	interface.
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void \*).
 * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)
 */
struct ieee80211_vif {
	enum nl80211_iftype type;
	struct ieee80211_bss_conf bss_conf;
	u8 addr[ETH_ALEN];
	bool p2p;
	bool csa_active;
	bool mu_mimo_owner;

	u8 cab_queue;
	u8 hw_queue[IEEE80211_NUM_ACS];

	struct ieee80211_txq *txq;

	struct ieee80211_chanctx_conf __rcu *chanctx_conf;

	u32 driver_flags;

#ifdef CONFIG_MAC80211_DEBUGFS
	struct dentry *debugfs_dir;
#endif

	unsigned int probe_req_reg;

	/* must be last */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
{
#ifdef CONFIG_MAC80211_MESH
	return vif->type == NL80211_IFTYPE_MESH_POINT;
#endif
	return false;
}

/**
 * wdev_to_ieee80211_vif - return a vif struct from a wdev
 * @wdev: the wdev to get the vif for
 *
 * This can be used by mac80211 drivers with direct cfg80211 APIs
 * (like the vendor commands) that get a wdev.
 *
 * Note that this function may return %NULL if the given wdev isn't
 * associated with a vif that the driver knows about (e.g. monitor
 * or AP_VLAN interfaces.)
 */
struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);

/**
 * ieee80211_vif_to_wdev - return a wdev struct from a vif
 * @vif: the vif to get the wdev for
 *
 * This can be used by mac80211 drivers with direct cfg80211 APIs
 * (like the vendor commands) that needs to get the wdev for a vif.
 *
 * Note that this function may return %NULL if the given wdev isn't
 * associated with a vif that the driver knows about (e.g. monitor
 * or AP_VLAN interfaces.)
 */
struct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif);

/**
 * enum ieee80211_key_flags - key flags
 *
 * These flags are used for communication about keys between the driver
 * and mac80211, with the @flags parameter of &struct ieee80211_key_conf.
 *
 * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the
 *	driver to indicate that it requires IV generation for this
 *	particular key. Setting this flag does not necessarily mean that SKBs
 *	will have sufficient tailroom for ICV or MIC.
 * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by
 *	the driver for a TKIP key if it requires Michael MIC
 *	generation in software.
 * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates
 *	that the key is pairwise rather then a shared key.
 * @IEEE80211_KEY_FLAG_SW_MGMT_TX: This flag should be set by the driver for a
 *	CCMP/GCMP key if it requires CCMP/GCMP encryption of management frames
 *	(MFP) to be done in software.
 * @IEEE80211_KEY_FLAG_PUT_IV_SPACE: This flag should be set by the driver
 *	if space should be prepared for the IV, but the IV
 *	itself should not be generated. Do not set together with
 *	@IEEE80211_KEY_FLAG_GENERATE_IV on the same key. Setting this flag does
 *	not necessarily mean that SKBs will have sufficient tailroom for ICV or
 *	MIC.
 * @IEEE80211_KEY_FLAG_RX_MGMT: This key will be used to decrypt received
 *	management frames. The flag can help drivers that have a hardware
 *	crypto implementation that doesn't deal with management frames
 *	properly by allowing them to not upload the keys to hardware and
 *	fall back to software crypto. Note that this flag deals only with
 *	RX, if your crypto engine can't deal with TX you can also set the
 *	%IEEE80211_KEY_FLAG_SW_MGMT_TX flag to encrypt such frames in SW.
 * @IEEE80211_KEY_FLAG_GENERATE_IV_MGMT: This flag should be set by the
 *	driver for a CCMP/GCMP key to indicate that is requires IV generation
 *	only for managment frames (MFP).
 * @IEEE80211_KEY_FLAG_RESERVE_TAILROOM: This flag should be set by the
 *	driver for a key to indicate that sufficient tailroom must always
 *	be reserved for ICV or MIC, even when HW encryption is enabled.
 */
enum ieee80211_key_flags {
	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT	= BIT(0),
	IEEE80211_KEY_FLAG_GENERATE_IV		= BIT(1),
	IEEE80211_KEY_FLAG_GENERATE_MMIC	= BIT(2),
	IEEE80211_KEY_FLAG_PAIRWISE		= BIT(3),
	IEEE80211_KEY_FLAG_SW_MGMT_TX		= BIT(4),
	IEEE80211_KEY_FLAG_PUT_IV_SPACE		= BIT(5),
	IEEE80211_KEY_FLAG_RX_MGMT		= BIT(6),
	IEEE80211_KEY_FLAG_RESERVE_TAILROOM	= BIT(7),
};

/**
 * struct ieee80211_key_conf - key information
 *
 * This key information is given by mac80211 to the driver by
 * the set_key() callback in &struct ieee80211_ops.
 *
 * @hw_key_idx: To be set by the driver, this is the key index the driver
 *	wants to be given when a frame is transmitted and needs to be
 *	encrypted in hardware.
 * @cipher: The key's cipher suite selector.
 * @tx_pn: PN used for TX keys, may be used by the driver as well if it
 *	needs to do software PN assignment by itself (e.g. due to TSO)
 * @flags: key flags, see &enum ieee80211_key_flags.
 * @keyidx: the key index (0-3)
 * @keylen: key material length
 * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)
 * 	data block:
 * 	- Temporal Encryption Key (128 bits)
 * 	- Temporal Authenticator Tx MIC Key (64 bits)
 * 	- Temporal Authenticator Rx MIC Key (64 bits)
 * @icv_len: The ICV length for this key type
 * @iv_len: The IV length for this key type
 */
struct ieee80211_key_conf {
	atomic64_t tx_pn;
	u32 cipher;
	u8 icv_len;
	u8 iv_len;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	u8 keylen;
	u8 key[0];
};

#define IEEE80211_MAX_PN_LEN	16

#define TKIP_PN_TO_IV16(pn) ((u16)(pn & 0xffff))
#define TKIP_PN_TO_IV32(pn) ((u32)((pn >> 16) & 0xffffffff))

/**
 * struct ieee80211_key_seq - key sequence counter
 *
 * @tkip: TKIP data, containing IV32 and IV16 in host byte order
 * @ccmp: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @aes_cmac: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @aes_gmac: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @gcmp: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @hw: data for HW-only (e.g. cipher scheme) keys
 */
struct ieee80211_key_seq {
	union {
		struct {
			u32 iv32;
			u16 iv16;
		} tkip;
		struct {
			u8 pn[6];
		} ccmp;
		struct {
			u8 pn[6];
		} aes_cmac;
		struct {
			u8 pn[6];
		} aes_gmac;
		struct {
			u8 pn[6];
		} gcmp;
		struct {
			u8 seq[IEEE80211_MAX_PN_LEN];
			u8 seq_len;
		} hw;
	};
};

/**
 * struct ieee80211_cipher_scheme - cipher scheme
 *
 * This structure contains a cipher scheme information defining
 * the secure packet crypto handling.
 *
 * @cipher: a cipher suite selector
 * @iftype: a cipher iftype bit mask indicating an allowed cipher usage
 * @hdr_len: a length of a security header used the cipher
 * @pn_len: a length of a packet number in the security header
 * @pn_off: an offset of pn from the beginning of the security header
 * @key_idx_off: an offset of key index byte in the security header
 * @key_idx_mask: a bit mask of key_idx bits
 * @key_idx_shift: a bit shift needed to get key_idx
 *     key_idx value calculation:
 *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift
 * @mic_len: a mic length in bytes
 */
struct ieee80211_cipher_scheme {
	u32 cipher;
	u16 iftype;
	u8 hdr_len;
	u8 pn_len;
	u8 pn_off;
	u8 key_idx_off;
	u8 key_idx_mask;
	u8 key_idx_shift;
	u8 mic_len;
};

/**
 * enum set_key_cmd - key command
 *
 * Used with the set_key() callback in &struct ieee80211_ops, this
 * indicates whether a key is being removed or added.
 *
 * @SET_KEY: a key is set
 * @DISABLE_KEY: a key must be disabled
 */
enum set_key_cmd {
	SET_KEY, DISABLE_KEY,
};

/**
 * enum ieee80211_sta_state - station state
 *
 * @IEEE80211_STA_NOTEXIST: station doesn't exist at all,
 *	this is a special state for add/remove transitions
 * @IEEE80211_STA_NONE: station exists without special state
 * @IEEE80211_STA_AUTH: station is authenticated
 * @IEEE80211_STA_ASSOC: station is associated
 * @IEEE80211_STA_AUTHORIZED: station is authorized (802.1X)
 */
enum ieee80211_sta_state {
	/* NOTE: These need to be ordered correctly! */
	IEEE80211_STA_NOTEXIST,
	IEEE80211_STA_NONE,
	IEEE80211_STA_AUTH,
	IEEE80211_STA_ASSOC,
	IEEE80211_STA_AUTHORIZED,
};

/**
 * enum ieee80211_sta_rx_bandwidth - station RX bandwidth
 * @IEEE80211_STA_RX_BW_20: station can only receive 20 MHz
 * @IEEE80211_STA_RX_BW_40: station can receive up to 40 MHz
 * @IEEE80211_STA_RX_BW_80: station can receive up to 80 MHz
 * @IEEE80211_STA_RX_BW_160: station can receive up to 160 MHz
 *	(including 80+80 MHz)
 *
 * Implementation note: 20 must be zero to be initialized
 *	correctly, the values must be sorted.
 */
enum ieee80211_sta_rx_bandwidth {
	IEEE80211_STA_RX_BW_20 = 0,
	IEEE80211_STA_RX_BW_40,
	IEEE80211_STA_RX_BW_80,
	IEEE80211_STA_RX_BW_160,
};

/**
 * struct ieee80211_sta_rates - station rate selection table
 *
 * @rcu_head: RCU head used for freeing the table on update
 * @rate: transmit rates/flags to be used by default.
 *	Overriding entries per-packet is possible by using cb tx control.
 */
struct ieee80211_sta_rates {
	struct rcu_head rcu_head;
	struct {
		s8 idx;
		u8 count;
		u8 count_cts;
		u8 count_rts;
		u16 flags;
	} rate[IEEE80211_TX_RATE_TABLE_SIZE];
};

/**
 * struct ieee80211_sta - station table entry
 *
 * A station table entry represents a station we are possibly
 * communicating with. Since stations are RCU-managed in
 * mac80211, any ieee80211_sta pointer you get access to must
 * either be protected by rcu_read_lock() explicitly or implicitly,
 * or you must take good care to not use such a pointer after a
 * call to your sta_remove callback that removed it.
 *
 * @addr: MAC address
 * @aid: AID we assigned to the station if we're an AP
 * @supp_rates: Bitmap of supported rates (per band)
 * @ht_cap: HT capabilities of this STA; restricted to our own capabilities
 * @vht_cap: VHT capabilities of this STA; restricted to our own capabilities
 * @max_rx_aggregation_subframes: maximal amount of frames in a single AMPDU
 *	that this station is allowed to transmit to us.
 *	Can be modified by driver.
 * @wme: indicates whether the STA supports QoS/WME (if local devices does,
 *	otherwise always false)
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void \*), size is determined in hw information.
 * @uapsd_queues: bitmap of queues configured for uapsd. Only valid
 *	if wme is supported.
 * @max_sp: max Service Period. Only valid if wme is supported.
 * @bandwidth: current bandwidth the station can receive with
 * @rx_nss: in HT/VHT, the maximum number of spatial streams the
 *	station can receive at the moment, changed by operating mode
 *	notifications and capabilities. The value is only valid after
 *	the station moves to associated state.
 * @smps_mode: current SMPS mode (off, static or dynamic)
 * @rates: rate control selection table
 * @tdls: indicates whether the STA is a TDLS peer
 * @tdls_initiator: indicates the STA is an initiator of the TDLS link. Only
 *	valid if the STA is a TDLS peer in the first place.
 * @mfp: indicates whether the STA uses management frame protection or not.
 * @max_amsdu_subframes: indicates the maximal number of MSDUs in a single
 *	A-MSDU. Taken from the Extended Capabilities element. 0 means
 *	unlimited.
 * @max_amsdu_len: indicates the maximal length of an A-MSDU in bytes. This
 *	field is always valid for packets with a VHT preamble. For packets
 *	with a HT preamble, additional limits apply:
 *		+ If the skb is transmitted as part of a BA agreement, the
 *		  A-MSDU maximal size is min(max_amsdu_len, 4065) bytes.
 *		+ If the skb is not part of a BA aggreement, the A-MSDU maximal
 *		  size is min(max_amsdu_len, 7935) bytes.
 *	Both additional HT limits must be enforced by the low level driver.
 *	This is defined by the spec (IEEE 802.11-2012 section 8.3.2.2 NOTE 2).
 * @support_p2p_ps: indicates whether the STA supports P2P PS mechanism or not.
 * @max_rc_amsdu_len: Maximum A-MSDU size in bytes recommended by rate control.
 * @txq: per-TID data TX queues (if driver uses the TXQ abstraction)
 */
struct ieee80211_sta {
	u32 supp_rates[NUM_NL80211_BANDS];
	u8 addr[ETH_ALEN];
	u16 aid;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	u8 max_rx_aggregation_subframes;
	bool wme;
	u8 uapsd_queues;
	u8 max_sp;
	u8 rx_nss;
	enum ieee80211_sta_rx_bandwidth bandwidth;
	enum ieee80211_smps_mode smps_mode;
	struct ieee80211_sta_rates __rcu *rates;
	bool tdls;
	bool tdls_initiator;
	bool mfp;
	u8 max_amsdu_subframes;
	u16 max_amsdu_len;
	bool support_p2p_ps;
	u16 max_rc_amsdu_len;

	struct ieee80211_txq *txq[IEEE80211_NUM_TIDS];

	/* must be last */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

/**
 * enum sta_notify_cmd - sta notify command
 *
 * Used with the sta_notify() callback in &struct ieee80211_ops, this
 * indicates if an associated station made a power state transition.
 *
 * @STA_NOTIFY_SLEEP: a station is now sleeping
 * @STA_NOTIFY_AWAKE: a sleeping station woke up
 */
enum sta_notify_cmd {
	STA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,
};

/**
 * struct ieee80211_tx_control - TX control data
 *
 * @sta: station table entry, this sta pointer may be NULL and
 * 	it is not allowed to copy the pointer, due to RCU.
 */
struct ieee80211_tx_control {
	struct ieee80211_sta *sta;
};

/**
 * struct ieee80211_txq - Software intermediate tx queue
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @sta: station table entry, %NULL for per-vif queue
 * @tid: the TID for this queue (unused for per-vif queue)
 * @ac: the AC for this queue
 * @drv_priv: driver private area, sized by hw->txq_data_size
 *
 * The driver can obtain packets from this queue by calling
 * ieee80211_tx_dequeue().
 */
struct ieee80211_txq {
	struct ieee80211_vif *vif;
	struct ieee80211_sta *sta;
	u8 tid;
	u8 ac;

	/* must be last */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

/**
 * enum ieee80211_hw_flags - hardware flags
 *
 * These flags are used to indicate hardware capabilities to
 * the stack. Generally, flags here should have their meaning
 * done in a way that the simplest hardware doesn't need setting
 * any particular flags. There are some exceptions to this rule,
 * however, so you are advised to review these flags carefully.
 *
 * @IEEE80211_HW_HAS_RATE_CONTROL:
 *	The hardware or firmware includes rate control, and cannot be
 *	controlled by the stack. As such, no rate control algorithm
 *	should be instantiated, and the TX rate reported to userspace
 *	will be taken from the TX status instead of the rate control
 *	algorithm.
 *	Note that this requires that the driver implement a number of
 *	callbacks so it has the correct information, it needs to have
 *	the @set_rts_threshold callback and must look at the BSS config
 *	@use_cts_prot for G/N protection, @use_short_slot for slot
 *	timing in 2.4 GHz and @use_short_preamble for preambles for
 *	CCK frames.
 *
 * @IEEE80211_HW_RX_INCLUDES_FCS:
 *	Indicates that received frames passed to the stack include
 *	the FCS at the end.
 *
 * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:
 *	Some wireless LAN chipsets buffer broadcast/multicast frames
 *	for power saving stations in the hardware/firmware and others
 *	rely on the host system for such buffering. This option is used
 *	to configure the IEEE 802.11 upper layer to buffer broadcast and
 *	multicast frames when there are power saving stations so that
 *	the driver can fetch them with ieee80211_get_buffered_bc().
 *
 * @IEEE80211_HW_SIGNAL_UNSPEC:
 *	Hardware can provide signal values but we don't know its units. We
 *	expect values between 0 and @max_signal.
 *	If possible please provide dB or dBm instead.
 *
 * @IEEE80211_HW_SIGNAL_DBM:
 *	Hardware gives signal values in dBm, decibel difference from
 *	one milliwatt. This is the preferred method since it is standardized
 *	between different devices. @max_signal does not need to be set.
 *
 * @IEEE80211_HW_SPECTRUM_MGMT:
 * 	Hardware supports spectrum management defined in 802.11h
 * 	Measurement, Channel Switch, Quieting, TPC
 *
 * @IEEE80211_HW_AMPDU_AGGREGATION:
 *	Hardware supports 11n A-MPDU aggregation.
 *
 * @IEEE80211_HW_SUPPORTS_PS:
 *	Hardware has power save support (i.e. can go to sleep).
 *
 * @IEEE80211_HW_PS_NULLFUNC_STACK:
 *	Hardware requires nullfunc frame handling in stack, implies
 *	stack support for dynamic PS.
 *
 * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:
 *	Hardware has support for dynamic PS.
 *
 * @IEEE80211_HW_MFP_CAPABLE:
 *	Hardware supports management frame protection (MFP, IEEE 802.11w).
 *
 * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:
 *	Hardware can provide ack status reports of Tx frames to
 *	the stack.
 *
 * @IEEE80211_HW_CONNECTION_MONITOR:
 *	The hardware performs its own connection monitoring, including
 *	periodic keep-alives to the AP and probing the AP on beacon loss.
 *
 * @IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC:
 *	This device needs to get data from beacon before association (i.e.
 *	dtim_period).
 *
 * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device's crypto engine supports
 *	per-station GTKs as used by IBSS RSN or during fast transition. If
 *	the device doesn't support per-station GTKs, but can be asked not
 *	to decrypt group addressed frames, then IBSS RSN support is still
 *	possible but software crypto will be used. Advertise the wiphy flag
 *	only in that case.
 *
 * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device
 *	autonomously manages the PS status of connected stations. When
 *	this flag is set mac80211 will not trigger PS mode for connected
 *	stations based on the PM bit of incoming frames.
 *	Use ieee80211_start_ps()/ieee8021_end_ps() to manually configure
 *	the PS mode of connected stations.
 *
 * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session
 *	setup strictly in HW. mac80211 should not attempt to do this in
 *	software.
 *
 * @IEEE80211_HW_WANT_MONITOR_VIF: The driver would like to be informed of
 *	a virtual monitor interface when monitor interfaces are the only
 *	active interfaces.
 *
 * @IEEE80211_HW_NO_AUTO_VIF: The driver would like for no wlanX to
 *	be created.  It is expected user-space will create vifs as
 *	desired (and thus have them named as desired).
 *
 * @IEEE80211_HW_SW_CRYPTO_CONTROL: The driver wants to control which of the
 *	crypto algorithms can be done in software - so don't automatically
 *	try to fall back to it if hardware crypto fails, but do so only if
 *	the driver returns 1. This also forces the driver to advertise its
 *	supported cipher suites.
 *
 * @IEEE80211_HW_SUPPORT_FAST_XMIT: The driver/hardware supports fast-xmit,
 *	this currently requires only the ability to calculate the duration
 *	for frames.
 *
 * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface
 *	queue mapping in order to use different queues (not just one per AC)
 *	for different virtual interfaces. See the doc section on HW queue
 *	control for more details.
 *
 * @IEEE80211_HW_SUPPORTS_RC_TABLE: The driver supports using a rate
 *	selection table provided by the rate control algorithm.
 *
 * @IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF: Use the P2P Device address for any
 *	P2P Interface. This will be honoured even if more than one interface
 *	is supported.
 *
 * @IEEE80211_HW_TIMING_BEACON_ONLY: Use sync timing from beacon frames
 *	only, to allow getting TBTT of a DTIM beacon.
 *
 * @IEEE80211_HW_SUPPORTS_HT_CCK_RATES: Hardware supports mixing HT/CCK rates
 *	and can cope with CCK rates in an aggregation session (e.g. by not
 *	using aggregation for such frames.)
 *
 * @IEEE80211_HW_CHANCTX_STA_CSA: Support 802.11h based channel-switch (CSA)
 *	for a single active channel while using channel contexts. When support
 *	is not enabled the default action is to disconnect when getting the
 *	CSA frame.
 *
 * @IEEE80211_HW_SUPPORTS_CLONED_SKBS: The driver will never modify the payload
 *	or tailroom of TX skbs without copying them first.
 *
 * @IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS: The HW supports scanning on all bands
 *	in one command, mac80211 doesn't have to run separate scans per band.
 *
 * @IEEE80211_HW_TDLS_WIDER_BW: The device/driver supports wider bandwidth
 *	than then BSS bandwidth for a TDLS link on the base channel.
 *
 * @IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU: The driver supports receiving A-MSDUs
 *	within A-MPDU.
 *
 * @IEEE80211_HW_BEACON_TX_STATUS: The device/driver provides TX status
 *	for sent beacons.
 *
 * @IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR: Hardware (or driver) requires that each
 *	station has a unique address, i.e. each station entry can be identified
 *	by just its MAC address; this prevents, for example, the same station
 *	from connecting to two virtual AP interfaces at the same time.
 *
 * @IEEE80211_HW_SUPPORTS_REORDERING_BUFFER: Hardware (or driver) manages the
 *	reordering buffer internally, guaranteeing mac80211 receives frames in
 *	order and does not need to manage its own reorder buffer or BA session
 *	timeout.
 *
 * @IEEE80211_HW_USES_RSS: The device uses RSS and thus requires parallel RX,
 *	which implies using per-CPU station statistics.
 *
 * @IEEE80211_HW_TX_AMSDU: Hardware (or driver) supports software aggregated
 *	A-MSDU frames. Requires software tx queueing and fast-xmit support.
 *	When not using minstrel/minstrel_ht rate control, the driver must
 *	limit the maximum A-MSDU size based on the current tx rate by setting
 *	max_rc_amsdu_len in struct ieee80211_sta.
 *
 * @IEEE80211_HW_TX_FRAG_LIST: Hardware (or driver) supports sending frag_list
 *	skbs, needed for zero-copy software A-MSDU.
 *
 * @IEEE80211_HW_REPORTS_LOW_ACK: The driver (or firmware) reports low ack event
 *	by ieee80211_report_low_ack() based on its own algorithm. For such
 *	drivers, mac80211 packet loss mechanism will not be triggered and driver
 *	is completely depending on firmware event for station kickout.
 *
 * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
 */
enum ieee80211_hw_flags {
	IEEE80211_HW_HAS_RATE_CONTROL,
	IEEE80211_HW_RX_INCLUDES_FCS,
	IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,
	IEEE80211_HW_SIGNAL_UNSPEC,
	IEEE80211_HW_SIGNAL_DBM,
	IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,
	IEEE80211_HW_SPECTRUM_MGMT,
	IEEE80211_HW_AMPDU_AGGREGATION,
	IEEE80211_HW_SUPPORTS_PS,
	IEEE80211_HW_PS_NULLFUNC_STACK,
	IEEE80211_HW_SUPPORTS_DYNAMIC_PS,
	IEEE80211_HW_MFP_CAPABLE,
	IEEE80211_HW_WANT_MONITOR_VIF,
	IEEE80211_HW_NO_AUTO_VIF,
	IEEE80211_HW_SW_CRYPTO_CONTROL,
	IEEE80211_HW_SUPPORT_FAST_XMIT,
	IEEE80211_HW_REPORTS_TX_ACK_STATUS,
	IEEE80211_HW_CONNECTION_MONITOR,
	IEEE80211_HW_QUEUE_CONTROL,
	IEEE80211_HW_SUPPORTS_PER_STA_GTK,
	IEEE80211_HW_AP_LINK_PS,
	IEEE80211_HW_TX_AMPDU_SETUP_IN_HW,
	IEEE80211_HW_SUPPORTS_RC_TABLE,
	IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,
	IEEE80211_HW_TIMING_BEACON_ONLY,
	IEEE80211_HW_SUPPORTS_HT_CCK_RATES,
	IEEE80211_HW_CHANCTX_STA_CSA,
	IEEE80211_HW_SUPPORTS_CLONED_SKBS,
	IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS,
	IEEE80211_HW_TDLS_WIDER_BW,
	IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU,
	IEEE80211_HW_BEACON_TX_STATUS,
	IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR,
	IEEE80211_HW_SUPPORTS_REORDERING_BUFFER,
	IEEE80211_HW_USES_RSS,
	IEEE80211_HW_TX_AMSDU,
	IEEE80211_HW_TX_FRAG_LIST,
	IEEE80211_HW_REPORTS_LOW_ACK,

	/* keep last, obviously */
	NUM_IEEE80211_HW_FLAGS
};

/**
 * struct ieee80211_hw - hardware information and state
 *
 * This structure contains the configuration and hardware
 * information for an 802.11 PHY.
 *
 * @wiphy: This points to the &struct wiphy allocated for this
 *	802.11 PHY. You must fill in the @perm_addr and @dev
 *	members of this structure using SET_IEEE80211_DEV()
 *	and SET_IEEE80211_PERM_ADDR(). Additionally, all supported
 *	bands (with channels, bitrates) are registered here.
 *
 * @conf: &struct ieee80211_conf, device configuration, don't use.
 *
 * @priv: pointer to private area that was allocated for driver use
 *	along with this structure.
 *
 * @flags: hardware flags, see &enum ieee80211_hw_flags.
 *
 * @extra_tx_headroom: headroom to reserve in each transmit skb
 *	for use by the driver (e.g. for transmit headers.)
 *
 * @extra_beacon_tailroom: tailroom to reserve in each beacon tx skb.
 *	Can be used by drivers to add extra IEs.
 *
 * @max_signal: Maximum value for signal (rssi) in RX information, used
 *	only when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB
 *
 * @max_listen_interval: max listen interval in units of beacon interval
 *	that HW supports
 *
 * @queues: number of available hardware transmit queues for
 *	data packets. WMM/QoS requires at least four, these
 *	queues need to have configurable access parameters.
 *
 * @rate_control_algorithm: rate control algorithm for this hardware.
 *	If unset (NULL), the default algorithm will be used. Must be
 *	set before calling ieee80211_register_hw().
 *
 * @vif_data_size: size (in bytes) of the drv_priv data area
 *	within &struct ieee80211_vif.
 * @sta_data_size: size (in bytes) of the drv_priv data area
 *	within &struct ieee80211_sta.
 * @chanctx_data_size: size (in bytes) of the drv_priv data area
 *	within &struct ieee80211_chanctx_conf.
 * @txq_data_size: size (in bytes) of the drv_priv data area
 *	within @struct ieee80211_txq.
 *
 * @max_rates: maximum number of alternate rate retry stages the hw
 *	can handle.
 * @max_report_rates: maximum number of alternate rate retry stages
 *	the hw can report back.
 * @max_rate_tries: maximum number of tries for each stage
 *
 * @max_rx_aggregation_subframes: maximum buffer size (number of
 *	sub-frames) to be used for A-MPDU block ack receiver
 *	aggregation.
 *	This is only relevant if the device has restrictions on the
 *	number of subframes, if it relies on mac80211 to do reordering
 *	it shouldn't be set.
 *
 * @max_tx_aggregation_subframes: maximum number of subframes in an
 *	aggregate an HT driver will transmit. Though ADDBA will advertise
 *	a constant value of 64 as some older APs can crash if the window
 *	size is smaller (an example is LinkSys WRT120N with FW v1.0.07
 *	build 002 Jun 18 2012).
 *
 * @max_tx_fragments: maximum number of tx buffers per (A)-MSDU, sum
 *	of 1 + skb_shinfo(skb)->nr_frags for each skb in the frag_list.
 *
 * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX
 *	(if %IEEE80211_HW_QUEUE_CONTROL is set)
 *
 * @radiotap_mcs_details: lists which MCS information can the HW
 *	reports, by default it is set to _MCS, _GI and _BW but doesn't
 *	include _FMT. Use %IEEE80211_RADIOTAP_MCS_HAVE_\* values, only
 *	adding _BW is supported today.
 *
 * @radiotap_vht_details: lists which VHT MCS information the HW reports,
 *	the default is _GI | _BANDWIDTH.
 *	Use the %IEEE80211_RADIOTAP_VHT_KNOWN_\* values.
 *
 * @radiotap_timestamp: Information for the radiotap timestamp field; if the
 *	'units_pos' member is set to a non-negative value it must be set to
 *	a combination of a IEEE80211_RADIOTAP_TIMESTAMP_UNIT_* and a
 *	IEEE80211_RADIOTAP_TIMESTAMP_SPOS_* value, and then the timestamp
 *	field will be added and populated from the &struct ieee80211_rx_status
 *	device_timestamp. If the 'accuracy' member is non-negative, it's put
 *	into the accuracy radiotap field and the accuracy known flag is set.
 *
 * @netdev_features: netdev features to be set in each netdev created
 *	from this HW. Note that not all features are usable with mac80211,
 *	other features will be rejected during HW registration.
 *
 * @uapsd_queues: This bitmap is included in (re)association frame to indicate
 *	for each access category if it is uAPSD trigger-enabled and delivery-
 *	enabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.
 *	Each bit corresponds to different AC. Value '1' in specific bit means
 *	that corresponding AC is both trigger- and delivery-enabled. '0' means
 *	neither enabled.
 *
 * @uapsd_max_sp_len: maximum number of total buffered frames the WMM AP may
 *	deliver to a WMM STA during any Service Period triggered by the WMM STA.
 *	Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.
 *
 * @n_cipher_schemes: a size of an array of cipher schemes definitions.
 * @cipher_schemes: a pointer to an array of cipher scheme definitions
 *	supported by HW.
 * @max_nan_de_entries: maximum number of NAN DE functions supported by the
 *	device.
 */
struct ieee80211_hw {
	struct ieee80211_conf conf;
	struct wiphy *wiphy;
	const char *rate_control_algorithm;
	void *priv;
	unsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];
	unsigned int extra_tx_headroom;
	unsigned int extra_beacon_tailroom;
	int vif_data_size;
	int sta_data_size;
	int chanctx_data_size;
	int txq_data_size;
	u16 queues;
	u16 max_listen_interval;
	s8 max_signal;
	u8 max_rates;
	u8 max_report_rates;
	u8 max_rate_tries;
	u8 max_rx_aggregation_subframes;
	u8 max_tx_aggregation_subframes;
	u8 max_tx_fragments;
	u8 offchannel_tx_hw_queue;
	u8 radiotap_mcs_details;
	u16 radiotap_vht_details;
	struct {
		int units_pos;
		s16 accuracy;
	} radiotap_timestamp;
	netdev_features_t netdev_features;
	u8 uapsd_queues;
	u8 uapsd_max_sp_len;
	u8 n_cipher_schemes;
	const struct ieee80211_cipher_scheme *cipher_schemes;
	u8 max_nan_de_entries;
};

static inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,
				       enum ieee80211_hw_flags flg)
{
	return test_bit(flg, hw->flags);
}
#define ieee80211_hw_check(hw, flg)	_ieee80211_hw_check(hw, IEEE80211_HW_##flg)

static inline void _ieee80211_hw_set(struct ieee80211_hw *hw,
				     enum ieee80211_hw_flags flg)
{
	return __set_bit(flg, hw->flags);
}
#define ieee80211_hw_set(hw, flg)	_ieee80211_hw_set(hw, IEEE80211_HW_##flg)

/**
 * struct ieee80211_scan_request - hw scan request
 *
 * @ies: pointers different parts of IEs (in req.ie)
 * @req: cfg80211 request.
 */
struct ieee80211_scan_request {
	struct ieee80211_scan_ies ies;

	/* Keep last */
	struct cfg80211_scan_request req;
};

/**
 * struct ieee80211_tdls_ch_sw_params - TDLS channel switch parameters
 *
 * @sta: peer this TDLS channel-switch request/response came from
 * @chandef: channel referenced in a TDLS channel-switch request
 * @action_code: see &enum ieee80211_tdls_actioncode
 * @status: channel-switch response status
 * @timestamp: time at which the frame was received
 * @switch_time: switch-timing parameter received in the frame
 * @switch_timeout: switch-timing parameter received in the frame
 * @tmpl_skb: TDLS switch-channel response template
 * @ch_sw_tm_ie: offset of the channel-switch timing IE inside @tmpl_skb
 */
struct ieee80211_tdls_ch_sw_params {
	struct ieee80211_sta *sta;
	struct cfg80211_chan_def *chandef;
	u8 action_code;
	u32 status;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	struct sk_buff *tmpl_skb;
	u32 ch_sw_tm_ie;
};

/**
 * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy
 *
 * @wiphy: the &struct wiphy which we want to query
 *
 * mac80211 drivers can use this to get to their respective
 * &struct ieee80211_hw. Drivers wishing to get to their own private
 * structure can then access it via hw->priv. Note that mac802111 drivers should
 * not use wiphy_priv() to try to get their private driver structure as this
 * is already used internally by mac80211.
 *
 * Return: The mac80211 driver hw struct of @wiphy.
 */
struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);

/**
 * SET_IEEE80211_DEV - set device for 802.11 hardware
 *
 * @hw: the &struct ieee80211_hw to set the device for
 * @dev: the &struct device of this 802.11 device
 */
static inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)
{
	set_wiphy_dev(hw->wiphy, dev);
}

/**
 * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware
 *
 * @hw: the &struct ieee80211_hw to set the MAC address for
 * @addr: the address to set
 */
static inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, const u8 *addr)
{
	memcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);
}

static inline struct ieee80211_rate *
ieee80211_get_tx_rate(const struct ieee80211_hw *hw,
		      const struct ieee80211_tx_info *c)
{
	if (WARN_ON_ONCE(c->control.rates[0].idx < 0))
		return NULL;
	return &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];
}

static inline struct ieee80211_rate *
ieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,
			   const struct ieee80211_tx_info *c)
{
	if (c->control.rts_cts_rate_idx < 0)
		return NULL;
	return &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];
}

static inline struct ieee80211_rate *
ieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,
			     const struct ieee80211_tx_info *c, int idx)
{
	if (c->control.rates[idx + 1].idx < 0)
		return NULL;
	return &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];
}

/**
 * ieee80211_free_txskb - free TX skb
 * @hw: the hardware
 * @skb: the skb
 *
 * Free a transmit skb. Use this funtion when some failure
 * to transmit happened and thus status cannot be reported.
 */
void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);

/**
 * DOC: Hardware crypto acceleration
 *
 * mac80211 is capable of taking advantage of many hardware
 * acceleration designs for encryption and decryption operations.
 *
 * The set_key() callback in the &struct ieee80211_ops for a given
 * device is called to enable hardware acceleration of encryption and
 * decryption. The callback takes a @sta parameter that will be NULL
 * for default keys or keys used for transmission only, or point to
 * the station information for the peer for individual keys.
 * Multiple transmission keys with the same key index may be used when
 * VLANs are configured for an access point.
 *
 * When transmitting, the TX control data will use the @hw_key_idx
 * selected by the driver by modifying the &struct ieee80211_key_conf
 * pointed to by the @key parameter to the set_key() function.
 *
 * The set_key() call for the %SET_KEY command should return 0 if
 * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn't be
 * added; if you return 0 then hw_key_idx must be assigned to the
 * hardware key index, you are free to use the full u8 range.
 *
 * Note that in the case that the @IEEE80211_HW_SW_CRYPTO_CONTROL flag is
 * set, mac80211 will not automatically fall back to software crypto if
 * enabling hardware crypto failed. The set_key() call may also return the
 * value 1 to permit this specific key/algorithm to be done in software.
 *
 * When the cmd is %DISABLE_KEY then it must succeed.
 *
 * Note that it is permissible to not decrypt a frame even if a key
 * for it has been uploaded to hardware, the stack will not make any
 * decision based on whether a key has been uploaded or not but rather
 * based on the receive flags.
 *
 * The &struct ieee80211_key_conf structure pointed to by the @key
 * parameter is guaranteed to be valid until another call to set_key()
 * removes it, but it can only be used as a cookie to differentiate
 * keys.
 *
 * In TKIP some HW need to be provided a phase 1 key, for RX decryption
 * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
 * handler.
 * The update_tkip_key() call updates the driver with the new phase 1 key.
 * This happens every time the iv16 wraps around (every 65536 packets). The
 * set_key() call will happen only once for each key (unless the AP did
 * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
 * provided by update_tkip_key only. The trigger that makes mac80211 call this
 * handler is software decryption with wrap around of iv16.
 *
 * The set_default_unicast_key() call updates the default WEP key index
 * configured to the hardware for WEP encryption type. This is required
 * for devices that support offload of data packets (e.g. ARP responses).
 */

/**
 * DOC: Powersave support
 *
 * mac80211 has support for various powersave implementations.
 *
 * First, it can support hardware that handles all powersaving by itself,
 * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware
 * flag. In that case, it will be told about the desired powersave mode
 * with the %IEEE80211_CONF_PS flag depending on the association status.
 * The hardware must take care of sending nullfunc frames when necessary,
 * i.e. when entering and leaving powersave mode. The hardware is required
 * to look at the AID in beacons and signal to the AP that it woke up when
 * it finds traffic directed to it.
 *
 * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in
 * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
 * with hardware wakeup and sleep states. Driver is responsible for waking
 * up the hardware before issuing commands to the hardware and putting it
 * back to sleep at appropriate times.
 *
 * When PS is enabled, hardware needs to wakeup for beacons and receive the
 * buffered multicast/broadcast frames after the beacon. Also it must be
 * possible to send frames and receive the acknowledment frame.
 *
 * Other hardware designs cannot send nullfunc frames by themselves and also
 * need software support for parsing the TIM bitmap. This is also supported
 * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and
 * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still
 * required to pass up beacons. The hardware is still required to handle
 * waking up for multicast traffic; if it cannot the driver must handle that
 * as best as it can, mac80211 is too slow to do that.
 *
 * Dynamic powersave is an extension to normal powersave in which the
 * hardware stays awake for a user-specified period of time after sending a
 * frame so that reply frames need not be buffered and therefore delayed to
 * the next wakeup. It's compromise of getting good enough latency when
 * there's data traffic and still saving significantly power in idle
 * periods.
 *
 * Dynamic powersave is simply supported by mac80211 enabling and disabling
 * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS
 * flag and mac80211 will handle everything automatically. Additionally,
 * hardware having support for the dynamic PS feature may set the
 * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support
 * dynamic PS mode itself. The driver needs to look at the
 * @dynamic_ps_timeout hardware configuration value and use it that value
 * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable
 * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS
 * enabled whenever user has enabled powersave.
 *
 * Driver informs U-APSD client support by enabling
 * %IEEE80211_VIF_SUPPORTS_UAPSD flag. The mode is configured through the
 * uapsd parameter in conf_tx() operation. Hardware needs to send the QoS
 * Nullfunc frames and stay awake until the service period has ended. To
 * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
 * from that AC are transmitted with powersave enabled.
 *
 * Note: U-APSD client mode is not yet supported with
 * %IEEE80211_HW_PS_NULLFUNC_STACK.
 */

/**
 * DOC: Beacon filter support
 *
 * Some hardware have beacon filter support to reduce host cpu wakeups
 * which will reduce system power consumption. It usually works so that
 * the firmware creates a checksum of the beacon but omits all constantly
 * changing elements (TSF, TIM etc). Whenever the checksum changes the
 * beacon is forwarded to the host, otherwise it will be just dropped. That
 * way the host will only receive beacons where some relevant information
 * (for example ERP protection or WMM settings) have changed.
 *
 * Beacon filter support is advertised with the %IEEE80211_VIF_BEACON_FILTER
 * interface capability. The driver needs to enable beacon filter support
 * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When
 * power save is enabled, the stack will not check for beacon loss and the
 * driver needs to notify about loss of beacons with ieee80211_beacon_loss().
 *
 * The time (or number of beacons missed) until the firmware notifies the
 * driver of a beacon loss event (which in turn causes the driver to call
 * ieee80211_beacon_loss()) should be configurable and will be controlled
 * by mac80211 and the roaming algorithm in the future.
 *
 * Since there may be constantly changing information elements that nothing
 * in the software stack cares about, we will, in the future, have mac80211
 * tell the driver which information elements are interesting in the sense
 * that we want to see changes in them. This will include
 *
 *  - a list of information element IDs
 *  - a list of OUIs for the vendor information element
 *
 * Ideally, the hardware would filter out any beacons without changes in the
 * requested elements, but if it cannot support that it may, at the expense
 * of some efficiency, filter out only a subset. For example, if the device
 * doesn't support checking for OUIs it should pass up all changes in all
 * vendor information elements.
 *
 * Note that change, for the sake of simplification, also includes information
 * elements appearing or disappearing from the beacon.
 *
 * Some hardware supports an "ignore list" instead, just make sure nothing
 * that was requested is on the ignore list, and include commonly changing
 * information element IDs in the ignore list, for example 11 (BSS load) and
 * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
 * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
 * it could also include some currently unused IDs.
 *
 *
 * In addition to these capabilities, hardware should support notifying the
 * host of changes in the beacon RSSI. This is relevant to implement roaming
 * when no traffic is flowing (when traffic is flowing we see the RSSI of
 * the received data packets). This can consist in notifying the host when
 * the RSSI changes significantly or when it drops below or rises above
 * configurable thresholds. In the future these thresholds will also be
 * configured by mac80211 (which gets them from userspace) to implement
 * them as the roaming algorithm requires.
 *
 * If the hardware cannot implement this, the driver should ask it to
 * periodically pass beacon frames to the host so that software can do the
 * signal strength threshold checking.
 */

/**
 * DOC: Spatial multiplexing power save
 *
 * SMPS (Spatial multiplexing power save) is a mechanism to conserve
 * power in an 802.11n implementation. For details on the mechanism
 * and rationale, please refer to 802.11 (as amended by 802.11n-2009)
 * "11.2.3 SM power save".
 *
 * The mac80211 implementation is capable of sending action frames
 * to update the AP about the station's SMPS mode, and will instruct
 * the driver to enter the specific mode. It will also announce the
 * requested SMPS mode during the association handshake. Hardware
 * support for this feature is required, and can be indicated by
 * hardware flags.
 *
 * The default mode will be "automatic", which nl80211/cfg80211
 * defines to be dynamic SMPS in (regular) powersave, and SMPS
 * turned off otherwise.
 *
 * To support this feature, the driver must set the appropriate
 * hardware support flags, and handle the SMPS flag to the config()
 * operation. It will then with this mechanism be instructed to
 * enter the requested SMPS mode while associated to an HT AP.
 */

/**
 * DOC: Frame filtering
 *
 * mac80211 requires to see many management frames for proper
 * operation, and users may want to see many more frames when
 * in monitor mode. However, for best CPU usage and power consumption,
 * having as few frames as possible percolate through the stack is
 * desirable. Hence, the hardware should filter as much as possible.
 *
 * To achieve this, mac80211 uses filter flags (see below) to tell
 * the driver's configure_filter() function which frames should be
 * passed to mac80211 and which should be filtered out.
 *
 * Before configure_filter() is invoked, the prepare_multicast()
 * callback is invoked with the parameters @mc_count and @mc_list
 * for the combined multicast address list of all virtual interfaces.
 * It's use is optional, and it returns a u64 that is passed to
 * configure_filter(). Additionally, configure_filter() has the
 * arguments @changed_flags telling which flags were changed and
 * @total_flags with the new flag states.
 *
 * If your device has no multicast address filters your driver will
 * need to check both the %FIF_ALLMULTI flag and the @mc_count
 * parameter to see whether multicast frames should be accepted
 * or dropped.
 *
 * All unsupported flags in @total_flags must be cleared.
 * Hardware does not support a flag if it is incapable of _passing_
 * the frame to the stack. Otherwise the driver must ignore
 * the flag, but not clear it.
 * You must _only_ clear the flag (announce no support for the
 * flag to mac80211) if you are not able to pass the packet type
 * to the stack (so the hardware always filters it).
 * So for example, you should clear @FIF_CONTROL, if your hardware
 * always filters control frames. If your hardware always passes
 * control frames to the kernel and is incapable of filtering them,
 * you do _not_ clear the @FIF_CONTROL flag.
 * This rule applies to all other FIF flags as well.
 */

/**
 * DOC: AP support for powersaving clients
 *
 * In order to implement AP and P2P GO modes, mac80211 has support for
 * client powersaving, both "legacy" PS (PS-Poll/null data) and uAPSD.
 * There currently is no support for sAPSD.
 *
 * There is one assumption that mac80211 makes, namely that a client
 * will not poll with PS-Poll and trigger with uAPSD at the same time.
 * Both are supported, and both can be used by the same client, but
 * they can't be used concurrently by the same client. This simplifies
 * the driver code.
 *
 * The first thing to keep in mind is that there is a flag for complete
 * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,
 * mac80211 expects the driver to handle most of the state machine for
 * powersaving clients and will ignore the PM bit in incoming frames.
 * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of
 * stations' powersave transitions. In this mode, mac80211 also doesn't
 * handle PS-Poll/uAPSD.
 *
 * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the
 * PM bit in incoming frames for client powersave transitions. When a
 * station goes to sleep, we will stop transmitting to it. There is,
 * however, a race condition: a station might go to sleep while there is
 * data buffered on hardware queues. If the device has support for this
 * it will reject frames, and the driver should give the frames back to
 * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will
 * cause mac80211 to retry the frame when the station wakes up. The
 * driver is also notified of powersave transitions by calling its
 * @sta_notify callback.
 *
 * When the station is asleep, it has three choices: it can wake up,
 * it can PS-Poll, or it can possibly start a uAPSD service period.
 * Waking up is implemented by simply transmitting all buffered (and
 * filtered) frames to the station. This is the easiest case. When
 * the station sends a PS-Poll or a uAPSD trigger frame, mac80211
 * will inform the driver of this with the @allow_buffered_frames
 * callback; this callback is optional. mac80211 will then transmit
 * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER
 * on each frame. The last frame in the service period (or the only
 * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to
 * indicate that it ends the service period; as this frame must have
 * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.
 * When TX status is reported for this frame, the service period is
 * marked has having ended and a new one can be started by the peer.
 *
 * Additionally, non-bufferable MMPDUs can also be transmitted by
 * mac80211 with the %IEEE80211_TX_CTL_NO_PS_BUFFER set in them.
 *
 * Another race condition can happen on some devices like iwlwifi
 * when there are frames queued for the station and it wakes up
 * or polls; the frames that are already queued could end up being
 * transmitted first instead, causing reordering and/or wrong
 * processing of the EOSP. The cause is that allowing frames to be
 * transmitted to a certain station is out-of-band communication to
 * the device. To allow this problem to be solved, the driver can
 * call ieee80211_sta_block_awake() if frames are buffered when it
 * is notified that the station went to sleep. When all these frames
 * have been filtered (see above), it must call the function again
 * to indicate that the station is no longer blocked.
 *
 * If the driver buffers frames in the driver for aggregation in any
 * way, it must use the ieee80211_sta_set_buffered() call when it is
 * notified of the station going to sleep to inform mac80211 of any
 * TIDs that have frames buffered. Note that when a station wakes up
 * this information is reset (hence the requirement to call it when
 * informed of the station going to sleep). Then, when a service
 * period starts for any reason, @release_buffered_frames is called
 * with the number of frames to be released and which TIDs they are
 * to come from. In this case, the driver is responsible for setting
 * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
 * to help the @more_data parameter is passed to tell the driver if
 * there is more data on other TIDs -- the TIDs to release frames
 * from are ignored since mac80211 doesn't know how many frames the
 * buffers for those TIDs contain.
 *
 * If the driver also implement GO mode, where absence periods may
 * shorten service periods (or abort PS-Poll responses), it must
 * filter those response frames except in the case of frames that
 * are buffered in the driver -- those must remain buffered to avoid
 * reordering. Because it is possible that no frames are released
 * in this case, the driver must call ieee80211_sta_eosp()
 * to indicate to mac80211 that the service period ended anyway.
 *
 * Finally, if frames from multiple TIDs are released from mac80211
 * but the driver might reorder them, it must clear & set the flags
 * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
 * and also take care of the EOSP and MORE_DATA bits in the frame.
 * The driver may also use ieee80211_sta_eosp() in this case.
 *
 * Note that if the driver ever buffers frames other than QoS-data
 * frames, it must take care to never send a non-QoS-data frame as
 * the last frame in a service period, adding a QoS-nulldata frame
 * after a non-QoS-data frame if needed.
 */

/**
 * DOC: HW queue control
 *
 * Before HW queue control was introduced, mac80211 only had a single static
 * assignment of per-interface AC software queues to hardware queues. This
 * was problematic for a few reasons:
 * 1) off-channel transmissions might get stuck behind other frames
 * 2) multiple virtual interfaces couldn't be handled correctly
 * 3) after-DTIM frames could get stuck behind other frames
 *
 * To solve this, hardware typically uses multiple different queues for all
 * the different usages, and this needs to be propagated into mac80211 so it
 * won't have the same problem with the software queues.
 *
 * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability
 * flag that tells it that the driver implements its own queue control. To do
 * so, the driver will set up the various queues in each &struct ieee80211_vif
 * and the offchannel queue in &struct ieee80211_hw. In response, mac80211 will
 * use those queue IDs in the hw_queue field of &struct ieee80211_tx_info and
 * if necessary will queue the frame on the right software queue that mirrors
 * the hardware queue.
 * Additionally, the driver has to then use these HW queue IDs for the queue
 * management functions (ieee80211_stop_queue() et al.)
 *
 * The driver is free to set up the queue mappings as needed, multiple virtual
 * interfaces may map to the same hardware queues if needed. The setup has to
 * happen during add_interface or change_interface callbacks. For example, a
 * driver supporting station+station and station+AP modes might decide to have
 * 10 hardware queues to handle different scenarios:
 *
 * 4 AC HW queues for 1st vif: 0, 1, 2, 3
 * 4 AC HW queues for 2nd vif: 4, 5, 6, 7
 * after-DTIM queue for AP:   8
 * off-channel queue:         9
 *
 * It would then set up the hardware like this:
 *   hw.offchannel_tx_hw_queue = 9
 *
 * and the first virtual interface that is added as follows:
 *   vif.hw_queue[IEEE80211_AC_VO] = 0
 *   vif.hw_queue[IEEE80211_AC_VI] = 1
 *   vif.hw_queue[IEEE80211_AC_BE] = 2
 *   vif.hw_queue[IEEE80211_AC_BK] = 3
 *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE
 * and the second virtual interface with 4-7.
 *
 * If queue 6 gets full, for example, mac80211 would only stop the second
 * virtual interface's BE queue since virtual interface queues are per AC.
 *
 * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE
 * whenever the queue is not used (i.e. the interface is not in AP mode) if the
 * queue could potentially be shared since mac80211 will look at cab_queue when
 * a queue is stopped/woken even if the interface is not in AP mode.
 */

/**
 * enum ieee80211_filter_flags - hardware filter flags
 *
 * These flags determine what the filter in hardware should be
 * programmed to let through and what should not be passed to the
 * stack. It is always safe to pass more frames than requested,
 * but this has negative impact on power consumption.
 *
 * @FIF_ALLMULTI: pass all multicast frames, this is used if requested
 *	by the user or if the hardware is not capable of filtering by
 *	multicast address.
 *
 * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the
 *	%RX_FLAG_FAILED_FCS_CRC for them)
 *
 * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set
 *	the %RX_FLAG_FAILED_PLCP_CRC for them
 *
 * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate
 *	to the hardware that it should not filter beacons or probe responses
 *	by BSSID. Filtering them can greatly reduce the amount of processing
 *	mac80211 needs to do and the amount of CPU wakeups, so you should
 *	honour this flag if possible.
 *
 * @FIF_CONTROL: pass control frames (except for PS Poll) addressed to this
 *	station
 *
 * @FIF_OTHER_BSS: pass frames destined to other BSSes
 *
 * @FIF_PSPOLL: pass PS Poll frames
 *
 * @FIF_PROBE_REQ: pass probe request frames
 */
enum ieee80211_filter_flags {
	FIF_ALLMULTI		= 1<<1,
	FIF_FCSFAIL		= 1<<2,
	FIF_PLCPFAIL		= 1<<3,
	FIF_BCN_PRBRESP_PROMISC	= 1<<4,
	FIF_CONTROL		= 1<<5,
	FIF_OTHER_BSS		= 1<<6,
	FIF_PSPOLL		= 1<<7,
	FIF_PROBE_REQ		= 1<<8,
};

/**
 * enum ieee80211_ampdu_mlme_action - A-MPDU actions
 *
 * These flags are used with the ampdu_action() callback in
 * &struct ieee80211_ops to indicate which action is needed.
 *
 * Note that drivers MUST be able to deal with a TX aggregation
 * session being stopped even before they OK'ed starting it by
 * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
 * might receive the addBA frame and send a delBA right away!
 *
 * @IEEE80211_AMPDU_RX_START: start RX aggregation
 * @IEEE80211_AMPDU_RX_STOP: stop RX aggregation
 * @IEEE80211_AMPDU_TX_START: start TX aggregation
 * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational
 * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting
 *	queued packets, now unaggregated. After all packets are transmitted the
 *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe().
 * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,
 *	called when the station is removed. There's no need or reason to call
 *	ieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the
 *	session is gone and removes the station.
 * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped
 *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and
 *	now the connection is dropped and the station will be removed. Drivers
 *	should clean up and drop remaining packets when this is called.
 */
enum ieee80211_ampdu_mlme_action {
	IEEE80211_AMPDU_RX_START,
	IEEE80211_AMPDU_RX_STOP,
	IEEE80211_AMPDU_TX_START,
	IEEE80211_AMPDU_TX_STOP_CONT,
	IEEE80211_AMPDU_TX_STOP_FLUSH,
	IEEE80211_AMPDU_TX_STOP_FLUSH_CONT,
	IEEE80211_AMPDU_TX_OPERATIONAL,
};

/**
 * struct ieee80211_ampdu_params - AMPDU action parameters
 *
 * @action: the ampdu action, value from %ieee80211_ampdu_mlme_action.
 * @sta: peer of this AMPDU session
 * @tid: tid of the BA session
 * @ssn: start sequence number of the session. TX/RX_STOP can pass 0. When
 *	action is set to %IEEE80211_AMPDU_RX_START the driver passes back the
 *	actual ssn value used to start the session and writes the value here.
 * @buf_size: reorder buffer size  (number of subframes). Valid only when the
 *	action is set to %IEEE80211_AMPDU_RX_START or
 *	%IEEE80211_AMPDU_TX_OPERATIONAL
 * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.
 *	valid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL
 * @timeout: BA session timeout. Valid only when the action is set to
 *	%IEEE80211_AMPDU_RX_START
 */
struct ieee80211_ampdu_params {
	enum ieee80211_ampdu_mlme_action action;
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
	u8 buf_size;
	bool amsdu;
	u16 timeout;
};

/**
 * enum ieee80211_frame_release_type - frame release reason
 * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll
 * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to
 *	frame received on trigger-enabled AC
 */
enum ieee80211_frame_release_type {
	IEEE80211_FRAME_RELEASE_PSPOLL,
	IEEE80211_FRAME_RELEASE_UAPSD,
};

/**
 * enum ieee80211_rate_control_changed - flags to indicate what changed
 *
 * @IEEE80211_RC_BW_CHANGED: The bandwidth that can be used to transmit
 *	to this station changed. The actual bandwidth is in the station
 *	information -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40
 *	flag changes, for HT and VHT the bandwidth field changes.
 * @IEEE80211_RC_SMPS_CHANGED: The SMPS state of the station changed.
 * @IEEE80211_RC_SUPP_RATES_CHANGED: The supported rate set of this peer
 *	changed (in IBSS mode) due to discovering more information about
 *	the peer.
 * @IEEE80211_RC_NSS_CHANGED: N_SS (number of spatial streams) was changed
 *	by the peer
 */
enum ieee80211_rate_control_changed {
	IEEE80211_RC_BW_CHANGED		= BIT(0),
	IEEE80211_RC_SMPS_CHANGED	= BIT(1),
	IEEE80211_RC_SUPP_RATES_CHANGED	= BIT(2),
	IEEE80211_RC_NSS_CHANGED	= BIT(3),
};

/**
 * enum ieee80211_roc_type - remain on channel type
 *
 * With the support for multi channel contexts and multi channel operations,
 * remain on channel operations might be limited/deferred/aborted by other
 * flows/operations which have higher priority (and vise versa).
 * Specifying the ROC type can be used by devices to prioritize the ROC
 * operations compared to other operations/flows.
 *
 * @IEEE80211_ROC_TYPE_NORMAL: There are no special requirements for this ROC.
 * @IEEE80211_ROC_TYPE_MGMT_TX: The remain on channel request is required
 *	for sending managment frames offchannel.
 */
enum ieee80211_roc_type {
	IEEE80211_ROC_TYPE_NORMAL = 0,
	IEEE80211_ROC_TYPE_MGMT_TX,
};

/**
 * enum ieee80211_reconfig_complete_type - reconfig type
 *
 * This enum is used by the reconfig_complete() callback to indicate what
 * reconfiguration type was completed.
 *
 * @IEEE80211_RECONFIG_TYPE_RESTART: hw restart type
 *	(also due to resume() callback returning 1)
 * @IEEE80211_RECONFIG_TYPE_SUSPEND: suspend type (regardless
 *	of wowlan configuration)
 */
enum ieee80211_reconfig_type {
	IEEE80211_RECONFIG_TYPE_RESTART,
	IEEE80211_RECONFIG_TYPE_SUSPEND,
};

/**
 * struct ieee80211_ops - callbacks from mac80211 to the driver
 *
 * This structure contains various callbacks that the driver may
 * handle or, in some cases, must handle, for example to configure
 * the hardware to a new channel or to transmit a frame.
 *
 * @tx: Handler that 802.11 module calls for each transmitted frame.
 *	skb contains the buffer starting from the IEEE 802.11 header.
 *	The low-level driver should send the frame out based on
 *	configuration in the TX control data. This handler should,
 *	preferably, never fail and stop queues appropriately.
 *	Must be atomic.
 *
 * @start: Called before the first netdevice attached to the hardware
 *	is enabled. This should turn on the hardware and must turn on
 *	frame reception (for possibly enabled monitor interfaces.)
 *	Returns negative error codes, these may be seen in userspace,
 *	or zero.
 *	When the device is started it should not have a MAC address
 *	to avoid acknowledging frames before a non-monitor device
 *	is added.
 *	Must be implemented and can sleep.
 *
 * @stop: Called after last netdevice attached to the hardware
 *	is disabled. This should turn off the hardware (at least
 *	it must turn off frame reception.)
 *	May be called right after add_interface if that rejects
 *	an interface. If you added any work onto the mac80211 workqueue
 *	you should ensure to cancel it on this callback.
 *	Must be implemented and can sleep.
 *
 * @suspend: Suspend the device; mac80211 itself will quiesce before and
 *	stop transmitting and doing any other configuration, and then
 *	ask the device to suspend. This is only invoked when WoWLAN is
 *	configured, otherwise the device is deconfigured completely and
 *	reconfigured at resume time.
 *	The driver may also impose special conditions under which it
 *	wants to use the "normal" suspend (deconfigure), say if it only
 *	supports WoWLAN when the device is associated. In this case, it
 *	must return 1 from this function.
 *
 * @resume: If WoWLAN was configured, this indicates that mac80211 is
 *	now resuming its operation, after this the device must be fully
 *	functional again. If this returns an error, the only way out is
 *	to also unregister the device. If it returns 1, then mac80211
 *	will also go through the regular complete restart on resume.
 *
 * @set_wakeup: Enable or disable wakeup when WoWLAN configuration is
 *	modified. The reason is that device_set_wakeup_enable() is
 *	supposed to be called when the configuration changes, not only
 *	in suspend().
 *
 * @add_interface: Called when a netdevice attached to the hardware is
 *	enabled. Because it is not called for monitor mode devices, @start
 *	and @stop must be implemented.
 *	The driver should perform any initialization it needs before
 *	the device can be enabled. The initial configuration for the
 *	interface is given in the conf parameter.
 *	The callback may refuse to add an interface by returning a
 *	negative error code (which will be seen in userspace.)
 *	Must be implemented and can sleep.
 *
 * @change_interface: Called when a netdevice changes type. This callback
 *	is optional, but only if it is supported can interface types be
 *	switched while the interface is UP. The callback may sleep.
 *	Note that while an interface is being switched, it will not be
 *	found by the interface iteration callbacks.
 *
 * @remove_interface: Notifies a driver that an interface is going down.
 *	The @stop callback is called after this if it is the last interface
 *	and no monitor interfaces are present.
 *	When all interfaces are removed, the MAC address in the hardware
 *	must be cleared so the device no longer acknowledges packets,
 *	the mac_addr member of the conf structure is, however, set to the
 *	MAC address of the device going away.
 *	Hence, this callback must be implemented. It can sleep.
 *
 * @config: Handler for configuration requests. IEEE 802.11 code calls this
 *	function to change hardware configuration, e.g., channel.
 *	This function should never fail but returns a negative error code
 *	if it does. The callback can sleep.
 *
 * @bss_info_changed: Handler for configuration requests related to BSS
 *	parameters that may vary during BSS's lifespan, and may affect low
 *	level driver (e.g. assoc/disassoc status, erp parameters).
 *	This function should not be used if no BSS has been set, unless
 *	for association indication. The @changed parameter indicates which
 *	of the bss parameters has changed when a call is made. The callback
 *	can sleep.
 *
 * @prepare_multicast: Prepare for multicast filter configuration.
 *	This callback is optional, and its return value is passed
 *	to configure_filter(). This callback must be atomic.
 *
 * @configure_filter: Configure the device's RX filter.
 *	See the section "Frame filtering" for more information.
 *	This callback must be implemented and can sleep.
 *
 * @config_iface_filter: Configure the interface's RX filter.
 *	This callback is optional and is used to configure which frames
 *	should be passed to mac80211. The filter_flags is the combination
 *	of FIF_* flags. The changed_flags is a bit mask that indicates
 *	which flags are changed.
 *	This callback can sleep.
 *
 * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit
 * 	must be set or cleared for a given STA. Must be atomic.
 *
 * @set_key: See the section "Hardware crypto acceleration"
 *	This callback is only called between add_interface and
 *	remove_interface calls, i.e. while the given virtual interface
 *	is enabled.
 *	Returns a negative error code if the key can't be added.
 *	The callback can sleep.
 *
 * @update_tkip_key: See the section "Hardware crypto acceleration"
 * 	This callback will be called in the context of Rx. Called for drivers
 * 	which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
 *	The callback must be atomic.
 *
 * @set_rekey_data: If the device supports GTK rekeying, for example while the
 *	host is suspended, it can assign this callback to retrieve the data
 *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
 *	After rekeying was done it should (for example during resume) notify
 *	userspace of the new replay counter using ieee80211_gtk_rekey_notify().
 *
 * @set_default_unicast_key: Set the default (unicast) key index, useful for
 *	WEP when the device sends data packets autonomously, e.g. for ARP
 *	offloading. The index can be 0-3, or -1 for unsetting it.
 *
 * @hw_scan: Ask the hardware to service the scan request, no need to start
 *	the scan state machine in stack. The scan must honour the channel
 *	configuration done by the regulatory agent in the wiphy's
 *	registered bands. The hardware (or the driver) needs to make sure
 *	that power save is disabled.
 *	The @req ie/ie_len members are rewritten by mac80211 to contain the
 *	entire IEs after the SSID, so that drivers need not look at these
 *	at all but just send them after the SSID -- mac80211 includes the
 *	(extended) supported rates and HT information (where applicable).
 *	When the scan finishes, ieee80211_scan_completed() must be called;
 *	note that it also must be called when the scan cannot finish due to
 *	any error unless this callback returned a negative error code.
 *	The callback can sleep.
 *
 * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.
 *	The driver should ask the hardware to cancel the scan (if possible),
 *	but the scan will be completed only after the driver will call
 *	ieee80211_scan_completed().
 *	This callback is needed for wowlan, to prevent enqueueing a new
 *	scan_work after the low-level driver was already suspended.
 *	The callback can sleep.
 *
 * @sched_scan_start: Ask the hardware to start scanning repeatedly at
 *	specific intervals.  The driver must call the
 *	ieee80211_sched_scan_results() function whenever it finds results.
 *	This process will continue until sched_scan_stop is called.
 *
 * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
 *	In this case, ieee80211_sched_scan_stopped() must not be called.
 *
 * @sw_scan_start: Notifier function that is called just before a software scan
 *	is started. Can be NULL, if the driver doesn't need this notification.
 *	The mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,
 *	the driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it
 *	can use this parameter. The callback can sleep.
 *
 * @sw_scan_complete: Notifier function that is called just after a
 *	software scan finished. Can be NULL, if the driver doesn't need
 *	this notification.
 *	The callback can sleep.
 *
 * @get_stats: Return low-level statistics.
 * 	Returns zero if statistics are available.
 *	The callback can sleep.
 *
 * @get_key_seq: If your device implements encryption in hardware and does
 *	IV/PN assignment then this callback should be provided to read the
 *	IV/PN for the given key from hardware.
 *	The callback must be atomic.
 *
 * @set_frag_threshold: Configuration of fragmentation threshold. Assign this
 *	if the device does fragmentation by itself; if this callback is
 *	implemented then the stack will not do fragmentation.
 *	The callback can sleep.
 *
 * @set_rts_threshold: Configuration of RTS threshold (if device needs it)
 *	The callback can sleep.
 *
 * @sta_add: Notifies low level driver about addition of an associated station,
 *	AP, IBSS/WDS/mesh peer etc. This callback can sleep.
 *
 * @sta_remove: Notifies low level driver about removal of an associated
 *	station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
 *	returns it isn't safe to use the pointer, not even RCU protected;
 *	no RCU grace period is guaranteed between returning here and freeing
 *	the station. See @sta_pre_rcu_remove if needed.
 *	This callback can sleep.
 *
 * @sta_add_debugfs: Drivers can use this callback to add debugfs files
 *	when a station is added to mac80211's station list. This callback
 *	should be within a CONFIG_MAC80211_DEBUGFS conditional. This
 *	callback can sleep.
 *
 * @sta_notify: Notifies low level driver about power state transition of an
 *	associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
 *	in AP mode, this callback will not be called when the flag
 *	%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.
 *
 * @sta_state: Notifies low level driver about state transition of a
 *	station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
 *	This callback is mutually exclusive with @sta_add/@sta_remove.
 *	It must not fail for down transitions but may fail for transitions
 *	up the list of states. Also note that after the callback returns it
 *	isn't safe to use the pointer, not even RCU protected - no RCU grace
 *	period is guaranteed between returning here and freeing the station.
 *	See @sta_pre_rcu_remove if needed.
 *	The callback can sleep.
 *
 * @sta_pre_rcu_remove: Notify driver about station removal before RCU
 *	synchronisation. This is useful if a driver needs to have station
 *	pointers protected using RCU, it can then use this call to clear
 *	the pointers instead of waiting for an RCU grace period to elapse
 *	in @sta_state.
 *	The callback can sleep.
 *
 * @sta_rc_update: Notifies the driver of changes to the bitrates that can be
 *	used to transmit to the station. The changes are advertised with bits
 *	from &enum ieee80211_rate_control_changed and the values are reflected
 *	in the station data. This callback should only be used when the driver
 *	uses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since
 *	otherwise the rate control algorithm is notified directly.
 *	Must be atomic.
 * @sta_rate_tbl_update: Notifies the driver that the rate table changed. This
 *	is only used if the configured rate control algorithm actually uses
 *	the new rate table API, and is therefore optional. Must be atomic.
 *
 * @sta_statistics: Get statistics for this station. For example with beacon
 *	filtering, the statistics kept by mac80211 might not be accurate, so
 *	let the driver pre-fill the statistics. The driver can fill most of
 *	the values (indicating which by setting the filled bitmap), but not
 *	all of them make sense - see the source for which ones are possible.
 *	Statistics that the driver doesn't fill will be filled by mac80211.
 *	The callback can sleep.
 *
 * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
 *	bursting) for a hardware TX queue.
 *	Returns a negative error code on failure.
 *	The callback can sleep.
 *
 * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,
 *	this is only used for IBSS mode BSSID merging and debugging. Is not a
 *	required function.
 *	The callback can sleep.
 *
 * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.
 *	Currently, this is only used for IBSS mode debugging. Is not a
 *	required function.
 *	The callback can sleep.
 *
 * @offset_tsf: Offset the TSF timer by the specified value in the
 *	firmware/hardware.  Preferred to set_tsf as it avoids delay between
 *	calling set_tsf() and hardware getting programmed, which will show up
 *	as TSF delay. Is not a required function.
 *	The callback can sleep.
 *
 * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize
 *	with other STAs in the IBSS. This is only used in IBSS mode. This
 *	function is optional if the firmware/hardware takes full care of
 *	TSF synchronization.
 *	The callback can sleep.
 *
 * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.
 *	This is needed only for IBSS mode and the result of this function is
 *	used to determine whether to reply to Probe Requests.
 *	Returns non-zero if this device sent the last beacon.
 *	The callback can sleep.
 *
 * @ampdu_action: Perform a certain A-MPDU action
 * 	The RA/TID combination determines the destination and TID we want
 * 	the ampdu action to be performed for. The action is defined through
 *	ieee80211_ampdu_mlme_action.
 *	When the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL the driver
 *	may neither send aggregates containing more subframes than @buf_size
 *	nor send aggregates in a way that lost frames would exceed the
 *	buffer size. If just limiting the aggregate size, this would be
 *	possible with a buf_size of 8:
 *	 - TX: 1.....7
 *	 - RX:  2....7 (lost frame #1)
 *	 - TX:        8..1...
 *	which is invalid since #1 was now re-transmitted well past the
 *	buffer size of 8. Correct ways to retransmit #1 would be:
 *	 - TX:       1 or 18 or 81
 *	Even "189" would be wrong since 1 could be lost again.
 *
 *	Returns a negative error code on failure.
 *	The callback can sleep.
 *
 * @get_survey: Return per-channel survey information
 *
 * @rfkill_poll: Poll rfkill hardware state. If you need this, you also
 *	need to set wiphy->rfkill_poll to %true before registration,
 *	and need to call wiphy_rfkill_set_hw_state() in the callback.
 *	The callback can sleep.
 *
 * @set_coverage_class: Set slot time for given coverage class as specified
 *	in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
 *	accordingly; coverage class equals to -1 to enable ACK timeout
 *	estimation algorithm (dynack). To disable dynack set valid value for
 *	coverage class. This callback is not required and may sleep.
 *
 * @testmode_cmd: Implement a cfg80211 test mode command. The passed @vif may
 *	be %NULL. The callback can sleep.
 * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.
 *
 * @flush: Flush all pending frames from the hardware queue, making sure
 *	that the hardware queues are empty. The @queues parameter is a bitmap
 *	of queues to flush, which is useful if different virtual interfaces
 *	use different hardware queues; it may also indicate all queues.
 *	If the parameter @drop is set to %true, pending frames may be dropped.
 *	Note that vif can be NULL.
 *	The callback can sleep.
 *
 * @channel_switch: Drivers that need (or want) to offload the channel
 *	switch operation for CSAs received from the AP may implement this
 *	callback. They must then call ieee80211_chswitch_done() to indicate
 *	completion of the channel switch.
 *
 * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
 *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
 *	reject TX/RX mask combinations they cannot support by returning -EINVAL
 *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).
 *
 * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
 *
 * @remain_on_channel: Starts an off-channel period on the given channel, must
 *	call back to ieee80211_ready_on_channel() when on that channel. Note
 *	that normal channel traffic is not stopped as this is intended for hw
 *	offload. Frames to transmit on the off-channel channel are transmitted
 *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
 *	duration (which will always be non-zero) expires, the driver must call
 *	ieee80211_remain_on_channel_expired().
 *	Note that this callback may be called while the device is in IDLE and
 *	must be accepted in this case.
 *	This callback may sleep.
 * @cancel_remain_on_channel: Requests that an ongoing off-channel period is
 *	aborted before it expires. This callback may sleep.
 *
 * @set_ringparam: Set tx and rx ring sizes.
 *
 * @get_ringparam: Get tx and rx ring current and maximum sizes.
 *
 * @tx_frames_pending: Check if there is any pending frame in the hardware
 *	queues before entering power save.
 *
 * @set_bitrate_mask: Set a mask of rates to be used for rate control selection
 *	when transmitting a frame. Currently only legacy rates are handled.
 *	The callback can sleep.
 * @event_callback: Notify driver about any event in mac80211. See
 *	&enum ieee80211_event_type for the different types.
 *	The callback must be atomic.
 *
 * @release_buffered_frames: Release buffered frames according to the given
 *	parameters. In the case where the driver buffers some frames for
 *	sleeping stations mac80211 will use this callback to tell the driver
 *	to release some frames, either for PS-poll or uAPSD.
 *	Note that if the @more_data parameter is %false the driver must check
 *	if there are more frames on the given TIDs, and if there are more than
 *	the frames being released then it must still set the more-data bit in
 *	the frame. If the @more_data parameter is %true, then of course the
 *	more-data bit must always be set.
 *	The @tids parameter tells the driver which TIDs to release frames
 *	from, for PS-poll it will always have only a single bit set.
 *	In the case this is used for a PS-poll initiated release, the
 *	@num_frames parameter will always be 1 so code can be shared. In
 *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag
 *	on the TX status (and must report TX status) so that the PS-poll
 *	period is properly ended. This is used to avoid sending multiple
 *	responses for a retried PS-poll frame.
 *	In the case this is used for uAPSD, the @num_frames parameter may be
 *	bigger than one, but the driver may send fewer frames (it must send
 *	at least one, however). In this case it is also responsible for
 *	setting the EOSP flag in the QoS header of the frames. Also, when the
 *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP
 *	on the last frame in the SP. Alternatively, it may call the function
 *	ieee80211_sta_eosp() to inform mac80211 of the end of the SP.
 *	This callback must be atomic.
 * @allow_buffered_frames: Prepare device to allow the given number of frames
 *	to go out to the given station. The frames will be sent by mac80211
 *	via the usual TX path after this call. The TX information for frames
 *	released will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set
 *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case
 *	frames from multiple TIDs are released and the driver might reorder
 *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag
 *	on the last frame and clear it on all others and also handle the EOSP
 *	bit in the QoS header correctly. Alternatively, it can also call the
 *	ieee80211_sta_eosp() function.
 *	The @tids parameter is a bitmap and tells the driver which TIDs the
 *	frames will be on; it will at most have two bits set.
 *	This callback must be atomic.
 *
 * @get_et_sset_count:  Ethtool API to get string-set count.
 *
 * @get_et_stats:  Ethtool API to get a set of u64 stats.
 *
 * @get_et_strings:  Ethtool API to get a set of strings to describe stats
 *	and perhaps other supported types of ethtool data-sets.
 *
 * @mgd_prepare_tx: Prepare for transmitting a management frame for association
 *	before associated. In multi-channel scenarios, a virtual interface is
 *	bound to a channel before it is associated, but as it isn't associated
 *	yet it need not necessarily be given airtime, in particular since any
 *	transmission to a P2P GO needs to be synchronized against the GO's
 *	powersave state. mac80211 will call this function before transmitting a
 *	management frame prior to having successfully associated to allow the
 *	driver to give it channel time for the transmission, to get a response
 *	and to be able to synchronize with the GO.
 *	The callback will be called before each transmission and upon return
 *	mac80211 will transmit the frame right away.
 *	The callback is optional and can (should!) sleep.
 *
 * @mgd_protect_tdls_discover: Protect a TDLS discovery session. After sending
 *	a TDLS discovery-request, we expect a reply to arrive on the AP's
 *	channel. We must stay on the channel (no PSM, scan, etc.), since a TDLS
 *	setup-response is a direct packet not buffered by the AP.
 *	mac80211 will call this function just before the transmission of a TDLS
 *	discovery-request. The recommended period of protection is at least
 *	2 * (DTIM period).
 *	The callback is optional and can sleep.
 *
 * @add_chanctx: Notifies device driver about new channel context creation.
 *	This callback may sleep.
 * @remove_chanctx: Notifies device driver about channel context destruction.
 *	This callback may sleep.
 * @change_chanctx: Notifies device driver about channel context changes that
 *	may happen when combining different virtual interfaces on the same
 *	channel context with different settings
 *	This callback may sleep.
 * @assign_vif_chanctx: Notifies device driver about channel context being bound
 *	to vif. Possible use is for hw queue remapping.
 *	This callback may sleep.
 * @unassign_vif_chanctx: Notifies device driver about channel context being
 *	unbound from vif.
 *	This callback may sleep.
 * @switch_vif_chanctx: switch a number of vifs from one chanctx to
 *	another, as specified in the list of
 *	@ieee80211_vif_chanctx_switch passed to the driver, according
 *	to the mode defined in &ieee80211_chanctx_switch_mode.
 *	This callback may sleep.
 *
 * @start_ap: Start operation on the AP interface, this is called after all the
 *	information in bss_conf is set and beacon can be retrieved. A channel
 *	context is bound before this is called. Note that if the driver uses
 *	software scan or ROC, this (and @stop_ap) isn't called when the AP is
 *	just "paused" for scanning/ROC, which is indicated by the beacon being
 *	disabled/enabled via @bss_info_changed.
 * @stop_ap: Stop operation on the AP interface.
 *
 * @reconfig_complete: Called after a call to ieee80211_restart_hw() and
 *	during resume, when the reconfiguration has completed.
 *	This can help the driver implement the reconfiguration step (and
 *	indicate mac80211 is ready to receive frames).
 *	This callback may sleep.
 *
 * @ipv6_addr_change: IPv6 address assignment on the given interface changed.
 *	Currently, this is only called for managed or P2P client interfaces.
 *	This callback is optional; it must not sleep.
 *
 * @channel_switch_beacon: Starts a channel switch to a new channel.
 *	Beacons are modified to include CSA or ECSA IEs before calling this
 *	function. The corresponding count fields in these IEs must be
 *	decremented, and when they reach 1 the driver must call
 *	ieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()
 *	get the csa counter decremented by mac80211, but must check if it is
 *	1 using ieee80211_csa_is_complete() after the beacon has been
 *	transmitted and then call ieee80211_csa_finish().
 *	If the CSA count starts as zero or 1, this function will not be called,
 *	since there won't be any time to beacon before the switch anyway.
 * @pre_channel_switch: This is an optional callback that is called
 *	before a channel switch procedure is started (ie. when a STA
 *	gets a CSA or an userspace initiated channel-switch), allowing
 *	the driver to prepare for the channel switch.
 * @post_channel_switch: This is an optional callback that is called
 *	after a channel switch procedure is completed, allowing the
 *	driver to go back to a normal configuration.
 *
 * @join_ibss: Join an IBSS (on an IBSS interface); this is called after all
 *	information in bss_conf is set up and the beacon can be retrieved. A
 *	channel context is bound before this is called.
 * @leave_ibss: Leave the IBSS again.
 *
 * @get_expected_throughput: extract the expected throughput towards the
 *	specified station. The returned value is expressed in Kbps. It returns 0
 *	if the RC algorithm does not have proper data to provide.
 *
 * @get_txpower: get current maximum tx power (in dBm) based on configuration
 *	and hardware limits.
 *
 * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver
 *	is responsible for continually initiating channel-switching operations
 *	and returning to the base channel for communication with the AP. The
 *	driver receives a channel-switch request template and the location of
 *	the switch-timing IE within the template as part of the invocation.
 *	The template is valid only within the call, and the driver can
 *	optionally copy the skb for further re-use.
 * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both
 *	peers must be on the base channel when the call completes.
 * @tdls_recv_channel_switch: a TDLS channel-switch related frame (request or
 *	response) has been received from a remote peer. The driver gets
 *	parameters parsed from the incoming frame and may use them to continue
 *	an ongoing channel-switch operation. In addition, a channel-switch
 *	response template is provided, together with the location of the
 *	switch-timing IE within the template. The skb can only be used within
 *	the function call.
 *
 * @wake_tx_queue: Called when new packets have been added to the queue.
 * @sync_rx_queues: Process all pending frames in RSS queues. This is a
 *	synchronization which is needed in case driver has in its RSS queues
 *	pending frames that were received prior to the control path action
 *	currently taken (e.g. disassociation) but are not processed yet.
 *
 * @start_nan: join an existing NAN cluster, or create a new one.
 * @stop_nan: leave the NAN cluster.
 * @nan_change_conf: change NAN configuration. The data in cfg80211_nan_conf
 *	contains full new configuration and changes specify which parameters
 *	are changed with respect to the last NAN config.
 *	The driver gets both full configuration and the changed parameters since
 *	some devices may need the full configuration while others need only the
 *	changed parameters.
 * @add_nan_func: Add a NAN function. Returns 0 on success. The data in
 *	cfg80211_nan_func must not be referenced outside the scope of
 *	this call.
 * @del_nan_func: Remove a NAN function. The driver must call
 *	ieee80211_nan_func_terminated() with
 *	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST reason code upon removal.
 */
struct ieee80211_ops {
	void (*tx)(struct ieee80211_hw *hw,
		   struct ieee80211_tx_control *control,
		   struct sk_buff *skb);
	int (*start)(struct ieee80211_hw *hw);
	void (*stop)(struct ieee80211_hw *hw);
#ifdef CONFIG_PM
	int (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
	int (*resume)(struct ieee80211_hw *hw);
	void (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);
#endif
	int (*add_interface)(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif);
	int (*change_interface)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				enum nl80211_iftype new_type, bool p2p);
	void (*remove_interface)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif);
	int (*config)(struct ieee80211_hw *hw, u32 changed);
	void (*bss_info_changed)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct ieee80211_bss_conf *info,
				 u32 changed);

	int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);

	u64 (*prepare_multicast)(struct ieee80211_hw *hw,
				 struct netdev_hw_addr_list *mc_list);
	void (*configure_filter)(struct ieee80211_hw *hw,
				 unsigned int changed_flags,
				 unsigned int *total_flags,
				 u64 multicast);
	void (*config_iface_filter)(struct ieee80211_hw *hw,
				    struct ieee80211_vif *vif,
				    unsigned int filter_flags,
				    unsigned int changed_flags);
	int (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
		       bool set);
	int (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,
		       struct ieee80211_vif *vif, struct ieee80211_sta *sta,
		       struct ieee80211_key_conf *key);
	void (*update_tkip_key)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct ieee80211_key_conf *conf,
				struct ieee80211_sta *sta,
				u32 iv32, u16 *phase1key);
	void (*set_rekey_data)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct cfg80211_gtk_rekey_data *data);
	void (*set_default_unicast_key)(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif, int idx);
	int (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		       struct ieee80211_scan_request *req);
	void (*cancel_hw_scan)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif);
	int (*sched_scan_start)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct cfg80211_sched_scan_request *req,
				struct ieee80211_scan_ies *ies);
	int (*sched_scan_stop)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif);
	void (*sw_scan_start)(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      const u8 *mac_addr);
	void (*sw_scan_complete)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif);
	int (*get_stats)(struct ieee80211_hw *hw,
			 struct ieee80211_low_level_stats *stats);
	void (*get_key_seq)(struct ieee80211_hw *hw,
			    struct ieee80211_key_conf *key,
			    struct ieee80211_key_seq *seq);
	int (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);
	int (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);
	int (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		       struct ieee80211_sta *sta);
	int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			  struct ieee80211_sta *sta);
#ifdef CONFIG_MAC80211_DEBUGFS
	void (*sta_add_debugfs)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct ieee80211_sta *sta,
				struct dentry *dir);
#endif
	void (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			enum sta_notify_cmd, struct ieee80211_sta *sta);
	int (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			 struct ieee80211_sta *sta,
			 enum ieee80211_sta_state old_state,
			 enum ieee80211_sta_state new_state);
	void (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif,
				   struct ieee80211_sta *sta);
	void (*sta_rc_update)(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      struct ieee80211_sta *sta,
			      u32 changed);
	void (*sta_rate_tbl_update)(struct ieee80211_hw *hw,
				    struct ieee80211_vif *vif,
				    struct ieee80211_sta *sta);
	void (*sta_statistics)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct ieee80211_sta *sta,
			       struct station_info *sinfo);
	int (*conf_tx)(struct ieee80211_hw *hw,
		       struct ieee80211_vif *vif, u16 ac,
		       const struct ieee80211_tx_queue_params *params);
	u64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	void (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			u64 tsf);
	void (*offset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			   s64 offset);
	void (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	int (*tx_last_beacon)(struct ieee80211_hw *hw);
	int (*ampdu_action)(struct ieee80211_hw *hw,
			    struct ieee80211_vif *vif,
			    struct ieee80211_ampdu_params *params);
	int (*get_survey)(struct ieee80211_hw *hw, int idx,
		struct survey_info *survey);
	void (*rfkill_poll)(struct ieee80211_hw *hw);
	void (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);
#ifdef CONFIG_NL80211_TESTMODE
	int (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			    void *data, int len);
	int (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,
			     struct netlink_callback *cb,
			     void *data, int len);
#endif
	void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		      u32 queues, bool drop);
	void (*channel_switch)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct ieee80211_channel_switch *ch_switch);
	int (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
	int (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);

	int (*remain_on_channel)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct ieee80211_channel *chan,
				 int duration,
				 enum ieee80211_roc_type type);
	int (*cancel_remain_on_channel)(struct ieee80211_hw *hw);
	int (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);
	void (*get_ringparam)(struct ieee80211_hw *hw,
			      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
	bool (*tx_frames_pending)(struct ieee80211_hw *hw);
	int (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
				const struct cfg80211_bitrate_mask *mask);
	void (*event_callback)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       const struct ieee80211_event *event);

	void (*allow_buffered_frames)(struct ieee80211_hw *hw,
				      struct ieee80211_sta *sta,
				      u16 tids, int num_frames,
				      enum ieee80211_frame_release_type reason,
				      bool more_data);
	void (*release_buffered_frames)(struct ieee80211_hw *hw,
					struct ieee80211_sta *sta,
					u16 tids, int num_frames,
					enum ieee80211_frame_release_type reason,
					bool more_data);

	int	(*get_et_sset_count)(struct ieee80211_hw *hw,
				     struct ieee80211_vif *vif, int sset);
	void	(*get_et_stats)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct ethtool_stats *stats, u64 *data);
	void	(*get_et_strings)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif,
				  u32 sset, u8 *data);

	void	(*mgd_prepare_tx)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif);

	void	(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,
					     struct ieee80211_vif *vif);

	int (*add_chanctx)(struct ieee80211_hw *hw,
			   struct ieee80211_chanctx_conf *ctx);
	void (*remove_chanctx)(struct ieee80211_hw *hw,
			       struct ieee80211_chanctx_conf *ctx);
	void (*change_chanctx)(struct ieee80211_hw *hw,
			       struct ieee80211_chanctx_conf *ctx,
			       u32 changed);
	int (*assign_vif_chanctx)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif,
				  struct ieee80211_chanctx_conf *ctx);
	void (*unassign_vif_chanctx)(struct ieee80211_hw *hw,
				     struct ieee80211_vif *vif,
				     struct ieee80211_chanctx_conf *ctx);
	int (*switch_vif_chanctx)(struct ieee80211_hw *hw,
				  struct ieee80211_vif_chanctx_switch *vifs,
				  int n_vifs,
				  enum ieee80211_chanctx_switch_mode mode);

	void (*reconfig_complete)(struct ieee80211_hw *hw,
				  enum ieee80211_reconfig_type reconfig_type);

#if IS_ENABLED(CONFIG_IPV6)
	void (*ipv6_addr_change)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct inet6_dev *idev);
#endif
	void (*channel_switch_beacon)(struct ieee80211_hw *hw,
				      struct ieee80211_vif *vif,
				      struct cfg80211_chan_def *chandef);
	int (*pre_channel_switch)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif,
				  struct ieee80211_channel_switch *ch_switch);

	int (*post_channel_switch)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif);

	int (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	void (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	u32 (*get_expected_throughput)(struct ieee80211_hw *hw,
				       struct ieee80211_sta *sta);
	int (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			   int *dbm);

	int (*tdls_channel_switch)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif,
				   struct ieee80211_sta *sta, u8 oper_class,
				   struct cfg80211_chan_def *chandef,
				   struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);
	void (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,
					   struct ieee80211_vif *vif,
					   struct ieee80211_sta *sta);
	void (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,
					 struct ieee80211_vif *vif,
					 struct ieee80211_tdls_ch_sw_params *params);

	void (*wake_tx_queue)(struct ieee80211_hw *hw,
			      struct ieee80211_txq *txq);
	void (*sync_rx_queues)(struct ieee80211_hw *hw);

	int (*start_nan)(struct ieee80211_hw *hw,
			 struct ieee80211_vif *vif,
			 struct cfg80211_nan_conf *conf);
	int (*stop_nan)(struct ieee80211_hw *hw,
			struct ieee80211_vif *vif);
	int (*nan_change_conf)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct cfg80211_nan_conf *conf, u32 changes);
	int (*add_nan_func)(struct ieee80211_hw *hw,
			    struct ieee80211_vif *vif,
			    const struct cfg80211_nan_func *nan_func);
	void (*del_nan_func)(struct ieee80211_hw *hw,
			    struct ieee80211_vif *vif,
			    u8 instance_id);
};

/**
 * ieee80211_alloc_hw_nm - Allocate a new hardware device
 *
 * This must be called once for each hardware device. The returned pointer
 * must be used to refer to this device when calling other functions.
 * mac80211 allocates a private data area for the driver pointed to by
 * @priv in &struct ieee80211_hw, the size of this area is given as
 * @priv_data_len.
 *
 * @priv_data_len: length of private data
 * @ops: callbacks for this device
 * @requested_name: Requested name for this device.
 *	NULL is valid value, and means use the default naming (phy%d)
 *
 * Return: A pointer to the new hardware device, or %NULL on error.
 */
struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
					   const struct ieee80211_ops *ops,
					   const char *requested_name);

/**
 * ieee80211_alloc_hw - Allocate a new hardware device
 *
 * This must be called once for each hardware device. The returned pointer
 * must be used to refer to this device when calling other functions.
 * mac80211 allocates a private data area for the driver pointed to by
 * @priv in &struct ieee80211_hw, the size of this area is given as
 * @priv_data_len.
 *
 * @priv_data_len: length of private data
 * @ops: callbacks for this device
 *
 * Return: A pointer to the new hardware device, or %NULL on error.
 */
static inline
struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
					const struct ieee80211_ops *ops)
{
	return ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);
}

/**
 * ieee80211_register_hw - Register hardware device
 *
 * You must call this function before any other functions in
 * mac80211. Note that before a hardware can be registered, you
 * need to fill the contained wiphy's information.
 *
 * @hw: the device to register as returned by ieee80211_alloc_hw()
 *
 * Return: 0 on success. An error code otherwise.
 */
int ieee80211_register_hw(struct ieee80211_hw *hw);

/**
 * struct ieee80211_tpt_blink - throughput blink description
 * @throughput: throughput in Kbit/sec
 * @blink_time: blink time in milliseconds
 *	(full cycle, ie. one off + one on period)
 */
struct ieee80211_tpt_blink {
	int throughput;
	int blink_time;
};

/**
 * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags
 * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio
 * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working
 * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one
 *	interface is connected in some way, including being an AP
 */
enum ieee80211_tpt_led_trigger_flags {
	IEEE80211_TPT_LEDTRIG_FL_RADIO		= BIT(0),
	IEEE80211_TPT_LEDTRIG_FL_WORK		= BIT(1),
	IEEE80211_TPT_LEDTRIG_FL_CONNECTED	= BIT(2),
};

#ifdef CONFIG_MAC80211_LEDS
const char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
const char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
const char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
const char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
const char *
__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
				   unsigned int flags,
				   const struct ieee80211_tpt_blink *blink_table,
				   unsigned int blink_table_len);
#endif
/**
 * ieee80211_get_tx_led_name - get name of TX LED
 *
 * mac80211 creates a transmit LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline const char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_tx_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_get_rx_led_name - get name of RX LED
 *
 * mac80211 creates a receive LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline const char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_rx_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_get_assoc_led_name - get name of association LED
 *
 * mac80211 creates a association LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline const char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_assoc_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_get_radio_led_name - get name of radio LED
 *
 * mac80211 creates a radio change LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline const char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_radio_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_create_tpt_led_trigger - create throughput LED trigger
 * @hw: the hardware to create the trigger for
 * @flags: trigger flags, see &enum ieee80211_tpt_led_trigger_flags
 * @blink_table: the blink table -- needs to be ordered by throughput
 * @blink_table_len: size of the blink table
 *
 * Return: %NULL (in case of error, or if no LED triggers are
 * configured) or the name of the new trigger.
 *
 * Note: This function must be called before ieee80211_register_hw().
 */
static inline const char *
ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
				 const struct ieee80211_tpt_blink *blink_table,
				 unsigned int blink_table_len)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,
						  blink_table_len);
#else
	return NULL;
#endif
}

/**
 * ieee80211_unregister_hw - Unregister a hardware device
 *
 * This function instructs mac80211 to free allocated resources
 * and unregister netdevices from the networking subsystem.
 *
 * @hw: the hardware to unregister
 */
void ieee80211_unregister_hw(struct ieee80211_hw *hw);

/**
 * ieee80211_free_hw - free hardware descriptor
 *
 * This function frees everything that was allocated, including the
 * private data for the driver. You must call ieee80211_unregister_hw()
 * before calling this function.
 *
 * @hw: the hardware to free
 */
void ieee80211_free_hw(struct ieee80211_hw *hw);

/**
 * ieee80211_restart_hw - restart hardware completely
 *
 * Call this function when the hardware was restarted for some reason
 * (hardware error, ...) and the driver is unable to restore its state
 * by itself. mac80211 assumes that at this point the driver/hardware
 * is completely uninitialised and stopped, it starts the process by
 * calling the ->start() operation. The driver will need to reset all
 * internal state that it has prior to calling this function.
 *
 * @hw: the hardware to restart
 */
void ieee80211_restart_hw(struct ieee80211_hw *hw);

/**
 * ieee80211_rx_napi - receive frame from NAPI context
 *
 * Use this function to hand received frames to mac80211. The receive
 * buffer in @skb must start with an IEEE 802.11 header. In case of a
 * paged @skb is used, the driver is recommended to put the ieee80211
 * header of the frame on the linear part of the @skb to avoid memory
 * allocation and/or memcpy by the stack.
 *
 * This function may not be called in IRQ context. Calls to this function
 * for a single hardware must be synchronized against each other. Calls to
 * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be
 * mixed for a single hardware. Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * This function must be called with BHs disabled.
 *
 * @hw: the hardware this frame came in on
 * @sta: the station the frame was received from, or %NULL
 * @skb: the buffer to receive, owned by mac80211 after this call
 * @napi: the NAPI context
 */
void ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
		       struct sk_buff *skb, struct napi_struct *napi);

/**
 * ieee80211_rx - receive frame
 *
 * Use this function to hand received frames to mac80211. The receive
 * buffer in @skb must start with an IEEE 802.11 header. In case of a
 * paged @skb is used, the driver is recommended to put the ieee80211
 * header of the frame on the linear part of the @skb to avoid memory
 * allocation and/or memcpy by the stack.
 *
 * This function may not be called in IRQ context. Calls to this function
 * for a single hardware must be synchronized against each other. Calls to
 * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be
 * mixed for a single hardware. Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * In process context use instead ieee80211_rx_ni().
 *
 * @hw: the hardware this frame came in on
 * @skb: the buffer to receive, owned by mac80211 after this call
 */
static inline void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)
{
	ieee80211_rx_napi(hw, NULL, skb, NULL);
}

/**
 * ieee80211_rx_irqsafe - receive frame
 *
 * Like ieee80211_rx() but can be called in IRQ context
 * (internally defers to a tasklet.)
 *
 * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not
 * be mixed for a single hardware.Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * @hw: the hardware this frame came in on
 * @skb: the buffer to receive, owned by mac80211 after this call
 */
void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);

/**
 * ieee80211_rx_ni - receive frame (in process context)
 *
 * Like ieee80211_rx() but can be called in process context
 * (internally disables bottom halves).
 *
 * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may
 * not be mixed for a single hardware. Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * @hw: the hardware this frame came in on
 * @skb: the buffer to receive, owned by mac80211 after this call
 */
static inline void ieee80211_rx_ni(struct ieee80211_hw *hw,
				   struct sk_buff *skb)
{
	local_bh_disable();
	ieee80211_rx(hw, skb);
	local_bh_enable();
}

/**
 * ieee80211_sta_ps_transition - PS transition for connected sta
 *
 * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS
 * flag set, use this function to inform mac80211 about a connected station
 * entering/leaving PS mode.
 *
 * This function may not be called in IRQ context or with softirqs enabled.
 *
 * Calls to this function for a single hardware must be synchronized against
 * each other.
 *
 * @sta: currently connected sta
 * @start: start or stop PS
 *
 * Return: 0 on success. -EINVAL when the requested PS mode is already set.
 */
int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);

/**
 * ieee80211_sta_ps_transition_ni - PS transition for connected sta
 *                                  (in process context)
 *
 * Like ieee80211_sta_ps_transition() but can be called in process context
 * (internally disables bottom halves). Concurrent call restriction still
 * applies.
 *
 * @sta: currently connected sta
 * @start: start or stop PS
 *
 * Return: Like ieee80211_sta_ps_transition().
 */
static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
						  bool start)
{
	int ret;

	local_bh_disable();
	ret = ieee80211_sta_ps_transition(sta, start);
	local_bh_enable();

	return ret;
}

/**
 * ieee80211_sta_pspoll - PS-Poll frame received
 * @sta: currently connected station
 *
 * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,
 * use this function to inform mac80211 that a PS-Poll frame from a
 * connected station was received.
 * This must be used in conjunction with ieee80211_sta_ps_transition()
 * and possibly ieee80211_sta_uapsd_trigger(); calls to all three must
 * be serialized.
 */
void ieee80211_sta_pspoll(struct ieee80211_sta *sta);

/**
 * ieee80211_sta_uapsd_trigger - (potential) U-APSD trigger frame received
 * @sta: currently connected station
 * @tid: TID of the received (potential) trigger frame
 *
 * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,
 * use this function to inform mac80211 that a (potential) trigger frame
 * from a connected station was received.
 * This must be used in conjunction with ieee80211_sta_ps_transition()
 * and possibly ieee80211_sta_pspoll(); calls to all three must be
 * serialized.
 */
void ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid);

/*
 * The TX headroom reserved by mac80211 for its own tx_status functions.
 * This is enough for the radiotap header.
 */
#define IEEE80211_TX_STATUS_HEADROOM	14

/**
 * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames
 * @sta: &struct ieee80211_sta pointer for the sleeping station
 * @tid: the TID that has buffered frames
 * @buffered: indicates whether or not frames are buffered for this TID
 *
 * If a driver buffers frames for a powersave station instead of passing
 * them back to mac80211 for retransmission, the station may still need
 * to be told that there are buffered frames via the TIM bit.
 *
 * This function informs mac80211 whether or not there are frames that are
 * buffered in the driver for a given TID; mac80211 can then use this data
 * to set the TIM bit (NOTE: This may call back into the driver's set_tim
 * call! Beware of the locking!)
 *
 * If all frames are released to the station (due to PS-poll or uAPSD)
 * then the driver needs to inform mac80211 that there no longer are
 * frames buffered. However, when the station wakes up mac80211 assumes
 * that all buffered frames will be transmitted and clears this data,
 * drivers need to make sure they inform mac80211 about all buffered
 * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).
 *
 * Note that technically mac80211 only needs to know this per AC, not per
 * TID, but since driver buffering will inevitably happen per TID (since
 * it is related to aggregation) it is easier to make mac80211 map the
 * TID to the AC as required instead of keeping track in all drivers that
 * use this API.
 */
void ieee80211_sta_set_buffered(struct ieee80211_sta *sta,
				u8 tid, bool buffered);

/**
 * ieee80211_get_tx_rates - get the selected transmit rates for a packet
 *
 * Call this function in a driver with per-packet rate selection support
 * to combine the rate info in the packet tx info with the most recent
 * rate selection table for the station entry.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @sta: the receiver station to which this packet is sent.
 * @skb: the frame to be transmitted.
 * @dest: buffer for extracted rate/retry information
 * @max_rates: maximum number of rates to fetch
 */
void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
			    struct ieee80211_sta *sta,
			    struct sk_buff *skb,
			    struct ieee80211_tx_rate *dest,
			    int max_rates);

/**
 * ieee80211_tx_status - transmit status callback
 *
 * Call this function for all transmitted frames after they have been
 * transmitted. It is permissible to not call this function for
 * multicast frames but this can affect statistics.
 *
 * This function may not be called in IRQ context. Calls to this function
 * for a single hardware must be synchronized against each other. Calls
 * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()
 * may not be mixed for a single hardware. Must not run concurrently with
 * ieee80211_rx() or ieee80211_rx_ni().
 *
 * @hw: the hardware the frame was transmitted by
 * @skb: the frame that was transmitted, owned by mac80211 after this call
 */
void ieee80211_tx_status(struct ieee80211_hw *hw,
			 struct sk_buff *skb);

/**
 * ieee80211_tx_status_noskb - transmit status callback without skb
 *
 * This function can be used as a replacement for ieee80211_tx_status
 * in drivers that cannot reliably map tx status information back to
 * specific skbs.
 *
 * Calls to this function for a single hardware must be synchronized
 * against each other. Calls to this function, ieee80211_tx_status_ni()
 * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.
 *
 * @hw: the hardware the frame was transmitted by
 * @sta: the receiver station to which this packet is sent
 *	(NULL for multicast packets)
 * @info: tx status information
 */
void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
			       struct ieee80211_sta *sta,
			       struct ieee80211_tx_info *info);

/**
 * ieee80211_tx_status_ni - transmit status callback (in process context)
 *
 * Like ieee80211_tx_status() but can be called in process context.
 *
 * Calls to this function, ieee80211_tx_status() and
 * ieee80211_tx_status_irqsafe() may not be mixed
 * for a single hardware.
 *
 * @hw: the hardware the frame was transmitted by
 * @skb: the frame that was transmitted, owned by mac80211 after this call
 */
static inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,
					  struct sk_buff *skb)
{
	local_bh_disable();
	ieee80211_tx_status(hw, skb);
	local_bh_enable();
}

/**
 * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback
 *
 * Like ieee80211_tx_status() but can be called in IRQ context
 * (internally defers to a tasklet.)
 *
 * Calls to this function, ieee80211_tx_status() and
 * ieee80211_tx_status_ni() may not be mixed for a single hardware.
 *
 * @hw: the hardware the frame was transmitted by
 * @skb: the frame that was transmitted, owned by mac80211 after this call
 */
void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
				 struct sk_buff *skb);

/**
 * ieee80211_report_low_ack - report non-responding station
 *
 * When operating in AP-mode, call this function to report a non-responding
 * connected STA.
 *
 * @sta: the non-responding connected sta
 * @num_packets: number of packets sent to @sta without a response
 */
void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);

#define IEEE80211_MAX_CSA_COUNTERS_NUM 2

/**
 * struct ieee80211_mutable_offsets - mutable beacon offsets
 * @tim_offset: position of TIM element
 * @tim_length: size of TIM element
 * @csa_counter_offs: array of IEEE80211_MAX_CSA_COUNTERS_NUM offsets
 *	to CSA counters.  This array can contain zero values which
 *	should be ignored.
 */
struct ieee80211_mutable_offsets {
	u16 tim_offset;
	u16 tim_length;

	u16 csa_counter_offs[IEEE80211_MAX_CSA_COUNTERS_NUM];
};

/**
 * ieee80211_beacon_get_template - beacon template generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
 *	receive the offsets that may be updated by the driver.
 *
 * If the driver implements beaconing modes, it must use this function to
 * obtain the beacon template.
 *
 * This function should be used if the beacon frames are generated by the
 * device, and then the driver must use the returned beacon as the template
 * The driver or the device are responsible to update the DTIM and, when
 * applicable, the CSA count.
 *
 * The driver is responsible for freeing the returned skb.
 *
 * Return: The beacon template. %NULL on error.
 */
struct sk_buff *
ieee80211_beacon_get_template(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      struct ieee80211_mutable_offsets *offs);

/**
 * ieee80211_beacon_get_tim - beacon generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @tim_offset: pointer to variable that will receive the TIM IE offset.
 *	Set to 0 if invalid (in non-AP modes).
 * @tim_length: pointer to variable that will receive the TIM IE length,
 *	(including the ID and length bytes!).
 *	Set to 0 if invalid (in non-AP modes).
 *
 * If the driver implements beaconing modes, it must use this function to
 * obtain the beacon frame.
 *
 * If the beacon frames are generated by the host system (i.e., not in
 * hardware/firmware), the driver uses this function to get each beacon
 * frame from mac80211 -- it is responsible for calling this function exactly
 * once before the beacon is needed (e.g. based on hardware interrupt).
 *
 * The driver is responsible for freeing the returned skb.
 *
 * Return: The beacon template. %NULL on error.
 */
struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
					 struct ieee80211_vif *vif,
					 u16 *tim_offset, u16 *tim_length);

/**
 * ieee80211_beacon_get - beacon generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * See ieee80211_beacon_get_tim().
 *
 * Return: See ieee80211_beacon_get_tim().
 */
static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
						   struct ieee80211_vif *vif)
{
	return ieee80211_beacon_get_tim(hw, vif, NULL, NULL);
}

/**
 * ieee80211_csa_update_counter - request mac80211 to decrement the csa counter
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * The csa counter should be updated after each beacon transmission.
 * This function is called implicitly when
 * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
 * beacon frames are generated by the device, the driver should call this
 * function after each beacon transmission to sync mac80211's csa counters.
 *
 * Return: new csa counter value
 */
u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);

/**
 * ieee80211_csa_finish - notify mac80211 about channel switch
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * After a channel switch announcement was scheduled and the counter in this
 * announcement hits 1, this function must be called by the driver to
 * notify mac80211 that the channel can be changed.
 */
void ieee80211_csa_finish(struct ieee80211_vif *vif);

/**
 * ieee80211_csa_is_complete - find out if counters reached 1
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * This function returns whether the channel switch counters reached zero.
 */
bool ieee80211_csa_is_complete(struct ieee80211_vif *vif);


/**
 * ieee80211_proberesp_get - retrieve a Probe Response template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a Probe Response template which can, for example, be uploaded to
 * hardware. The destination address should be set by the caller.
 *
 * Can only be called in AP mode.
 *
 * Return: The Probe Response template. %NULL on error.
 */
struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif);

/**
 * ieee80211_pspoll_get - retrieve a PS Poll template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a PS Poll a template which can, for example, uploaded to
 * hardware. The template must be updated after association so that correct
 * AID, BSSID and MAC address is used.
 *
 * Note: Caller (or hardware) is responsible for setting the
 * &IEEE80211_FCTL_PM bit.
 *
 * Return: The PS Poll template. %NULL on error.
 */
struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
				     struct ieee80211_vif *vif);

/**
 * ieee80211_nullfunc_get - retrieve a nullfunc template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a Nullfunc template which can, for example, uploaded to
 * hardware. The template must be updated after association so that correct
 * BSSID and address is used.
 *
 * Note: Caller (or hardware) is responsible for setting the
 * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.
 *
 * Return: The nullfunc template. %NULL on error.
 */
struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
				       struct ieee80211_vif *vif);

/**
 * ieee80211_probereq_get - retrieve a Probe Request template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @src_addr: source MAC address
 * @ssid: SSID buffer
 * @ssid_len: length of SSID
 * @tailroom: tailroom to reserve at end of SKB for IEs
 *
 * Creates a Probe Request template which can, for example, be uploaded to
 * hardware.
 *
 * Return: The Probe Request template. %NULL on error.
 */
struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
				       const u8 *src_addr,
				       const u8 *ssid, size_t ssid_len,
				       size_t tailroom);

/**
 * ieee80211_rts_get - RTS frame generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame: pointer to the frame that is going to be protected by the RTS.
 * @frame_len: the frame length (in octets).
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 * @rts: The buffer where to store the RTS frame.
 *
 * If the RTS frames are generated by the host system (i.e., not in
 * hardware/firmware), the low-level driver uses this function to receive
 * the next RTS frame from the 802.11 code. The low-level is responsible
 * for calling this function before and RTS frame is needed.
 */
void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		       const void *frame, size_t frame_len,
		       const struct ieee80211_tx_info *frame_txctl,
		       struct ieee80211_rts *rts);

/**
 * ieee80211_rts_duration - Get the duration field for an RTS frame
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame_len: the length of the frame that is going to be protected by the RTS.
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 *
 * If the RTS is generated in firmware, but the host system must provide
 * the duration field, the low-level driver uses this function to receive
 * the duration field value in little-endian byteorder.
 *
 * Return: The duration.
 */
__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif, size_t frame_len,
			      const struct ieee80211_tx_info *frame_txctl);

/**
 * ieee80211_ctstoself_get - CTS-to-self frame generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
 * @frame_len: the frame length (in octets).
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 * @cts: The buffer where to store the CTS-to-self frame.
 *
 * If the CTS-to-self frames are generated by the host system (i.e., not in
 * hardware/firmware), the low-level driver uses this function to receive
 * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
 * for calling this function before and CTS-to-self frame is needed.
 */
void ieee80211_ctstoself_get(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif,
			     const void *frame, size_t frame_len,
			     const struct ieee80211_tx_info *frame_txctl,
			     struct ieee80211_cts *cts);

/**
 * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 *
 * If the CTS-to-self is generated in firmware, but the host system must provide
 * the duration field, the low-level driver uses this function to receive
 * the duration field value in little-endian byteorder.
 *
 * Return: The duration.
 */
__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
				    struct ieee80211_vif *vif,
				    size_t frame_len,
				    const struct ieee80211_tx_info *frame_txctl);

/**
 * ieee80211_generic_frame_duration - Calculate the duration field for a frame
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @band: the band to calculate the frame duration on
 * @frame_len: the length of the frame.
 * @rate: the rate at which the frame is going to be transmitted.
 *
 * Calculate the duration field of some generic frame, given its
 * length and transmission rate (in 100kbps).
 *
 * Return: The duration.
 */
__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif,
					enum nl80211_band band,
					size_t frame_len,
					struct ieee80211_rate *rate);

/**
 * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Function for accessing buffered broadcast and multicast frames. If
 * hardware/firmware does not implement buffering of broadcast/multicast
 * frames when power saving is used, 802.11 code buffers them in the host
 * memory. The low-level driver uses this function to fetch next buffered
 * frame. In most cases, this is used when generating beacon frame.
 *
 * Return: A pointer to the next buffered skb or NULL if no more buffered
 * frames are available.
 *
 * Note: buffered frames are returned only after DTIM beacon frame was
 * generated with ieee80211_beacon_get() and the low-level driver must thus
 * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns
 * NULL if the previous generated beacon was not DTIM, so the low-level driver
 * does not need to check for DTIM beacons separately and should be able to
 * use common code for all beacons.
 */
struct sk_buff *
ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);

/**
 * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32
 *
 * This function returns the TKIP phase 1 key for the given IV32.
 *
 * @keyconf: the parameter passed with the set key
 * @iv32: IV32 to get the P1K for
 * @p1k: a buffer to which the key will be written, as 5 u16 values
 */
void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
			       u32 iv32, u16 *p1k);

/**
 * ieee80211_get_tkip_p1k - get a TKIP phase 1 key
 *
 * This function returns the TKIP phase 1 key for the IV32 taken
 * from the given packet.
 *
 * @keyconf: the parameter passed with the set key
 * @skb: the packet to take the IV32 value from that will be encrypted
 *	with this P1K
 * @p1k: a buffer to which the key will be written, as 5 u16 values
 */
static inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,
					  struct sk_buff *skb, u16 *p1k)
{
	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
	u32 iv32 = get_unaligned_le32(&data[4]);

	ieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);
}

/**
 * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX
 *
 * This function returns the TKIP phase 1 key for the given IV32
 * and transmitter address.
 *
 * @keyconf: the parameter passed with the set key
 * @ta: TA that will be used with the key
 * @iv32: IV32 to get the P1K for
 * @p1k: a buffer to which the key will be written, as 5 u16 values
 */
void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
			       const u8 *ta, u32 iv32, u16 *p1k);

/**
 * ieee80211_get_tkip_p2k - get a TKIP phase 2 key
 *
 * This function computes the TKIP RC4 key for the IV values
 * in the packet.
 *
 * @keyconf: the parameter passed with the set key
 * @skb: the packet to take the IV32/IV16 values from that will be
 *	encrypted with this key
 * @p2k: a buffer to which the key will be written, 16 bytes
 */
void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
			    struct sk_buff *skb, u8 *p2k);

/**
 * ieee80211_tkip_add_iv - write TKIP IV and Ext. IV to pos
 *
 * @pos: start of crypto header
 * @keyconf: the parameter passed with the set key
 * @pn: PN to add
 *
 * Returns: pointer to the octet following IVs (i.e. beginning of
 * the packet payload)
 *
 * This function writes the tkip IV value to pos (which should
 * point to the crypto header)
 */
u8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn);

/**
 * ieee80211_get_key_rx_seq - get key RX sequence counter
 *
 * @keyconf: the parameter passed with the set key
 * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);
 *	the value on TID 0 is also used for non-QoS frames. For
 *	CMAC, only TID 0 is valid.
 * @seq: buffer to receive the sequence data
 *
 * This function allows a driver to retrieve the current RX IV/PNs
 * for the given key. It must not be called if IV checking is done
 * by the device and not by mac80211.
 *
 * Note that this function may only be called when no RX processing
 * can be done concurrently.
 */
void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
			      int tid, struct ieee80211_key_seq *seq);

/**
 * ieee80211_set_key_rx_seq - set key RX sequence counter
 *
 * @keyconf: the parameter passed with the set key
 * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);
 *	the value on TID 0 is also used for non-QoS frames. For
 *	CMAC, only TID 0 is valid.
 * @seq: new sequence data
 *
 * This function allows a driver to set the current RX IV/PNs for the
 * given key. This is useful when resuming from WoWLAN sleep and GTK
 * rekey may have been done while suspended. It should not be called
 * if IV checking is done by the device and not by mac80211.
 *
 * Note that this function may only be called when no RX processing
 * can be done concurrently.
 */
void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
			      int tid, struct ieee80211_key_seq *seq);

/**
 * ieee80211_remove_key - remove the given key
 * @keyconf: the parameter passed with the set key
 *
 * Remove the given key. If the key was uploaded to the hardware at the
 * time this function is called, it is not deleted in the hardware but
 * instead assumed to have been removed already.
 *
 * Note that due to locking considerations this function can (currently)
 * only be called during key iteration (ieee80211_iter_keys().)
 */
void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);

/**
 * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN
 * @vif: the virtual interface to add the key on
 * @keyconf: new key data
 *
 * When GTK rekeying was done while the system was suspended, (a) new
 * key(s) will be available. These will be needed by mac80211 for proper
 * RX processing, so this function allows setting them.
 *
 * The function returns the newly allocated key structure, which will
 * have similar contents to the passed key configuration but point to
 * mac80211-owned memory. In case of errors, the function returns an
 * ERR_PTR(), use IS_ERR() etc.
 *
 * Note that this function assumes the key isn't added to hardware
 * acceleration, so no TX will be done with the key. Since it's a GTK
 * on managed (station) networks, this is true anyway. If the driver
 * calls this function from the resume callback and subsequently uses
 * the return code 1 to reconfigure the device, this key will be part
 * of the reconfiguration.
 *
 * Note that the driver should also call ieee80211_set_key_rx_seq()
 * for the new key for each TID to set up sequence counters properly.
 *
 * IMPORTANT: If this replaces a key that is present in the hardware,
 * then it will attempt to remove it during this call. In many cases
 * this isn't what you want, so call ieee80211_remove_key() first for
 * the key that's being replaced.
 */
struct ieee80211_key_conf *
ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
			struct ieee80211_key_conf *keyconf);

/**
 * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
 * @vif: virtual interface the rekeying was done on
 * @bssid: The BSSID of the AP, for checking association
 * @replay_ctr: the new replay counter after GTK rekeying
 * @gfp: allocation flags
 */
void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
				const u8 *replay_ctr, gfp_t gfp);

/**
 * ieee80211_wake_queue - wake specific queue
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @queue: queue number (counted from zero).
 *
 * Drivers should use this function instead of netif_wake_queue.
 */
void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);

/**
 * ieee80211_stop_queue - stop specific queue
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @queue: queue number (counted from zero).
 *
 * Drivers should use this function instead of netif_stop_queue.
 */
void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);

/**
 * ieee80211_queue_stopped - test status of the queue
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @queue: queue number (counted from zero).
 *
 * Drivers should use this function instead of netif_stop_queue.
 *
 * Return: %true if the queue is stopped. %false otherwise.
 */

int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);

/**
 * ieee80211_stop_queues - stop all queues
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 *
 * Drivers should use this function instead of netif_stop_queue.
 */
void ieee80211_stop_queues(struct ieee80211_hw *hw);

/**
 * ieee80211_wake_queues - wake all queues
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 *
 * Drivers should use this function instead of netif_wake_queue.
 */
void ieee80211_wake_queues(struct ieee80211_hw *hw);

/**
 * ieee80211_scan_completed - completed hardware scan
 *
 * When hardware scan offload is used (i.e. the hw_scan() callback is
 * assigned) this function needs to be called by the driver to notify
 * mac80211 that the scan finished. This function can be called from
 * any context, including hardirq context.
 *
 * @hw: the hardware that finished the scan
 * @info: information about the completed scan
 */
void ieee80211_scan_completed(struct ieee80211_hw *hw,
			      struct cfg80211_scan_info *info);

/**
 * ieee80211_sched_scan_results - got results from scheduled scan
 *
 * When a scheduled scan is running, this function needs to be called by the
 * driver whenever there are new scan results available.
 *
 * @hw: the hardware that is performing scheduled scans
 */
void ieee80211_sched_scan_results(struct ieee80211_hw *hw);

/**
 * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped
 *
 * When a scheduled scan is running, this function can be called by
 * the driver if it needs to stop the scan to perform another task.
 * Usual scenarios are drivers that cannot continue the scheduled scan
 * while associating, for instance.
 *
 * @hw: the hardware that is performing scheduled scans
 */
void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);

/**
 * enum ieee80211_interface_iteration_flags - interface iteration flags
 * @IEEE80211_IFACE_ITER_NORMAL: Iterate over all interfaces that have
 *	been added to the driver; However, note that during hardware
 *	reconfiguration (after restart_hw) it will iterate over a new
 *	interface and over all the existing interfaces even if they
 *	haven't been re-added to the driver yet.
 * @IEEE80211_IFACE_ITER_RESUME_ALL: During resume, iterate over all
 *	interfaces, even if they haven't been re-added to the driver yet.
 * @IEEE80211_IFACE_ITER_ACTIVE: Iterate only active interfaces (netdev is up).
 */
enum ieee80211_interface_iteration_flags {
	IEEE80211_IFACE_ITER_NORMAL	= 0,
	IEEE80211_IFACE_ITER_RESUME_ALL	= BIT(0),
	IEEE80211_IFACE_ITER_ACTIVE	= BIT(1),
};

/**
 * ieee80211_iterate_interfaces - iterate interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware and calls the callback for them. This includes active as well as
 * inactive interfaces. This function allows the iterator function to sleep.
 * Will iterate over a new interface during add_interface().
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags,
				  void (*iterator)(void *data, u8 *mac,
						   struct ieee80211_vif *vif),
				  void *data);

/**
 * ieee80211_iterate_active_interfaces - iterate active interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware that are currently active and calls the callback for them.
 * This function allows the iterator function to sleep, when the iterator
 * function is atomic @ieee80211_iterate_active_interfaces_atomic can
 * be used.
 * Does not iterate over a new interface during add_interface().
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call
 * @data: first argument of the iterator function
 */
static inline void
ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags,
				    void (*iterator)(void *data, u8 *mac,
						     struct ieee80211_vif *vif),
				    void *data)
{
	ieee80211_iterate_interfaces(hw,
				     iter_flags | IEEE80211_IFACE_ITER_ACTIVE,
				     iterator, data);
}

/**
 * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware that are currently active and calls the callback for them.
 * This function requires the iterator callback function to be atomic,
 * if that is not desired, use @ieee80211_iterate_active_interfaces instead.
 * Does not iterate over a new interface during add_interface().
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call, cannot sleep
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
						u32 iter_flags,
						void (*iterator)(void *data,
						    u8 *mac,
						    struct ieee80211_vif *vif),
						void *data);

/**
 * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware that are currently active and calls the callback for them.
 * This version can only be used while holding the RTNL.
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call, cannot sleep
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
					      u32 iter_flags,
					      void (*iterator)(void *data,
						u8 *mac,
						struct ieee80211_vif *vif),
					      void *data);

/**
 * ieee80211_iterate_stations_atomic - iterate stations
 *
 * This function iterates over all stations associated with a given
 * hardware that are currently uploaded to the driver and calls the callback
 * function for them.
 * This function requires the iterator callback function to be atomic,
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iterator: the iterator function to call, cannot sleep
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
				       void (*iterator)(void *data,
						struct ieee80211_sta *sta),
				       void *data);
/**
 * ieee80211_queue_work - add work onto the mac80211 workqueue
 *
 * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
 * This helper ensures drivers are not queueing work when they should not be.
 *
 * @hw: the hardware struct for the interface we are adding work for
 * @work: the work we want to add onto the mac80211 workqueue
 */
void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);

/**
 * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue
 *
 * Drivers and mac80211 use this to queue delayed work onto the mac80211
 * workqueue.
 *
 * @hw: the hardware struct for the interface we are adding work for
 * @dwork: delayable work to queue onto the mac80211 workqueue
 * @delay: number of jiffies to wait before queueing
 */
void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
				  struct delayed_work *dwork,
				  unsigned long delay);

/**
 * ieee80211_start_tx_ba_session - Start a tx Block Ack session.
 * @sta: the station for which to start a BA session
 * @tid: the TID to BA on.
 * @timeout: session timeout value (in TUs)
 *
 * Return: success if addBA request was sent, failure otherwise
 *
 * Although mac80211/low level driver/user space application can estimate
 * the need to start aggregation on a certain RA/TID, the session level
 * will be managed by the mac80211.
 */
int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
				  u16 timeout);

/**
 * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @ra: receiver address of the BA session recipient.
 * @tid: the TID to BA on.
 *
 * This function must be called by low level driver once it has
 * finished with preparations for the BA session. It can be called
 * from any context.
 */
void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
				      u16 tid);

/**
 * ieee80211_stop_tx_ba_session - Stop a Block Ack session.
 * @sta: the station whose BA session to stop
 * @tid: the TID to stop BA.
 *
 * Return: negative error if the TID is invalid, or no aggregation active
 *
 * Although mac80211/low level driver/user space application can estimate
 * the need to stop aggregation on a certain RA/TID, the session level
 * will be managed by the mac80211.
 */
int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);

/**
 * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @ra: receiver address of the BA session recipient.
 * @tid: the desired TID to BA on.
 *
 * This function must be called by low level driver once it has
 * finished with preparations for the BA session tear down. It
 * can be called from any context.
 */
void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
				     u16 tid);

/**
 * ieee80211_find_sta - find a station
 *
 * @vif: virtual interface to look for station on
 * @addr: station's address
 *
 * Return: The station, if found. %NULL otherwise.
 *
 * Note: This function must be called under RCU lock and the
 * resulting pointer is only valid under RCU lock as well.
 */
struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
					 const u8 *addr);

/**
 * ieee80211_find_sta_by_ifaddr - find a station on hardware
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @addr: remote station's address
 * @localaddr: local address (vif->sdata->vif.addr). Use NULL for 'any'.
 *
 * Return: The station, if found. %NULL otherwise.
 *
 * Note: This function must be called under RCU lock and the
 * resulting pointer is only valid under RCU lock as well.
 *
 * NOTE: You may pass NULL for localaddr, but then you will just get
 *      the first STA that matches the remote address 'addr'.
 *      We can have multiple STA associated with multiple
 *      logical stations (e.g. consider a station connecting to another
 *      BSSID on the same AP hardware without disconnecting first).
 *      In this case, the result of this method with localaddr NULL
 *      is not reliable.
 *
 * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
 */
struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
					       const u8 *addr,
					       const u8 *localaddr);

/**
 * ieee80211_sta_block_awake - block station from waking up
 * @hw: the hardware
 * @pubsta: the station
 * @block: whether to block or unblock
 *
 * Some devices require that all frames that are on the queues
 * for a specific station that went to sleep are flushed before
 * a poll response or frames after the station woke up can be
 * delivered to that it. Note that such frames must be rejected
 * by the driver as filtered, with the appropriate status flag.
 *
 * This function allows implementing this mode in a race-free
 * manner.
 *
 * To do this, a driver must keep track of the number of frames
 * still enqueued for a specific station. If this number is not
 * zero when the station goes to sleep, the driver must call
 * this function to force mac80211 to consider the station to
 * be asleep regardless of the station's actual state. Once the
 * number of outstanding frames reaches zero, the driver must
 * call this function again to unblock the station. That will
 * cause mac80211 to be able to send ps-poll responses, and if
 * the station queried in the meantime then frames will also
 * be sent out as a result of this. Additionally, the driver
 * will be notified that the station woke up some time after
 * it is unblocked, regardless of whether the station actually
 * woke up while blocked or not.
 */
void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block);

/**
 * ieee80211_sta_eosp - notify mac80211 about end of SP
 * @pubsta: the station
 *
 * When a device transmits frames in a way that it can't tell
 * mac80211 in the TX status about the EOSP, it must clear the
 * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.
 * This applies for PS-Poll as well as uAPSD.
 *
 * Note that just like with _tx_status() and _rx() drivers must
 * not mix calls to irqsafe/non-irqsafe versions, this function
 * must not be mixed with those either. Use the all irqsafe, or
 * all non-irqsafe, don't mix!
 *
 * NB: the _irqsafe version of this function doesn't exist, no
 *     driver needs it right now. Don't call this function if
 *     you'd need the _irqsafe version, look at the git history
 *     and restore the _irqsafe version!
 */
void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);

/**
 * ieee80211_send_eosp_nullfunc - ask mac80211 to send NDP with EOSP
 * @pubsta: the station
 * @tid: the tid of the NDP
 *
 * Sometimes the device understands that it needs to close
 * the Service Period unexpectedly. This can happen when
 * sending frames that are filling holes in the BA window.
 * In this case, the device can ask mac80211 to send a
 * Nullfunc frame with EOSP set. When that happens, the
 * driver must have called ieee80211_sta_set_buffered() to
 * let mac80211 know that there are no buffered frames any
 * more, otherwise mac80211 will get the more_data bit wrong.
 * The low level driver must have made sure that the frame
 * will be sent despite the station being in power-save.
 * Mac80211 won't call allow_buffered_frames().
 * Note that calling this function, doesn't exempt the driver
 * from closing the EOSP properly, it will still have to call
 * ieee80211_sta_eosp when the NDP is sent.
 */
void ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);

/**
 * ieee80211_iter_keys - iterate keys programmed into the device
 * @hw: pointer obtained from ieee80211_alloc_hw()
 * @vif: virtual interface to iterate, may be %NULL for all
 * @iter: iterator function that will be called for each key
 * @iter_data: custom data to pass to the iterator function
 *
 * This function can be used to iterate all the keys known to
 * mac80211, even those that weren't previously programmed into
 * the device. This is intended for use in WoWLAN if the device
 * needs reprogramming of the keys during suspend. Note that due
 * to locking reasons, it is also only safe to call this at few
 * spots since it must hold the RTNL and be able to sleep.
 *
 * The order in which the keys are iterated matches the order
 * in which they were originally installed and handed to the
 * set_key callback.
 */
void ieee80211_iter_keys(struct ieee80211_hw *hw,
			 struct ieee80211_vif *vif,
			 void (*iter)(struct ieee80211_hw *hw,
				      struct ieee80211_vif *vif,
				      struct ieee80211_sta *sta,
				      struct ieee80211_key_conf *key,
				      void *data),
			 void *iter_data);

/**
 * ieee80211_iter_keys_rcu - iterate keys programmed into the device
 * @hw: pointer obtained from ieee80211_alloc_hw()
 * @vif: virtual interface to iterate, may be %NULL for all
 * @iter: iterator function that will be called for each key
 * @iter_data: custom data to pass to the iterator function
 *
 * This function can be used to iterate all the keys known to
 * mac80211, even those that weren't previously programmed into
 * the device. Note that due to locking reasons, keys of station
 * in removal process will be skipped.
 *
 * This function requires being called in an RCU critical section,
 * and thus iter must be atomic.
 */
void ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif,
			     void (*iter)(struct ieee80211_hw *hw,
					  struct ieee80211_vif *vif,
					  struct ieee80211_sta *sta,
					  struct ieee80211_key_conf *key,
					  void *data),
			     void *iter_data);

/**
 * ieee80211_iter_chan_contexts_atomic - iterate channel contexts
 * @hw: pointre obtained from ieee80211_alloc_hw().
 * @iter: iterator function
 * @iter_data: data passed to iterator function
 *
 * Iterate all active channel contexts. This function is atomic and
 * doesn't acquire any locks internally that might be held in other
 * places while calling into the driver.
 *
 * The iterator will not find a context that's being added (during
 * the driver callback to add it) but will find it while it's being
 * removed.
 *
 * Note that during hardware restart, all contexts that existed
 * before the restart are considered already present so will be
 * found while iterating, whether they've been re-added already
 * or not.
 */
void ieee80211_iter_chan_contexts_atomic(
	struct ieee80211_hw *hw,
	void (*iter)(struct ieee80211_hw *hw,
		     struct ieee80211_chanctx_conf *chanctx_conf,
		     void *data),
	void *iter_data);

/**
 * ieee80211_ap_probereq_get - retrieve a Probe Request template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a Probe Request template which can, for example, be uploaded to
 * hardware. The template is filled with bssid, ssid and supported rate
 * information. This function must only be called from within the
 * .bss_info_changed callback function and only in managed mode. The function
 * is only useful when the interface is associated, otherwise it will return
 * %NULL.
 *
 * Return: The Probe Request template. %NULL on error.
 */
struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
					  struct ieee80211_vif *vif);

/**
 * ieee80211_beacon_loss - inform hardware does not receive beacons
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER and
 * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the
 * hardware is not receiving beacons with this function.
 */
void ieee80211_beacon_loss(struct ieee80211_vif *vif);

/**
 * ieee80211_connection_loss - inform hardware has lost connection to the AP
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER, and
 * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver
 * needs to inform if the connection to the AP has been lost.
 * The function may also be called if the connection needs to be terminated
 * for some other reason, even if %IEEE80211_HW_CONNECTION_MONITOR isn't set.
 *
 * This function will cause immediate change to disassociated state,
 * without connection recovery attempts.
 */
void ieee80211_connection_loss(struct ieee80211_vif *vif);

/**
 * ieee80211_resume_disconnect - disconnect from AP after resume
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Instructs mac80211 to disconnect from the AP after resume.
 * Drivers can use this after WoWLAN if they know that the
 * connection cannot be kept up, for example because keys were
 * used while the device was asleep but the replay counters or
 * similar cannot be retrieved from the device during resume.
 *
 * Note that due to implementation issues, if the driver uses
 * the reconfiguration functionality during resume the interface
 * will still be added as associated first during resume and then
 * disconnect normally later.
 *
 * This function can only be called from the resume callback and
 * the driver must not be holding any of its own locks while it
 * calls this function, or at least not any locks it needs in the
 * key configuration paths (if it supports HW crypto).
 */
void ieee80211_resume_disconnect(struct ieee80211_vif *vif);

/**
 * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring
 *	rssi threshold triggered
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @rssi_event: the RSSI trigger event type
 * @gfp: context flags
 *
 * When the %IEEE80211_VIF_SUPPORTS_CQM_RSSI is set, and a connection quality
 * monitoring is configured with an rssi threshold, the driver will inform
 * whenever the rssi level reaches the threshold.
 */
void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
			       enum nl80211_cqm_rssi_threshold_event rssi_event,
			       gfp_t gfp);

/**
 * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @gfp: context flags
 */
void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);

/**
 * ieee80211_radar_detected - inform that a radar was detected
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 */
void ieee80211_radar_detected(struct ieee80211_hw *hw);

/**
 * ieee80211_chswitch_done - Complete channel switch process
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @success: make the channel switch successful or not
 *
 * Complete the channel switch post-process: set the new operational channel
 * and wake up the suspended queues.
 */
void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);

/**
 * ieee80211_request_smps - request SM PS transition
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @smps_mode: new SM PS mode
 *
 * This allows the driver to request an SM PS transition in managed
 * mode. This is useful when the driver has more information than
 * the stack about possible interference, for example by bluetooth.
 */
void ieee80211_request_smps(struct ieee80211_vif *vif,
			    enum ieee80211_smps_mode smps_mode);

/**
 * ieee80211_ready_on_channel - notification of remain-on-channel start
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 */
void ieee80211_ready_on_channel(struct ieee80211_hw *hw);

/**
 * ieee80211_remain_on_channel_expired - remain_on_channel duration expired
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 */
void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);

/**
 * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions
 *
 * in order not to harm the system performance and user experience, the device
 * may request not to allow any rx ba session and tear down existing rx ba
 * sessions based on system constraints such as periodic BT activity that needs
 * to limit wlan activity (eg.sco or a2dp)."
 * in such cases, the intention is to limit the duration of the rx ppdu and
 * therefore prevent the peer device to use a-mpdu aggregation.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @ba_rx_bitmap: Bit map of open rx ba per tid
 * @addr: & to bssid mac address
 */
void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
				  const u8 *addr);

/**
 * ieee80211_mark_rx_ba_filtered_frames - move RX BA window and mark filtered
 * @pubsta: station struct
 * @tid: the session's TID
 * @ssn: starting sequence number of the bitmap, all frames before this are
 *	assumed to be out of the window after the call
 * @filtered: bitmap of filtered frames, BIT(0) is the @ssn entry etc.
 * @received_mpdus: number of received mpdus in firmware
 *
 * This function moves the BA window and releases all frames before @ssn, and
 * marks frames marked in the bitmap as having been filtered. Afterwards, it
 * checks if any frames in the window starting from @ssn can now be released
 * (in case they were only waiting for frames that were filtered.)
 */
void ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,
					  u16 ssn, u64 filtered,
					  u16 received_mpdus);

/**
 * ieee80211_send_bar - send a BlockAckReq frame
 *
 * can be used to flush pending frames from the peer's aggregation reorder
 * buffer.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @ra: the peer's destination address
 * @tid: the TID of the aggregation session
 * @ssn: the new starting sequence number for the receiver
 */
void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);

/**
 * ieee80211_start_rx_ba_session_offl - start a Rx BA session
 *
 * Some device drivers may offload part of the Rx aggregation flow including
 * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
 * reordering.
 *
 * Create structures responsible for reordering so device drivers may call here
 * when they complete AddBa negotiation.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @addr: station mac address
 * @tid: the rx tid
 */
void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
					const u8 *addr, u16 tid);

/**
 * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session
 *
 * Some device drivers may offload part of the Rx aggregation flow including
 * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
 * reordering.
 *
 * Destroy structures responsible for reordering so device drivers may call here
 * when they complete DelBa negotiation.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @addr: station mac address
 * @tid: the rx tid
 */
void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,
				       const u8 *addr, u16 tid);

/* Rate control API */

/**
 * struct ieee80211_tx_rate_control - rate control information for/from RC algo
 *
 * @hw: The hardware the algorithm is invoked for.
 * @sband: The band this frame is being transmitted on.
 * @bss_conf: the current BSS configuration
 * @skb: the skb that will be transmitted, the control information in it needs
 *	to be filled in
 * @reported_rate: The rate control algorithm can fill this in to indicate
 *	which rate should be reported to userspace as the current rate and
 *	used for rate calculations in the mesh network.
 * @rts: whether RTS will be used for this frame because it is longer than the
 *	RTS threshold
 * @short_preamble: whether mac80211 will request short-preamble transmission
 *	if the selected rate supports it
 * @max_rate_idx: user-requested maximum (legacy) rate
 *	(deprecated; this will be removed once drivers get updated to use
 *	rate_idx_mask)
 * @rate_idx_mask: user-requested (legacy) rate mask
 * @rate_idx_mcs_mask: user-requested MCS rate mask (NULL if not in use)
 * @bss: whether this frame is sent out in AP or IBSS mode
 */
struct ieee80211_tx_rate_control {
	struct ieee80211_hw *hw;
	struct ieee80211_supported_band *sband;
	struct ieee80211_bss_conf *bss_conf;
	struct sk_buff *skb;
	struct ieee80211_tx_rate reported_rate;
	bool rts, short_preamble;
	u8 max_rate_idx;
	u32 rate_idx_mask;
	u8 *rate_idx_mcs_mask;
	bool bss;
};

struct rate_control_ops {
	const char *name;
	void *(*alloc)(struct ieee80211_hw *hw, struct dentry *debugfsdir);
	void (*free)(void *priv);

	void *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);
	void (*rate_init)(void *priv, struct ieee80211_supported_band *sband,
			  struct cfg80211_chan_def *chandef,
			  struct ieee80211_sta *sta, void *priv_sta);
	void (*rate_update)(void *priv, struct ieee80211_supported_band *sband,
			    struct cfg80211_chan_def *chandef,
			    struct ieee80211_sta *sta, void *priv_sta,
			    u32 changed);
	void (*free_sta)(void *priv, struct ieee80211_sta *sta,
			 void *priv_sta);

	void (*tx_status_noskb)(void *priv,
				struct ieee80211_supported_band *sband,
				struct ieee80211_sta *sta, void *priv_sta,
				struct ieee80211_tx_info *info);
	void (*tx_status)(void *priv, struct ieee80211_supported_band *sband,
			  struct ieee80211_sta *sta, void *priv_sta,
			  struct sk_buff *skb);
	void (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,
			 struct ieee80211_tx_rate_control *txrc);

	void (*add_sta_debugfs)(void *priv, void *priv_sta,
				struct dentry *dir);
	void (*remove_sta_debugfs)(void *priv, void *priv_sta);

	u32 (*get_expected_throughput)(void *priv_sta);
};

static inline int rate_supported(struct ieee80211_sta *sta,
				 enum nl80211_band band,
				 int index)
{
	return (sta == NULL || sta->supp_rates[band] & BIT(index));
}

/**
 * rate_control_send_low - helper for drivers for management/no-ack frames
 *
 * Rate control algorithms that agree to use the lowest rate to
 * send management frames and NO_ACK data with the respective hw
 * retries should use this in the beginning of their mac80211 get_rate
 * callback. If true is returned the rate control can simply return.
 * If false is returned we guarantee that sta and sta and priv_sta is
 * not null.
 *
 * Rate control algorithms wishing to do more intelligent selection of
 * rate for multicast/broadcast frames may choose to not use this.
 *
 * @sta: &struct ieee80211_sta pointer to the target destination. Note
 * 	that this may be null.
 * @priv_sta: private rate control structure. This may be null.
 * @txrc: rate control information we sholud populate for mac80211.
 */
bool rate_control_send_low(struct ieee80211_sta *sta,
			   void *priv_sta,
			   struct ieee80211_tx_rate_control *txrc);


static inline s8
rate_lowest_index(struct ieee80211_supported_band *sband,
		  struct ieee80211_sta *sta)
{
	int i;

	for (i = 0; i < sband->n_bitrates; i++)
		if (rate_supported(sta, sband->band, i))
			return i;

	/* warn when we cannot find a rate. */
	WARN_ON_ONCE(1);

	/* and return 0 (the lowest index) */
	return 0;
}

static inline
bool rate_usable_index_exists(struct ieee80211_supported_band *sband,
			      struct ieee80211_sta *sta)
{
	unsigned int i;

	for (i = 0; i < sband->n_bitrates; i++)
		if (rate_supported(sta, sband->band, i))
			return true;
	return false;
}

/**
 * rate_control_set_rates - pass the sta rate selection to mac80211/driver
 *
 * When not doing a rate control probe to test rates, rate control should pass
 * its rate selection to mac80211. If the driver supports receiving a station
 * rate table, it will use it to ensure that frames are always sent based on
 * the most recent rate control module decision.
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @pubsta: &struct ieee80211_sta pointer to the target destination.
 * @rates: new tx rate set to be used for this station.
 */
int rate_control_set_rates(struct ieee80211_hw *hw,
			   struct ieee80211_sta *pubsta,
			   struct ieee80211_sta_rates *rates);

int ieee80211_rate_control_register(const struct rate_control_ops *ops);
void ieee80211_rate_control_unregister(const struct rate_control_ops *ops);

static inline bool
conf_is_ht20(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_20;
}

static inline bool
conf_is_ht40_minus(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_40 &&
	       conf->chandef.center_freq1 < conf->chandef.chan->center_freq;
}

static inline bool
conf_is_ht40_plus(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_40 &&
	       conf->chandef.center_freq1 > conf->chandef.chan->center_freq;
}

static inline bool
conf_is_ht40(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_40;
}

static inline bool
conf_is_ht(struct ieee80211_conf *conf)
{
	return (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&
		(conf->chandef.width != NL80211_CHAN_WIDTH_10) &&
		(conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);
}

static inline enum nl80211_iftype
ieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)
{
	if (p2p) {
		switch (type) {
		case NL80211_IFTYPE_STATION:
			return NL80211_IFTYPE_P2P_CLIENT;
		case NL80211_IFTYPE_AP:
			return NL80211_IFTYPE_P2P_GO;
		default:
			break;
		}
	}
	return type;
}

static inline enum nl80211_iftype
ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
{
	return ieee80211_iftype_p2p(vif->type, vif->p2p);
}

/**
 * ieee80211_update_mu_groups - set the VHT MU-MIMO groud data
 *
 * @vif: the specified virtual interface
 * @membership: 64 bits array - a bit is set if station is member of the group
 * @position: 2 bits per group id indicating the position in the group
 *
 * Note: This function assumes that the given vif is valid and the position and
 * membership data is of the correct size and are in the same byte order as the
 * matching GroupId management frame.
 * Calls to this function need to be serialized with RX path.
 */
void ieee80211_update_mu_groups(struct ieee80211_vif *vif,
				const u8 *membership, const u8 *position);

void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
				   int rssi_min_thold,
				   int rssi_max_thold);

void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);

/**
 * ieee80211_ave_rssi - report the average RSSI for the specified interface
 *
 * @vif: the specified virtual interface
 *
 * Note: This function assumes that the given vif is valid.
 *
 * Return: The average RSSI value for the requested interface, or 0 if not
 * applicable.
 */
int ieee80211_ave_rssi(struct ieee80211_vif *vif);

/**
 * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup
 * @vif: virtual interface
 * @wakeup: wakeup reason(s)
 * @gfp: allocation flags
 *
 * See cfg80211_report_wowlan_wakeup().
 */
void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
				    struct cfg80211_wowlan_wakeup *wakeup,
				    gfp_t gfp);

/**
 * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @vif: virtual interface
 * @skb: frame to be sent from within the driver
 * @band: the band to transmit on
 * @sta: optional pointer to get the station to send the frame to
 *
 * Note: must be called under RCU lock
 */
bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif, struct sk_buff *skb,
			      int band, struct ieee80211_sta **sta);

/**
 * struct ieee80211_noa_data - holds temporary data for tracking P2P NoA state
 *
 * @next_tsf: TSF timestamp of the next absent state change
 * @has_next_tsf: next absent state change event pending
 *
 * @absent: descriptor bitmask, set if GO is currently absent
 *
 * private:
 *
 * @count: count fields from the NoA descriptors
 * @desc: adjusted data from the NoA
 */
struct ieee80211_noa_data {
	u32 next_tsf;
	bool has_next_tsf;

	u8 absent;

	u8 count[IEEE80211_P2P_NOA_DESC_MAX];
	struct {
		u32 start;
		u32 duration;
		u32 interval;
	} desc[IEEE80211_P2P_NOA_DESC_MAX];
};

/**
 * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE
 *
 * @attr: P2P NoA IE
 * @data: NoA tracking data
 * @tsf: current TSF timestamp
 *
 * Return: number of successfully parsed descriptors
 */
int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
			    struct ieee80211_noa_data *data, u32 tsf);

/**
 * ieee80211_update_p2p_noa - get next pending P2P GO absent state change
 *
 * @data: NoA tracking data
 * @tsf: current TSF timestamp
 */
void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);

/**
 * ieee80211_tdls_oper - request userspace to perform a TDLS operation
 * @vif: virtual interface
 * @peer: the peer's destination address
 * @oper: the requested TDLS operation
 * @reason_code: reason code for the operation, valid for TDLS teardown
 * @gfp: allocation flags
 *
 * See cfg80211_tdls_oper_request().
 */
void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
				 enum nl80211_tdls_operation oper,
				 u16 reason_code, gfp_t gfp);

/**
 * ieee80211_reserve_tid - request to reserve a specific TID
 *
 * There is sometimes a need (such as in TDLS) for blocking the driver from
 * using a specific TID so that the FW can use it for certain operations such
 * as sending PTI requests. To make sure that the driver doesn't use that TID,
 * this function must be called as it flushes out packets on this TID and marks
 * it as blocked, so that any transmit for the station on this TID will be
 * redirected to the alternative TID in the same AC.
 *
 * Note that this function blocks and may call back into the driver, so it
 * should be called without driver locks held. Also note this function should
 * only be called from the driver's @sta_state callback.
 *
 * @sta: the station to reserve the TID for
 * @tid: the TID to reserve
 *
 * Returns: 0 on success, else on failure
 */
int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);

/**
 * ieee80211_unreserve_tid - request to unreserve a specific TID
 *
 * Once there is no longer any need for reserving a certain TID, this function
 * should be called, and no longer will packets have their TID modified for
 * preventing use of this TID in the driver.
 *
 * Note that this function blocks and acquires a lock, so it should be called
 * without driver locks held. Also note this function should only be called
 * from the driver's @sta_state callback.
 *
 * @sta: the station
 * @tid: the TID to unreserve
 */
void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);

/**
 * ieee80211_tx_dequeue - dequeue a packet from a software tx queue
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @txq: pointer obtained from station or virtual interface
 *
 * Returns the skb if successful, %NULL if no frame was available.
 */
struct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,
				     struct ieee80211_txq *txq);

/**
 * ieee80211_txq_get_depth - get pending frame/byte count of given txq
 *
 * The values are not guaranteed to be coherent with regard to each other, i.e.
 * txq state can change half-way of this function and the caller may end up
 * with "new" frame_cnt and "old" byte_cnt or vice-versa.
 *
 * @txq: pointer obtained from station or virtual interface
 * @frame_cnt: pointer to store frame count
 * @byte_cnt: pointer to store byte count
 */
void ieee80211_txq_get_depth(struct ieee80211_txq *txq,
			     unsigned long *frame_cnt,
			     unsigned long *byte_cnt);

/**
 * ieee80211_nan_func_terminated - notify about NAN function termination.
 *
 * This function is used to notify mac80211 about NAN function termination.
 * Note that this function can't be called from hard irq.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @inst_id: the local instance id
 * @reason: termination reason (one of the NL80211_NAN_FUNC_TERM_REASON_*)
 * @gfp: allocation flags
 */
void ieee80211_nan_func_terminated(struct ieee80211_vif *vif,
				   u8 inst_id,
				   enum nl80211_nan_func_term_reason reason,
				   gfp_t gfp);

/**
 * ieee80211_nan_func_match - notify about NAN function match event.
 *
 * This function is used to notify mac80211 about NAN function match. The
 * cookie inside the match struct will be assigned by mac80211.
 * Note that this function can't be called from hard irq.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @match: match event information
 * @gfp: allocation flags
 */
void ieee80211_nan_func_match(struct ieee80211_vif *vif,
			      struct cfg80211_nan_match_params *match,
			      gfp_t gfp);

#endif /* MAC80211_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * This was automagically generated from arch/arm/tools/mach-types!
 * Do NOT edit
 */

#ifndef __ASM_ARM_MACH_TYPE_H
#define __ASM_ARM_MACH_TYPE_H

#ifndef __ASSEMBLY__
/* The type of machine we're running on */
extern unsigned int __machine_arch_type;
#endif

/* see arch/arm/kernel/arch.c for a description of these */
#define MACH_TYPE_EBSA110              0
#define MACH_TYPE_RISCPC               1
#define MACH_TYPE_EBSA285              4
#define MACH_TYPE_NETWINDER            5
#define MACH_TYPE_CATS                 6
#define MACH_TYPE_SHARK                15
#define MACH_TYPE_BRUTUS               16
#define MACH_TYPE_PERSONAL_SERVER      17
#define MACH_TYPE_L7200                19
#define MACH_TYPE_PLEB                 20
#define MACH_TYPE_INTEGRATOR           21
#define MACH_TYPE_H3600                22
#define MACH_TYPE_P720T                24
#define MACH_TYPE_ASSABET              25
#define MACH_TYPE_LART                 27
#define MACH_TYPE_GRAPHICSCLIENT       29
#define MACH_TYPE_XP860                30
#define MACH_TYPE_CERF                 31
#define MACH_TYPE_NANOENGINE           32
#define MACH_TYPE_JORNADA720           48
#define MACH_TYPE_EDB7211              50
#define MACH_TYPE_PFS168               52
#define MACH_TYPE_FLEXANET             54
#define MACH_TYPE_SIMPAD               87
#define MACH_TYPE_LUBBOCK              89
#define MACH_TYPE_CLEP7212             91
#define MACH_TYPE_SHANNON              97
#define MACH_TYPE_CONSUS               105
#define MACH_TYPE_AAED2000             106
#define MACH_TYPE_CDB89712             107
#define MACH_TYPE_GRAPHICSMASTER       108
#define MACH_TYPE_ADSBITSY             109
#define MACH_TYPE_PXA_IDP              110
#define MACH_TYPE_PT_SYSTEM3           112
#define MACH_TYPE_AUTCPU12             118
#define MACH_TYPE_H3100                136
#define MACH_TYPE_COLLIE               146
#define MACH_TYPE_BADGE4               148
#define MACH_TYPE_FORTUNET             152
#define MACH_TYPE_MX1ADS               160
#define MACH_TYPE_H7201                161
#define MACH_TYPE_H7202                162
#define MACH_TYPE_IQ80321              169
#define MACH_TYPE_KS8695               180
#define MACH_TYPE_SMDK2410             193
#define MACH_TYPE_CEIVA                200
#define MACH_TYPE_VOICEBLUE            218
#define MACH_TYPE_H5400                220
#define MACH_TYPE_OMAP_INNOVATOR       234
#define MACH_TYPE_IXDP2400             242
#define MACH_TYPE_IXDP2800             243
#define MACH_TYPE_IXDP425              245
#define MACH_TYPE_HACKKIT              254
#define MACH_TYPE_IXCDP1100            260
#define MACH_TYPE_AT91RM9200DK         262
#define MACH_TYPE_CINTEGRATOR          275
#define MACH_TYPE_VIPER                283
#define MACH_TYPE_ADI_COYOTE           290
#define MACH_TYPE_IXDP2401             299
#define MACH_TYPE_IXDP2801             300
#define MACH_TYPE_IQ31244              327
#define MACH_TYPE_BAST                 331
#define MACH_TYPE_H1940                347
#define MACH_TYPE_ENP2611              356
#define MACH_TYPE_S3C2440              362
#define MACH_TYPE_GUMSTIX              373
#define MACH_TYPE_OMAP_H2              382
#define MACH_TYPE_E740                 384
#define MACH_TYPE_IQ80331              385
#define MACH_TYPE_VERSATILE_PB         387
#define MACH_TYPE_KEV7A400             388
#define MACH_TYPE_LPD7A400             389
#define MACH_TYPE_LPD7A404             390
#define MACH_TYPE_CSB337               399
#define MACH_TYPE_MAINSTONE            406
#define MACH_TYPE_LITE300              408
#define MACH_TYPE_XCEP                 413
#define MACH_TYPE_ARCOM_VULCAN         414
#define MACH_TYPE_NOMADIK              420
#define MACH_TYPE_CORGI                423
#define MACH_TYPE_POODLE               424
#define MACH_TYPE_ARMCORE              438
#define MACH_TYPE_MX31ADS              447
#define MACH_TYPE_HIMALAYA             448
#define MACH_TYPE_EDB9312              451
#define MACH_TYPE_OMAP_GENERIC         452
#define MACH_TYPE_EDB9301              462
#define MACH_TYPE_EDB9315              463
#define MACH_TYPE_VR1000               475
#define MACH_TYPE_OMAP_PERSEUS2        491
#define MACH_TYPE_E800                 496
#define MACH_TYPE_E750                 497
#define MACH_TYPE_SCB9328              508
#define MACH_TYPE_OMAP_H3              509
#define MACH_TYPE_OMAP_H4              510
#define MACH_TYPE_OMAP_OSK             515
#define MACH_TYPE_TOSA                 520
#define MACH_TYPE_AVILA                526
#define MACH_TYPE_EDB9302              538
#define MACH_TYPE_HUSKY                543
#define MACH_TYPE_SHEPHERD             545
#define MACH_TYPE_H4700                562
#define MACH_TYPE_RX3715               592
#define MACH_TYPE_NSLU2                597
#define MACH_TYPE_E400                 598
#define MACH_TYPE_IXDPG425             604
#define MACH_TYPE_VERSATILE_AB         606
#define MACH_TYPE_EDB9307              607
#define MACH_TYPE_KB9200               612
#define MACH_TYPE_SX1                  613
#define MACH_TYPE_IXDP465              618
#define MACH_TYPE_IXDP2351             619
#define MACH_TYPE_CM4008               624
#define MACH_TYPE_IQ80332              629
#define MACH_TYPE_GTWX5715             641
#define MACH_TYPE_CSB637               648
#define MACH_TYPE_N30                  656
#define MACH_TYPE_NEC_MP900            659
#define MACH_TYPE_KAFA                 662
#define MACH_TYPE_CM41XX               672
#define MACH_TYPE_TS72XX               673
#define MACH_TYPE_OTOM                 680
#define MACH_TYPE_NEXCODER_2440        681
#define MACH_TYPE_ECO920               702
#define MACH_TYPE_ROADRUNNER           704
#define MACH_TYPE_AT91RM9200EK         705
#define MACH_TYPE_SPITZ                713
#define MACH_TYPE_ADSSPHERE            723
#define MACH_TYPE_COLIBRI              729
#define MACH_TYPE_GATEWAY7001          731
#define MACH_TYPE_PCM027               732
#define MACH_TYPE_ANUBIS               734
#define MACH_TYPE_XBOARDGP8            742
#define MACH_TYPE_AKITA                744
#define MACH_TYPE_E330                 753
#define MACH_TYPE_NOKIA770             755
#define MACH_TYPE_CARMEVA              769
#define MACH_TYPE_EDB9315A             772
#define MACH_TYPE_STARGATE2            774
#define MACH_TYPE_INTELMOTE2           775
#define MACH_TYPE_TRIZEPS4             776
#define MACH_TYPE_PNX4008              782
#define MACH_TYPE_CPUAT91              787
#define MACH_TYPE_IQ81340SC            799
#define MACH_TYPE_IQ81340MC            801
#define MACH_TYPE_SE4200               809
#define MACH_TYPE_MICRO9               811
#define MACH_TYPE_MICRO9L              812
#define MACH_TYPE_OMAP_PALMTE          817
#define MACH_TYPE_REALVIEW_EB          827
#define MACH_TYPE_BORZOI               831
#define MACH_TYPE_PALMLD               835
#define MACH_TYPE_IXDP28X5             838
#define MACH_TYPE_OMAP_PALMTT          839
#define MACH_TYPE_ARCOM_ZEUS           841
#define MACH_TYPE_OSIRIS               842
#define MACH_TYPE_PALMTE2              844
#define MACH_TYPE_MX27ADS              846
#define MACH_TYPE_AT91SAM9261EK        848
#define MACH_TYPE_LOFT                 849
#define MACH_TYPE_MX21ADS              851
#define MACH_TYPE_AMS_DELTA            862
#define MACH_TYPE_NAS100D              865
#define MACH_TYPE_MAGICIAN             875
#define MACH_TYPE_CM4002               876
#define MACH_TYPE_NXDKN                880
#define MACH_TYPE_PALMTX               885
#define MACH_TYPE_S3C2413              887
#define MACH_TYPE_WG302V2              890
#define MACH_TYPE_OMAP_2430SDP         900
#define MACH_TYPE_DAVINCI_EVM          901
#define MACH_TYPE_PALMZ72              904
#define MACH_TYPE_NXDB500              905
#define MACH_TYPE_APF9328              906
#define MACH_TYPE_PALMT5               917
#define MACH_TYPE_PALMTC               918
#define MACH_TYPE_OMAP_APOLLON         919
#define MACH_TYPE_ATEB9200             923
#define MACH_TYPE_N35                  927
#define MACH_TYPE_LOGICPD_PXA270       930
#define MACH_TYPE_NXEB500HMI           941
#define MACH_TYPE_ESPRESSO             949
#define MACH_TYPE_RX1950               952
#define MACH_TYPE_GESBC9312            958
#define MACH_TYPE_PICOTUX2XX           963
#define MACH_TYPE_DSMG600              964
#define MACH_TYPE_OMAP_FSAMPLE         970
#define MACH_TYPE_SNAPPER_CL15         986
#define MACH_TYPE_OMAP_PALMZ71         993
#define MACH_TYPE_SMDK2412             1009
#define MACH_TYPE_SMDK2413             1022
#define MACH_TYPE_AML_M5900            1024
#define MACH_TYPE_BALLOON3             1029
#define MACH_TYPE_ECBAT91              1072
#define MACH_TYPE_ONEARM               1075
#define MACH_TYPE_SMDK2443             1084
#define MACH_TYPE_FSG                  1091
#define MACH_TYPE_AT91SAM9260EK        1099
#define MACH_TYPE_GLANTANK             1100
#define MACH_TYPE_N2100                1101
#define MACH_TYPE_IM42XX               1105
#define MACH_TYPE_QT2410               1108
#define MACH_TYPE_KIXRP435             1109
#define MACH_TYPE_CC9P9360DEV          1114
#define MACH_TYPE_EDB9302A             1127
#define MACH_TYPE_EDB9307A             1128
#define MACH_TYPE_OMAP_3430SDP         1138
#define MACH_TYPE_VSTMS                1140
#define MACH_TYPE_MICRO9M              1169
#define MACH_TYPE_BUG                  1179
#define MACH_TYPE_AT91SAM9263EK        1202
#define MACH_TYPE_EM7210               1212
#define MACH_TYPE_VPAC270              1227
#define MACH_TYPE_TREO680              1230
#define MACH_TYPE_ZYLONITE             1233
#define MACH_TYPE_MX31LITE             1236
#define MACH_TYPE_MIOA701              1257
#define MACH_TYPE_ARMADILLO5X0         1260
#define MACH_TYPE_CC9P9360JS           1264
#define MACH_TYPE_SMDK6400             1270
#define MACH_TYPE_NOKIA_N800           1271
#define MACH_TYPE_EP80219              1281
#define MACH_TYPE_GORAMO_MLR           1292
#define MACH_TYPE_EM_X270              1297
#define MACH_TYPE_NEO1973_GTA02        1304
#define MACH_TYPE_AT91SAM9RLEK         1326
#define MACH_TYPE_COLIBRI320           1340
#define MACH_TYPE_CAM60                1351
#define MACH_TYPE_AT91EB01             1354
#define MACH_TYPE_DB88F5281            1358
#define MACH_TYPE_CSB726               1359
#define MACH_TYPE_DAVINCI_DM6467_EVM   1380
#define MACH_TYPE_DAVINCI_DM355_EVM    1381
#define MACH_TYPE_LITTLETON            1388
#define MACH_TYPE_IM4004               1400
#define MACH_TYPE_REALVIEW_PB11MP      1407
#define MACH_TYPE_MX27_3DS             1430
#define MACH_TYPE_HALIBUT              1439
#define MACH_TYPE_TROUT                1440
#define MACH_TYPE_TCT_HAMMER           1460
#define MACH_TYPE_HERALD               1461
#define MACH_TYPE_SIM_ONE              1476
#define MACH_TYPE_JIVE                 1490
#define MACH_TYPE_SAM9_L9260           1501
#define MACH_TYPE_REALVIEW_PB1176      1504
#define MACH_TYPE_YL9200               1507
#define MACH_TYPE_RD88F5182            1508
#define MACH_TYPE_KUROBOX_PRO          1509
#define MACH_TYPE_MX31_3DS             1511
#define MACH_TYPE_QONG                 1524
#define MACH_TYPE_OMAP2EVM             1534
#define MACH_TYPE_OMAP3EVM             1535
#define MACH_TYPE_DNS323               1542
#define MACH_TYPE_OMAP3_BEAGLE         1546
#define MACH_TYPE_NOKIA_N810           1548
#define MACH_TYPE_PCM038               1551
#define MACH_TYPE_SG310                1564
#define MACH_TYPE_TS209                1565
#define MACH_TYPE_AT91CAP9ADK          1566
#define MACH_TYPE_MX31MOBOARD          1574
#define MACH_TYPE_VISION_EP9307        1578
#define MACH_TYPE_TERASTATION_PRO2     1584
#define MACH_TYPE_LINKSTATION_PRO      1585
#define MACH_TYPE_E350                 1596
#define MACH_TYPE_TS409                1601
#define MACH_TYPE_RSI_EWS              1609
#define MACH_TYPE_CM_X300              1616
#define MACH_TYPE_AT91SAM9G20EK        1624
#define MACH_TYPE_SMDK6410             1626
#define MACH_TYPE_U300                 1627
#define MACH_TYPE_WRT350N_V2           1633
#define MACH_TYPE_OMAP_LDP             1639
#define MACH_TYPE_MX35_3DS             1645
#define MACH_TYPE_NEUROS_OSD2          1647
#define MACH_TYPE_TRIZEPS4WL           1649
#define MACH_TYPE_TS78XX               1652
#define MACH_TYPE_SFFSDR               1657
#define MACH_TYPE_PCM037               1673
#define MACH_TYPE_DB88F6281_BP         1680
#define MACH_TYPE_RD88F6192_NAS        1681
#define MACH_TYPE_RD88F6281            1682
#define MACH_TYPE_DB78X00_BP           1683
#define MACH_TYPE_SMDK2416             1685
#define MACH_TYPE_WBD111               1690
#define MACH_TYPE_MV2120               1693
#define MACH_TYPE_MX51_3DS             1696
#define MACH_TYPE_IMX27LITE            1701
#define MACH_TYPE_USB_A9260            1709
#define MACH_TYPE_USB_A9263            1710
#define MACH_TYPE_QIL_A9260            1711
#define MACH_TYPE_KZM_ARM11_01         1722
#define MACH_TYPE_NOKIA_N810_WIMAX     1727
#define MACH_TYPE_SAPPHIRE             1729
#define MACH_TYPE_STMP37XX             1732
#define MACH_TYPE_STMP378X             1733
#define MACH_TYPE_EZX_A780             1740
#define MACH_TYPE_EZX_E680             1741
#define MACH_TYPE_EZX_A1200            1742
#define MACH_TYPE_EZX_E6               1743
#define MACH_TYPE_EZX_E2               1744
#define MACH_TYPE_EZX_A910             1745
#define MACH_TYPE_EDMINI_V2            1756
#define MACH_TYPE_ZIPIT2               1757
#define MACH_TYPE_OMAP3_PANDORA        1761
#define MACH_TYPE_MSS2                 1766
#define MACH_TYPE_LB88RC8480           1769
#define MACH_TYPE_MX25_3DS             1771
#define MACH_TYPE_OMAP3530_LV_SOM      1773
#define MACH_TYPE_DAVINCI_DA830_EVM    1781
#define MACH_TYPE_DOVE_DB              1788
#define MACH_TYPE_OVERO                1798
#define MACH_TYPE_AT2440EVB            1799
#define MACH_TYPE_NEOCORE926           1800
#define MACH_TYPE_WNR854T              1801
#define MACH_TYPE_RD88F5181L_GE        1812
#define MACH_TYPE_RD88F5181L_FXO       1818
#define MACH_TYPE_STAMP9G20            1824
#define MACH_TYPE_SMDKC100             1826
#define MACH_TYPE_TAVOREVB             1827
#define MACH_TYPE_SAAR                 1828
#define MACH_TYPE_AT91SAM9M10G45EK     1830
#define MACH_TYPE_USB_A9G20            1841
#define MACH_TYPE_MXLADS               1851
#define MACH_TYPE_LINKSTATION_MINI     1858
#define MACH_TYPE_AFEB9260             1859
#define MACH_TYPE_IMX27IPCAM           1871
#define MACH_TYPE_RD88F6183AP_GE       1894
#define MACH_TYPE_REALVIEW_PBA8        1897
#define MACH_TYPE_REALVIEW_PBX         1901
#define MACH_TYPE_MICRO9S              1902
#define MACH_TYPE_RUT100               1908
#define MACH_TYPE_G3EVM                1919
#define MACH_TYPE_W90P910EVB           1921
#define MACH_TYPE_W90P950EVB           1923
#define MACH_TYPE_W90N960EVB           1924
#define MACH_TYPE_MV88F6281GTW_GE      1932
#define MACH_TYPE_NCP                  1933
#define MACH_TYPE_DAVINCI_DM365_EVM    1939
#define MACH_TYPE_CENTRO               1944
#define MACH_TYPE_NOKIA_RX51           1955
#define MACH_TYPE_OMAP_ZOOM2           1967
#define MACH_TYPE_CPUAT9260            1973
#define MACH_TYPE_EUKREA_CPUIMX27      1975
#define MACH_TYPE_ACS5K                1982
#define MACH_TYPE_SNAPPER_9260         1987
#define MACH_TYPE_DSM320               1988
#define MACH_TYPE_EXEDA                1994
#define MACH_TYPE_MINI2440             1999
#define MACH_TYPE_COLIBRI300           2000
#define MACH_TYPE_LINKSTATION_LS_HGL   2005
#define MACH_TYPE_CPUAT9G20            2031
#define MACH_TYPE_SMDK6440             2032
#define MACH_TYPE_NAS4220B             2038
#define MACH_TYPE_ZYLONITE2            2042
#define MACH_TYPE_ASPENITE             2043
#define MACH_TYPE_TTC_DKB              2045
#define MACH_TYPE_PCM043               2072
#define MACH_TYPE_SHEEVAPLUG           2097
#define MACH_TYPE_AVENGERS_LITE        2104
#define MACH_TYPE_MX51_BABBAGE         2125
#define MACH_TYPE_RD78X00_MASA         2135
#define MACH_TYPE_DM355_LEOPARD        2138
#define MACH_TYPE_TS219                2139
#define MACH_TYPE_PCA100               2149
#define MACH_TYPE_DAVINCI_DA850_EVM    2157
#define MACH_TYPE_AT91SAM9G10EK        2159
#define MACH_TYPE_OMAP_4430SDP         2160
#define MACH_TYPE_MAGX_ZN5             2162
#define MACH_TYPE_OMAP3_TORPEDO        2178
#define MACH_TYPE_ANW6410              2183
#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
#define MACH_TYPE_PORTUXG20            2191
#define MACH_TYPE_SMDKC110             2193
#define MACH_TYPE_CABESPRESSO          2194
#define MACH_TYPE_OMAP3517EVM          2200
#define MACH_TYPE_NETSPACE_V2          2201
#define MACH_TYPE_NETSPACE_MAX_V2      2202
#define MACH_TYPE_D2NET_V2             2203
#define MACH_TYPE_NET2BIG_V2           2204
#define MACH_TYPE_NET5BIG_V2           2206
#define MACH_TYPE_INETSPACE_V2         2208
#define MACH_TYPE_AT91SAM9G45EKES      2212
#define MACH_TYPE_SPEAR600             2236
#define MACH_TYPE_SPEAR300             2237
#define MACH_TYPE_LILLY1131            2239
#define MACH_TYPE_HMT                  2254
#define MACH_TYPE_VEXPRESS             2272
#define MACH_TYPE_D2NET                2282
#define MACH_TYPE_BIGDISK              2283
#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
#define MACH_TYPE_BCMRING              2289
#define MACH_TYPE_MAHIMAHI             2304
#define MACH_TYPE_CEREBRIC             2311
#define MACH_TYPE_SMDK6442             2324
#define MACH_TYPE_OPENRD_BASE          2325
#define MACH_TYPE_DEVKIT8000           2330
#define MACH_TYPE_MX51_EFIKAMX         2336
#define MACH_TYPE_CM_T35               2341
#define MACH_TYPE_NET2BIG              2342
#define MACH_TYPE_IGEP0020             2344
#define MACH_TYPE_NUC932EVB            2356
#define MACH_TYPE_OPENRD_CLIENT        2361
#define MACH_TYPE_U8500                2368
#define MACH_TYPE_MX51_EFIKASB         2370
#define MACH_TYPE_MARVELL_JASPER       2382
#define MACH_TYPE_FLINT                2383
#define MACH_TYPE_TAVOREVB3            2384
#define MACH_TYPE_TOUCHBOOK            2393
#define MACH_TYPE_RAUMFELD_RC          2413
#define MACH_TYPE_RAUMFELD_CONNECTOR   2414
#define MACH_TYPE_RAUMFELD_SPEAKER     2415
#define MACH_TYPE_TNETV107X            2418
#define MACH_TYPE_SMDKV210             2456
#define MACH_TYPE_OMAP_ZOOM3           2464
#define MACH_TYPE_OMAP_3630SDP         2465
#define MACH_TYPE_CYBOOK2440           2466
#define MACH_TYPE_SMARTQ7              2479
#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
#define MACH_TYPE_G4EVM                2493
#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
#define MACH_TYPE_TS41X                2502
#define MACH_TYPE_PHY3250              2511
#define MACH_TYPE_MINI6410             2520
#define MACH_TYPE_MX28EVK              2531
#define MACH_TYPE_SMARTQ5              2534
#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
#define MACH_TYPE_MXT_TD60             2550
#define MACH_TYPE_CAPC7117             2612
#define MACH_TYPE_ICONTROL             2624
#define MACH_TYPE_GPLUGD               2625
#define MACH_TYPE_QSD8X50A_ST1_5       2627
#define MACH_TYPE_MX23EVK              2629
#define MACH_TYPE_AP4EVB               2630
#define MACH_TYPE_MITYOMAPL138         2650
#define MACH_TYPE_GURUPLUG             2659
#define MACH_TYPE_SPEAR310             2660
#define MACH_TYPE_SPEAR320             2661
#define MACH_TYPE_AQUILA               2676
#define MACH_TYPE_ESATA_SHEEVAPLUG     2678
#define MACH_TYPE_MSM7X30_SURF         2679
#define MACH_TYPE_TERASTATION_WXL      2697
#define MACH_TYPE_MSM7X25_SURF         2703
#define MACH_TYPE_MSM7X25_FFA          2704
#define MACH_TYPE_MSM7X27_SURF         2705
#define MACH_TYPE_MSM7X27_FFA          2706
#define MACH_TYPE_MSM7X30_FFA          2707
#define MACH_TYPE_QSD8X50_SURF         2708
#define MACH_TYPE_MX53_EVK             2716
#define MACH_TYPE_IGEP0030             2717
#define MACH_TYPE_SBC3530              2722
#define MACH_TYPE_SAARB                2727
#define MACH_TYPE_HARMONY              2731
#define MACH_TYPE_CYBOOK_ORIZON        2733
#define MACH_TYPE_MSM7X30_FLUID        2741
#define MACH_TYPE_CM_T3517             2750
#define MACH_TYPE_WBD222               2753
#define MACH_TYPE_MSM8X60_SURF         2755
#define MACH_TYPE_MSM8X60_SIM          2756
#define MACH_TYPE_TCC8000_SDK          2758
#define MACH_TYPE_CNS3420VB            2776
#define MACH_TYPE_OMAP4_PANDA          2791
#define MACH_TYPE_TI8168EVM            2800
#define MACH_TYPE_TETON_BGA            2816
#define MACH_TYPE_EUKREA_CPUIMX25SD    2820
#define MACH_TYPE_EUKREA_CPUIMX35SD    2821
#define MACH_TYPE_EUKREA_CPUIMX51SD    2822
#define MACH_TYPE_EUKREA_CPUIMX51      2823
#define MACH_TYPE_SMDKC210             2838
#define MACH_TYPE_T5325                2846
#define MACH_TYPE_INCOME               2849
#define MACH_TYPE_GONI                 2862
#define MACH_TYPE_BV07                 2882
#define MACH_TYPE_OPENRD_ULTIMATE      2884
#define MACH_TYPE_DEVIXP               2885
#define MACH_TYPE_MICCPT               2886
#define MACH_TYPE_MIC256               2887
#define MACH_TYPE_U5500                2890
#define MACH_TYPE_LINKSTATION_LSCHL    2913
#define MACH_TYPE_SMDKV310             2925
#define MACH_TYPE_WM8505_7IN_NETBOOK   2928
#define MACH_TYPE_CRANEBOARD           2932
#define MACH_TYPE_SMDK6450             2938
#define MACH_TYPE_BROWNSTONE           2957
#define MACH_TYPE_FLEXIBITY            2965
#define MACH_TYPE_MX50_RDP             2988
#define MACH_TYPE_UNIVERSAL_C210       2989
#define MACH_TYPE_REAL6410             2990
#define MACH_TYPE_DOCKSTAR             2998
#define MACH_TYPE_TI8148EVM            3004
#define MACH_TYPE_SEABOARD             3005
#define MACH_TYPE_MX53_ARD             3010
#define MACH_TYPE_MX53_SMD             3011
#define MACH_TYPE_MSM8X60_RUMI3        3016
#define MACH_TYPE_MSM8X60_FFA          3017
#define MACH_TYPE_CM_A510              3020
#define MACH_TYPE_TX28                 3043
#define MACH_TYPE_PCONTROL_G20         3062
#define MACH_TYPE_VPR200               3087
#define MACH_TYPE_TORBRECK             3090
#define MACH_TYPE_PRIMA2_EVB           3103
#define MACH_TYPE_PAZ00                3128
#define MACH_TYPE_ACMENETUSFOXG20      3129
#define MACH_TYPE_AG5EVM               3189
#define MACH_TYPE_ICS_IF_VOIP          3206
#define MACH_TYPE_WLF_CRAGG_6410       3207
#define MACH_TYPE_TRIMSLICE            3209
#define MACH_TYPE_KAEN                 3217
#define MACH_TYPE_NOKIA_RM680          3220
#define MACH_TYPE_MSM8960_SIM          3230
#define MACH_TYPE_MSM8960_RUMI3        3231
#define MACH_TYPE_GSIA18S              3234
#define MACH_TYPE_MX53_LOCO            3273
#define MACH_TYPE_WARIO                3288
#define MACH_TYPE_CM_T3730             3290
#define MACH_TYPE_HREFV60              3293
#define MACH_TYPE_ARMLEX4210           3361
#define MACH_TYPE_SNOWBALL             3363
#define MACH_TYPE_XILINX_EP107         3378
#define MACH_TYPE_NURI                 3379
#define MACH_TYPE_ORIGEN               3455
#define MACH_TYPE_NSPIRE               3503
#define MACH_TYPE_NOKIA_RM696          3522
#define MACH_TYPE_MIKRAP_X168          3543
#define MACH_TYPE_DETO_MACARM9         3568
#define MACH_TYPE_M28EVK               3613
#define MACH_TYPE_KOTA2                3616
#define MACH_TYPE_BONITO               3623
#define MACH_TYPE_OMAP3_EGF            3637
#define MACH_TYPE_SMDK4212             3638
#define MACH_TYPE_APX4DEVKIT           3712
#define MACH_TYPE_SMDK4412             3765
#define MACH_TYPE_MARZEN               3790
#define MACH_TYPE_KROME                3797
#define MACH_TYPE_ARMADILLO800EVA      3863
#define MACH_TYPE_MX53_UMOBO           3927
#define MACH_TYPE_MT4                  3981
#define MACH_TYPE_U8520                3990
#define MACH_TYPE_CHUPACABRA           4098
#define MACH_TYPE_SCORPION             4099
#define MACH_TYPE_DAVINCI_HE_HMI10     4100
#define MACH_TYPE_TOPKICK              4101
#define MACH_TYPE_M3_AUGUESTRUSH       4102
#define MACH_TYPE_IPC335X              4103
#define MACH_TYPE_SUN4I                4104
#define MACH_TYPE_IMX233_OLINUXINO     4105
#define MACH_TYPE_K2_WL                4106
#define MACH_TYPE_K2_UL                4107
#define MACH_TYPE_K2_CL                4108
#define MACH_TYPE_MINBARI_W            4109
#define MACH_TYPE_MINBARI_M            4110
#define MACH_TYPE_K035                 4111
#define MACH_TYPE_ARIEL                4112
#define MACH_TYPE_ARIELSAARC           4113
#define MACH_TYPE_ARIELDKB             4114
#define MACH_TYPE_ARMADILLO810         4115
#define MACH_TYPE_TAM335X              4116
#define MACH_TYPE_GROUPER              4117
#define MACH_TYPE_MPCSA21_9G20         4118
#define MACH_TYPE_M6U_CPU              4119
#define MACH_TYPE_GINKGO               4121
#define MACH_TYPE_CGT_QMX6             4122
#define MACH_TYPE_PROFPGA              4123
#define MACH_TYPE_ACFX100OC            4124
#define MACH_TYPE_ACFX100NB            4125
#define MACH_TYPE_CAPRICORN            4126
#define MACH_TYPE_PISCES               4127
#define MACH_TYPE_ARIES                4128
#define MACH_TYPE_CANCER               4129
#define MACH_TYPE_LEO                  4130
#define MACH_TYPE_VIRGO                4131
#define MACH_TYPE_SAGITTARIUS          4132
#define MACH_TYPE_DEVIL                4133
#define MACH_TYPE_BALLANTINES          4134
#define MACH_TYPE_OMAP3_PROCERUSVPU    4135
#define MACH_TYPE_MY27                 4136
#define MACH_TYPE_SUN6I                4137
#define MACH_TYPE_SUN5I                4138
#define MACH_TYPE_MX512_MX             4139
#define MACH_TYPE_KZM9G                4140
#define MACH_TYPE_VDSTBN               4141
#define MACH_TYPE_CFA10036             4142
#define MACH_TYPE_CFA10049             4143
#define MACH_TYPE_PCM051               4144
#define MACH_TYPE_VYBRID_VF7XX         4145
#define MACH_TYPE_VYBRID_VF6XX         4146
#define MACH_TYPE_VYBRID_VF5XX         4147
#define MACH_TYPE_VYBRID_VF4XX         4148
#define MACH_TYPE_ARIA_G25             4149
#define MACH_TYPE_BCM21553             4150
#define MACH_TYPE_SMDK5410             4151
#define MACH_TYPE_LPC18XX              4152
#define MACH_TYPE_ORATISPARTY          4153
#define MACH_TYPE_QSEVEN               4154
#define MACH_TYPE_GMV_GENERIC          4155
#define MACH_TYPE_TH_LINK_ETH          4156
#define MACH_TYPE_TN_MUNINN            4157
#define MACH_TYPE_RAMPAGE              4158
#define MACH_TYPE_VISSTRIM_MV10        4159
#define MACH_TYPE_MX28_WILMA           4164
#define MACH_TYPE_MSM8625_FFA          4166
#define MACH_TYPE_VPU101               4167
#define MACH_TYPE_BAILEYS              4169
#define MACH_TYPE_FAMILYBOX            4170
#define MACH_TYPE_ENSEMBLE_MX35        4171
#define MACH_TYPE_SC_SPS_1             4172
#define MACH_TYPE_UCSIMPLY_SAM9260     4173
#define MACH_TYPE_UNICORN              4174
#define MACH_TYPE_M9G45A               4175
#define MACH_TYPE_MTWEBIF              4176
#define MACH_TYPE_PLAYSTONE            4177
#define MACH_TYPE_CHELSEA              4178
#define MACH_TYPE_BAYERN               4179
#define MACH_TYPE_MITWO                4180
#define MACH_TYPE_MX25_NOAH            4181
#define MACH_TYPE_STM_B2020            4182
#define MACH_TYPE_ANNAX_SRC            4183
#define MACH_TYPE_IONICS_STRATUS       4184
#define MACH_TYPE_HUGO                 4185
#define MACH_TYPE_EM300                4186
#define MACH_TYPE_MMP3_QSEVEN          4187
#define MACH_TYPE_BOSPHORUS2           4188
#define MACH_TYPE_TT2200               4189
#define MACH_TYPE_OCELOT3              4190
#define MACH_TYPE_TEK_COBRA            4191
#define MACH_TYPE_PROTOU               4192
#define MACH_TYPE_MSM8625_EVT          4193
#define MACH_TYPE_MX53_SELLWOOD        4194
#define MACH_TYPE_SOMIQ_AM35           4195
#define MACH_TYPE_SOMIQ_AM37           4196
#define MACH_TYPE_K2_PLC_CL            4197
#define MACH_TYPE_TC2                  4198
#define MACH_TYPE_DULEX_J              4199
#define MACH_TYPE_STM_B2044            4200
#define MACH_TYPE_DELUXE_J             4201
#define MACH_TYPE_MANGO2443            4202
#define MACH_TYPE_CP2DCG               4203
#define MACH_TYPE_CP2DTG               4204
#define MACH_TYPE_CP2DUG               4205
#define MACH_TYPE_VAR_SOM_AM33         4206
#define MACH_TYPE_PEPPER               4207
#define MACH_TYPE_MANGO2450            4208
#define MACH_TYPE_VALENTE_WX_C9        4209
#define MACH_TYPE_MINITV               4210
#define MACH_TYPE_U8540                4211
#define MACH_TYPE_IV_ATLAS_I_Z7E       4212
#define MACH_TYPE_MACH_TYPE_SKY        4214
#define MACH_TYPE_BLUESKY              4215
#define MACH_TYPE_NGROUTER             4216
#define MACH_TYPE_MX53_DENETIM         4217
#define MACH_TYPE_OPAL                 4218
#define MACH_TYPE_GNET_US3GREF         4219
#define MACH_TYPE_GNET_NC3G            4220
#define MACH_TYPE_GNET_GE3G            4221
#define MACH_TYPE_ADP2                 4222
#define MACH_TYPE_TQMA28               4223
#define MACH_TYPE_KACOM3               4224
#define MACH_TYPE_RRHDEMO              4225
#define MACH_TYPE_PROTODUG             4226
#define MACH_TYPE_LAGO                 4227
#define MACH_TYPE_KTT30                4228
#define MACH_TYPE_TS43XX               4229
#define MACH_TYPE_MX6Q_DENSO           4230
#define MACH_TYPE_COMSAT_GSMUMTS8      4231
#define MACH_TYPE_DREAMX               4232
#define MACH_TYPE_THUNDERSTONEM        4233
#define MACH_TYPE_YOYOPAD              4234
#define MACH_TYPE_YOYOPATIENT          4235
#define MACH_TYPE_A10L                 4236
#define MACH_TYPE_MQ60                 4237
#define MACH_TYPE_LINKSTATION_LSQL     4238
#define MACH_TYPE_AM3703GATEWAY        4239
#define MACH_TYPE_ACCIPITER            4240
#define MACH_TYPE_MAGNIDUG             4242
#define MACH_TYPE_HYDRA                4243
#define MACH_TYPE_SUN3I                4244
#define MACH_TYPE_STM_B2078            4245
#define MACH_TYPE_AT91SAM9263DESKV2    4246
#define MACH_TYPE_DELUXE_R             4247
#define MACH_TYPE_P_98_V               4248
#define MACH_TYPE_P_98_C               4249
#define MACH_TYPE_DAVINCI_AM18XX_OMN   4250
#define MACH_TYPE_SOCFPGA_CYCLONE5     4251
#define MACH_TYPE_CABATUIN             4252
#define MACH_TYPE_YOYOPAD_FT           4253
#define MACH_TYPE_DAN2400EVB           4254
#define MACH_TYPE_DAN3400EVB           4255
#define MACH_TYPE_EDM_SF_IMX6          4256
#define MACH_TYPE_EDM_CF_IMX6          4257
#define MACH_TYPE_VPOS3XX              4258
#define MACH_TYPE_VULCANO_9X5          4259
#define MACH_TYPE_SPMP8000             4260
#define MACH_TYPE_CATALINA             4261
#define MACH_TYPE_RD88F5181L_FE        4262
#define MACH_TYPE_MX535_MX             4263
#define MACH_TYPE_ARMADILLO840         4264
#define MACH_TYPE_SPC9000BASEBOARD     4265
#define MACH_TYPE_IRIS                 4266
#define MACH_TYPE_PROTODCG             4267
#define MACH_TYPE_PALMTREE             4268
#define MACH_TYPE_NOVENA               4269
#define MACH_TYPE_MA_UM                4270
#define MACH_TYPE_MA_AM                4271
#define MACH_TYPE_EMS348               4272
#define MACH_TYPE_CM_FX6               4273
#define MACH_TYPE_ARNDALE              4274
#define MACH_TYPE_Q5XR5                4275
#define MACH_TYPE_WILLOW               4276
#define MACH_TYPE_OMAP3621_ODYV3       4277
#define MACH_TYPE_OMAPL138_PRESONUS    4278
#define MACH_TYPE_DVF99                4279
#define MACH_TYPE_IMPRESSION_J         4280
#define MACH_TYPE_QBLISSA9             4281
#define MACH_TYPE_ROBIN_HELIVIEW10     4282
#define MACH_TYPE_SUN7I                4283
#define MACH_TYPE_MX6Q_HDMIDONGLE      4284
#define MACH_TYPE_MX6_SID2             4285
#define MACH_TYPE_HELIOS_V3            4286
#define MACH_TYPE_HELIOS_V4            4287
#define MACH_TYPE_Q7_IMX6              4288
#define MACH_TYPE_ODROIDX              4289
#define MACH_TYPE_ROBPRO               4290
#define MACH_TYPE_RESEARCH59IF_MK1     4291
#define MACH_TYPE_BOBSLEIGH            4292
#define MACH_TYPE_DCSHGWT3             4293
#define MACH_TYPE_GLD1018              4294
#define MACH_TYPE_EV10                 4295
#define MACH_TYPE_NITROGEN6X           4296
#define MACH_TYPE_P_107_BB             4297
#define MACH_TYPE_EVITA_UTL            4298
#define MACH_TYPE_FALCONWING           4299
#define MACH_TYPE_DCT3                 4300
#define MACH_TYPE_CPX2E_CELL           4301
#define MACH_TYPE_AMIRO                4302
#define MACH_TYPE_MX6Q_BRASSBOARD      4303
#define MACH_TYPE_DALMORE              4304
#define MACH_TYPE_OMAP3_PORTAL7CP      4305
#define MACH_TYPE_TEGRA_PLUTO          4306
#define MACH_TYPE_MX6SL_EVK            4307
#define MACH_TYPE_M7                   4308
#define MACH_TYPE_PXM2                 4309
#define MACH_TYPE_HABA_KNX_LITE        4310
#define MACH_TYPE_TAI                  4311
#define MACH_TYPE_PROTOTD              4312
#define MACH_TYPE_DST_TONTO            4313
#define MACH_TYPE_DRACO                4314
#define MACH_TYPE_DXR2                 4315
#define MACH_TYPE_RUT                  4316
#define MACH_TYPE_AM180X_WSC           4317
#define MACH_TYPE_DELUXE_U             4318
#define MACH_TYPE_DELUXE_UL            4319
#define MACH_TYPE_AT91SAM9260MEDTHS    4320
#define MACH_TYPE_MATRIX516            4321
#define MACH_TYPE_VID401X              4322
#define MACH_TYPE_HELIOS_V5            4323
#define MACH_TYPE_PLAYPAQ2             4324
#define MACH_TYPE_IGAM                 4325
#define MACH_TYPE_AMICO_I              4326
#define MACH_TYPE_AMICO_E              4327
#define MACH_TYPE_SENTIENT_MM3_CK      4328
#define MACH_TYPE_SMX6                 4329
#define MACH_TYPE_PANGO                4330
#define MACH_TYPE_NS115_STICK          4331
#define MACH_TYPE_BCTRM3               4332
#define MACH_TYPE_DOCTORWS             4333
#define MACH_TYPE_M2601                4334
#define MACH_TYPE_VGG1111              4337
#define MACH_TYPE_COUNTACH             4338
#define MACH_TYPE_VISSTRIM_SM20        4339
#define MACH_TYPE_A639                 4340
#define MACH_TYPE_SPACEMONKEY          4341
#define MACH_TYPE_ZPDU_STAMP           4342
#define MACH_TYPE_HTC_G7_CLONE         4343
#define MACH_TYPE_FT2080_CORVUS        4344
#define MACH_TYPE_FISLAND              4345
#define MACH_TYPE_ZPDU                 4346
#define MACH_TYPE_URT                  4347
#define MACH_TYPE_CONTI_OVIP           4348
#define MACH_TYPE_OMAPL138_NAGRA       4349
#define MACH_TYPE_DA850_AT3KP1         4350
#define MACH_TYPE_DA850_AT3KP2         4351
#define MACH_TYPE_SURMA                4352
#define MACH_TYPE_STM_B2092            4353
#define MACH_TYPE_MX535_YCR            4354
#define MACH_TYPE_M7_WL                4355
#define MACH_TYPE_M7_U                 4356
#define MACH_TYPE_OMAP3_STNDT_EVM      4357
#define MACH_TYPE_M7_WLV               4358
#define MACH_TYPE_XAM3517              4359
#define MACH_TYPE_A220                 4360
#define MACH_TYPE_ACLIMA_ODIE          4361
#define MACH_TYPE_VIBBLE               4362
#define MACH_TYPE_K2_U                 4363
#define MACH_TYPE_MX53_EGF             4364
#define MACH_TYPE_NOVPEK_IMX53         4365
#define MACH_TYPE_NOVPEK_IMX6X         4366
#define MACH_TYPE_MX25_SMARTBOX        4367
#define MACH_TYPE_EICG6410             4368
#define MACH_TYPE_PICASSO_E3           4369
#define MACH_TYPE_MOTONAVIGATOR        4370
#define MACH_TYPE_VARIOCONNECT2        4371
#define MACH_TYPE_DELUXE_TW            4372
#define MACH_TYPE_KORE3                4374
#define MACH_TYPE_MX6S_DRS             4375
#define MACH_TYPE_CMIMX6               4376
#define MACH_TYPE_ROTH                 4377
#define MACH_TYPE_EQ4UX                4378
#define MACH_TYPE_X1PLUS               4379
#define MACH_TYPE_MODIMX27             4380
#define MACH_TYPE_VIDEON_HDUAC         4381
#define MACH_TYPE_BLACKBIRD            4382
#define MACH_TYPE_RUNMASTER            4383
#define MACH_TYPE_CERES                4384
#define MACH_TYPE_NAD435               4385
#define MACH_TYPE_NS115_PROTO_TYPE     4386
#define MACH_TYPE_FS20_VCC             4387
#define MACH_TYPE_MESON6TV_SKT         4389
#define MACH_TYPE_KEYSTONE             4390
#define MACH_TYPE_PCM052               4391
#define MACH_TYPE_QRD_SKUD_PRIME       4393
#define MACH_TYPE_GUF_SANTARO          4395
#define MACH_TYPE_SHEEPSHEAD           4396
#define MACH_TYPE_MX6_IWG15M_MXM       4397
#define MACH_TYPE_MX6_IWG15M_Q7        4398
#define MACH_TYPE_AT91SAM9263IF8MIC    4399
#define MACH_TYPE_MARCOPOLO            4401
#define MACH_TYPE_MX535_SDCR           4402
#define MACH_TYPE_MX53_CSB2733         4403
#define MACH_TYPE_DIVA                 4404
#define MACH_TYPE_NCR_7744             4405
#define MACH_TYPE_MACALLAN             4406
#define MACH_TYPE_WNR3500              4407
#define MACH_TYPE_PGAVRF               4408
#define MACH_TYPE_HELIOS_V6            4409
#define MACH_TYPE_LCCT                 4410
#define MACH_TYPE_CSNDUG               4411
#define MACH_TYPE_WANDBOARD_IMX6       4412
#define MACH_TYPE_OMAP4_JET            4413
#define MACH_TYPE_TEGRA_ROTH           4414
#define MACH_TYPE_M7DCG                4415
#define MACH_TYPE_M7DUG                4416
#define MACH_TYPE_M7DTG                4417
#define MACH_TYPE_AP42X                4418
#define MACH_TYPE_VAR_SOM_MX6          4419
#define MACH_TYPE_PDLU                 4420
#define MACH_TYPE_HYDROGEN             4421
#define MACH_TYPE_NPA211E              4422
#define MACH_TYPE_ARCADIA              4423
#define MACH_TYPE_ARCADIA_L            4424
#define MACH_TYPE_MSM8930DT            4425
#define MACH_TYPE_KTAM3874             4426
#define MACH_TYPE_CEC4                 4427
#define MACH_TYPE_APE6EVM              4428
#define MACH_TYPE_TX6                  4429
#define MACH_TYPE_CFA10037             4431
#define MACH_TYPE_EZP1000              4433
#define MACH_TYPE_WGR826V              4434
#define MACH_TYPE_EXUMA                4435
#define MACH_TYPE_FREGATE              4436
#define MACH_TYPE_OSIRISIMX508         4437
#define MACH_TYPE_ST_EXIGO             4438
#define MACH_TYPE_PISMO                4439
#define MACH_TYPE_ATC7                 4440
#define MACH_TYPE_NSPIRECLP            4441
#define MACH_TYPE_NSPIRETP             4442
#define MACH_TYPE_NSPIRECX             4443
#define MACH_TYPE_MAYA                 4444
#define MACH_TYPE_WECCT                4445
#define MACH_TYPE_M2S                  4446
#define MACH_TYPE_MSM8625Q_EVBD        4447
#define MACH_TYPE_TINY210              4448
#define MACH_TYPE_G3                   4449
#define MACH_TYPE_HURRICANE            4450
#define MACH_TYPE_MX6_POD              4451
#define MACH_TYPE_ELONDCN              4452
#define MACH_TYPE_CWMX535              4453
#define MACH_TYPE_M7_WLJ               4454
#define MACH_TYPE_QSP_ARM              4455
#define MACH_TYPE_MSM8625Q_SKUD        4456
#define MACH_TYPE_HTCMONDRIAN          4457
#define MACH_TYPE_WATSON_EAD           4458
#define MACH_TYPE_MITWOA               4459
#define MACH_TYPE_OMAP3_WOLVERINE      4460
#define MACH_TYPE_MAPLETREE            4461
#define MACH_TYPE_MSM8625_FIH_SAE      4462
#define MACH_TYPE_EPC35                4463
#define MACH_TYPE_SMARTRTU             4464
#define MACH_TYPE_RCM101               4465
#define MACH_TYPE_AMX_IMX53_MXX        4466
#define MACH_TYPE_ACER_A12             4470
#define MACH_TYPE_SBC6X                4471
#define MACH_TYPE_U2                   4472
#define MACH_TYPE_SMDK4270             4473
#define MACH_TYPE_PRISCILLAG           4474
#define MACH_TYPE_PRISCILLAC           4475
#define MACH_TYPE_PRISCILLA            4476
#define MACH_TYPE_INNOVA_SHPU_V2       4477
#define MACH_TYPE_MACH_TYPE_DEP2410    4479
#define MACH_TYPE_BCTRE3               4480
#define MACH_TYPE_OMAP_M100            4481
#define MACH_TYPE_FLO                  4482
#define MACH_TYPE_NANOBONE             4483
#define MACH_TYPE_STM_B2105            4484
#define MACH_TYPE_OMAP4_BSC_BAP_V3     4485
#define MACH_TYPE_SS1PAM               4486
#define MACH_TYPE_PRIMOMINIU           4488
#define MACH_TYPE_MRT_35HD_DUALNAS_E   4489
#define MACH_TYPE_KIWI                 4490
#define MACH_TYPE_HW90496              4491
#define MACH_TYPE_MEP2440              4492
#define MACH_TYPE_COLIBRI_T30          4493
#define MACH_TYPE_CWV1                 4494
#define MACH_TYPE_NSA325               4495
#define MACH_TYPE_DPXMTC               4497
#define MACH_TYPE_TT_STUTTGART         4498
#define MACH_TYPE_MIRANDA_APCII        4499
#define MACH_TYPE_MX6Q_MODEROX         4500
#define MACH_TYPE_MUDSKIPPER           4501
#define MACH_TYPE_URANIA               4502
#define MACH_TYPE_STM_B2112            4503
#define MACH_TYPE_MX6Q_ATS_PHOENIX     4505
#define MACH_TYPE_STM_B2116            4506
#define MACH_TYPE_MYTHOLOGY            4507
#define MACH_TYPE_FC360V1              4508
#define MACH_TYPE_GPS_SENSOR           4509
#define MACH_TYPE_GAZELLE              4510
#define MACH_TYPE_MPQ8064_DMA          4511
#define MACH_TYPE_WEMS_ASD01           4512
#define MACH_TYPE_APALIS_T30           4513
#define MACH_TYPE_ARMSTONEA9           4515
#define MACH_TYPE_OMAP_BLAZETABLET     4516
#define MACH_TYPE_AR6MXQ               4517
#define MACH_TYPE_AR6MXS               4518
#define MACH_TYPE_GWVENTANA            4520
#define MACH_TYPE_IGEP0033             4521
#define MACH_TYPE_H52C1_CONCERTO       4524
#define MACH_TYPE_FCMBRD               4525
#define MACH_TYPE_PCAAXS1              4526
#define MACH_TYPE_LS_ORCA              4527
#define MACH_TYPE_PCM051LB             4528
#define MACH_TYPE_MX6S_LP507_GVCI      4529
#define MACH_TYPE_DIDO                 4530
#define MACH_TYPE_SWARCO_ITC3_9G20     4531
#define MACH_TYPE_ROBO_ROADY           4532
#define MACH_TYPE_RSKRZA1              4533
#define MACH_TYPE_SWARCO_SID           4534
#define MACH_TYPE_MX6_IWG15S_SBC       4535
#define MACH_TYPE_MX6Q_CAMARO          4536
#define MACH_TYPE_HB6MXS               4537
#define MACH_TYPE_LAGER                4538
#define MACH_TYPE_LP8X4X               4539
#define MACH_TYPE_TEGRATAB7            4540
#define MACH_TYPE_ANDROMEDA            4541
#define MACH_TYPE_BOOTES               4542
#define MACH_TYPE_NETHMI               4543
#define MACH_TYPE_TEGRATAB             4544
#define MACH_TYPE_SOM5_EVB             4545
#define MACH_TYPE_VENATICORUM          4546
#define MACH_TYPE_STM_B2110            4547
#define MACH_TYPE_ELUX_HATHOR          4548
#define MACH_TYPE_HELIOS_V7            4549
#define MACH_TYPE_XC10V1               4550
#define MACH_TYPE_CP2U                 4551
#define MACH_TYPE_IAP_F                4552
#define MACH_TYPE_IAP_G                4553
#define MACH_TYPE_AAE                  4554
#define MACH_TYPE_PEGASUS              4555
#define MACH_TYPE_CYGNUS               4556
#define MACH_TYPE_CENTAURUS            4557
#define MACH_TYPE_MSM8930_QRD8930      4558
#define MACH_TYPE_QUBY_TIM             4559
#define MACH_TYPE_ZEDI3250A            4560
#define MACH_TYPE_GRUS                 4561
#define MACH_TYPE_APOLLO3              4562
#define MACH_TYPE_COWON_R7             4563
#define MACH_TYPE_TONGA3               4564
#define MACH_TYPE_P535                 4565
#define MACH_TYPE_SA3874I              4566
#define MACH_TYPE_MX6_NAVICO_COM       4567
#define MACH_TYPE_PROXMOBIL2           4568
#define MACH_TYPE_UBINUX1              4569
#define MACH_TYPE_ISTOS                4570
#define MACH_TYPE_BENVOLIO4            4571
#define MACH_TYPE_ECO5_BX2             4572
#define MACH_TYPE_EUKREA_CPUIMX28SD    4573
#define MACH_TYPE_DOMOTAB              4574
#define MACH_TYPE_PFLA03               4575

#ifdef CONFIG_ARCH_EBSA110
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EBSA110
# endif
# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
#else
# define machine_is_ebsa110()	(0)
#endif

#ifdef CONFIG_ARCH_RPC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RISCPC
# endif
# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
#else
# define machine_is_riscpc()	(0)
#endif

#ifdef CONFIG_ARCH_EBSA285
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EBSA285
# endif
# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
#else
# define machine_is_ebsa285()	(0)
#endif

#ifdef CONFIG_ARCH_NETWINDER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETWINDER
# endif
# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
#else
# define machine_is_netwinder()	(0)
#endif

#ifdef CONFIG_ARCH_CATS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CATS
# endif
# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
#else
# define machine_is_cats()	(0)
#endif

#ifdef CONFIG_ARCH_SHARK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHARK
# endif
# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
#else
# define machine_is_shark()	(0)
#endif

#ifdef CONFIG_SA1100_BRUTUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BRUTUS
# endif
# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
#else
# define machine_is_brutus()	(0)
#endif

#ifdef CONFIG_ARCH_PERSONAL_SERVER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
# endif
# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
#else
# define machine_is_personal_server()	(0)
#endif

#ifdef CONFIG_ARCH_L7200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_L7200
# endif
# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
#else
# define machine_is_l7200()	(0)
#endif

#ifdef CONFIG_SA1100_PLEB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PLEB
# endif
# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
#else
# define machine_is_pleb()	(0)
#endif

#ifdef CONFIG_ARCH_INTEGRATOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INTEGRATOR
# endif
# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
#else
# define machine_is_integrator()	(0)
#endif

#ifdef CONFIG_SA1100_H3600
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H3600
# endif
# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
#else
# define machine_is_h3600()	(0)
#endif

#ifdef CONFIG_ARCH_P720T
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P720T
# endif
# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
#else
# define machine_is_p720t()	(0)
#endif

#ifdef CONFIG_SA1100_ASSABET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ASSABET
# endif
# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
#else
# define machine_is_assabet()	(0)
#endif

#ifdef CONFIG_SA1100_LART
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LART
# endif
# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
#else
# define machine_is_lart()	(0)
#endif

#ifdef CONFIG_SA1100_GRAPHICSCLIENT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
# endif
# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
#else
# define machine_is_graphicsclient()	(0)
#endif

#ifdef CONFIG_SA1100_XP860
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XP860
# endif
# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
#else
# define machine_is_xp860()	(0)
#endif

#ifdef CONFIG_SA1100_CERF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CERF
# endif
# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
#else
# define machine_is_cerf()	(0)
#endif

#ifdef CONFIG_SA1100_NANOENGINE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NANOENGINE
# endif
# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
#else
# define machine_is_nanoengine()	(0)
#endif

#ifdef CONFIG_SA1100_JORNADA720
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_JORNADA720
# endif
# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
#else
# define machine_is_jornada720()	(0)
#endif

#ifdef CONFIG_ARCH_EDB7211
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB7211
# endif
# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
#else
# define machine_is_edb7211()	(0)
#endif

#ifdef CONFIG_SA1100_PFS168
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PFS168
# endif
# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
#else
# define machine_is_pfs168()	(0)
#endif

#ifdef CONFIG_SA1100_FLEXANET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLEXANET
# endif
# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
#else
# define machine_is_flexanet()	(0)
#endif

#ifdef CONFIG_SA1100_SIMPAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SIMPAD
# endif
# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
#else
# define machine_is_simpad()	(0)
#endif

#ifdef CONFIG_ARCH_LUBBOCK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LUBBOCK
# endif
# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
#else
# define machine_is_lubbock()	(0)
#endif

#ifdef CONFIG_ARCH_CLEP7212
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CLEP7212
# endif
# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
#else
# define machine_is_clep7212()	(0)
#endif

#ifdef CONFIG_SA1100_SHANNON
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHANNON
# endif
# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
#else
# define machine_is_shannon()	(0)
#endif

#ifdef CONFIG_SA1100_CONSUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CONSUS
# endif
# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
#else
# define machine_is_consus()	(0)
#endif

#ifdef CONFIG_ARCH_AAED2000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AAED2000
# endif
# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
#else
# define machine_is_aaed2000()	(0)
#endif

#ifdef CONFIG_ARCH_CDB89712
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CDB89712
# endif
# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
#else
# define machine_is_cdb89712()	(0)
#endif

#ifdef CONFIG_SA1100_GRAPHICSMASTER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
# endif
# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
#else
# define machine_is_graphicsmaster()	(0)
#endif

#ifdef CONFIG_SA1100_ADSBITSY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ADSBITSY
# endif
# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
#else
# define machine_is_adsbitsy()	(0)
#endif

#ifdef CONFIG_ARCH_PXA_IDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PXA_IDP
# endif
# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
#else
# define machine_is_pxa_idp()	(0)
#endif

#ifdef CONFIG_SA1100_PT_SYSTEM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
# endif
# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
#else
# define machine_is_pt_system3()	(0)
#endif

#ifdef CONFIG_ARCH_AUTCPU12
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AUTCPU12
# endif
# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
#else
# define machine_is_autcpu12()	(0)
#endif

#ifdef CONFIG_SA1100_H3100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H3100
# endif
# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
#else
# define machine_is_h3100()	(0)
#endif

#ifdef CONFIG_SA1100_COLLIE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLLIE
# endif
# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
#else
# define machine_is_collie()	(0)
#endif

#ifdef CONFIG_SA1100_BADGE4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BADGE4
# endif
# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
#else
# define machine_is_badge4()	(0)
#endif

#ifdef CONFIG_ARCH_FORTUNET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FORTUNET
# endif
# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
#else
# define machine_is_fortunet()	(0)
#endif

#ifdef CONFIG_ARCH_MX1ADS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX1ADS
# endif
# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
#else
# define machine_is_mx1ads()	(0)
#endif

#ifdef CONFIG_ARCH_H7201
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H7201
# endif
# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
#else
# define machine_is_h7201()	(0)
#endif

#ifdef CONFIG_ARCH_H7202
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H7202
# endif
# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
#else
# define machine_is_h7202()	(0)
#endif

#ifdef CONFIG_ARCH_IQ80321
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IQ80321
# endif
# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
#else
# define machine_is_iq80321()	(0)
#endif

#ifdef CONFIG_ARCH_KS8695
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KS8695
# endif
# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
#else
# define machine_is_ks8695()	(0)
#endif

#ifdef CONFIG_ARCH_SMDK2410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK2410
# endif
# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
#else
# define machine_is_smdk2410()	(0)
#endif

#ifdef CONFIG_ARCH_CEIVA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CEIVA
# endif
# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
#else
# define machine_is_ceiva()	(0)
#endif

#ifdef CONFIG_MACH_VOICEBLUE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VOICEBLUE
# endif
# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
#else
# define machine_is_voiceblue()	(0)
#endif

#ifdef CONFIG_ARCH_H5400
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H5400
# endif
# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
#else
# define machine_is_h5400()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_INNOVATOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
# endif
# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
#else
# define machine_is_omap_innovator()	(0)
#endif

#ifdef CONFIG_ARCH_IXDP2400
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP2400
# endif
# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
#else
# define machine_is_ixdp2400()	(0)
#endif

#ifdef CONFIG_ARCH_IXDP2800
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP2800
# endif
# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
#else
# define machine_is_ixdp2800()	(0)
#endif

#ifdef CONFIG_ARCH_IXDP425
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP425
# endif
# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
#else
# define machine_is_ixdp425()	(0)
#endif

#ifdef CONFIG_SA1100_HACKKIT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HACKKIT
# endif
# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
#else
# define machine_is_hackkit()	(0)
#endif

#ifdef CONFIG_ARCH_IXCDP1100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXCDP1100
# endif
# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
#else
# define machine_is_ixcdp1100()	(0)
#endif

#ifdef CONFIG_ARCH_AT91RM9200DK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
# endif
# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
#else
# define machine_is_at91rm9200dk()	(0)
#endif

#ifdef CONFIG_ARCH_CINTEGRATOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
# endif
# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
#else
# define machine_is_cintegrator()	(0)
#endif

#ifdef CONFIG_ARCH_VIPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIPER
# endif
# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
#else
# define machine_is_viper()	(0)
#endif

#ifdef CONFIG_ARCH_ADI_COYOTE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
# endif
# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
#else
# define machine_is_adi_coyote()	(0)
#endif

#ifdef CONFIG_ARCH_IXDP2401
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP2401
# endif
# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
#else
# define machine_is_ixdp2401()	(0)
#endif

#ifdef CONFIG_ARCH_IXDP2801
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP2801
# endif
# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
#else
# define machine_is_ixdp2801()	(0)
#endif

#ifdef CONFIG_ARCH_IQ31244
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IQ31244
# endif
# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
#else
# define machine_is_iq31244()	(0)
#endif

#ifdef CONFIG_ARCH_BAST
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BAST
# endif
# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
#else
# define machine_is_bast()	(0)
#endif

#ifdef CONFIG_ARCH_H1940
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H1940
# endif
# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
#else
# define machine_is_h1940()	(0)
#endif

#ifdef CONFIG_ARCH_ENP2611
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ENP2611
# endif
# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
#else
# define machine_is_enp2611()	(0)
#endif

#ifdef CONFIG_ARCH_S3C2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_S3C2440
# endif
# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
#else
# define machine_is_s3c2440()	(0)
#endif

#ifdef CONFIG_ARCH_GUMSTIX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GUMSTIX
# endif
# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
#else
# define machine_is_gumstix()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_H2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_H2
# endif
# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
#else
# define machine_is_omap_h2()	(0)
#endif

#ifdef CONFIG_MACH_E740
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_E740
# endif
# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
#else
# define machine_is_e740()	(0)
#endif

#ifdef CONFIG_ARCH_IQ80331
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IQ80331
# endif
# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
#else
# define machine_is_iq80331()	(0)
#endif

#ifdef CONFIG_ARCH_VERSATILE_PB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
# endif
# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
#else
# define machine_is_versatile_pb()	(0)
#endif

#ifdef CONFIG_MACH_KEV7A400
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KEV7A400
# endif
# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
#else
# define machine_is_kev7a400()	(0)
#endif

#ifdef CONFIG_MACH_LPD7A400
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LPD7A400
# endif
# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
#else
# define machine_is_lpd7a400()	(0)
#endif

#ifdef CONFIG_MACH_LPD7A404
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LPD7A404
# endif
# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
#else
# define machine_is_lpd7a404()	(0)
#endif

#ifdef CONFIG_MACH_CSB337
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CSB337
# endif
# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
#else
# define machine_is_csb337()	(0)
#endif

#ifdef CONFIG_MACH_MAINSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAINSTONE
# endif
# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
#else
# define machine_is_mainstone()	(0)
#endif

#ifdef CONFIG_MACH_LITE300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LITE300
# endif
# define machine_is_lite300()	(machine_arch_type == MACH_TYPE_LITE300)
#else
# define machine_is_lite300()	(0)
#endif

#ifdef CONFIG_MACH_XCEP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XCEP
# endif
# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
#else
# define machine_is_xcep()	(0)
#endif

#ifdef CONFIG_MACH_ARCOM_VULCAN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
# endif
# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
#else
# define machine_is_arcom_vulcan()	(0)
#endif

#ifdef CONFIG_MACH_NOMADIK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOMADIK
# endif
# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
#else
# define machine_is_nomadik()	(0)
#endif

#ifdef CONFIG_MACH_CORGI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CORGI
# endif
# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
#else
# define machine_is_corgi()	(0)
#endif

#ifdef CONFIG_MACH_POODLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_POODLE
# endif
# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
#else
# define machine_is_poodle()	(0)
#endif

#ifdef CONFIG_MACH_ARMCORE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMCORE
# endif
# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
#else
# define machine_is_armcore()	(0)
#endif

#ifdef CONFIG_MACH_MX31ADS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX31ADS
# endif
# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
#else
# define machine_is_mx31ads()	(0)
#endif

#ifdef CONFIG_MACH_HIMALAYA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HIMALAYA
# endif
# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
#else
# define machine_is_himalaya()	(0)
#endif

#ifdef CONFIG_MACH_EDB9312
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9312
# endif
# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
#else
# define machine_is_edb9312()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_GENERIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
# endif
# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
#else
# define machine_is_omap_generic()	(0)
#endif

#ifdef CONFIG_MACH_EDB9301
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9301
# endif
# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
#else
# define machine_is_edb9301()	(0)
#endif

#ifdef CONFIG_MACH_EDB9315
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9315
# endif
# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
#else
# define machine_is_edb9315()	(0)
#endif

#ifdef CONFIG_MACH_VR1000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VR1000
# endif
# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
#else
# define machine_is_vr1000()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_PERSEUS2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
# endif
# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
#else
# define machine_is_omap_perseus2()	(0)
#endif

#ifdef CONFIG_MACH_E800
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_E800
# endif
# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
#else
# define machine_is_e800()	(0)
#endif

#ifdef CONFIG_MACH_E750
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_E750
# endif
# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
#else
# define machine_is_e750()	(0)
#endif

#ifdef CONFIG_MACH_SCB9328
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SCB9328
# endif
# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
#else
# define machine_is_scb9328()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_H3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_H3
# endif
# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
#else
# define machine_is_omap_h3()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_H4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_H4
# endif
# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
#else
# define machine_is_omap_h4()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_OSK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_OSK
# endif
# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
#else
# define machine_is_omap_osk()	(0)
#endif

#ifdef CONFIG_MACH_TOSA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TOSA
# endif
# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
#else
# define machine_is_tosa()	(0)
#endif

#ifdef CONFIG_MACH_AVILA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AVILA
# endif
# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
#else
# define machine_is_avila()	(0)
#endif

#ifdef CONFIG_MACH_EDB9302
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9302
# endif
# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
#else
# define machine_is_edb9302()	(0)
#endif

#ifdef CONFIG_MACH_HUSKY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HUSKY
# endif
# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
#else
# define machine_is_husky()	(0)
#endif

#ifdef CONFIG_MACH_SHEPHERD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHEPHERD
# endif
# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
#else
# define machine_is_shepherd()	(0)
#endif

#ifdef CONFIG_MACH_H4700
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H4700
# endif
# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
#else
# define machine_is_h4700()	(0)
#endif

#ifdef CONFIG_MACH_RX3715
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RX3715
# endif
# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
#else
# define machine_is_rx3715()	(0)
#endif

#ifdef CONFIG_MACH_NSLU2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSLU2
# endif
# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
#else
# define machine_is_nslu2()	(0)
#endif

#ifdef CONFIG_MACH_E400
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_E400
# endif
# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
#else
# define machine_is_e400()	(0)
#endif

#ifdef CONFIG_MACH_IXDPG425
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDPG425
# endif
# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
#else
# define machine_is_ixdpg425()	(0)
#endif

#ifdef CONFIG_MACH_VERSATILE_AB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
# endif
# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
#else
# define machine_is_versatile_ab()	(0)
#endif

#ifdef CONFIG_MACH_EDB9307
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9307
# endif
# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
#else
# define machine_is_edb9307()	(0)
#endif

#ifdef CONFIG_MACH_KB9200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KB9200
# endif
# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
#else
# define machine_is_kb9200()	(0)
#endif

#ifdef CONFIG_MACH_SX1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SX1
# endif
# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
#else
# define machine_is_sx1()	(0)
#endif

#ifdef CONFIG_MACH_IXDP465
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP465
# endif
# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
#else
# define machine_is_ixdp465()	(0)
#endif

#ifdef CONFIG_MACH_IXDP2351
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP2351
# endif
# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
#else
# define machine_is_ixdp2351()	(0)
#endif

#ifdef CONFIG_MACH_CM4008
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM4008
# endif
# define machine_is_cm4008()	(machine_arch_type == MACH_TYPE_CM4008)
#else
# define machine_is_cm4008()	(0)
#endif

#ifdef CONFIG_MACH_IQ80332
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IQ80332
# endif
# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
#else
# define machine_is_iq80332()	(0)
#endif

#ifdef CONFIG_MACH_GTWX5715
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GTWX5715
# endif
# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
#else
# define machine_is_gtwx5715()	(0)
#endif

#ifdef CONFIG_MACH_CSB637
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CSB637
# endif
# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
#else
# define machine_is_csb637()	(0)
#endif

#ifdef CONFIG_MACH_N30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_N30
# endif
# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
#else
# define machine_is_n30()	(0)
#endif

#ifdef CONFIG_MACH_NEC_MP900
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NEC_MP900
# endif
# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
#else
# define machine_is_nec_mp900()	(0)
#endif

#ifdef CONFIG_MACH_KAFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KAFA
# endif
# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
#else
# define machine_is_kafa()	(0)
#endif

#ifdef CONFIG_MACH_CM41XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM41XX
# endif
# define machine_is_cm41xx()	(machine_arch_type == MACH_TYPE_CM41XX)
#else
# define machine_is_cm41xx()	(0)
#endif

#ifdef CONFIG_MACH_TS72XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS72XX
# endif
# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
#else
# define machine_is_ts72xx()	(0)
#endif

#ifdef CONFIG_MACH_OTOM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OTOM
# endif
# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
#else
# define machine_is_otom()	(0)
#endif

#ifdef CONFIG_MACH_NEXCODER_2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
# endif
# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
#else
# define machine_is_nexcoder_2440()	(0)
#endif

#ifdef CONFIG_MACH_ECO920
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ECO920
# endif
# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
#else
# define machine_is_eco920()	(0)
#endif

#ifdef CONFIG_MACH_ROADRUNNER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROADRUNNER
# endif
# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
#else
# define machine_is_roadrunner()	(0)
#endif

#ifdef CONFIG_MACH_AT91RM9200EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
# endif
# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
#else
# define machine_is_at91rm9200ek()	(0)
#endif

#ifdef CONFIG_MACH_SPITZ
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPITZ
# endif
# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
#else
# define machine_is_spitz()	(0)
#endif

#ifdef CONFIG_MACH_ADSSPHERE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ADSSPHERE
# endif
# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
#else
# define machine_is_adssphere()	(0)
#endif

#ifdef CONFIG_MACH_COLIBRI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLIBRI
# endif
# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
#else
# define machine_is_colibri()	(0)
#endif

#ifdef CONFIG_MACH_GATEWAY7001
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GATEWAY7001
# endif
# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
#else
# define machine_is_gateway7001()	(0)
#endif

#ifdef CONFIG_MACH_PCM027
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM027
# endif
# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
#else
# define machine_is_pcm027()	(0)
#endif

#ifdef CONFIG_MACH_ANUBIS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANUBIS
# endif
# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
#else
# define machine_is_anubis()	(0)
#endif

#ifdef CONFIG_MACH_XBOARDGP8
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XBOARDGP8
# endif
# define machine_is_xboardgp8()	(machine_arch_type == MACH_TYPE_XBOARDGP8)
#else
# define machine_is_xboardgp8()	(0)
#endif

#ifdef CONFIG_MACH_AKITA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AKITA
# endif
# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
#else
# define machine_is_akita()	(0)
#endif

#ifdef CONFIG_MACH_E330
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_E330
# endif
# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
#else
# define machine_is_e330()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA770
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA770
# endif
# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
#else
# define machine_is_nokia770()	(0)
#endif

#ifdef CONFIG_MACH_CARMEVA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CARMEVA
# endif
# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
#else
# define machine_is_carmeva()	(0)
#endif

#ifdef CONFIG_MACH_EDB9315A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9315A
# endif
# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
#else
# define machine_is_edb9315a()	(0)
#endif

#ifdef CONFIG_MACH_STARGATE2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STARGATE2
# endif
# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
#else
# define machine_is_stargate2()	(0)
#endif

#ifdef CONFIG_MACH_INTELMOTE2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INTELMOTE2
# endif
# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
#else
# define machine_is_intelmote2()	(0)
#endif

#ifdef CONFIG_MACH_TRIZEPS4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TRIZEPS4
# endif
# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
#else
# define machine_is_trizeps4()	(0)
#endif

#ifdef CONFIG_MACH_PNX4008
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PNX4008
# endif
# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
#else
# define machine_is_pnx4008()	(0)
#endif

#ifdef CONFIG_MACH_CPUAT91
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CPUAT91
# endif
# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
#else
# define machine_is_cpuat91()	(0)
#endif

#ifdef CONFIG_MACH_IQ81340SC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IQ81340SC
# endif
# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
#else
# define machine_is_iq81340sc()	(0)
#endif

#ifdef CONFIG_MACH_IQ81340MC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IQ81340MC
# endif
# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
#else
# define machine_is_iq81340mc()	(0)
#endif

#ifdef CONFIG_MACH_SE4200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SE4200
# endif
# define machine_is_se4200()	(machine_arch_type == MACH_TYPE_SE4200)
#else
# define machine_is_se4200()	(0)
#endif

#ifdef CONFIG_MACH_MICRO9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MICRO9
# endif
# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
#else
# define machine_is_micro9()	(0)
#endif

#ifdef CONFIG_MACH_MICRO9L
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MICRO9L
# endif
# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
#else
# define machine_is_micro9l()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_PALMTE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
# endif
# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
#else
# define machine_is_omap_palmte()	(0)
#endif

#ifdef CONFIG_MACH_REALVIEW_EB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
# endif
# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
#else
# define machine_is_realview_eb()	(0)
#endif

#ifdef CONFIG_MACH_BORZOI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BORZOI
# endif
# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
#else
# define machine_is_borzoi()	(0)
#endif

#ifdef CONFIG_MACH_PALMLD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMLD
# endif
# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
#else
# define machine_is_palmld()	(0)
#endif

#ifdef CONFIG_MACH_IXDP28X5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IXDP28X5
# endif
# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
#else
# define machine_is_ixdp28x5()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_PALMTT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
# endif
# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
#else
# define machine_is_omap_palmtt()	(0)
#endif

#ifdef CONFIG_MACH_ARCOM_ZEUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
# endif
# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
#else
# define machine_is_arcom_zeus()	(0)
#endif

#ifdef CONFIG_MACH_OSIRIS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OSIRIS
# endif
# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
#else
# define machine_is_osiris()	(0)
#endif

#ifdef CONFIG_MACH_PALMTE2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMTE2
# endif
# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
#else
# define machine_is_palmte2()	(0)
#endif

#ifdef CONFIG_MACH_MX27ADS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX27ADS
# endif
# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
#else
# define machine_is_mx27ads()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9261EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
# endif
# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
#else
# define machine_is_at91sam9261ek()	(0)
#endif

#ifdef CONFIG_MACH_LOFT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LOFT
# endif
# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
#else
# define machine_is_loft()	(0)
#endif

#ifdef CONFIG_MACH_MX21ADS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX21ADS
# endif
# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
#else
# define machine_is_mx21ads()	(0)
#endif

#ifdef CONFIG_MACH_AMS_DELTA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMS_DELTA
# endif
# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
#else
# define machine_is_ams_delta()	(0)
#endif

#ifdef CONFIG_MACH_NAS100D
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NAS100D
# endif
# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
#else
# define machine_is_nas100d()	(0)
#endif

#ifdef CONFIG_MACH_MAGICIAN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAGICIAN
# endif
# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
#else
# define machine_is_magician()	(0)
#endif

#ifdef CONFIG_MACH_CM4002
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM4002
# endif
# define machine_is_cm4002()	(machine_arch_type == MACH_TYPE_CM4002)
#else
# define machine_is_cm4002()	(0)
#endif

#ifdef CONFIG_MACH_NXDKN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NXDKN
# endif
# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
#else
# define machine_is_nxdkn()	(0)
#endif

#ifdef CONFIG_MACH_PALMTX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMTX
# endif
# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
#else
# define machine_is_palmtx()	(0)
#endif

#ifdef CONFIG_MACH_S3C2413
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_S3C2413
# endif
# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
#else
# define machine_is_s3c2413()	(0)
#endif

#ifdef CONFIG_MACH_WG302V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WG302V2
# endif
# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
#else
# define machine_is_wg302v2()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_2430SDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
# endif
# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
#else
# define machine_is_omap_2430sdp()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
# endif
# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
#else
# define machine_is_davinci_evm()	(0)
#endif

#ifdef CONFIG_MACH_PALMZ72
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMZ72
# endif
# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
#else
# define machine_is_palmz72()	(0)
#endif

#ifdef CONFIG_MACH_NXDB500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NXDB500
# endif
# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
#else
# define machine_is_nxdb500()	(0)
#endif

#ifdef CONFIG_MACH_APF9328
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APF9328
# endif
# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
#else
# define machine_is_apf9328()	(0)
#endif

#ifdef CONFIG_MACH_PALMT5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMT5
# endif
# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
#else
# define machine_is_palmt5()	(0)
#endif

#ifdef CONFIG_MACH_PALMTC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMTC
# endif
# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
#else
# define machine_is_palmtc()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_APOLLON
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
# endif
# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
#else
# define machine_is_omap_apollon()	(0)
#endif

#ifdef CONFIG_MACH_ATEB9200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ATEB9200
# endif
# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
#else
# define machine_is_ateb9200()	(0)
#endif

#ifdef CONFIG_MACH_N35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_N35
# endif
# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
#else
# define machine_is_n35()	(0)
#endif

#ifdef CONFIG_MACH_LOGICPD_PXA270
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
# endif
# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
#else
# define machine_is_logicpd_pxa270()	(0)
#endif

#ifdef CONFIG_MACH_NXEB500HMI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NXEB500HMI
# endif
# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
#else
# define machine_is_nxeb500hmi()	(0)
#endif

#ifdef CONFIG_MACH_ESPRESSO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ESPRESSO
# endif
# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
#else
# define machine_is_espresso()	(0)
#endif

#ifdef CONFIG_MACH_RX1950
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RX1950
# endif
# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
#else
# define machine_is_rx1950()	(0)
#endif

#ifdef CONFIG_MACH_GESBC9312
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GESBC9312
# endif
# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
#else
# define machine_is_gesbc9312()	(0)
#endif

#ifdef CONFIG_MACH_PICOTUX2XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
# endif
# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
#else
# define machine_is_picotux2xx()	(0)
#endif

#ifdef CONFIG_MACH_DSMG600
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DSMG600
# endif
# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
#else
# define machine_is_dsmg600()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_FSAMPLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
# endif
# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
#else
# define machine_is_omap_fsample()	(0)
#endif

#ifdef CONFIG_MACH_SNAPPER_CL15
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
# endif
# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
#else
# define machine_is_snapper_cl15()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_PALMZ71
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
# endif
# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
#else
# define machine_is_omap_palmz71()	(0)
#endif

#ifdef CONFIG_MACH_SMDK2412
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK2412
# endif
# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
#else
# define machine_is_smdk2412()	(0)
#endif

#ifdef CONFIG_MACH_SMDK2413
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK2413
# endif
# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
#else
# define machine_is_smdk2413()	(0)
#endif

#ifdef CONFIG_MACH_AML_M5900
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AML_M5900
# endif
# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
#else
# define machine_is_aml_m5900()	(0)
#endif

#ifdef CONFIG_MACH_BALLOON3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BALLOON3
# endif
# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
#else
# define machine_is_balloon3()	(0)
#endif

#ifdef CONFIG_MACH_ECBAT91
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ECBAT91
# endif
# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
#else
# define machine_is_ecbat91()	(0)
#endif

#ifdef CONFIG_MACH_ONEARM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ONEARM
# endif
# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
#else
# define machine_is_onearm()	(0)
#endif

#ifdef CONFIG_MACH_SMDK2443
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK2443
# endif
# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
#else
# define machine_is_smdk2443()	(0)
#endif

#ifdef CONFIG_MACH_FSG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FSG
# endif
# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
#else
# define machine_is_fsg()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9260EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
# endif
# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
#else
# define machine_is_at91sam9260ek()	(0)
#endif

#ifdef CONFIG_MACH_GLANTANK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GLANTANK
# endif
# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
#else
# define machine_is_glantank()	(0)
#endif

#ifdef CONFIG_MACH_N2100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_N2100
# endif
# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
#else
# define machine_is_n2100()	(0)
#endif

#ifdef CONFIG_MACH_IM42XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IM42XX
# endif
# define machine_is_im42xx()	(machine_arch_type == MACH_TYPE_IM42XX)
#else
# define machine_is_im42xx()	(0)
#endif

#ifdef CONFIG_MACH_QT2410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QT2410
# endif
# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
#else
# define machine_is_qt2410()	(0)
#endif

#ifdef CONFIG_MACH_KIXRP435
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KIXRP435
# endif
# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
#else
# define machine_is_kixrp435()	(0)
#endif

#ifdef CONFIG_MACH_CC9P9360DEV
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
# endif
# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
#else
# define machine_is_cc9p9360dev()	(0)
#endif

#ifdef CONFIG_MACH_EDB9302A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9302A
# endif
# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
#else
# define machine_is_edb9302a()	(0)
#endif

#ifdef CONFIG_MACH_EDB9307A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDB9307A
# endif
# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
#else
# define machine_is_edb9307a()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_3430SDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_3430SDP
# endif
# define machine_is_omap_3430sdp()	(machine_arch_type == MACH_TYPE_OMAP_3430SDP)
#else
# define machine_is_omap_3430sdp()	(0)
#endif

#ifdef CONFIG_MACH_VSTMS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VSTMS
# endif
# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
#else
# define machine_is_vstms()	(0)
#endif

#ifdef CONFIG_MACH_MICRO9M
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MICRO9M
# endif
# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
#else
# define machine_is_micro9m()	(0)
#endif

#ifdef CONFIG_MACH_BUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BUG
# endif
# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
#else
# define machine_is_bug()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9263EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
# endif
# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
#else
# define machine_is_at91sam9263ek()	(0)
#endif

#ifdef CONFIG_MACH_EM7210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EM7210
# endif
# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
#else
# define machine_is_em7210()	(0)
#endif

#ifdef CONFIG_MACH_VPAC270
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPAC270
# endif
# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
#else
# define machine_is_vpac270()	(0)
#endif

#ifdef CONFIG_MACH_TREO680
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TREO680
# endif
# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
#else
# define machine_is_treo680()	(0)
#endif

#ifdef CONFIG_MACH_ZYLONITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZYLONITE
# endif
# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
#else
# define machine_is_zylonite()	(0)
#endif

#ifdef CONFIG_MACH_MX31LITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX31LITE
# endif
# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
#else
# define machine_is_mx31lite()	(0)
#endif

#ifdef CONFIG_MACH_MIOA701
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIOA701
# endif
# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
#else
# define machine_is_mioa701()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO5X0
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
# endif
# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
#else
# define machine_is_armadillo5x0()	(0)
#endif

#ifdef CONFIG_MACH_CC9P9360JS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CC9P9360JS
# endif
# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
#else
# define machine_is_cc9p9360js()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6400
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6400
# endif
# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
#else
# define machine_is_smdk6400()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_N800
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_N800
# endif
# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
#else
# define machine_is_nokia_n800()	(0)
#endif

#ifdef CONFIG_MACH_EP80219
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EP80219
# endif
# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
#else
# define machine_is_ep80219()	(0)
#endif

#ifdef CONFIG_MACH_GORAMO_MLR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
# endif
# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
#else
# define machine_is_goramo_mlr()	(0)
#endif

#ifdef CONFIG_MACH_EM_X270
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EM_X270
# endif
# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
#else
# define machine_is_em_x270()	(0)
#endif

#ifdef CONFIG_MACH_NEO1973_GTA02
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
# endif
# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
#else
# define machine_is_neo1973_gta02()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9RLEK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
# endif
# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
#else
# define machine_is_at91sam9rlek()	(0)
#endif

#ifdef CONFIG_MACH_COLIBRI320
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLIBRI320
# endif
# define machine_is_colibri320()	(machine_arch_type == MACH_TYPE_COLIBRI320)
#else
# define machine_is_colibri320()	(0)
#endif

#ifdef CONFIG_MACH_CAM60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CAM60
# endif
# define machine_is_cam60()	(machine_arch_type == MACH_TYPE_CAM60)
#else
# define machine_is_cam60()	(0)
#endif

#ifdef CONFIG_MACH_AT91EB01
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91EB01
# endif
# define machine_is_at91eb01()	(machine_arch_type == MACH_TYPE_AT91EB01)
#else
# define machine_is_at91eb01()	(0)
#endif

#ifdef CONFIG_MACH_DB88F5281
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DB88F5281
# endif
# define machine_is_db88f5281()	(machine_arch_type == MACH_TYPE_DB88F5281)
#else
# define machine_is_db88f5281()	(0)
#endif

#ifdef CONFIG_MACH_CSB726
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CSB726
# endif
# define machine_is_csb726()	(machine_arch_type == MACH_TYPE_CSB726)
#else
# define machine_is_csb726()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DM6467_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467_EVM
# endif
# define machine_is_davinci_dm6467_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467_EVM)
#else
# define machine_is_davinci_dm6467_evm()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
# endif
# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
#else
# define machine_is_davinci_dm355_evm()	(0)
#endif

#ifdef CONFIG_MACH_LITTLETON
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LITTLETON
# endif
# define machine_is_littleton()	(machine_arch_type == MACH_TYPE_LITTLETON)
#else
# define machine_is_littleton()	(0)
#endif

#ifdef CONFIG_MACH_IM4004
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IM4004
# endif
# define machine_is_im4004()	(machine_arch_type == MACH_TYPE_IM4004)
#else
# define machine_is_im4004()	(0)
#endif

#ifdef CONFIG_MACH_REALVIEW_PB11MP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REALVIEW_PB11MP
# endif
# define machine_is_realview_pb11mp()	(machine_arch_type == MACH_TYPE_REALVIEW_PB11MP)
#else
# define machine_is_realview_pb11mp()	(0)
#endif

#ifdef CONFIG_MACH_MX27_3DS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX27_3DS
# endif
# define machine_is_mx27_3ds()	(machine_arch_type == MACH_TYPE_MX27_3DS)
#else
# define machine_is_mx27_3ds()	(0)
#endif

#ifdef CONFIG_MACH_HALIBUT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HALIBUT
# endif
# define machine_is_halibut()	(machine_arch_type == MACH_TYPE_HALIBUT)
#else
# define machine_is_halibut()	(0)
#endif

#ifdef CONFIG_MACH_TROUT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TROUT
# endif
# define machine_is_trout()	(machine_arch_type == MACH_TYPE_TROUT)
#else
# define machine_is_trout()	(0)
#endif

#ifdef CONFIG_MACH_TCT_HAMMER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TCT_HAMMER
# endif
# define machine_is_tct_hammer()	(machine_arch_type == MACH_TYPE_TCT_HAMMER)
#else
# define machine_is_tct_hammer()	(0)
#endif

#ifdef CONFIG_MACH_HERALD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HERALD
# endif
# define machine_is_herald()	(machine_arch_type == MACH_TYPE_HERALD)
#else
# define machine_is_herald()	(0)
#endif

#ifdef CONFIG_MACH_SIM_ONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SIM_ONE
# endif
# define machine_is_sim_one()	(machine_arch_type == MACH_TYPE_SIM_ONE)
#else
# define machine_is_sim_one()	(0)
#endif

#ifdef CONFIG_MACH_JIVE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_JIVE
# endif
# define machine_is_jive()	(machine_arch_type == MACH_TYPE_JIVE)
#else
# define machine_is_jive()	(0)
#endif

#ifdef CONFIG_MACH_SAM9_L9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAM9_L9260
# endif
# define machine_is_sam9_l9260()	(machine_arch_type == MACH_TYPE_SAM9_L9260)
#else
# define machine_is_sam9_l9260()	(0)
#endif

#ifdef CONFIG_MACH_REALVIEW_PB1176
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REALVIEW_PB1176
# endif
# define machine_is_realview_pb1176()	(machine_arch_type == MACH_TYPE_REALVIEW_PB1176)
#else
# define machine_is_realview_pb1176()	(0)
#endif

#ifdef CONFIG_MACH_YL9200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YL9200
# endif
# define machine_is_yl9200()	(machine_arch_type == MACH_TYPE_YL9200)
#else
# define machine_is_yl9200()	(0)
#endif

#ifdef CONFIG_MACH_RD88F5182
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F5182
# endif
# define machine_is_rd88f5182()	(machine_arch_type == MACH_TYPE_RD88F5182)
#else
# define machine_is_rd88f5182()	(0)
#endif

#ifdef CONFIG_MACH_KUROBOX_PRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KUROBOX_PRO
# endif
# define machine_is_kurobox_pro()	(machine_arch_type == MACH_TYPE_KUROBOX_PRO)
#else
# define machine_is_kurobox_pro()	(0)
#endif

#ifdef CONFIG_MACH_MX31_3DS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX31_3DS
# endif
# define machine_is_mx31_3ds()	(machine_arch_type == MACH_TYPE_MX31_3DS)
#else
# define machine_is_mx31_3ds()	(0)
#endif

#ifdef CONFIG_MACH_QONG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QONG
# endif
# define machine_is_qong()	(machine_arch_type == MACH_TYPE_QONG)
#else
# define machine_is_qong()	(0)
#endif

#ifdef CONFIG_MACH_OMAP2EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP2EVM
# endif
# define machine_is_omap2evm()	(machine_arch_type == MACH_TYPE_OMAP2EVM)
#else
# define machine_is_omap2evm()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3EVM
# endif
# define machine_is_omap3evm()	(machine_arch_type == MACH_TYPE_OMAP3EVM)
#else
# define machine_is_omap3evm()	(0)
#endif

#ifdef CONFIG_MACH_DNS323
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DNS323
# endif
# define machine_is_dns323()	(machine_arch_type == MACH_TYPE_DNS323)
#else
# define machine_is_dns323()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_BEAGLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_BEAGLE
# endif
# define machine_is_omap3_beagle()	(machine_arch_type == MACH_TYPE_OMAP3_BEAGLE)
#else
# define machine_is_omap3_beagle()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_N810
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_N810
# endif
# define machine_is_nokia_n810()	(machine_arch_type == MACH_TYPE_NOKIA_N810)
#else
# define machine_is_nokia_n810()	(0)
#endif

#ifdef CONFIG_MACH_PCM038
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM038
# endif
# define machine_is_pcm038()	(machine_arch_type == MACH_TYPE_PCM038)
#else
# define machine_is_pcm038()	(0)
#endif

#ifdef CONFIG_MACH_SG310
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SG310
# endif
# define machine_is_sg310()	(machine_arch_type == MACH_TYPE_SG310)
#else
# define machine_is_sg310()	(0)
#endif

#ifdef CONFIG_MACH_TS209
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS209
# endif
# define machine_is_ts209()	(machine_arch_type == MACH_TYPE_TS209)
#else
# define machine_is_ts209()	(0)
#endif

#ifdef CONFIG_MACH_AT91CAP9ADK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91CAP9ADK
# endif
# define machine_is_at91cap9adk()	(machine_arch_type == MACH_TYPE_AT91CAP9ADK)
#else
# define machine_is_at91cap9adk()	(0)
#endif

#ifdef CONFIG_MACH_MX31MOBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX31MOBOARD
# endif
# define machine_is_mx31moboard()	(machine_arch_type == MACH_TYPE_MX31MOBOARD)
#else
# define machine_is_mx31moboard()	(0)
#endif

#ifdef CONFIG_MACH_VISION_EP9307
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VISION_EP9307
# endif
# define machine_is_vision_ep9307()	(machine_arch_type == MACH_TYPE_VISION_EP9307)
#else
# define machine_is_vision_ep9307()	(0)
#endif

#ifdef CONFIG_MACH_TERASTATION_PRO2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TERASTATION_PRO2
# endif
# define machine_is_terastation_pro2()	(machine_arch_type == MACH_TYPE_TERASTATION_PRO2)
#else
# define machine_is_terastation_pro2()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_PRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRO
# endif
# define machine_is_linkstation_pro()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRO)
#else
# define machine_is_linkstation_pro()	(0)
#endif

#ifdef CONFIG_MACH_E350
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_E350
# endif
# define machine_is_e350()	(machine_arch_type == MACH_TYPE_E350)
#else
# define machine_is_e350()	(0)
#endif

#ifdef CONFIG_MACH_TS409
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS409
# endif
# define machine_is_ts409()	(machine_arch_type == MACH_TYPE_TS409)
#else
# define machine_is_ts409()	(0)
#endif

#ifdef CONFIG_MACH_RSI_EWS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RSI_EWS
# endif
# define machine_is_rsi_ews()	(machine_arch_type == MACH_TYPE_RSI_EWS)
#else
# define machine_is_rsi_ews()	(0)
#endif

#ifdef CONFIG_MACH_CM_X300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_X300
# endif
# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
#else
# define machine_is_cm_x300()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G20EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
# endif
# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
#else
# define machine_is_at91sam9g20ek()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6410
# endif
# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
#else
# define machine_is_smdk6410()	(0)
#endif

#ifdef CONFIG_MACH_U300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U300
# endif
# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
#else
# define machine_is_u300()	(0)
#endif

#ifdef CONFIG_MACH_WRT350N_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WRT350N_V2
# endif
# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
#else
# define machine_is_wrt350n_v2()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_LDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_LDP
# endif
# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
#else
# define machine_is_omap_ldp()	(0)
#endif

#ifdef CONFIG_MACH_MX35_3DS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX35_3DS
# endif
# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
#else
# define machine_is_mx35_3ds()	(0)
#endif

#ifdef CONFIG_MACH_NEUROS_OSD2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
# endif
# define machine_is_neuros_osd2()	(machine_arch_type == MACH_TYPE_NEUROS_OSD2)
#else
# define machine_is_neuros_osd2()	(0)
#endif

#ifdef CONFIG_MACH_TRIZEPS4WL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
# endif
# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
#else
# define machine_is_trizeps4wl()	(0)
#endif

#ifdef CONFIG_MACH_TS78XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS78XX
# endif
# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
#else
# define machine_is_ts78xx()	(0)
#endif

#ifdef CONFIG_MACH_SFFSDR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SFFSDR
# endif
# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
#else
# define machine_is_sffsdr()	(0)
#endif

#ifdef CONFIG_MACH_PCM037
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM037
# endif
# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
#else
# define machine_is_pcm037()	(0)
#endif

#ifdef CONFIG_MACH_DB88F6281_BP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
# endif
# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
#else
# define machine_is_db88f6281_bp()	(0)
#endif

#ifdef CONFIG_MACH_RD88F6192_NAS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
# endif
# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
#else
# define machine_is_rd88f6192_nas()	(0)
#endif

#ifdef CONFIG_MACH_RD88F6281
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F6281
# endif
# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
#else
# define machine_is_rd88f6281()	(0)
#endif

#ifdef CONFIG_MACH_DB78X00_BP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DB78X00_BP
# endif
# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
#else
# define machine_is_db78x00_bp()	(0)
#endif

#ifdef CONFIG_MACH_SMDK2416
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK2416
# endif
# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
#else
# define machine_is_smdk2416()	(0)
#endif

#ifdef CONFIG_MACH_WBD111
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WBD111
# endif
# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
#else
# define machine_is_wbd111()	(0)
#endif

#ifdef CONFIG_MACH_MV2120
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MV2120
# endif
# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
#else
# define machine_is_mv2120()	(0)
#endif

#ifdef CONFIG_MACH_MX51_3DS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_3DS
# endif
# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
#else
# define machine_is_mx51_3ds()	(0)
#endif

#ifdef CONFIG_MACH_IMX27LITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMX27LITE
# endif
# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
#else
# define machine_is_imx27lite()	(0)
#endif

#ifdef CONFIG_MACH_USB_A9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_USB_A9260
# endif
# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
#else
# define machine_is_usb_a9260()	(0)
#endif

#ifdef CONFIG_MACH_USB_A9263
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_USB_A9263
# endif
# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
#else
# define machine_is_usb_a9263()	(0)
#endif

#ifdef CONFIG_MACH_QIL_A9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QIL_A9260
# endif
# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
#else
# define machine_is_qil_a9260()	(0)
#endif

#ifdef CONFIG_MACH_KZM_ARM11_01
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
# endif
# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
#else
# define machine_is_kzm_arm11_01()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
# endif
# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
#else
# define machine_is_nokia_n810_wimax()	(0)
#endif

#ifdef CONFIG_MACH_SAPPHIRE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAPPHIRE
# endif
# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
#else
# define machine_is_sapphire()	(0)
#endif

#ifdef CONFIG_MACH_STMP37XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STMP37XX
# endif
# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
#else
# define machine_is_stmp37xx()	(0)
#endif

#ifdef CONFIG_MACH_STMP378X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STMP378X
# endif
# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
#else
# define machine_is_stmp378x()	(0)
#endif

#ifdef CONFIG_MACH_EZX_A780
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZX_A780
# endif
# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
#else
# define machine_is_ezx_a780()	(0)
#endif

#ifdef CONFIG_MACH_EZX_E680
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZX_E680
# endif
# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
#else
# define machine_is_ezx_e680()	(0)
#endif

#ifdef CONFIG_MACH_EZX_A1200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZX_A1200
# endif
# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
#else
# define machine_is_ezx_a1200()	(0)
#endif

#ifdef CONFIG_MACH_EZX_E6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZX_E6
# endif
# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
#else
# define machine_is_ezx_e6()	(0)
#endif

#ifdef CONFIG_MACH_EZX_E2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZX_E2
# endif
# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
#else
# define machine_is_ezx_e2()	(0)
#endif

#ifdef CONFIG_MACH_EZX_A910
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZX_A910
# endif
# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
#else
# define machine_is_ezx_a910()	(0)
#endif

#ifdef CONFIG_MACH_EDMINI_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDMINI_V2
# endif
# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
#else
# define machine_is_edmini_v2()	(0)
#endif

#ifdef CONFIG_MACH_ZIPIT2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZIPIT2
# endif
# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
#else
# define machine_is_zipit2()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_PANDORA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
# endif
# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
#else
# define machine_is_omap3_pandora()	(0)
#endif

#ifdef CONFIG_MACH_MSS2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSS2
# endif
# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
#else
# define machine_is_mss2()	(0)
#endif

#ifdef CONFIG_MACH_LB88RC8480
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LB88RC8480
# endif
# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
#else
# define machine_is_lb88rc8480()	(0)
#endif

#ifdef CONFIG_MACH_MX25_3DS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX25_3DS
# endif
# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
#else
# define machine_is_mx25_3ds()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3530_LV_SOM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
# endif
# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
#else
# define machine_is_omap3530_lv_som()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DA830_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DA830_EVM
# endif
# define machine_is_davinci_da830_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA830_EVM)
#else
# define machine_is_davinci_da830_evm()	(0)
#endif

#ifdef CONFIG_MACH_DOVE_DB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOVE_DB
# endif
# define machine_is_dove_db()	(machine_arch_type == MACH_TYPE_DOVE_DB)
#else
# define machine_is_dove_db()	(0)
#endif

#ifdef CONFIG_MACH_OVERO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OVERO
# endif
# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
#else
# define machine_is_overo()	(0)
#endif

#ifdef CONFIG_MACH_AT2440EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT2440EVB
# endif
# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
#else
# define machine_is_at2440evb()	(0)
#endif

#ifdef CONFIG_MACH_NEOCORE926
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NEOCORE926
# endif
# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
#else
# define machine_is_neocore926()	(0)
#endif

#ifdef CONFIG_MACH_WNR854T
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WNR854T
# endif
# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
#else
# define machine_is_wnr854t()	(0)
#endif

#ifdef CONFIG_MACH_RD88F5181L_GE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
# endif
# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
#else
# define machine_is_rd88f5181l_ge()	(0)
#endif

#ifdef CONFIG_MACH_RD88F5181L_FXO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
# endif
# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
#else
# define machine_is_rd88f5181l_fxo()	(0)
#endif

#ifdef CONFIG_MACH_STAMP9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STAMP9G20
# endif
# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
#else
# define machine_is_stamp9g20()	(0)
#endif

#ifdef CONFIG_MACH_SMDKC100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKC100
# endif
# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
#else
# define machine_is_smdkc100()	(0)
#endif

#ifdef CONFIG_MACH_TAVOREVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAVOREVB
# endif
# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
#else
# define machine_is_tavorevb()	(0)
#endif

#ifdef CONFIG_MACH_SAAR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAAR
# endif
# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
#else
# define machine_is_saar()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9M10G45EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
# endif
# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
#else
# define machine_is_at91sam9m10g45ek()	(0)
#endif

#ifdef CONFIG_MACH_USB_A9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_USB_A9G20
# endif
# define machine_is_usb_a9g20()	(machine_arch_type == MACH_TYPE_USB_A9G20)
#else
# define machine_is_usb_a9g20()	(0)
#endif

#ifdef CONFIG_MACH_MXLADS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MXLADS
# endif
# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
#else
# define machine_is_mxlads()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_MINI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
# endif
# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
#else
# define machine_is_linkstation_mini()	(0)
#endif

#ifdef CONFIG_MACH_AFEB9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AFEB9260
# endif
# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
#else
# define machine_is_afeb9260()	(0)
#endif

#ifdef CONFIG_MACH_IMX27IPCAM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
# endif
# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
#else
# define machine_is_imx27ipcam()	(0)
#endif

#ifdef CONFIG_MACH_RD88F6183AP_GE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
# endif
# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
#else
# define machine_is_rd88f6183ap_ge()	(0)
#endif

#ifdef CONFIG_MACH_REALVIEW_PBA8
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
# endif
# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
#else
# define machine_is_realview_pba8()	(0)
#endif

#ifdef CONFIG_MACH_REALVIEW_PBX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
# endif
# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
#else
# define machine_is_realview_pbx()	(0)
#endif

#ifdef CONFIG_MACH_MICRO9S
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MICRO9S
# endif
# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
#else
# define machine_is_micro9s()	(0)
#endif

#ifdef CONFIG_MACH_RUT100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RUT100
# endif
# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
#else
# define machine_is_rut100()	(0)
#endif

#ifdef CONFIG_MACH_G3EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_G3EVM
# endif
# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
#else
# define machine_is_g3evm()	(0)
#endif

#ifdef CONFIG_MACH_W90P910EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_W90P910EVB
# endif
# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
#else
# define machine_is_w90p910evb()	(0)
#endif

#ifdef CONFIG_MACH_W90P950EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_W90P950EVB
# endif
# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
#else
# define machine_is_w90p950evb()	(0)
#endif

#ifdef CONFIG_MACH_W90N960EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_W90N960EVB
# endif
# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
#else
# define machine_is_w90n960evb()	(0)
#endif

#ifdef CONFIG_MACH_MV88F6281GTW_GE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
# endif
# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
#else
# define machine_is_mv88f6281gtw_ge()	(0)
#endif

#ifdef CONFIG_MACH_NCP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NCP
# endif
# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
#else
# define machine_is_ncp()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
# endif
# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
#else
# define machine_is_davinci_dm365_evm()	(0)
#endif

#ifdef CONFIG_MACH_CENTRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CENTRO
# endif
# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
#else
# define machine_is_centro()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_RX51
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
# endif
# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
#else
# define machine_is_nokia_rx51()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_ZOOM2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
# endif
# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
#else
# define machine_is_omap_zoom2()	(0)
#endif

#ifdef CONFIG_MACH_CPUAT9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CPUAT9260
# endif
# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
#else
# define machine_is_cpuat9260()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX27
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX27
# endif
# define machine_is_eukrea_cpuimx27()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX27)
#else
# define machine_is_eukrea_cpuimx27()	(0)
#endif

#ifdef CONFIG_MACH_ACS5K
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACS5K
# endif
# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
#else
# define machine_is_acs5k()	(0)
#endif

#ifdef CONFIG_MACH_SNAPPER_9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
# endif
# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
#else
# define machine_is_snapper_9260()	(0)
#endif

#ifdef CONFIG_MACH_DSM320
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DSM320
# endif
# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
#else
# define machine_is_dsm320()	(0)
#endif

#ifdef CONFIG_MACH_EXEDA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EXEDA
# endif
# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
#else
# define machine_is_exeda()	(0)
#endif

#ifdef CONFIG_MACH_MINI2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINI2440
# endif
# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
#else
# define machine_is_mini2440()	(0)
#endif

#ifdef CONFIG_MACH_COLIBRI300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLIBRI300
# endif
# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
#else
# define machine_is_colibri300()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
# endif
# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
#else
# define machine_is_linkstation_ls_hgl()	(0)
#endif

#ifdef CONFIG_MACH_CPUAT9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CPUAT9G20
# endif
# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
#else
# define machine_is_cpuat9g20()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6440
# endif
# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
#else
# define machine_is_smdk6440()	(0)
#endif

#ifdef CONFIG_MACH_NAS4220B
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NAS4220B
# endif
# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
#else
# define machine_is_nas4220b()	(0)
#endif

#ifdef CONFIG_MACH_ZYLONITE2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZYLONITE2
# endif
# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
#else
# define machine_is_zylonite2()	(0)
#endif

#ifdef CONFIG_MACH_ASPENITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ASPENITE
# endif
# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
#else
# define machine_is_aspenite()	(0)
#endif

#ifdef CONFIG_MACH_TTC_DKB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TTC_DKB
# endif
# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
#else
# define machine_is_ttc_dkb()	(0)
#endif

#ifdef CONFIG_MACH_PCM043
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM043
# endif
# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
#else
# define machine_is_pcm043()	(0)
#endif

#ifdef CONFIG_MACH_SHEEVAPLUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
# endif
# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
#else
# define machine_is_sheevaplug()	(0)
#endif

#ifdef CONFIG_MACH_AVENGERS_LITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
# endif
# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
#else
# define machine_is_avengers_lite()	(0)
#endif

#ifdef CONFIG_MACH_MX51_BABBAGE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
# endif
# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
#else
# define machine_is_mx51_babbage()	(0)
#endif

#ifdef CONFIG_MACH_RD78X00_MASA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
# endif
# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
#else
# define machine_is_rd78x00_masa()	(0)
#endif

#ifdef CONFIG_MACH_DM355_LEOPARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
# endif
# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
#else
# define machine_is_dm355_leopard()	(0)
#endif

#ifdef CONFIG_MACH_TS219
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS219
# endif
# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
#else
# define machine_is_ts219()	(0)
#endif

#ifdef CONFIG_MACH_PCA100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCA100
# endif
# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
#else
# define machine_is_pca100()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
# endif
# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
#else
# define machine_is_davinci_da850_evm()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G10EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
# endif
# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
#else
# define machine_is_at91sam9g10ek()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_4430SDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
# endif
# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
#else
# define machine_is_omap_4430sdp()	(0)
#endif

#ifdef CONFIG_MACH_MAGX_ZN5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
# endif
# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
#else
# define machine_is_magx_zn5()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_TORPEDO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
# endif
# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
#else
# define machine_is_omap3_torpedo()	(0)
#endif

#ifdef CONFIG_MACH_ANW6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANW6410
# endif
# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
#else
# define machine_is_anw6410()	(0)
#endif

#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
# endif
# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
#else
# define machine_is_imx27_visstrim_m10()	(0)
#endif

#ifdef CONFIG_MACH_PORTUXG20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PORTUXG20
# endif
# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
#else
# define machine_is_portuxg20()	(0)
#endif

#ifdef CONFIG_MACH_SMDKC110
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKC110
# endif
# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
#else
# define machine_is_smdkc110()	(0)
#endif

#ifdef CONFIG_MACH_CABESPRESSO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CABESPRESSO
# endif
# define machine_is_cabespresso()	(machine_arch_type == MACH_TYPE_CABESPRESSO)
#else
# define machine_is_cabespresso()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3517EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
# endif
# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
#else
# define machine_is_omap3517evm()	(0)
#endif

#ifdef CONFIG_MACH_NETSPACE_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
# endif
# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
#else
# define machine_is_netspace_v2()	(0)
#endif

#ifdef CONFIG_MACH_NETSPACE_MAX_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
# endif
# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
#else
# define machine_is_netspace_max_v2()	(0)
#endif

#ifdef CONFIG_MACH_D2NET_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_D2NET_V2
# endif
# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
#else
# define machine_is_d2net_v2()	(0)
#endif

#ifdef CONFIG_MACH_NET2BIG_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
# endif
# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
#else
# define machine_is_net2big_v2()	(0)
#endif

#ifdef CONFIG_MACH_NET5BIG_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
# endif
# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
#else
# define machine_is_net5big_v2()	(0)
#endif

#ifdef CONFIG_MACH_INETSPACE_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
# endif
# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
#else
# define machine_is_inetspace_v2()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G45EKES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
# endif
# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
#else
# define machine_is_at91sam9g45ekes()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR600
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR600
# endif
# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
#else
# define machine_is_spear600()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR300
# endif
# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
#else
# define machine_is_spear300()	(0)
#endif

#ifdef CONFIG_MACH_LILLY1131
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LILLY1131
# endif
# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
#else
# define machine_is_lilly1131()	(0)
#endif

#ifdef CONFIG_MACH_HMT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HMT
# endif
# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
#else
# define machine_is_hmt()	(0)
#endif

#ifdef CONFIG_MACH_VEXPRESS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VEXPRESS
# endif
# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
#else
# define machine_is_vexpress()	(0)
#endif

#ifdef CONFIG_MACH_D2NET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_D2NET
# endif
# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
#else
# define machine_is_d2net()	(0)
#endif

#ifdef CONFIG_MACH_BIGDISK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BIGDISK
# endif
# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
#else
# define machine_is_bigdisk()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
# endif
# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
#else
# define machine_is_at91sam9g20ek_2mmc()	(0)
#endif

#ifdef CONFIG_MACH_BCMRING
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCMRING
# endif
# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
#else
# define machine_is_bcmring()	(0)
#endif

#ifdef CONFIG_MACH_MAHIMAHI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAHIMAHI
# endif
# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
#else
# define machine_is_mahimahi()	(0)
#endif

#ifdef CONFIG_MACH_CEREBRIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CEREBRIC
# endif
# define machine_is_cerebric()	(machine_arch_type == MACH_TYPE_CEREBRIC)
#else
# define machine_is_cerebric()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6442
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6442
# endif
# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
#else
# define machine_is_smdk6442()	(0)
#endif

#ifdef CONFIG_MACH_OPENRD_BASE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
# endif
# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
#else
# define machine_is_openrd_base()	(0)
#endif

#ifdef CONFIG_MACH_DEVKIT8000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DEVKIT8000
# endif
# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
#else
# define machine_is_devkit8000()	(0)
#endif

#ifdef CONFIG_MACH_MX51_EFIKAMX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_EFIKAMX
# endif
# define machine_is_mx51_efikamx()	(machine_arch_type == MACH_TYPE_MX51_EFIKAMX)
#else
# define machine_is_mx51_efikamx()	(0)
#endif

#ifdef CONFIG_MACH_CM_T35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_T35
# endif
# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
#else
# define machine_is_cm_t35()	(0)
#endif

#ifdef CONFIG_MACH_NET2BIG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NET2BIG
# endif
# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
#else
# define machine_is_net2big()	(0)
#endif

#ifdef CONFIG_MACH_IGEP0020
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGEP0020
# endif
# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
#else
# define machine_is_igep0020()	(0)
#endif

#ifdef CONFIG_MACH_NUC932EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NUC932EVB
# endif
# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
#else
# define machine_is_nuc932evb()	(0)
#endif

#ifdef CONFIG_MACH_OPENRD_CLIENT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
# endif
# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
#else
# define machine_is_openrd_client()	(0)
#endif

#ifdef CONFIG_MACH_U8500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U8500
# endif
# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
#else
# define machine_is_u8500()	(0)
#endif

#ifdef CONFIG_MACH_MX51_EFIKASB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_EFIKASB
# endif
# define machine_is_mx51_efikasb()	(machine_arch_type == MACH_TYPE_MX51_EFIKASB)
#else
# define machine_is_mx51_efikasb()	(0)
#endif

#ifdef CONFIG_MACH_MARVELL_JASPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
# endif
# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
#else
# define machine_is_marvell_jasper()	(0)
#endif

#ifdef CONFIG_MACH_FLINT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLINT
# endif
# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
#else
# define machine_is_flint()	(0)
#endif

#ifdef CONFIG_MACH_TAVOREVB3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAVOREVB3
# endif
# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
#else
# define machine_is_tavorevb3()	(0)
#endif

#ifdef CONFIG_MACH_TOUCHBOOK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
# endif
# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
#else
# define machine_is_touchbook()	(0)
#endif

#ifdef CONFIG_MACH_RAUMFELD_RC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
# endif
# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
#else
# define machine_is_raumfeld_rc()	(0)
#endif

#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
# endif
# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
#else
# define machine_is_raumfeld_connector()	(0)
#endif

#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
# endif
# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
#else
# define machine_is_raumfeld_speaker()	(0)
#endif

#ifdef CONFIG_MACH_TNETV107X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TNETV107X
# endif
# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
#else
# define machine_is_tnetv107x()	(0)
#endif

#ifdef CONFIG_MACH_SMDKV210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKV210
# endif
# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
#else
# define machine_is_smdkv210()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_ZOOM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
# endif
# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
#else
# define machine_is_omap_zoom3()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_3630SDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
# endif
# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
#else
# define machine_is_omap_3630sdp()	(0)
#endif

#ifdef CONFIG_MACH_CYBOOK2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CYBOOK2440
# endif
# define machine_is_cybook2440()	(machine_arch_type == MACH_TYPE_CYBOOK2440)
#else
# define machine_is_cybook2440()	(0)
#endif

#ifdef CONFIG_MACH_SMARTQ7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMARTQ7
# endif
# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
#else
# define machine_is_smartq7()	(0)
#endif

#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
# endif
# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
#else
# define machine_is_watson_efm_plugin()	(0)
#endif

#ifdef CONFIG_MACH_G4EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_G4EVM
# endif
# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
#else
# define machine_is_g4evm()	(0)
#endif

#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
# endif
# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
#else
# define machine_is_omapl138_hawkboard()	(0)
#endif

#ifdef CONFIG_MACH_TS41X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS41X
# endif
# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
#else
# define machine_is_ts41x()	(0)
#endif

#ifdef CONFIG_MACH_PHY3250
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PHY3250
# endif
# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
#else
# define machine_is_phy3250()	(0)
#endif

#ifdef CONFIG_MACH_MINI6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINI6410
# endif
# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
#else
# define machine_is_mini6410()	(0)
#endif

#ifdef CONFIG_MACH_MX28EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX28EVK
# endif
# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
#else
# define machine_is_mx28evk()	(0)
#endif

#ifdef CONFIG_MACH_SMARTQ5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMARTQ5
# endif
# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
#else
# define machine_is_smartq5()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
# endif
# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
#else
# define machine_is_davinci_dm6467tevm()	(0)
#endif

#ifdef CONFIG_MACH_MXT_TD60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MXT_TD60
# endif
# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
#else
# define machine_is_mxt_td60()	(0)
#endif

#ifdef CONFIG_MACH_CAPC7117
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CAPC7117
# endif
# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
#else
# define machine_is_capc7117()	(0)
#endif

#ifdef CONFIG_MACH_ICONTROL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ICONTROL
# endif
# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
#else
# define machine_is_icontrol()	(0)
#endif

#ifdef CONFIG_MACH_GPLUGD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GPLUGD
# endif
# define machine_is_gplugd()	(machine_arch_type == MACH_TYPE_GPLUGD)
#else
# define machine_is_gplugd()	(0)
#endif

#ifdef CONFIG_MACH_QSD8X50A_ST1_5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
# endif
# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
#else
# define machine_is_qsd8x50a_st1_5()	(0)
#endif

#ifdef CONFIG_MACH_MX23EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX23EVK
# endif
# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
#else
# define machine_is_mx23evk()	(0)
#endif

#ifdef CONFIG_MACH_AP4EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AP4EVB
# endif
# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
#else
# define machine_is_ap4evb()	(0)
#endif

#ifdef CONFIG_MACH_MITYOMAPL138
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
# endif
# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
#else
# define machine_is_mityomapl138()	(0)
#endif

#ifdef CONFIG_MACH_GURUPLUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GURUPLUG
# endif
# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
#else
# define machine_is_guruplug()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR310
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR310
# endif
# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
#else
# define machine_is_spear310()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR320
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR320
# endif
# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
#else
# define machine_is_spear320()	(0)
#endif

#ifdef CONFIG_MACH_AQUILA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AQUILA
# endif
# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
#else
# define machine_is_aquila()	(0)
#endif

#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
# endif
# define machine_is_esata_sheevaplug()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
#else
# define machine_is_esata_sheevaplug()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X30_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X30_SURF
# endif
# define machine_is_msm7x30_surf()	(machine_arch_type == MACH_TYPE_MSM7X30_SURF)
#else
# define machine_is_msm7x30_surf()	(0)
#endif

#ifdef CONFIG_MACH_TERASTATION_WXL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TERASTATION_WXL
# endif
# define machine_is_terastation_wxl()	(machine_arch_type == MACH_TYPE_TERASTATION_WXL)
#else
# define machine_is_terastation_wxl()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X25_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X25_SURF
# endif
# define machine_is_msm7x25_surf()	(machine_arch_type == MACH_TYPE_MSM7X25_SURF)
#else
# define machine_is_msm7x25_surf()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X25_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X25_FFA
# endif
# define machine_is_msm7x25_ffa()	(machine_arch_type == MACH_TYPE_MSM7X25_FFA)
#else
# define machine_is_msm7x25_ffa()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X27_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X27_SURF
# endif
# define machine_is_msm7x27_surf()	(machine_arch_type == MACH_TYPE_MSM7X27_SURF)
#else
# define machine_is_msm7x27_surf()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X27_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X27_FFA
# endif
# define machine_is_msm7x27_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27_FFA)
#else
# define machine_is_msm7x27_ffa()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X30_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X30_FFA
# endif
# define machine_is_msm7x30_ffa()	(machine_arch_type == MACH_TYPE_MSM7X30_FFA)
#else
# define machine_is_msm7x30_ffa()	(0)
#endif

#ifdef CONFIG_MACH_QSD8X50_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSD8X50_SURF
# endif
# define machine_is_qsd8x50_surf()	(machine_arch_type == MACH_TYPE_QSD8X50_SURF)
#else
# define machine_is_qsd8x50_surf()	(0)
#endif

#ifdef CONFIG_MACH_MX53_EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_EVK
# endif
# define machine_is_mx53_evk()	(machine_arch_type == MACH_TYPE_MX53_EVK)
#else
# define machine_is_mx53_evk()	(0)
#endif

#ifdef CONFIG_MACH_IGEP0030
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGEP0030
# endif
# define machine_is_igep0030()	(machine_arch_type == MACH_TYPE_IGEP0030)
#else
# define machine_is_igep0030()	(0)
#endif

#ifdef CONFIG_MACH_SBC3530
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SBC3530
# endif
# define machine_is_sbc3530()	(machine_arch_type == MACH_TYPE_SBC3530)
#else
# define machine_is_sbc3530()	(0)
#endif

#ifdef CONFIG_MACH_SAARB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAARB
# endif
# define machine_is_saarb()	(machine_arch_type == MACH_TYPE_SAARB)
#else
# define machine_is_saarb()	(0)
#endif

#ifdef CONFIG_MACH_HARMONY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HARMONY
# endif
# define machine_is_harmony()	(machine_arch_type == MACH_TYPE_HARMONY)
#else
# define machine_is_harmony()	(0)
#endif

#ifdef CONFIG_MACH_CYBOOK_ORIZON
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CYBOOK_ORIZON
# endif
# define machine_is_cybook_orizon()	(machine_arch_type == MACH_TYPE_CYBOOK_ORIZON)
#else
# define machine_is_cybook_orizon()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X30_FLUID
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X30_FLUID
# endif
# define machine_is_msm7x30_fluid()	(machine_arch_type == MACH_TYPE_MSM7X30_FLUID)
#else
# define machine_is_msm7x30_fluid()	(0)
#endif

#ifdef CONFIG_MACH_CM_T3517
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_T3517
# endif
# define machine_is_cm_t3517()	(machine_arch_type == MACH_TYPE_CM_T3517)
#else
# define machine_is_cm_t3517()	(0)
#endif

#ifdef CONFIG_MACH_WBD222
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WBD222
# endif
# define machine_is_wbd222()	(machine_arch_type == MACH_TYPE_WBD222)
#else
# define machine_is_wbd222()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_SURF
# endif
# define machine_is_msm8x60_surf()	(machine_arch_type == MACH_TYPE_MSM8X60_SURF)
#else
# define machine_is_msm8x60_surf()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_SIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_SIM
# endif
# define machine_is_msm8x60_sim()	(machine_arch_type == MACH_TYPE_MSM8X60_SIM)
#else
# define machine_is_msm8x60_sim()	(0)
#endif

#ifdef CONFIG_MACH_TCC8000_SDK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TCC8000_SDK
# endif
# define machine_is_tcc8000_sdk()	(machine_arch_type == MACH_TYPE_TCC8000_SDK)
#else
# define machine_is_tcc8000_sdk()	(0)
#endif

#ifdef CONFIG_MACH_CNS3420VB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CNS3420VB
# endif
# define machine_is_cns3420vb()	(machine_arch_type == MACH_TYPE_CNS3420VB)
#else
# define machine_is_cns3420vb()	(0)
#endif

#ifdef CONFIG_MACH_OMAP4_PANDA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP4_PANDA
# endif
# define machine_is_omap4_panda()	(machine_arch_type == MACH_TYPE_OMAP4_PANDA)
#else
# define machine_is_omap4_panda()	(0)
#endif

#ifdef CONFIG_MACH_TI8168EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TI8168EVM
# endif
# define machine_is_ti8168evm()	(machine_arch_type == MACH_TYPE_TI8168EVM)
#else
# define machine_is_ti8168evm()	(0)
#endif

#ifdef CONFIG_MACH_TETON_BGA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TETON_BGA
# endif
# define machine_is_teton_bga()	(machine_arch_type == MACH_TYPE_TETON_BGA)
#else
# define machine_is_teton_bga()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX25SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX25SD
# endif
# define machine_is_eukrea_cpuimx25sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX25SD)
#else
# define machine_is_eukrea_cpuimx25sd()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX35SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX35SD
# endif
# define machine_is_eukrea_cpuimx35sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX35SD)
#else
# define machine_is_eukrea_cpuimx35sd()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX51SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51SD
# endif
# define machine_is_eukrea_cpuimx51sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51SD)
#else
# define machine_is_eukrea_cpuimx51sd()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX51
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51
# endif
# define machine_is_eukrea_cpuimx51()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51)
#else
# define machine_is_eukrea_cpuimx51()	(0)
#endif

#ifdef CONFIG_MACH_SMDKC210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKC210
# endif
# define machine_is_smdkc210()	(machine_arch_type == MACH_TYPE_SMDKC210)
#else
# define machine_is_smdkc210()	(0)
#endif

#ifdef CONFIG_MACH_T5325
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_T5325
# endif
# define machine_is_t5325()	(machine_arch_type == MACH_TYPE_T5325)
#else
# define machine_is_t5325()	(0)
#endif

#ifdef CONFIG_MACH_INCOME
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INCOME
# endif
# define machine_is_income()	(machine_arch_type == MACH_TYPE_INCOME)
#else
# define machine_is_income()	(0)
#endif

#ifdef CONFIG_MACH_GONI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GONI
# endif
# define machine_is_goni()	(machine_arch_type == MACH_TYPE_GONI)
#else
# define machine_is_goni()	(0)
#endif

#ifdef CONFIG_MACH_BV07
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BV07
# endif
# define machine_is_bv07()	(machine_arch_type == MACH_TYPE_BV07)
#else
# define machine_is_bv07()	(0)
#endif

#ifdef CONFIG_MACH_OPENRD_ULTIMATE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPENRD_ULTIMATE
# endif
# define machine_is_openrd_ultimate()	(machine_arch_type == MACH_TYPE_OPENRD_ULTIMATE)
#else
# define machine_is_openrd_ultimate()	(0)
#endif

#ifdef CONFIG_MACH_DEVIXP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DEVIXP
# endif
# define machine_is_devixp()	(machine_arch_type == MACH_TYPE_DEVIXP)
#else
# define machine_is_devixp()	(0)
#endif

#ifdef CONFIG_MACH_MICCPT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MICCPT
# endif
# define machine_is_miccpt()	(machine_arch_type == MACH_TYPE_MICCPT)
#else
# define machine_is_miccpt()	(0)
#endif

#ifdef CONFIG_MACH_MIC256
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIC256
# endif
# define machine_is_mic256()	(machine_arch_type == MACH_TYPE_MIC256)
#else
# define machine_is_mic256()	(0)
#endif

#ifdef CONFIG_MACH_U5500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U5500
# endif
# define machine_is_u5500()	(machine_arch_type == MACH_TYPE_U5500)
#else
# define machine_is_u5500()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_LSCHL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSCHL
# endif
# define machine_is_linkstation_lschl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSCHL)
#else
# define machine_is_linkstation_lschl()	(0)
#endif

#ifdef CONFIG_MACH_SMDKV310
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKV310
# endif
# define machine_is_smdkv310()	(machine_arch_type == MACH_TYPE_SMDKV310)
#else
# define machine_is_smdkv310()	(0)
#endif

#ifdef CONFIG_MACH_WM8505_7IN_NETBOOK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WM8505_7IN_NETBOOK
# endif
# define machine_is_wm8505_7in_netbook()	(machine_arch_type == MACH_TYPE_WM8505_7IN_NETBOOK)
#else
# define machine_is_wm8505_7in_netbook()	(0)
#endif

#ifdef CONFIG_MACH_CRANEBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CRANEBOARD
# endif
# define machine_is_craneboard()	(machine_arch_type == MACH_TYPE_CRANEBOARD)
#else
# define machine_is_craneboard()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6450
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6450
# endif
# define machine_is_smdk6450()	(machine_arch_type == MACH_TYPE_SMDK6450)
#else
# define machine_is_smdk6450()	(0)
#endif

#ifdef CONFIG_MACH_BROWNSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BROWNSTONE
# endif
# define machine_is_brownstone()	(machine_arch_type == MACH_TYPE_BROWNSTONE)
#else
# define machine_is_brownstone()	(0)
#endif

#ifdef CONFIG_MACH_FLEXIBITY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLEXIBITY
# endif
# define machine_is_flexibity()	(machine_arch_type == MACH_TYPE_FLEXIBITY)
#else
# define machine_is_flexibity()	(0)
#endif

#ifdef CONFIG_MACH_MX50_RDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX50_RDP
# endif
# define machine_is_mx50_rdp()	(machine_arch_type == MACH_TYPE_MX50_RDP)
#else
# define machine_is_mx50_rdp()	(0)
#endif

#ifdef CONFIG_MACH_UNIVERSAL_C210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UNIVERSAL_C210
# endif
# define machine_is_universal_c210()	(machine_arch_type == MACH_TYPE_UNIVERSAL_C210)
#else
# define machine_is_universal_c210()	(0)
#endif

#ifdef CONFIG_MACH_REAL6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REAL6410
# endif
# define machine_is_real6410()	(machine_arch_type == MACH_TYPE_REAL6410)
#else
# define machine_is_real6410()	(0)
#endif

#ifdef CONFIG_MACH_DOCKSTAR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOCKSTAR
# endif
# define machine_is_dockstar()	(machine_arch_type == MACH_TYPE_DOCKSTAR)
#else
# define machine_is_dockstar()	(0)
#endif

#ifdef CONFIG_MACH_TI8148EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TI8148EVM
# endif
# define machine_is_ti8148evm()	(machine_arch_type == MACH_TYPE_TI8148EVM)
#else
# define machine_is_ti8148evm()	(0)
#endif

#ifdef CONFIG_MACH_SEABOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SEABOARD
# endif
# define machine_is_seaboard()	(machine_arch_type == MACH_TYPE_SEABOARD)
#else
# define machine_is_seaboard()	(0)
#endif

#ifdef CONFIG_MACH_MX53_ARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_ARD
# endif
# define machine_is_mx53_ard()	(machine_arch_type == MACH_TYPE_MX53_ARD)
#else
# define machine_is_mx53_ard()	(0)
#endif

#ifdef CONFIG_MACH_MX53_SMD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_SMD
# endif
# define machine_is_mx53_smd()	(machine_arch_type == MACH_TYPE_MX53_SMD)
#else
# define machine_is_mx53_smd()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_RUMI3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_RUMI3
# endif
# define machine_is_msm8x60_rumi3()	(machine_arch_type == MACH_TYPE_MSM8X60_RUMI3)
#else
# define machine_is_msm8x60_rumi3()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_FFA
# endif
# define machine_is_msm8x60_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FFA)
#else
# define machine_is_msm8x60_ffa()	(0)
#endif

#ifdef CONFIG_MACH_CM_A510
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_A510
# endif
# define machine_is_cm_a510()	(machine_arch_type == MACH_TYPE_CM_A510)
#else
# define machine_is_cm_a510()	(0)
#endif

#ifdef CONFIG_MACH_TX28
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TX28
# endif
# define machine_is_tx28()	(machine_arch_type == MACH_TYPE_TX28)
#else
# define machine_is_tx28()	(0)
#endif

#ifdef CONFIG_MACH_PCONTROL_G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCONTROL_G20
# endif
# define machine_is_pcontrol_g20()	(machine_arch_type == MACH_TYPE_PCONTROL_G20)
#else
# define machine_is_pcontrol_g20()	(0)
#endif

#ifdef CONFIG_MACH_VPR200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPR200
# endif
# define machine_is_vpr200()	(machine_arch_type == MACH_TYPE_VPR200)
#else
# define machine_is_vpr200()	(0)
#endif

#ifdef CONFIG_MACH_TORBRECK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TORBRECK
# endif
# define machine_is_torbreck()	(machine_arch_type == MACH_TYPE_TORBRECK)
#else
# define machine_is_torbreck()	(0)
#endif

#ifdef CONFIG_MACH_PRIMA2_EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRIMA2_EVB
# endif
# define machine_is_prima2_evb()	(machine_arch_type == MACH_TYPE_PRIMA2_EVB)
#else
# define machine_is_prima2_evb()	(0)
#endif

#ifdef CONFIG_MACH_PAZ00
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PAZ00
# endif
# define machine_is_paz00()	(machine_arch_type == MACH_TYPE_PAZ00)
#else
# define machine_is_paz00()	(0)
#endif

#ifdef CONFIG_MACH_ACMENETUSFOXG20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACMENETUSFOXG20
# endif
# define machine_is_acmenetusfoxg20()	(machine_arch_type == MACH_TYPE_ACMENETUSFOXG20)
#else
# define machine_is_acmenetusfoxg20()	(0)
#endif

#ifdef CONFIG_MACH_AG5EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AG5EVM
# endif
# define machine_is_ag5evm()	(machine_arch_type == MACH_TYPE_AG5EVM)
#else
# define machine_is_ag5evm()	(0)
#endif

#ifdef CONFIG_MACH_ICS_IF_VOIP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ICS_IF_VOIP
# endif
# define machine_is_ics_if_voip()	(machine_arch_type == MACH_TYPE_ICS_IF_VOIP)
#else
# define machine_is_ics_if_voip()	(0)
#endif

#ifdef CONFIG_MACH_WLF_CRAGG_6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WLF_CRAGG_6410
# endif
# define machine_is_wlf_cragg_6410()	(machine_arch_type == MACH_TYPE_WLF_CRAGG_6410)
#else
# define machine_is_wlf_cragg_6410()	(0)
#endif

#ifdef CONFIG_MACH_TRIMSLICE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TRIMSLICE
# endif
# define machine_is_trimslice()	(machine_arch_type == MACH_TYPE_TRIMSLICE)
#else
# define machine_is_trimslice()	(0)
#endif

#ifdef CONFIG_MACH_KAEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KAEN
# endif
# define machine_is_kaen()	(machine_arch_type == MACH_TYPE_KAEN)
#else
# define machine_is_kaen()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_RM680
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_RM680
# endif
# define machine_is_nokia_rm680()	(machine_arch_type == MACH_TYPE_NOKIA_RM680)
#else
# define machine_is_nokia_rm680()	(0)
#endif

#ifdef CONFIG_MACH_MSM8960_SIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8960_SIM
# endif
# define machine_is_msm8960_sim()	(machine_arch_type == MACH_TYPE_MSM8960_SIM)
#else
# define machine_is_msm8960_sim()	(0)
#endif

#ifdef CONFIG_MACH_MSM8960_RUMI3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8960_RUMI3
# endif
# define machine_is_msm8960_rumi3()	(machine_arch_type == MACH_TYPE_MSM8960_RUMI3)
#else
# define machine_is_msm8960_rumi3()	(0)
#endif

#ifdef CONFIG_MACH_GSIA18S
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GSIA18S
# endif
# define machine_is_gsia18s()	(machine_arch_type == MACH_TYPE_GSIA18S)
#else
# define machine_is_gsia18s()	(0)
#endif

#ifdef CONFIG_MACH_MX53_LOCO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_LOCO
# endif
# define machine_is_mx53_loco()	(machine_arch_type == MACH_TYPE_MX53_LOCO)
#else
# define machine_is_mx53_loco()	(0)
#endif

#ifdef CONFIG_MACH_WARIO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WARIO
# endif
# define machine_is_wario()	(machine_arch_type == MACH_TYPE_WARIO)
#else
# define machine_is_wario()	(0)
#endif

#ifdef CONFIG_MACH_CM_T3730
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_T3730
# endif
# define machine_is_cm_t3730()	(machine_arch_type == MACH_TYPE_CM_T3730)
#else
# define machine_is_cm_t3730()	(0)
#endif

#ifdef CONFIG_MACH_HREFV60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HREFV60
# endif
# define machine_is_hrefv60()	(machine_arch_type == MACH_TYPE_HREFV60)
#else
# define machine_is_hrefv60()	(0)
#endif

#ifdef CONFIG_MACH_ARMLEX4210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMLEX4210
# endif
# define machine_is_armlex4210()	(machine_arch_type == MACH_TYPE_ARMLEX4210)
#else
# define machine_is_armlex4210()	(0)
#endif

#ifdef CONFIG_MACH_SNOWBALL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SNOWBALL
# endif
# define machine_is_snowball()	(machine_arch_type == MACH_TYPE_SNOWBALL)
#else
# define machine_is_snowball()	(0)
#endif

#ifdef CONFIG_MACH_XILINX_EP107
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XILINX_EP107
# endif
# define machine_is_xilinx_ep107()	(machine_arch_type == MACH_TYPE_XILINX_EP107)
#else
# define machine_is_xilinx_ep107()	(0)
#endif

#ifdef CONFIG_MACH_NURI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NURI
# endif
# define machine_is_nuri()	(machine_arch_type == MACH_TYPE_NURI)
#else
# define machine_is_nuri()	(0)
#endif

#ifdef CONFIG_MACH_ORIGEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ORIGEN
# endif
# define machine_is_origen()	(machine_arch_type == MACH_TYPE_ORIGEN)
#else
# define machine_is_origen()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRE
# endif
# define machine_is_nspire()	(machine_arch_type == MACH_TYPE_NSPIRE)
#else
# define machine_is_nspire()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_RM696
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_RM696
# endif
# define machine_is_nokia_rm696()	(machine_arch_type == MACH_TYPE_NOKIA_RM696)
#else
# define machine_is_nokia_rm696()	(0)
#endif

#ifdef CONFIG_MACH_MIKRAP_X168
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIKRAP_X168
# endif
# define machine_is_mikrap_x168()	(machine_arch_type == MACH_TYPE_MIKRAP_X168)
#else
# define machine_is_mikrap_x168()	(0)
#endif

#ifdef CONFIG_MACH_DETO_MACARM9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DETO_MACARM9
# endif
# define machine_is_deto_macarm9()	(machine_arch_type == MACH_TYPE_DETO_MACARM9)
#else
# define machine_is_deto_macarm9()	(0)
#endif

#ifdef CONFIG_MACH_M28EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M28EVK
# endif
# define machine_is_m28evk()	(machine_arch_type == MACH_TYPE_M28EVK)
#else
# define machine_is_m28evk()	(0)
#endif

#ifdef CONFIG_MACH_KOTA2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KOTA2
# endif
# define machine_is_kota2()	(machine_arch_type == MACH_TYPE_KOTA2)
#else
# define machine_is_kota2()	(0)
#endif

#ifdef CONFIG_MACH_BONITO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BONITO
# endif
# define machine_is_bonito()	(machine_arch_type == MACH_TYPE_BONITO)
#else
# define machine_is_bonito()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_EGF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_EGF
# endif
# define machine_is_omap3_egf()	(machine_arch_type == MACH_TYPE_OMAP3_EGF)
#else
# define machine_is_omap3_egf()	(0)
#endif

#ifdef CONFIG_MACH_SMDK4212
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK4212
# endif
# define machine_is_smdk4212()	(machine_arch_type == MACH_TYPE_SMDK4212)
#else
# define machine_is_smdk4212()	(0)
#endif

#ifdef CONFIG_MACH_APX4DEVKIT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APX4DEVKIT
# endif
# define machine_is_apx4devkit()	(machine_arch_type == MACH_TYPE_APX4DEVKIT)
#else
# define machine_is_apx4devkit()	(0)
#endif

#ifdef CONFIG_MACH_SMDK4412
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK4412
# endif
# define machine_is_smdk4412()	(machine_arch_type == MACH_TYPE_SMDK4412)
#else
# define machine_is_smdk4412()	(0)
#endif

#ifdef CONFIG_MACH_MARZEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MARZEN
# endif
# define machine_is_marzen()	(machine_arch_type == MACH_TYPE_MARZEN)
#else
# define machine_is_marzen()	(0)
#endif

#ifdef CONFIG_MACH_KROME
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KROME
# endif
# define machine_is_krome()	(machine_arch_type == MACH_TYPE_KROME)
#else
# define machine_is_krome()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO800EVA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO800EVA
# endif
# define machine_is_armadillo800eva()	(machine_arch_type == MACH_TYPE_ARMADILLO800EVA)
#else
# define machine_is_armadillo800eva()	(0)
#endif

#ifdef CONFIG_MACH_MX53_UMOBO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_UMOBO
# endif
# define machine_is_mx53_umobo()	(machine_arch_type == MACH_TYPE_MX53_UMOBO)
#else
# define machine_is_mx53_umobo()	(0)
#endif

#ifdef CONFIG_MACH_MT4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MT4
# endif
# define machine_is_mt4()	(machine_arch_type == MACH_TYPE_MT4)
#else
# define machine_is_mt4()	(0)
#endif

#ifdef CONFIG_MACH_U8520
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U8520
# endif
# define machine_is_u8520()	(machine_arch_type == MACH_TYPE_U8520)
#else
# define machine_is_u8520()	(0)
#endif

#ifdef CONFIG_MACH_CHUPACABRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CHUPACABRA
# endif
# define machine_is_chupacabra()	(machine_arch_type == MACH_TYPE_CHUPACABRA)
#else
# define machine_is_chupacabra()	(0)
#endif

#ifdef CONFIG_MACH_SCORPION
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SCORPION
# endif
# define machine_is_scorpion()	(machine_arch_type == MACH_TYPE_SCORPION)
#else
# define machine_is_scorpion()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_HE_HMI10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_HE_HMI10
# endif
# define machine_is_davinci_he_hmi10()	(machine_arch_type == MACH_TYPE_DAVINCI_HE_HMI10)
#else
# define machine_is_davinci_he_hmi10()	(0)
#endif

#ifdef CONFIG_MACH_TOPKICK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TOPKICK
# endif
# define machine_is_topkick()	(machine_arch_type == MACH_TYPE_TOPKICK)
#else
# define machine_is_topkick()	(0)
#endif

#ifdef CONFIG_MACH_M3_AUGUESTRUSH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M3_AUGUESTRUSH
# endif
# define machine_is_m3_auguestrush()	(machine_arch_type == MACH_TYPE_M3_AUGUESTRUSH)
#else
# define machine_is_m3_auguestrush()	(0)
#endif

#ifdef CONFIG_MACH_IPC335X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IPC335X
# endif
# define machine_is_ipc335x()	(machine_arch_type == MACH_TYPE_IPC335X)
#else
# define machine_is_ipc335x()	(0)
#endif

#ifdef CONFIG_MACH_SUN4I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN4I
# endif
# define machine_is_sun4i()	(machine_arch_type == MACH_TYPE_SUN4I)
#else
# define machine_is_sun4i()	(0)
#endif

#ifdef CONFIG_MACH_IMX233_OLINUXINO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMX233_OLINUXINO
# endif
# define machine_is_imx233_olinuxino()	(machine_arch_type == MACH_TYPE_IMX233_OLINUXINO)
#else
# define machine_is_imx233_olinuxino()	(0)
#endif

#ifdef CONFIG_MACH_K2_WL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_WL
# endif
# define machine_is_k2_wl()	(machine_arch_type == MACH_TYPE_K2_WL)
#else
# define machine_is_k2_wl()	(0)
#endif

#ifdef CONFIG_MACH_K2_UL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_UL
# endif
# define machine_is_k2_ul()	(machine_arch_type == MACH_TYPE_K2_UL)
#else
# define machine_is_k2_ul()	(0)
#endif

#ifdef CONFIG_MACH_K2_CL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_CL
# endif
# define machine_is_k2_cl()	(machine_arch_type == MACH_TYPE_K2_CL)
#else
# define machine_is_k2_cl()	(0)
#endif

#ifdef CONFIG_MACH_MINBARI_W
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINBARI_W
# endif
# define machine_is_minbari_w()	(machine_arch_type == MACH_TYPE_MINBARI_W)
#else
# define machine_is_minbari_w()	(0)
#endif

#ifdef CONFIG_MACH_MINBARI_M
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINBARI_M
# endif
# define machine_is_minbari_m()	(machine_arch_type == MACH_TYPE_MINBARI_M)
#else
# define machine_is_minbari_m()	(0)
#endif

#ifdef CONFIG_MACH_K035
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K035
# endif
# define machine_is_k035()	(machine_arch_type == MACH_TYPE_K035)
#else
# define machine_is_k035()	(0)
#endif

#ifdef CONFIG_MACH_ARIEL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIEL
# endif
# define machine_is_ariel()	(machine_arch_type == MACH_TYPE_ARIEL)
#else
# define machine_is_ariel()	(0)
#endif

#ifdef CONFIG_MACH_ARIELSAARC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIELSAARC
# endif
# define machine_is_arielsaarc()	(machine_arch_type == MACH_TYPE_ARIELSAARC)
#else
# define machine_is_arielsaarc()	(0)
#endif

#ifdef CONFIG_MACH_ARIELDKB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIELDKB
# endif
# define machine_is_arieldkb()	(machine_arch_type == MACH_TYPE_ARIELDKB)
#else
# define machine_is_arieldkb()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO810
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO810
# endif
# define machine_is_armadillo810()	(machine_arch_type == MACH_TYPE_ARMADILLO810)
#else
# define machine_is_armadillo810()	(0)
#endif

#ifdef CONFIG_MACH_TAM335X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAM335X
# endif
# define machine_is_tam335x()	(machine_arch_type == MACH_TYPE_TAM335X)
#else
# define machine_is_tam335x()	(0)
#endif

#ifdef CONFIG_MACH_GROUPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GROUPER
# endif
# define machine_is_grouper()	(machine_arch_type == MACH_TYPE_GROUPER)
#else
# define machine_is_grouper()	(0)
#endif

#ifdef CONFIG_MACH_MPCSA21_9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MPCSA21_9G20
# endif
# define machine_is_mpcsa21_9g20()	(machine_arch_type == MACH_TYPE_MPCSA21_9G20)
#else
# define machine_is_mpcsa21_9g20()	(0)
#endif

#ifdef CONFIG_MACH_M6U_CPU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M6U_CPU
# endif
# define machine_is_m6u_cpu()	(machine_arch_type == MACH_TYPE_M6U_CPU)
#else
# define machine_is_m6u_cpu()	(0)
#endif

#ifdef CONFIG_MACH_GINKGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GINKGO
# endif
# define machine_is_ginkgo()	(machine_arch_type == MACH_TYPE_GINKGO)
#else
# define machine_is_ginkgo()	(0)
#endif

#ifdef CONFIG_MACH_CGT_QMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CGT_QMX6
# endif
# define machine_is_cgt_qmx6()	(machine_arch_type == MACH_TYPE_CGT_QMX6)
#else
# define machine_is_cgt_qmx6()	(0)
#endif

#ifdef CONFIG_MACH_PROFPGA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROFPGA
# endif
# define machine_is_profpga()	(machine_arch_type == MACH_TYPE_PROFPGA)
#else
# define machine_is_profpga()	(0)
#endif

#ifdef CONFIG_MACH_ACFX100OC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACFX100OC
# endif
# define machine_is_acfx100oc()	(machine_arch_type == MACH_TYPE_ACFX100OC)
#else
# define machine_is_acfx100oc()	(0)
#endif

#ifdef CONFIG_MACH_ACFX100NB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACFX100NB
# endif
# define machine_is_acfx100nb()	(machine_arch_type == MACH_TYPE_ACFX100NB)
#else
# define machine_is_acfx100nb()	(0)
#endif

#ifdef CONFIG_MACH_CAPRICORN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CAPRICORN
# endif
# define machine_is_capricorn()	(machine_arch_type == MACH_TYPE_CAPRICORN)
#else
# define machine_is_capricorn()	(0)
#endif

#ifdef CONFIG_MACH_PISCES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PISCES
# endif
# define machine_is_pisces()	(machine_arch_type == MACH_TYPE_PISCES)
#else
# define machine_is_pisces()	(0)
#endif

#ifdef CONFIG_MACH_ARIES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIES
# endif
# define machine_is_aries()	(machine_arch_type == MACH_TYPE_ARIES)
#else
# define machine_is_aries()	(0)
#endif

#ifdef CONFIG_MACH_CANCER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CANCER
# endif
# define machine_is_cancer()	(machine_arch_type == MACH_TYPE_CANCER)
#else
# define machine_is_cancer()	(0)
#endif

#ifdef CONFIG_MACH_LEO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LEO
# endif
# define machine_is_leo()	(machine_arch_type == MACH_TYPE_LEO)
#else
# define machine_is_leo()	(0)
#endif

#ifdef CONFIG_MACH_VIRGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIRGO
# endif
# define machine_is_virgo()	(machine_arch_type == MACH_TYPE_VIRGO)
#else
# define machine_is_virgo()	(0)
#endif

#ifdef CONFIG_MACH_SAGITTARIUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAGITTARIUS
# endif
# define machine_is_sagittarius()	(machine_arch_type == MACH_TYPE_SAGITTARIUS)
#else
# define machine_is_sagittarius()	(0)
#endif

#ifdef CONFIG_MACH_DEVIL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DEVIL
# endif
# define machine_is_devil()	(machine_arch_type == MACH_TYPE_DEVIL)
#else
# define machine_is_devil()	(0)
#endif

#ifdef CONFIG_MACH_BALLANTINES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BALLANTINES
# endif
# define machine_is_ballantines()	(machine_arch_type == MACH_TYPE_BALLANTINES)
#else
# define machine_is_ballantines()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_PROCERUSVPU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_PROCERUSVPU
# endif
# define machine_is_omap3_procerusvpu()	(machine_arch_type == MACH_TYPE_OMAP3_PROCERUSVPU)
#else
# define machine_is_omap3_procerusvpu()	(0)
#endif

#ifdef CONFIG_MACH_MY27
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MY27
# endif
# define machine_is_my27()	(machine_arch_type == MACH_TYPE_MY27)
#else
# define machine_is_my27()	(0)
#endif

#ifdef CONFIG_MACH_SUN6I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN6I
# endif
# define machine_is_sun6i()	(machine_arch_type == MACH_TYPE_SUN6I)
#else
# define machine_is_sun6i()	(0)
#endif

#ifdef CONFIG_MACH_SUN5I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN5I
# endif
# define machine_is_sun5i()	(machine_arch_type == MACH_TYPE_SUN5I)
#else
# define machine_is_sun5i()	(0)
#endif

#ifdef CONFIG_MACH_MX512_MX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX512_MX
# endif
# define machine_is_mx512_mx()	(machine_arch_type == MACH_TYPE_MX512_MX)
#else
# define machine_is_mx512_mx()	(0)
#endif

#ifdef CONFIG_MACH_KZM9G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KZM9G
# endif
# define machine_is_kzm9g()	(machine_arch_type == MACH_TYPE_KZM9G)
#else
# define machine_is_kzm9g()	(0)
#endif

#ifdef CONFIG_MACH_VDSTBN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VDSTBN
# endif
# define machine_is_vdstbn()	(machine_arch_type == MACH_TYPE_VDSTBN)
#else
# define machine_is_vdstbn()	(0)
#endif

#ifdef CONFIG_MACH_CFA10036
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CFA10036
# endif
# define machine_is_cfa10036()	(machine_arch_type == MACH_TYPE_CFA10036)
#else
# define machine_is_cfa10036()	(0)
#endif

#ifdef CONFIG_MACH_CFA10049
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CFA10049
# endif
# define machine_is_cfa10049()	(machine_arch_type == MACH_TYPE_CFA10049)
#else
# define machine_is_cfa10049()	(0)
#endif

#ifdef CONFIG_MACH_PCM051
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM051
# endif
# define machine_is_pcm051()	(machine_arch_type == MACH_TYPE_PCM051)
#else
# define machine_is_pcm051()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF7XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF7XX
# endif
# define machine_is_vybrid_vf7xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF7XX)
#else
# define machine_is_vybrid_vf7xx()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF6XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF6XX
# endif
# define machine_is_vybrid_vf6xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF6XX)
#else
# define machine_is_vybrid_vf6xx()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF5XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF5XX
# endif
# define machine_is_vybrid_vf5xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF5XX)
#else
# define machine_is_vybrid_vf5xx()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF4XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF4XX
# endif
# define machine_is_vybrid_vf4xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF4XX)
#else
# define machine_is_vybrid_vf4xx()	(0)
#endif

#ifdef CONFIG_MACH_ARIA_G25
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIA_G25
# endif
# define machine_is_aria_g25()	(machine_arch_type == MACH_TYPE_ARIA_G25)
#else
# define machine_is_aria_g25()	(0)
#endif

#ifdef CONFIG_MACH_BCM21553
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCM21553
# endif
# define machine_is_bcm21553()	(machine_arch_type == MACH_TYPE_BCM21553)
#else
# define machine_is_bcm21553()	(0)
#endif

#ifdef CONFIG_MACH_SMDK5410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK5410
# endif
# define machine_is_smdk5410()	(machine_arch_type == MACH_TYPE_SMDK5410)
#else
# define machine_is_smdk5410()	(0)
#endif

#ifdef CONFIG_MACH_LPC18XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LPC18XX
# endif
# define machine_is_lpc18xx()	(machine_arch_type == MACH_TYPE_LPC18XX)
#else
# define machine_is_lpc18xx()	(0)
#endif

#ifdef CONFIG_MACH_ORATISPARTY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ORATISPARTY
# endif
# define machine_is_oratisparty()	(machine_arch_type == MACH_TYPE_ORATISPARTY)
#else
# define machine_is_oratisparty()	(0)
#endif

#ifdef CONFIG_MACH_QSEVEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSEVEN
# endif
# define machine_is_qseven()	(machine_arch_type == MACH_TYPE_QSEVEN)
#else
# define machine_is_qseven()	(0)
#endif

#ifdef CONFIG_MACH_GMV_GENERIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GMV_GENERIC
# endif
# define machine_is_gmv_generic()	(machine_arch_type == MACH_TYPE_GMV_GENERIC)
#else
# define machine_is_gmv_generic()	(0)
#endif

#ifdef CONFIG_MACH_TH_LINK_ETH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TH_LINK_ETH
# endif
# define machine_is_th_link_eth()	(machine_arch_type == MACH_TYPE_TH_LINK_ETH)
#else
# define machine_is_th_link_eth()	(0)
#endif

#ifdef CONFIG_MACH_TN_MUNINN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TN_MUNINN
# endif
# define machine_is_tn_muninn()	(machine_arch_type == MACH_TYPE_TN_MUNINN)
#else
# define machine_is_tn_muninn()	(0)
#endif

#ifdef CONFIG_MACH_RAMPAGE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAMPAGE
# endif
# define machine_is_rampage()	(machine_arch_type == MACH_TYPE_RAMPAGE)
#else
# define machine_is_rampage()	(0)
#endif

#ifdef CONFIG_MACH_VISSTRIM_MV10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VISSTRIM_MV10
# endif
# define machine_is_visstrim_mv10()	(machine_arch_type == MACH_TYPE_VISSTRIM_MV10)
#else
# define machine_is_visstrim_mv10()	(0)
#endif

#ifdef CONFIG_MACH_MX28_WILMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX28_WILMA
# endif
# define machine_is_mx28_wilma()	(machine_arch_type == MACH_TYPE_MX28_WILMA)
#else
# define machine_is_mx28_wilma()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625_FFA
# endif
# define machine_is_msm8625_ffa()	(machine_arch_type == MACH_TYPE_MSM8625_FFA)
#else
# define machine_is_msm8625_ffa()	(0)
#endif

#ifdef CONFIG_MACH_VPU101
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPU101
# endif
# define machine_is_vpu101()	(machine_arch_type == MACH_TYPE_VPU101)
#else
# define machine_is_vpu101()	(0)
#endif

#ifdef CONFIG_MACH_BAILEYS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BAILEYS
# endif
# define machine_is_baileys()	(machine_arch_type == MACH_TYPE_BAILEYS)
#else
# define machine_is_baileys()	(0)
#endif

#ifdef CONFIG_MACH_FAMILYBOX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FAMILYBOX
# endif
# define machine_is_familybox()	(machine_arch_type == MACH_TYPE_FAMILYBOX)
#else
# define machine_is_familybox()	(0)
#endif

#ifdef CONFIG_MACH_ENSEMBLE_MX35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ENSEMBLE_MX35
# endif
# define machine_is_ensemble_mx35()	(machine_arch_type == MACH_TYPE_ENSEMBLE_MX35)
#else
# define machine_is_ensemble_mx35()	(0)
#endif

#ifdef CONFIG_MACH_SC_SPS_1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SC_SPS_1
# endif
# define machine_is_sc_sps_1()	(machine_arch_type == MACH_TYPE_SC_SPS_1)
#else
# define machine_is_sc_sps_1()	(0)
#endif

#ifdef CONFIG_MACH_UCSIMPLY_SAM9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UCSIMPLY_SAM9260
# endif
# define machine_is_ucsimply_sam9260()	(machine_arch_type == MACH_TYPE_UCSIMPLY_SAM9260)
#else
# define machine_is_ucsimply_sam9260()	(0)
#endif

#ifdef CONFIG_MACH_UNICORN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UNICORN
# endif
# define machine_is_unicorn()	(machine_arch_type == MACH_TYPE_UNICORN)
#else
# define machine_is_unicorn()	(0)
#endif

#ifdef CONFIG_MACH_M9G45A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M9G45A
# endif
# define machine_is_m9g45a()	(machine_arch_type == MACH_TYPE_M9G45A)
#else
# define machine_is_m9g45a()	(0)
#endif

#ifdef CONFIG_MACH_MTWEBIF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MTWEBIF
# endif
# define machine_is_mtwebif()	(machine_arch_type == MACH_TYPE_MTWEBIF)
#else
# define machine_is_mtwebif()	(0)
#endif

#ifdef CONFIG_MACH_PLAYSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PLAYSTONE
# endif
# define machine_is_playstone()	(machine_arch_type == MACH_TYPE_PLAYSTONE)
#else
# define machine_is_playstone()	(0)
#endif

#ifdef CONFIG_MACH_CHELSEA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CHELSEA
# endif
# define machine_is_chelsea()	(machine_arch_type == MACH_TYPE_CHELSEA)
#else
# define machine_is_chelsea()	(0)
#endif

#ifdef CONFIG_MACH_BAYERN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BAYERN
# endif
# define machine_is_bayern()	(machine_arch_type == MACH_TYPE_BAYERN)
#else
# define machine_is_bayern()	(0)
#endif

#ifdef CONFIG_MACH_MITWO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MITWO
# endif
# define machine_is_mitwo()	(machine_arch_type == MACH_TYPE_MITWO)
#else
# define machine_is_mitwo()	(0)
#endif

#ifdef CONFIG_MACH_MX25_NOAH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX25_NOAH
# endif
# define machine_is_mx25_noah()	(machine_arch_type == MACH_TYPE_MX25_NOAH)
#else
# define machine_is_mx25_noah()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2020
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2020
# endif
# define machine_is_stm_b2020()	(machine_arch_type == MACH_TYPE_STM_B2020)
#else
# define machine_is_stm_b2020()	(0)
#endif

#ifdef CONFIG_MACH_ANNAX_SRC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANNAX_SRC
# endif
# define machine_is_annax_src()	(machine_arch_type == MACH_TYPE_ANNAX_SRC)
#else
# define machine_is_annax_src()	(0)
#endif

#ifdef CONFIG_MACH_IONICS_STRATUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IONICS_STRATUS
# endif
# define machine_is_ionics_stratus()	(machine_arch_type == MACH_TYPE_IONICS_STRATUS)
#else
# define machine_is_ionics_stratus()	(0)
#endif

#ifdef CONFIG_MACH_HUGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HUGO
# endif
# define machine_is_hugo()	(machine_arch_type == MACH_TYPE_HUGO)
#else
# define machine_is_hugo()	(0)
#endif

#ifdef CONFIG_MACH_EM300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EM300
# endif
# define machine_is_em300()	(machine_arch_type == MACH_TYPE_EM300)
#else
# define machine_is_em300()	(0)
#endif

#ifdef CONFIG_MACH_MMP3_QSEVEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MMP3_QSEVEN
# endif
# define machine_is_mmp3_qseven()	(machine_arch_type == MACH_TYPE_MMP3_QSEVEN)
#else
# define machine_is_mmp3_qseven()	(0)
#endif

#ifdef CONFIG_MACH_BOSPHORUS2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BOSPHORUS2
# endif
# define machine_is_bosphorus2()	(machine_arch_type == MACH_TYPE_BOSPHORUS2)
#else
# define machine_is_bosphorus2()	(0)
#endif

#ifdef CONFIG_MACH_TT2200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TT2200
# endif
# define machine_is_tt2200()	(machine_arch_type == MACH_TYPE_TT2200)
#else
# define machine_is_tt2200()	(0)
#endif

#ifdef CONFIG_MACH_OCELOT3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OCELOT3
# endif
# define machine_is_ocelot3()	(machine_arch_type == MACH_TYPE_OCELOT3)
#else
# define machine_is_ocelot3()	(0)
#endif

#ifdef CONFIG_MACH_TEK_COBRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEK_COBRA
# endif
# define machine_is_tek_cobra()	(machine_arch_type == MACH_TYPE_TEK_COBRA)
#else
# define machine_is_tek_cobra()	(0)
#endif

#ifdef CONFIG_MACH_PROTOU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTOU
# endif
# define machine_is_protou()	(machine_arch_type == MACH_TYPE_PROTOU)
#else
# define machine_is_protou()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625_EVT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625_EVT
# endif
# define machine_is_msm8625_evt()	(machine_arch_type == MACH_TYPE_MSM8625_EVT)
#else
# define machine_is_msm8625_evt()	(0)
#endif

#ifdef CONFIG_MACH_MX53_SELLWOOD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_SELLWOOD
# endif
# define machine_is_mx53_sellwood()	(machine_arch_type == MACH_TYPE_MX53_SELLWOOD)
#else
# define machine_is_mx53_sellwood()	(0)
#endif

#ifdef CONFIG_MACH_SOMIQ_AM35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOMIQ_AM35
# endif
# define machine_is_somiq_am35()	(machine_arch_type == MACH_TYPE_SOMIQ_AM35)
#else
# define machine_is_somiq_am35()	(0)
#endif

#ifdef CONFIG_MACH_SOMIQ_AM37
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOMIQ_AM37
# endif
# define machine_is_somiq_am37()	(machine_arch_type == MACH_TYPE_SOMIQ_AM37)
#else
# define machine_is_somiq_am37()	(0)
#endif

#ifdef CONFIG_MACH_K2_PLC_CL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_PLC_CL
# endif
# define machine_is_k2_plc_cl()	(machine_arch_type == MACH_TYPE_K2_PLC_CL)
#else
# define machine_is_k2_plc_cl()	(0)
#endif

#ifdef CONFIG_MACH_TC2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TC2
# endif
# define machine_is_tc2()	(machine_arch_type == MACH_TYPE_TC2)
#else
# define machine_is_tc2()	(0)
#endif

#ifdef CONFIG_MACH_DULEX_J
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DULEX_J
# endif
# define machine_is_dulex_j()	(machine_arch_type == MACH_TYPE_DULEX_J)
#else
# define machine_is_dulex_j()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2044
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2044
# endif
# define machine_is_stm_b2044()	(machine_arch_type == MACH_TYPE_STM_B2044)
#else
# define machine_is_stm_b2044()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_J
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_J
# endif
# define machine_is_deluxe_j()	(machine_arch_type == MACH_TYPE_DELUXE_J)
#else
# define machine_is_deluxe_j()	(0)
#endif

#ifdef CONFIG_MACH_MANGO2443
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MANGO2443
# endif
# define machine_is_mango2443()	(machine_arch_type == MACH_TYPE_MANGO2443)
#else
# define machine_is_mango2443()	(0)
#endif

#ifdef CONFIG_MACH_CP2DCG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2DCG
# endif
# define machine_is_cp2dcg()	(machine_arch_type == MACH_TYPE_CP2DCG)
#else
# define machine_is_cp2dcg()	(0)
#endif

#ifdef CONFIG_MACH_CP2DTG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2DTG
# endif
# define machine_is_cp2dtg()	(machine_arch_type == MACH_TYPE_CP2DTG)
#else
# define machine_is_cp2dtg()	(0)
#endif

#ifdef CONFIG_MACH_CP2DUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2DUG
# endif
# define machine_is_cp2dug()	(machine_arch_type == MACH_TYPE_CP2DUG)
#else
# define machine_is_cp2dug()	(0)
#endif

#ifdef CONFIG_MACH_VAR_SOM_AM33
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VAR_SOM_AM33
# endif
# define machine_is_var_som_am33()	(machine_arch_type == MACH_TYPE_VAR_SOM_AM33)
#else
# define machine_is_var_som_am33()	(0)
#endif

#ifdef CONFIG_MACH_PEPPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PEPPER
# endif
# define machine_is_pepper()	(machine_arch_type == MACH_TYPE_PEPPER)
#else
# define machine_is_pepper()	(0)
#endif

#ifdef CONFIG_MACH_MANGO2450
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MANGO2450
# endif
# define machine_is_mango2450()	(machine_arch_type == MACH_TYPE_MANGO2450)
#else
# define machine_is_mango2450()	(0)
#endif

#ifdef CONFIG_MACH_VALENTE_WX_C9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VALENTE_WX_C9
# endif
# define machine_is_valente_wx_c9()	(machine_arch_type == MACH_TYPE_VALENTE_WX_C9)
#else
# define machine_is_valente_wx_c9()	(0)
#endif

#ifdef CONFIG_MACH_MINITV
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINITV
# endif
# define machine_is_minitv()	(machine_arch_type == MACH_TYPE_MINITV)
#else
# define machine_is_minitv()	(0)
#endif

#ifdef CONFIG_MACH_U8540
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U8540
# endif
# define machine_is_u8540()	(machine_arch_type == MACH_TYPE_U8540)
#else
# define machine_is_u8540()	(0)
#endif

#ifdef CONFIG_MACH_IV_ATLAS_I_Z7E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IV_ATLAS_I_Z7E
# endif
# define machine_is_iv_atlas_i_z7e()	(machine_arch_type == MACH_TYPE_IV_ATLAS_I_Z7E)
#else
# define machine_is_iv_atlas_i_z7e()	(0)
#endif

#ifdef CONFIG_MACH_MACH_TYPE_SKY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MACH_TYPE_SKY
# endif
# define machine_is_mach_type_sky()	(machine_arch_type == MACH_TYPE_MACH_TYPE_SKY)
#else
# define machine_is_mach_type_sky()	(0)
#endif

#ifdef CONFIG_MACH_BLUESKY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BLUESKY
# endif
# define machine_is_bluesky()	(machine_arch_type == MACH_TYPE_BLUESKY)
#else
# define machine_is_bluesky()	(0)
#endif

#ifdef CONFIG_MACH_NGROUTER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NGROUTER
# endif
# define machine_is_ngrouter()	(machine_arch_type == MACH_TYPE_NGROUTER)
#else
# define machine_is_ngrouter()	(0)
#endif

#ifdef CONFIG_MACH_MX53_DENETIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_DENETIM
# endif
# define machine_is_mx53_denetim()	(machine_arch_type == MACH_TYPE_MX53_DENETIM)
#else
# define machine_is_mx53_denetim()	(0)
#endif

#ifdef CONFIG_MACH_OPAL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPAL
# endif
# define machine_is_opal()	(machine_arch_type == MACH_TYPE_OPAL)
#else
# define machine_is_opal()	(0)
#endif

#ifdef CONFIG_MACH_GNET_US3GREF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GNET_US3GREF
# endif
# define machine_is_gnet_us3gref()	(machine_arch_type == MACH_TYPE_GNET_US3GREF)
#else
# define machine_is_gnet_us3gref()	(0)
#endif

#ifdef CONFIG_MACH_GNET_NC3G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GNET_NC3G
# endif
# define machine_is_gnet_nc3g()	(machine_arch_type == MACH_TYPE_GNET_NC3G)
#else
# define machine_is_gnet_nc3g()	(0)
#endif

#ifdef CONFIG_MACH_GNET_GE3G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GNET_GE3G
# endif
# define machine_is_gnet_ge3g()	(machine_arch_type == MACH_TYPE_GNET_GE3G)
#else
# define machine_is_gnet_ge3g()	(0)
#endif

#ifdef CONFIG_MACH_ADP2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ADP2
# endif
# define machine_is_adp2()	(machine_arch_type == MACH_TYPE_ADP2)
#else
# define machine_is_adp2()	(0)
#endif

#ifdef CONFIG_MACH_TQMA28
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TQMA28
# endif
# define machine_is_tqma28()	(machine_arch_type == MACH_TYPE_TQMA28)
#else
# define machine_is_tqma28()	(0)
#endif

#ifdef CONFIG_MACH_KACOM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KACOM3
# endif
# define machine_is_kacom3()	(machine_arch_type == MACH_TYPE_KACOM3)
#else
# define machine_is_kacom3()	(0)
#endif

#ifdef CONFIG_MACH_RRHDEMO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RRHDEMO
# endif
# define machine_is_rrhdemo()	(machine_arch_type == MACH_TYPE_RRHDEMO)
#else
# define machine_is_rrhdemo()	(0)
#endif

#ifdef CONFIG_MACH_PROTODUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTODUG
# endif
# define machine_is_protodug()	(machine_arch_type == MACH_TYPE_PROTODUG)
#else
# define machine_is_protodug()	(0)
#endif

#ifdef CONFIG_MACH_LAGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LAGO
# endif
# define machine_is_lago()	(machine_arch_type == MACH_TYPE_LAGO)
#else
# define machine_is_lago()	(0)
#endif

#ifdef CONFIG_MACH_KTT30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KTT30
# endif
# define machine_is_ktt30()	(machine_arch_type == MACH_TYPE_KTT30)
#else
# define machine_is_ktt30()	(0)
#endif

#ifdef CONFIG_MACH_TS43XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS43XX
# endif
# define machine_is_ts43xx()	(machine_arch_type == MACH_TYPE_TS43XX)
#else
# define machine_is_ts43xx()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_DENSO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_DENSO
# endif
# define machine_is_mx6q_denso()	(machine_arch_type == MACH_TYPE_MX6Q_DENSO)
#else
# define machine_is_mx6q_denso()	(0)
#endif

#ifdef CONFIG_MACH_COMSAT_GSMUMTS8
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COMSAT_GSMUMTS8
# endif
# define machine_is_comsat_gsmumts8()	(machine_arch_type == MACH_TYPE_COMSAT_GSMUMTS8)
#else
# define machine_is_comsat_gsmumts8()	(0)
#endif

#ifdef CONFIG_MACH_DREAMX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DREAMX
# endif
# define machine_is_dreamx()	(machine_arch_type == MACH_TYPE_DREAMX)
#else
# define machine_is_dreamx()	(0)
#endif

#ifdef CONFIG_MACH_THUNDERSTONEM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_THUNDERSTONEM
# endif
# define machine_is_thunderstonem()	(machine_arch_type == MACH_TYPE_THUNDERSTONEM)
#else
# define machine_is_thunderstonem()	(0)
#endif

#ifdef CONFIG_MACH_YOYOPAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YOYOPAD
# endif
# define machine_is_yoyopad()	(machine_arch_type == MACH_TYPE_YOYOPAD)
#else
# define machine_is_yoyopad()	(0)
#endif

#ifdef CONFIG_MACH_YOYOPATIENT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YOYOPATIENT
# endif
# define machine_is_yoyopatient()	(machine_arch_type == MACH_TYPE_YOYOPATIENT)
#else
# define machine_is_yoyopatient()	(0)
#endif

#ifdef CONFIG_MACH_A10L
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_A10L
# endif
# define machine_is_a10l()	(machine_arch_type == MACH_TYPE_A10L)
#else
# define machine_is_a10l()	(0)
#endif

#ifdef CONFIG_MACH_MQ60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MQ60
# endif
# define machine_is_mq60()	(machine_arch_type == MACH_TYPE_MQ60)
#else
# define machine_is_mq60()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_LSQL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSQL
# endif
# define machine_is_linkstation_lsql()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSQL)
#else
# define machine_is_linkstation_lsql()	(0)
#endif

#ifdef CONFIG_MACH_AM3703GATEWAY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AM3703GATEWAY
# endif
# define machine_is_am3703gateway()	(machine_arch_type == MACH_TYPE_AM3703GATEWAY)
#else
# define machine_is_am3703gateway()	(0)
#endif

#ifdef CONFIG_MACH_ACCIPITER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACCIPITER
# endif
# define machine_is_accipiter()	(machine_arch_type == MACH_TYPE_ACCIPITER)
#else
# define machine_is_accipiter()	(0)
#endif

#ifdef CONFIG_MACH_MAGNIDUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAGNIDUG
# endif
# define machine_is_magnidug()	(machine_arch_type == MACH_TYPE_MAGNIDUG)
#else
# define machine_is_magnidug()	(0)
#endif

#ifdef CONFIG_MACH_HYDRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HYDRA
# endif
# define machine_is_hydra()	(machine_arch_type == MACH_TYPE_HYDRA)
#else
# define machine_is_hydra()	(0)
#endif

#ifdef CONFIG_MACH_SUN3I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN3I
# endif
# define machine_is_sun3i()	(machine_arch_type == MACH_TYPE_SUN3I)
#else
# define machine_is_sun3i()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2078
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2078
# endif
# define machine_is_stm_b2078()	(machine_arch_type == MACH_TYPE_STM_B2078)
#else
# define machine_is_stm_b2078()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9263DESKV2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9263DESKV2
# endif
# define machine_is_at91sam9263deskv2()	(machine_arch_type == MACH_TYPE_AT91SAM9263DESKV2)
#else
# define machine_is_at91sam9263deskv2()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_R
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_R
# endif
# define machine_is_deluxe_r()	(machine_arch_type == MACH_TYPE_DELUXE_R)
#else
# define machine_is_deluxe_r()	(0)
#endif

#ifdef CONFIG_MACH_P_98_V
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P_98_V
# endif
# define machine_is_p_98_v()	(machine_arch_type == MACH_TYPE_P_98_V)
#else
# define machine_is_p_98_v()	(0)
#endif

#ifdef CONFIG_MACH_P_98_C
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P_98_C
# endif
# define machine_is_p_98_c()	(machine_arch_type == MACH_TYPE_P_98_C)
#else
# define machine_is_p_98_c()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_AM18XX_OMN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_AM18XX_OMN
# endif
# define machine_is_davinci_am18xx_omn()	(machine_arch_type == MACH_TYPE_DAVINCI_AM18XX_OMN)
#else
# define machine_is_davinci_am18xx_omn()	(0)
#endif

#ifdef CONFIG_MACH_SOCFPGA_CYCLONE5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOCFPGA_CYCLONE5
# endif
# define machine_is_socfpga_cyclone5()	(machine_arch_type == MACH_TYPE_SOCFPGA_CYCLONE5)
#else
# define machine_is_socfpga_cyclone5()	(0)
#endif

#ifdef CONFIG_MACH_CABATUIN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CABATUIN
# endif
# define machine_is_cabatuin()	(machine_arch_type == MACH_TYPE_CABATUIN)
#else
# define machine_is_cabatuin()	(0)
#endif

#ifdef CONFIG_MACH_YOYOPAD_FT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YOYOPAD_FT
# endif
# define machine_is_yoyopad_ft()	(machine_arch_type == MACH_TYPE_YOYOPAD_FT)
#else
# define machine_is_yoyopad_ft()	(0)
#endif

#ifdef CONFIG_MACH_DAN2400EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAN2400EVB
# endif
# define machine_is_dan2400evb()	(machine_arch_type == MACH_TYPE_DAN2400EVB)
#else
# define machine_is_dan2400evb()	(0)
#endif

#ifdef CONFIG_MACH_DAN3400EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAN3400EVB
# endif
# define machine_is_dan3400evb()	(machine_arch_type == MACH_TYPE_DAN3400EVB)
#else
# define machine_is_dan3400evb()	(0)
#endif

#ifdef CONFIG_MACH_EDM_SF_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDM_SF_IMX6
# endif
# define machine_is_edm_sf_imx6()	(machine_arch_type == MACH_TYPE_EDM_SF_IMX6)
#else
# define machine_is_edm_sf_imx6()	(0)
#endif

#ifdef CONFIG_MACH_EDM_CF_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDM_CF_IMX6
# endif
# define machine_is_edm_cf_imx6()	(machine_arch_type == MACH_TYPE_EDM_CF_IMX6)
#else
# define machine_is_edm_cf_imx6()	(0)
#endif

#ifdef CONFIG_MACH_VPOS3XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPOS3XX
# endif
# define machine_is_vpos3xx()	(machine_arch_type == MACH_TYPE_VPOS3XX)
#else
# define machine_is_vpos3xx()	(0)
#endif

#ifdef CONFIG_MACH_VULCANO_9X5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VULCANO_9X5
# endif
# define machine_is_vulcano_9x5()	(machine_arch_type == MACH_TYPE_VULCANO_9X5)
#else
# define machine_is_vulcano_9x5()	(0)
#endif

#ifdef CONFIG_MACH_SPMP8000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPMP8000
# endif
# define machine_is_spmp8000()	(machine_arch_type == MACH_TYPE_SPMP8000)
#else
# define machine_is_spmp8000()	(0)
#endif

#ifdef CONFIG_MACH_CATALINA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CATALINA
# endif
# define machine_is_catalina()	(machine_arch_type == MACH_TYPE_CATALINA)
#else
# define machine_is_catalina()	(0)
#endif

#ifdef CONFIG_MACH_RD88F5181L_FE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F5181L_FE
# endif
# define machine_is_rd88f5181l_fe()	(machine_arch_type == MACH_TYPE_RD88F5181L_FE)
#else
# define machine_is_rd88f5181l_fe()	(0)
#endif

#ifdef CONFIG_MACH_MX535_MX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX535_MX
# endif
# define machine_is_mx535_mx()	(machine_arch_type == MACH_TYPE_MX535_MX)
#else
# define machine_is_mx535_mx()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO840
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO840
# endif
# define machine_is_armadillo840()	(machine_arch_type == MACH_TYPE_ARMADILLO840)
#else
# define machine_is_armadillo840()	(0)
#endif

#ifdef CONFIG_MACH_SPC9000BASEBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPC9000BASEBOARD
# endif
# define machine_is_spc9000baseboard()	(machine_arch_type == MACH_TYPE_SPC9000BASEBOARD)
#else
# define machine_is_spc9000baseboard()	(0)
#endif

#ifdef CONFIG_MACH_IRIS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IRIS
# endif
# define machine_is_iris()	(machine_arch_type == MACH_TYPE_IRIS)
#else
# define machine_is_iris()	(0)
#endif

#ifdef CONFIG_MACH_PROTODCG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTODCG
# endif
# define machine_is_protodcg()	(machine_arch_type == MACH_TYPE_PROTODCG)
#else
# define machine_is_protodcg()	(0)
#endif

#ifdef CONFIG_MACH_PALMTREE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMTREE
# endif
# define machine_is_palmtree()	(machine_arch_type == MACH_TYPE_PALMTREE)
#else
# define machine_is_palmtree()	(0)
#endif

#ifdef CONFIG_MACH_NOVENA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOVENA
# endif
# define machine_is_novena()	(machine_arch_type == MACH_TYPE_NOVENA)
#else
# define machine_is_novena()	(0)
#endif

#ifdef CONFIG_MACH_MA_UM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MA_UM
# endif
# define machine_is_ma_um()	(machine_arch_type == MACH_TYPE_MA_UM)
#else
# define machine_is_ma_um()	(0)
#endif

#ifdef CONFIG_MACH_MA_AM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MA_AM
# endif
# define machine_is_ma_am()	(machine_arch_type == MACH_TYPE_MA_AM)
#else
# define machine_is_ma_am()	(0)
#endif

#ifdef CONFIG_MACH_EMS348
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EMS348
# endif
# define machine_is_ems348()	(machine_arch_type == MACH_TYPE_EMS348)
#else
# define machine_is_ems348()	(0)
#endif

#ifdef CONFIG_MACH_CM_FX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_FX6
# endif
# define machine_is_cm_fx6()	(machine_arch_type == MACH_TYPE_CM_FX6)
#else
# define machine_is_cm_fx6()	(0)
#endif

#ifdef CONFIG_MACH_ARNDALE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARNDALE
# endif
# define machine_is_arndale()	(machine_arch_type == MACH_TYPE_ARNDALE)
#else
# define machine_is_arndale()	(0)
#endif

#ifdef CONFIG_MACH_Q5XR5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_Q5XR5
# endif
# define machine_is_q5xr5()	(machine_arch_type == MACH_TYPE_Q5XR5)
#else
# define machine_is_q5xr5()	(0)
#endif

#ifdef CONFIG_MACH_WILLOW
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WILLOW
# endif
# define machine_is_willow()	(machine_arch_type == MACH_TYPE_WILLOW)
#else
# define machine_is_willow()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3621_ODYV3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3621_ODYV3
# endif
# define machine_is_omap3621_odyv3()	(machine_arch_type == MACH_TYPE_OMAP3621_ODYV3)
#else
# define machine_is_omap3621_odyv3()	(0)
#endif

#ifdef CONFIG_MACH_OMAPL138_PRESONUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAPL138_PRESONUS
# endif
# define machine_is_omapl138_presonus()	(machine_arch_type == MACH_TYPE_OMAPL138_PRESONUS)
#else
# define machine_is_omapl138_presonus()	(0)
#endif

#ifdef CONFIG_MACH_DVF99
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DVF99
# endif
# define machine_is_dvf99()	(machine_arch_type == MACH_TYPE_DVF99)
#else
# define machine_is_dvf99()	(0)
#endif

#ifdef CONFIG_MACH_IMPRESSION_J
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMPRESSION_J
# endif
# define machine_is_impression_j()	(machine_arch_type == MACH_TYPE_IMPRESSION_J)
#else
# define machine_is_impression_j()	(0)
#endif

#ifdef CONFIG_MACH_QBLISSA9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QBLISSA9
# endif
# define machine_is_qblissa9()	(machine_arch_type == MACH_TYPE_QBLISSA9)
#else
# define machine_is_qblissa9()	(0)
#endif

#ifdef CONFIG_MACH_ROBIN_HELIVIEW10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROBIN_HELIVIEW10
# endif
# define machine_is_robin_heliview10()	(machine_arch_type == MACH_TYPE_ROBIN_HELIVIEW10)
#else
# define machine_is_robin_heliview10()	(0)
#endif

#ifdef CONFIG_MACH_SUN7I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN7I
# endif
# define machine_is_sun7i()	(machine_arch_type == MACH_TYPE_SUN7I)
#else
# define machine_is_sun7i()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_HDMIDONGLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_HDMIDONGLE
# endif
# define machine_is_mx6q_hdmidongle()	(machine_arch_type == MACH_TYPE_MX6Q_HDMIDONGLE)
#else
# define machine_is_mx6q_hdmidongle()	(0)
#endif

#ifdef CONFIG_MACH_MX6_SID2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_SID2
# endif
# define machine_is_mx6_sid2()	(machine_arch_type == MACH_TYPE_MX6_SID2)
#else
# define machine_is_mx6_sid2()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V3
# endif
# define machine_is_helios_v3()	(machine_arch_type == MACH_TYPE_HELIOS_V3)
#else
# define machine_is_helios_v3()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V4
# endif
# define machine_is_helios_v4()	(machine_arch_type == MACH_TYPE_HELIOS_V4)
#else
# define machine_is_helios_v4()	(0)
#endif

#ifdef CONFIG_MACH_Q7_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_Q7_IMX6
# endif
# define machine_is_q7_imx6()	(machine_arch_type == MACH_TYPE_Q7_IMX6)
#else
# define machine_is_q7_imx6()	(0)
#endif

#ifdef CONFIG_MACH_ODROIDX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ODROIDX
# endif
# define machine_is_odroidx()	(machine_arch_type == MACH_TYPE_ODROIDX)
#else
# define machine_is_odroidx()	(0)
#endif

#ifdef CONFIG_MACH_ROBPRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROBPRO
# endif
# define machine_is_robpro()	(machine_arch_type == MACH_TYPE_ROBPRO)
#else
# define machine_is_robpro()	(0)
#endif

#ifdef CONFIG_MACH_RESEARCH59IF_MK1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RESEARCH59IF_MK1
# endif
# define machine_is_research59if_mk1()	(machine_arch_type == MACH_TYPE_RESEARCH59IF_MK1)
#else
# define machine_is_research59if_mk1()	(0)
#endif

#ifdef CONFIG_MACH_BOBSLEIGH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BOBSLEIGH
# endif
# define machine_is_bobsleigh()	(machine_arch_type == MACH_TYPE_BOBSLEIGH)
#else
# define machine_is_bobsleigh()	(0)
#endif

#ifdef CONFIG_MACH_DCSHGWT3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DCSHGWT3
# endif
# define machine_is_dcshgwt3()	(machine_arch_type == MACH_TYPE_DCSHGWT3)
#else
# define machine_is_dcshgwt3()	(0)
#endif

#ifdef CONFIG_MACH_GLD1018
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GLD1018
# endif
# define machine_is_gld1018()	(machine_arch_type == MACH_TYPE_GLD1018)
#else
# define machine_is_gld1018()	(0)
#endif

#ifdef CONFIG_MACH_EV10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EV10
# endif
# define machine_is_ev10()	(machine_arch_type == MACH_TYPE_EV10)
#else
# define machine_is_ev10()	(0)
#endif

#ifdef CONFIG_MACH_NITROGEN6X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NITROGEN6X
# endif
# define machine_is_nitrogen6x()	(machine_arch_type == MACH_TYPE_NITROGEN6X)
#else
# define machine_is_nitrogen6x()	(0)
#endif

#ifdef CONFIG_MACH_P_107_BB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P_107_BB
# endif
# define machine_is_p_107_bb()	(machine_arch_type == MACH_TYPE_P_107_BB)
#else
# define machine_is_p_107_bb()	(0)
#endif

#ifdef CONFIG_MACH_EVITA_UTL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EVITA_UTL
# endif
# define machine_is_evita_utl()	(machine_arch_type == MACH_TYPE_EVITA_UTL)
#else
# define machine_is_evita_utl()	(0)
#endif

#ifdef CONFIG_MACH_FALCONWING
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FALCONWING
# endif
# define machine_is_falconwing()	(machine_arch_type == MACH_TYPE_FALCONWING)
#else
# define machine_is_falconwing()	(0)
#endif

#ifdef CONFIG_MACH_DCT3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DCT3
# endif
# define machine_is_dct3()	(machine_arch_type == MACH_TYPE_DCT3)
#else
# define machine_is_dct3()	(0)
#endif

#ifdef CONFIG_MACH_CPX2E_CELL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CPX2E_CELL
# endif
# define machine_is_cpx2e_cell()	(machine_arch_type == MACH_TYPE_CPX2E_CELL)
#else
# define machine_is_cpx2e_cell()	(0)
#endif

#ifdef CONFIG_MACH_AMIRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMIRO
# endif
# define machine_is_amiro()	(machine_arch_type == MACH_TYPE_AMIRO)
#else
# define machine_is_amiro()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_BRASSBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_BRASSBOARD
# endif
# define machine_is_mx6q_brassboard()	(machine_arch_type == MACH_TYPE_MX6Q_BRASSBOARD)
#else
# define machine_is_mx6q_brassboard()	(0)
#endif

#ifdef CONFIG_MACH_DALMORE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DALMORE
# endif
# define machine_is_dalmore()	(machine_arch_type == MACH_TYPE_DALMORE)
#else
# define machine_is_dalmore()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_PORTAL7CP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_PORTAL7CP
# endif
# define machine_is_omap3_portal7cp()	(machine_arch_type == MACH_TYPE_OMAP3_PORTAL7CP)
#else
# define machine_is_omap3_portal7cp()	(0)
#endif

#ifdef CONFIG_MACH_TEGRA_PLUTO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRA_PLUTO
# endif
# define machine_is_tegra_pluto()	(machine_arch_type == MACH_TYPE_TEGRA_PLUTO)
#else
# define machine_is_tegra_pluto()	(0)
#endif

#ifdef CONFIG_MACH_MX6SL_EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6SL_EVK
# endif
# define machine_is_mx6sl_evk()	(machine_arch_type == MACH_TYPE_MX6SL_EVK)
#else
# define machine_is_mx6sl_evk()	(0)
#endif

#ifdef CONFIG_MACH_M7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7
# endif
# define machine_is_m7()	(machine_arch_type == MACH_TYPE_M7)
#else
# define machine_is_m7()	(0)
#endif

#ifdef CONFIG_MACH_PXM2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PXM2
# endif
# define machine_is_pxm2()	(machine_arch_type == MACH_TYPE_PXM2)
#else
# define machine_is_pxm2()	(0)
#endif

#ifdef CONFIG_MACH_HABA_KNX_LITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HABA_KNX_LITE
# endif
# define machine_is_haba_knx_lite()	(machine_arch_type == MACH_TYPE_HABA_KNX_LITE)
#else
# define machine_is_haba_knx_lite()	(0)
#endif

#ifdef CONFIG_MACH_TAI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAI
# endif
# define machine_is_tai()	(machine_arch_type == MACH_TYPE_TAI)
#else
# define machine_is_tai()	(0)
#endif

#ifdef CONFIG_MACH_PROTOTD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTOTD
# endif
# define machine_is_prototd()	(machine_arch_type == MACH_TYPE_PROTOTD)
#else
# define machine_is_prototd()	(0)
#endif

#ifdef CONFIG_MACH_DST_TONTO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DST_TONTO
# endif
# define machine_is_dst_tonto()	(machine_arch_type == MACH_TYPE_DST_TONTO)
#else
# define machine_is_dst_tonto()	(0)
#endif

#ifdef CONFIG_MACH_DRACO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DRACO
# endif
# define machine_is_draco()	(machine_arch_type == MACH_TYPE_DRACO)
#else
# define machine_is_draco()	(0)
#endif

#ifdef CONFIG_MACH_DXR2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DXR2
# endif
# define machine_is_dxr2()	(machine_arch_type == MACH_TYPE_DXR2)
#else
# define machine_is_dxr2()	(0)
#endif

#ifdef CONFIG_MACH_RUT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RUT
# endif
# define machine_is_rut()	(machine_arch_type == MACH_TYPE_RUT)
#else
# define machine_is_rut()	(0)
#endif

#ifdef CONFIG_MACH_AM180X_WSC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AM180X_WSC
# endif
# define machine_is_am180x_wsc()	(machine_arch_type == MACH_TYPE_AM180X_WSC)
#else
# define machine_is_am180x_wsc()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_U
# endif
# define machine_is_deluxe_u()	(machine_arch_type == MACH_TYPE_DELUXE_U)
#else
# define machine_is_deluxe_u()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_UL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_UL
# endif
# define machine_is_deluxe_ul()	(machine_arch_type == MACH_TYPE_DELUXE_UL)
#else
# define machine_is_deluxe_ul()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9260MEDTHS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9260MEDTHS
# endif
# define machine_is_at91sam9260medths()	(machine_arch_type == MACH_TYPE_AT91SAM9260MEDTHS)
#else
# define machine_is_at91sam9260medths()	(0)
#endif

#ifdef CONFIG_MACH_MATRIX516
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MATRIX516
# endif
# define machine_is_matrix516()	(machine_arch_type == MACH_TYPE_MATRIX516)
#else
# define machine_is_matrix516()	(0)
#endif

#ifdef CONFIG_MACH_VID401X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VID401X
# endif
# define machine_is_vid401x()	(machine_arch_type == MACH_TYPE_VID401X)
#else
# define machine_is_vid401x()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V5
# endif
# define machine_is_helios_v5()	(machine_arch_type == MACH_TYPE_HELIOS_V5)
#else
# define machine_is_helios_v5()	(0)
#endif

#ifdef CONFIG_MACH_PLAYPAQ2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PLAYPAQ2
# endif
# define machine_is_playpaq2()	(machine_arch_type == MACH_TYPE_PLAYPAQ2)
#else
# define machine_is_playpaq2()	(0)
#endif

#ifdef CONFIG_MACH_IGAM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGAM
# endif
# define machine_is_igam()	(machine_arch_type == MACH_TYPE_IGAM)
#else
# define machine_is_igam()	(0)
#endif

#ifdef CONFIG_MACH_AMICO_I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMICO_I
# endif
# define machine_is_amico_i()	(machine_arch_type == MACH_TYPE_AMICO_I)
#else
# define machine_is_amico_i()	(0)
#endif

#ifdef CONFIG_MACH_AMICO_E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMICO_E
# endif
# define machine_is_amico_e()	(machine_arch_type == MACH_TYPE_AMICO_E)
#else
# define machine_is_amico_e()	(0)
#endif

#ifdef CONFIG_MACH_SENTIENT_MM3_CK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SENTIENT_MM3_CK
# endif
# define machine_is_sentient_mm3_ck()	(machine_arch_type == MACH_TYPE_SENTIENT_MM3_CK)
#else
# define machine_is_sentient_mm3_ck()	(0)
#endif

#ifdef CONFIG_MACH_SMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMX6
# endif
# define machine_is_smx6()	(machine_arch_type == MACH_TYPE_SMX6)
#else
# define machine_is_smx6()	(0)
#endif

#ifdef CONFIG_MACH_PANGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PANGO
# endif
# define machine_is_pango()	(machine_arch_type == MACH_TYPE_PANGO)
#else
# define machine_is_pango()	(0)
#endif

#ifdef CONFIG_MACH_NS115_STICK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NS115_STICK
# endif
# define machine_is_ns115_stick()	(machine_arch_type == MACH_TYPE_NS115_STICK)
#else
# define machine_is_ns115_stick()	(0)
#endif

#ifdef CONFIG_MACH_BCTRM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCTRM3
# endif
# define machine_is_bctrm3()	(machine_arch_type == MACH_TYPE_BCTRM3)
#else
# define machine_is_bctrm3()	(0)
#endif

#ifdef CONFIG_MACH_DOCTORWS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOCTORWS
# endif
# define machine_is_doctorws()	(machine_arch_type == MACH_TYPE_DOCTORWS)
#else
# define machine_is_doctorws()	(0)
#endif

#ifdef CONFIG_MACH_M2601
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M2601
# endif
# define machine_is_m2601()	(machine_arch_type == MACH_TYPE_M2601)
#else
# define machine_is_m2601()	(0)
#endif

#ifdef CONFIG_MACH_VGG1111
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VGG1111
# endif
# define machine_is_vgg1111()	(machine_arch_type == MACH_TYPE_VGG1111)
#else
# define machine_is_vgg1111()	(0)
#endif

#ifdef CONFIG_MACH_COUNTACH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COUNTACH
# endif
# define machine_is_countach()	(machine_arch_type == MACH_TYPE_COUNTACH)
#else
# define machine_is_countach()	(0)
#endif

#ifdef CONFIG_MACH_VISSTRIM_SM20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VISSTRIM_SM20
# endif
# define machine_is_visstrim_sm20()	(machine_arch_type == MACH_TYPE_VISSTRIM_SM20)
#else
# define machine_is_visstrim_sm20()	(0)
#endif

#ifdef CONFIG_MACH_A639
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_A639
# endif
# define machine_is_a639()	(machine_arch_type == MACH_TYPE_A639)
#else
# define machine_is_a639()	(0)
#endif

#ifdef CONFIG_MACH_SPACEMONKEY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPACEMONKEY
# endif
# define machine_is_spacemonkey()	(machine_arch_type == MACH_TYPE_SPACEMONKEY)
#else
# define machine_is_spacemonkey()	(0)
#endif

#ifdef CONFIG_MACH_ZPDU_STAMP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZPDU_STAMP
# endif
# define machine_is_zpdu_stamp()	(machine_arch_type == MACH_TYPE_ZPDU_STAMP)
#else
# define machine_is_zpdu_stamp()	(0)
#endif

#ifdef CONFIG_MACH_HTC_G7_CLONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HTC_G7_CLONE
# endif
# define machine_is_htc_g7_clone()	(machine_arch_type == MACH_TYPE_HTC_G7_CLONE)
#else
# define machine_is_htc_g7_clone()	(0)
#endif

#ifdef CONFIG_MACH_FT2080_CORVUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FT2080_CORVUS
# endif
# define machine_is_ft2080_corvus()	(machine_arch_type == MACH_TYPE_FT2080_CORVUS)
#else
# define machine_is_ft2080_corvus()	(0)
#endif

#ifdef CONFIG_MACH_FISLAND
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FISLAND
# endif
# define machine_is_fisland()	(machine_arch_type == MACH_TYPE_FISLAND)
#else
# define machine_is_fisland()	(0)
#endif

#ifdef CONFIG_MACH_ZPDU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZPDU
# endif
# define machine_is_zpdu()	(machine_arch_type == MACH_TYPE_ZPDU)
#else
# define machine_is_zpdu()	(0)
#endif

#ifdef CONFIG_MACH_URT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_URT
# endif
# define machine_is_urt()	(machine_arch_type == MACH_TYPE_URT)
#else
# define machine_is_urt()	(0)
#endif

#ifdef CONFIG_MACH_CONTI_OVIP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CONTI_OVIP
# endif
# define machine_is_conti_ovip()	(machine_arch_type == MACH_TYPE_CONTI_OVIP)
#else
# define machine_is_conti_ovip()	(0)
#endif

#ifdef CONFIG_MACH_OMAPL138_NAGRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAPL138_NAGRA
# endif
# define machine_is_omapl138_nagra()	(machine_arch_type == MACH_TYPE_OMAPL138_NAGRA)
#else
# define machine_is_omapl138_nagra()	(0)
#endif

#ifdef CONFIG_MACH_DA850_AT3KP1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DA850_AT3KP1
# endif
# define machine_is_da850_at3kp1()	(machine_arch_type == MACH_TYPE_DA850_AT3KP1)
#else
# define machine_is_da850_at3kp1()	(0)
#endif

#ifdef CONFIG_MACH_DA850_AT3KP2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DA850_AT3KP2
# endif
# define machine_is_da850_at3kp2()	(machine_arch_type == MACH_TYPE_DA850_AT3KP2)
#else
# define machine_is_da850_at3kp2()	(0)
#endif

#ifdef CONFIG_MACH_SURMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SURMA
# endif
# define machine_is_surma()	(machine_arch_type == MACH_TYPE_SURMA)
#else
# define machine_is_surma()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2092
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2092
# endif
# define machine_is_stm_b2092()	(machine_arch_type == MACH_TYPE_STM_B2092)
#else
# define machine_is_stm_b2092()	(0)
#endif

#ifdef CONFIG_MACH_MX535_YCR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX535_YCR
# endif
# define machine_is_mx535_ycr()	(machine_arch_type == MACH_TYPE_MX535_YCR)
#else
# define machine_is_mx535_ycr()	(0)
#endif

#ifdef CONFIG_MACH_M7_WL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_WL
# endif
# define machine_is_m7_wl()	(machine_arch_type == MACH_TYPE_M7_WL)
#else
# define machine_is_m7_wl()	(0)
#endif

#ifdef CONFIG_MACH_M7_U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_U
# endif
# define machine_is_m7_u()	(machine_arch_type == MACH_TYPE_M7_U)
#else
# define machine_is_m7_u()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_STNDT_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_STNDT_EVM
# endif
# define machine_is_omap3_stndt_evm()	(machine_arch_type == MACH_TYPE_OMAP3_STNDT_EVM)
#else
# define machine_is_omap3_stndt_evm()	(0)
#endif

#ifdef CONFIG_MACH_M7_WLV
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_WLV
# endif
# define machine_is_m7_wlv()	(machine_arch_type == MACH_TYPE_M7_WLV)
#else
# define machine_is_m7_wlv()	(0)
#endif

#ifdef CONFIG_MACH_XAM3517
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XAM3517
# endif
# define machine_is_xam3517()	(machine_arch_type == MACH_TYPE_XAM3517)
#else
# define machine_is_xam3517()	(0)
#endif

#ifdef CONFIG_MACH_A220
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_A220
# endif
# define machine_is_a220()	(machine_arch_type == MACH_TYPE_A220)
#else
# define machine_is_a220()	(0)
#endif

#ifdef CONFIG_MACH_ACLIMA_ODIE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACLIMA_ODIE
# endif
# define machine_is_aclima_odie()	(machine_arch_type == MACH_TYPE_ACLIMA_ODIE)
#else
# define machine_is_aclima_odie()	(0)
#endif

#ifdef CONFIG_MACH_VIBBLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIBBLE
# endif
# define machine_is_vibble()	(machine_arch_type == MACH_TYPE_VIBBLE)
#else
# define machine_is_vibble()	(0)
#endif

#ifdef CONFIG_MACH_K2_U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_U
# endif
# define machine_is_k2_u()	(machine_arch_type == MACH_TYPE_K2_U)
#else
# define machine_is_k2_u()	(0)
#endif

#ifdef CONFIG_MACH_MX53_EGF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_EGF
# endif
# define machine_is_mx53_egf()	(machine_arch_type == MACH_TYPE_MX53_EGF)
#else
# define machine_is_mx53_egf()	(0)
#endif

#ifdef CONFIG_MACH_NOVPEK_IMX53
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOVPEK_IMX53
# endif
# define machine_is_novpek_imx53()	(machine_arch_type == MACH_TYPE_NOVPEK_IMX53)
#else
# define machine_is_novpek_imx53()	(0)
#endif

#ifdef CONFIG_MACH_NOVPEK_IMX6X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOVPEK_IMX6X
# endif
# define machine_is_novpek_imx6x()	(machine_arch_type == MACH_TYPE_NOVPEK_IMX6X)
#else
# define machine_is_novpek_imx6x()	(0)
#endif

#ifdef CONFIG_MACH_MX25_SMARTBOX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX25_SMARTBOX
# endif
# define machine_is_mx25_smartbox()	(machine_arch_type == MACH_TYPE_MX25_SMARTBOX)
#else
# define machine_is_mx25_smartbox()	(0)
#endif

#ifdef CONFIG_MACH_EICG6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EICG6410
# endif
# define machine_is_eicg6410()	(machine_arch_type == MACH_TYPE_EICG6410)
#else
# define machine_is_eicg6410()	(0)
#endif

#ifdef CONFIG_MACH_PICASSO_E3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PICASSO_E3
# endif
# define machine_is_picasso_e3()	(machine_arch_type == MACH_TYPE_PICASSO_E3)
#else
# define machine_is_picasso_e3()	(0)
#endif

#ifdef CONFIG_MACH_MOTONAVIGATOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MOTONAVIGATOR
# endif
# define machine_is_motonavigator()	(machine_arch_type == MACH_TYPE_MOTONAVIGATOR)
#else
# define machine_is_motonavigator()	(0)
#endif

#ifdef CONFIG_MACH_VARIOCONNECT2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VARIOCONNECT2
# endif
# define machine_is_varioconnect2()	(machine_arch_type == MACH_TYPE_VARIOCONNECT2)
#else
# define machine_is_varioconnect2()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_TW
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_TW
# endif
# define machine_is_deluxe_tw()	(machine_arch_type == MACH_TYPE_DELUXE_TW)
#else
# define machine_is_deluxe_tw()	(0)
#endif

#ifdef CONFIG_MACH_KORE3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KORE3
# endif
# define machine_is_kore3()	(machine_arch_type == MACH_TYPE_KORE3)
#else
# define machine_is_kore3()	(0)
#endif

#ifdef CONFIG_MACH_MX6S_DRS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6S_DRS
# endif
# define machine_is_mx6s_drs()	(machine_arch_type == MACH_TYPE_MX6S_DRS)
#else
# define machine_is_mx6s_drs()	(0)
#endif

#ifdef CONFIG_MACH_CMIMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CMIMX6
# endif
# define machine_is_cmimx6()	(machine_arch_type == MACH_TYPE_CMIMX6)
#else
# define machine_is_cmimx6()	(0)
#endif

#ifdef CONFIG_MACH_ROTH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROTH
# endif
# define machine_is_roth()	(machine_arch_type == MACH_TYPE_ROTH)
#else
# define machine_is_roth()	(0)
#endif

#ifdef CONFIG_MACH_EQ4UX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EQ4UX
# endif
# define machine_is_eq4ux()	(machine_arch_type == MACH_TYPE_EQ4UX)
#else
# define machine_is_eq4ux()	(0)
#endif

#ifdef CONFIG_MACH_X1PLUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_X1PLUS
# endif
# define machine_is_x1plus()	(machine_arch_type == MACH_TYPE_X1PLUS)
#else
# define machine_is_x1plus()	(0)
#endif

#ifdef CONFIG_MACH_MODIMX27
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MODIMX27
# endif
# define machine_is_modimx27()	(machine_arch_type == MACH_TYPE_MODIMX27)
#else
# define machine_is_modimx27()	(0)
#endif

#ifdef CONFIG_MACH_VIDEON_HDUAC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIDEON_HDUAC
# endif
# define machine_is_videon_hduac()	(machine_arch_type == MACH_TYPE_VIDEON_HDUAC)
#else
# define machine_is_videon_hduac()	(0)
#endif

#ifdef CONFIG_MACH_BLACKBIRD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BLACKBIRD
# endif
# define machine_is_blackbird()	(machine_arch_type == MACH_TYPE_BLACKBIRD)
#else
# define machine_is_blackbird()	(0)
#endif

#ifdef CONFIG_MACH_RUNMASTER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RUNMASTER
# endif
# define machine_is_runmaster()	(machine_arch_type == MACH_TYPE_RUNMASTER)
#else
# define machine_is_runmaster()	(0)
#endif

#ifdef CONFIG_MACH_CERES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CERES
# endif
# define machine_is_ceres()	(machine_arch_type == MACH_TYPE_CERES)
#else
# define machine_is_ceres()	(0)
#endif

#ifdef CONFIG_MACH_NAD435
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NAD435
# endif
# define machine_is_nad435()	(machine_arch_type == MACH_TYPE_NAD435)
#else
# define machine_is_nad435()	(0)
#endif

#ifdef CONFIG_MACH_NS115_PROTO_TYPE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NS115_PROTO_TYPE
# endif
# define machine_is_ns115_proto_type()	(machine_arch_type == MACH_TYPE_NS115_PROTO_TYPE)
#else
# define machine_is_ns115_proto_type()	(0)
#endif

#ifdef CONFIG_MACH_FS20_VCC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FS20_VCC
# endif
# define machine_is_fs20_vcc()	(machine_arch_type == MACH_TYPE_FS20_VCC)
#else
# define machine_is_fs20_vcc()	(0)
#endif

#ifdef CONFIG_MACH_MESON6TV_SKT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MESON6TV_SKT
# endif
# define machine_is_meson6tv_skt()	(machine_arch_type == MACH_TYPE_MESON6TV_SKT)
#else
# define machine_is_meson6tv_skt()	(0)
#endif

#ifdef CONFIG_MACH_KEYSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KEYSTONE
# endif
# define machine_is_keystone()	(machine_arch_type == MACH_TYPE_KEYSTONE)
#else
# define machine_is_keystone()	(0)
#endif

#ifdef CONFIG_MACH_PCM052
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM052
# endif
# define machine_is_pcm052()	(machine_arch_type == MACH_TYPE_PCM052)
#else
# define machine_is_pcm052()	(0)
#endif

#ifdef CONFIG_MACH_QRD_SKUD_PRIME
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QRD_SKUD_PRIME
# endif
# define machine_is_qrd_skud_prime()	(machine_arch_type == MACH_TYPE_QRD_SKUD_PRIME)
#else
# define machine_is_qrd_skud_prime()	(0)
#endif

#ifdef CONFIG_MACH_GUF_SANTARO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GUF_SANTARO
# endif
# define machine_is_guf_santaro()	(machine_arch_type == MACH_TYPE_GUF_SANTARO)
#else
# define machine_is_guf_santaro()	(0)
#endif

#ifdef CONFIG_MACH_SHEEPSHEAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHEEPSHEAD
# endif
# define machine_is_sheepshead()	(machine_arch_type == MACH_TYPE_SHEEPSHEAD)
#else
# define machine_is_sheepshead()	(0)
#endif

#ifdef CONFIG_MACH_MX6_IWG15M_MXM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_IWG15M_MXM
# endif
# define machine_is_mx6_iwg15m_mxm()	(machine_arch_type == MACH_TYPE_MX6_IWG15M_MXM)
#else
# define machine_is_mx6_iwg15m_mxm()	(0)
#endif

#ifdef CONFIG_MACH_MX6_IWG15M_Q7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_IWG15M_Q7
# endif
# define machine_is_mx6_iwg15m_q7()	(machine_arch_type == MACH_TYPE_MX6_IWG15M_Q7)
#else
# define machine_is_mx6_iwg15m_q7()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9263IF8MIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9263IF8MIC
# endif
# define machine_is_at91sam9263if8mic()	(machine_arch_type == MACH_TYPE_AT91SAM9263IF8MIC)
#else
# define machine_is_at91sam9263if8mic()	(0)
#endif

#ifdef CONFIG_MACH_MARCOPOLO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MARCOPOLO
# endif
# define machine_is_marcopolo()	(machine_arch_type == MACH_TYPE_MARCOPOLO)
#else
# define machine_is_marcopolo()	(0)
#endif

#ifdef CONFIG_MACH_MX535_SDCR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX535_SDCR
# endif
# define machine_is_mx535_sdcr()	(machine_arch_type == MACH_TYPE_MX535_SDCR)
#else
# define machine_is_mx535_sdcr()	(0)
#endif

#ifdef CONFIG_MACH_MX53_CSB2733
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_CSB2733
# endif
# define machine_is_mx53_csb2733()	(machine_arch_type == MACH_TYPE_MX53_CSB2733)
#else
# define machine_is_mx53_csb2733()	(0)
#endif

#ifdef CONFIG_MACH_DIVA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DIVA
# endif
# define machine_is_diva()	(machine_arch_type == MACH_TYPE_DIVA)
#else
# define machine_is_diva()	(0)
#endif

#ifdef CONFIG_MACH_NCR_7744
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NCR_7744
# endif
# define machine_is_ncr_7744()	(machine_arch_type == MACH_TYPE_NCR_7744)
#else
# define machine_is_ncr_7744()	(0)
#endif

#ifdef CONFIG_MACH_MACALLAN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MACALLAN
# endif
# define machine_is_macallan()	(machine_arch_type == MACH_TYPE_MACALLAN)
#else
# define machine_is_macallan()	(0)
#endif

#ifdef CONFIG_MACH_WNR3500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WNR3500
# endif
# define machine_is_wnr3500()	(machine_arch_type == MACH_TYPE_WNR3500)
#else
# define machine_is_wnr3500()	(0)
#endif

#ifdef CONFIG_MACH_PGAVRF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PGAVRF
# endif
# define machine_is_pgavrf()	(machine_arch_type == MACH_TYPE_PGAVRF)
#else
# define machine_is_pgavrf()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V6
# endif
# define machine_is_helios_v6()	(machine_arch_type == MACH_TYPE_HELIOS_V6)
#else
# define machine_is_helios_v6()	(0)
#endif

#ifdef CONFIG_MACH_LCCT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LCCT
# endif
# define machine_is_lcct()	(machine_arch_type == MACH_TYPE_LCCT)
#else
# define machine_is_lcct()	(0)
#endif

#ifdef CONFIG_MACH_CSNDUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CSNDUG
# endif
# define machine_is_csndug()	(machine_arch_type == MACH_TYPE_CSNDUG)
#else
# define machine_is_csndug()	(0)
#endif

#ifdef CONFIG_MACH_WANDBOARD_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WANDBOARD_IMX6
# endif
# define machine_is_wandboard_imx6()	(machine_arch_type == MACH_TYPE_WANDBOARD_IMX6)
#else
# define machine_is_wandboard_imx6()	(0)
#endif

#ifdef CONFIG_MACH_OMAP4_JET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP4_JET
# endif
# define machine_is_omap4_jet()	(machine_arch_type == MACH_TYPE_OMAP4_JET)
#else
# define machine_is_omap4_jet()	(0)
#endif

#ifdef CONFIG_MACH_TEGRA_ROTH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRA_ROTH
# endif
# define machine_is_tegra_roth()	(machine_arch_type == MACH_TYPE_TEGRA_ROTH)
#else
# define machine_is_tegra_roth()	(0)
#endif

#ifdef CONFIG_MACH_M7DCG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7DCG
# endif
# define machine_is_m7dcg()	(machine_arch_type == MACH_TYPE_M7DCG)
#else
# define machine_is_m7dcg()	(0)
#endif

#ifdef CONFIG_MACH_M7DUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7DUG
# endif
# define machine_is_m7dug()	(machine_arch_type == MACH_TYPE_M7DUG)
#else
# define machine_is_m7dug()	(0)
#endif

#ifdef CONFIG_MACH_M7DTG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7DTG
# endif
# define machine_is_m7dtg()	(machine_arch_type == MACH_TYPE_M7DTG)
#else
# define machine_is_m7dtg()	(0)
#endif

#ifdef CONFIG_MACH_AP42X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AP42X
# endif
# define machine_is_ap42x()	(machine_arch_type == MACH_TYPE_AP42X)
#else
# define machine_is_ap42x()	(0)
#endif

#ifdef CONFIG_MACH_VAR_SOM_MX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VAR_SOM_MX6
# endif
# define machine_is_var_som_mx6()	(machine_arch_type == MACH_TYPE_VAR_SOM_MX6)
#else
# define machine_is_var_som_mx6()	(0)
#endif

#ifdef CONFIG_MACH_PDLU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PDLU
# endif
# define machine_is_pdlu()	(machine_arch_type == MACH_TYPE_PDLU)
#else
# define machine_is_pdlu()	(0)
#endif

#ifdef CONFIG_MACH_HYDROGEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HYDROGEN
# endif
# define machine_is_hydrogen()	(machine_arch_type == MACH_TYPE_HYDROGEN)
#else
# define machine_is_hydrogen()	(0)
#endif

#ifdef CONFIG_MACH_NPA211E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NPA211E
# endif
# define machine_is_npa211e()	(machine_arch_type == MACH_TYPE_NPA211E)
#else
# define machine_is_npa211e()	(0)
#endif

#ifdef CONFIG_MACH_ARCADIA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARCADIA
# endif
# define machine_is_arcadia()	(machine_arch_type == MACH_TYPE_ARCADIA)
#else
# define machine_is_arcadia()	(0)
#endif

#ifdef CONFIG_MACH_ARCADIA_L
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARCADIA_L
# endif
# define machine_is_arcadia_l()	(machine_arch_type == MACH_TYPE_ARCADIA_L)
#else
# define machine_is_arcadia_l()	(0)
#endif

#ifdef CONFIG_MACH_MSM8930DT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8930DT
# endif
# define machine_is_msm8930dt()	(machine_arch_type == MACH_TYPE_MSM8930DT)
#else
# define machine_is_msm8930dt()	(0)
#endif

#ifdef CONFIG_MACH_KTAM3874
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KTAM3874
# endif
# define machine_is_ktam3874()	(machine_arch_type == MACH_TYPE_KTAM3874)
#else
# define machine_is_ktam3874()	(0)
#endif

#ifdef CONFIG_MACH_CEC4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CEC4
# endif
# define machine_is_cec4()	(machine_arch_type == MACH_TYPE_CEC4)
#else
# define machine_is_cec4()	(0)
#endif

#ifdef CONFIG_MACH_APE6EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APE6EVM
# endif
# define machine_is_ape6evm()	(machine_arch_type == MACH_TYPE_APE6EVM)
#else
# define machine_is_ape6evm()	(0)
#endif

#ifdef CONFIG_MACH_TX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TX6
# endif
# define machine_is_tx6()	(machine_arch_type == MACH_TYPE_TX6)
#else
# define machine_is_tx6()	(0)
#endif

#ifdef CONFIG_MACH_CFA10037
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CFA10037
# endif
# define machine_is_cfa10037()	(machine_arch_type == MACH_TYPE_CFA10037)
#else
# define machine_is_cfa10037()	(0)
#endif

#ifdef CONFIG_MACH_EZP1000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZP1000
# endif
# define machine_is_ezp1000()	(machine_arch_type == MACH_TYPE_EZP1000)
#else
# define machine_is_ezp1000()	(0)
#endif

#ifdef CONFIG_MACH_WGR826V
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WGR826V
# endif
# define machine_is_wgr826v()	(machine_arch_type == MACH_TYPE_WGR826V)
#else
# define machine_is_wgr826v()	(0)
#endif

#ifdef CONFIG_MACH_EXUMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EXUMA
# endif
# define machine_is_exuma()	(machine_arch_type == MACH_TYPE_EXUMA)
#else
# define machine_is_exuma()	(0)
#endif

#ifdef CONFIG_MACH_FREGATE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FREGATE
# endif
# define machine_is_fregate()	(machine_arch_type == MACH_TYPE_FREGATE)
#else
# define machine_is_fregate()	(0)
#endif

#ifdef CONFIG_MACH_OSIRISIMX508
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OSIRISIMX508
# endif
# define machine_is_osirisimx508()	(machine_arch_type == MACH_TYPE_OSIRISIMX508)
#else
# define machine_is_osirisimx508()	(0)
#endif

#ifdef CONFIG_MACH_ST_EXIGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ST_EXIGO
# endif
# define machine_is_st_exigo()	(machine_arch_type == MACH_TYPE_ST_EXIGO)
#else
# define machine_is_st_exigo()	(0)
#endif

#ifdef CONFIG_MACH_PISMO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PISMO
# endif
# define machine_is_pismo()	(machine_arch_type == MACH_TYPE_PISMO)
#else
# define machine_is_pismo()	(0)
#endif

#ifdef CONFIG_MACH_ATC7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ATC7
# endif
# define machine_is_atc7()	(machine_arch_type == MACH_TYPE_ATC7)
#else
# define machine_is_atc7()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRECLP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRECLP
# endif
# define machine_is_nspireclp()	(machine_arch_type == MACH_TYPE_NSPIRECLP)
#else
# define machine_is_nspireclp()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRETP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRETP
# endif
# define machine_is_nspiretp()	(machine_arch_type == MACH_TYPE_NSPIRETP)
#else
# define machine_is_nspiretp()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRECX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRECX
# endif
# define machine_is_nspirecx()	(machine_arch_type == MACH_TYPE_NSPIRECX)
#else
# define machine_is_nspirecx()	(0)
#endif

#ifdef CONFIG_MACH_MAYA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAYA
# endif
# define machine_is_maya()	(machine_arch_type == MACH_TYPE_MAYA)
#else
# define machine_is_maya()	(0)
#endif

#ifdef CONFIG_MACH_WECCT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WECCT
# endif
# define machine_is_wecct()	(machine_arch_type == MACH_TYPE_WECCT)
#else
# define machine_is_wecct()	(0)
#endif

#ifdef CONFIG_MACH_M2S
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M2S
# endif
# define machine_is_m2s()	(machine_arch_type == MACH_TYPE_M2S)
#else
# define machine_is_m2s()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625Q_EVBD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625Q_EVBD
# endif
# define machine_is_msm8625q_evbd()	(machine_arch_type == MACH_TYPE_MSM8625Q_EVBD)
#else
# define machine_is_msm8625q_evbd()	(0)
#endif

#ifdef CONFIG_MACH_TINY210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TINY210
# endif
# define machine_is_tiny210()	(machine_arch_type == MACH_TYPE_TINY210)
#else
# define machine_is_tiny210()	(0)
#endif

#ifdef CONFIG_MACH_G3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_G3
# endif
# define machine_is_g3()	(machine_arch_type == MACH_TYPE_G3)
#else
# define machine_is_g3()	(0)
#endif

#ifdef CONFIG_MACH_HURRICANE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HURRICANE
# endif
# define machine_is_hurricane()	(machine_arch_type == MACH_TYPE_HURRICANE)
#else
# define machine_is_hurricane()	(0)
#endif

#ifdef CONFIG_MACH_MX6_POD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_POD
# endif
# define machine_is_mx6_pod()	(machine_arch_type == MACH_TYPE_MX6_POD)
#else
# define machine_is_mx6_pod()	(0)
#endif

#ifdef CONFIG_MACH_ELONDCN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ELONDCN
# endif
# define machine_is_elondcn()	(machine_arch_type == MACH_TYPE_ELONDCN)
#else
# define machine_is_elondcn()	(0)
#endif

#ifdef CONFIG_MACH_CWMX535
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CWMX535
# endif
# define machine_is_cwmx535()	(machine_arch_type == MACH_TYPE_CWMX535)
#else
# define machine_is_cwmx535()	(0)
#endif

#ifdef CONFIG_MACH_M7_WLJ
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_WLJ
# endif
# define machine_is_m7_wlj()	(machine_arch_type == MACH_TYPE_M7_WLJ)
#else
# define machine_is_m7_wlj()	(0)
#endif

#ifdef CONFIG_MACH_QSP_ARM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSP_ARM
# endif
# define machine_is_qsp_arm()	(machine_arch_type == MACH_TYPE_QSP_ARM)
#else
# define machine_is_qsp_arm()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625Q_SKUD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625Q_SKUD
# endif
# define machine_is_msm8625q_skud()	(machine_arch_type == MACH_TYPE_MSM8625Q_SKUD)
#else
# define machine_is_msm8625q_skud()	(0)
#endif

#ifdef CONFIG_MACH_HTCMONDRIAN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HTCMONDRIAN
# endif
# define machine_is_htcmondrian()	(machine_arch_type == MACH_TYPE_HTCMONDRIAN)
#else
# define machine_is_htcmondrian()	(0)
#endif

#ifdef CONFIG_MACH_WATSON_EAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WATSON_EAD
# endif
# define machine_is_watson_ead()	(machine_arch_type == MACH_TYPE_WATSON_EAD)
#else
# define machine_is_watson_ead()	(0)
#endif

#ifdef CONFIG_MACH_MITWOA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MITWOA
# endif
# define machine_is_mitwoa()	(machine_arch_type == MACH_TYPE_MITWOA)
#else
# define machine_is_mitwoa()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_WOLVERINE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_WOLVERINE
# endif
# define machine_is_omap3_wolverine()	(machine_arch_type == MACH_TYPE_OMAP3_WOLVERINE)
#else
# define machine_is_omap3_wolverine()	(0)
#endif

#ifdef CONFIG_MACH_MAPLETREE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAPLETREE
# endif
# define machine_is_mapletree()	(machine_arch_type == MACH_TYPE_MAPLETREE)
#else
# define machine_is_mapletree()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625_FIH_SAE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625_FIH_SAE
# endif
# define machine_is_msm8625_fih_sae()	(machine_arch_type == MACH_TYPE_MSM8625_FIH_SAE)
#else
# define machine_is_msm8625_fih_sae()	(0)
#endif

#ifdef CONFIG_MACH_EPC35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EPC35
# endif
# define machine_is_epc35()	(machine_arch_type == MACH_TYPE_EPC35)
#else
# define machine_is_epc35()	(0)
#endif

#ifdef CONFIG_MACH_SMARTRTU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMARTRTU
# endif
# define machine_is_smartrtu()	(machine_arch_type == MACH_TYPE_SMARTRTU)
#else
# define machine_is_smartrtu()	(0)
#endif

#ifdef CONFIG_MACH_RCM101
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RCM101
# endif
# define machine_is_rcm101()	(machine_arch_type == MACH_TYPE_RCM101)
#else
# define machine_is_rcm101()	(0)
#endif

#ifdef CONFIG_MACH_AMX_IMX53_MXX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMX_IMX53_MXX
# endif
# define machine_is_amx_imx53_mxx()	(machine_arch_type == MACH_TYPE_AMX_IMX53_MXX)
#else
# define machine_is_amx_imx53_mxx()	(0)
#endif

#ifdef CONFIG_MACH_ACER_A12
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACER_A12
# endif
# define machine_is_acer_a12()	(machine_arch_type == MACH_TYPE_ACER_A12)
#else
# define machine_is_acer_a12()	(0)
#endif

#ifdef CONFIG_MACH_SBC6X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SBC6X
# endif
# define machine_is_sbc6x()	(machine_arch_type == MACH_TYPE_SBC6X)
#else
# define machine_is_sbc6x()	(0)
#endif

#ifdef CONFIG_MACH_U2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U2
# endif
# define machine_is_u2()	(machine_arch_type == MACH_TYPE_U2)
#else
# define machine_is_u2()	(0)
#endif

#ifdef CONFIG_MACH_SMDK4270
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK4270
# endif
# define machine_is_smdk4270()	(machine_arch_type == MACH_TYPE_SMDK4270)
#else
# define machine_is_smdk4270()	(0)
#endif

#ifdef CONFIG_MACH_PRISCILLAG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRISCILLAG
# endif
# define machine_is_priscillag()	(machine_arch_type == MACH_TYPE_PRISCILLAG)
#else
# define machine_is_priscillag()	(0)
#endif

#ifdef CONFIG_MACH_PRISCILLAC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRISCILLAC
# endif
# define machine_is_priscillac()	(machine_arch_type == MACH_TYPE_PRISCILLAC)
#else
# define machine_is_priscillac()	(0)
#endif

#ifdef CONFIG_MACH_PRISCILLA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRISCILLA
# endif
# define machine_is_priscilla()	(machine_arch_type == MACH_TYPE_PRISCILLA)
#else
# define machine_is_priscilla()	(0)
#endif

#ifdef CONFIG_MACH_INNOVA_SHPU_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INNOVA_SHPU_V2
# endif
# define machine_is_innova_shpu_v2()	(machine_arch_type == MACH_TYPE_INNOVA_SHPU_V2)
#else
# define machine_is_innova_shpu_v2()	(0)
#endif

#ifdef CONFIG_MACH_MACH_TYPE_DEP2410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MACH_TYPE_DEP2410
# endif
# define machine_is_mach_type_dep2410()	(machine_arch_type == MACH_TYPE_MACH_TYPE_DEP2410)
#else
# define machine_is_mach_type_dep2410()	(0)
#endif

#ifdef CONFIG_MACH_BCTRE3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCTRE3
# endif
# define machine_is_bctre3()	(machine_arch_type == MACH_TYPE_BCTRE3)
#else
# define machine_is_bctre3()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_M100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_M100
# endif
# define machine_is_omap_m100()	(machine_arch_type == MACH_TYPE_OMAP_M100)
#else
# define machine_is_omap_m100()	(0)
#endif

#ifdef CONFIG_MACH_FLO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLO
# endif
# define machine_is_flo()	(machine_arch_type == MACH_TYPE_FLO)
#else
# define machine_is_flo()	(0)
#endif

#ifdef CONFIG_MACH_NANOBONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NANOBONE
# endif
# define machine_is_nanobone()	(machine_arch_type == MACH_TYPE_NANOBONE)
#else
# define machine_is_nanobone()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2105
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2105
# endif
# define machine_is_stm_b2105()	(machine_arch_type == MACH_TYPE_STM_B2105)
#else
# define machine_is_stm_b2105()	(0)
#endif

#ifdef CONFIG_MACH_OMAP4_BSC_BAP_V3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP4_BSC_BAP_V3
# endif
# define machine_is_omap4_bsc_bap_v3()	(machine_arch_type == MACH_TYPE_OMAP4_BSC_BAP_V3)
#else
# define machine_is_omap4_bsc_bap_v3()	(0)
#endif

#ifdef CONFIG_MACH_SS1PAM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SS1PAM
# endif
# define machine_is_ss1pam()	(machine_arch_type == MACH_TYPE_SS1PAM)
#else
# define machine_is_ss1pam()	(0)
#endif

#ifdef CONFIG_MACH_PRIMOMINIU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRIMOMINIU
# endif
# define machine_is_primominiu()	(machine_arch_type == MACH_TYPE_PRIMOMINIU)
#else
# define machine_is_primominiu()	(0)
#endif

#ifdef CONFIG_MACH_MRT_35HD_DUALNAS_E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MRT_35HD_DUALNAS_E
# endif
# define machine_is_mrt_35hd_dualnas_e()	(machine_arch_type == MACH_TYPE_MRT_35HD_DUALNAS_E)
#else
# define machine_is_mrt_35hd_dualnas_e()	(0)
#endif

#ifdef CONFIG_MACH_KIWI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KIWI
# endif
# define machine_is_kiwi()	(machine_arch_type == MACH_TYPE_KIWI)
#else
# define machine_is_kiwi()	(0)
#endif

#ifdef CONFIG_MACH_HW90496
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HW90496
# endif
# define machine_is_hw90496()	(machine_arch_type == MACH_TYPE_HW90496)
#else
# define machine_is_hw90496()	(0)
#endif

#ifdef CONFIG_MACH_MEP2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MEP2440
# endif
# define machine_is_mep2440()	(machine_arch_type == MACH_TYPE_MEP2440)
#else
# define machine_is_mep2440()	(0)
#endif

#ifdef CONFIG_MACH_COLIBRI_T30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLIBRI_T30
# endif
# define machine_is_colibri_t30()	(machine_arch_type == MACH_TYPE_COLIBRI_T30)
#else
# define machine_is_colibri_t30()	(0)
#endif

#ifdef CONFIG_MACH_CWV1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CWV1
# endif
# define machine_is_cwv1()	(machine_arch_type == MACH_TYPE_CWV1)
#else
# define machine_is_cwv1()	(0)
#endif

#ifdef CONFIG_MACH_NSA325
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSA325
# endif
# define machine_is_nsa325()	(machine_arch_type == MACH_TYPE_NSA325)
#else
# define machine_is_nsa325()	(0)
#endif

#ifdef CONFIG_MACH_DPXMTC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DPXMTC
# endif
# define machine_is_dpxmtc()	(machine_arch_type == MACH_TYPE_DPXMTC)
#else
# define machine_is_dpxmtc()	(0)
#endif

#ifdef CONFIG_MACH_TT_STUTTGART
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TT_STUTTGART
# endif
# define machine_is_tt_stuttgart()	(machine_arch_type == MACH_TYPE_TT_STUTTGART)
#else
# define machine_is_tt_stuttgart()	(0)
#endif

#ifdef CONFIG_MACH_MIRANDA_APCII
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIRANDA_APCII
# endif
# define machine_is_miranda_apcii()	(machine_arch_type == MACH_TYPE_MIRANDA_APCII)
#else
# define machine_is_miranda_apcii()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_MODEROX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_MODEROX
# endif
# define machine_is_mx6q_moderox()	(machine_arch_type == MACH_TYPE_MX6Q_MODEROX)
#else
# define machine_is_mx6q_moderox()	(0)
#endif

#ifdef CONFIG_MACH_MUDSKIPPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MUDSKIPPER
# endif
# define machine_is_mudskipper()	(machine_arch_type == MACH_TYPE_MUDSKIPPER)
#else
# define machine_is_mudskipper()	(0)
#endif

#ifdef CONFIG_MACH_URANIA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_URANIA
# endif
# define machine_is_urania()	(machine_arch_type == MACH_TYPE_URANIA)
#else
# define machine_is_urania()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2112
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2112
# endif
# define machine_is_stm_b2112()	(machine_arch_type == MACH_TYPE_STM_B2112)
#else
# define machine_is_stm_b2112()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_ATS_PHOENIX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_ATS_PHOENIX
# endif
# define machine_is_mx6q_ats_phoenix()	(machine_arch_type == MACH_TYPE_MX6Q_ATS_PHOENIX)
#else
# define machine_is_mx6q_ats_phoenix()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2116
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2116
# endif
# define machine_is_stm_b2116()	(machine_arch_type == MACH_TYPE_STM_B2116)
#else
# define machine_is_stm_b2116()	(0)
#endif

#ifdef CONFIG_MACH_MYTHOLOGY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MYTHOLOGY
# endif
# define machine_is_mythology()	(machine_arch_type == MACH_TYPE_MYTHOLOGY)
#else
# define machine_is_mythology()	(0)
#endif

#ifdef CONFIG_MACH_FC360V1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FC360V1
# endif
# define machine_is_fc360v1()	(machine_arch_type == MACH_TYPE_FC360V1)
#else
# define machine_is_fc360v1()	(0)
#endif

#ifdef CONFIG_MACH_GPS_SENSOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GPS_SENSOR
# endif
# define machine_is_gps_sensor()	(machine_arch_type == MACH_TYPE_GPS_SENSOR)
#else
# define machine_is_gps_sensor()	(0)
#endif

#ifdef CONFIG_MACH_GAZELLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GAZELLE
# endif
# define machine_is_gazelle()	(machine_arch_type == MACH_TYPE_GAZELLE)
#else
# define machine_is_gazelle()	(0)
#endif

#ifdef CONFIG_MACH_MPQ8064_DMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MPQ8064_DMA
# endif
# define machine_is_mpq8064_dma()	(machine_arch_type == MACH_TYPE_MPQ8064_DMA)
#else
# define machine_is_mpq8064_dma()	(0)
#endif

#ifdef CONFIG_MACH_WEMS_ASD01
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WEMS_ASD01
# endif
# define machine_is_wems_asd01()	(machine_arch_type == MACH_TYPE_WEMS_ASD01)
#else
# define machine_is_wems_asd01()	(0)
#endif

#ifdef CONFIG_MACH_APALIS_T30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APALIS_T30
# endif
# define machine_is_apalis_t30()	(machine_arch_type == MACH_TYPE_APALIS_T30)
#else
# define machine_is_apalis_t30()	(0)
#endif

#ifdef CONFIG_MACH_ARMSTONEA9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMSTONEA9
# endif
# define machine_is_armstonea9()	(machine_arch_type == MACH_TYPE_ARMSTONEA9)
#else
# define machine_is_armstonea9()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_BLAZETABLET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_BLAZETABLET
# endif
# define machine_is_omap_blazetablet()	(machine_arch_type == MACH_TYPE_OMAP_BLAZETABLET)
#else
# define machine_is_omap_blazetablet()	(0)
#endif

#ifdef CONFIG_MACH_AR6MXQ
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AR6MXQ
# endif
# define machine_is_ar6mxq()	(machine_arch_type == MACH_TYPE_AR6MXQ)
#else
# define machine_is_ar6mxq()	(0)
#endif

#ifdef CONFIG_MACH_AR6MXS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AR6MXS
# endif
# define machine_is_ar6mxs()	(machine_arch_type == MACH_TYPE_AR6MXS)
#else
# define machine_is_ar6mxs()	(0)
#endif

#ifdef CONFIG_MACH_GWVENTANA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GWVENTANA
# endif
# define machine_is_gwventana()	(machine_arch_type == MACH_TYPE_GWVENTANA)
#else
# define machine_is_gwventana()	(0)
#endif

#ifdef CONFIG_MACH_IGEP0033
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGEP0033
# endif
# define machine_is_igep0033()	(machine_arch_type == MACH_TYPE_IGEP0033)
#else
# define machine_is_igep0033()	(0)
#endif

#ifdef CONFIG_MACH_H52C1_CONCERTO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H52C1_CONCERTO
# endif
# define machine_is_h52c1_concerto()	(machine_arch_type == MACH_TYPE_H52C1_CONCERTO)
#else
# define machine_is_h52c1_concerto()	(0)
#endif

#ifdef CONFIG_MACH_FCMBRD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FCMBRD
# endif
# define machine_is_fcmbrd()	(machine_arch_type == MACH_TYPE_FCMBRD)
#else
# define machine_is_fcmbrd()	(0)
#endif

#ifdef CONFIG_MACH_PCAAXS1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCAAXS1
# endif
# define machine_is_pcaaxs1()	(machine_arch_type == MACH_TYPE_PCAAXS1)
#else
# define machine_is_pcaaxs1()	(0)
#endif

#ifdef CONFIG_MACH_LS_ORCA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LS_ORCA
# endif
# define machine_is_ls_orca()	(machine_arch_type == MACH_TYPE_LS_ORCA)
#else
# define machine_is_ls_orca()	(0)
#endif

#ifdef CONFIG_MACH_PCM051LB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM051LB
# endif
# define machine_is_pcm051lb()	(machine_arch_type == MACH_TYPE_PCM051LB)
#else
# define machine_is_pcm051lb()	(0)
#endif

#ifdef CONFIG_MACH_MX6S_LP507_GVCI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6S_LP507_GVCI
# endif
# define machine_is_mx6s_lp507_gvci()	(machine_arch_type == MACH_TYPE_MX6S_LP507_GVCI)
#else
# define machine_is_mx6s_lp507_gvci()	(0)
#endif

#ifdef CONFIG_MACH_DIDO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DIDO
# endif
# define machine_is_dido()	(machine_arch_type == MACH_TYPE_DIDO)
#else
# define machine_is_dido()	(0)
#endif

#ifdef CONFIG_MACH_SWARCO_ITC3_9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SWARCO_ITC3_9G20
# endif
# define machine_is_swarco_itc3_9g20()	(machine_arch_type == MACH_TYPE_SWARCO_ITC3_9G20)
#else
# define machine_is_swarco_itc3_9g20()	(0)
#endif

#ifdef CONFIG_MACH_ROBO_ROADY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROBO_ROADY
# endif
# define machine_is_robo_roady()	(machine_arch_type == MACH_TYPE_ROBO_ROADY)
#else
# define machine_is_robo_roady()	(0)
#endif

#ifdef CONFIG_MACH_RSKRZA1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RSKRZA1
# endif
# define machine_is_rskrza1()	(machine_arch_type == MACH_TYPE_RSKRZA1)
#else
# define machine_is_rskrza1()	(0)
#endif

#ifdef CONFIG_MACH_SWARCO_SID
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SWARCO_SID
# endif
# define machine_is_swarco_sid()	(machine_arch_type == MACH_TYPE_SWARCO_SID)
#else
# define machine_is_swarco_sid()	(0)
#endif

#ifdef CONFIG_MACH_MX6_IWG15S_SBC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_IWG15S_SBC
# endif
# define machine_is_mx6_iwg15s_sbc()	(machine_arch_type == MACH_TYPE_MX6_IWG15S_SBC)
#else
# define machine_is_mx6_iwg15s_sbc()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_CAMARO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_CAMARO
# endif
# define machine_is_mx6q_camaro()	(machine_arch_type == MACH_TYPE_MX6Q_CAMARO)
#else
# define machine_is_mx6q_camaro()	(0)
#endif

#ifdef CONFIG_MACH_HB6MXS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HB6MXS
# endif
# define machine_is_hb6mxs()	(machine_arch_type == MACH_TYPE_HB6MXS)
#else
# define machine_is_hb6mxs()	(0)
#endif

#ifdef CONFIG_MACH_LAGER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LAGER
# endif
# define machine_is_lager()	(machine_arch_type == MACH_TYPE_LAGER)
#else
# define machine_is_lager()	(0)
#endif

#ifdef CONFIG_MACH_LP8X4X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LP8X4X
# endif
# define machine_is_lp8x4x()	(machine_arch_type == MACH_TYPE_LP8X4X)
#else
# define machine_is_lp8x4x()	(0)
#endif

#ifdef CONFIG_MACH_TEGRATAB7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRATAB7
# endif
# define machine_is_tegratab7()	(machine_arch_type == MACH_TYPE_TEGRATAB7)
#else
# define machine_is_tegratab7()	(0)
#endif

#ifdef CONFIG_MACH_ANDROMEDA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANDROMEDA
# endif
# define machine_is_andromeda()	(machine_arch_type == MACH_TYPE_ANDROMEDA)
#else
# define machine_is_andromeda()	(0)
#endif

#ifdef CONFIG_MACH_BOOTES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BOOTES
# endif
# define machine_is_bootes()	(machine_arch_type == MACH_TYPE_BOOTES)
#else
# define machine_is_bootes()	(0)
#endif

#ifdef CONFIG_MACH_NETHMI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETHMI
# endif
# define machine_is_nethmi()	(machine_arch_type == MACH_TYPE_NETHMI)
#else
# define machine_is_nethmi()	(0)
#endif

#ifdef CONFIG_MACH_TEGRATAB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRATAB
# endif
# define machine_is_tegratab()	(machine_arch_type == MACH_TYPE_TEGRATAB)
#else
# define machine_is_tegratab()	(0)
#endif

#ifdef CONFIG_MACH_SOM5_EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOM5_EVB
# endif
# define machine_is_som5_evb()	(machine_arch_type == MACH_TYPE_SOM5_EVB)
#else
# define machine_is_som5_evb()	(0)
#endif

#ifdef CONFIG_MACH_VENATICORUM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VENATICORUM
# endif
# define machine_is_venaticorum()	(machine_arch_type == MACH_TYPE_VENATICORUM)
#else
# define machine_is_venaticorum()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2110
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2110
# endif
# define machine_is_stm_b2110()	(machine_arch_type == MACH_TYPE_STM_B2110)
#else
# define machine_is_stm_b2110()	(0)
#endif

#ifdef CONFIG_MACH_ELUX_HATHOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ELUX_HATHOR
# endif
# define machine_is_elux_hathor()	(machine_arch_type == MACH_TYPE_ELUX_HATHOR)
#else
# define machine_is_elux_hathor()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V7
# endif
# define machine_is_helios_v7()	(machine_arch_type == MACH_TYPE_HELIOS_V7)
#else
# define machine_is_helios_v7()	(0)
#endif

#ifdef CONFIG_MACH_XC10V1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XC10V1
# endif
# define machine_is_xc10v1()	(machine_arch_type == MACH_TYPE_XC10V1)
#else
# define machine_is_xc10v1()	(0)
#endif

#ifdef CONFIG_MACH_CP2U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2U
# endif
# define machine_is_cp2u()	(machine_arch_type == MACH_TYPE_CP2U)
#else
# define machine_is_cp2u()	(0)
#endif

#ifdef CONFIG_MACH_IAP_F
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IAP_F
# endif
# define machine_is_iap_f()	(machine_arch_type == MACH_TYPE_IAP_F)
#else
# define machine_is_iap_f()	(0)
#endif

#ifdef CONFIG_MACH_IAP_G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IAP_G
# endif
# define machine_is_iap_g()	(machine_arch_type == MACH_TYPE_IAP_G)
#else
# define machine_is_iap_g()	(0)
#endif

#ifdef CONFIG_MACH_AAE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AAE
# endif
# define machine_is_aae()	(machine_arch_type == MACH_TYPE_AAE)
#else
# define machine_is_aae()	(0)
#endif

#ifdef CONFIG_MACH_PEGASUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PEGASUS
# endif
# define machine_is_pegasus()	(machine_arch_type == MACH_TYPE_PEGASUS)
#else
# define machine_is_pegasus()	(0)
#endif

#ifdef CONFIG_MACH_CYGNUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CYGNUS
# endif
# define machine_is_cygnus()	(machine_arch_type == MACH_TYPE_CYGNUS)
#else
# define machine_is_cygnus()	(0)
#endif

#ifdef CONFIG_MACH_CENTAURUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CENTAURUS
# endif
# define machine_is_centaurus()	(machine_arch_type == MACH_TYPE_CENTAURUS)
#else
# define machine_is_centaurus()	(0)
#endif

#ifdef CONFIG_MACH_MSM8930_QRD8930
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8930_QRD8930
# endif
# define machine_is_msm8930_qrd8930()	(machine_arch_type == MACH_TYPE_MSM8930_QRD8930)
#else
# define machine_is_msm8930_qrd8930()	(0)
#endif

#ifdef CONFIG_MACH_QUBY_TIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QUBY_TIM
# endif
# define machine_is_quby_tim()	(machine_arch_type == MACH_TYPE_QUBY_TIM)
#else
# define machine_is_quby_tim()	(0)
#endif

#ifdef CONFIG_MACH_ZEDI3250A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZEDI3250A
# endif
# define machine_is_zedi3250a()	(machine_arch_type == MACH_TYPE_ZEDI3250A)
#else
# define machine_is_zedi3250a()	(0)
#endif

#ifdef CONFIG_MACH_GRUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GRUS
# endif
# define machine_is_grus()	(machine_arch_type == MACH_TYPE_GRUS)
#else
# define machine_is_grus()	(0)
#endif

#ifdef CONFIG_MACH_APOLLO3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APOLLO3
# endif
# define machine_is_apollo3()	(machine_arch_type == MACH_TYPE_APOLLO3)
#else
# define machine_is_apollo3()	(0)
#endif

#ifdef CONFIG_MACH_COWON_R7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COWON_R7
# endif
# define machine_is_cowon_r7()	(machine_arch_type == MACH_TYPE_COWON_R7)
#else
# define machine_is_cowon_r7()	(0)
#endif

#ifdef CONFIG_MACH_TONGA3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TONGA3
# endif
# define machine_is_tonga3()	(machine_arch_type == MACH_TYPE_TONGA3)
#else
# define machine_is_tonga3()	(0)
#endif

#ifdef CONFIG_MACH_P535
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P535
# endif
# define machine_is_p535()	(machine_arch_type == MACH_TYPE_P535)
#else
# define machine_is_p535()	(0)
#endif

#ifdef CONFIG_MACH_SA3874I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SA3874I
# endif
# define machine_is_sa3874i()	(machine_arch_type == MACH_TYPE_SA3874I)
#else
# define machine_is_sa3874i()	(0)
#endif

#ifdef CONFIG_MACH_MX6_NAVICO_COM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_NAVICO_COM
# endif
# define machine_is_mx6_navico_com()	(machine_arch_type == MACH_TYPE_MX6_NAVICO_COM)
#else
# define machine_is_mx6_navico_com()	(0)
#endif

#ifdef CONFIG_MACH_PROXMOBIL2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROXMOBIL2
# endif
# define machine_is_proxmobil2()	(machine_arch_type == MACH_TYPE_PROXMOBIL2)
#else
# define machine_is_proxmobil2()	(0)
#endif

#ifdef CONFIG_MACH_UBINUX1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UBINUX1
# endif
# define machine_is_ubinux1()	(machine_arch_type == MACH_TYPE_UBINUX1)
#else
# define machine_is_ubinux1()	(0)
#endif

#ifdef CONFIG_MACH_ISTOS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ISTOS
# endif
# define machine_is_istos()	(machine_arch_type == MACH_TYPE_ISTOS)
#else
# define machine_is_istos()	(0)
#endif

#ifdef CONFIG_MACH_BENVOLIO4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BENVOLIO4
# endif
# define machine_is_benvolio4()	(machine_arch_type == MACH_TYPE_BENVOLIO4)
#else
# define machine_is_benvolio4()	(0)
#endif

#ifdef CONFIG_MACH_ECO5_BX2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ECO5_BX2
# endif
# define machine_is_eco5_bx2()	(machine_arch_type == MACH_TYPE_ECO5_BX2)
#else
# define machine_is_eco5_bx2()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX28SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX28SD
# endif
# define machine_is_eukrea_cpuimx28sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX28SD)
#else
# define machine_is_eukrea_cpuimx28sd()	(0)
#endif

#ifdef CONFIG_MACH_DOMOTAB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOMOTAB
# endif
# define machine_is_domotab()	(machine_arch_type == MACH_TYPE_DOMOTAB)
#else
# define machine_is_domotab()	(0)
#endif

#ifdef CONFIG_MACH_PFLA03
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PFLA03
# endif
# define machine_is_pfla03()	(machine_arch_type == MACH_TYPE_PFLA03)
#else
# define machine_is_pfla03()	(0)
#endif

/*
 * These have not yet been registered
 */

#ifndef machine_arch_type
#define machine_arch_type	__machine_arch_type
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 *
 * Automatically generated file; DO NOT EDIT.
 * Linux/arm 4.9.80 Kernel Configuration
 *
 */
#define CONFIG_IP6_NF_MATCH_AH_MODULE 1
#define CONFIG_NLS_CODEPAGE_861_MODULE 1
#define CONFIG_RING_BUFFER 1
#define CONFIG_SND_SOC_WM8804_MODULE 1
#define CONFIG_NF_CONNTRACK_H323_MODULE 1
#define CONFIG_HAVE_ARCH_SECCOMP_FILTER 1
#define CONFIG_SND_PROC_FS 1
#define CONFIG_SCSI_DMA 1
#define CONFIG_KERNEL_GZIP 1
#define CONFIG_VIDEO_EM28XX_V4L2_MODULE 1
#define CONFIG_INPUT_KEYBOARD 1
#define CONFIG_SLUB_CPU_PARTIAL 1
#define CONFIG_RFS_ACCEL 1
#define CONFIG_IP_NF_TARGET_REDIRECT_MODULE 1
#define CONFIG_CRC32 1
#define CONFIG_SND_BCM2708_SOC_FE_PI_AUDIO_MODULE 1
#define CONFIG_I2C_BOARDINFO 1
#define CONFIG_NF_NAT_PROTO_SCTP_MODULE 1
#define CONFIG_USB_ALI_M5632 1
#define CONFIG_DM_SNAPSHOT_MODULE 1
#define CONFIG_VFP 1
#define CONFIG_IR_JVC_DECODER_MODULE 1
#define CONFIG_FSCACHE 1
#define CONFIG_NETFILTER_XT_MATCH_CPU_MODULE 1
#define CONFIG_DVB_ISL6405_MODULE 1
#define CONFIG_B43_BCMA_PIO 1
#define CONFIG_AEABI 1
#define CONFIG_SUNRPC_SWAP 1
#define CONFIG_IR_MCE_KBD_DECODER_MODULE 1
#define CONFIG_SECCOMP 1
#define CONFIG_HIGH_RES_TIMERS 1
#define CONFIG_ARCH_MULTI_V6_V7 1
#define CONFIG_BLK_DEV_DM_MODULE 1
#define CONFIG_RT2800USB_RT3573 1
#define CONFIG_VLAN_8021Q_MODULE 1
#define CONFIG_IP_MULTIPLE_TABLES 1
#define CONFIG_UEVENT_HELPER 1
#define CONFIG_BT_RFCOMM_MODULE 1
#define CONFIG_FIX_EARLYCON_MEM 1
#define CONFIG_LEDS_TRIGGER_HEARTBEAT 1
#define CONFIG_FB_TFT_HX8353D_MODULE 1
#define CONFIG_DVB_TDA1004X_MODULE 1
#define CONFIG_XZ_DEC_IA64 1
#define CONFIG_DVB_BCM3510_MODULE 1
#define CONFIG_INOTIFY_USER 1
#define CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE 1
#define CONFIG_HDMI 1
#define CONFIG_BRIDGE_EBT_T_FILTER_MODULE 1
#define CONFIG_NETWORK_FILESYSTEMS 1
#define CONFIG_IPIPE 1
#define CONFIG_CRYPTO_MD4_MODULE 1
#define CONFIG_USB_SI470X_MODULE 1
#define CONFIG_RPI_AXIPERF_MODULE 1
#define CONFIG_USB_GSPCA_JL2005BCD_MODULE 1
#define CONFIG_BT_HCIBFUSB_MODULE 1
#define CONFIG_CGROUP_DEVICE 1
#define CONFIG_PPP_SYNC_TTY_MODULE 1
#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
#define CONFIG_INLINE_WRITE_UNLOCK_IRQ 1
#define CONFIG_RC_CORE_MODULE 1
#define CONFIG_CGROUP_WRITEBACK 1
#define CONFIG_SND_SOC_TPA6130A2_MODULE 1
#define CONFIG_MAC80211_STA_HASH_MAX_SIZE 0
#define CONFIG_IP_VS_NQ_MODULE 1
#define CONFIG_DVB_DRXD_MODULE 1
#define CONFIG_HAVE_ARCH_MMAP_RND_BITS 1
#define CONFIG_HID_SPEEDLINK_MODULE 1
#define CONFIG_BLK_DEV_NBD_MODULE 1
#define CONFIG_ARM_UNWIND 1
#define CONFIG_USB_SERIAL_NAVMAN_MODULE 1
#define CONFIG_TCP_CONG_HTCP_MODULE 1
#define CONFIG_EXT4_FS_POSIX_ACL 1
#define CONFIG_BINFMT_MISC_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE 1
#define CONFIG_SSB_POSSIBLE 1
#define CONFIG_BRIDGE_EBT_T_NAT_MODULE 1
#define CONFIG_NF_NAT_SIP_MODULE 1
#define CONFIG_RADIO_SHARK_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE 1
#define CONFIG_NLS_CODEPAGE_855_MODULE 1
#define CONFIG_FB_TFT_ILI9486_MODULE 1
#define CONFIG_UHID_MODULE 1
#define CONFIG_DVB_EC100_MODULE 1
#define CONFIG_IP_NF_NAT_MODULE 1
#define CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE 1
#define CONFIG_B43LEGACY_LEDS 1
#define CONFIG_USB_SERIAL_SAFE_MODULE 1
#define CONFIG_DVB_LGS8GL5_MODULE 1
#define CONFIG_BRIDGE_NF_EBTABLES_MODULE 1
#define CONFIG_DVB_LG2160_MODULE 1
#define CONFIG_USB_OHCI_LITTLE_ENDIAN 1
#define CONFIG_NET_SCH_FIFO 1
#define CONFIG_REISERFS_FS_MODULE 1
#define CONFIG_SWPHY 1
#define CONFIG_FSNOTIFY 1
#define CONFIG_BLK_DEV_LOOP_MIN_COUNT 8
#define CONFIG_STP_MODULE 1
#define CONFIG_USB_GSPCA_SQ905_MODULE 1
#define CONFIG_DVB_AU8522_MODULE 1
#define CONFIG_INET6_TUNNEL_MODULE 1
#define CONFIG_DVB_M88RS2000_MODULE 1
#define CONFIG_NF_CONNTRACK_SIP_MODULE 1
#define CONFIG_STACK_TRACER 1
#define CONFIG_MEDIA_ATTACH 1
#define CONFIG_CRYPTO_MANAGER_DISABLE_TESTS 1
#define CONFIG_HIDRAW 1
#define CONFIG_NET_SCH_FQ_CODEL_MODULE 1
#define CONFIG_KSDAZZLE_DONGLE_MODULE 1
#define CONFIG_HAVE_KERNEL_LZMA 1
#define CONFIG_ARCH_WANT_IPC_PARSE_VERSION 1
#define CONFIG_RT2X00_LIB_LEDS 1
#define CONFIG_IP_VS_SED_MODULE 1
#define CONFIG_GENERIC_SMP_IDLE_THREAD 1
#define CONFIG_NET_VENDOR_QUALCOMM 1
#define CONFIG_DVB_DS3000_MODULE 1
#define CONFIG_SQUASHFS_FILE_CACHE 1
#define CONFIG_XENO_ARCH_OUTOFLINE_XNLOCK 1
#define CONFIG_USB_SERIAL_FTDI_SIO_MODULE 1
#define CONFIG_NET_VENDOR_EZCHIP 1
#define CONFIG_BRIDGE_EBT_REDIRECT_MODULE 1
#define CONFIG_DEFAULT_SECURITY_DAC 1
#define CONFIG_MEDIA_DIGITAL_TV_SUPPORT 1
#define CONFIG_THERMAL_BCM2835 1
#define CONFIG_FIB_RULES 1
#define CONFIG_W1_SLAVE_DS2408_MODULE 1
#define CONFIG_IP_VS_NFCT 1
#define CONFIG_HID_EMS_FF_MODULE 1
#define CONFIG_VLAN_8021Q_GVRP 1
#define CONFIG_IP_SET_HASH_NETIFACE_MODULE 1
#define CONFIG_IP6_NF_MANGLE_MODULE 1
#define CONFIG_MEDIA_TUNER_SI2157_MODULE 1
#define CONFIG_HAVE_IRQ_TIME_ACCOUNTING 1
#define CONFIG_BT_MRVL_SDIO_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_REALM_MODULE 1
#define CONFIG_BT_HCIBPA10X_MODULE 1
#define CONFIG_SQUASHFS_XATTR 1
#define CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED 1
#define CONFIG_IP_VS_RR_MODULE 1
#define CONFIG_IPV6_MODULE 1
#define CONFIG_USB_SERIAL_QUALCOMM_MODULE 1
#define CONFIG_NET_9P_MODULE 1
#define CONFIG_CRYPTO_AEAD_MODULE 1
#define CONFIG_BQL 1
#define CONFIG_XENO_OPT_TIMING_SCHEDLAT 0
#define CONFIG_DEFAULT_TCP_CONG "cubic"
#define CONFIG_UEVENT_HELPER_PATH ""
#define CONFIG_DEVTMPFS 1
#define CONFIG_NET_CLS_FLOW_MODULE 1
#define CONFIG_VIDEO_BCM2835 1
#define CONFIG_DVB_ISL6423_MODULE 1
#define CONFIG_USB_STORAGE_USBAT_MODULE 1
#define CONFIG_REISERFS_FS_POSIX_ACL 1
#define CONFIG_NF_NAT_PROTO_GRE_MODULE 1
#define CONFIG_NLS_ISO8859_7_MODULE 1
#define CONFIG_IP6_NF_TARGET_REJECT_MODULE 1
#define CONFIG_PWM_PCA9685_MODULE 1
#define CONFIG_IR_SHARP_DECODER_MODULE 1
#define CONFIG_ASYNC_MEMCPY_MODULE 1
#define CONFIG_NF_NAT_REDIRECT_MODULE 1
#define CONFIG_RTC_DRV_DS1305_MODULE 1
#define CONFIG_IR_NEC_DECODER_MODULE 1
#define CONFIG_USB_SERIAL_MOS7840_MODULE 1
#define CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM 1
#define CONFIG_WLAN 1
#define CONFIG_NAMESPACES 1
#define CONFIG_W1_SLAVE_DS2423_MODULE 1
#define CONFIG_RTC_DRV_ABX80X_MODULE 1
#define CONFIG_USB_NET_INT51X1_MODULE 1
#define CONFIG_SND_SOC_SIGMADSP_MODULE 1
#define CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY 1
#define CONFIG_BLK_DEV_BSG 1
#define CONFIG_CONNECTOR_MODULE 1
#define CONFIG_MEDIA_USB_SUPPORT 1
#define CONFIG_NETFILTER_XT_TARGET_RATEEST_MODULE 1
#define CONFIG_SCTP_COOKIE_HMAC_SHA1 1
#define CONFIG_BRIDGE_EBT_ARPREPLY_MODULE 1
#define CONFIG_B43LEGACY_DMA_AND_PIO_MODE 1
#define CONFIG_FB_RPISENSE_MODULE 1
#define CONFIG_DVB_MAX_ADAPTERS 8
#define CONFIG_LIBERTAS_USB_MODULE 1
#define CONFIG_JFS_FS_MODULE 1
#define CONFIG_XFRM_IPCOMP_MODULE 1
#define CONFIG_CRYPTO_DRBG_MENU_MODULE 1
#define CONFIG_CRYPTO_RNG2 1
#define CONFIG_USB_PWC_INPUT_EVDEV 1
#define CONFIG_NETFILTER_NETLINK_QUEUE_MODULE 1
#define CONFIG_NET_ACT_CSUM_MODULE 1
#define CONFIG_DVB_CXD2880_MODULE 1
#define CONFIG_MSDOS_FS 1
#define CONFIG_NET_CLS_CGROUP_MODULE 1
#define CONFIG_TUN_MODULE 1
#define CONFIG_USB_GSPCA_SUNPLUS_MODULE 1
#define CONFIG_DVB_AU8522_V4L_MODULE 1
#define CONFIG_IIO_KFIFO_BUF_MODULE 1
#define CONFIG_IPV6_PIMSM_V2 1
#define CONFIG_SENSORS_ADS1015_MODULE 1
#define CONFIG_DVB_USB_DVBSKY_MODULE 1
#define CONFIG_CAN_MODULE 1
#define CONFIG_GPIO_BCM_VIRT 1
#define CONFIG_CFG80211_MODULE 1
#define CONFIG_SSB_BLOCKIO 1
#define CONFIG_FB_TFT_HX8347D_MODULE 1
#define CONFIG_NLS_CODEPAGE_1250_MODULE 1
#define CONFIG_OF_RESERVED_MEM 1
#define CONFIG_DM_CRYPT_MODULE 1
#define CONFIG_SERIAL_8250 1
#define CONFIG_RTC_DRV_ISL12022_MODULE 1
#define CONFIG_IPIPE_ARM_KUSER_TSC 1
#define CONFIG_B43LEGACY_PIO 1
#define CONFIG_HAVE_PROC_CPU 1
#define CONFIG_LZO_DECOMPRESS 1
#define CONFIG_LIBERTAS_THINFIRM_MODULE 1
#define CONFIG_IP_VS_PROTO_AH 1
#define CONFIG_HID_BELKIN_MODULE 1
#define CONFIG_VIDEO_IR_I2C_MODULE 1
#define CONFIG_DVB_STV0367_MODULE 1
#define CONFIG_LEDS_TRIGGER_CAMERA_MODULE 1
#define CONFIG_NLS_CODEPAGE_862_MODULE 1
#define CONFIG_WLAN_VENDOR_CISCO 1
#define CONFIG_SND_AUDIOINJECTOR_OCTO_SOUNDCARD_MODULE 1
#define CONFIG_NFSD_MODULE 1
#define CONFIG_USB_SERIAL_OPTION_MODULE 1
#define CONFIG_HID_ACRUX_MODULE 1
#define CONFIG_USB_GSPCA_SE401_MODULE 1
#define CONFIG_USB 1
#define CONFIG_HAVE_ARCH_HARDENED_USERCOPY 1
#define CONFIG_USB_SPEEDTOUCH_MODULE 1
#define CONFIG_CRYPTO_HMAC_MODULE 1
#define CONFIG_WLAN_VENDOR_REALTEK 1
#define CONFIG_INPUT_ADXL34X_SPI_MODULE 1
#define CONFIG_ETHERNET 1
#define CONFIG_NET_SCH_CODEL_MODULE 1
#define CONFIG_USBIP_VHCI_HC_PORTS 8
#define CONFIG_USB_GSPCA_JEILINJ_MODULE 1
#define CONFIG_HID_LOGITECH_HIDPP_MODULE 1
#define CONFIG_BRANCH_PROFILE_NONE 1
#define CONFIG_CRC_ITU_T 1
#define CONFIG_SND_HRTIMER_MODULE 1
#define CONFIG_HAVE_DMA_CONTIGUOUS 1
#define CONFIG_DQL 1
#define CONFIG_VXLAN_MODULE 1
#define CONFIG_FRAMEBUFFER_CONSOLE 1
#define CONFIG_SND_SOC_PCM512x_I2C_MODULE 1
#define CONFIG_DM_ZERO_MODULE 1
#define CONFIG_DVB_DIB8000_MODULE 1
#define CONFIG_SND_SEQUENCER_MODULE 1
#define CONFIG_SONY_FF 1
#define CONFIG_SOCK_CGROUP_DATA 1
#define CONFIG_RASPBERRYPI_FIRMWARE 1
#define CONFIG_COREDUMP 1
#define CONFIG_USB_NET_GL620A_MODULE 1
#define CONFIG_DVB_LGDT3306A_MODULE 1
#define CONFIG_IP_NF_ARPTABLES_MODULE 1
#define CONFIG_DVB_ASCOT2E_MODULE 1
#define CONFIG_DVB_USB_GP8PSK_MODULE 1
#define CONFIG_USB_SERIAL_GENERIC 1
#define CONFIG_HID_CHERRY_MODULE 1
#define CONFIG_MKISS_MODULE 1
#define CONFIG_HID_SUNPLUS_MODULE 1
#define CONFIG_INPUT_ADXL34X_MODULE 1
#define CONFIG_HID_PICOLCD_MODULE 1
#define CONFIG_BCMA_POSSIBLE 1
#define CONFIG_NF_LOG_IPV4_MODULE 1
#define CONFIG_NET_SCH_SFB_MODULE 1
#define CONFIG_NET_VENDOR_CIRRUS 1
#define CONFIG_CIFS_ACL 1
#define CONFIG_ZRAM_MODULE 1
#define CONFIG_CRYPTO_CAST5_MODULE 1
#define CONFIG_FORCE_MAX_ZONEORDER 11
#define CONFIG_SND_SOC_MODULE 1
#define CONFIG_MODULES_USE_ELF_REL 1
#define CONFIG_SND_BCM2708_SOC_JUSTBOOM_DIGI_MODULE 1
#define CONFIG_NET_IPGRE_DEMUX_MODULE 1
#define CONFIG_MEDIA_TUNER_XC5000_MODULE 1
#define CONFIG_NET_POLL_CONTROLLER 1
#define CONFIG_PRINTK 1
#define CONFIG_6LOWPAN_NHC_ROUTING_MODULE 1
#define CONFIG_FB_SYS_FILLRECT_MODULE 1
#define CONFIG_TIMERFD 1
#define CONFIG_HID_THRUSTMASTER_MODULE 1
#define CONFIG_SND_BCM2708_SOC_RPI_PROTO_MODULE 1
#define CONFIG_DNS_RESOLVER 1
#define CONFIG_TRACEPOINTS 1
#define CONFIG_B43_PHY_LP 1
#define CONFIG_MTD_CFI_I2 1
#define CONFIG_CRYPTO_AUTHENC_MODULE 1
#define CONFIG_DVB_SP8870_MODULE 1
#define CONFIG_W1_MASTER_DS2482_MODULE 1
#define CONFIG_NET_EMATCH_STACK 32
#define CONFIG_CARL9170_LEDS 1
#define CONFIG_USB_STORAGE_ENE_UB6250_MODULE 1
#define CONFIG_BRCMFMAC_SDIO 1
#define CONFIG_IRDA_MODULE 1
#define CONFIG_P54_COMMON_MODULE 1
#define CONFIG_SHMEM 1
#define CONFIG_MTD_MODULE 1
#define CONFIG_HAVE_ARCH_JUMP_LABEL 1
#define CONFIG_MMC_BLOCK_MINORS 32
#define CONFIG_USB_HSO_MODULE 1
#define CONFIG_DEVTMPFS_MOUNT 1
#define CONFIG_USB_IPHETH_MODULE 1
#define CONFIG_NLS_CODEPAGE_850_MODULE 1
#define CONFIG_DVB_CX22700_MODULE 1
#define CONFIG_DNOTIFY 1
#define CONFIG_CRYPTO_CTS_MODULE 1
#define CONFIG_SND_SOC_WM5102_MODULE 1
#define CONFIG_DVB_USB_UMT_010_MODULE 1
#define CONFIG_RTC_DRV_R9701_MODULE 1
#define CONFIG_INPUT_MOUSEDEV 1
#define CONFIG_GENERIC_NET_UTILS 1
#define CONFIG_SND_SOC_CS42XX8_MODULE 1
#define CONFIG_CRYPTO_DES 1
#define CONFIG_ENABLE_MUST_CHECK 1
#define CONFIG_VDSO 1
#define CONFIG_SND_SOC_COMPRESS 1
#define CONFIG_NLS_CODEPAGE_437 1
#define CONFIG_MTD_NAND_IDS_MODULE 1
#define CONFIG_BT_HS 1
#define CONFIG_MCS_FIR_MODULE 1
#define CONFIG_NET_CLS_U32_MODULE 1
#define CONFIG_EXPORTFS 1
#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
#define CONFIG_FB_TFT_WATTEROTT_MODULE 1
#define CONFIG_SND_MIXER_OSS_MODULE 1
#define CONFIG_IP6_NF_MATCH_MH_MODULE 1
#define CONFIG_NET_INGRESS 1
#define CONFIG_FB_TFT_ST7789V_MODULE 1
#define CONFIG_DVB_S921_MODULE 1
#define CONFIG_LRU_CACHE_MODULE 1
#define CONFIG_DVB_AF9013_MODULE 1
#define CONFIG_OLD_SIGSUSPEND3 1
#define CONFIG_SERIO_MODULE 1
#define CONFIG_DVB_USB_DTV5100_MODULE 1
#define CONFIG_SCHEDSTATS 1
#define CONFIG_FB_SYS_IMAGEBLIT_MODULE 1
#define CONFIG_VIDEO_TVEEPROM_MODULE 1
#define CONFIG_ARCH_HAS_SG_CHAIN 1
#define CONFIG_SUNRPC_GSS 1
#define CONFIG_HID_LED_MODULE 1
#define CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS 1
#define CONFIG_NETCONSOLE_MODULE 1
#define CONFIG_RTC_INTF_SYSFS 1
#define CONFIG_SND_SOC_SPDIF_MODULE 1
#define CONFIG_RTC_DRV_RS5C372_MODULE 1
#define CONFIG_NET_EMATCH_U32_MODULE 1
#define CONFIG_USB_EMI62_MODULE 1
#define CONFIG_DM_BUFIO_MODULE 1
#define CONFIG_CAN_GS_USB_MODULE 1
#define CONFIG_BT_ATH3K_MODULE 1
#define CONFIG_LEDS_TRIGGER_TIMER 1
#define CONFIG_RT2800_LIB_MODULE 1
#define CONFIG_SND_BCM2708_SOC_IQAUDIO_DAC_MODULE 1
#define CONFIG_BT_INTEL_MODULE 1
#define CONFIG_DVB_USB_DW2102_MODULE 1
#define CONFIG_NF_CONNTRACK_SANE_MODULE 1
#define CONFIG_GPIO_PCF857X_MODULE 1
#define CONFIG_SND_OSSEMUL 1
#define CONFIG_ARCH_CLOCKSOURCE_DATA 1
#define CONFIG_USB_SERIAL_MOS7720_MODULE 1
#define CONFIG_NF_CT_PROTO_DCCP_MODULE 1
#define CONFIG_ZLIB_INFLATE_MODULE 1
#define CONFIG_NET_VENDOR_SYNOPSYS 1
#define CONFIG_DVB_TUA6100_MODULE 1
#define CONFIG_SENSORS_SHTC1_MODULE 1
#define CONFIG_BMP280_MODULE 1
#define CONFIG_MEDIA_TUNER_QT1010_MODULE 1
#define CONFIG_THERMAL_OF 1
#define CONFIG_RTLWIFI_DEBUG 1
#define CONFIG_HWMON_MODULE 1
#define CONFIG_LOGO_LINUX_CLUT224 1
#define CONFIG_BT_HCIUART_3WIRE 1
#define CONFIG_NLS_ISO8859_2_MODULE 1
#define CONFIG_IP_PNP 1
#define CONFIG_RC_DEVICES 1
#define CONFIG_USB_VIDEO_CLASS_MODULE 1
#define CONFIG_RTC_INTF_PROC 1
#define CONFIG_USB_SERIAL_TI_MODULE 1
#define CONFIG_NET_SCH_CBQ_MODULE 1
#define CONFIG_PM_CLK 1
#define CONFIG_ARCH_USE_BUILTIN_BSWAP 1
#define CONFIG_DVB_SI2168_MODULE 1
#define CONFIG_PWM_BCM2835_MODULE 1
#define CONFIG_FB_TFT_TINYLCD_MODULE 1
#define CONFIG_FB_FLEX_MODULE 1
#define CONFIG_STACKTRACE_SUPPORT 1
#define CONFIG_DVB_USB_AF9035_MODULE 1
#define CONFIG_FB_TFT_HX8340BN_MODULE 1
#define CONFIG_LOCKD 1
#define CONFIG_DRM_KMS_FB_HELPER 1
#define CONFIG_DVB_S5H1411_MODULE 1
#define CONFIG_SOUND_OSS_CORE 1
#define CONFIG_RT2800USB_RT35XX 1
#define CONFIG_LIBERTAS_MODULE 1
#define CONFIG_WLAN_VENDOR_RALINK 1
#define CONFIG_ARM 1
#define CONFIG_USB_GSPCA_TV8532_MODULE 1
#define CONFIG_CRYPTO_KPP2 1
#define CONFIG_LATENCYTOP 1
#define CONFIG_NET_VENDOR_MICROCHIP 1
#define CONFIG_JFFS2_FS_MODULE 1
#define CONFIG_ARM_L1_CACHE_SHIFT 6
#define CONFIG_XENO_OPT_SHARED_HEAPSZ 256
#define CONFIG_BT_RFCOMM_TTY 1
#define CONFIG_NET_UDP_TUNNEL_MODULE 1
#define CONFIG_RPCSEC_GSS_KRB5_MODULE 1
#define CONFIG_VIDEOBUF_VMALLOC_MODULE 1
#define CONFIG_ARM_PATCH_IDIV 1
#define CONFIG_NO_HZ_IDLE 1
#define CONFIG_DVB_STV0299_MODULE 1
#define CONFIG_USB_AN2720 1
#define CONFIG_F2FS_STAT_FS 1
#define CONFIG_BSD_PROCESS_ACCT 1
#define CONFIG_NETFILTER_XT_MATCH_STRING_MODULE 1
#define CONFIG_ARM_CPU_TOPOLOGY 1
#define CONFIG_88EU_AP_MODE 1
#define CONFIG_MEDIA_TUNER_MAX2165_MODULE 1
#define CONFIG_CRYPTO_DRBG_HMAC 1
#define CONFIG_DRM_BRIDGE 1
#define CONFIG_LOGO 1
#define CONFIG_DLM_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_BPF_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_GOTOP 1
#define CONFIG_XENO_OPT_TIMER_LIST 1
#define CONFIG_BT_6LOWPAN_MODULE 1
#define CONFIG_USB_STORAGE 1
#define CONFIG_NET_VENDOR_BROADCOM 1
#define CONFIG_DVB_USB_PCTV452E_MODULE 1
#define CONFIG_DVB_VES1820_MODULE 1
#define CONFIG_STANDALONE 1
#define CONFIG_BAYCOM_SER_HDX_MODULE 1
#define CONFIG_IR_LIRC_CODEC_MODULE 1
#define CONFIG_RATIONAL 1
#define CONFIG_I2C_MUX_MODULE 1
#define CONFIG_IPIPE_CORE 1
#define CONFIG_DVB_TS2020_MODULE 1
#define CONFIG_WLAN_VENDOR_INTEL 1
#define CONFIG_MEDIA_TUNER_QM1D1C0042_MODULE 1
#define CONFIG_WATCHDOG_CORE 1
#define CONFIG_GENERIC_EARLY_IOREMAP 1
#define CONFIG_DVB_TUNER_DIB0090_MODULE 1
#define CONFIG_IPIPE_TARGET_APIREV 2
#define CONFIG_SND_USB_AUDIO_MODULE 1
#define CONFIG_VIDEO_CX231XX_MODULE 1
#define CONFIG_IEEE802154_MODULE 1
#define CONFIG_BLOCK 1
#define CONFIG_IP_VS_LC_MODULE 1
#define CONFIG_HID_APPLE_MODULE 1
#define CONFIG_SND_BCM2708_SOC_HIFIBERRY_DACPLUS_MODULE 1
#define CONFIG_DVB_DIB9000_MODULE 1
#define CONFIG_MEDIA_TUNER_TDA827X_MODULE 1
#define CONFIG_INIT_ENV_ARG_LIMIT 32
#define CONFIG_SND_RAWMIDI_SEQ_MODULE 1
#define CONFIG_IP_NF_ARP_MANGLE_MODULE 1
#define CONFIG_DVB_USB_MODULE 1
#define CONFIG_FB_TFT_SSD1306_MODULE 1
#define CONFIG_P54_LEDS 1
#define CONFIG_DVB_ATBM8830_MODULE 1
#define CONFIG_ROOT_NFS 1
#define CONFIG_USER_NS 1
#define CONFIG_CRYPTO_USER_MODULE 1
#define CONFIG_NF_CONNTRACK_PPTP_MODULE 1
#define CONFIG_DVB_ZL10036_MODULE 1
#define CONFIG_VIDEO_CX231XX_ALSA_MODULE 1
#define CONFIG_HFSPLUS_FS_MODULE 1
#define CONFIG_TMPFS_POSIX_ACL 1
#define CONFIG_SND_USB_UA101_MODULE 1
#define CONFIG_BUG 1
#define CONFIG_CONTEXT_SWITCH_TRACER 1
#define CONFIG_MAC80211_HAS_RC 1
#define CONFIG_BATMAN_ADV_BLA 1
#define CONFIG_LOGIWHEELS_FF 1
#define CONFIG_OF_OVERLAY 1
#define CONFIG_OCFS2_FS_O2CB_MODULE 1
#define CONFIG_6LOWPAN_NHC_UDP_MODULE 1
#define CONFIG_NET_EMATCH_META_MODULE 1
#define CONFIG_CLKSRC_OF 1
#define CONFIG_W1_MASTER_DS1WM_MODULE 1
#define CONFIG_PM 1
#define CONFIG_PPS_MODULE 1
#define CONFIG_USB_LCD_MODULE 1
#define CONFIG_MEMCG 1
#define CONFIG_SPI 1
#define CONFIG_RTC_SYSTOHC_DEVICE "rtc0"
#define CONFIG_NF_CONNTRACK_IRC_MODULE 1
#define CONFIG_L2TP_IP_MODULE 1
#define CONFIG_OF_IRQ 1
#define CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
#define CONFIG_LIBFDT 1
#define CONFIG_USB_STV06XX_MODULE 1
#define CONFIG_PPP_DEFLATE_MODULE 1
#define CONFIG_NTFS_RW 1
#define CONFIG_TEXTSEARCH_KMP_MODULE 1
#define CONFIG_W1_SLAVE_SMEM_MODULE 1
#define CONFIG_VT 1
#define CONFIG_USB_NET_NET1080_MODULE 1
#define CONFIG_DTC 1
#define CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE 1
#define CONFIG_REGMAP_SPI 1
#define CONFIG_SND_BCM2708_SOC_HIFIBERRY_AMP_MODULE 1
#define CONFIG_BT_BREDR 1
#define CONFIG_SPLIT_PTLOCK_CPUS 4
#define CONFIG_SBITMAP 1
#define CONFIG_DVB_TUNER_ITD1000_MODULE 1
#define CONFIG_POWER_SUPPLY 1
#define CONFIG_DM_PERSISTENT_DATA_MODULE 1
#define CONFIG_SND_BCM2708_SOC_JUSTBOOM_DAC_MODULE 1
#define CONFIG_SCTP_COOKIE_HMAC_MD5 1
#define CONFIG_CIFS_XATTR 1
#define CONFIG_CPU_CACHE_VIPT 1
#define CONFIG_SND_DMAENGINE_PCM_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE 1
#define CONFIG_WEXT_CORE 1
#define CONFIG_USB_GSPCA_MR97310A_MODULE 1
#define CONFIG_VIDEO_WM8775_MODULE 1
#define CONFIG_NLS 1
#define CONFIG_MFD_ARIZONA 1
#define CONFIG_IP_SET_HASH_IPPORTNET_MODULE 1
#define CONFIG_CDROM_PKTCDVD_BUFFERS 8
#define CONFIG_SCHED_AUTOGROUP 1
#define CONFIG_SPI_SPIDEV_MODULE 1
#define CONFIG_MEDIA_CAMERA_SUPPORT 1
#define CONFIG_PRISM2_USB_MODULE 1
#define CONFIG_FB_TFT_ILI9325_MODULE 1
#define CONFIG_HID_MAGICMOUSE_MODULE 1
#define CONFIG_SND_SOC_AK4554_MODULE 1
#define CONFIG_I2C_GPIO_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_ETURBO 1
#define CONFIG_PPPOE_MODULE 1
#define CONFIG_USB_GSPCA_SPCA508_MODULE 1
#define CONFIG_USB_LEGOTOWER_MODULE 1
#define CONFIG_NF_NAT_IPV6_MODULE 1
#define CONFIG_I2C_ROBOTFUZZ_OSIF_MODULE 1
#define CONFIG_DVB_DRX39XYJ_MODULE 1
#define CONFIG_DVB_USB_DIBUSB_MC_MODULE 1
#define CONFIG_DVB_USB_VP702X_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_OWNER_MODULE 1
#define CONFIG_IP_NF_TARGET_ECN_MODULE 1
#define CONFIG_SYN_COOKIES 1
#define CONFIG_IRQ_WORK 1
#define CONFIG_ATH9K_MODULE 1
#define CONFIG_IP_ADVANCED_ROUTER 1
#define CONFIG_ENABLE_WARN_DEPRECATED 1
#define CONFIG_VIDEO_USBVISION_MODULE 1
#define CONFIG_FB_SYS_COPYAREA_MODULE 1
#define CONFIG_HTU21_MODULE 1
#define CONFIG_CLEANCACHE 1
#define CONFIG_MEDIA_TUNER_MT2063_MODULE 1
#define CONFIG_USB_STORAGE_ALAUDA_MODULE 1
#define CONFIG_W1_SLAVE_DS2406_MODULE 1
#define CONFIG_USB_COMMON 1
#define CONFIG_CYPRESS_FIRMWARE_MODULE 1
#define CONFIG_TASK_XACCT 1
#define CONFIG_MEDIA_TUNER_TDA18271_MODULE 1
#define CONFIG_IP_SET_BITMAP_PORT_MODULE 1
#define CONFIG_IP6_NF_IPTABLES_MODULE 1
#define CONFIG_LZ4_COMPRESS_MODULE 1
#define CONFIG_QFMT_V1_MODULE 1
#define CONFIG_DVB_IX2505V_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_ZYTRONIC 1
#define CONFIG_FIXED_PHY 1
#define CONFIG_DVB_SP2_MODULE 1
#define CONFIG_SND_BCM2708_SOC_IQAUDIO_DIGI_MODULE 1
#define CONFIG_LOG_CPU_MAX_BUF_SHIFT 12
#define CONFIG_NF_DUP_IPV4_MODULE 1
#define CONFIG_BLK_DEV_DM_BUILTIN 1
#define CONFIG_USB_SERIAL_IPW_MODULE 1
#define CONFIG_INET_IPCOMP_MODULE 1
#define CONFIG_OF_NET 1
#define CONFIG_DVB_USB_DIB0700_MODULE 1
#define CONFIG_ARM_ARCH_TIMER 1
#define CONFIG_EVENT_TRACING 1
#define CONFIG_NET_CADENCE 1
#define CONFIG_ASYNC_PQ_MODULE 1
#define CONFIG_HID_KEYTOUCH_MODULE 1
#define CONFIG_HID_CYPRESS_MODULE 1
#define CONFIG_SG_POOL 1
#define CONFIG_BRIDGE_EBT_LIMIT_MODULE 1
#define CONFIG_DRM_KMS_HELPER_MODULE 1
#define CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN_MODULE 1
#define CONFIG_OCFS2_FS_USERSPACE_CLUSTER_MODULE 1
#define CONFIG_ATA_OVER_ETH_MODULE 1
#define CONFIG_USB_NET_PLUSB_MODULE 1
#define CONFIG_VIDEO_SAA711X_MODULE 1
#define CONFIG_RTL8192C_COMMON_MODULE 1
#define CONFIG_PREEMPT_VOLUNTARY 1
#define CONFIG_NLS_ISO8859_1_MODULE 1
#define CONFIG_CRYPTO_WORKQUEUE 1
#define CONFIG_NFC_MODULE 1
#define CONFIG_CIFS_FSCACHE 1
#define CONFIG_HID_KENSINGTON_MODULE 1
#define CONFIG_BATTERY_DS2760_MODULE 1
#define CONFIG_SND_SOC_ADAU1977_MODULE 1
#define CONFIG_TEXTSEARCH_BM_MODULE 1
#define CONFIG_FS_IOMAP 1
#define CONFIG_CIFS_SMB2 1
#define CONFIG_JFS_SECURITY 1
#define CONFIG_NF_CONNTRACK_PROCFS 1
#define CONFIG_HID_ZYDACRON_MODULE 1
#define CONFIG_PPP_MPPE_MODULE 1
#define CONFIG_CAN_CALC_BITTIMING 1
#define CONFIG_SND_PCM_OSS_MODULE 1
#define CONFIG_DVB_B2C2_FLEXCOP_MODULE 1
#define CONFIG_ARM_CRYPTO 1
#define CONFIG_USB_NET_SR9700_MODULE 1
#define CONFIG_USB_IRDA_MODULE 1
#define CONFIG_RFKILL_MODULE 1
#define CONFIG_VIDEO_TVP5150_MODULE 1
#define CONFIG_MEDIA_TUNER_FC0012_MODULE 1
#define CONFIG_NETDEVICES 1
#define CONFIG_NET_KEY_MODULE 1
#define CONFIG_SMS_SIANO_MDTV_MODULE 1
#define CONFIG_IP6_NF_TARGET_HL_MODULE 1
#define CONFIG_IOSCHED_DEADLINE 1
#define CONFIG_CGROUP_FREEZER 1
#define CONFIG_CPU_TLB_V7 1
#define CONFIG_EVENTFD 1
#define CONFIG_FS_POSIX_ACL 1
#define CONFIG_IPV6_SIT_MODULE 1
#define CONFIG_XFRM 1
#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
#define CONFIG_IP_SET_HASH_IP_MODULE 1
#define CONFIG_USB_MR800_MODULE 1
#define CONFIG_SERIAL_8250_CONSOLE 1
#define CONFIG_IPV6_MULTIPLE_TABLES 1
#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
#define CONFIG_USB_SERIAL_WHITEHEAT_MODULE 1
#define CONFIG_NET_CLS_ROUTE4_MODULE 1
#define CONFIG_JUMP_LABEL 1
#define CONFIG_CRYPTO_SHA1_ARM_MODULE 1
#define CONFIG_IPIPE_WANT_PREEMPTIBLE_SWITCH 1
#define CONFIG_OVERLAY_FS_MODULE 1
#define CONFIG_IP_SET_HASH_NETPORT_MODULE 1
#define CONFIG_ATH9K_HTC_MODULE 1
#define CONFIG_IP_VS_DH_MODULE 1
#define CONFIG_AX25_DAMA_SLAVE 1
#define CONFIG_RADIO_WL128X_MODULE 1
#define CONFIG_IP_NF_TARGET_MASQUERADE_MODULE 1
#define CONFIG_XENO_OPT_TIMING_IRQLAT 0
#define CONFIG_XENO_OPT_VFILE 1
#define CONFIG_NF_CONNTRACK_BROADCAST_MODULE 1
#define CONFIG_CRYPTO_LZ4_MODULE 1
#define CONFIG_ECRYPT_FS_MODULE 1
#define CONFIG_HZ_100 1
#define CONFIG_PROC_PAGE_MONITOR 1
#define CONFIG_SERIAL_8250_EXTENDED 1
#define CONFIG_KS959_DONGLE_MODULE 1
#define CONFIG_MEDIA_TUNER_R820T_MODULE 1
#define CONFIG_MTD_SPI_NOR_USE_4K_SECTORS 1
#define CONFIG_BPF 1
#define CONFIG_9P_FS_POSIX_ACL 1
#define CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC_PLUS_MODULE 1
#define CONFIG_KINGSUN_DONGLE_MODULE 1
#define CONFIG_NF_NAT_PROTO_DCCP_MODULE 1
#define CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
#define CONFIG_DM_DELAY_MODULE 1
#define CONFIG_SND_BCM2708_SOC_RASPIDAC3_MODULE 1
#define CONFIG_USB_SERIAL_CH341_MODULE 1
#define CONFIG_USB_FTDI_ELAN_MODULE 1
#define CONFIG_DVB_USB_FRIIO_MODULE 1
#define CONFIG_IP_SET_HASH_IPPORT_MODULE 1
#define CONFIG_SENSORS_SHT21_MODULE 1
#define CONFIG_USB_IOWARRIOR_MODULE 1
#define CONFIG_USB_EZUSB_FX2_MODULE 1
#define CONFIG_WIMAX_I2400M_USB_MODULE 1
#define CONFIG_RTL8XXXU_MODULE 1
#define CONFIG_VIDEO_OV7640_MODULE 1
#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
#define CONFIG_B43_HWRNG 1
#define CONFIG_MTD_OF_PARTS_MODULE 1
#define CONFIG_USB_M5602_MODULE 1
#define CONFIG_RT2X00_LIB_USB_MODULE 1
#define CONFIG_OF_RESOLVE 1
#define CONFIG_CRYPTO_NULL_MODULE 1
#define CONFIG_DVB_USB_AF9005_REMOTE_MODULE 1
#define CONFIG_B43_PHY_G 1
#define CONFIG_NET_VENDOR_SEEQ 1
#define CONFIG_NF_DEFRAG_IPV4_MODULE 1
#define CONFIG_MIGHT_HAVE_PCI 1
#define CONFIG_USB_IDMOUSE_MODULE 1
#define CONFIG_INET_XFRM_MODE_BEET_MODULE 1
#define CONFIG_HID_LCPOWER_MODULE 1
#define CONFIG_HAVE_ARCH_PFN_VALID 1
#define CONFIG_CPU_COPY_V6 1
#define CONFIG_VIDEO_TW9906_MODULE 1
#define CONFIG_IPV6_ROUTE_INFO 1
#define CONFIG_NETFILTER_ADVANCED 1
#define CONFIG_CRYPTO_DEFLATE_MODULE 1
#define CONFIG_GENERIC_STRNLEN_USER 1
#define CONFIG_USB_APPLEDISPLAY_MODULE 1
#define CONFIG_USB_SERIAL_KLSI_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE 1
#define CONFIG_PGTABLE_MAPPING 1
#define CONFIG_IPV6_ROUTER_PREF 1
#define CONFIG_JFFS2_FS_DEBUG 0
#define CONFIG_XENO_DRIVERS_GPIO 1
#define CONFIG_WLAN_VENDOR_RSI 1
#define CONFIG_SLIP_COMPRESSED 1
#define CONFIG_CRYPTO_JITTERENTROPY_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_L2TP_MODULE 1
#define CONFIG_CRYPTO_GCM_MODULE 1
#define CONFIG_NETFILTER_NETLINK_LOG_MODULE 1
#define CONFIG_HAVE_DYNAMIC_FTRACE 1
#define CONFIG_NLS_ISO8859_14_MODULE 1
#define CONFIG_MAGIC_SYSRQ 1
#define CONFIG_IPV6_SIT_6RD 1
#define CONFIG_PGTABLE_LEVELS 2
#define CONFIG_CPUSETS 1
#define CONFIG_NETFILTER_XT_MATCH_MARK_MODULE 1
#define CONFIG_VIDEO_PVRUSB2_SYSFS 1
#define CONFIG_FUNCTION_PROFILER 1
#define CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
#define CONFIG_ARM_VIRT_EXT 1
#define CONFIG_SPARSE_IRQ 1
#define CONFIG_DVB_LGS8GXX_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP_MODULE 1
#define CONFIG_IP_NF_MANGLE_MODULE 1
#define CONFIG_DVB_VES1X93_MODULE 1
#define CONFIG_FB_TFT_ILI9341_MODULE 1
#define CONFIG_DRM_UDL_MODULE 1
#define CONFIG_DEFAULT_CFQ 1
#define CONFIG_RCU_STALL_COMMON 1
#define CONFIG_BT_DEBUGFS 1
#define CONFIG_INET6_XFRM_MODE_TUNNEL_MODULE 1
#define CONFIG_BRIDGE_EBT_VLAN_MODULE 1
#define CONFIG_MEDIA_SUPPORT_MODULE 1
#define CONFIG_DEBUG_BUGVERBOSE 1
#define CONFIG_IP_NF_FILTER_MODULE 1
#define CONFIG_HID_ZEROPLUS_MODULE 1
#define CONFIG_SND_AUDIOINJECTOR_PI_SOUNDCARD_MODULE 1
#define CONFIG_MAC802154_MODULE 1
#define CONFIG_BCM2835_DEVGPIOMEM_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE 1
#define CONFIG_BRIDGE_EBT_PKTTYPE_MODULE 1
#define CONFIG_MODULES_TREE_LOOKUP 1
#define CONFIG_FAT_FS 1
#define CONFIG_MAY_USE_DEVLINK 1
#define CONFIG_TEXTSEARCH_FSM_MODULE 1
#define CONFIG_SND_BCM2835_MODULE 1
#define CONFIG_SENSORS_LM75_MODULE 1
#define CONFIG_IP6_NF_RAW_MODULE 1
#define CONFIG_SPEAKUP_SYNTH_SOFT_MODULE 1
#define CONFIG_DVB_USB_EC168_MODULE 1
#define CONFIG_USB_ZD1201_MODULE 1
#define CONFIG_NVMEM_MODULE 1
#define CONFIG_INET_TUNNEL_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_NOTRACK_MODULE 1
#define CONFIG_EEPROM_93CX6_MODULE 1
#define CONFIG_PINCONF 1
#define CONFIG_MMC_BLOCK_BOUNCE 1
#define CONFIG_VIDEO_STK1160_AC97 1
#define CONFIG_GENERIC_CLOCKEVENTS 1
#define CONFIG_IOSCHED_CFQ 1
#define CONFIG_OID_REGISTRY 1
#define CONFIG_DVB_USB_DTT200U_MODULE 1
#define CONFIG_CIFS_UPCALL 1
#define CONFIG_RWSEM_XCHGADD_ALGORITHM 1
#define CONFIG_RADIO_TEA575X_MODULE 1
#define CONFIG_LIB80211_MODULE 1
#define CONFIG_MFD_CORE 1
#define CONFIG_HAVE_KERNEL_XZ 1
#define CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5 1
#define CONFIG_USB_CXACRU_MODULE 1
#define CONFIG_CPU_CP15_MMU 1
#define CONFIG_SERIAL_AMBA_PL011 1
#define CONFIG_RFKILL_LEDS 1
#define CONFIG_BT_HCIBTUSB_BCM 1
#define CONFIG_CONSOLE_TRANSLATIONS 1
#define CONFIG_ARCH_SUPPORTS_ATOMIC_RMW 1
#define CONFIG_XENO_OPT_TIMING_KSCHEDLAT 0
#define CONFIG_RAID6_PQ_MODULE 1
#define CONFIG_NET_IPGRE_MODULE 1
#define CONFIG_LIBERTAS_SDIO_MODULE 1
#define CONFIG_BRIDGE_EBT_IP6_MODULE 1
#define CONFIG_NF_NAT_SNMP_BASIC_MODULE 1
#define CONFIG_SERIAL_EARLYCON 1
#define CONFIG_CLS_U32_MARK 1
#define CONFIG_DVB_CX24120_MODULE 1
#define CONFIG_FSCACHE_HISTOGRAM 1
#define CONFIG_SND_SOC_ARIZONA_MODULE 1
#define CONFIG_SND_SOC_SIGMADSP_I2C_MODULE 1
#define CONFIG_LEDS_TRIGGER_BACKLIGHT 1
#define CONFIG_USB_GSPCA_MODULE 1
#define CONFIG_DM_MIRROR_MODULE 1
#define CONFIG_DUMMY_CONSOLE 1
#define CONFIG_SERIAL_AMBA_PL011_CONSOLE 1
#define CONFIG_I2C_BCM2708_BAUDRATE 100000
#define CONFIG_NLS_ASCII 1
#define CONFIG_B43_MODULE 1
#define CONFIG_BAYCOM_SER_FDX_MODULE 1
#define CONFIG_NF_REJECT_IPV4_MODULE 1
#define CONFIG_RTC_DRV_M41T94_MODULE 1
#define CONFIG_WIMAX_DEBUG_LEVEL 8
#define CONFIG_ARCH_MMAP_RND_BITS_MAX 15
#define CONFIG_USB_LAN78XX 1
#define CONFIG_BACKLIGHT_GPIO_MODULE 1
#define CONFIG_6LOWPAN_NHC_MOBILITY_MODULE 1
#define CONFIG_USB_RIO500_MODULE 1
#define CONFIG_IEEE802154_MRF24J40_MODULE 1
#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
#define CONFIG_MFD_SYSCON 1
#define CONFIG_NFS_V3_ACL 1
#define CONFIG_BCM2708_VCMEM 1
#define CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO_V2_MODULE 1
#define CONFIG_GAMEPORT_L4_MODULE 1
#define CONFIG_DETECT_HUNG_TASK 1
#define CONFIG_CAN_MCP251X_MODULE 1
#define CONFIG_CRYPTO_CCM_MODULE 1
#define CONFIG_TCP_CONG_ADVANCED 1
#define CONFIG_NET_CLS_RSVP6_MODULE 1
#define CONFIG_USB_NET_CDC_SUBSET_MODULE 1
#define CONFIG_BT_RTL_MODULE 1
#define CONFIG_DRM_KMS_CMA_HELPER 1
#define CONFIG_QFMT_V2_MODULE 1
#define CONFIG_USB_S2255_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE 1
#define CONFIG_ATH9K_HW_MODULE 1
#define CONFIG_BLK_CGROUP 1
#define CONFIG_USB_SERIAL_MCT_U232_MODULE 1
#define CONFIG_UIO_PDRV_GENIRQ_MODULE 1
#define CONFIG_LEDS_TRIGGERS 1
#define CONFIG_WIMAX_I2400M_DEBUG_LEVEL 8
#define CONFIG_CRYPTO_RNG_MODULE 1
#define CONFIG_USB_SERIAL_GARMIN_MODULE 1
#define CONFIG_W1_MASTER_GPIO_MODULE 1
#define CONFIG_RAW_DRIVER 1
#define CONFIG_XFS_QUOTA 1
#define CONFIG_NET_SCH_ATM_MODULE 1
#define CONFIG_SND_USB 1
#define CONFIG_LOGIG940_FF 1
#define CONFIG_VIDEOBUF2_MEMOPS_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_E2I 1
#define CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
#define CONFIG_USB_SERIAL_KEYSPAN_MODULE 1
#define CONFIG_TREE_RCU 1
#define CONFIG_PWM_SYSFS 1
#define CONFIG_SND_BCM2835_SOC_I2S_MODULE 1
#define CONFIG_FB_TFT_FBTFT_DEVICE_MODULE 1
#define CONFIG_ALLOW_DEV_COREDUMP 1
#define CONFIG_LBDAF 1
#define CONFIG_SWIOTLB 1
#define CONFIG_SND_USB_CAIAQ_MODULE 1
#define CONFIG_USB_STORAGE_CYPRESS_ATACB_MODULE 1
#define CONFIG_EXT4_FS_SECURITY 1
#define CONFIG_BCM2835_WDT 1
#define CONFIG_DVB_S5H1432_MODULE 1
#define CONFIG_IR_XMP_DECODER_MODULE 1
#define CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN 1
#define CONFIG_XENO_DRIVERS_SWITCHTEST 1
#define CONFIG_HID_ROCCAT_MODULE 1
#define CONFIG_INET_XFRM_MODE_TRANSPORT_MODULE 1
#define CONFIG_CRYPTO_MD5_MODULE 1
#define CONFIG_VIDEO_CS53L32A_MODULE 1
#define CONFIG_IR_REDRAT3_MODULE 1
#define CONFIG_USB_GSPCA_VICAM_MODULE 1
#define CONFIG_ISCSI_TCP_MODULE 1
#define CONFIG_NFSD_V3 1
#define CONFIG_MFD_WL1273_CORE_MODULE 1
#define CONFIG_RT2800USB_RT53XX 1
#define CONFIG_MEDIA_TUNER_FC0011_MODULE 1
#define CONFIG_DVB_TDA10023_MODULE 1
#define CONFIG_MEDIA_TUNER_TEA5767_MODULE 1
#define CONFIG_BATMAN_ADV_MODULE 1
#define CONFIG_ELFCORE 1
#define CONFIG_VIDEOBUF_DVB_MODULE 1
#define CONFIG_USB_GSPCA_OV519_MODULE 1
#define CONFIG_BINFMT_ELF 1
#define CONFIG_RTC_DRV_RX4581_MODULE 1
#define CONFIG_XENO_OPT_NRTIMERS 256
#define CONFIG_MD_RAID456_MODULE 1
#define CONFIG_IIO_TRIGGER 1
#define CONFIG_JOYSTICK_IFORCE_USB 1
#define CONFIG_SCHED_TRACER 1
#define CONFIG_UDF_NLS 1
#define CONFIG_HAVE_PERF_REGS 1
#define CONFIG_CIFS_DEBUG 1
#define CONFIG_MEDIA_ANALOG_TV_SUPPORT 1
#define CONFIG_IP_PIMSM_V1 1
#define CONFIG_INET6_AH_MODULE 1
#define CONFIG_CPU_CP15 1
#define CONFIG_CC_STACKPROTECTOR_NONE 1
#define CONFIG_HZ_FIXED 0
#define CONFIG_HID_XINMO_MODULE 1
#define CONFIG_USB_SERIAL_MODULE 1
#define CONFIG_USB_MON_MODULE 1
#define CONFIG_REGULATOR_FIXED_VOLTAGE_MODULE 1
#define CONFIG_NET_VENDOR_RENESAS 1
#define CONFIG_SIGMATEL_FIR_MODULE 1
#define CONFIG_KEYS 1
#define CONFIG_INET_XFRM_TUNNEL_MODULE 1
#define CONFIG_RTC_DRV_FM3130_MODULE 1
#define CONFIG_BRCMDBG 1
#define CONFIG_SND_VMASTER 1
#define CONFIG_NETFILTER_XT_MARK_MODULE 1
#define CONFIG_NETFILTER_XTABLES_MODULE 1
#define CONFIG_IP_VS_LBLC_MODULE 1
#define CONFIG_LEDS_TRIGGER_INPUT 1
#define CONFIG_DVB_USB_OPERA1_MODULE 1
#define CONFIG_MFD_STMPE 1
#define CONFIG_CRYPTO_ECHAINIV_MODULE 1
#define CONFIG_HAVE_ARCH_AUDITSYSCALL 1
#define CONFIG_NMI_LOG_BUF_SHIFT 12
#define CONFIG_SLABINFO 1
#define CONFIG_USB_STORAGE_DATAFAB_MODULE 1
#define CONFIG_DVB_USB_AF9005_MODULE 1
#define CONFIG_TIMER_STATS 1
#define CONFIG_BOOT_PRINTK_DELAY 1
#define CONFIG_MAC80211_RC_MINSTREL_HT 1
#define CONFIG_USB_STORAGE_KARMA_MODULE 1
#define CONFIG_TTPCI_EEPROM_MODULE 1
#define CONFIG_USE_OF 1
#define CONFIG_HID_GREENASIA_MODULE 1
#define CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE 0x1
#define CONFIG_SMS_USB_DRV_MODULE 1
#define CONFIG_HARDIRQS_SW_RESEND 1
#define CONFIG_JFFS2_FS_WRITEBUFFER 1
#define CONFIG_SPI_MASTER 1
#define CONFIG_FB_TFT_RA8875_MODULE 1
#define CONFIG_USB_SERIAL_OPTICON_MODULE 1
#define CONFIG_IEEE802154_AT86RF230_MODULE 1
#define CONFIG_SERIAL_SC16IS7XX_I2C 1
#define CONFIG_DVB_TC90522_MODULE 1
#define CONFIG_DVB_NXT200X_MODULE 1
#define CONFIG_BLK_DEV_THROTTLING 1
#define CONFIG_VT_HW_CONSOLE_BINDING 1
#define CONFIG_MPLS 1
#define CONFIG_VIDEO_TW9903_MODULE 1
#define CONFIG_NET_ACT_GACT_MODULE 1
#define CONFIG_SND_SEQUENCER_OSS 1
#define CONFIG_HID_GYRATION_MODULE 1
#define CONFIG_IRDA_CACHE_LAST_LSAP 1
#define CONFIG_ARCH_MULTI_V7 1
#define CONFIG_USB_WDM_MODULE 1
#define CONFIG_BT_HCIBCM203X_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE 1
#define CONFIG_SND_USB_HIFACE_MODULE 1
#define CONFIG_VIDEO_EM28XX_DVB_MODULE 1
#define CONFIG_USB_SERIAL_KOBIL_SCT_MODULE 1
#define CONFIG_XZ_DEC_X86 1
#define CONFIG_SERIAL_OF_PLATFORM 1
#define CONFIG_MAC80211_LEDS 1
#define CONFIG_INPUT_JOYDEV_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_TPROXY_MODULE 1
#define CONFIG_USB_ACM_MODULE 1
#define CONFIG_USB_RTL8150_MODULE 1
#define CONFIG_CRC16 1
#define CONFIG_USB_NET_AX8817X_MODULE 1
#define CONFIG_GENERIC_CALIBRATE_DELAY 1
#define CONFIG_CRYPTO_GF128MUL_MODULE 1
#define CONFIG_NLS_ISO8859_6_MODULE 1
#define CONFIG_NET_CLS 1
#define CONFIG_XFS_RT 1
#define CONFIG_AX25_MODULE 1
#define CONFIG_MFD_RPISENSE_CORE_MODULE 1
#define CONFIG_TMPFS 1
#define CONFIG_HOSTAP_MODULE 1
#define CONFIG_ANON_INODES 1
#define CONFIG_VIDEO_EM28XX_MODULE 1
#define CONFIG_NLS_CODEPAGE_936_MODULE 1
#define CONFIG_EXTCON_ARIZONA_MODULE 1
#define CONFIG_FUTEX 1
#define CONFIG_IP_PNP_DHCP 1
#define CONFIG_FB_TFT_HX8357D_MODULE 1
#define CONFIG_MCP320X_MODULE 1
#define CONFIG_MMC_SPI_MODULE 1
#define CONFIG_USB_GSPCA_SQ930X_MODULE 1
#define CONFIG_REGMAP_I2C 1
#define CONFIG_GENERIC_SCHED_CLOCK 1
#define CONFIG_JOYSTICK_XPAD_FF 1
#define CONFIG_NETFILTER_XT_TARGET_HL_MODULE 1
#define CONFIG_XENO_REVISION_LEVEL 8
#define CONFIG_DVB_CORE_MODULE 1
#define CONFIG_NFSD_V2_ACL 1
#define CONFIG_CRYPTO_USER_API_MODULE 1
#define CONFIG_HAVE_ARCH_BITREVERSE 1
#define CONFIG_SERIAL_CORE_CONSOLE 1
#define CONFIG_CIFS_WEAK_PW_HASH 1
#define CONFIG_REGMAP_IRQ 1
#define CONFIG_USB_HID 1
#define CONFIG_DVB_USB_AF9015_MODULE 1
#define CONFIG_UBIFS_FS_MODULE 1
#define CONFIG_RTL8192CU_MODULE 1
#define CONFIG_ATM_DRIVERS 1
#define CONFIG_CRYPTO_TGR192_MODULE 1
#define CONFIG_SLUB_DEBUG 1
#define CONFIG_BCM2835_TIMER 1
#define CONFIG_BLK_DEV_MD_MODULE 1
#define CONFIG_USB_SERIAL_AIRCABLE_MODULE 1
#define CONFIG_IP_SET_BITMAP_IP_MODULE 1
#define CONFIG_NET_SCH_INGRESS_MODULE 1
#define CONFIG_BCMA_MODULE 1
#define CONFIG_DMADEVICES 1
#define CONFIG_NF_CONNTRACK_EVENTS 1
#define CONFIG_PINCTRL 1
#define CONFIG_IPV6_NDISC_NODETYPE 1
#define CONFIG_HFS_FS_MODULE 1
#define CONFIG_DVB_USB_TECHNISAT_USB2_MODULE 1
#define CONFIG_NLS_CODEPAGE_1251_MODULE 1
#define CONFIG_FANOTIFY 1
#define CONFIG_MEDIA_TUNER_MXL301RF_MODULE 1
#define CONFIG_IP_VS_PROTO_SCTP 1
#define CONFIG_NETFILTER_XT_MATCH_CONNLABEL_MODULE 1
#define CONFIG_CGROUP_SCHED 1
#define CONFIG_SYSVIPC 1
#define CONFIG_HAVE_DEBUG_KMEMLEAK 1
#define CONFIG_DVB_TDA10071_MODULE 1
#define CONFIG_DVB_OR51211_MODULE 1
#define CONFIG_RT2X00_MODULE 1
#define CONFIG_NLS_CODEPAGE_863_MODULE 1
#define CONFIG_KEYBOARD_GPIO_MODULE 1
#define CONFIG_NF_CONNTRACK_FTP_MODULE 1
#define CONFIG_MODULES 1
#define CONFIG_IP_NF_MATCH_ECN_MODULE 1
#define CONFIG_CPU_HAS_ASID 1
#define CONFIG_USB_GSPCA_SPCA506_MODULE 1
#define CONFIG_VIDEO_EM28XX_ALSA_MODULE 1
#define CONFIG_MEDIA_TUNER_MXL5005S_MODULE 1
#define CONFIG_USB_HIDDEV 1
#define CONFIG_DVB_SI21XX_MODULE 1
#define CONFIG_SOUND 1
#define CONFIG_JOLIET 1
#define CONFIG_SERIAL_SC16IS7XX_MODULE 1
#define CONFIG_DVB_USB_VP7045_MODULE 1
#define CONFIG_MEDIA_TUNER_TDA9887_MODULE 1
#define CONFIG_ARCH_HIBERNATION_POSSIBLE 1
#define CONFIG_DVB_USB_LME2510_MODULE 1
#define CONFIG_UNIX 1
#define CONFIG_USB_CATC_MODULE 1
#define CONFIG_USB_NET_DRIVERS 1
#define CONFIG_NO_HZ_COMMON 1
#define CONFIG_DRM_MIPI_DSI 1
#define CONFIG_HAVE_CLK 1
#define CONFIG_CRYPTO_HASH2 1
#define CONFIG_CARL9170_MODULE 1
#define CONFIG_DVB_CX24117_MODULE 1
#define CONFIG_THERMAL_GOV_STEP_WISE 1
#define CONFIG_DEFAULT_HOSTNAME "(none)"
#define CONFIG_SRCU 1
#define CONFIG_NLS_KOI8_R_MODULE 1
#define CONFIG_USB_GSPCA_SONIXB_MODULE 1
#define CONFIG_DVB_USB_RTL28XXU_MODULE 1
#define CONFIG_USB_STORAGE_ISD200_MODULE 1
#define CONFIG_USB_GSPCA_OV534_9_MODULE 1
#define CONFIG_NFS_FS 1
#define CONFIG_USB_NET_SMSC95XX 1
#define CONFIG_MEMBARRIER 1
#define CONFIG_BLK_DEV_IO_TRACE 1
#define CONFIG_SERIAL_8250_BCM2835AUX 1
#define CONFIG_XPS 1
#define CONFIG_NET_ACT_SKBEDIT_MODULE 1
#define CONFIG_INET_ESP_MODULE 1
#define CONFIG_LZ4_DECOMPRESS_MODULE 1
#define CONFIG_NF_CONNTRACK_ZONES 1
#define CONFIG_DMA_BCM2708 1
#define CONFIG_NF_CONNTRACK_IPV6_MODULE 1
#define CONFIG_FONT_SUPPORT 1
#define CONFIG_ADVISE_SYSCALLS 1
#define CONFIG_MD 1
#define CONFIG_CRYPTO_ALGAPI 1
#define CONFIG_GENERIC_IRQ_SHOW_LEVEL 1
#define CONFIG_BSD_PROCESS_ACCT_V3 1
#define CONFIG_DRM_PANEL_SIMPLE_MODULE 1
#define CONFIG_NET_VENDOR_WIZNET 1
#define CONFIG_BRIDGE_MODULE 1
#define CONFIG_MEDIA_TUNER_MODULE 1
#define CONFIG_USB_CYPRESS_CY7C63_MODULE 1
#define CONFIG_BACKLIGHT_RPI_MODULE 1
#define CONFIG_WANT_DEV_COREDUMP 1
#define CONFIG_INPUT_UINPUT_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_CHECKSUM_MODULE 1
#define CONFIG_LEDS_TRIGGER_GPIO 1
#define CONFIG_RTLWIFI_USB_MODULE 1
#define CONFIG_SND_BCM2708_SOC_ADAU1977_ADC_MODULE 1
#define CONFIG_TINYDRM_MI0283QT_MODULE 1
#define CONFIG_DVB_MB86A16_MODULE 1
#define CONFIG_MEDIA_TUNER_SIMPLE_MODULE 1
#define CONFIG_NET_IP_TUNNEL_MODULE 1
#define CONFIG_MTD_CFI_I1 1
#define CONFIG_NF_NAT_MODULE 1
#define CONFIG_W1_SLAVE_DS2780_MODULE 1
#define CONFIG_MAX_RAW_DEVS 256
#define CONFIG_UBIFS_FS_ZLIB 1
#define CONFIG_USB_SERIAL_XIRCOM_MODULE 1
#define CONFIG_DVB_USB_AZ6027_MODULE 1
#define CONFIG_WLAN_VENDOR_INTERSIL 1
#define CONFIG_IP6_NF_MATCH_RPFILTER_MODULE 1
#define CONFIG_NFS_COMMON 1
#define CONFIG_6LOWPAN_NHC_IPV6_MODULE 1
#define CONFIG_REGULATOR 1
#define CONFIG_FAIR_GROUP_SCHED 1
#define CONFIG_RT2800USB_MODULE 1
#define CONFIG_CRYPTO_HASH 1
#define CONFIG_EFI_PARTITION 1
#define CONFIG_TRACE_CLOCK 1
#define CONFIG_BCMA_BLOCKIO 1
#define CONFIG_LOG_BUF_SHIFT 17
#define CONFIG_OLD_MCOUNT 1
#define CONFIG_WLAN_VENDOR_ATH 1
#define CONFIG_VIDEO_BCM2835_MMAL_MODULE 1
#define CONFIG_NLS_CODEPAGE_857_MODULE 1
#define CONFIG_SOUND_OSS_CORE_PRECLAIM 1
#define CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE 1
#define CONFIG_EXTRA_FIRMWARE ""
#define CONFIG_NET_VENDOR_8390 1
#define CONFIG_MFD_WM5102 1
#define CONFIG_IPV6_MROUTE 1
#define CONFIG_SENSORS_SHT3x_MODULE 1
#define CONFIG_VFAT_FS 1
#define CONFIG_PID_NS 1
#define CONFIG_MD_RAID1_MODULE 1
#define CONFIG_RADIO_TEF6862_MODULE 1
#define CONFIG_CRC32_SLICEBY8 1
#define CONFIG_NET_SCH_FQ_MODULE 1
#define CONFIG_VIDEO_HDPVR_MODULE 1
#define CONFIG_ARCH_BCM 1
#define CONFIG_GPIO_ARIZONA_MODULE 1
#define CONFIG_BLK_DEV_SR_MODULE 1
#define CONFIG_CPU_RMAP 1
#define CONFIG_SND_HWDEP_MODULE 1
#define CONFIG_BCM2835_MBOX 1
#define CONFIG_BLK_DEV_LOOP 1
#define CONFIG_DEFAULT_HUNG_TASK_TIMEOUT 120
#define CONFIG_HAVE_OPTPROBES 1
#define CONFIG_L2TP_ETH_MODULE 1
#define CONFIG_CFQ_GROUP_IOSCHED 1
#define CONFIG_NF_NAT_IRC_MODULE 1
#define CONFIG_MEDIA_TUNER_XC2028_MODULE 1
#define CONFIG_INPUT_MISC 1
#define CONFIG_SND_COMPRESS_OFFLOAD_MODULE 1
#define CONFIG_AUTO_ZRELADDR 1
#define CONFIG_CPU_PABRT_V7 1
#define CONFIG_DVB_STV0288_MODULE 1
#define CONFIG_MULTIUSER 1
#define CONFIG_DMA_OF 1
#define CONFIG_CROSS_MEMORY_ATTACH 1
#define CONFIG_MTD_NAND_ECC_MODULE 1
#define CONFIG_CRYPTO_CBC 1
#define CONFIG_MMC_BCM2835_SDHOST 1
#define CONFIG_MEDIA_CONTROLLER 1
#define CONFIG_NETFILTER_XT_TARGET_HMARK_MODULE 1
#define CONFIG_IP6_NF_MATCH_RT_MODULE 1
#define CONFIG_SQUASHFS_DECOMP_SINGLE 1
#define CONFIG_SERIAL_8250_RUNTIME_UARTS 0
#define CONFIG_BCM2835_SMI_MODULE 1
#define CONFIG_TSL4531_MODULE 1
#define CONFIG_KPROBES 1
#define CONFIG_FS_MBCACHE 1
#define CONFIG_SENSORS_JC42_MODULE 1
#define CONFIG_VIDEO_STK1160_COMMON_MODULE 1
#define CONFIG_GFS2_FS_MODULE 1
#define CONFIG_MEDIA_TUNER_TUA9001_MODULE 1
#define CONFIG_RTC_CLASS 1
#define CONFIG_DVB_TUNER_DIB0070_MODULE 1
#define CONFIG_CRC7_MODULE 1
#define CONFIG_CRYPTO_RNG_DEFAULT_MODULE 1
#define CONFIG_NET_CLS_TCINDEX_MODULE 1
#define CONFIG_USB_EMI26_MODULE 1
#define CONFIG_IP_VS_PROTO_ESP 1
#define CONFIG_MEDIA_TUNER_IT913X_MODULE 1
#define CONFIG_TMPFS_XATTR 1
#define CONFIG_EXT4_USE_FOR_EXT2 1
#define CONFIG_W1_MODULE 1
#define CONFIG_ARM_AMBA 1
#define CONFIG_FB_TFT_MODULE 1
#define CONFIG_USB_GSPCA_VC032X_MODULE 1
#define CONFIG_OPENVSWITCH_GRE_MODULE 1
#define CONFIG_SND_SOC_PCM5102A_MODULE 1
#define CONFIG_IOMMU_HELPER 1
#define CONFIG_DVB_ISL6421_MODULE 1
#define CONFIG_VIDEO_AU0828_RC 1
#define CONFIG_RTC_DRV_DS1374_MODULE 1
#define CONFIG_GENERIC_TRACER 1
#define CONFIG_BCM_VCIO 1
#define CONFIG_NLS_ISO8859_5_MODULE 1
#define CONFIG_IP_VS_WLC_MODULE 1
#define CONFIG_HAVE_FUNCTION_TRACER 1
#define CONFIG_BCM2708_VCHIQ 1
#define CONFIG_NF_NAT_TFTP_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE 1
#define CONFIG_MTD_SPI_NOR_MODULE 1
#define CONFIG_NET_SCH_NETEM_MODULE 1
#define CONFIG_USB_STORAGE_REALTEK_MODULE 1
#define CONFIG_MMC_BCM2835 1
#define CONFIG_CPU_CACHE_V7 1
#define CONFIG_RTC_DRV_DS1307_MODULE 1
#define CONFIG_NFSD_V4 1
#define CONFIG_I2C_SI4713_MODULE 1
#define CONFIG_TOUCHSCREEN_PROPERTIES 1
#define CONFIG_NETFILTER_XT_TARGET_REDIRECT_MODULE 1
#define CONFIG_CRYPTO_MANAGER2 1
#define CONFIG_PM_GENERIC_DOMAINS_OF 1
#define CONFIG_TOUCHSCREEN_USB_3M 1
#define CONFIG_TOUCHSCREEN_USB_EGALAX 1
#define CONFIG_BRIDGE_EBT_DNAT_MODULE 1
#define CONFIG_GENERIC_PCI_IOMAP 1
#define CONFIG_NETFILTER_XT_TARGET_LOG_MODULE 1
#define CONFIG_SLUB 1
#define CONFIG_CONFIGFS_FS 1
#define CONFIG_NET_SCH_HHF_MODULE 1
#define CONFIG_MTD_UBI_MODULE 1
#define CONFIG_XZ_DEC_BCJ 1
#define CONFIG_SLIP_MODULE 1
#define CONFIG_F2FS_FS_XATTR 1
#define CONFIG_I2C 1
#define CONFIG_JFFS2_ZLIB 1
#define CONFIG_PPP_MULTILINK 1
#define CONFIG_BINFMT_SCRIPT 1
#define CONFIG_VIDEO_CX25840_MODULE 1
#define CONFIG_MTD_NAND_BCM2835_SMI_MODULE 1
#define CONFIG_DVB_MN88472_MODULE 1
#define CONFIG_PPS_CLIENT_GPIO_MODULE 1
#define CONFIG_FRAME_POINTER 1
#define CONFIG_BT_HIDP_MODULE 1
#define CONFIG_CPU_ABRT_EV7 1
#define CONFIG_VIDEO_CX231XX_RC 1
#define CONFIG_TICK_CPU_ACCOUNTING 1
#define CONFIG_BRCM_CHAR_DRIVERS 1
#define CONFIG_VM_EVENT_COUNTERS 1
#define CONFIG_MEDIA_COMMON_OPTIONS 1
#define CONFIG_RELAY 1
#define CONFIG_USB_GSPCA_FINEPIX_MODULE 1
#define CONFIG_CRYPTO_ECB_MODULE 1
#define CONFIG_USB_GSPCA_ETOMS_MODULE 1
#define CONFIG_WLAN_VENDOR_BROADCOM 1
#define CONFIG_SQUASHFS_LZO 1
#define CONFIG_6LOWPAN_NHC_HOP_MODULE 1
#define CONFIG_NF_CONNTRACK_AMANDA_MODULE 1
#define CONFIG_BCM2835_SMI_DEV_MODULE 1
#define CONFIG_DEBUG_FS 1
#define CONFIG_JOYSTICK_RPISENSE_MODULE 1
#define CONFIG_HAVE_KERNEL_LZ4 1
#define CONFIG_NET_PKTGEN_MODULE 1
#define CONFIG_TRACING_EVENTS_GPIO 1
#define CONFIG_USB_SERIAL_EDGEPORT_MODULE 1
#define CONFIG_BASE_FULL 1
#define CONFIG_FB_CFB_IMAGEBLIT 1
#define CONFIG_ZLIB_DEFLATE_MODULE 1
#define CONFIG_SUNRPC 1
#define CONFIG_INPUT_ATI_REMOTE2_MODULE 1
#define CONFIG_NLS_CODEPAGE_864_MODULE 1
#define CONFIG_IIO_BUFFER 1
#define CONFIG_IP_VS_LBLCR_MODULE 1
#define CONFIG_GPIO_SYSFS 1
#define CONFIG_USB_YUREX_MODULE 1
#define CONFIG_FW_LOADER 1
#define CONFIG_IP6_NF_NAT_MODULE 1
#define CONFIG_KALLSYMS 1
#define CONFIG_COMMON_CLK 1
#define CONFIG_USB_GSPCA_SPCA501_MODULE 1
#define CONFIG_CRYPTO_XTS_MODULE 1
#define CONFIG_PWM 1
#define CONFIG_NETFILTER_XT_MATCH_RECENT_MODULE 1
#define CONFIG_BT_BCM_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE 1
#define CONFIG_MII 1
#define CONFIG_SIGNALFD 1
#define CONFIG_NET_CORE 1
#define CONFIG_VIDEO_CPIA2_MODULE 1
#define CONFIG_EXT4_FS 1
#define CONFIG_NET_SCH_DRR_MODULE 1
#define CONFIG_BRIDGE_EBT_802_3_MODULE 1
#define CONFIG_SERIAL_SC16IS7XX_SPI 1
#define CONFIG_HAVE_HW_BREAKPOINT 1
#define CONFIG_KRETPROBES 1
#define CONFIG_SND_JACK_INPUT_DEV 1
#define CONFIG_ARM_DMA_MEM_BUFFERABLE 1
#define CONFIG_CRYPTO_SHA1_MODULE 1
#define CONFIG_BPQETHER_MODULE 1
#define CONFIG_USB_ADUTUX_MODULE 1
#define CONFIG_VIDEO_UDA1342_MODULE 1
#define CONFIG_MT7601U_MODULE 1
#define CONFIG_ARCH_WANT_GENERAL_HUGETLB 1
#define CONFIG_NLS_KOI8_U_MODULE 1
#define CONFIG_RADIO_SHARK2_MODULE 1
#define CONFIG_CRC8_MODULE 1
#define CONFIG_XZ_DEC 1
#define CONFIG_USB_BELKIN 1
#define CONFIG_CAN_VCAN_MODULE 1
#define CONFIG_ATH_COMMON_MODULE 1
#define CONFIG_LOCKD_V4 1
#define CONFIG_DUMMY_MODULE 1
#define CONFIG_W1_SLAVE_DS2431_MODULE 1
#define CONFIG_DVB_TUNER_CX24113_MODULE 1
#define CONFIG_BRIDGE_EBT_MARK_T_MODULE 1
#define CONFIG_WATCHDOG 1
#define CONFIG_HAS_IOMEM 1
#define CONFIG_RING_BUFFER_ALLOW_SWAP 1
#define CONFIG_SND_RAWMIDI_MODULE 1
#define CONFIG_MFD_ARIZONA_SPI_MODULE 1
#define CONFIG_NF_LOG_IPV6_MODULE 1
#define CONFIG_LIRC_SASEM_MODULE 1
#define CONFIG_DRM_VC4_MODULE 1
#define CONFIG_IEEE802154_SOCKET_MODULE 1
#define CONFIG_USB_GSPCA_STK1135_MODULE 1
#define CONFIG_GENERIC_IRQ_PROBE 1
#define CONFIG_ATH6KL_USB_MODULE 1
#define CONFIG_USB_NET_CDC_EEM_MODULE 1
#define CONFIG_USB_STORAGE_SDDR09_MODULE 1
#define CONFIG_IP_NF_MATCH_TTL_MODULE 1
#define CONFIG_ASYNC_RAID6_RECOV_MODULE 1
#define CONFIG_PWRSEQ_EMMC 1
#define CONFIG_VIDEOMODE_HELPERS 1
#define CONFIG_FB_TFT_SSD1289_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE 1
#define CONFIG_IRDA_ULTRA 1
#define CONFIG_DVB_HD29L2_MODULE 1
#define CONFIG_RTC_DRV_X1205_MODULE 1
#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
#define CONFIG_IP6_NF_MATCH_FRAG_MODULE 1
#define CONFIG_HDC100X_MODULE 1
#define CONFIG_USB_SERIAL_CYBERJACK_MODULE 1
#define CONFIG_NET_SCH_PRIO_MODULE 1
#define CONFIG_SCHED_HRTICK 1
#define CONFIG_TOUCHSCREEN_EXC3000_MODULE 1
#define CONFIG_DVB_DRXK_MODULE 1
#define CONFIG_USB_SERIAL_IUU_MODULE 1
#define CONFIG_VIDEO_GO7007_USB_S2250_BOARD_MODULE 1
#define CONFIG_EPOLL 1
#define CONFIG_CRYPTO_LZO_MODULE 1
#define CONFIG_SND_PCM_MODULE 1
#define CONFIG_BRIDGE_EBT_SNAT_MODULE 1
#define CONFIG_SND_PISOUND_MODULE 1
#define CONFIG_XENO_ARCH_WANT_TIP 1
#define CONFIG_MMC_BCM2835_DMA 1
#define CONFIG_PARTITION_ADVANCED 1
#define CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE 1
#define CONFIG_BT_BNEP_MC_FILTER 1
#define CONFIG_CRYPTO_CRC32 1
#define CONFIG_SCSI_ISCSI_ATTRS 1
#define CONFIG_HAVE_NET_DSA 1
#define CONFIG_USB_SERIAL_EMPEG_MODULE 1
#define CONFIG_IR_SONY_DECODER_MODULE 1
#define CONFIG_NLS_CODEPAGE_852_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_IDEALTEK 1
#define CONFIG_VIDEO_PVRUSB2_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE 1
#define CONFIG_NFS_SWAP 1
#define CONFIG_FB_SSD1307_MODULE 1
#define CONFIG_GPIO_BCM_EXP 1
#define CONFIG_USB_NET_RNDIS_HOST_MODULE 1
#define CONFIG_NET 1
#define CONFIG_INPUT_EVDEV_MODULE 1
#define CONFIG_SND_JACK 1
#define CONFIG_XENO_VERSION_MAJOR 3
#define CONFIG_NETFILTER_XT_TARGET_TCPMSS_MODULE 1
#define CONFIG_FB_TFT_SSD1351_MODULE 1
#define CONFIG_I2C_BCM2708_MODULE 1
#define CONFIG_B43LEGACY_DMA 1
#define CONFIG_BMP280_SPI_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE 1
#define CONFIG_CRYPTO_WP512_MODULE 1
#define CONFIG_STMPE_SPI 1
#define CONFIG_HID_DRAGONRISE_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE 1
#define CONFIG_ARM_ARCH_TIMER_EVTSTREAM 1
#define CONFIG_IR_IGUANA_MODULE 1
#define CONFIG_XENO_OPT_PRIVATE_HEAPSZ 256
#define CONFIG_NETFILTER_XT_MATCH_RATEEST_MODULE 1
#define CONFIG_PWRSEQ_SIMPLE 1
#define CONFIG_VFPv3 1
#define CONFIG_SND_ALOOP_MODULE 1
#define CONFIG_PINMUX 1
#define CONFIG_USB_LD_MODULE 1
#define CONFIG_QUOTA_TREE_MODULE 1
#define CONFIG_USB_NET_CDCETHER_MODULE 1
#define CONFIG_PACKET 1
#define CONFIG_MODULE_SRCVERSION_ALL 1
#define CONFIG_XFRM_ALGO 1
#define CONFIG_SND_SIMPLE_CARD_UTILS_MODULE 1
#define CONFIG_NF_CONNTRACK_TIMESTAMP 1
#define CONFIG_HAVE_CLK_PREPARE 1
#define CONFIG_CRYPTO_AKCIPHER2 1
#define CONFIG_MWIFIEX_SDIO_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_IPRANGE_MODULE 1
#define CONFIG_NET_CLS_BASIC_MODULE 1
#define CONFIG_NETROM_MODULE 1
#define CONFIG_BTRFS_FS_POSIX_ACL 1
#define CONFIG_USB_GSPCA_OV534_MODULE 1
#define CONFIG_FRONTSWAP 1
#define CONFIG_DVB_USB_GL861_MODULE 1
#define CONFIG_MFD_ARIZONA_I2C_MODULE 1
#define CONFIG_NF_CONNTRACK_TFTP_MODULE 1
#define CONFIG_NFS_V3 1
#define CONFIG_RTC_DRV_MAX6902_MODULE 1
#define CONFIG_DVB_USB_ANYSEE_MODULE 1
#define CONFIG_NLS_CODEPAGE_949_MODULE 1
#define CONFIG_DVB_CX24110_MODULE 1
#define CONFIG_SENSORS_TMP102_MODULE 1
#define CONFIG_NOP_TRACER 1
#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
#define CONFIG_INET 1
#define CONFIG_IP_ROUTE_VERBOSE 1
#define CONFIG_XZ_DEC_POWERPC 1
#define CONFIG_DVB_RTL2832_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE 1
#define CONFIG_PREVENT_FIRMWARE_BUILD 1
#define CONFIG_USB_NET_MCS7830_MODULE 1
#define CONFIG_FREEZER 1
#define CONFIG_W1_SLAVE_DS2413_MODULE 1
#define CONFIG_USB_TEST_MODULE 1
#define CONFIG_BT_MODULE 1
#define CONFIG_BT_HCIVHCI_MODULE 1
#define CONFIG_INPUT_CM109_MODULE 1
#define CONFIG_DVB_USB_MXL111SF_MODULE 1
#define CONFIG_SPI_BCM2835_MODULE 1
#define CONFIG_NET_CLS_ACT 1
#define CONFIG_XENO_OPT_SYS_HEAPSZ 4096
#define CONFIG_CIFS_DFS_UPCALL 1
#define CONFIG_BRIDGE_EBT_BROUTE_MODULE 1
#define CONFIG_USB_NET_SMSC75XX_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE 1
#define CONFIG_IP_SET_MAX 256
#define CONFIG_HID_WACOM_MODULE 1
#define CONFIG_USB_SERIAL_CP210X_MODULE 1
#define CONFIG_NET_SCH_SFQ_MODULE 1
#define CONFIG_NEED_KUSER_HELPERS 1
#define CONFIG_RTC_LIB 1
#define CONFIG_XENO_OPT_REGISTRY_NRSLOTS 512
#define CONFIG_USB_UEAGLEATM_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE 1
#define CONFIG_HAVE_KPROBES 1
#define CONFIG_FB_TFT_AGM1264K_FL_MODULE 1
#define CONFIG_IP_ROUTE_CLASSID 1
#define CONFIG_NETFILTER_XT_TARGET_TEE_MODULE 1
#define CONFIG_ENC28J60_MODULE 1
#define CONFIG_USB_SERIAL_XSENS_MT_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_ITM 1
#define CONFIG_CRYPTO_AES 1
#define CONFIG_DVB_DIB7000P_MODULE 1
#define CONFIG_GPIOLIB 1
#define CONFIG_SSB_MODULE 1
#define CONFIG_DM_BIO_PRISON_MODULE 1
#define CONFIG_VIDEO_EM28XX_RC_MODULE 1
#define CONFIG_RADIO_TEA5764_MODULE 1
#define CONFIG_DVB_LNBH25_MODULE 1
#define CONFIG_USB_GSPCA_SPCA1528_MODULE 1
#define CONFIG_HID_PID 1
#define CONFIG_USB_SERIAL_QT2_MODULE 1
#define CONFIG_GAMEPORT_MODULE 1
#define CONFIG_ISO9660_FS_MODULE 1
#define CONFIG_NETFILTER_XT_NAT_MODULE 1
#define CONFIG_BT_HCIUART_H4 1
#define CONFIG_RTC_DRV_DS3232_MODULE 1
#define CONFIG_SWP_EMULATE 1
#define CONFIG_CLKSRC_MMIO 1
#define CONFIG_CRYPTO_AES_ARM_BS_MODULE 1
#define CONFIG_SND_PCM_ELD 1
#define CONFIG_DVB_USB_M920X_MODULE 1
#define CONFIG_UIO_MODULE 1
#define CONFIG_SND_ARM 1
#define CONFIG_SND_BCM2708_SOC_GOOGLEVOICEHAT_SOUNDCARD_MODULE 1
#define CONFIG_HID_WALTOP_MODULE 1
#define CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR 1
#define CONFIG_B43LEGACY_DEBUG 1
#define CONFIG_NF_CONNTRACK_MARK 1
#define CONFIG_NETFILTER 1
#define CONFIG_RC_LOOPBACK_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE 1
#define CONFIG_BRIDGE_EBT_AMONG_MODULE 1
#define CONFIG_B43_PIO 1
#define CONFIG_B43_BUSES_BCMA_AND_SSB 1
#define CONFIG_NET_VENDOR_SMSC 1
#define CONFIG_NETFILTER_NETLINK_ACCT_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_CLUSTER_MODULE 1
#define CONFIG_USB_KC2190 1
#define CONFIG_USB_MDC800_MODULE 1
#define CONFIG_6LOWPAN_MODULE 1
#define CONFIG_SERIO_SERPORT_MODULE 1
#define CONFIG_NLS_CODEPAGE_950_MODULE 1
#define CONFIG_DVB_STV0297_MODULE 1
#define CONFIG_CLONE_BACKWARDS 1
#define CONFIG_LEDS_TRIGGER_ONESHOT 1
#define CONFIG_HAVE_NMI 1
#define CONFIG_LIRC_MODULE 1
#define CONFIG_BT_BNEP_MODULE 1
#define CONFIG_NET_SCH_QFQ_MODULE 1
#define CONFIG_DVB_TDA826X_MODULE 1
#define CONFIG_BLK_DEV_RAM_COUNT 16
#define CONFIG_IP_MROUTE 1
#define CONFIG_INET_XFRM_MODE_TUNNEL_MODULE 1
#define CONFIG_XENO_OPT_HOSTRT 1
#define CONFIG_NF_NAT_NEEDED 1
#define CONFIG_TINYDRM_MIPI_DBI_MODULE 1
#define CONFIG_NF_CONNTRACK_SNMP_MODULE 1
#define CONFIG_SND_DRIVERS 1
#define CONFIG_USB_SERIAL_BELKIN_MODULE 1
#define CONFIG_W1_MASTER_DS2490_MODULE 1
#define CONFIG_PRINTK_NMI 1
#define CONFIG_MEDIA_TUNER_MT2266_MODULE 1
#define CONFIG_NET_FLOW_LIMIT 1
#define CONFIG_XFS_FS_MODULE 1
#define CONFIG_INPUT_KEYSPAN_REMOTE_MODULE 1
#define CONFIG_USB_GSPCA_PAC7302_MODULE 1
#define CONFIG_LOCKDEP_SUPPORT 1
#define CONFIG_NLS_CODEPAGE_869_MODULE 1
#define CONFIG_IP6_NF_TARGET_MASQUERADE_MODULE 1
#define CONFIG_TOUCHSCREEN_EGALAX_MODULE 1
#define CONFIG_SPI_BCM2835AUX_MODULE 1
#define CONFIG_NO_HZ 1
#define CONFIG_POSIX_MQUEUE 1
#define CONFIG_NETFILTER_INGRESS 1
#define CONFIG_XENO_ARCH_UNLOCKED_SWITCH 1
#define CONFIG_USB_NET_CDC_MBIM_MODULE 1
#define CONFIG_JFS_STATISTICS 1
#define CONFIG_GENERIC_STRNCPY_FROM_USER 1
#define CONFIG_CHR_DEV_OSST_MODULE 1
#define CONFIG_FB_TFT_SSD1331_MODULE 1
#define CONFIG_MTD_BLKDEVS_MODULE 1
#define CONFIG_ARM_HAS_SG_CHAIN 1
#define CONFIG_DVB_TDA10086_MODULE 1
#define CONFIG_NET_SCH_MQPRIO_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_NETMAP_MODULE 1
#define CONFIG_FB_BCM2708 1
#define CONFIG_DVB_NXT6000_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE 1
#define CONFIG_XENO_OPT_RTDM_COMPAT_DEVNODE 1
#define CONFIG_SMS_SIANO_RC 1
#define CONFIG_SND_PCM_OSS_PLUGINS 1
#define CONFIG_NLS_ISO8859_15_MODULE 1
#define CONFIG_INET6_ESP_MODULE 1
#define CONFIG_IP_VS_WRR_MODULE 1
#define CONFIG_AUTOFS4_FS 1
#define CONFIG_NETFILTER_XT_SET_MODULE 1
#define CONFIG_OF_CONFIGFS 1
#define CONFIG_TASKSTATS 1
#define CONFIG_NLS_CODEPAGE_932_MODULE 1
#define CONFIG_JFS_POSIX_ACL 1
#define CONFIG_IP6_NF_FILTER_MODULE 1
#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
#define CONFIG_NEED_DMA_MAP_STATE 1
#define CONFIG_FB_TFT_ILI9340_MODULE 1
#define CONFIG_IIO_MODULE 1
#define CONFIG_SND_HDA_PREALLOC_SIZE 64
#define CONFIG_GARP_MODULE 1
#define CONFIG_RT2500USB_MODULE 1
#define CONFIG_BLK_DEV_DRBD_MODULE 1
#define CONFIG_IP_VS_PROTO_TCP 1
#define CONFIG_ISCSI_BOOT_SYSFS_MODULE 1
#define CONFIG_NET_SCH_RED_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_NFACCT_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE 1
#define CONFIG_USB_SERIAL_METRO_MODULE 1
#define CONFIG_PAGE_OFFSET 0x80000000
#define CONFIG_USB_PRINTER_MODULE 1
#define CONFIG_FONT_8x8 1
#define CONFIG_USB_GSPCA_PAC207_MODULE 1
#define CONFIG_USB_SERIAL_IR_MODULE 1
#define CONFIG_CPU_V7 1
#define CONFIG_XOR_BLOCKS_MODULE 1
#define CONFIG_HID_TWINHAN_MODULE 1
#define CONFIG_PANIC_TIMEOUT 0
#define CONFIG_ZBOOT_ROM_BSS 0x0
#define CONFIG_XENO_DRIVERS_AUTOTUNE 1
#define CONFIG_INPUT_JOYSTICK 1
#define CONFIG_NET_ACT_SIMP_MODULE 1
#define CONFIG_RT2X00_LIB_MODULE 1
#define CONFIG_HID_BATTERY_STRENGTH 1
#define CONFIG_YAM_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_ECN_MODULE 1
#define CONFIG_USB_GSPCA_STV0680_MODULE 1
#define CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT 1
#define CONFIG_ATH9K_PCOEM 1
#define CONFIG_USB_STORAGE_SDDR55_MODULE 1
#define CONFIG_FB_TFT_S6D02A1_MODULE 1
#define CONFIG_IP_NF_TARGET_TTL_MODULE 1
#define CONFIG_NF_NAT_MASQUERADE_IPV4_MODULE 1
#define CONFIG_CFG80211_DEFAULT_PS 1
#define CONFIG_BUILD_BIN2C 1
#define CONFIG_USBIP_HOST_MODULE 1
#define CONFIG_SND_SOC_ADAU7002_MODULE 1
#define CONFIG_POWER_RESET_GPIO 1
#define CONFIG_DVB_OR51132_MODULE 1
#define CONFIG_RT2X00_LIB_FIRMWARE 1
#define CONFIG_SMP 1
#define CONFIG_DVB_ZL10353_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_TIME_MODULE 1
#define CONFIG_TTY 1
#define CONFIG_IP_VS_MODULE 1
#define CONFIG_HAVE_KERNEL_GZIP 1
#define CONFIG_ZSMALLOC_MODULE 1
#define CONFIG_NET_VENDOR_I825XX 1
#define CONFIG_USB_XUSBATM_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_MAC_MODULE 1
#define CONFIG_NET_ACT_PEDIT_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_JASTEC 1
#define CONFIG_GENERIC_ALLOCATOR 1
#define CONFIG_OPENVSWITCH_MODULE 1
#define CONFIG_RTC_DRV_DS1390_MODULE 1
#define CONFIG_L2TP_MODULE 1
#define CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE 1
#define CONFIG_TCP_CONG_WESTWOOD_MODULE 1
#define CONFIG_RTC_DRV_M41T93_MODULE 1
#define CONFIG_KALLSYMS_ALL 1
#define CONFIG_USB_GSPCA_SPCA561_MODULE 1
#define CONFIG_GENERIC_IO 1
#define CONFIG_LIBCRC32C 1
#define CONFIG_ARCH_NR_GPIO 0
#define CONFIG_GENERIC_BUG 1
#define CONFIG_CRYPTO_SHA256_MODULE 1
#define CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
#define CONFIG_RTC_DRV_DS1307_HWMON 1
#define CONFIG_VIDEO_AU0828_MODULE 1
#define CONFIG_INET_TCP_DIAG_MODULE 1
#define CONFIG_HID_SONY_MODULE 1
#define CONFIG_VIDEO_PVRUSB2_DVB 1
#define CONFIG_HW_CONSOLE 1
#define CONFIG_MDIO_BITBANG_MODULE 1
#define CONFIG_NET_ACT_IPT_MODULE 1
#define CONFIG_DVB_AS102_MODULE 1
#define CONFIG_VIDEO_GO7007_LOADER_MODULE 1
#define CONFIG_DEVMEM 1
#define CONFIG_ARM_PMU 1
#define CONFIG_USB_GSPCA_ZC3XX_MODULE 1
#define CONFIG_SND_SPI 1
#define CONFIG_BRIDGE_EBT_IP_MODULE 1
#define CONFIG_HID_MONTEREY_MODULE 1
#define CONFIG_FB_UDL_MODULE 1
#define CONFIG_USB_SERIAL_CYPRESS_M8_MODULE 1
#define CONFIG_HID_EZKEY_MODULE 1
#define CONFIG_IOSCHED_NOOP 1
#define CONFIG_DVB_S5H1409_MODULE 1
#define CONFIG_DM_THIN_PROVISIONING_MODULE 1
#define CONFIG_HAVE_UID16 1
#define CONFIG_W1_SLAVE_DS2438_MODULE 1
#define CONFIG_JOYSTICK_XPAD_LEDS 1
#define CONFIG_BT_MRVL_MODULE 1
#define CONFIG_QUOTACTL 1
#define CONFIG_RTC_DRV_RX8581_MODULE 1
#define CONFIG_CRYPTO_CRYPTD_MODULE 1
#define CONFIG_NEON 1
#define CONFIG_IPIPE_WANT_ACTIVE_MM 1
#define CONFIG_TOUCHSCREEN_RPI_FT5406_MODULE 1
#define CONFIG_USBIP_VHCI_HCD_MODULE 1
#define CONFIG_DEBUG_KERNEL 1
#define CONFIG_HAVE_ARM_SMCCC 1
#define CONFIG_GAMEPORT_NS558_MODULE 1
#define CONFIG_INV_MPU6050_IIO_MODULE 1
#define CONFIG_VIDEO_CX2341X_MODULE 1
#define CONFIG_LOCALVERSION "-rpi-xeno-3.0.8"
#define CONFIG_REISERFS_FS_SECURITY 1
#define CONFIG_DVB_STV6110x_MODULE 1
#define CONFIG_XENO_VERSION_STRING "3.0.8"
#define CONFIG_RADIO_ADAPTERS 1
#define CONFIG_NFS_FSCACHE 1
#define CONFIG_MAC80211_MESH 1
#define CONFIG_USB_GSPCA_TOPRO_MODULE 1
#define CONFIG_USB_GSPCA_MARS_MODULE 1
#define CONFIG_CAN_RAW_MODULE 1
#define CONFIG_DVB_SI2165_MODULE 1
#define CONFIG_CRYPTO 1
#define CONFIG_I2C_MUX_PCA954x_MODULE 1
#define CONFIG_FUNCTION_TRACER 1
#define CONFIG_USB_TRANCEVIBRATOR_MODULE 1
#define CONFIG_SCHED_DEBUG 1
#define CONFIG_USB_STKWEBCAM_MODULE 1
#define CONFIG_BTRFS_FS_MODULE 1
#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
#define CONFIG_SND_USB_6FIRE_MODULE 1
#define CONFIG_INPUT_AD714X_I2C_MODULE 1
#define CONFIG_XENO_VERSION_MINOR 0
#define CONFIG_MEDIA_TUNER_TDA18218_MODULE 1
#define CONFIG_IP_NF_IPTABLES_MODULE 1
#define CONFIG_CMDLINE "console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
#define CONFIG_W1_SLAVE_BQ27000_MODULE 1
#define CONFIG_BT_BNEP_PROTO_FILTER 1
#define CONFIG_USB_GSPCA_CPIA1_MODULE 1
#define CONFIG_HAVE_DMA_API_DEBUG 1
#define CONFIG_IPIPE_CORE_APIREV 2
#define CONFIG_DEFAULT_CUBIC 1
#define CONFIG_HID_SAMSUNG_MODULE 1
#define CONFIG_IP_SET_LIST_SET_MODULE 1
#define CONFIG_IP_PIMSM_V2 1
#define CONFIG_HW_PERF_EVENTS 1
#define CONFIG_VIDEO_TW2804_MODULE 1
#define CONFIG_USB_ISIGHTFW_MODULE 1
#define CONFIG_DMA_VIRTUAL_CHANNELS 1
#define CONFIG_SND_SEQ_HRTIMER_DEFAULT 1
#define CONFIG_USB_ARCH_HAS_HCD 1
#define CONFIG_DVB_DIB3000MC_MODULE 1
#define CONFIG_CACHEFILES 1
#define CONFIG_GENERIC_IRQ_SHOW 1
#define CONFIG_TINYDRM_REPAPER_MODULE 1
#define CONFIG_ARCH_HAS_ELF_RANDOMIZE 1
#define CONFIG_9P_FS_MODULE 1
#define CONFIG_PANIC_ON_OOPS_VALUE 0
#define CONFIG_NET_VENDOR_SAMSUNG 1
#define CONFIG_ALIGNMENT_TRAP 1
#define CONFIG_IIO_MS_SENSORS_I2C_MODULE 1
#define CONFIG_SCSI_MOD 1
#define CONFIG_NET_VENDOR_MICREL 1
#define CONFIG_FB_TFT_UPD161704_MODULE 1
#define CONFIG_F2FS_FS_POSIX_ACL 1
#define CONFIG_USB_SERIAL_SPCP8X5_MODULE 1
#define CONFIG_BCM_VC_SM 1
#define CONFIG_RC_DECODERS 1
#define CONFIG_B43_LEDS 1
#define CONFIG_P54_USB_MODULE 1
#define CONFIG_USB_GSPCA_KINECT_MODULE 1
#define CONFIG_USB_SERIAL_WISHBONE_MODULE 1
#define CONFIG_USB_NET_HUAWEI_CDC_NCM_MODULE 1
#define CONFIG_OPROFILE_MODULE 1
#define CONFIG_CRYPTO_CRC32C 1
#define CONFIG_SERIAL_CORE 1
#define CONFIG_FUSE_FS_MODULE 1
#define CONFIG_BUILDTIME_EXTABLE_SORT 1
#define CONFIG_HANDLE_DOMAIN_IRQ 1
#define CONFIG_UID16 1
#define CONFIG_SND_SOC_PCM512x_MODULE 1
#define CONFIG_EMBEDDED 1
#define CONFIG_HID_MICROSOFT_MODULE 1
#define CONFIG_RTC_DRV_S35390A_MODULE 1
#define CONFIG_HAVE_KRETPROBES 1
#define CONFIG_ASSOCIATIVE_ARRAY 1
#define CONFIG_NF_DEFRAG_IPV6_MODULE 1
#define CONFIG_USB_GSPCA_CONEX_MODULE 1
#define CONFIG_DRM_LOAD_EDID_FIRMWARE 1
#define CONFIG_VIDEO_DEV_MODULE 1
#define CONFIG_NFS_V4 1
#define CONFIG_IRCOMM_MODULE 1
#define CONFIG_PPP_FILTER 1
#define CONFIG_MAILBOX 1
#define CONFIG_INPUT_LEDS 1
#define CONFIG_INLINE_READ_UNLOCK 1
#define CONFIG_SOUND_PRIME_MODULE 1
#define CONFIG_HAS_DMA 1
#define CONFIG_NF_CT_PROTO_SCTP_MODULE 1
#define CONFIG_USB_SERIAL_VISOR_MODULE 1
#define CONFIG_USB_DWCOTG 1
#define CONFIG_DVB_AS102_FE_MODULE 1
#define CONFIG_SND_SOC_CS42XX8_I2C_MODULE 1
#define CONFIG_SCSI 1
#define CONFIG_LEDS_TRIGGER_PANIC 1
#define CONFIG_DVB_CXD2841ER_MODULE 1
#define CONFIG_FB_CFB_FILLRECT 1
#define CONFIG_AT76C50X_USB_MODULE 1
#define CONFIG_FUNCTION_GRAPH_TRACER 1
#define CONFIG_NF_NAT_PPTP_MODULE 1
#define CONFIG_HID_CHICONY_MODULE 1
#define CONFIG_HID 1
#define CONFIG_LIBERTAS_THINFIRM_USB_MODULE 1
#define CONFIG_IPIPE_WANT_APIREV_2 1
#define CONFIG_SLIP_SMART 1
#define CONFIG_NLS_ISO8859_9_MODULE 1
#define CONFIG_SND_SERIAL_U16550_MODULE 1
#define CONFIG_USB_ARMLINUX 1
#define CONFIG_IP_VS_PE_SIP_MODULE 1
#define CONFIG_RTLWIFI_MODULE 1
#define CONFIG_CLKDEV_LOOKUP 1
#define CONFIG_LEDS_TRIGGER_DEFAULT_ON 1
#define CONFIG_FONT_8x16 1
#define CONFIG_MAC80211_HWSIM_MODULE 1
#define CONFIG_DVB_LGDT330X_MODULE 1
#define CONFIG_SERIAL_8250_FSL 1
#define CONFIG_IEEE802154_DRIVERS_MODULE 1
#define CONFIG_RTC_DRV_RV3029_HWMON 1
#define CONFIG_TCP_CONG_BBR_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_IRTOUCH 1
#define CONFIG_USB_PWC_MODULE 1
#define CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
#define CONFIG_MEDIA_TUNER_TDA8290_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_PANJIT 1
#define CONFIG_BONDING_MODULE 1
#define CONFIG_MEDIA_TUNER_TDA18212_MODULE 1
#define CONFIG_MCP3422_MODULE 1
#define CONFIG_RTC_DRV_EM3027_MODULE 1
#define CONFIG_6LOWPAN_NHC_DEST_MODULE 1
#define CONFIG_VEML6070_MODULE 1
#define CONFIG_JBD2 1
#define CONFIG_USBIP_CORE_MODULE 1
#define CONFIG_SND_BCM2708_SOC_RPI_DAC_MODULE 1
#define CONFIG_INET6_IPCOMP_MODULE 1
#define CONFIG_IRDA_FAST_RR 1
#define CONFIG_NET_VENDOR_MARVELL 1
#define CONFIG_PHYLIB 1
#define CONFIG_IPV6_TUNNEL_MODULE 1
#define CONFIG_W1_SLAVE_DS2760_MODULE 1
#define CONFIG_NET_VENDOR_FARADAY 1
#define CONFIG_DVB_TDA665x_MODULE 1
#define CONFIG_NLS_CODEPAGE_874_MODULE 1
#define CONFIG_FB_CMDLINE 1
#define CONFIG_IRQ_DOMAIN 1
#define CONFIG_UNCOMPRESS_INCLUDE "debug/uncompress.h"
#define CONFIG_PPS_CLIENT_LDISC_MODULE 1
#define CONFIG_MEDIA_TUNER_MT20XX_MODULE 1
#define CONFIG_JFFS2_RTIME 1
#define CONFIG_IPC_NS 1
#define CONFIG_DVB_HORUS3A_MODULE 1
#define CONFIG_MISC_FILESYSTEMS 1
#define CONFIG_ARCH_MMAP_RND_BITS_MIN 8
#define CONFIG_FTRACE 1
#define CONFIG_NETFILTER_XT_MATCH_CONNLIMIT_MODULE 1
#define CONFIG_IP_NF_RAW_MODULE 1
#define CONFIG_HAVE_CC_STACKPROTECTOR 1
#define CONFIG_IP_NF_ARPFILTER_MODULE 1
#define CONFIG_ARM_L1_CACHE_SHIFT_6 1
#define CONFIG_TOUCHSCREEN_USB_ETT_TC45USB 1
#define CONFIG_LIRC_SERIAL_TRANSMITTER 1
#define CONFIG_W1_CON 1
#define CONFIG_MIGHT_HAVE_CACHE_L2X0 1
#define CONFIG_NETFILTER_XT_MATCH_SOCKET_MODULE 1
#define CONFIG_PPPOL2TP_MODULE 1
#define CONFIG_FB_TFT_TLS8204_MODULE 1
#define CONFIG_R8712U_MODULE 1
#define CONFIG_HID_TOPSEED_MODULE 1
#define CONFIG_B43_PHY_HT 1
#define CONFIG_XENO_OPT_STATS 1
#define CONFIG_ATH9K_RFKILL 1
#define CONFIG_ARCH_SUPPORTS_UPROBES 1
#define CONFIG_NET_VENDOR_STMICRO 1
#define CONFIG_DEBUG_LL_INCLUDE "mach/debug-macro.S"
#define CONFIG_OF_DYNAMIC 1
#define CONFIG_NF_NAT_H323_MODULE 1
#define CONFIG_XZ_DEC_SPARC 1
#define CONFIG_JFFS2_SUMMARY 1
#define CONFIG_USB_NET_QMI_WWAN_MODULE 1
#define CONFIG_INPUT_CMA3000_MODULE 1
#define CONFIG_OF_GPIO 1
#define CONFIG_FB_TFT_S6D1121_MODULE 1
#define CONFIG_INLINE_READ_UNLOCK_IRQ 1
#define CONFIG_GACT_PROB 1
#define CONFIG_HID_A4TECH_MODULE 1
#define CONFIG_MEDIA_TUNER_MC44S803_MODULE 1
#define CONFIG_NLS_CODEPAGE_860_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_ESP_MODULE 1
#define CONFIG_PRINT_QUOTA_WARNING 1
#define CONFIG_SND_BCM2708_SOC_RPI_CIRRUS_MODULE 1
#define CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO_MODULE 1
#define CONFIG_IP_NF_TARGET_NETMAP_MODULE 1
#define CONFIG_DST_CACHE 1
#define CONFIG_USB_GSPCA_SPCA505_MODULE 1
#define CONFIG_NF_REJECT_IPV6_MODULE 1
#define CONFIG_RCU_CPU_STALL_TIMEOUT 21
#define CONFIG_USB_GSPCA_SQ905C_MODULE 1
#define CONFIG_USB_ZR364XX_MODULE 1
#define CONFIG_RTC_DRV_ISL1208_MODULE 1
#define CONFIG_SND_DIGIDAC1_SOUNDCARD_MODULE 1
#define CONFIG_SND_VERBOSE_PROCFS 1
#define CONFIG_BT_HCIUART_BCM 1
#define CONFIG_IP_ROUTE_MULTIPATH 1
#define CONFIG_RTC_DRV_PCF2123_MODULE 1
#define CONFIG_DVB_LNBP21_MODULE 1
#define CONFIG_DVB_TDA10048_MODULE 1
#define CONFIG_INPUT_FF_MEMLESS_MODULE 1
#define CONFIG_CHR_DEV_SG_MODULE 1
#define CONFIG_IP_SET_HASH_NET_MODULE 1
#define CONFIG_SECTION_MISMATCH_WARN_ONLY 1
#define CONFIG_HW_RANDOM_BCM2835 1
#define CONFIG_NET_SCH_DSMARK_MODULE 1
#define CONFIG_SND_MPU401_MODULE 1
#define CONFIG_DVB_CX24116_MODULE 1
#define CONFIG_POWER_RESET 1
#define CONFIG_CRYPTO_XCBC_MODULE 1
#define CONFIG_NF_NAT_AMANDA_MODULE 1
#define CONFIG_BRIDGE_EBT_MARK_MODULE 1
#define CONFIG_IR_GPIO_CIR_MODULE 1
#define CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE 1
#define CONFIG_MACVLAN_MODULE 1
#define CONFIG_L2TP_V3 1
#define CONFIG_INV_MPU6050_I2C_MODULE 1
#define CONFIG_SENSORS_INA2XX_MODULE 1
#define CONFIG_JOYSTICK_IFORCE_MODULE 1
#define CONFIG_PROFILING 1
#define CONFIG_FB_TFT_ST7735R_MODULE 1
#define CONFIG_SND_SOC_WM8731_MODULE 1
#define CONFIG_NET_VENDOR_AMAZON 1
#define CONFIG_INET6_XFRM_MODE_TRANSPORT_MODULE 1
#define CONFIG_CRYPTO_ARC4_MODULE 1
#define CONFIG_IEEE802154_6LOWPAN_MODULE 1
#define CONFIG_WLAN_VENDOR_ATMEL 1
#define CONFIG_NET_VENDOR_HISILICON 1
#define CONFIG_DVB_STV0900_MODULE 1
#define CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE 1
#define CONFIG_USB_GL860_MODULE 1
#define CONFIG_GRACE_PERIOD 1
#define CONFIG_SLHC_MODULE 1
#define CONFIG_R8188EU_MODULE 1
#define CONFIG_HAVE_SMP 1
#define CONFIG_XENO_DRIVERS_GPIO_BCM2835_MODULE 1
#define CONFIG_CRYPTO_MANAGER 1
#define CONFIG_NET_SCH_HTB_MODULE 1
#define CONFIG_EEPROM_AT24_MODULE 1
#define CONFIG_PPP_BSDCOMP_MODULE 1
#define CONFIG_DVB_USB_TTUSB2_MODULE 1
#define CONFIG_MTD_NAND_MODULE 1
#define CONFIG_EDAC_SUPPORT 1
#define CONFIG_RT_MUTEXES 1
#define CONFIG_VECTORS_BASE 0xffff0000
#define CONFIG_LOCK_SPIN_ON_OWNER 1
#define CONFIG_HID_ORTEK_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_MARK_MODULE 1
#define CONFIG_DRM_GEM_CMA_HELPER 1
#define CONFIG_AR5523_MODULE 1
#define CONFIG_MEDIA_TUNER_MXL5007T_MODULE 1
#define CONFIG_MD_LINEAR_MODULE 1
#define CONFIG_DVB_TDA10021_MODULE 1
#define CONFIG_VIDEO_CX231XX_DVB_MODULE 1
#define CONFIG_KERNFS 1
#define CONFIG_CXD2880_SPI_DRV_MODULE 1
#define CONFIG_VMSPLIT_2G 1
#define CONFIG_IPV6_SUBTREES 1
#define CONFIG_I2C_ALGOBIT_MODULE 1
#define CONFIG_MMC_BLOCK 1
#define CONFIG_NET_CLS_FW_MODULE 1
#define CONFIG_PAGE_COUNTER 1
#define CONFIG_SND_SIMPLE_CARD_MODULE 1
#define CONFIG_W1_SLAVE_DS2781_MODULE 1
#define CONFIG_EXPERT 1
#define CONFIG_IR_SANYO_DECODER_MODULE 1
#define CONFIG_LIRC_SERIAL_MODULE 1
#define CONFIG_XENO_ARCH_FPU 1
#define CONFIG_CFG80211_CRDA_SUPPORT 1
#define CONFIG_VIDEO_MT9V011_MODULE 1
#define CONFIG_WIRELESS 1
#define CONFIG_WEXT_PROC 1
#define CONFIG_SQUASHFS_MODULE 1
#define CONFIG_DRM_TINYDRM_MODULE 1
#define CONFIG_6LOWPAN_NHC_MODULE 1
#define CONFIG_ARCH_MULTIPLATFORM 1
#define CONFIG_MMC_BCM2835_PIO_DMA_BARRIER 2
#define CONFIG_USB_GSPCA_KONICA_MODULE 1
#define CONFIG_NET_SCH_TBF_MODULE 1
#define CONFIG_BT_HCIBTUSB_MODULE 1
#define CONFIG_FRAME_VECTOR 1
#define CONFIG_PERF_USE_VMALLOC 1
#define CONFIG_FB_TFT_ILI9481_MODULE 1
#define CONFIG_DVB_CX22702_MODULE 1
#define CONFIG_SERIO_RAW_MODULE 1
#define CONFIG_TASK_IO_ACCOUNTING 1
#define CONFIG_FAT_DEFAULT_IOCHARSET "ascii"
#define CONFIG_USBIP_VHCI_NR_HCS 1
#define CONFIG_ASYNC_XOR_MODULE 1
#define CONFIG_NET_CLS_RSVP_MODULE 1
#define CONFIG_FB_TFT_ILI9163_MODULE 1
#define CONFIG_DVB_STB6100_MODULE 1
#define CONFIG_MD_RAID0_MODULE 1
#define CONFIG_FRAME_WARN 1024
#define CONFIG_USB_NET_CDC_NCM_MODULE 1
#define CONFIG_XENO_OPT_AUTOTUNE 1
#define CONFIG_HID_GENERIC 1
#define CONFIG_ARCH_MMAP_RND_BITS 8
#define CONFIG_FB_TFT_ILI9320_MODULE 1
#define CONFIG_SND_SOC_ADAU1701_MODULE 1
#define CONFIG_GENERIC_HWEIGHT 1
#define CONFIG_RTL_CARDS_MODULE 1
#define CONFIG_DHT11_MODULE 1
#define CONFIG_CGROUPS 1
#define CONFIG_SND_USB_CAIAQ_INPUT 1
#define CONFIG_MMC 1
#define CONFIG_LZO_COMPRESS 1
#define CONFIG_TOUCHSCREEN_USB_GUNZE 1
#define CONFIG_CRYPTO_SEQIV_MODULE 1
#define CONFIG_BRCMFMAC_MODULE 1
#define CONFIG_ARM_ERRATA_643719 1
#define CONFIG_TTY_PRINTK 1
#define CONFIG_HID_LOGITECH_MODULE 1
#define CONFIG_DM_LOG_USERSPACE_MODULE 1
#define CONFIG_HAVE_GCC_PLUGINS 1
#define CONFIG_DVB_SP887X_MODULE 1
#define CONFIG_STACKTRACE 1
#define CONFIG_EXTCON_MODULE 1
#define CONFIG_MULTI_IRQ_HANDLER 1
#define CONFIG_NETFILTER_XT_TARGET_IDLETIMER_MODULE 1
#define CONFIG_USB_NET_RNDIS_WLAN_MODULE 1
#define CONFIG_VIDEO_TUNER_MODULE 1
#define CONFIG_IFB_MODULE 1
#define CONFIG_USB_SEVSEG_MODULE 1
#define CONFIG_SND_MPU401_UART_MODULE 1
#define CONFIG_CRYPTO_DRBG_MODULE 1
#define CONFIG_RTC_DRV_PCF8563_MODULE 1
#define CONFIG_MEDIA_TUNER_MSI001_MODULE 1
#define CONFIG_OF_EARLY_FLATTREE 1
#define CONFIG_DVB_USB_V2_MODULE 1
#define CONFIG_USB_DSBR_MODULE 1
#define CONFIG_DEBUG_ALIGN_RODATA 1
#define CONFIG_WLAN_VENDOR_ADMTEK 1
#define CONFIG_CGROUP_CPUACCT 1
#define CONFIG_USB_SERIAL_OTI6858_MODULE 1
#define CONFIG_SERIAL_SC16IS7XX_CORE_MODULE 1
#define CONFIG_VIDEO_GO7007_USB_MODULE 1
#define CONFIG_CAN_BCM_MODULE 1
#define CONFIG_HAS_IOPORT_MAP 1
#define CONFIG_NET_VENDOR_VIA 1
#define CONFIG_USB_ATM_MODULE 1
#define CONFIG_HZ 100
#define CONFIG_SERIAL_8250_SHARE_IRQ 1
#define CONFIG_UCB1400_CORE_MODULE 1
#define CONFIG_HAVE_CBPF_JIT 1
#define CONFIG_SND_BCM2708_SOC_HIFIBERRY_DIGI_MODULE 1
#define CONFIG_USB_RTL8152_MODULE 1
#define CONFIG_I2C_HELPER_AUTO 1
#define CONFIG_NETFILTER_XT_MATCH_U32_MODULE 1
#define CONFIG_VIDEO_SONY_BTF_MPX_MODULE 1
#define CONFIG_SQUASHFS_ZLIB 1
#define CONFIG_INLINE_SPIN_UNLOCK_IRQ 1
#define CONFIG_NLS_ISO8859_4_MODULE 1
#define CONFIG_IRQSOFF_TRACER 1
#define CONFIG_FB_BACKLIGHT 1
#define CONFIG_RTC_DRV_RX8025_MODULE 1
#define CONFIG_SERIAL_8250_NR_UARTS 1
#define CONFIG_NET_EMATCH_IPSET_MODULE 1
#define CONFIG_IR_IMON_MODULE 1
#define CONFIG_NET_EGRESS 1
#define CONFIG_ARM_PATCH_PHYS_VIRT 1
#define CONFIG_NET_VENDOR_ARC 1
#define CONFIG_FB_TFT_BD663474_MODULE 1
#define CONFIG_BATMAN_ADV_DEBUGFS 1
#define CONFIG_INET_AH_MODULE 1
#define CONFIG_MTD_UBI_BEB_LIMIT 20
#define CONFIG_DEFAULT_IOSCHED "cfq"
#define CONFIG_UDF_FS_MODULE 1
#define CONFIG_HAVE_PERF_USER_STACK_DUMP 1
#define CONFIG_NLATTR 1
#define CONFIG_ZD1211RW_MODULE 1
#define CONFIG_TCP_CONG_CUBIC 1
#define CONFIG_NR_CPUS 4
#define CONFIG_HAVE_EXIT_THREAD 1
#define CONFIG_IIO_BUFFER_CB_MODULE 1
#define CONFIG_LIRC_IMON_MODULE 1
#define CONFIG_MMC_SDHCI 1
#define CONFIG_B43_SSB 1
#define CONFIG_SND_SUPPORT_OLD_API 1
#define CONFIG_DVB_DIB7000M_MODULE 1
#define CONFIG_NETFILTER_XT_CONNMARK_MODULE 1
#define CONFIG_LOGITECH_FF 1
#define CONFIG_DVB_AF9033_MODULE 1
#define CONFIG_HID_KYE_MODULE 1
#define CONFIG_SND_SOC_ADAU1977_I2C_MODULE 1
#define CONFIG_HID_GEMBIRD_MODULE 1
#define CONFIG_FIRMWARE_IN_KERNEL 1
#define CONFIG_IP_MROUTE_MULTIPLE_TABLES 1
#define CONFIG_VIDEO_TM6000_ALSA_MODULE 1
#define CONFIG_SYSFS 1
#define CONFIG_IP_SET_BITMAP_IPMAC_MODULE 1
#define CONFIG_USB_DEFAULT_PERSIST 1
#define CONFIG_DVB_MN88473_MODULE 1
#define CONFIG_LIB80211_CRYPT_WEP_MODULE 1
#define CONFIG_INPUT_TOUCHSCREEN 1
#define CONFIG_RT2800USB_UNKNOWN 1
#define CONFIG_RADIO_SI4713_MODULE 1
#define CONFIG_USB_GSPCA_NW80X_MODULE 1
#define CONFIG_NF_CONNTRACK_LABELS 1
#define CONFIG_ARM_THUMB 1
#define CONFIG_IP_NF_MATCH_AH_MODULE 1
#define CONFIG_CARL9170_WPC 1
#define CONFIG_DVB_S5H1420_MODULE 1
#define CONFIG_DVB_NET 1
#define CONFIG_NF_LOG_COMMON_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE 1
#define CONFIG_XZ_DEC_ARM 1
#define CONFIG_NLS_CODEPAGE_775_MODULE 1
#define CONFIG_IRLAN_MODULE 1
#define CONFIG_FB_SYS_FOPS_MODULE 1
#define CONFIG_WIMAX_MODULE 1
#define CONFIG_HAVE_SYSCALL_TRACEPOINTS 1
#define CONFIG_MEDIA_TUNER_XC4000_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_DEVGROUP_MODULE 1
#define CONFIG_DVB_LGDT3305_MODULE 1
#define CONFIG_VIDEO_USBTV_MODULE 1
#define CONFIG_FB 1
#define CONFIG_TRACING 1
#define CONFIG_IP_NF_MATCH_RPFILTER_MODULE 1
#define CONFIG_NLS_CODEPAGE_865_MODULE 1
#define CONFIG_I2C_COMPAT 1
#define CONFIG_CPU_32v7 1
#define CONFIG_WLAN_VENDOR_ZYDAS 1
#define CONFIG_INET_SCTP_DIAG_MODULE 1
#define CONFIG_NFSD_V3_ACL 1
#define CONFIG_USB_GSPCA_SPCA500_MODULE 1
#define CONFIG_LEDS_TRIGGER_CPU 1
#define CONFIG_HID_ELO_MODULE 1
#define CONFIG_TRACE_IRQFLAGS 1
#define CONFIG_NET_ACT_NAT_MODULE 1
#define CONFIG_OCFS2_FS_STATS 1
#define CONFIG_MSDOS_PARTITION 1
#define CONFIG_DMA_BCM2835 1
#define CONFIG_RTC_I2C_AND_SPI 1
#define CONFIG_BT_HCIUART_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_NEXIO 1
#define CONFIG_RT2800USB_RT33XX 1
#define CONFIG_DVB_LNBP22_MODULE 1
#define CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC_MODULE 1
#define CONFIG_RASPBERRYPI_POWER 1
#define CONFIG_USB_GSPCA_SN9C2028_MODULE 1
#define CONFIG_BMP280_I2C_MODULE 1
#define CONFIG_HAVE_OPROFILE 1
#define CONFIG_IR_STREAMZAP_MODULE 1
#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
#define CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC_MODULE 1
#define CONFIG_ARCH_HAVE_CUSTOM_GPIO_H 1
#define CONFIG_IP_SET_MODULE 1
#define CONFIG_THERMAL 1
#define CONFIG_INPUT_POWERMATE_MODULE 1
#define CONFIG_IP_PNP_RARP 1
#define CONFIG_BRCMUTIL_MODULE 1
#define CONFIG_VETH_MODULE 1
#define CONFIG_RTC_DRV_PCF8583_MODULE 1
#define CONFIG_OLD_SIGACTION 1
#define CONFIG_DVB_MT312_MODULE 1
#define CONFIG_DVB_USB_DIBUSB_MB_FAULTY 1
#define CONFIG_HID_PETALYNX_MODULE 1
#define CONFIG_NET_ACT_MIRRED_MODULE 1
#define CONFIG_HAVE_ARCH_KGDB 1
#define CONFIG_CRYPTO_ABLK_HELPER_MODULE 1
#define CONFIG_NF_CONNTRACK_IPV4_MODULE 1
#define CONFIG_SMP_ON_UP 1
#define CONFIG_USB_VL600_MODULE 1
#define CONFIG_B43LEGACY_HWRNG 1
#define CONFIG_ATH9K_BTCOEX_SUPPORT 1
#define CONFIG_SND_DUMMY_MODULE 1
#define CONFIG_NET_VENDOR_INTEL 1
#define CONFIG_RPS 1
#define CONFIG_DVB_AU8522_DTV_MODULE 1
#define CONFIG_USB_NET_ZAURUS_MODULE 1
#define CONFIG_INET6_XFRM_TUNNEL_MODULE 1
#define CONFIG_PROC_PID_CPUSET 1
#define CONFIG_QCA7000_MODULE 1
#define CONFIG_REALTEK_AUTOPM 1
#define CONFIG_USB_NET_AX88179_178A_MODULE 1
#define CONFIG_PM_GENERIC_DOMAINS 1
#define CONFIG_MEDIA_TUNER_E4000_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_DMC_TSC10 1
#define CONFIG_DVB_ZL10039_MODULE 1
#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
#define CONFIG_USB_SERIAL_DEBUG_MODULE 1
#define CONFIG_IP_SET_HASH_IPPORTIP_MODULE 1
#define CONFIG_GENERIC_IDLE_POLL_SETUP 1
#define CONFIG_NET_EMATCH_NBYTE_MODULE 1
#define CONFIG_ZISOFS 1
#define CONFIG_WLAN_VENDOR_MEDIATEK 1
#define CONFIG_WIMAX_I2400M_MODULE 1
#define CONFIG_CUSE_MODULE 1
#define CONFIG_BLK_DEV_CRYPTOLOOP_MODULE 1
#define CONFIG_IP_MULTICAST 1
#define CONFIG_DVB_MT352_MODULE 1
#define CONFIG_RC_ATI_REMOTE_MODULE 1
#define CONFIG_SQUASHFS_XZ 1
#define CONFIG_USB_NET_CX82310_ETH_MODULE 1
#define CONFIG_CPU_32v6K 1
#define CONFIG_HID_LOGITECH_DJ_MODULE 1
#define CONFIG_DEFAULT_SECURITY ""
#define CONFIG_VIDEO_STK1160_MODULE 1
#define CONFIG_TICK_ONESHOT 1
#define CONFIG_HID_BETOP_FF_MODULE 1
#define CONFIG_NF_NAT_PROTO_UDPLITE_MODULE 1
#define CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE 1
#define CONFIG_CRYPTO_CTR_MODULE 1
#define CONFIG_DVB_STV090x_MODULE 1
#define CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE 1
#define CONFIG_WIRELESS_EXT 1
#define CONFIG_MEDIA_TUNER_MT2060_MODULE 1
#define CONFIG_RTC_DRV_RS5C348_MODULE 1
#define CONFIG_MODVERSIONS 1
#define CONFIG_HW_RANDOM 1
#define CONFIG_MUTEX_SPIN_ON_OWNER 1
#define CONFIG_DVB_USB_AU6610_MODULE 1
#define CONFIG_BT_HCIBTUSB_RTL 1
#define CONFIG_IRNET_MODULE 1
#define CONFIG_SND_SOC_WM8804_I2C_MODULE 1
#define CONFIG_CGROUP_NET_CLASSID 1
#define CONFIG_NLS_CODEPAGE_737_MODULE 1
#define CONFIG_NF_NAT_IPV4_MODULE 1
#define CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
#define CONFIG_OF_MDIO 1
#define CONFIG_VIDEOBUF2_CORE_MODULE 1
#define CONFIG_DVB_HELENE_MODULE 1
#define CONFIG_IRTTY_SIR_MODULE 1
#define CONFIG_REGULATOR_ARIZONA_MODULE 1
#define CONFIG_INPUT_ADXL34X_I2C_MODULE 1
#define CONFIG_CRYPTO_NULL2 1
#define CONFIG_NTFS_FS_MODULE 1
#define CONFIG_VIDEO_AU0828_V4L2 1
#define CONFIG_RT2X00_LIB_CRYPTO 1
#define CONFIG_IP_SCTP_MODULE 1
#define CONFIG_DVB_STB0899_MODULE 1
#define CONFIG_BASE_SMALL 0
#define CONFIG_CRYPTO_BLKCIPHER2 1
#define CONFIG_RTL8187_MODULE 1
#define CONFIG_SND_SEQ_DUMMY_MODULE 1
#define CONFIG_DM_RAID_MODULE 1
#define CONFIG_NFS_V2 1
#define CONFIG_DVB_TDA18271C2DD_MODULE 1
#define CONFIG_VIDEO_TM6000_MODULE 1
#define CONFIG_DVB_CXD2820R_MODULE 1
#define CONFIG_NF_DUP_IPV6_MODULE 1
#define CONFIG_USB_GSPCA_SONIXJ_MODULE 1
#define CONFIG_GPIO_STMPE 1
#define CONFIG_STMPE_I2C 1
#define CONFIG_USB_SERIAL_F81232_MODULE 1
#define CONFIG_PROC_FS 1
#define CONFIG_MTD_BLOCK_MODULE 1
#define CONFIG_VIDEOBUF2_VMALLOC_MODULE 1
#define CONFIG_6LOWPAN_NHC_FRAGMENT_MODULE 1
#define CONFIG_RC_MAP_MODULE 1
#define CONFIG_WEXT_PRIV 1
#define CONFIG_NET_VENDOR_ROCKER 1
#define CONFIG_SCSI_LOWLEVEL 1
#define CONFIG_ROSE_MODULE 1
#define CONFIG_INPUT_GPIO_ROTARY_ENCODER_MODULE 1
#define CONFIG_IP_VS_PROTO_AH_ESP 1
#define CONFIG_IRQ_FORCED_THREADING 1
#define CONFIG_NILFS2_FS_MODULE 1
#define CONFIG_EDAC_ATOMIC_SCRUB 1
#define CONFIG_NLS_ISO8859_3_MODULE 1
#define CONFIG_CRYPTO_CMAC_MODULE 1
#define CONFIG_HID_PANTHERLORD_MODULE 1
#define CONFIG_DRM_FBDEV_EMULATION 1
#define CONFIG_SND_MODULE 1
#define CONFIG_FLATMEM 1
#define CONFIG_NET_SCH_TEQL_MODULE 1
#define CONFIG_SND_SOC_TAS5713_MODULE 1
#define CONFIG_IR_RC6_DECODER_MODULE 1
#define CONFIG_IP_VS_SH_MODULE 1
#define CONFIG_VIDEO_MSP3400_MODULE 1
#define CONFIG_USB_PEGASUS_MODULE 1
#define CONFIG_FB_TFT_UC1701_MODULE 1
#define CONFIG_V4L_PLATFORM_DRIVERS 1
#define CONFIG_W1_SLAVE_DS2408_READBACK 1
#define CONFIG_RFKILL_INPUT 1
#define CONFIG_NET_VENDOR_NATSEMI 1
#define CONFIG_BLK_DEV_BSGLIB 1
#define CONFIG_MEDIA_TUNER_FC2580_MODULE 1
#define CONFIG_ATH9K_COMMON_MODULE 1
#define CONFIG_IKCONFIG_MODULE 1
#define CONFIG_DVB_STB6000_MODULE 1
#define CONFIG_USB_SERIAL_QCAUX_MODULE 1
#define CONFIG_NET_VENDOR_NETRONOME 1
#define CONFIG_NFS_USE_KERNEL_DNS 1
#define CONFIG_LIRC_STAGING 1
#define CONFIG_SYSCTL 1
#define CONFIG_ARCH_HAS_GCOV_PROFILE_ALL 1
#define CONFIG_BRIDGE_IGMP_SNOOPING 1
#define CONFIG_IP_NF_TARGET_CLUSTERIP_MODULE 1
#define CONFIG_W1_SLAVE_THERM_MODULE 1
#define CONFIG_CAN_SLCAN_MODULE 1
#define CONFIG_SND_SOC_WM_ADSP_MODULE 1
#define CONFIG_DVB_M88DS3103_MODULE 1
#define CONFIG_TOUCHSCREEN_STMPE_MODULE 1
#define CONFIG_HAVE_C_RECORDMCOUNT 1
#define CONFIG_MEDIA_TUNER_MT2131_MODULE 1
#define CONFIG_ARCH_BCM2835 1
#define CONFIG_HID_THINGM_MODULE 1
#define CONFIG_USB_NET_KALMIA_MODULE 1
#define CONFIG_IR_TTUSBIR_MODULE 1
#define CONFIG_USB_NET_DM9601_MODULE 1
#define CONFIG_HAVE_ARCH_TRACEHOOK 1
#define CONFIG_IR_MCEUSB_MODULE 1
#define CONFIG_CIFS_MODULE 1
#define CONFIG_XFRM_USER 1
#define CONFIG_TCP_CONG_BIC_MODULE 1
#define CONFIG_TASK_DELAY_ACCT 1
#define CONFIG_NET_NS 1
#define CONFIG_REISERFS_FS_XATTR 1
#define CONFIG_HAVE_PERF_EVENTS 1
#define CONFIG_NET_EMATCH_CMP_MODULE 1
#define CONFIG_USB_GSPCA_T613_MODULE 1
#define CONFIG_SND_MTPAV_MODULE 1
#define CONFIG_PPP_ASYNC_MODULE 1
#define CONFIG_MD_RAID10_MODULE 1
#define CONFIG_NO_BOOTMEM 1
#define CONFIG_SSB_SDIOHOST_POSSIBLE 1
#define CONFIG_CAN_GW_MODULE 1
#define CONFIG_NLS_CODEPAGE_866_MODULE 1
#define CONFIG_RADIO_SAA7706H_MODULE 1
#define CONFIG_LIRC_RPI_MODULE 1
#define CONFIG_LEDS_TRIGGER_TRANSIENT_MODULE 1
#define CONFIG_DEBUG_MEMORY_INIT 1
#define CONFIG_CHR_DEV_ST_MODULE 1
#define CONFIG_KERNEL_MODE_NEON 1
#define CONFIG_DVB_GP8PSK_FE_MODULE 1
#define CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE 1
#define CONFIG_CRYPTO_USER_API_SKCIPHER_MODULE 1
#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
#define CONFIG_ARM_GIC_MAX_NR 1
#define CONFIG_B43LEGACY_MODULE 1
#define CONFIG_HID_MULTITOUCH_MODULE 1
#define CONFIG_FB_DEFERRED_IO 1
#define CONFIG_DVB_USB_A800_MODULE 1
#define CONFIG_I2C_SI470X_MODULE 1
#define CONFIG_DVB_A8293_MODULE 1
#define CONFIG_OPTPROBES 1
#define CONFIG_HID_ELECOM_MODULE 1
#define CONFIG_FB_TFT_PCD8544_MODULE 1
#define CONFIG_SND_TIMER_MODULE 1
#define CONFIG_FAT_DEFAULT_CODEPAGE 437
#define CONFIG_IPV6_MROUTE_MULTIPLE_TABLES 1
#define CONFIG_CRYPTO_SHA1_ARM_NEON_MODULE 1
#define CONFIG_BLK_DEV 1
#define CONFIG_MAC80211_RC_DEFAULT "minstrel_ht"
#define CONFIG_RTL8187_LEDS 1
#define CONFIG_NFS_ACL_SUPPORT 1
#define CONFIG_RT2800USB_RT55XX 1
#define CONFIG_W1_SLAVE_DS2433_MODULE 1
#define CONFIG_XENO_DRIVERS_TIMERBENCH 1
#define CONFIG_USB_SERIAL_OMNINET_MODULE 1
#define CONFIG_BRIDGE_NETFILTER_MODULE 1
#define CONFIG_DVB_MB86A20S_MODULE 1
#define CONFIG_OF_FLATTREE 1
#define CONFIG_TRACING_SUPPORT 1
#define CONFIG_UNIX98_PTYS 1
#define CONFIG_CDROM_PKTCDVD_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE 1
#define CONFIG_NET_RX_BUSY_POLL 1
#define CONFIG_RADIO_WL1273_MODULE 1
#define CONFIG_CRYPTO_MICHAEL_MIC_MODULE 1
#define CONFIG_PINCTRL_BCM2835 1
#define CONFIG_NET_SCHED 1
#define CONFIG_STAGING_MEDIA 1
#define CONFIG_DRM_PANEL 1
#define CONFIG_DVB_PLL_MODULE 1
#define CONFIG_SND_BCM2708_SOC_ALLO_BOSS_DAC_MODULE 1
#define CONFIG_PRINTK_TIME 1
#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
#define CONFIG_SECCOMP_FILTER 1
#define CONFIG_IRQCHIP 1
#define CONFIG_PPP_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE 1
#define CONFIG_TI_ST_MODULE 1
#define CONFIG_NET_SCH_PIE_MODULE 1
#define CONFIG_HAVE_KERNEL_LZO 1
#define CONFIG_ASYNC_CORE_MODULE 1
#define CONFIG_NET_SCH_MULTIQ_MODULE 1
#define CONFIG_INET_DIAG_MODULE 1
#define CONFIG_CRYPTO_GHASH_MODULE 1
#define CONFIG_OCFS2_DEBUG_MASKLOG 1
#define CONFIG_SND_SOC_WM8741_MODULE 1
#define CONFIG_NF_NAT_FTP_MODULE 1
#define CONFIG_MAC80211_RC_MINSTREL 1
#define CONFIG_IIO_CONSUMERS_PER_TRIGGER 2
#define CONFIG_NF_CT_PROTO_UDPLITE_MODULE 1
#define CONFIG_IKCONFIG_PROC 1
#define CONFIG_SPEAKUP_MODULE 1
#define CONFIG_ELF_CORE 1
#define CONFIG_DEV_COREDUMP 1
#define CONFIG_TEXTSEARCH 1
#define CONFIG_USB_SUPPORT 1
#define CONFIG_INPUT_POLLDEV_MODULE 1
#define CONFIG_MEDIA_RC_SUPPORT 1
#define CONFIG_RTC_DRV_BQ32K_MODULE 1
#define CONFIG_USB_GSPCA_PAC7311_MODULE 1
#define CONFIG_WLAN_VENDOR_ST 1
#define CONFIG_BRCMFMAC_PROTO_BCDC 1
#define CONFIG_TOUCHSCREEN_USB_EASYTOUCH 1
#define CONFIG_STAGING 1
#define CONFIG_F2FS_FS 1
#define CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE 1
#define CONFIG_FLAT_NODE_MEM_MAP 1
#define CONFIG_ATM_MODULE 1
#define CONFIG_VT_CONSOLE 1
#define CONFIG_HID_UCLOGIC_MODULE 1
#define CONFIG_LEDS_GPIO 1
#define CONFIG_SCHED_INFO 1
#define CONFIG_USB_GSPCA_STK014_MODULE 1
#define CONFIG_IP_VS_FTP_MODULE 1
#define CONFIG_SND_BCM2708_SOC_ALLO_DIGIONE_MODULE 1
#define CONFIG_CFG80211_WEXT 1
#define CONFIG_WLAN_VENDOR_MARVELL 1
#define CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE 1
#define CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE 1
#define CONFIG_XENOMAI 1
#define CONFIG_DVB_USB_DIBUSB_MB_MODULE 1
#define CONFIG_BLK_DEV_RAM 1
#define CONFIG_NETFILTER_XT_MATCH_STATE_MODULE 1
#define CONFIG_DVB_L64781_MODULE 1
#define CONFIG_LOGIRUMBLEPAD2_FF 1
#define CONFIG_CRYPTO_CAST_COMMON_MODULE 1
#define CONFIG_IIO_TRIGGERED_BUFFER_MODULE 1
#define CONFIG_RTC_DRV_PCF2127_MODULE 1
#define CONFIG_USB_STORAGE_FREECOM_MODULE 1
#define CONFIG_BRIDGE_EBT_LOG_MODULE 1
#define CONFIG_SND_SOC_PCM1794A_MODULE 1
#define CONFIG_MICROCHIP_PHY 1
#define CONFIG_TOUCHSCREEN_ADS7846_MODULE 1
#define CONFIG_OPENVSWITCH_VXLAN_MODULE 1
#define CONFIG_IR_RC5_DECODER_MODULE 1
#define CONFIG_NET_SCH_GRED_MODULE 1
#define CONFIG_ARM_TIMER_SP804 1
#define CONFIG_DRM_MODULE 1
#define CONFIG_INET6_XFRM_MODE_BEET_MODULE 1
#define CONFIG_CLKSRC_PROBE 1
#define CONFIG_MEDIA_RADIO_SUPPORT 1
#define CONFIG_POSIX_MQUEUE_SYSCTL 1
#define CONFIG_RTC_DRV_MAX6900_MODULE 1
#define CONFIG_FB_CFB_COPYAREA 1
#define CONFIG_DVB_RTL2830_MODULE 1
#define CONFIG_BRIDGE_EBT_STP_MODULE 1
#define CONFIG_RT73USB_MODULE 1
#define CONFIG_BRIDGE_EBT_ARP_MODULE 1
#define CONFIG_MANDATORY_FILE_LOCKING 1
#define CONFIG_ARCH_HAS_TICK_BROADCAST 1
#define CONFIG_USB_CYTHERM_MODULE 1
#define CONFIG_IP6_NF_MATCH_EUI64_MODULE 1
#define CONFIG_BINARY_PRINTF 1
#define CONFIG_MWIFIEX_MODULE 1
#define CONFIG_USB_STORAGE_JUMPSHOT_MODULE 1
#define CONFIG_SND_SOC_SGTL5000_MODULE 1
#define CONFIG_NET_SCH_PLUG_MODULE 1
#define CONFIG_TRACER_MAX_TRACE 1
#define CONFIG_USB_KEENE_MODULE 1
#define CONFIG_VIDEOBUF_GEN_MODULE 1
#define CONFIG_SYSFS_SYSCALL 1
#define CONFIG_VIDEO_V4L2_MODULE 1
#define CONFIG_SND_PCM_TIMER 1
#define CONFIG_DVB_STV6110_MODULE 1
#define CONFIG_AC97_BUS_MODULE 1
#define CONFIG_SYSVIPC_SYSCTL 1
#define CONFIG_WLAN_VENDOR_TI 1
#define CONFIG_HID_NTRIG_MODULE 1
#define CONFIG_DMA_SHARED_BUFFER 1
#define CONFIG_RTC_SYSTOHC 1
#define CONFIG_DVB_USB_NOVA_T_USB2_MODULE 1
#define CONFIG_CIFS_POSIX 1
#define CONFIG_USB_EPSON2888 1
#define CONFIG_OF_ADDRESS 1
#define CONFIG_W1_SLAVE_DS28E04_MODULE 1
#define CONFIG_USB_SERIAL_ARK3116_MODULE 1
#define CONFIG_QUOTA 1
#define CONFIG_MMC_SDHCI_PLTFM 1
#define CONFIG_I2C_CHARDEV_MODULE 1
#define CONFIG_MEDIA_TUNER_FC0013_MODULE 1
#define CONFIG_LLC_MODULE 1
#define CONFIG_CROSS_COMPILE ""
#define CONFIG_MEDIA_TUNER_TEA5761_MODULE 1
#define CONFIG_REGMAP_MMIO 1
#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
#define CONFIG_HID_HOLTEK_MODULE 1
#define CONFIG_CRYPTO_AES_ARM_MODULE 1
#define CONFIG_LIB80211_CRYPT_CCMP_MODULE 1
#define CONFIG_USB_GSPCA_DTCS033_MODULE 1
#define CONFIG_RTC_DRV_DS1672_MODULE 1
#define CONFIG_USB_SERIAL_SSU100_MODULE 1
#define CONFIG_DVB_USB_DIB3000MC_MODULE 1
#define CONFIG_ATALK_MODULE 1
#define CONFIG_XZ_DEC_ARMTHUMB 1
#define CONFIG_XENO_OPT_RR_QUANTUM 1000
#define CONFIG_B43_BCMA 1
#define CONFIG_ARCH_USE_CMPXCHG_LOCKREF 1
#define CONFIG_REGMAP 1
#define CONFIG_6PACK_MODULE 1
#define CONFIG_NLS_UTF8_MODULE 1
#define CONFIG_RADIO_SI470X 1
#define CONFIG_VIDEO_TM6000_DVB_MODULE 1
#define CONFIG_JOYSTICK_XPAD_MODULE 1
#define CONFIG_GPIO_WATCHDOG_MODULE 1
#define CONFIG_HAVE_MOD_ARCH_SPECIFIC 1
#define CONFIG_FB_NOTIFY 1
#define CONFIG_CAN_DEV_MODULE 1
#define CONFIG_INPUT_YEALINK_MODULE 1
#define CONFIG_DVB_DIB3000MB_MODULE 1
#define CONFIG_IEEE802154_CC2520_MODULE 1
#define CONFIG_RTC_DRV_M41T80_MODULE 1
#define CONFIG_VT6656_MODULE 1
#define CONFIG_USB_USBNET 1
#define CONFIG_USB_SERIAL_PL2303_MODULE 1
#define CONFIG_NET_ACT_POLICE_MODULE 1
#define CONFIG_HAMRADIO 1
#define CONFIG_DVB_USB_CINERGY_T2_MODULE 1
#define CONFIG_FHANDLE 1
#define CONFIG_USB_MICROTEK_MODULE 1
#define CONFIG_HID_SMARTJOYPLUS_MODULE 1
#define CONFIG_TOUCHSCREEN_GOODIX_MODULE 1
#define CONFIG_NEW_LEDS 1
#define CONFIG_SWAP 1
#define CONFIG_USB_NET_CDC_SUBSET_ENABLE_MODULE 1
#define CONFIG_NET_SCH_HFSC_MODULE 1
#define CONFIG_RTC_DRV_RV3029C2_MODULE 1
#define CONFIG_MAC80211_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH 1
#define CONFIG_CRC_CCITT_MODULE 1
#define CONFIG_GPIOLIB_IRQCHIP 1
#define CONFIG_DVB_TDA8261_MODULE 1
#define CONFIG_BLK_DEV_SD 1
#define CONFIG_INPUT_AD714X_SPI_MODULE 1
#define CONFIG_NETFILTER_NETLINK_MODULE 1
#define CONFIG_MODULE_UNLOAD 1
#define CONFIG_FSCACHE_STATS 1
#define CONFIG_USB_GSPCA_BENQ_MODULE 1
#define CONFIG_BT_LE 1
#define CONFIG_SND_AC97_CODEC_MODULE 1
#define CONFIG_DVB_USB_CXUSB_MODULE 1
#define CONFIG_RWSEM_SPIN_ON_OWNER 1
#define CONFIG_MEDIA_TUNER_M88RS6000T_MODULE 1
#define CONFIG_TRACER_SNAPSHOT 1
#define CONFIG_BITREVERSE 1
#define CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP 1
#define CONFIG_BLK_DEV_RAM_SIZE 4096
#define CONFIG_USB_SERIAL_WWAN_MODULE 1
#define CONFIG_MAC_PARTITION 1
#define CONFIG_XFS_POSIX_ACL 1
#define CONFIG_BT_WILINK_MODULE 1
#define CONFIG_IPIPE_HAVE_HOSTRT 1
#define CONFIG_BRCMFMAC_USB 1
#define CONFIG_FB_MODE_HELPERS 1
#define CONFIG_NLS_ISO8859_13_MODULE 1
#define CONFIG_CRYPTO_BLKCIPHER 1
#define CONFIG_USB_STORAGE_ONETOUCH_MODULE 1
#define CONFIG_NLS_ISO8859_8_MODULE 1
#define CONFIG_NF_CONNTRACK_MODULE 1
#define CONFIG_RTC_DRV_PCF8523_MODULE 1
#define CONFIG_LCD_CLASS_DEVICE_MODULE 1
#define CONFIG_FILE_LOCKING 1
#define CONFIG_USB_GSPCA_XIRLINK_CIT_MODULE 1
#define CONFIG_USB_GSPCA_SN9C20X_MODULE 1
#define CONFIG_TOUCHSCREEN_USB_ELO 1
#define CONFIG_RTC_DRV_DS1302_MODULE 1
#define CONFIG_SND_SOC_I2C_AND_SPI_MODULE 1
#define CONFIG_NETPOLL 1
#define CONFIG_AIO 1
#define CONFIG_FIQ 1
#define CONFIG_DVB_TDA8083_MODULE 1
#define CONFIG_NET_MPLS_GSO_MODULE 1
#define CONFIG_DVB_USB_AZ6007_MODULE 1
#define CONFIG_OF 1
#define CONFIG_NET_EMATCH 1
#define CONFIG_PERF_EVENTS 1
#define CONFIG_GENERIC_TIME_VSYSCALL 1
#define CONFIG_IP_NF_TARGET_REJECT_MODULE 1
#define CONFIG_NET_SCH_CHOKE_MODULE 1
#define CONFIG_LEDS_CLASS 1
#define CONFIG_DVB_USB_DIGITV_MODULE 1
#define CONFIG_IP6_NF_MATCH_HL_MODULE 1
#define CONFIG_KALLSYMS_BASE_RELATIVE 1
#define CONFIG_IP_VS_TAB_BITS 12
#define CONFIG_IP6_NF_MATCH_OPTS_MODULE 1
#define CONFIG_RTC_INTF_DEV 1
#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
#define CONFIG_DCACHE_WORD_ACCESS 1
#define CONFIG_IP6_NF_TARGET_NPT_MODULE 1
#define CONFIG_DVB_USB_CE6230_MODULE 1
#define CONFIG_USB_SERIAL_SYMBOL_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_OSF_MODULE 1
#define CONFIG_VIDEO_GO7007_MODULE 1
#define CONFIG_MESSAGE_LOGLEVEL_DEFAULT 4
#define CONFIG_SND_VIRMIDI_MODULE 1
#define CONFIG_LIB80211_CRYPT_TKIP_MODULE 1
#define CONFIG_IP_VS_PROTO_UDP 1
#define CONFIG_NLS_DEFAULT "utf8"
#define CONFIG_UTS_NS 1
#define CONFIG_NF_CT_PROTO_GRE_MODULE 1
#define CONFIG_HAVE_ARM_ARCH_TIMER 1
#define CONFIG_NF_CT_NETLINK_MODULE 1
#define CONFIG_USB_NET_SR9800_MODULE 1
#define CONFIG_DMA_ENGINE 1
#define CONFIG_NET_EMATCH_TEXT_MODULE 1
#define CONFIG_HID_WIIMOTE_MODULE 1
#define CONFIG_USB_MA901_MODULE 1
#define CONFIG_CRYPTO_AEAD2 1
#define CONFIG_NF_NAT_MASQUERADE_IPV6_MODULE 1
#define CONFIG_NET_IPIP_MODULE 1
#define CONFIG_IP_VS_SH_TAB_BITS 8
#define CONFIG_USB_SERIAL_IPAQ_MODULE 1
#define CONFIG_NETFILTER_XT_MATCH_HL_MODULE 1
#define CONFIG_CRYPTO_ALGAPI2 1
#define CONFIG_NETFILTER_XT_TARGET_LED_MODULE 1
#define CONFIG_WEXT_SPY 1
#define CONFIG_UBIFS_FS_LZO 1
#define CONFIG_ZBOOT_ROM_TEXT 0x0
#define CONFIG_HAVE_MEMBLOCK 1
#define CONFIG_DEBUG_RODATA 1
#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS 1
#define CONFIG_INPUT 1
#define CONFIG_PPPOATM_MODULE 1
#define CONFIG_PROC_SYSCTL 1
#define CONFIG_ATH6KL_MODULE 1
#define CONFIG_NETFILTER_XT_TARGET_CT_MODULE 1
#define CONFIG_MMU 1
#define CONFIG_DVB_CX24123_MODULE 1
#define CONFIG_I2C_BCM2835_MODULE 1
#define CONFIG_OCFS2_FS_MODULE 1
#define CONFIG_MTD_M25P80_MODULE 1
#define CONFIG_USB_KAWETH_MODULE 1
#define CONFIG_USB_SIERRA_NET_MODULE 1
#define CONFIG_GPIO_MCP23S08_MODULE 1
#define CONFIG_BRIDGE_EBT_NFLOG_MODULE 1
#define CONFIG_KUSER_HELPERS 1
#define CONFIG_INLINE_WRITE_UNLOCK 1
#define CONFIG_INPUT_AD714X_MODULE 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           