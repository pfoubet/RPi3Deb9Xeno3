ernel: [    0.000000] pcpu-alloc: s37952 r8192 d23488 u69632 alloc=17*4096
May  9 17:17:04 raspberrypi kernel: [    0.000000] pcpu-alloc: [0] 0 [0] 1 [0] 2 [0] 3 
May  9 17:17:04 raspberrypi kernel: [    0.872777] dwc_otg: Microframe scheduler enabled
May  9 17:17:04 raspberrypi kernel: [    0.878438] dwc_otg: FIQ enabled
May  9 17:17:04 raspberrypi kernel: [    0.878447] dwc_otg: NAK holdoff enabled
May  9 17:17:04 raspberrypi kernel: [    0.878455] dwc_otg: FIQ split-transaction FSM enabled
May  9 17:17:04 raspberrypi kernel: [    0.878476] Module dwc_common_port init
May  9 17:17:04 raspberrypi kernel: [    6.352858] brcmfmac: F1 signature read @0x18000000=0x15264345
May 28 20:25:04 raspberrypi thd[357]: Found socket passed from systemd
May 28 20:25:04 raspberrypi kernel: [    0.000000] On node 0 totalpages: 242688
May 28 20:25:04 raspberrypi kernel: [    0.000000] free_area_init_node: node 0, pgdat 80c769c0, node_mem_map baba6000
May 28 20:25:04 raspberrypi kernel: [    0.000000]   Normal zone: 2133 pages used for memmap
May 28 20:25:04 raspberrypi kernel: [    0.000000]   Normal zone: 0 pages reserved
May 28 20:25:04 raspberrypi kernel: [    0.000000]   Normal zone: 242688 pages, LIFO batch:31
May 28 20:25:04 raspberrypi kernel: [    0.000000] pcpu-alloc: s37952 r8192 d23488 u69632 alloc=17*4096
May 28 20:25:04 raspberrypi kernel: [    0.000000] pcpu-alloc: [0] 0 [0] 1 [0] 2 [0] 3 
May 28 20:25:04 raspberrypi kernel: [    0.872977] dwc_otg: Microframe scheduler enabled
May 28 20:25:04 raspberrypi kernel: [    0.878628] dwc_otg: FIQ enabled
May 28 20:25:04 raspberrypi kernel: [    0.878637] dwc_otg: NAK holdoff enabled
May 28 20:25:04 raspberrypi kernel: [    0.878644] dwc_otg: FIQ split-transaction FSM enabled
May 28 20:25:04 raspberrypi kernel: [    0.878667] Module dwc_common_port init
May 28 20:25:04 raspberrypi kernel: [    6.992743] brcmfmac: F1 signature read @0x18000000=0x15264345
May 28 20:33:52 raspberrypi kernel: [    0.000000] On node 0 totalpages: 242688
May 28 20:33:52 raspberrypi kernel: [    0.000000] free_area_init_node: node 0, pgdat 80c769c0, node_mem_map baba6000
May 28 20:33:52 raspberrypi kernel: [    0.000000]   Normal zone: 2133 pages used for memmap
May 28 20:33:52 raspberrypi kernel: [    0.000000]   Normal zone: 0 pages reserved
May 28 20:33:52 raspberrypi kernel: [    0.000000]   Normal zone: 242688 pages, LIFO batch:31
May 28 20:33:52 raspberrypi kernel: [    0.000000] pcpu-alloc: s37952 r8192 d23488 u69632 alloc=17*4096
May 28 20:33:52 raspberrypi kernel: [    0.000000] pcpu-alloc: [0] 0 [0] 1 [0] 2 [0] 3 
May 28 20:33:52 raspberrypi kernel: [    0.872983] dwc_otg: Microframe scheduler enabled
May 28 20:33:52 raspberrypi kernel: [    0.878576] dwc_otg: FIQ enabled
May 28 20:33:52 raspberrypi kernel: [    0.878585] dwc_otg: NAK holdoff enabled
May 28 20:33:52 raspberrypi kernel: [    0.878593] dwc_otg: FIQ split-transaction FSM enabled
May 28 20:33:52 raspberrypi kernel: [    0.878616] Module dwc_common_port init
May 28 20:33:52 raspberrypi kernel: [    6.598934] brcmfmac: F1 signature read @0x18000000=0x15264345
May 28 20:33:52 raspberrypi thd[400]: Found socket passed from systemd
May 28 20:40:51 raspberrypi kernel: [    0.000000] On node 0 totalpages: 242688
May 28 20:40:51 raspberrypi kernel: [    0.000000] free_area_init_node: node 0, pgdat 80c85780, node_mem_map ba39f000
May 28 20:40:51 raspberrypi kernel: [    0.000000]   Normal zone: 2133 pages used for memmap
May 28 20:40:51 raspberrypi kernel: [    0.000000]   Normal zone: 0 pages reserved
May 28 20:40:51 raspberrypi kernel: [    0.000000]   Normal zone: 242688 pages, LIFO batch:31
May 28 20:40:51 raspberrypi kernel: [    0.000000] pcpu-alloc: s38720 r8192 d22720 u69632 alloc=17*4096
May 28 20:40:51 raspberrypi kernel: [    0.000000] pcpu-alloc: [0] 0 [0] 1 [0] 2 [0] 3 
May 28 20:40:51 raspberrypi thd[326]: Found socket passed from systemd
May 28 20:40:51 raspberrypi kernel: [    0.717410] dwc_otg: Microframe scheduler enabled
May 28 20:40:51 raspberrypi kernel: [    0.737638] dwc_otg: FIQ enabled
May 28 20:40:51 raspberrypi ker# Unix SMB/CIFS implementation.
# backend code for provisioning DNS for a Samba4 server
#
# Copyright (C) Kai Blin <kai@samba.org> 2011
# Copyright (C) Amitay Isaacs <amitay@gmail.com> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""DNS-related provisioning"""

import os
import uuid
import shutil
import time
import ldb
from base64 import b64encode
import subprocess
import samba
from samba.tdb_util import tdb_copy
from samba.ndr import ndr_pack, ndr_unpack
from samba import setup_file
from samba.dcerpc import dnsp, misc, security
from samba.dsdb import (
    DS_DOMAIN_FUNCTION_2000,
    DS_DOMAIN_FUNCTION_2003,
    DS_DOMAIN_FUNCTION_2008_R2,
    DS_DOMAIN_FUNCTION_2012_R2
    )
from samba.descriptor import (
    get_domain_descriptor,
    get_domain_delete_protected1_descriptor,
    get_domain_delete_protected2_descriptor,
    get_dns_partition_descriptor,
    get_dns_forest_microsoft_dns_descriptor,
    get_dns_domain_microsoft_dns_descriptor
    )
from samba.provision.common import (
    setup_path,
    setup_add_ldif,
    setup_modify_ldif,
    setup_ldb,
    FILL_FULL,
    FILL_SUBDOMAIN,
    FILL_NT4SYNC,
    FILL_DRS,
    )


def get_domainguid(samdb, domaindn):
    res = samdb.search(base=domaindn, scope=ldb.SCOPE_BASE, attrs=["objectGUID"])
    domainguid =  str(ndr_unpack(misc.GUID, res[0]["objectGUID"][0]))
    return domainguid


def get_dnsadmins_sid(samdb, domaindn):
    res = samdb.search(base="CN=DnsAdmins,CN=Users,%s" % domaindn, scope=ldb.SCOPE_BASE,
                       attrs=["objectSid"])
    dnsadmins_sid = ndr_unpack(security.dom_sid, res[0]["objectSid"][0])
    return dnsadmins_sid


class ARecord(dnsp.DnssrvRpcRecord):

    def __init__(self, ip_addr, serial=1, ttl=900, rank=dnsp.DNS_RANK_ZONE):
        super(ARecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_A
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        self.data = ip_addr


class AAAARecord(dnsp.DnssrvRpcRecord):

    def __init__(self, ip6_addr, serial=1, ttl=900, rank=dnsp.DNS_RANK_ZONE):
        super(AAAARecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_AAAA
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        self.data = ip6_addr


class CNameRecord(dnsp.DnssrvRpcRecord):

    def __init__(self, cname, serial=1, ttl=900, rank=dnsp.DNS_RANK_ZONE):
        super(CNameRecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_CNAME
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        self.data = cname


class NSRecord(dnsp.DnssrvRpcRecord):

    def __init__(self, dns_server, serial=1, ttl=900, rank=dnsp.DNS_RANK_ZONE):
        super(NSRecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_NS
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        self.data = dns_server


class SOARecord(dnsp.DnssrvRpcRecord):

    def __init__(self, mname, rname, serial=1, refresh=900, retry=600,
                 expire=86400, minimum=3600, ttl=3600, rank=dnsp.DNS_RANK_ZONE):
        super(SOARecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_SOA
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        soa = dnsp.soa()
        soa.serial = serial
        soa.refresh = refresh
        soa.retry = retry
        soa.expire = expire
        soa.mname = mname
        soa.rname = rname
        soa.minimum = minimum
        self.data = soa


class SRVRecord(dnsp.DnssrvRpcRecord):

    def __init__(self, target, port, priority=0, weight=100, serial=1, ttl=900,
                rank=dnsp.DNS_RANK_ZONE):
        super(SRVRecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_SRV
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        srv = dnsp.srv()
        srv.nameTarget = target
        srv.wPort = port
        srv.wPriority = priority
        srv.wWeight = weight
        self.data = srv


class TXTRecord(dnsp.DnssrvRpcRecord):

    def __init__(self, slist, serial=1, ttl=900, rank=dnsp.DNS_RANK_ZONE):
        super(TXTRecord, self).__init__()
        self.wType = dnsp.DNS_TYPE_TXT
        self.rank = rank
        self.dwSerial = serial
        self.dwTtlSeconds = ttl
        stringlist = dnsp.string_list()
        stringlist.count = len(slist)
        stringlist.str = slist
        self.data = stringlist


class TypeProperty(dnsp.DnsProperty):

    def __init__(self, zone_type=dnsp.DNS_ZONE_TYPE_PRIMARY):
        super(TypeProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1
        self.id = dnsp.DSPROPERTY_ZONE_TYPE
        self.data = zone_type


class AllowUpdateProperty(dnsp.DnsProperty):

    def __init__(self, allow_update=dnsp.DNS_ZONE_UPDATE_SECURE):
        super(AllowUpdateProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1
        self.id = dnsp.DSPROPERTY_ZONE_ALLOW_UPDATE
        self.data = allow_update


class SecureTimeProperty(dnsp.DnsProperty):

    def __init__(self, secure_time=0):
        super(SecureTimeProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1
        self.id = dnsp.DSPROPERTY_ZONE_SECURE_TIME
        self.data = secure_time


class NorefreshIntervalProperty(dnsp.DnsProperty):

    def __init__(self, norefresh_interval=0):
        super(NorefreshIntervalProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1
        self.id = dnsp.DSPROPERTY_ZONE_NOREFRESH_INTERVAL
        self.data = norefresh_interval


class RefreshIntervalProperty(dnsp.DnsProperty):

    def __init__(self, refresh_interval=0):
        super(RefreshIntervalProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1
        self.id = dnsp.DSPROPERTY_ZONE_REFRESH_INTERVAL
        self.data = refresh_interval


class AgingStateProperty(dnsp.DnsProperty):

    def __init__(self, aging_enabled=0):
        super(AgingStateProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1
        self.id = dnsp.DSPROPERTY_ZONE_AGING_STATE
        self.data = aging_enabled


class AgingEnabledTimeProperty(dnsp.DnsProperty):

    def __init__(self, next_cycle_hours=0):
        super(AgingEnabledTimeProperty, self).__init__()
        self.wDataLength = 1
        self.version = 1;
        self.id = dnsp.DSPROPERTY_ZONE_AGING_ENABLED_TIME
        self.data = next_cycle_hours


def setup_dns_partitions(samdb, domainsid, domaindn, forestdn, configdn,
                         serverdn, fill_level):
    domainzone_dn = "DC=DomainDnsZones,%s" % domaindn
    forestzone_dn = "DC=ForestDnsZones,%s" % forestdn
    descriptor = get_dns_partition_descriptor(domainsid)

    setup_add_ldif(samdb, setup_path("provision_dnszones_partitions.ldif"), {
        "ZONE_DN": domainzone_dn,
        "SECDESC"      : b64encode(descriptor)
        })
    if fill_level != FILL_SUBDOMAIN:
        setup_add_ldif(samdb, setup_path("provision_dnszones_partitions.ldif"), {
            "ZONE_DN": forestzone_dn,
            "SECDESC"      : b64encode(descriptor)
        })

    domainzone_guid = get_domainguid(samdb, domainzone_dn)
    domainzone_guid = str(uuid.uuid4())
    domainzone_dns = ldb.Dn(samdb, domainzone_dn).canonical_ex_str().strip()

    protected1_desc = get_domain_delete_protected1_descriptor(domainsid)
    protected2_desc = get_domain_delete_protected2_descriptor(domainsid)
    setup_add_ldif(samdb, setup_path("provision_dnszones_add.ldif"), {
        "ZONE_DN": domainzone_dn,
        "ZONE_GUID": domainzone_guid,
        "ZONE_DNS": domainzone_dns,
        "CONFIGDN": configdn,
        "SERVERDN": serverdn,
        "LOSTANDFOUND_DESCRIPTOR": b64encode(protected2_desc),
        "INFRASTRUCTURE_DESCRIPTOR": b64encode(protected1_desc),
        })
    setup_modify_ldif(samdb, setup_path("provision_dnszones_modify.ldif"), {
        "CONFIGDN": configdn,
        "SERVERDN": serverdn,
        "ZONE_DN": domainzone_dn,
    })

    if fill_level != FILL_SUBDOMAIN:
        forestzone_guid = get_domainguid(samdb, forestzone_dn)
        forestzone_guid = str(uuid.uuid4())
        forestzone_dns = ldb.Dn(samdb, forestzone_dn).canonical_ex_str().strip()

        setup_add_ldif(samdb, setup_path("provision_dnszones_add.ldif"), {
            "ZONE_DN": forestzone_dn,
            "ZONE_GUID": forestzone_guid,
            "ZONE_DNS": forestzone_dns,
            "CONFIGDN": configdn,
            "SERVERDN": serverdn,
            "LOSTANDFOUND_DESCRIPTOR": b64encode(protected2_desc),
            "INFRASTRUCTURE_DESCRIPTOR": b64encode(protected1_desc),
        })
        setup_modify_ldif(samdb, setup_path("provision_dnszones_modify.ldif"), {
            "CONFIGDN": configdn,
            "SERVERDN": serverdn,
            "ZONE_DN": forestzone_dn,
        })


def add_dns_accounts(samdb, domaindn):
    setup_add_ldif(samdb, setup_path("provision_dns_accounts_add.ldif"), {
        "DOMAINDN": domaindn,
        })


def add_dns_container(samdb, domaindn, prefix, domain_sid, dnsadmins_sid, forest=False):
    name_map = {'DnsAdmins': str(dnsadmins_sid)}
    if forest is True:
        sd_val = get_dns_forest_microsoft_dns_descriptor(domain_sid,
                                                         name_map=name_map)
    else:
        sd_val = get_dns_domain_microsoft_dns_descriptor(domain_sid,
                                                         name_map=name_map)
    # CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    msg = ldb.Message(ldb.Dn(samdb, "CN=MicrosoftDNS,%s,%s" % (prefix, domaindn)))
    msg["objectClass"] = ["top", "container"]
    msg["nTSecurityDescriptor"] = ldb.MessageElement(sd_val, ldb.FLAG_MOD_ADD,
        "nTSecurityDescriptor")
    samdb.add(msg)


def add_rootservers(samdb, domaindn, prefix):
    # https://www.internic.net/zones/named.root
    rootservers = {}
    rootservers["a.root-servers.net"] = "198.41.0.4"
    rootservers["b.root-servers.net"] = "192.228.79.201"
    rootservers["c.root-servers.net"] = "192.33.4.12"
    rootservers["d.root-servers.net"] = "199.7.91.13"
    rootservers["e.root-servers.net"] = "192.203.230.10"
    rootservers["f.root-servers.net"] = "192.5.5.241"
    rootservers["g.root-servers.net"] = "192.112.36.4"
    rootservers["h.root-servers.net"] = "198.97.190.53"
    rootservers["i.root-servers.net"] = "192.36.148.17"
    rootservers["j.root-servers.net"] = "192.58.128.30"
    rootservers["k.root-servers.net"] = "193.0.14.129"
    rootservers["l.root-servers.net"] = "199.7.83.42"
    rootservers["m.root-servers.net"] = "202.12.27.33"

    rootservers_v6 = {}
    rootservers_v6["a.root-servers.net"] = "2001:503:ba3e::2:30"
    rootservers_v6["b.root-servers.net"] = "2001:500:84::b"
    rootservers_v6["c.root-servers.net"] = "2001:500:2::c"
    rootservers_v6["d.root-servers.net"] = "2001:500:2d::d"
    rootservers_v6["e.root-servers.net"] = "2001:500:a8::e"
    rootservers_v6["f.root-servers.net"] = "2001:500:2f::f"
    rootservers_v6["g.root-servers.net"] = "2001:500:12::d0d"
    rootservers_v6["h.root-servers.net"] = "2001:500:1::53"
    rootservers_v6["i.root-servers.net"] = "2001:7fe::53"
    rootservers_v6["j.root-servers.net"] = "2001:503:c27::2:30"
    rootservers_v6["k.root-servers.net"] = "2001:7fd::1"
    rootservers_v6["l.root-servers.net"] = "2001:500:9f::42"
    rootservers_v6["m.root-servers.net"] = "2001:dc3::35"

    container_dn = "DC=RootDNSServers,CN=MicrosoftDNS,%s,%s" % (prefix, domaindn)

    # Add DC=RootDNSServers,CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    msg = ldb.Message(ldb.Dn(samdb, container_dn))
    props = []
    props.append(ndr_pack(TypeProperty(zone_type=dnsp.DNS_ZONE_TYPE_CACHE)))
    props.append(ndr_pack(AllowUpdateProperty(allow_update=dnsp.DNS_ZONE_UPDATE_OFF)))
    props.append(ndr_pack(SecureTimeProperty()))
    props.append(ndr_pack(NorefreshIntervalProperty()))
    props.append(ndr_pack(RefreshIntervalProperty()))
    props.append(ndr_pack(AgingStateProperty()))
    props.append(ndr_pack(AgingEnabledTimeProperty()))
    msg["objectClass"] = ["top", "dnsZone"]
    msg["cn"] = ldb.MessageElement("Zone", ldb.FLAG_MOD_ADD, "cn")
    msg["dNSProperty"] = ldb.MessageElement(props, ldb.FLAG_MOD_ADD, "dNSProperty")
    samdb.add(msg)

    # Add DC=@,DC=RootDNSServers,CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    record = []
    for rserver in rootservers:
        record.append(ndr_pack(NSRecord(rserver, serial=0, ttl=0, rank=dnsp.DNS_RANK_ROOT_HINT)))

    msg = ldb.Message(ldb.Dn(samdb, "DC=@,%s" % container_dn))
    msg["objectClass"] = ["top", "dnsNode"]
    msg["dnsRecord"] = ldb.MessageElement(record, ldb.FLAG_MOD_ADD, "dnsRecord")
    samdb.add(msg)

    # Add DC=<rootserver>,DC=RootDNSServers,CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    for rserver in rootservers:
        record = [ndr_pack(ARecord(rootservers[rserver], serial=0, ttl=0, rank=dnsp.DNS_RANK_ROOT_HINT))]
        # Add AAAA record as well (How does W2K* add IPv6 records?)
        #if rserver in rootservers_v6:
        #    record.append(ndr_pack(AAAARecord(rootservers_v6[rserver], serial=0, ttl=0)))
        msg = ldb.Message(ldb.Dn(samdb, "DC=%s,%s" % (rserver, container_dn)))
        msg["objectClass"] = ["top", "dnsNode"]
        msg["dnsRecord"] = ldb.MessageElement(record, ldb.FLAG_MOD_ADD, "dnsRecord")
        samdb.add(msg)

def add_at_record(samdb, container_dn, prefix, hostname, dnsdomain, hostip, hostip6):

    fqdn_hostname = "%s.%s" % (hostname, dnsdomain)

    at_records = []

    # SOA record
    at_soa_record = SOARecord(fqdn_hostname, "hostmaster.%s" % dnsdomain)
    at_records.append(ndr_pack(at_soa_record))

    # NS record
    at_ns_record = NSRecord(fqdn_hostname)
    at_records.append(ndr_pack(at_ns_record))

    if hostip is not None:
        # A record
        at_a_record = ARecord(hostip)
        at_records.append(ndr_pack(at_a_record))

    if hostip6 is not None:
        # AAAA record
        at_aaaa_record = AAAARecord(hostip6)
        at_records.append(ndr_pack(at_aaaa_record))

    msg = ldb.Message(ldb.Dn(samdb, "DC=@,%s" % container_dn))
    msg["objectClass"] = ["top", "dnsNode"]
    msg["dnsRecord"] = ldb.MessageElement(at_records, ldb.FLAG_MOD_ADD, "dnsRecord")
    samdb.add(msg)


def add_srv_record(samdb, container_dn, prefix, host, port):
    srv_record = SRVRecord(host, port)
    msg = ldb.Message(ldb.Dn(samdb, "%s,%s" % (prefix, container_dn)))
    msg["objectClass"] = ["top", "dnsNode"]
    msg["dnsRecord"] = ldb.MessageElement(ndr_pack(srv_record), ldb.FLAG_MOD_ADD, "dnsRecord")
    samdb.add(msg)


def add_ns_record(samdb, container_dn, prefix, host):
    ns_record = NSRecord(host)
    msg = ldb.Message(ldb.Dn(samdb, "%s,%s" % (prefix, container_dn)))
    msg["objectClass"] = ["top", "dnsNode"]
    msg["dnsRecord"] = ldb.MessageElement(ndr_pack(ns_record), ldb.FLAG_MOD_ADD, "dnsRecord")
    samdb.add(msg)


def add_ns_glue_record(samdb, container_dn, prefix, host):
    ns_record = NSRecord(host, rank=dnsp.DNS_RANK_NS_GLUE)
    msg = ldb.Message(ldb.Dn(samdb, "%s,%s" % (prefix, container_dn)))
    msg["objectClass"] = ["top", "dnsNode"]
    msg["dnsRecord"] = ldb.MessageElement(ndr_pack(ns_record), ldb.FLAG_MOD_ADD, "dnsRecord")
    samdb.add(msg)


def add_cname_record(samdb, container_dn, prefix, host):
    cname_record = CNameRecord(host)
    msg = ldb.Message(ldb.Dn(samdb, "%s,%s" % (prefix, container_dn)))
    msg["objectClass"] = ["top", "dnsNode"]
    msg["dnsRecord"] = ldb.MessageElement(ndr_pack(cname_record), ldb.FLAG_MOD_ADD, "dnsRecord")
    samdb.add(msg)


def add_host_record(samdb, container_dn, prefix, hostip, hostip6):
    host_records = []
    if hostip:
        a_record = ARecord(hostip)
        host_records.append(ndr_pack(a_record))
    if hostip6:
        aaaa_record = AAAARecord(hostip6)
        host_records.append(ndr_pack(aaaa_record))
    if host_records:
        msg = ldb.Message(ldb.Dn(samdb, "%s,%s" % (prefix, container_dn)))
        msg["objectClass"] = ["top", "dnsNode"]
        msg["dnsRecord"] = ldb.MessageElement(host_records, ldb.FLAG_MOD_ADD, "dnsRecord")
        samdb.add(msg)


def add_domain_record(samdb, domaindn, prefix, dnsdomain, domainsid, dnsadmins_sid):
    # DC=<DNSDOMAIN>,CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    sddl = "O:SYG:BAD:AI" \
    "(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)" \
    "(A;;CC;;;AU)" \
    "(A;;RPLCLORC;;;WD)" \
    "(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)" \
    "(A;CI;RPWPCRCCDCLCRCWOWDSDDTSW;;;ED)" \
    "(A;CIID;RPWPCRCCDCLCRCWOWDSDDTSW;;;%s)" \
    "(A;CIID;RPWPCRCCDCLCRCWOWDSDDTSW;;;ED)" \
    "(OA;CIID;RPWPCR;91e647de-d96f-4b70-9557-d63ff4f3ccd8;;PS)" \
    "(A;CIID;RPWPCRCCDCLCLORCWOWDSDDTSW;;;EA)" \
    "(A;CIID;LC;;;RU)" \
    "(A;CIID;RPWPCRCCLCLORCWOWDSDSW;;;BA)" \
    "S:AI" % dnsadmins_sid
    sec = security.descriptor.from_sddl(sddl, domainsid)
    props = []
    props.append(ndr_pack(TypeProperty()))
    props.append(ndr_pack(AllowUpdateProperty()))
    props.append(ndr_pack(SecureTimeProperty()))
    props.append(ndr_pack(NorefreshIntervalProperty(norefresh_interval=168)))
    props.append(ndr_pack(RefreshIntervalProperty(refresh_interval=168)))
    props.append(ndr_pack(AgingStateProperty()))
    props.append(ndr_pack(AgingEnabledTimeProperty()))
    msg = ldb.Message(ldb.Dn(samdb, "DC=%s,CN=MicrosoftDNS,%s,%s" % (dnsdomain, prefix, domaindn)))
    msg["objectClass"] = ["top", "dnsZone"]
    msg["ntSecurityDescriptor"] = ldb.MessageElement(ndr_pack(sec), ldb.FLAG_MOD_ADD,
        "nTSecurityDescriptor")
    msg["dNSProperty"] = ldb.MessageElement(props, ldb.FLAG_MOD_ADD, "dNSProperty")
    samdb.add(msg)


def add_msdcs_record(samdb, forestdn, prefix, dnsforest):
    # DC=_msdcs.<DNSFOREST>,CN=MicrosoftDNS,<PREFIX>,<FORESTDN>
    msg = ldb.Message(ldb.Dn(samdb, "DC=_msdcs.%s,CN=MicrosoftDNS,%s,%s" %
                                    (dnsforest, prefix, forestdn)))
    msg["objectClass"] = ["top", "dnsZone"]
    samdb.add(msg)


def add_dc_domain_records(samdb, domaindn, prefix, site, dnsdomain, hostname,
        hostip, hostip6):

    fqdn_hostname = "%s.%s" % (hostname, dnsdomain)

    # Set up domain container - DC=<DNSDOMAIN>,CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    domain_container_dn = ldb.Dn(samdb, "DC=%s,CN=MicrosoftDNS,%s,%s" %
                                    (dnsdomain, prefix, domaindn))

    # DC=@ record
    add_at_record(samdb, domain_container_dn, "DC=@", hostname, dnsdomain,
            hostip, hostip6)

    # DC=<HOSTNAME> record
    add_host_record(samdb, domain_container_dn, "DC=%s" % hostname, hostip,
            hostip6)

    # DC=_kerberos._tcp record
    add_srv_record(samdb, domain_container_dn, "DC=_kerberos._tcp",
            fqdn_hostname, 88)

    # DC=_kerberos._tcp.<SITENAME>._sites record
    add_srv_record(samdb, domain_container_dn, "DC=_kerberos._tcp.%s._sites" %
            site, fqdn_hostname, 88)

    # DC=_kerberos._udp record
    add_srv_record(samdb, domain_container_dn, "DC=_kerberos._udp",
            fqdn_hostname, 88)

    # DC=_kpasswd._tcp record
    add_srv_record(samdb, domain_container_dn, "DC=_kpasswd._tcp",
            fqdn_hostname, 464)

    # DC=_kpasswd._udp record
    add_srv_record(samdb, domain_container_dn, "DC=_kpasswd._udp",
            fqdn_hostname, 464)

    # DC=_ldap._tcp record
    add_srv_record(samdb, domain_container_dn, "DC=_ldap._tcp", fqdn_hostname,
            389)

    # DC=_ldap._tcp.<SITENAME>._sites record
    add_srv_record(samdb, domain_container_dn, "DC=_ldap._tcp.%s._sites" %
            site, fqdn_hostname, 389)

    # FIXME: The number of SRV records depend on the various roles this DC has.
    #        _gc and _msdcs records are added if the we are the forest dc and not subdomain dc
    #
    # Assumption: current DC is GC and add all the entries

    # DC=_gc._tcp record
    add_srv_record(samdb, domain_container_dn, "DC=_gc._tcp", fqdn_hostname,
            3268)

    # DC=_gc._tcp.<SITENAME>,_sites record
    add_srv_record(samdb, domain_container_dn, "DC=_gc._tcp.%s._sites" % site,
            fqdn_hostname, 3268)

    # DC=_msdcs record
    add_ns_glue_record(samdb, domain_container_dn, "DC=_msdcs", fqdn_hostname)

    # FIXME: Following entries are added only if DomainDnsZones and ForestDnsZones partitions
    #        are created
    #
    # Assumption: Additional entries won't hurt on os_level = 2000

    # DC=_ldap._tcp.<SITENAME>._sites.DomainDnsZones
    add_srv_record(samdb, domain_container_dn,
            "DC=_ldap._tcp.%s._sites.DomainDnsZones" % site, fqdn_hostname,
            389)

    # DC=_ldap._tcp.<SITENAME>._sites.ForestDnsZones
    add_srv_record(samdb, domain_container_dn,
            "DC=_ldap._tcp.%s._sites.ForestDnsZones" % site, fqdn_hostname,
            389)

    # DC=_ldap._tcp.DomainDnsZones
    add_srv_record(samdb, domain_container_dn, "DC=_ldap._tcp.DomainDnsZones",
                    fqdn_hostname, 389)

    # DC=_ldap._tcp.ForestDnsZones
    add_srv_record(samdb, domain_container_dn, "DC=_ldap._tcp.ForestDnsZones",
                    fqdn_hostname, 389)

    # DC=DomainDnsZones
    add_host_record(samdb, domain_container_dn, "DC=DomainDnsZones", hostip,
            hostip6)

    # DC=ForestDnsZones
    add_host_record(samdb, domain_container_dn, "DC=ForestDnsZones", hostip,
            hostip6)


def add_dc_msdcs_records(samdb, forestdn, prefix, site, dnsforest, hostname,
                            hostip, hostip6, domainguid, ntdsguid):

    fqdn_hostname = "%s.%s" % (hostname, dnsforest)

    # Set up forest container - DC=<DNSDOMAIN>,CN=MicrosoftDNS,<PREFIX>,<DOMAINDN>
    forest_container_dn = ldb.Dn(samdb, "DC=_msdcs.%s,CN=MicrosoftDNS,%s,%s" %
                                    (dnsforest, prefix, forestdn))

    # DC=@ record
    add_at_record(samdb, forest_container_dn, "DC=@", hostname, dnsforest,
            None, None)

    # DC=_kerberos._tcp.dc record
    add_srv_record(samdb, forest_container_dn, "DC=_kerberos._tcp.dc",
            fqdn_hostname, 88)

    # DC=_kerberos._tcp.<SITENAME>._sites.dc record
    add_srv_record(samdb, forest_container_dn,
            "DC=_kerberos._tcp.%s._sites.dc" % site, fqdn_hostname, 88)

    # DC=_ldap._tcp.dc record
    add_srv_record(samdb, forest_container_dn, "DC=_ldap._tcp.dc",
            fqdn_hostname, 389)

    # DC=_ldap._tcp.<SITENAME>._sites.dc record
    add_srv_record(samdb, forest_container_dn, "DC=_ldap._tcp.%s._sites.dc" %
            site, fqdn_hostname, 389)

    # DC=_ldap._tcp.<SITENAME>._sites.gc record
    add_srv_record(samdb, forest_container_dn, "DC=_ldap._tcp.%s._sites.gc" %
            site, fqdn_hostname, 3268)

    # DC=_ldap._tcp.gc record
    add_srv_record(samdb, forest_container_dn, "DC=_ldap._tcp.gc",
            fqdn_hostname, 3268)

    # DC=_ldap._tcp.pdc record
    add_srv_record(samdb, forest_container_dn, "DC=_ldap._tcp.pdc",
            fqdn_hostname, 389)

    # DC=gc record
    add_host_record(samdb, forest_container_dn, "DC=gc", hostip, hostip6)

    # DC=_ldap._tcp.<DOMAINGUID>.domains record
    add_srv_record(samdb, forest_container_dn,
            "DC=_ldap._tcp.%s.domains" % domainguid, fqdn_hostname, 389)

    # DC=<NTDSGUID>
    add_cname_record(samdb, forest_container_dn, "DC=%s" % ntdsguid,
            fqdn_hostname)


def secretsdb_setup_dns(secretsdb, names, private_dir, realm,
                        dnsdomain, dns_keytab_path, dnspass, key_version_number):
    """Add DNS specific bits to a secrets database.

    :param secretsdb: Ldb Handle to the secrets database
    :param names: Names shortcut
    :param machinepass: Machine password
    """
    try:
        os.unlink(os.path.join(private_dir, dns_keytab_path))
    except OSError:
        pass

    if key_version_number is None:
        key_version_number = 1

    setup_ldb(secretsdb, setup_path("secrets_dns.ldif"), {
            "REALM": realm,
            "DNSDOMAIN": dnsdomain,
            "DNS_KEYTAB": dns_keytab_path,
            "DNSPASS_B64": b64encode(dnspass.encode('utf-8')),
            "KEY_VERSION_NUMBER": str(key_version_number),
            "HOSTNAME": names.hostname,
            "DNSNAME" : '%s.%s' % (
                names.netbiosname.lower(), names.dnsdomain.lower())
            })


def create_dns_dir(logger, paths):
    """Write out a DNS zone file, from the info in the current database.

    :param logger: Logger object
    :param paths: paths object
    """
    dns_dir = os.path.dirname(paths.dns)

    try:
        shutil.rmtree(dns_dir, True)
    except OSError:
        pass

    os.mkdir(dns_dir, 0770)

    if paths.bind_gid is not None:
        try:
            os.chown(dns_dir, -1, paths.bind_gid)
            # chmod needed to cope with umask
            os.chmod(dns_dir, 0770)
        except OSError:
            if not os.environ.has_key('SAMBA_SELFTEST'):
                logger.error("Failed to chown %s to bind gid %u" % (
                    dns_dir, paths.bind_gid))


def create_zone_file(lp, logger, paths, targetdir, dnsdomain,
                     hostip, hostip6, hostname, realm, domainguid,
                     ntdsguid, site):
    """Write out a DNS zone file, from the info in the current database.

    :param paths: paths object
    :param dnsdomain: DNS Domain name
    :param domaindn: DN of the Domain
    :param hostip: Local IPv4 IP
    :param hostip6: Local IPv6 IP
    :param hostname: Local hostname
    :param realm: Realm name
    :param domainguid: GUID of the domain.
    :param ntdsguid: GUID of the hosts nTDSDSA record.
    """
    assert isinstance(domainguid, str)

    if hostip6 is not None:
        hostip6_base_line = "            IN AAAA    " + hostip6
        hostip6_host_line = hostname + "        IN AAAA    " + hostip6
        gc_msdcs_ip6_line = "gc._msdcs               IN AAAA    " + hostip6
    else:
        hostip6_base_line = ""
        hostip6_host_line = ""
        gc_msdcs_ip6_line = ""

    if hostip is not None:
        hostip_base_line = "            IN A    " + hostip
        hostip_host_line = hostname + "        IN A    " + hostip
        gc_msdcs_ip_line = "gc._msdcs               IN A    " + hostip
    else:
        hostip_base_line = ""
        hostip_host_line = ""
        gc_msdcs_ip_line = ""

    # we need to freeze the zone while we update the contents
    if targetdir is None:
        rndc = ' '.join(lp.get("rndc command"))
        os.system(rndc + " freeze " + lp.get("realm"))

    setup_file(setup_path("provision.zone"), paths.dns, {
            "HOSTNAME": hostname,
            "DNSDOMAIN": dnsdomain,
            "REALM": realm,
            "HOSTIP_BASE_LINE": hostip_base_line,
            "HOSTIP_HOST_LINE": hostip_host_line,
            "DOMAINGUID": domainguid,
            "DATESTRING": time.strftime("%Y%m%d%H"),
            "DEFAULTSITE": site,
            "NTDSGUID": ntdsguid,
            "HOSTIP6_BASE_LINE": hostip6_base_line,
            "HOSTIP6_HOST_LINE": hostip6_host_line,
            "GC_MSDCS_IP_LINE": gc_msdcs_ip_line,
            "GC_MSDCS_IP6_LINE": gc_msdcs_ip6_line,
        })

    if paths.bind_gid is not None:
        try:
            os.chown(paths.dns, -1, paths.bind_gid)
            # chmod needed to cope with umask
            os.chmod(paths.dns, 0664)
        except OSError:
            if not os.environ.has_key('SAMBA_SELFTEST'):
                logger.error("Failed to chown %s to bind gid %u" % (
                    paths.dns, paths.bind_gid))

    if targetdir is None:
        os.system(rndc + " unfreeze " + lp.get("realm"))


def create_samdb_copy(samdb, logger, paths, names, domainsid, domainguid):
    """Create a copy of samdb and give write permissions to named for dns partitions
    """
    private_dir = paths.private_dir
    samldb_dir = os.path.join(private_dir, "sam.ldb.d")
    dns_dir = os.path.dirname(paths.dns)
    dns_samldb_dir = os.path.join(dns_dir, "sam.ldb.d")

    # Find the partitions and corresponding filenames
    partfile = {}
    res = samdb.search(base="@PARTITION", scope=ldb.SCOPE_BASE, attrs=["partition"])
    for tmp in res[0]["partition"]:
        (nc, fname) = tmp.split(':')
        partfile[nc.upper()] = fname

    # Create empty domain partition
    domaindn = names.domaindn.upper()
    domainpart_file = os.path.join(dns_dir, partfile[domaindn])
    try:
        os.mkdir(dns_samldb_dir)
        file(domainpart_file, 'w').close()

        # Fill the basedn and @OPTION records in domain partition
        dom_ldb = samba.Ldb(domainpart_file)
        domainguid_line = "objectGUID: %s\n-" % domainguid
        descr = b64encode(get_domain_descriptor(domainsid))
        setup_add_ldif(dom_ldb, setup_path("provision_basedn.ldif"), {
            "DOMAINDN" : names.domaindn,
            "DOMAINGUID" : domainguid_line,
            "DOMAINSID" : str(domainsid),
            "DESCRIPTOR" : descr})
        setup_add_ldif(dom_ldb,
            setup_path("provision_basedn_options.ldif"), None)
    except:
        logger.error(
            "Failed to setup database for BIND, AD based DNS cannot be used")
        raise

    # This line is critical to the security of the whole scheme.
    # We assume there is no secret data in the (to be left out of
    # date and essentially read-only) config, schema and metadata partitions.
    #
    # Only the stub of the domain partition is created above.
    #
    # That way, things like the krbtgt key do not leak.
    del partfile[domaindn]

    # Link dns partitions and metadata
    domainzonedn = "DC=DOMAINDNSZONES,%s" % names.domaindn.upper()
    forestzonedn = "DC=FORESTDNSZONES,%s" % names.rootdn.upper()

    domainzone_file = partfile[domainzonedn]
    forestzone_file = partfile.get(forestzonedn)

    metadata_file = "metadata.tdb"
    try:
        os.link(os.path.join(samldb_dir, metadata_file),
            os.path.join(dns_samldb_dir, metadata_file))
        os.link(os.path.join(private_dir, domainzone_file),
            os.path.join(dns_dir, domainzone_file))
        if forestzone_file:
            os.link(os.path.join(private_dir, forestzone_file),
                    os.path.join(dns_dir, forestzone_file))
    except OSError:
        logger.error(
            "Failed to setup database for BIND, AD based DNS cannot be used")
        raise
    del partfile[domainzonedn]
    if forestzone_file:
        del partfile[forestzonedn]

    # Copy root, config, schema partitions (and any other if any)
    # Since samdb is open in the current process, copy them in a child process
    try:
        tdb_copy(os.path.join(private_dir, "sam.ldb"),
                 os.path.join(dns_dir, "sam.ldb"))
        for nc in partfile:
            pfile = partfile[nc]
            tdb_copy(os.path.join(private_dir, pfile),
                     os.path.join(dns_dir, pfile))
    except:
        logger.error(
            "Failed to setup database for BIND, AD based DNS cannot be used")
        raise

    # Give bind read/write permissions dns partitions
    if paths.bind_gid is not None:
        try:
            os.chown(samldb_dir, -1, paths.bind_gid)
            os.chmod(samldb_dir, 0750)

            for dirname, dirs, files in os.walk(dns_dir):
                for d in dirs:
                    dpath = os.path.join(dirname, d)
                    os.chown(dpath, -1, paths.bind_gid)
                    os.chmod(dpath, 0770)
                for f in files:
                    if f.endswith('.ldb') or f.endswith('.tdb'):
                        fpath = os.path.join(dirname, f)
                        os.chown(fpath, -1, paths.bind_gid)
                        os.chmod(fpath, 0660)
        except OSError:
            if not os.environ.has_key('SAMBA_SELFTEST'):
                logger.error(
                    "Failed to set permissions to sam.ldb* files, fix manually")
    else:
        if not os.environ.has_key('SAMBA_SELFTEST'):
            logger.warning("""Unable to find group id for BIND,
                set permissions to sam.ldb* files manually""")


def create_dns_update_list(lp, logger, paths):
    """Write out a dns_update_list file"""
    # note that we use no variable substitution on this file
    # the substitution is done at runtime by samba_dnsupdate, samba_spnupdate
    setup_file(setup_path("dns_update_list"), paths.dns_update_list, None)
    setup_file(setup_path("spn_update_list"), paths.spn_update_list, None)


def create_named_conf(paths, realm, dnsdomain, dns_backend, logger):
    """Write out a file containing zone statements suitable for inclusion in a
    named.conf file (including GSS-TSIG configuration).

    :param paths: all paths
    :param realm: Realm name
    :param dnsdomain: DNS Domain name
    :param dns_backend: DNS backend type
    :param keytab_name: File name of DNS keytab file
    :param logger: Logger object
    """

    # TODO: This really should have been done as a top level import.
    # It is done here to avoid a depencency loop.  That is, we move
    # ProvisioningError to another file, and have all the provision
    # scripts import it from there.

    from samba.provision import ProvisioningError

    if dns_backend == "BIND9_FLATFILE":
        setup_file(setup_path("named.conf"), paths.namedconf, {
                    "DNSDOMAIN": dnsdomain,
                    "REALM": realm,
                    "ZONE_FILE": paths.dns,
                    "REALM_WC": "*." + ".".join(realm.split(".")[1:]),
                    "NAMED_CONF": paths.namedconf,
                    "NAMED_CONF_UPDATE": paths.namedconf_update
                    })

        setup_file(setup_path("named.conf.update"), paths.namedconf_update)

    elif dns_backend == "BIND9_DLZ":
        bind_info = subprocess.Popen(['named -V'], shell=True,
                                     stdout=subprocess.PIPE,
                                     stderr=subprocess.STDOUT,
                                     cwd='.').communicate()[0]
        bind9_8 = '#'
        bind9_9 = '#'
        bind9_10 = '#'
        bind9_11 = '#'
        if bind_info.upper().find('BIND 9.8') != -1:
            bind9_8 = ''
        elif bind_info.upper().find('BIND 9.9') != -1:
            bind9_9 = ''
        elif bind_info.upper().find('BIND 9.10') != -1:
            bind9_10 = ''
        elif bind_info.upper().find('BIND 9.11') != -1:
            bind9_11 = ''
        elif bind_info.upper().find('BIND 9.7') != -1:
            raise ProvisioningError("DLZ option incompatible with BIND 9.7.")
        else:
            logger.warning("BIND version unknown, please modify %s manually." % paths.namedconf)
        setup_file(setup_path("named.conf.dlz"), paths.namedconf, {
                    "NAMED_CONF": paths.namedconf,
                    "MODULESDIR" : samba.param.modules_dir(),
                    "BIND9_8" : bind9_8,
                    "BIND9_9" : bind9_9,
                    "BIND9_10" : bind9_10,
                    "BIND9_11" : bind9_11
                    })


def create_named_txt(path, realm, dnsdomain, dnsname, private_dir,
    keytab_name):
    """Write out a file containing zone statements suitable for inclusion in a
    named.conf file (including GSS-TSIG configuration).

    :param path: Path of the new named.conf file.
    :param realm: Realm name
    :param dnsdomain: DNS Domain name
    :param private_dir: Path to private directory
    :param keytab_name: File name of DNS keytab file
    """
    setup_file(setup_path("named.txt"), path, {
            "DNSDOMAIN": dnsdomain,
            "DNSNAME" : dnsname,
            "REALM": realm,
            "DNS_KEYTAB": keytab_name,
            "DNS_KEYTAB_ABS": os.path.join(private_dir, keytab_name),
            "PRIVATE_DIR": private_dir
        })


def is_valid_dns_backend(dns_backend):
    return dns_backend in ("BIND9_FLATFILE", "BIND9_DLZ", "SAMBA_INTERNAL", "NONE")


def is_valid_os_level(os_level):
    return DS_DOMAIN_FUNCTION_2000 <= os_level <= DS_DOMAIN_FUNCTION_2012_R2


def create_dns_legacy(samdb, domainsid, forestdn, dnsadmins_sid):
    # Set up MicrosoftDNS container
    add_dns_container(samdb, forestdn, "CN=System", domainsid, dnsadmins_sid)
    # Add root servers
    add_rootservers(samdb, forestdn, "CN=System")


def fill_dns_data_legacy(samdb, domainsid, forestdn, dnsdomain, site, hostname,
                         hostip, hostip6, dnsadmins_sid):
    # Add domain record
    add_domain_record(samdb, forestdn, "CN=System", dnsdomain, domainsid,
                      dnsadmins_sid)

    # Add DNS records for a DC in domain
    add_dc_domain_records(samdb, forestdn, "CN=System", site, dnsdomain,
                          hostname, hostip, hostip6)


def create_dns_partitions(samdb, domainsid, names, domaindn, forestdn,
                          dnsadmins_sid, fill_level):
    # Set up additional partitions (DomainDnsZones, ForstDnsZones)
    setup_dns_partitions(samdb, domainsid, domaindn, forestdn,
                        names.configdn, names.serverdn, fill_level)

    # Set up MicrosoftDNS containers
    add_dns_container(samdb, domaindn, "DC=DomainDnsZones", domainsid,
                      dnsadmins_sid)
    if fill_level != FILL_SUBDOMAIN:
        add_dns_container(samdb, forestdn, "DC=ForestDnsZones", domainsid,
                          dnsadmins_sid, forest=True)


def fill_dns_data_partitions(samdb, domainsid, site, domaindn, forestdn,
                             dnsdomain, dnsforest, hostname, hostip, hostip6,
                             domainguid, ntdsguid, dnsadmins_sid, autofill=True,
                             fill_level=FILL_FULL):
    """Fill data in various AD partitions

    :param samdb: LDB object connected to sam.ldb file
    :param domainsid: Domain SID (as dom_sid object)
    :param site: Site name to create hostnames in
    :param domaindn: DN of the domain
    :param forestdn: DN of the forest
    :param dnsdomain: DNS name of the domain
    :param dnsforest: DNS name of the forest
    :param hostname: Host name of this DC
    :param hostip: IPv4 addresses
    :param hostip6: IPv6 addresses
    :param domainguid: Domain GUID
    :param ntdsguid: NTDS GUID
    :param dnsadmins_sid: SID for DnsAdmins group
    :param autofill: Create DNS records (using fixed template)
    """

    ##### Set up DC=DomainDnsZones,<DOMAINDN>
    # Add rootserver records
    add_rootservers(samdb, domaindn, "DC=DomainDnsZones")

    # Add domain record
    add_domain_record(samdb, domaindn, "DC=DomainDnsZones", dnsdomain,
                      domainsid, dnsadmins_sid)

    # Add DNS records for a DC in domain
    if autofill:
        add_dc_domain_records(samdb, domaindn, "DC=DomainDnsZones", site,
                              dnsdomain, hostname, hostip, hostip6)

    if fill_level != FILL_SUBDOMAIN:
        ##### Set up DC=ForestDnsZones,<FORESTDN>
        # Add _msdcs record
        add_msdcs_record(samdb, forestdn, "DC=ForestDnsZones", dnsforest)

        # Add DNS records for a DC in forest
        if autofill:
            add_dc_msdcs_records(samdb, forestdn, "DC=ForestDnsZones", site,
                                 dnsforest, hostname, hostip, hostip6,
                                 domainguid, ntdsguid)


def setup_ad_dns(samdb, secretsdb, names, paths, lp, logger,
        dns_backend, os_level, dnspass=None, hostip=None, hostip6=None,
        targetdir=None, fill_level=FILL_FULL):
    """Provision DNS information (assuming GC role)

    :param samdb: LDB object connected to sam.ldb file
    :param secretsdb: LDB object connected to secrets.ldb file
    :param names: Names shortcut
    :param paths: Paths shortcut
    :param lp: Loadparm object
    :param logger: Logger object
    :param dns_backend: Type of DNS backend
    :param os_level: Functional level (treated as os level)
    :param dnspass: Password for bind's DNS account
    :param hostip: IPv4 address
    :param hostip6: IPv6 address
    :param targetdir: Target directory for creating DNS-related files for BIND9
    """

    if not is_valid_dns_backend(dns_backend):
        raise Exception("Invalid dns backend: %r" % dns_backend)

    if not is_valid_os_level(os_level):
        raise Exception("Invalid os level: %r" % os_level)

    if dns_backend == "NONE":
        logger.info("No DNS backend set, not configuring DNS")
        return

    # Add dns accounts (DnsAdmins, DnsUpdateProxy) in domain
    logger.info("Adding DNS accounts")
    add_dns_accounts(samdb, names.domaindn)

    # If dns_backend is BIND9_FLATFILE
    #   Populate only CN=MicrosoftDNS,CN=System,<DOMAINDN>
    #
    # If dns_backend is SAMBA_INTERNAL or BIND9_DLZ
    #   Populate DNS partitions

    # If os_level < 2003 (DS_DOMAIN_FUNCTION_2000)
    #   All dns records are in CN=MicrosoftDNS,CN=System,<DOMAINDN>
    #
    # If os_level >= 2003 (DS_DOMAIN_FUNCTION_2003, DS_DOMAIN_FUNCTION_2008,
    #                        DS_DOMAIN_FUNCTION_2008_R2)
    #   Root server records are in CN=MicrosoftDNS,CN=System,<DOMAINDN>
    #   Domain records are in CN=MicrosoftDNS,CN=System,<DOMAINDN>
    #   Domain records are in CN=MicrosoftDNS,DC=DomainDnsZones,<DOMAINDN>
    #   Forest records are in CN=MicrosoftDNS,DC=ForestDnsZones,<FORESTDN>
    domaindn = names.domaindn
    forestdn = samdb.get_root_basedn().get_linearized()

    dnsdomain = names.dnsdomain.lower()
    dnsforest = dnsdomain

    site = names.sitename

    hostname = names.netbiosname.lower()

    dnsadmins_sid = get_dnsadmins_sid(samdb, domaindn)
    domainguid = get_domainguid(samdb, domaindn)

    samdb.transaction_start()
    try:
        # Create CN=System
        logger.info("Creating CN=MicrosoftDNS,CN=System,%s" % domaindn)
        create_dns_legacy(samdb, names.domainsid, domaindn, dnsadmins_sid)

        if os_level == DS_DOMAIN_FUNCTION_2000:
            # Populating legacy dns
            logger.info("Populating CN=MicrosoftDNS,CN=System,%s" % domaindn)
            fill_dns_data_legacy(samdb, names.domainsid, domaindn, dnsdomain, site,
                                 hostname, hostip, hostip6, dnsadmins_sid)

        elif dns_backend in ("SAMBA_INTERNAL", "BIND9_DLZ") and \
                os_level >= DS_DOMAIN_FUNCTION_2003:

            # Create DNS partitions
            logger.info("Creating DomainDnsZones and ForestDnsZones partitions")
            create_dns_partitions(samdb, names.domainsid, names, domaindn, forestdn,
                                  dnsadmins_sid, fill_level)

            # Populating dns partitions
            logger.info("Populating DomainDnsZones and ForestDnsZones partitions")
            fill_dns_data_partitions(samdb, names.domainsid, site, domaindn, forestdn,
                                     dnsdomain, dnsforest, hostname, hostip, hostip6,
                                     domainguid, names.ntdsguid, dnsadmins_sid,
                                     fill_level=fill_level)

    except:
        samdb.transaction_cancel()
        raise
    else:
        samdb.transaction_commit()

    if dns_backend.startswith("BIND9_"):
        setup_bind9_dns(samdb, secretsdb, names, paths, lp, logger,
                        dns_backend, os_level, site=site, dnspass=dnspass, hostip=hostip,
                        hostip6=hostip6, targetdir=targetdir)


def setup_bind9_dns(samdb, secretsdb, names, paths, lp, logger,
        dns_backend, os_level, site=None, dnspass=None, hostip=None,
        hostip6=None, targetdir=None, key_version_number=None):
    """Provision DNS information (assuming BIND9 backend in DC role)

    :param samdb: LDB object connected to sam.ldb file
    :param secretsdb: LDB object connected to secrets.ldb file
    :param names: Names shortcut
    :param paths: Paths shortcut
    :param lp: Loadparm object
    :param logger: Logger object
    :param dns_backend: Type of DNS backend
    :param os_level: Functional level (treated as os level)
    :param site: Site to create hostnames in
    :param dnspass: Password for bind's DNS account
    :param hostip: IPv4 address
    :param hostip6: IPv6 address
    :param targetdir: Target directory for creating DNS-related files for BIND9
    """

    if (not is_valid_dns_backend(dns_backend) or
        not dns_backend.startswith("BIND9_")):
        raise Exception("Invalid dns backend: %r" % dns_backend)

    if not is_valid_os_level(os_level):
        raise Exception("Invalid os level: %r" % os_level)

    domaindn = names.domaindn

    domainguid = get_domainguid(samdb, domaindn)

    secretsdb_setup_dns(secretsdb, names,
                        paths.private_dir, realm=names.realm,
                        dnsdomain=names.dnsdomain,
                        dns_keytab_path=paths.dns_keytab, dnspass=dnspass,
                        key_version_number=key_version_number)

    dns_keytab_path = os.path.join(paths.private_dir, paths.dns_keytab)
    if os.path.isfile(dns_keytab_path) and paths.bind_gid is not None:
        try:
            os.chmod(dns_keytab_path, 0640)
            os.chown(dns_keytab_path, -1, paths.bind_gid)
        except OSError:
            if not os.environ.has_key('SAMBA_SELFTEST'):
                logger.info("Failed to chown %s to bind gid %u",
                            dns_keytab_path, paths.bind_gid)

    create_dns_dir(logger, paths)

    if dns_backend == "BIND9_FLATFILE":
        create_zone_file(lp, logger, paths, targetdir, site=site,
                         dnsdomain=names.dnsdomain, hostip=hostip,
                         hostip6=hostip6, hostname=names.hostname,
                         realm=names.realm, domainguid=domainguid,
                         ntdsguid=names.ntdsguid)

    if dns_backend == "BIND9_DLZ" and os_level >= DS_DOMAIN_FUNCTION_2003:
        create_samdb_copy(samdb, logger, paths, names, names.domainsid, domainguid)

    create_named_conf(paths, realm=names.realm,
                      dnsdomain=names.dnsdomain, dns_backend=dns_backend,
                      logger=logger)

    create_named_txt(paths.namedtxt,
                     realm=names.realm, dnsdomain=names.dnsdomain,
                     dnsname = "%s.%s" % (names.hostname, names.dnsdomain),
                     private_dir=paths.private_dir,
                     keytab_name=paths.dns_keytab)
    logger.info("See %s for an example configuration include file for BIND",
                paths.namedconf)
    logger.info("and %s for further documentation required for secure DNS "
                "updates", paths.namedtxt)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ELF          (      4   D    4    (                  0  0           =  = =              =  = = X  X                    $   $         Qtd                          Rtd=  = = X  X                 GNU qko*~	zK   8           @  AD 8   <   A    4BEr|PWqX3vT<&=Yy                    X       	     =       L           "                               ~                                                                    P             9                                        x                          _                                                                               x                                                                                 W                                       o                           .             l                          =             *                                       [                                                                    2               i             z             :             H                                       R                          h               C         C         %  H      C         @        C         C       H  \A      b  X       	   C          @(           pB        C        __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _Py_NoneStruct reg_open_local pytalloc_steal PyImport_ImportModule PyObject_GetAttrString win_errstr _Py_BuildValue_SizeT PyErr_SetObject PyRegistry _pytalloc_get_ptr _PyArg_ParseTuple_SizeT PyList_Size _talloc_array PyList_GetItem PyString_AsString reg_mount_hive PyErr_SetString smb_panic dbghdrclass dbgtext PyExc_TypeError DEBUGLEVEL_CLASS reg_diff_apply reg_get_predefined_key PyRegistryKey reg_key_del_abs reg_get_predefined_key_by_name hive_key_set_value hive_key_del_value hive_key_flush hive_key_del str_regtype PyString_FromString _PyArg_ParseTupleAndKeywords_SizeT talloc_named_const lpcfg_from_py_object _pytalloc_get_type samba_tevent_context_init reg_open_hive _talloc_free cli_credentials_init_anon PyErr_NoMemory PyHiveKey s4_event_context_init reg_open_ldb_file reg_open_samba reg_get_predef_name initregistry pytalloc_BaseObject_PyType_Ready Py_InitModule4 PyInt_FromLong PyModule_AddObject libregistry.so.0 libsamba-python.so.0 libsamba-util.so.0 libutil-reg.so.0 libsamba-debug.so.0 libsamba-credentials.so.0 libsamba-errors.so.1 libevents.so.0 libpython2.7.so.1.0 libpytalloc-util.so.2 libtalloc.so.2 libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/registry.so /usr/lib/arm-linux-gnueabihf/samba SAMBA_4.5.16_DEBIAN TALLOC_2.0.2 SAMBA_CREDENTIALS_0.0.1 PYTALLOC_UTIL_2.1.6 PYTALLOC_UTIL_2.0.6 SAMBA_UTIL_0.0.1 SAMBA_ERRORS_1 GLIBC_2.4                                  	    
   
                           
                                         J        5            J                 "   ^        Z         v  	 k                    J             0   Y  
      Y           "         T           t                    F            J                    J                 ii         =    =     @    @    @    @    @    @    @     @    $@    ,@    0@    8@    <@    D@    H@    L@    T@    X@    \@    d@    h@    l@    t@    x@    |@    @    @    hA    A    A     B    $B    ,B    0B    4B    <B    @B    DB    LB    PB    TB    \B    |B    B    C    4C    8C    @C    DC    HC    PC    TC    XC    `C    dC    hC    pC    tC    xC    C    ?   ?   ?   ? <  ?   ? C  ?   ?    ? ?  ? )  ? .  ?   ?    ?   $?   (? 	  ,? 
  0?   4?   8?   <?   @?   D?   H?   L?   P?   T?   X?   \?   `?   d?   h?   l?   p?   t?   x?   |?   ? !  ? "  ? #  ? $  ? %  ? &  ? '  ? (  ? *  ? +  ? ,  ? -  ? /  ? 0  ? 1  ? 2  ? 3  ? 4  ? 5  ? 6  ? 7  @-  --      x p h ` X P H @ 8 0 (                        x p h ` X P H @ 8 0 (0 0   R/P+    404 0  0 0C S 00/ 0  S/// / +    88    A,0A0/ 0  S//h/ d/ *    L0L 0  0  S/80@-0  S  
(0 30 0  / *    X+ . 8 80    0  R     0  S
@-3/@(  *    0 00      /)    0@-M  p   @P  d0 $0P   :H P   ,   V    0)          C-M@1p   0 p    P+  
 0T0d(  
 P `  
x1 @0   6 `P@   3@    T  Y+  
 0  	  @P   0 0 0 P
00       P          00 0 0  S  t   l0l 0 		   P
P0PP 0    )    L  (     l  0  ,                 8  0@-M@  P @@  P
  
  PP  l00      0P   |H@ @ C  ,     D  `  &          0@-M@_  P b@@  P	  
   < PP  d0 30P   IH @   ,   e    D  %           0@-M@,  P /@@  P
  
 a PP  l00      0P   H @   ,   1      (%    0  ,    0@-M@  P @@  P	  
    PP  d0 0P   H @   ,         X$    d  `  L  0@-$M 0@0000 0 0 P @@  P  
0   S   
     P  U  00      $0   PP   H] @ `  ,     a    p#    @  <  (  0@-M@|  P @@  P  
    PP  l00      0P   dH( @ +  ,     ,    h"    l  h  T  p@-Ip00 @P  d 0      pL   =D P   (   Y    p!    
  
  
  0@-M@!  P $@@  P  
    PP  l00      0P   	H @   ,   %    
        
  	  	   ,-M   P  
 
  A-P@8M $`` 00 0!00 0 $0  QP  P,  
!    @P>  
 pPI  
`1 0 P  
P `  V2  
     0p    `   V	  0  8   `   U @ X       Y  S 00  Tt } T0\0  HL q  ! 
   	     4
  H
               `	  d	       A-p 8Ma$A`  0 P000!000 0 $0 PPPA  P*  
!   R @P<  
 pPG  
  P  
P P  U2  
  ^   0p   [ P   U	  0  8   P    @           00  t  T0\0  L                                 |  1A-0(0 0M$0Q         !  P  P(  
x!    pP:  
 PE  
P!    P  
@ `  V.  
 @`0  @  `  V	  0 g0  l `   y= P @       A ; 00  <t e T0\0  0L Y  @ `  H       h                   p  (   \@-M =H@@  P  
   P  
 00        `    A-MA1@P C  Pp  1` =  Pj  1p 7  Pd  1 0  0   @PW  
x   `   
H   
0                      00  0  00  0  0t0   0A               x  h  `  X  P  @  <  4  P  (  `  $       @-py_mount_hive   samba   WERRORError (i,s)   OI|O    Expected list of elements   const char *    ../source4/lib/registry/pyregistry.c:127    ctx != NULL ../source4/lib/registry/pyregistry.c    PANIC: assert failed at %s(%d): %s
 assert failed: ctx != NULL  I   siz#    i   s|OOO   talloc_new: ../source4/lib/registry/pyregistry.c:268    Expected loadparm context   ../source4/lib/registry/pyregistry.c:277    struct cli_credentials  Expected credentials    ../source4/lib/registry/pyregistry.c:284    ../source4/lib/registry/pyregistry.c:292    talloc_new: ../source4/lib/registry/pyregistry.c:378    ../source4/lib/registry/pyregistry.c:387    ../source4/lib/registry/pyregistry.c:394    ../source4/lib/registry/pyregistry.c:402    |OOO    talloc_new: ../source4/lib/registry/pyregistry.c:327    ../source4/lib/registry/pyregistry.c:336    ../source4/lib/registry/pyregistry.c:343    ../source4/lib/registry/pyregistry.c:351    Registry    registry    HKEY_CLASSES_ROOT   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE  HKEY_USERS  HKEY_PERFORMANCE_DATA   HKEY_CURRENT_CONFIG HKEY_DYN_DATA   HKEY_PERFORMANCE_TEXT   HKEY_PERFORMANCE_NLSTEXT    HiveKey RegistryKey lp_ctx  session_info    location    credentials open_samba  open_samba() -> reg open_ldb    open_ldb(location, session_info=None, credentials=None, loadparm_context=None) -> key   open_hive   open_hive(location, session_info=None, credentials=None, loadparm_context=None) -> key  str_regtype str_regtype(int) -> str get_predef_name get_predef_name(hkey) -> str    del S.del(name) -> None
Delete a subkey flush   S.flush() -> None
Flush this key to disk    del_value   S.del_value(name) -> None
Delete a value    set_value   S.set_value(name, type, data) -> None
Set a value   get_predefined_key_by_name  S.get_predefined_key_by_name(name) -> key
Find a predefined key by name key_del_abs S.key_del_abs(name) -> None
Delete a key by absolute path.  get_predefined_key  S.get_predefined_key(hkey_id) -> key
Find a predefined key by id    diff_apply  S.diff_apply(filename) -> None
Apply the diff from the specified file   mount_hive  S.mount_hive(key, key_id, elements=None) -> None
Mount the specified key at the specified path.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           l                   "     5     F     Z     t                                   '     X     @(     =          =       o          x  
              ?    x                     H               o   o(  o   o  o>                                           =         d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d                                               @ ,  ,  ,  ,      ,  ,  ,  ,      ,  ,      ,  l#     -  -  $!     (-  -       -  -       -  .  %     .                              ,                                                                                                                                                                                               ,                                                                                                    B                                                                            8.       <.  `.  D     h.  .  p     .  .  L     .                              +                                                                                                   4C                                     L                                      /       (/  p/       |/  /       /  0       0  d0       p0                  A,   aeabi "   6 	
"8a71bd6bfc6fdd2aca7ee209eed57a1c4b05c1.debug    ]t4 .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       `                (         x  x  P              0                              8   o                       E   o   (  (  p               T   	          H               ]   	   B       x              f         X  X                    a         d  d  H                l                              r         @(  @(                    x         H(  H(                            0  0                             = =                            = =                            = =                             = =  X                        ? ?                             @  @                            C C                         p        C  -                                C  4                                C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Unix SMB/CIFS implementation.
# Copyright Matthieu Patou <mat@matws.net> 2011
# Copyright Andrew Bartlett <abartlet@samba.org> 2008-2015
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import uuid
import ldb
from ldb import LdbError
from samba.ndr import ndr_unpack
from samba.dcerpc import misc, dnsp
from samba.dcerpc.dnsp import DNS_TYPE_NS, DNS_TYPE_A, DNS_TYPE_AAAA, \
    DNS_TYPE_CNAME, DNS_TYPE_SRV, DNS_TYPE_PTR

class DemoteException(Exception):
    """Base element for demote errors"""

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return "DemoteException: " + self.value


def remove_sysvol_references(samdb, logger, dc_name):
    # DNs under the Configuration DN:
    realm = samdb.domain_dns_name()
    for s in ("CN=Enterprise,CN=Microsoft System Volumes,CN=System",
              "CN=%s,CN=Microsoft System Volumes,CN=System" % realm):
        dn = ldb.Dn(samdb, s)

        # This is verbose, but it is the safe, escape-proof way
        # to add a base and add an arbitrary RDN.
        if dn.add_base(samdb.get_config_basedn()) == False:
            raise DemoteException("Failed constructing DN %s by adding base %s" \
                                  % (dn, samdb.get_config_basedn()))
        if dn.add_child("CN=X") == False:
            raise DemoteException("Failed constructing DN %s by adding child CN=X"\
                                      % (dn))
        dn.set_component(0, "CN", dc_name)
        try:
            logger.info("Removing Sysvol reference: %s" % dn)
            samdb.delete(dn)
        except ldb.LdbError as (enum, estr):
            if enum == ldb.ERR_NO_SUCH_OBJECT:
                pass
            else:
                raise

    # DNs under the Domain DN:
    for s in ("CN=Domain System Volumes (SYSVOL share),CN=File Replication Service,CN=System",
              "CN=Topology,CN=Domain System Volume,CN=DFSR-GlobalSettings,CN=System"):
        # This is verbose, but it is the safe, escape-proof way
        # to add a base and add an arbitrary RDN.
        dn = ldb.Dn(samdb, s)
        if dn.add_base(samdb.get_default_basedn()) == False:
            raise DemoteException("Failed constructing DN %s by adding base" % \
                                  (dn, samdb.get_default_basedn()))
        if dn.add_child("CN=X") == False:
            raise DemoteException("Failed constructing DN %s by adding child %s"\
                                  % (dn, rdn))
        dn.set_component(0, "CN", dc_name)

        try:
            logger.info("Removing Sysvol reference: %s" % dn)
            samdb.delete(dn)
        except ldb.LdbError as (enum, estr):
            if enum == ldb.ERR_NO_SUCH_OBJECT:
                pass
            else:
                raise


def remove_dns_references(samdb, logger, dnsHostName):

    # Check we are using in-database DNS
    zones = samdb.search(base="", scope=ldb.SCOPE_SUBTREE,
                         expression="(&(objectClass=dnsZone)(!(dc=RootDNSServers)))",
                         attrs=[],
                         controls=["search_options:0:2"])
    if len(zones) == 0:
        return

    dnsHostNameUpper = dnsHostName.upper()

    try:
        primary_recs = samdb.dns_lookup(dnsHostName)
    except RuntimeError as (enum, estr):
        if enum == 0x000025F2: #WERR_DNS_ERROR_NAME_DOES_NOT_EXIST
              return
        raise DemoteException("lookup of %s failed: %s" % (dnsHostName, estr))
    samdb.dns_replace(dnsHostName, [])

    res = samdb.search("",
                       scope=ldb.SCOPE_BASE, attrs=["namingContexts"])
    assert len(res) == 1
    ncs = res[0]["namingContexts"]

    # Work out the set of names we will likely have an A record on by
    # default.  This is by default all the partitions of type
    # domainDNS.  By finding the canocial name of all the partitions,
    # we find the likely candidates.  We only remove the record if it
    # maches the IP that was used by the dnsHostName.  This avoids us
    # needing to look a the dns_update_list file from in the demote
    # script.

    def dns_name_from_dn(dn):
        # The canonical string of DC=example,DC=com is
        # example.com/
        #
        # The canonical string of CN=Configuration,DC=example,DC=com
        # is example.com/Configuration
        return ldb.Dn(samdb, dn).canonical_str().split('/', 1)[0]

    # By using a set here, duplicates via (eg) example.com/Configuration
    # do not matter, they become just example.com
    a_names_to_remove_from \
        = set(dns_name_from_dn(dn) for dn in ncs)

    def a_rec_to_remove(dnsRecord):
        if dnsRecord.wType == DNS_TYPE_A or dnsRecord.wType == DNS_TYPE_AAAA:
            for rec in primary_recs:
                if rec.wType == dnsRecord.wType and rec.data == dnsRecord.data:
                    return True
        return False

    for a_name in a_names_to_remove_from:
        try:
            logger.debug("checking for DNS records to remove on %s" % a_name)
            a_recs = samdb.dns_lookup(a_name)
        except RuntimeError as (enum, estr):
            if enum == 0x000025F2: #WERR_DNS_ERROR_NAME_DOES_NOT_EXIST
                return
            raise DemoteException("lookup of %s failed: %s" % (a_name, estr))

        orig_num_recs = len(a_recs)
        a_recs = [ r for r in a_recs if not a_rec_to_remove(r) ]

        if len(a_recs) != orig_num_recs:
            logger.info("updating %s keeping %d values, removing %s values" % \
                (a_name, len(a_recs), orig_num_recs - len(a_recs)))
            samdb.dns_replace(a_name, a_recs)

    # Find all the CNAME, NS, PTR and SRV records that point at the
    # name we are removing

    def to_remove(value):
        dnsRecord = ndr_unpack(dnsp.DnssrvRpcRecord, value)
        if dnsRecord.wType == DNS_TYPE_NS \
           or dnsRecord.wType == DNS_TYPE_CNAME \
           or dnsRecord.wType == DNS_TYPE_PTR:
            if dnsRecord.data.upper() == dnsHostNameUpper:
                return True
        elif dnsRecord.wType == DNS_TYPE_SRV:
            if dnsRecord.data.nameTarget.upper() == dnsHostNameUpper:
                return True
        return False

    for zone in zones:
        logger.debug("checking %s" % zone.dn)
        records = samdb.search(base=zone.dn, scope=ldb.SCOPE_SUBTREE,
                               expression="(&(objectClass=dnsNode)"
                               "(!(dNSTombstoned=TRUE)))",
                               attrs=["dnsRecord"])
        for record in records:
            try:
                orig_values = record["dnsRecord"]
            except KeyError:
                continue

            # Remove references to dnsHostName in A, AAAA, NS, CNAME and SRV
            values = [ ndr_unpack(dnsp.DnssrvRpcRecord, v)
                       for v in orig_values if not to_remove(v) ]

            if len(values) != len(orig_values):
                logger.info("updating %s keeping %d values, removing %s values" \
                            % (record.dn, len(values),
                               len(orig_values) - len(values)))

                # This requires the values to be unpacked, so this
                # has been done in the list comprehension above
                samdb.dns_replace_by_dn(record.dn, values)

def offline_remove_server(samdb, logger,
                          server_dn,
                          remove_computer_obj=False,
                          remove_server_obj=False,
                          remove_sysvol_obj=False,
                          remove_dns_names=False,
                          remove_dns_account=False):
    res = samdb.search("",
                       scope=ldb.SCOPE_BASE, attrs=["dsServiceName"])
    assert len(res) == 1
    my_serviceName = res[0]["dsServiceName"][0]

    # Confirm this is really a server object
    msgs = samdb.search(base=server_dn,
                        attrs=["serverReference", "cn",
                               "dnsHostName"],
                        scope=ldb.SCOPE_BASE,
                        expression="(objectClass=server)")
    msg = msgs[0]
    dc_name = str(msgs[0]["cn"][0])

    try:
        computer_dn = ldb.Dn(samdb, msgs[0]["serverReference"][0])
    except KeyError:
        computer_dn = None

    try:
        dnsHostName = msgs[0]["dnsHostName"][0]
    except KeyError:
        dnsHostName = None

    if remove_server_obj:
        # Remove the server DN
        samdb.delete(server_dn)

    if computer_dn is not None:
        computer_msgs = samdb.search(base=computer_dn,
                                     expression="objectclass=computer",
                                     attrs=["msDS-KrbTgtLink",
                                            "rIDSetReferences",
                                            "cn"],
                                     scope=ldb.SCOPE_BASE)
        if "rIDSetReferences" in computer_msgs[0]:
            rid_set_dn = str(computer_msgs[0]["rIDSetReferences"][0])
            logger.info("Removing RID Set: %s" % rid_set_dn)
            samdb.delete(rid_set_dn)
        if "msDS-KrbTgtLink" in computer_msgs[0]:
            krbtgt_link_dn = str(computer_msgs[0]["msDS-KrbTgtLink"][0])
            logger.info("Removing RODC KDC account: %s" % krbtgt_link_dn)
            samdb.delete(krbtgt_link_dn)

        if remove_computer_obj:
            # Delete the computer tree
            logger.info("Removing computer account: %s (and any child objects)" % computer_dn)
            samdb.delete(computer_dn, ["tree_delete:0"])

        if "dnsHostName" in msgs[0]:
            dnsHostName = msgs[0]["dnsHostName"][0]

    if remove_dns_account:
        res = samdb.search(expression="(&(objectclass=user)(cn=dns-%s)(servicePrincipalName=DNS/%s))" %
                           (ldb.binary_encode(dc_name), dnsHostName),
                           attrs=[], scope=ldb.SCOPE_SUBTREE,
                           base=samdb.get_default_basedn())
        if len(res) == 1:
            logger.info("Removing Samba-specific DNS service account: %s" % res[0].dn)
            samdb.delete(res[0].dn)

    if dnsHostName is not None and remove_dns_names:
        remove_dns_references(samdb, logger, dnsHostName)

    if remove_sysvol_obj:
        remove_sysvol_references(samdb, logger, dc_name)

def offline_remove_ntds_dc(samdb,
                           logger,
                           ntds_dn,
                           remove_computer_obj=False,
                           remove_server_obj=False,
                           remove_connection_obj=False,
                           seize_stale_fsmo=False,
                           remove_sysvol_obj=False,
                           remove_dns_names=False,
                           remove_dns_account=False):
    res = samdb.search("",
                       scope=ldb.SCOPE_BASE, attrs=["dsServiceName"])
    assert len(res) == 1
    my_serviceName = ldb.Dn(samdb, res[0]["dsServiceName"][0])
    server_dn = ntds_dn.parent()

    if my_serviceName == ntds_dn:
        raise DemoteException("Refusing to demote our own DSA: %s " % my_serviceName)

    try:
        msgs = samdb.search(base=ntds_dn, expression="objectClass=ntdsDSA",
                        attrs=["objectGUID"], scope=ldb.SCOPE_BASE)
    except LdbError as (enum, estr):
        if enum == ldb.ERR_NO_SUCH_OBJECT:
              raise DemoteException("Given DN %s doesn't exist" % ntds_dn)
        else:
            raise
    if (len(msgs) == 0):
        raise DemoteException("%s is not an ntdsda in %s"
                              % (ntds_dn, samdb.domain_dns_name()))

    msg = msgs[0]
    if (msg.dn.get_rdn_name() != "CN" or
        msg.dn.get_rdn_value() != "NTDS Settings"):
        raise DemoteException("Given DN (%s) wasn't the NTDS Settings DN" %
                              ntds_dn)

    ntds_guid = ndr_unpack(misc.GUID, msg["objectGUID"][0])

    if remove_connection_obj:
        # Find any nTDSConnection objects with that DC as the fromServer.
        # We use the GUID to avoid issues with any () chars in a server
        # name.
        stale_connections = samdb.search(base=samdb.get_config_basedn(),
                                         expression="(&(objectclass=nTDSConnection)"
                                         "(fromServer=<GUID=%s>))" % ntds_guid)
        for conn in stale_connections:
            logger.info("Removing nTDSConnection: %s" % conn.dn)
            samdb.delete(conn.dn)

    if seize_stale_fsmo:
        stale_fsmo_roles = samdb.search(base="", scope=ldb.SCOPE_SUBTREE,
                                        expression="(fsmoRoleOwner=<GUID=%s>))"
                                        % ntds_guid,
                                        controls=["search_options:0:2"])
        # Find any FSMO roles they have, give them to this server

        for role in stale_fsmo_roles:
            val = str(my_serviceName)
            m = ldb.Message()
            m.dn = role.dn
            m['value'] = ldb.MessageElement(val, ldb.FLAG_MOD_REPLACE,
                                            'fsmoRoleOwner')
            logger.warning("Seizing FSMO role on: %s (now owned by %s)"
                           % (role.dn, my_serviceName))
            samdb.modify(m)

    # Remove the NTDS setting tree
    try:
        logger.info("Removing nTDSDSA: %s (and any children)" % ntds_dn)
        samdb.delete(ntds_dn, ["tree_delete:0"])
    except LdbError as (enum, estr):
        raise DemoteException("Failed to remove the DCs NTDS DSA object: %s"
                              % estr)

    offline_remove_server(samdb, logger, server_dn,
                          remove_computer_obj=remove_computer_obj,
                          remove_server_obj=remove_server_obj,
                          remove_sysvol_obj=remove_sysvol_obj,
                          remove_dns_names=remove_dns_names,
                          remove_dns_account=remove_dns_account)


def remove_dc(samdb, logger, dc_name):

    # TODO: Check if this is the last server (covered mostly by
    # refusing to remove our own name)

    samdb.transaction_start()

    server_dn = None

    # Allow the name to be a the nTDS-DSA GUID
    try:
        ntds_guid = uuid.UUID(hex=dc_name)
        ntds_dn = "<GUID=%s>" % ntds_guid
    except ValueError:
        try:
            server_msgs = samdb.search(base=samdb.get_config_basedn(),
                                       attrs=[],
                                       expression="(&(objectClass=server)"
                                       "(cn=%s))"
                                    % ldb.binary_encode(dc_name))
        except LdbError as (enum, estr):
            raise DemoteException("Failure checking if %s is an server "
                                  "object in %s: "
                                  % (dc_name, samdb.domain_dns_name()), estr)

        if (len(server_msgs) == 0):
            raise DemoteException("%s is not an AD DC in %s"
                                  % (dc_name, samdb.domain_dns_name()))
        server_dn = server_msgs[0].dn

        ntds_dn = ldb.Dn(samdb, "CN=NTDS Settings")
        ntds_dn.add_base(server_dn)
        pass

    # Confirm this is really an ntdsDSA object
    try:
        ntds_msgs = samdb.search(base=ntds_dn, attrs=[], scope=ldb.SCOPE_BASE,
                                 expression="(objectClass=ntdsdsa)")
    except LdbError as (enum, estr):
        if enum == ldb.ERR_NO_SUCH_OBJECT:
            ntds_msgs = []
            pass
        else:
            raise DemoteException("Failure checking if %s is an NTDS DSA in %s: "
                                  % (ntds_dn, samdb.domain_dns_name()), estr)

    # If the NTDS Settings child DN wasn't found or wasnt an ntdsDSA
    # object, just remove the server object located above
    if (len(ntds_msgs) == 0):
        if server_dn is None:
            raise DemoteException("%s is not an AD DC in %s"
                                  % (dc_name, samdb.domain_dns_name()))

        offline_remove_server(samdb, logger,
                              server_dn,
                              remove_computer_obj=True,
                              remove_server_obj=True,
                              remove_sysvol_obj=True,
                              remove_dns_names=True,
                              remove_dns_account=True)
    else:
        offline_remove_ntds_dc(samdb, logger,
                               ntds_msgs[0].dn,
                               remove_computer_obj=True,
                               remove_server_obj=True,
                               remove_connection_obj=True,
                               seize_stale_fsmo=True,
                               remove_sysvol_obj=True,
                               remove_dns_names=True,
                               remove_dns_account=True)

    samdb.transaction_commit()



def offline_remove_dc_RemoveDsServer(samdb, ntds_dn):

    samdb.start_transaction()

    offline_remove_ntds_dc(samdb, ntds_dn, None)

    samdb.commit_transaction()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Support for reading Samba 3 data files."""

__docformat__ = "restructuredText"

REGISTRY_VALUE_PREFIX = "SAMBA_REGVAL"
REGISTRY_DB_VERSION = 1

import os
import struct
import tdb

import passdb
import param as s3param


def fetch_uint32(db, key):
    try:
        data = db[key]
    except KeyError:
        return None
    assert len(data) == 4
    return struct.unpack("<L", data)[0]


def fetch_int32(db, key):
    try:
        data = db[key]
    except KeyError:
        return None
    assert len(data) == 4
    return struct.unpack("<l", data)[0]


class DbDatabase(object):
    """Simple Samba 3 TDB database reader."""
    def __init__(self, file):
        """Open a file.

        :param file: Path of the file to open, appending .tdb or .ntdb.
        """
        self.db = tdb.Tdb(file + ".tdb", flags=os.O_RDONLY)
        self._check_version()

    def _check_version(self):
        pass

    def close(self):
        """Close resources associated with this object."""
        self.db.close()


class Registry(DbDatabase):
    """Simple read-only support for reading the Samba3 registry.

    :note: This object uses the same syntax for registry key paths as
        Samba 3. This particular format uses forward slashes for key path
        separators and abbreviations for the predefined key names.
        e.g.: HKLM/Software/Bar.
    """
    def __len__(self):
        """Return the number of keys."""
        return len(self.keys())

    def keys(self):
        """Return list with all the keys."""
        return [k.rstrip("\x00") for k in self.db.iterkeys() if not k.startswith(REGISTRY_VALUE_PREFIX)]

    def subkeys(self, key):
        """Retrieve the subkeys for the specified key.

        :param key: Key path.
        :return: list with key names
        """
        data = self.db.get("%s\x00" % key)
        if data is None:
            return []
        (num, ) = struct.unpack("<L", data[0:4])
        keys = data[4:].split("\0")
        assert keys[-1] == ""
        keys.pop()
        assert len(keys) == num
        return keys

    def values(self, key):
        """Return a dictionary with the values set for a specific key.

        :param key: Key to retrieve values for.
        :return: Dictionary with value names as key, tuple with type and
            data as value."""
        data = self.db.get("%s/%s\x00" % (REGISTRY_VALUE_PREFIX, key))
        if data is None:
            return {}
        ret = {}
        (num, ) = struct.unpack("<L", data[0:4])
        data = data[4:]
        for i in range(num):
            # Value name
            (name, data) = data.split("\0", 1)

            (type, ) = struct.unpack("<L", data[0:4])
            data = data[4:]
            (value_len, ) = struct.unpack("<L", data[0:4])
            data = data[4:]

            ret[name] = (type, data[:value_len])
            data = data[value_len:]

        return ret


# High water mark keys
IDMAP_HWM_GROUP = "GROUP HWM\0"
IDMAP_HWM_USER = "USER HWM\0"

IDMAP_GROUP_PREFIX = "GID "
IDMAP_USER_PREFIX = "UID "

# idmap version determines auto-conversion
IDMAP_VERSION_V2 = 2

class IdmapDatabase(DbDatabase):
    """Samba 3 ID map database reader."""

    def _check_version(self):
        assert fetch_int32(self.db, "IDMAP_VERSION\0") == IDMAP_VERSION_V2

    def ids(self):
        """Retrieve a list of all ids in this database."""
        for k in self.db.iterkeys():
            if k.startswith(IDMAP_USER_PREFIX):
                yield k.rstrip("\0").split(" ")
            if k.startswith(IDMAP_GROUP_PREFIX):
                yield k.rstrip("\0").split(" ")

    def uids(self):
        """Retrieve a list of all uids in this database."""
        for k in self.db.iterkeys():
            if k.startswith(IDMAP_USER_PREFIX):
                yield int(k[len(IDMAP_USER_PREFIX):].rstrip("\0"))

    def gids(self):
        """Retrieve a list of all gids in this database."""
        for k in self.db.iterkeys():
            if k.startswith(IDMAP_GROUP_PREFIX):
                yield int(k[len(IDMAP_GROUP_PREFIX):].rstrip("\0"))

    def get_sid(self, xid, id_type):
        """Retrive SID associated with a particular id and type.

        :param xid: UID or GID to retrive SID for.
        :param id_type: Type of id specified - 'UID' or 'GID'
        """
        data = self.db.get("%s %s\0" % (id_type, str(xid)))
        if data is None:
            return data
        return data.rstrip("\0")

    def get_user_sid(self, uid):
        """Retrieve the SID associated with a particular uid.

        :param uid: UID to retrieve SID for.
        :return: A SID or None if no mapping was found.
        """
        data = self.db.get("%s%d\0" % (IDMAP_USER_PREFIX, uid))
        if data is None:
            return data
        return data.rstrip("\0")

    def get_group_sid(self, gid):
        data = self.db.get("%s%d\0" % (IDMAP_GROUP_PREFIX, gid))
        if data is None:
            return data
        return data.rstrip("\0")

    def get_user_hwm(self):
        """Obtain the user high-water mark."""
        return fetch_uint32(self.db, IDMAP_HWM_USER)

    def get_group_hwm(self):
        """Obtain the group high-water mark."""
        return fetch_uint32(self.db, IDMAP_HWM_GROUP)


class SecretsDatabase(DbDatabase):
    """Samba 3 Secrets database reader."""

    def get_auth_password(self):
        return self.db.get("SECRETS/AUTH_PASSWORD")

    def get_auth_domain(self):
        return self.db.get("SECRETS/AUTH_DOMAIN")

    def get_auth_user(self):
        return self.db.get("SECRETS/AUTH_USER")

    def get_domain_guid(self, host):
        return self.db.get("SECRETS/DOMGUID/%s" % host)

    def ldap_dns(self):
        for k in self.db.iterkeys():
            if k.startswith("SECRETS/LDAP_BIND_PW/"):
                yield k[len("SECRETS/LDAP_BIND_PW/"):].rstrip("\0")

    def domains(self):
        """Iterate over domains in this database.

        :return: Iterator over the names of domains in this database.
        """
        for k in self.db.iterkeys():
            if k.startswith("SECRETS/SID/"):
                yield k[len("SECRETS/SID/"):].rstrip("\0")

    def get_ldap_bind_pw(self, host):
        return self.db.get("SECRETS/LDAP_BIND_PW/%s" % host)

    def get_afs_keyfile(self, host):
        return self.db.get("SECRETS/AFS_KEYFILE/%s" % host)

    def get_machine_sec_channel_type(self, host):
        return fetch_uint32(self.db, "SECRETS/MACHINE_SEC_CHANNEL_TYPE/%s" % host)

    def get_machine_last_change_time(self, host):
        return fetch_uint32(self.db, "SECRETS/MACHINE_LAST_CHANGE_TIME/%s" % host)

    def get_machine_password(self, host):
        return self.db.get("SECRETS/MACHINE_PASSWORD/%s" % host)

    def get_machine_acc(self, host):
        return self.db.get("SECRETS/$MACHINE.ACC/%s" % host)

    def get_domtrust_acc(self, host):
        return self.db.get("SECRETS/$DOMTRUST.ACC/%s" % host)

    def trusted_domains(self):
        for k in self.db.iterkeys():
            if k.startswith("SECRETS/$DOMTRUST.ACC/"):
                yield k[len("SECRETS/$DOMTRUST.ACC/"):].rstrip("\0")

    def get_random_seed(self):
        return self.db.get("INFO/random_seed")

    def get_sid(self, host):
        return self.db.get("SECRETS/SID/%s" % host.upper())


SHARE_DATABASE_VERSION_V1 = 1
SHARE_DATABASE_VERSION_V2 = 2


class ShareInfoDatabase(DbDatabase):
    """Samba 3 Share Info database reader."""

    def _check_version(self):
        assert fetch_int32(self.db, "INFO/version\0") in (SHARE_DATABASE_VERSION_V1, SHARE_DATABASE_VERSION_V2)

    def get_secdesc(self, name):
        """Obtain the security descriptor on a particular share.

        :param name: Name of the share
        """
        secdesc = self.db.get("SECDESC/%s" % name)
        # FIXME: Run ndr_pull_security_descriptor
        return secdesc


class Shares(object):
    """Container for share objects."""
    def __init__(self, lp, shareinfo):
        self.lp = lp
        self.shareinfo = shareinfo

    def __len__(self):
        """Number of shares."""
        return len(self.lp) - 1

    def __iter__(self):
        """Iterate over the share names."""
        return self.lp.__iter__()


def shellsplit(text):
    """Very simple shell-like line splitting.

    :param text: Text to split.
    :return: List with parts of the line as strings.
    """
    ret = list()
    inquotes = False
    current = ""
    for c in text:
        if c == "\"":
            inquotes = not inquotes
        elif c in ("\t", "\n", " ") and not inquotes:
            if current != "":
                ret.append(current)
            current = ""
        else:
            current += c
    if current != "":
        ret.append(current)
    return ret


class WinsDatabase(object):
    """Samba 3 WINS database reader."""
    def __init__(self, file):
        self.entries = {}
        f = open(file, 'r')
        assert f.readline().rstrip("\n") == "VERSION 1 0"
        for l in f.readlines():
            if l[0] == "#": # skip comments
                continue
            entries = shellsplit(l.rstrip("\n"))
            name = entries[0]
            ttl = int(entries[1])
            i = 2
            ips = []
            while "." in entries[i]:
                ips.append(entries[i])
                i+=1
            nb_flags = int(entries[i][:-1], 16)
            assert not name in self.entries, "Name %s exists twice" % name
            self.entries[name] = (ttl, ips, nb_flags)
        f.close()

    def __getitem__(self, name):
        return self.entries[name]

    def __len__(self):
        return len(self.entries)

    def __iter__(self):
        return iter(self.entries)

    def items(self):
        """Return the entries in this WINS database."""
        return self.entries.items()

    def close(self): # for consistency
        pass


class Samba3(object):
    """Samba 3 configuration and state data reader."""

    def __init__(self, smbconfpath, s3_lp_ctx=None):
        """Open the configuration and data for a Samba 3 installation.

        :param smbconfpath: Path to the smb.conf file.
        :param s3_lp_ctx: Samba3 Loadparm context
        """
        self.smbconfpath = smbconfpath
        if s3_lp_ctx:
            self.lp = s3_lp_ctx
        else:
            self.lp = s3param.get_context()
            self.lp.load(smbconfpath)

    def statedir_path(self, path):
        if path[0] == "/" or path[0] == ".":
            return path
        return os.path.join(self.lp.get("state directory"), path)

    def privatedir_path(self, path):
        if path[0] == "/" or path[0] == ".":
            return path
        return os.path.join(self.lp.get("private dir"), path)

    def get_conf(self):
        return self.lp

    def get_sam_db(self):
        return passdb.PDB(self.lp.get('passdb backend'))

    def get_registry(self):
        return Registry(self.statedir_path("registry"))

    def get_secrets_db(self):
        return SecretsDatabase(self.privatedir_path("secrets"))

    def get_shareinfo_db(self):
        return ShareInfoDatabase(self.statedir_path("share_info"))

    def get_idmap_db(self):
        return IdmapDatabase(self.statedir_path("winbindd_idmap"))

    def get_wins_db(self):
        return WinsDatabase(self.statedir_path("wins.dat"))

    def get_shares(self):
        return Shares(self.get_conf(), self.get_shareinfo_db())
                                                                                                                                                                                      ELF          (    @)  4   v    4    (                  d  d           |l  |l |l 	  	           l  l l `  `                    $   $         Qtd                          Rtd|l  |l |l                    GNU >YX3t/O<              @  Q@           4|CEPX=WqX vT<XyGli                    #       	     l                    	
                          9
             y	             \             g             	                                       F                                         [                                         o                                         
                                       ]	                          )                          X             ;             ,             h             s                          E                            
                          	             3             
             S
             2               l                          	             
                          X                                                                                                                      9             
                                                     p                          )             6                          >                          !	                          	                          u                          m                          w             A	             v             q             	                           O	                          <             
             y                                                     K
             S             n
                                       `                                       L                                                    %             	             3	             +                                                                  
                          
             	             \                          I                          '
                          "                          
                          L           "   K             '                            u         u       w  u       R  Q         p        u       ~  u         #       	   p         R          u         u         8       __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses cli_credentials_init pytalloc_steal _PyArg_ParseTuple_SizeT _pytalloc_get_type cli_credentials_set_forced_sasl_mech _Py_NoneStruct cli_credentials_get_gensec_features PyInt_FromLong cli_credentials_set_gensec_features talloc_named_const lpcfg_from_py_object samba_tevent_context_init cli_credentials_get_named_ccache talloc_unlink _talloc_steal_loc _talloc_free pytalloc_reference_ex PyErr_SetString PyErr_NoMemory PyCredentialCacheContainer PyExc_RuntimeError cli_credentials_set_machine_account PyImport_ImportModule PyObject_GetAttrString get_friendly_nt_error_msg _Py_BuildValue_SizeT PyErr_SetObject cli_credentials_guess cli_credentials_set_krb_forwardable cli_credentials_set_kerberos_state cli_credentials_get_kerberos_state cli_credentials_get_nt_hash PyString_FromStringAndSize cli_credentials_parse_string cli_credentials_set_cmdline_callbacks PyBool_FromLong cli_credentials_wrong_password cli_credentials_authentication_requested cli_credentials_set_workstation cli_credentials_set_anonymous cli_credentials_is_anonymous cli_credentials_set_bind_dn cli_credentials_set_realm cli_credentials_set_domain cli_credentials_set_old_password PyString_AsStringAndSize cli_credentials_set_utf16_password data_blob_null cli_credentials_set_password cli_credentials_set_username cli_credentials_get_forced_sasl_mech PyString_FromString cli_credentials_get_workstation cli_credentials_get_bind_dn cli_credentials_get_realm cli_credentials_get_domain cli_credentials_get_old_password cli_credentials_get_password cli_credentials_get_username cli_credentials_set_old_utf16_password initcredentials pytalloc_BaseObject_PyType_Ready Py_InitModule4 PyModule_AddObject PyCredentials _PyArg_VaParseTupleAndKeywords_SizeT __errno_location write PyEval_SaveThread pthread_join PyEval_RestoreThread close __assert_fail pthread_mutex_init pthread_cond_init pthread_mutex_lock pthread_cond_wait pthread_mutex_unlock pthread_cond_destroy pthread_mutex_destroy cli_shutdown pthread_cond_signal _tevent_req_callback_data cli_smb_oplock_break_waiter_recv talloc_get_size _talloc_realloc_array cli_smb_oplock_break_waiter_send tevent_req_set_callback PyGILState_Ensure _tevent_loop_once PyGILState_Release PyErr_SetFromErrno __stack_chk_fail __stack_chk_guard cli_list_send cli_list_recv PyList_Append cli_nt_delete_on_close_send cli_nt_delete_on_close_recv cli_ftruncate_send cli_ftruncate_recv cli_read_andx_send cli_read_andx_recv cli_write_andx_send cli_write_andx_recv cli_close_send cli_close_recv cli_ntcreate_send cli_ntcreate_recv memmove tevent_context_init_byname samba_tevent_set_debug tevent_set_trace_callback _talloc_zero pipe _tevent_add_fd PyEval_InitThreads pthread_create _talloc_set_destructor cli_full_connection_send cli_full_connection_recv cli_credentials_init_anon PyErr_Format initlibsmb_samba_internal _talloc_stackframe libpthread.so.0 libcmdline-credentials.so.0 libsamba-util.so.0 libsamba-python.so.0 libsamba-credentials.so.0 liblibsmb.so.0 libsamba-errors.so.1 libpython2.7.so.1.0 libtalloc.so.2 libtevent.so.0 libpytalloc-util.so.2 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/samba3/libsmb_samba_internal.so /usr/lib/arm-linux-gnueabihf/samba SAMBA_4.5.16_DEBIAN GLIBC_2.4 SAMBA_ERRORS_1 SAMBA_UTIL_0.0.1 TEVENT_0.9.16 TEVENT_0.9.9 PYTALLOC_UTIL_2.1.6 PYTALLOC_UTIL_2.0.6 TALLOC_2.0.2 SAMBA_CREDENTIALS_0.0.1                                                             	            
                                  	               	                  
                      	                                                           c         ii                                        T  	 '        Y         ii           4     0   "
   8     )   F                 ii           C     0   Y  
 S     Y   g        %         "   {                 v                             |l    l     p    p    p    <q    dq    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q    q     r    r    r    r    r    r     r    (r    ,r    0r    8r    <r    @r    Hr    Lr    Pr    Xr    \r    `r    hr    lr    pr    |r    r    r    r    r    r    r    r    r    r    r    r    r    r    r    r    r    r    r    r    r     s    s    s    s     s    ,s    0s    <s    @s    Ls    Ps    \s    `s    ls    ps    |s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s    s     t    t    t    t    t    t    t     t    $t    8t    Dt    t    t    t    t    t    t    t     u    u    u    u    u    u     u    $u    ,u    0u    4u    <u    @u    Du    Lu    Pu    Tu    \u    `u    du    lu    o   o   o   o $  o +  o   o A  o F  o S  o ~  o   m   m   m    n   n   n   n 	  n 
  n   n   n    n   $n   (n   ,n   0n   4n   8n   <n   @n   Dn   Hn   Ln   Pn   Tn   Xn   \n   `n   dn    hn !  ln "  pn #  tn %  xn &  |n '  n (  n )  n *  n ,  n -  n .  n /  n 0  n 1  n 2  n 3  n 4  n 5  n 6  n 7  n 8  n 9  n :  n ;  n <  n =  n >  n ?  n @  n B  n C  n D  n E  n G  n H  n I  n J   o K  o L  o M  o N  o O  o P  o Q  o R   o T  $o U  (o V  ,o W  0o X  4o Y  8o Z  <o [  @o \  Do ]  Ho ^  Lo _  Po `  To a  Xo b  \o c  `o d  do e  ho f  lo g  po h  to i  xo j  |o k  o l  o m  o n  o o  o p  o q  o r  o s  o t  o u  o v  o w  o x  o y  o z  o {  o |  o }  o ~  o   o   @-m -LJ  L D < 4 , $                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $                  0 0   R/D   404 0  0 0C S 00/ 0  S//L L \D   88    A,0A0/ 0  S//K K D   L0L 0  0  S/80@-0  S  
(0 0 0  pK C   E 0K 8 80    0  R     0  S
@-3/@B hC   @- @  c  @"0@- P TM ZD@@  P  
8 K$00      0H8  B '    @-9@8'  0@- P TM 4D@@  P  
8 %$00      0(5  PB &    A-@XQX1PTM00@0     P*  
 !    @P6  
 `P 4  
   0    p   g  X      0  |00  Q    
d   L 8 A   &  &  p&  \&  p&      P&  %  %  (1(!0@-`MP@P$  p   P  
     @P'  
 `P&  
 M ` 1S  
 0 0 0   ]x* @   \       } 4 _ \@   $  %  %  %  %  %  %   %  0 0@-`MP@P$O  p P  P  
    ` @P  
V `P  
 jX - 0 0 0> (   ?   #  x$  $  $%  $  0@- P TM D@@  P  
8 $00      0$  = "    0@- P TM  D@@  P  
8 M$00      0\$  = "    @-@L!  @p@-  @  T P  
  p!  #  0@-M0 P `  # L@@  P  
@ P  $00      0#  <  !    @-Z@   @-|@   @-@   @-M0 @ D  #   P  
( @z  A"  <   0@-n 0  00         L;   @-]B@d  @- @ 8M X  P  
  KR@0    @-M0 @ D  # @  P  
( @2  B8!    @-M0 @ D  # &  P  
( @  $!    @-M0 @ D  #   P  
( @  5   L  A- `0M` P$ 0 p@  0  P  P  
   P  T0 0 9(0(0   d9   0         @-M0 @ D  #   P  
( @  1t    @-M0 @ D  #   P  
( @  b    0 00      /7   $@-{  P  
@@@  $@-o  P  
@@  $@-c  P  
@@  $@-W  P  
@@  $@-K  P  
@@  $@-?A  P  
@@P  $@-3W  P  
@@   $@-'H  P  
@@  @-M`0` P P0 p @   P  P  
    P
  P0 0(0(0   6     T    |  p@-MTAT1@P G  PL  <1` A  PF  (!(  $! 0    @P;  
  >     7    0     )    "       } 0t0  0 u 0X0   0p@kp<5        8  $  (             ,    @- 03/  P 0000000 /@-@   P  
d 0000h#  0--M 0}/p@-MP 0 @`0e  { 0 S     p
  ` | P   U     p  
 0 0  p  
 00  p0 0   U!  |"  "  A-  P @P  
 p  @P   u @P  H@ ` % @ a  T  H0  S
 N  P     P     P
d0dd 0K/0  L0LL 0H 0  8088 04 0  !  !  !     x!  !  )     T!  p!  &  @- @   P  
x 00   P  
\ 00   P  
@ 00   P  
 000 @0/0!  4!  8!  @- @  P  0H0   P     Pd0dd 0` 00  P0PP 0L 00  <0<< 08 00    (   D   E  l         C  H      >  p@-M P  @ `  U `  
 \ 0  V0    G   P %10    0P  
 P0    P   
  g  P   
 {p       ,@-`@  P@-@	  
 P     P
  
 000  S   @0@@ 0 H0  G(0(( 0 H0  >  D  4         A- P@\`` p     P  0  S
    0   0z d0          @-\MP0P @P` 0T0  
x   pP 
  
X H0 p0    T  0 R  \ v4-   X    2C-0<MP @ (      !0 A ;  PZ  
 0   P  PN  
$0    ;  U @  
X   T/  D   `P;  
$0  S$  
(((q	pP  - p1  
$0 S     	0 ,  P8@ P  00C  S 0   `03/ <   2 P   p   {   ` < 00C  S 0  `03/L2   \  l  H    H         p@-M000 00  @0  PP  P0  
     0    & @$  P#  
   T `  
   V  x00      p\   T @ u  8     =  p/   *           @-M  0    0 @0  fPP  P.  
a 0`   @  P#  
   T `  
   V  x00      \   TT @ '  8       .   ( x    t  p  `  @-,M     1   !0 @0    P8  
b  1 `  ^ @  P+  
   PP        T P  
 T ,  T  
l K`   /X @   <   x   P ,-   |  d           A-8M8 @0 @, (  $  1   !0 P (0  P4  
c($ 1 `  @#  P#  
,   T P  
   U  p 0,   -8X   P @ t  4     <  8,   $  ,        p@- @ M PP  P,  
 0   @  P#  
   T `  
   V  t00      pX   P^ @ 1  4       p  $ D    
  
  
  p@-HMH @`@ @. <  8  4  0  ,  <1(   4!40 P <0 ,@4@8@@@0< P8  
D@<  40 , 8P(0P P Pu  P#  
 & 9  U @  
 J  T  p   Hp\   &T P   8   o    Hp|) T              A- P\a\1` pP`M 0\0(  PA  
@  T    P    @ P6      00@     \  0  R.  `*0  @  0   0  0    !H! @ h    0H     @$0 0  H"         \  \  `  $  O-<M@T 0P @ p40 	 `P  
g 00C  S 0 P}  
  U  
4  0  3,   #0`0P  : 00C  S 0 `a  
  V[  
    P b  
ex  Kh#     P P 6  
 p  
<<<30   P0  P   
#0    `P:  
   P  
X 00   p  
 0 0  p  
 00   P  
D 00   P	  
x `; 00 <M ` <0 03/0 03/|   P 44   P?  
! P p,0=  s  :!   ! 0      P  P
   U p  
P   W      P 
  # <  P  `   @ [       #0  0   `0  0    `t      &   l  \  TL  ,  L         4  H      D  @  0               p@-  Mt t  p p  0   a\@@pP ` q  P	  p0<0  p0p@Mp    h#     ! h  @-struct cli_credentials  NULL    |Os talloc_new: ../auth/credentials/pycredentials.c:410 ../auth/credentials/pycredentials.c:418 ../auth/credentials/pycredentials.c:428 ../auth/credentials/pycredentials.c:429 ../auth/credentials/pycredentials.c:435 |O  talloc_new: ../auth/credentials/pycredentials.c:367 ../auth/credentials/pycredentials.c:375 ../auth/credentials/pycredentials.c:380 samba   NTSTATUSError   (i,s)   talloc_new: ../auth/credentials/pycredentials.c:335 ../auth/credentials/pycredentials.c:343 ../auth/credentials/pycredentials.c:349 i   ../auth/credentials/pycredentials.c:272 s|i O|i Failed to convert passed value to Bytes O   Credentials management. credentials AUTO_USE_KERBEROS   DONT_USE_KERBEROS   MUST_USE_KERBEROS   AUTO_KRB_FORWARDABLE    NO_KRB_FORWARDABLE  FORCE_KRB_FORWARDABLE   credentials.CredentialCacheContainer    credentials.Credentials get_username    S.get_username() -> username
Obtain username.   set_username    S.set_username(name, obtained=CRED_SPECIFIED) -> None
Change username.  get_password    S.get_password() -> password
Obtain password.   set_password    S.set_password(password, obtained=CRED_SPECIFIED) -> None
Change password.  set_utf16_password  S.set_utf16_password(password, obtained=CRED_SPECIFIED) -> None
Change password.    get_old_password    S.get_old_password() -> password
Obtain old password.   set_old_password    S.set_old_password(password, obtained=CRED_SPECIFIED) -> None
Change old password.  set_old_utf16_password  S.set_old_utf16_password(password, obtained=CRED_SPECIFIED) -> None
Change old password.    get_domain  S.get_domain() -> domain
Obtain domain name.    set_domain  S.set_domain(domain, obtained=CRED_SPECIFIED) -> None
Change domain name.   get_realm   S.get_realm() -> realm
Obtain realm name.   set_realm   S.set_realm(realm, obtained=CRED_SPECIFIED) -> None
Change realm name.  get_bind_dn S.get_bind_dn() -> bind dn
Obtain bind DN.  set_bind_dn S.set_bind_dn(bind_dn) -> None
Change bind DN.  is_anonymous    set_anonymous   S.set_anonymous() -> None
Use anonymous credentials.    get_workstation set_workstation authentication_requested    wrong_password  S.wrong_password() -> bool
Indicate the returned password was incorrect.    set_cmdline_callbacks   S.set_cmdline_callbacks() -> bool
Use command-line to obtain credentials not explicitly set.    parse_string    S.parse_string(text, obtained=CRED_SPECIFIED) -> None
Parse credentials string. get_nt_hash get_kerberos_state  set_kerberos_state  set_krb_forwardable guess   set_machine_account get_named_ccache    set_gensec_features get_gensec_features get_forced_sasl_mech    S.get_forced_sasl_mech() -> SASL mechanism
Obtain forced SASL mechanism.    set_forced_sasl_mech    S.set_forced_sasl_mech(name) -> None
Set forced SASL mechanism. py_cli_thread_destructor    py_tevent_cond_wait py_tevent_cond_signal   py_cli_state_trace_callback py_cli_state_poll_thread    ../source3/libsmb/pylibsmb.c:160    ../source3/libsmb/pylibsmb.c    ret == 0    ../source3/libsmb/pylibsmb.c:567    ../source3/libsmb/pylibsmb.c:568    ../source3/libsmb/pylibsmb.c:569    ../source3/libsmb/pylibsmb.c:483    struct py_cli_oplock_break  t->py_threadstate == NULL   t->py_threadstate != NULL   ../source3/libsmb/pylibsmb.c:121    ../source3/libsmb/pylibsmb.c:377    s|II    ../source3/libsmb/pylibsmb.c:814    []  mode    {s:s,s:i}   II  ../source3/libsmb/pylibsmb.c:773    IK  ../source3/libsmb/pylibsmb.cELF          (    ;  4      4    (                             0 0 0                                       $   $         Qtd                          Rtd0 0 0                    GNU ?2U\lxF^qa          
   $  @   @ `   ""	  0     ( 
  Q  J1 	<     )
B_      @5i(d  B  "0                                                                                                                                                                                                                                                                                                                                      hp1nvOwF3HwT<S) 4	]"ag5|vh;al7 A'NkYG9PWsz'`BE@l.R"2UQP`XyVE4mu>E|:KfdY~0ju<]l.- qXBirWQu]V&U-`d|7Ztd;z2
>CW=?EJv|lhp2YjOEPVCWwXE|UfV,I>|7-5AdQ+|/T]Sg( IOw>,@iLWtB                    2       
     8                    
             3                          L                                                      g
             
                                                                   &                          i             &                          
                                       

                                                    T             &                                                    [             
                                                    [	                                       	             	             |             >             	                                                    	                          8                          z             l                                       b             
             Y                                                    <
             >                          .             i                          Q                          r                          [               ;             &                                       D                                                    	                          n             	             \
             9	             *
             
                          d                          =             '                                       6                                       h                                       	                                       
             f                                                                   k                                                    7             z
             %                          4             
                          2                          Y                            2               |	                          L           "   E             f	             
             Q
             K	              	          C  h      G       C \    R  @  D     ?  X        `O               v    (      lI 8    
  ?  L              I  M        B  8       0? t      c        S        h  @     `  F        ` h       =         E       $M        pO          B       J  P          8             o         ~  @  (     	   t        =       x  4A       i  ,         4 $       `K       r    X    %  @  d                U t       +     J  $         DW 4     
  ^ (    8    D        b       C  2       
 \  TV      n  dZ       LC  8       U      _  Y      ,  K      6  l@  L       `\ (       8B l    v            < P       \T 4       \ l     \           4u      /  H\      }  T\               8  J        xW        | $     @  $F  t     o   T <       C  8     P  <\        (
 H     `  S H               M      o   d=  \       0] D     P  N      -  L       ~  U        R        @       t]        T |        E                            U 4       U                X_ T    ~  D_        hU  <
      e   	        0         x       O      t  0_      l  @  8       |L         $       C  8        >      >  Q       \ <       X $     M  lY (       p
 <      tS d      __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses reg_get_predef_name reg_predefined_keys reg_get_predefined_key reg_get_predefined_key_by_name strcasecmp dbghdrclass dbgtext DEBUGLEVEL_CLASS reg_open_key reg_key_get_value_by_index reg_key_get_info reg_key_get_subkey_by_index reg_key_get_value_by_name reg_key_del reg_key_add_name reg_val_set reg_get_sec_desc reg_del_value reg_key_flush reg_set_sec_desc reg_val_data_string talloc_strdup convert_string_talloc data_blob_hex_string_upper talloc_asprintf smb_panic reg_val_description str_regtype reg_string_to_val regtype_by_string _talloc_free strncmp strlen data_blob_talloc_zero __ctype_toupper_loc strchr strtoll data_blob_talloc_named sscanf strcmp strtol reg_open_key_abs talloc_strndup strrchr reg_key_del_abs talloc_init reg_key_add_abs win_errstr lpcfg_private_dir reg_open_hive reg_mount_hive reg_open_ldb_file reg_open_samba reg_open_local fdprintf close _talloc_array __snprintf_chk reg_dotreg_diff_save open64 talloc_named_const reg_dotreg_diff_load afdgets strchr_m talloc_strdup_append next_codepoint write sys_write_v read push_codepoint reg_preg_diff_save reg_preg_diff_load strncasecmp __errno_location strerror reg_generate_diff_key data_blob_cmp reg_generate_diff lseek64 reg_diff_apply memcpy data_blob_named memset _talloc_realloc_array unix_to_nt_time _talloc_zero_array tdr_pull_init _talloc_reference_loc tdr_pull_nk_block ndr_pull_struct_blob tdr_pull_sk_block ndr_pull_security_descriptor tdr_pull_vk_block strupper_talloc tdr_pull_li_block tdr_pull_lh_block tdr_pull_lf_block tdr_pull_ri_block _talloc_steal_loc tdr_push_init tdr_push_regf_hdr tdr_push_to_fd tdr_push_hbin_block tdr_push_nk_block tdr_push_li_block tdr_push_lf_block tdr_push_lh_block ndr_push_struct_blob memcmp ndr_push_security_descriptor tdr_push_sk_block tdr_push_vk_block tdr_push_uint32 abort reg_create_regf_file creat64 security_descriptor_dacl_create talloc_unlink reg_open_regf_file _talloc_set_destructor fd_load tdr_pull_regf_hdr tdr_pull_hbin_block __stack_chk_fail __stack_chk_guard hive_key_get_info hive_key_add_name hive_key_del hive_get_key_by_name hive_enum_key hive_key_set_value hive_get_value hive_get_value_by_index hive_get_sec_desc hive_set_sec_desc hive_key_del_value hive_key_flush reg_import_hive_key local_get_predefined_key talloc_check_name str_list_length ldb_search ldb_dn_get_linearized ldb_errstring ldb_msg_find_attr_as_string ldb_msg_find_attr_as_uint ldb_msg_find_ldb_val strtoull strtoul _talloc_memdup ldb_msg_find_element ldb_dn_escape_value ldb_dn_copy ldb_msg_add_empty ldb_dn_add_child_fmt ldb_delete ldb_modify ldb_msg_add_string ldb_msg_add_value ldb_msg_remove_element ldb_add ldb_dn_new ldb_dn_validate ldb_dn_add_base ldb_transaction_start ldb_transaction_cancel ldb_transaction_commit ldb_msg_new ldb_wrap_connect ldb_set_debug_stderr dcerpc_winreg_QueryInfoKey_r ntstatus_to_werror nt_errstr dcerpc_winreg_QueryValue_r dcerpc_winreg_EnumValue_r dcerpc_winreg_EnumKey_r dcerpc_winreg_DeleteKey_r dcerpc_winreg_CreateKey_r dcerpc_winreg_OpenKey_r dcerpc_winreg_OpenHKCC_r dcerpc_winreg_OpenHKDD_r dcerpc_winreg_OpenHKU_r dcerpc_winreg_OpenHKPD_r dcerpc_winreg_OpenHKCR_r dcerpc_winreg_OpenHKCU_r dcerpc_winreg_OpenHKLM_r reg_open_remote dcerpc_init dcerpc_pipe_connect ndr_table_winreg tdr_pull_charset tdr_pull_uint32 tdr_pull_NTTIME tdr_push_charset tdr_push_NTTIME tdr_pull_uint8 tdr_push_uint8 tdr_pull_uint1632 tdr_pull_uint16 tdr_push_uint1632 tdr_push_uint16 tdr_push_ri_block tdr_push_expand talloc_get_size tdr_print_uint8 tdr_print_uint16 tdr_print_uint32 ascii_len_n utf16_len_n convert_string tdr_print_charset tdr_pull_hyper tdr_push_hyper tdr_push_time_t tdr_pull_time_t tdr_print_time_t timestring tdr_print_NTTIME nt_time_string tdr_print_DATA_BLOB dump_data tdr_push_DATA_BLOB tdr_pull_DATA_BLOB tdr_print_debug_helper __vasprintf_chk libpthread.so.0 libsamba-util.so.0 libdcerpc.so.0 libutil-reg.so.0 libdcerpc-samba.so.0 libldbsamba.so.0 libsamba-debug.so.0 libsamba-errors.so.1 libsamba-hostconfig.so.0 libsamba-security.so.0 libndr.so.0 libndr-standard.so.0 libsys-rw.so.0 libldb.so.1 libtalloc.so.2 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end libregistry.so.0 /usr/lib/arm-linux-gnueabihf/samba SAMBA_4.5.16_DEBIAN DCERPC_0.0.1 SAMBA_HOSTCONFIG_0.0.1 NDR_0.0.1 GLIBC_2.4 NDR_STANDARD_0.0.1 SAMBA_ERRORS_1 GLIBC_2.8 SAMBA_UTIL_0.0.1 LDB_0.9.10 TALLOC_2.0.2                       	 
                        	                                                                                    	                                                                                                                               0                                g         Q                    Q5           '                                                 A#           D         ii                               v                                )        [         ii  
                    	 <        Q     0   ii   K     ii                                                   T         T   U        6         4   f        B         "   q      0    4    @    H    P    X    `    h    p    x                                                                                                                              $    (    ,    0    4    8    <    D    H    L    P    T    \    `    d    h    t    x    |                                          	            &            J   M                  o                                                
                                                             $   (   ,   0   4   8   <   @   D   H   L   P   T   X   \   `   d    h   l !  p   t "  x #  |       $   %      '   (      )   *      +      ,   -      .         /         0   1   2   3   4   5   6   7   8          9   :      ;   <   =          >  $   ( ?  , @  0 A  4 B  8   <   @ C  D   H D  L   P E  T F  X G  \ H  ` I  d   h   l K  p   t L  x   | N      O   P   Q      R         S   T         U      V   W   X   Y   Z      [   \   ]      ^   _   `   a   b   c   d       e      f   g      h   i   j    k  $ l  (   ,   0 m  4 n  8 p  < q  @ r  D s  H t  L u  P   T v  X w  \ x  ` y  d z  h {  l |  p   t }  x ~  |                              @-? -  * * * * *| *t *l *d *\ *T *L *D *< *4 *, *$ * * * * * * * * * * * * * * * * * * * * *| *t *l *d *\ *T *L *D *< *4 *, *$ * * * * * * * * * * * * * * * * * * * * *| *t *l *d *\ *T *L *D *< *4 *, *$ * * * * * * * * * * * * * * * * * * * * *| *t *l *d *\ *T *L *D *< *4 *, *$ * * * * * * * * * * * * * * * * * * * * *| *t *l *d *\ *T *L *D *< *4 *, *$ * * * * * * * * * * * * * * * * * * * * *| *t *l *d *\ *T *L *D *< *4 *, *$ * * * * * * * * * * * * * *0 0   R/ L  404 0  0 0C S 00/ 0  S//  d H  88    A,0A0/ 0  S//L H  P  L0L 0  0  S/80@-0  S  
(0 0 0    \    8 80    0  R     0  S
@-3/@ p ,  DP  
808 0   Q  
   R /  ,   $ $  0@-03/G- pp00`	@ P  0P  S
  
 h@  P
  \        R   < <0 0 ?  P
$   E   $   $ # $$ @- Q  
  @  T  
4/00 0 0  S	  2 00 0 0  S  W t0t 0  0   P
T   H0@D 0  0   P
(      " # $ " `# p#  Q  
 @-M $@  T2   
 4/W / Q  
 @-M @  T2 
  
0,($  4/W / Q  
 @-M  @  T2   
 4/W / Q  
 @-M <@  T2   
 4/W / 0Q	  
 0 00  S  
@-3/2 /W /0@- QMW 
  
P  @  T  
 4/0d00 0 0  S  2 0D0D 000  m  P
 0   0   qX   d  ! ! M0@-M P0W   
P  @@  T  
  4/0@/l00 0 0  S  2 0@/D0D 0D0  6  P
 0   0   :    D! L!  0Q	  
 0 0(0  S  
@-3/2 /W / 0Q	  
 0 00  S  
@-3/2 /W / 0P	  
 0 00  S  
@-3/2 /W / 0P	  
 0 0,0  S  
@-3/2 /W /@-$M   2 R0  
A 
 Q            	             $  $      0   $$ R  0H  $ R  (@  p0`PD8(,<$ 0 0 0  S     ) 0 0 0  S      0   0   P
0 0-   p0p   0 r  P
T0TT 02   t h& ,! X!   x    d      (  0    MA- `Q @P0  
 0  p 0     A_``  O-4M p `@PXV\400 p    
 P   g    '  &        "  	      c  	    p  4  B  P  
 0h S  0e S  0x S  0  S  0 0 c p`@  ( 00 c2  (00,00   0   P   
@0J  P @2 
  
 00p S  :a @	 T:0  0004  X  0 00    :|2 P0 0  0 @` +  0P 
 @ 0$$( 0$L&  0&&,@ 0 ` 0 0 0 4 "000      @4 ]  0  ) S  S  
0) S  St 0 0 2 @PLX1 0 0 0  SL@1@!0 0Z  PC
$  a ?   P0 06   e0 P0 0  0 @   0P $
 @ 0$$( 0$L   0@4h0 0 0 0  S_d0d  0(0    PU
D   $Q  0 H      x        A- M@ \Pp  P"  
 @  `P   
  &h @   T 	   \  P  
 0  0 0 o   A- `P \@  P"  
\  @  pP  
0  T P   U  
 \  0  P    @ p@- ` M  @&\ P   P   
0  00  @P  
0 X p   @  C-M 4p @  \Pz`` P   
0 00 	  @P  
00 0 0 S   00  0p0	 H0H 0@0  J  P
 A     M      G- PM `<0   N pP   
` 80   P @  
`   T   
0 @ %@  80 j @ t A-M@Pp,` P*  0
!0  0 (0  `0!0  0 (0  ``0!0  0 (0  `800    `(0     2 /@-      @-      @-    d @- @  q s  < O-,M T` " V  $ P@u  
0C S7  *  )  4      Vs  8     p  Wh  
 XZ  
 XR  
 XJ  
 0 0 0  S8  0     5  ,    $   `0  $p00 x10   pP5  
``
P   	0    TP0  0 C 0     K  E  ?  p ,00 0 0  S     x0x   0   P
\0\\ 0X   t H @ $ $  l @       T `     A-`4!P p   U  q @p&  
!A   P  #    (   XP@ P@  0     P@ 0  000 0 0  S   h0h  00    P
H   <    D L D $l4   @ X O- 0	<M     
  p a PV 
(8 ` 000 00  $0```   J @P  
 P  U   %  [
   @ 0 S 0 0 P; U  U 
[ U  
  V  
  U2  
080 0 0  S   	`   00S] Sa  
70 0 0  S   = N PP~  
  [ `  
 0" S  
70 0 0  S   0  S  @ 0\ S  
 A 07` 0 0 S 0  S  
0P P,0  [ Pv 
  ,0P   5/  Pq 0  S  
     0	`0d0- SH  
 @  P% 
0  03/  P  
 6 P0 0 0  S  $ | <6& 000    Pi
  d50 0 0  S   `, W Y <\50 0 0  S  | L @ q P  
0 03/ PP<  
40 0 0  S    4 <  @ U0- S a  
" S`s  
:  PP  
 .  * P 0@ \ RC    p`` P <4<$0 00		 $  P
  *30 0 0  S     <#0    P
    C  0  0 3/0q  
2 P0 0 0  S  H  4 w @  # 0  	   P
P f P  0  2"0 00		   P

  2"0 00  P
  t"$0    P
X   } Q 424"000   Pw
  s2"0 00		   P
   G C 0 0  S    0 P 0  S"   3 1!0 00 Z  Pp
d   _jP1P!000 L  P
8  R(1(! 000  =  P
   BH      4 L          \      8 L           l   ` X T d p  t       h   \ |  
 l t 
   L
     /@- @      C-M P @`p	    	 { P
  0@ l  T :   C-M @P  p,`P	        '<''(pp    0
  &$&&<    0`     (        p@- M P`  @P   
 0@"0        4      P 4 p ` X @-pM P x `P!  
    @P  
 0@"0           t< P 	,   L     @-@M P\  @  pP%  
\ `@  @  `P  
0\ `!      :8 @ (    p  @-M@  P      A-`X!MP  p  U  4 @/  
(!A   P  +  ! P00  PPP   & p  M@ @  0 P 0P P@ 0 000 0 0  S   `0`   0   P
D   < tx   PReg  L     , O- PLTM  88+0@`   @ 980 0 P  
70 0 0  S3  0`00  
    T  r P  D0 S  P7 0 0 0  S LL7D0080  4,0$0    # PQ  0[ S: pf    ; R  
 S  p 0G  P
 0 0 pf     ; R  
 S  p 0G  P
 ` `  8   P!   `P   0; S   <  P)   `P   0; S  <0S  *  <0 P9  H`    >H0 0  P   0] S  
85 0 0 0  S      P;  
8    Po  
    P3   `;p  0` 003/   P 03/i4 0 0 0  S!4$ 00  u  P
 0`  0x``0 3/IH r  PY  4440(P `	$@Pp   q0 `  3/ `; v0 	 @P  $@(PY0 `  3/  0  3/h3h# 00    P
 000`   $    ,00   P^
  4 Y 0 3/ 80`   6/P2 0 0 0  S|  `(2 0 0 0  Sl2l" 00    P
L  1 0 0 0  S 2 "00   P
   `it1 0 0 0 S1!0 0  P
  1 0 0 0  S1!0 0   P
d  X1X!00   P[
@  W0 0 0 0  S1!0 0 x  P
   0  00  j  Px
   qt  v    , L l d D  l        	 L ` 	   L X  	 	  
 	 l d	 	  T	 d	  x	 	   , 0 P	   |  G- M `0  Ps @P  
x10 0 0  S?    @@@@ @0  M `P>  (p	   	 @P   ` `0    P 
    00 0 0  S0 0 

   P
   x0x   0   P
\   @@@@ @ 0 m   
 
 8	  
 (
  	 	 A-pM  0 `PP @P  
00 0 0  S      `P  
00 0 0  S    d|0|  0 0    P
\   L0L 0  0 }  P
,   k   	  <	 x  4	 | @-M@`p 0  QP P  
,0  0 (0 @P  
00 0 0  S   00 0 0  S    |0|  0<0  8  P
\   >L0L  0<0  )  P
,   /j    x d ( < P ` @-C  O-M 100 P>  
1`0 P @  @\ T  
`  Tp| 0 		  P  P P  
H1 0 0 0  S     0  		 z P  P!   @ `   0 0 X0   P
      l0  P0 0 0  S`0`  0X0    P
   0   Xi | h        4   O- pxM @    0H@L@T W `  
X0 0@@@@T0  PPR  T0  S  
,< $  ,0 , +p0 0 +@ ( 40P	  ;0 0 0 S`  T0@ Sm   PP P	0  
 P  X3  
L0P    PA  
 P P0 ( \ P+  
 0
 03/H0P  p  P  0L 0H  0
 |$
 :0 0 0 Sn   P0 , L0 P:0 0 0  S x  P0 0  P@*40   P

  
  TpXp  X  
 P`0 0PPPP \0  @Pb  
90 0 0 S   \`X0  S 
9 0(0t980,0h9	000\9pP040l0$0x@    P 0l  3/(l u,x rX0	 S $0	 @ P x|G0  P      X
l  @h  P0l U4x R\8 P0 0 0  S h F \0  Sa  
D8P0,0888040L000H0($0 $  P   P  
 P  ,P0  v PP  
 0	 3/00P  0   P  LH  4 \0@ S*  (0   $0 PP     WHp 7 P0 0 0  S    86@0 0 0  S"   8`0  SC
680,06 0006pP0406 0<060@060D0d0$0h0(0   P  h0 d  @ 4/,d 0p 4x `0
 St  (0 @ 0P$0
  p@t@x@|@~ PX    W
x@d  @l0   P h0  Pl  S<d @p Dx }\5\%0 p0  P
  0  84@ P0 0 0  S    ^ u840 0 0  S   Q h8P4 @0 0 0  S   C Z840 0 0 S  l 6	 M8P4P$ 0p0  [  P
 R $  _4$ 0p0  J  P@
  Q<3#0 p0 < Ph
 3   @a3#0 p0

 +  P
 "   /82 @0 0 0  S  \  H   820 0 0  Sc     8T2 @0 0 0  Sw    2" 0p0    P
    2"0 p0   PD
  l  =`2`"0p0   PB
H  ><2<"0 p0  PO
	    H2" 0p0    P1
    *1! 0p0    P
     1!0 p0		   Pm
  h  f\1 X!0 p0 y  P}
 p 0  }v, ,g  8        X X  
  8
 P
    t          0      D ` x    4  X          <    H        8  D  <  <    T  T    \          H  0      p l        |   X  O-4Mpp
@ 0`  Vc  
PP"L2 H 0 0 p$ 0(	  20 0 0 S<  @`  VH  
  P  (P,Pp,  j0  
10 0 0  S0  		   P
$ (0  S-  
,  Q 8  
0  00'  P
81 P0 0 0  S1   4!0   P
 @  `  V00  S  
 3/  4,   P 
0  03/(   P 0,0 03/( `0`  00    P
  4   Y             H  L      $  G-  M a4A@ p  
`  P: P p  
10 0 0  S-   & 00 0 0  S0  00  L  P
 
  R 0 0   0   p	   P   
L0L  00  )  P
, 
  /V     \  l  \  <     0  p@-MTPT@TTT00  P@  ` P@0`pDl@- 0O   $( T  LA- 0 @  SP	  
  U  :     U  :0  S10 0 0  S.   0 00 $  EpQ`QQ 0Qd4h	  J00 0 0  S
   0 H  B0 0C  p0p   0   P
T   D0D 0     P
(   T   |      L      G- @QL  
 0  S  T  :   T  :0  S D A$`pP
T	  Q  $10 0 0  S1!0 0  ]  P   Gb  @B  ^  a	  *@P@	D  ^ N $ @@$ @$0 h00 0 0  S  `   X0X 0 0 ,  P
<0<< 0M/  .HS   P      4      H     O-DM00  40D  S 0    
0  0   p   Wn 
'   $ & ( & ,    R `P  -    T d  0 S>  
u  :0` 0C VP  *$0 	
 @ 4DH  T  
 
0 0 0  S $0(    P
, 00   p@  W  
@0 0 0  S    0  7 ` D0 0 0 S  000  S" 
0 ` $  0c0 l$0!@L	 $0!!
 $00$  ` 0  S	  
  V  :     V  :0  S0 0 0  S    0$ 0D0$##$#< $ 00 0 0 S4$0 0  Q  P  0 0   R P@%   `44 08 O8<@ P0   U* D   D3#0 0 &  Pt
  -pP      Rk  #0P     |#(   pP  
`0  QpD  T    
000 @: P0@PP   a 2  0  B 0`@ v0, @B B$ , $  ! $  ! $  !  `#828"0 0    Pc
  ^2"0 0    P%  0 S 0F C% U^
0 0 0  S3    (X!p@ P l   60 0 0  S1  d  \  0P@[<1<! 00  m  P
10!  o1! 00  Z  P
0 0   \0 00 H  P
0 0   JPQ     4  H  p     L    t           D          t       <  $  h              @  d  l    D           D    O- $M    @(3  T0 0` 
  
 0 V  :   V*  :@  T  V  2 0 0 0  S    2 0 0 0  S  2"0 $0   P  
  	 G 0	  $O pF  VpG
$0 000 0  P4 Pj U   L W*   
P UB  * X* 4 
    Q	 
    0E S   $$0x  b$ 0hPBC $C  $C<p0$0	 P$0J0J($0J0 $0p PeP $0%p  $0%%\  $0 P$   $\0\  0$0  J  PX
<0<< 08   LO@I   P  P  @           L    b    Sp@-M   \0(0 0  R  
040 s  
@P `  .0  $  P      
  p 0 0A-M` @p 0A@ P    P   
   7/ P  
  00 0 0  S     00 0 0  S     0 080    P
d   T0T 0 80    P
4   $E |                H  H  A-p!M ml1l!0 `a` 0 @P!p X  # PP  
01P 0  Pz P  
 0  n R"  
00 0 0  S%   F @ 00 0 0  S0 0 H0f  P
   @k k R0  S `0`  0H0  M  P
@    Sp   G l  C p  4      p            @-4MA1@ P 00`   P  t10 0 0  SJ   40  s R.   k R+  p  W(  ,!    P   
1,(    0   P
00 0 0  S0 0 X0   P
   00 0 0  S0  0X0    P
d   T0T 0X0   P
<   A        0    T  X  H           0  G-M($c ^`   P@, 	 p  Zi  
 0( SA  :!1 @" D4   H$ PPS  
2 0	  P| P=  
  W  
  z  P  A  
80  S8 0 00  SQ  @	   < 0   R   20 0 0  Si   /  10 0 0  S1!0 l0  O  P
  V|10 0 0  S;  x   @10 0 0  S@1@!0 l0

 ,  P
0,  1!  <0  P  
0 0<0   "$0 <     <     < 0 0l0   P
   t0t 0 l0    P
T   ?     $        `  d          L    h  t        G-M p0` @P     P  
 	` p0
 @  P
0 P   C-dM p  a  Q`,  
   @    P3  
h k\   @P	  
D10 0 0  S-  0 d	X  0  P     d00 0 0  S0 0 |0 r  P
   y00 0 0  S   10  0|0  Y  P
h   `\0\  0|0  K  P
<   R;         4  <  t  <             @-  F    R  
 0@0s0A@   R @   O-lM`\~  0 |p1  
4 P@ 	 04  X  
  9 P"  
  2 P  
  + PF  
  $ P  
=0 0 0  S 0 l0 l t= 0 0	 S   D   1 P 
8 , D  pP 4  SS 
 0 0  S<,00   P
   < 0 0	 S   D    P 
 ex D  pP $0 R 
 0 0  S@<@,00   P
$   m; 0 0	 S m  \    Pr 
 3 \  pP 0 Y 
 0 0  Sn;+00 N  Pe
p  Ua$;0 0 0  S[L;L+0 0 :  PQ
,  AM ':  0 0	 SY   0P    PE  
 P R P 5  S-  
:,00:0 0<00\0$000(0X0 !<p  Wa 
0  0  / P3  
   ) pP[  
00  S  5{ S  0   R
 4  0   0 0  S  09)00 
   P
	  $  ! P 
 \   P 6  S p  00  Sp6wp Sd 0!  !  P
d 0 (   0$   P  
  \   P  N  Q 
 p  pwp Qd0   Y!0    P  00  S  S0  0   Rp4wp SzL 0!  !  P
L 0    0h  Y000  ^pwp YZd
  o  P!0  v  P  0   RH 0 0  S   0=6&00 
   P?
  ;6&0 0

 	  P 
  6&00 
   P
x   0 0  Sy  \ 0	    P
0  pwp PL0   Y!0    Pg  0   R 0 0  Sg   05%00 
   P
  , 0 0  S\  h z0d 0    0, 0 0  Sc   e0, 0 0  Sf   Zd 0 4$ 00  }  PU
  Q4$ 00  o  P{
  vwL 0    0~P4P$ 00  X  P
0  _$4$$0 0 J  P
  Q3# 00  <  Pb
  C^3#0 0 .  P
  53#0 0    P
  ' 0 0  S	  d   0 0  S  L  D3D# 00    P
$3$$0 #  3# 00    P
20>.  , 0 0  S    s, 0 0  S2"0 0   P
20"  t2t"0 0   P
T2TT0P"   0 0  S  0  A 0 0  S2" 00    P
10!  1! 00    P
10!  t9   <  t                          t        P        d  $             (    8  <  H           <  H  t  $        L    X          @  P  8  8  H            ,        \  t  x  (           4    z    P  X               h         T  \          X        \      <  D  X      O-\MP}p \    |  
$ `@ 	 $  Z  
< 
 . P  
$ 
 ' P~  
 
   P" 
 
  P  
<0 0 0  S  \ <p 0 0	 S   @  
 H P 
l @   P   YZ 
H<H00<,0,00     H0 !,  [ 
0      P  0 0	 S L 
  P 
 L   P 50 V *T 	FQs\
 D	 V  H\ b;p 0 0	 S <  L  
  P) 

 ' L  P %0 RW  
 0 0  Sm:*00 C  Pe

  Ja /@:p 0 0	 S    4  
  P  
8
 , 4 V P% #0 R  
 0 0  S:9)00   P2
	  .90 0 0  S(9)0 0

   P
	   T0Q  D0  S @  
04  rT  
L 0L $0  P   g
0  S0    [  
0(  P     R `8p 0 0	 S    4  
  P  

 |t 4  Pb #0 RD  
 0 0  S<8<(00   P
$    0 0   0 0 P  	 S  L 
  P  
 L   Pe 50 V	  *T 	FsQ<0Qss 4r S P<0Qf@7@'00 
 S  P
$  Z 0 0  S  
  6& 00  ;  P]
 0    ?V 0 0  S  
  6&00 
 !  P
|  ( 0 0  Sx  `
  L6L&00 
 
  PM
0  I 0 0  Sw  
   6 &00 
   P#
   0 0  Sn  
  p% 0 
   PI
 F 0 0  Sg  |
 l%0 
   PD
 A 0 0  So  4
  G 5 % 00    Pf
   b4$ 00    Ps
  o4$ 00    P|
  x  S/  
 Y 4$ 00    P}
`  yT4T$ 00  r  P
4  y(4($ 00  d  P
  k3# 00  V  P
  ]3#0 0 I  P
  P 0 0  S	     0 0  S    x3x# 00  -  P
X3XX0T#  /D3D# 00    P
$3$$0 #   0 0  S 3 # 00    P
20"   0 0  S      0 0  S2" 00    P
20"   0 0  S  `  hX2X" 00    P
828804"  $2$" 00    P
20/  X)     H              L  4                $     \      X              @  4    x    |  $  p  8  |    H  L    \      d             x    t      T  L        h    $  0  L  @  <      <      4  h      0  (  8    d  0                   @    x    D        p  0        l    4    p            P          t      C-MP @9b` pP b  
  U  0 P  U\      P P   0    	 Q PD  
  P^  
  0D 42   [ Pp  
  * P 0	 Q P2  
0    R+  
1Pp  0 P  R"  
  @ P10 0 0  S  1! 00    P	  
|    `10 0 0 S-     010 0 0  S(1(!0 0   P
  00 0 0  S0 0 0   P
   0 0 0  P
   X00 0 0  St0t 0 0 z  P
T      X        t          L        <  @        @- +`00 @P  
T 0 0 0  S   808  00  H  P
   O         A-`P pE @5/00 P
  
  t P  \ 0 0 0  S   P <0<  00    P
        $      O-DM`100,0 s.  
    	(0   S    
1 P p$00 0 @	 4DH 0 P
 0P7  
<   P  
(0p W: D	 :( 0 S  * q 0 (  S: B  R1(  0  
0,	  ,  0	  l  vD,	  0,0X        R@  A?4    P
$   ( $  @      X  d  O-4M 0Q0x=00 
0p 0 s<  
0 @S PP	  
@= 0 0 0 S   4@0   r>  
`  V`F:  
$
  $   P\   `F
 v(  
P P0   $P0 P
< 0 0 0  S 	 4d< 0 0 0 SP<P,0 E?  *  P
0  1@0,  r  
(P  UPE  
 <$00   `   P!   PE u2  
 		0   E P
|; 0 0 0  S 
 X;  @0 0 0  S  0;  @0 0 0  S(;(+0 E?

   P
  @0 	 P @`  V  
   P=  
   P  
   P 
  <: @ 0 0 P    S 2  Sf@:@* 0E?    P\
 
  X:*0 E?    P!
	   w9  0 0	 S `_  $    PJ 
 ; $   P   \  
0, Cq T
  
 S  *  P  
Ca a0s0 S:0Ls0  S2 
 0     @ B 8  0 0 4 q  
 0@    8  0 0	 S `  $   A P 
   $ > P "  R  
,0  T  
q0 R 0 0 S4  0 0L0s0 R  C0s0  R 0Bs0  S2  
d  S  46 @ 0 0  S474'0 I?   P  
   0 0  Ps 0 0 S6&0 I?    P  
   0 0 ,6  0 0	 S `   $    P  
d dX $  P  "  R  
,0  T  
q0 R 0 0  S 6 & 0I?  v  P}
  }y0s0 R  C0s0  R 0Bs0  S2  
5% 0E?  T  P
h  [\5\%0 E?		 F  PU
<  LP  0 05% 0E?  1  P6
  82  0 0 0 0  Sw    0 0=4$0I? 
   P
   0 0  S  l X4X$0I? 
   P
8  ,4,$0I?   P  
   0 0? 4 $ 0I?    P
   0 0  S   3#0I? 
   P!
  3#0 I?    P
h  L2 0 0 0  Sg  @  >838# 0I?    P}
  y 0 0  S	    ) 0 0  S    "2" 0I?    P
20"  2" 0I?  r  P
20"  tt2t" 0I?  _  PT
T  fP 0 0  S"  8  020" 0I?  J  Ps
  Qo2"0 E? =  P
10!  ?1! 0I?  *  P
10a.  ,   $    \  `    L        @  x    D  `  p    D  D    x  (  @  <  l  <          D  H  4         L  8  (                  l  $    4        D        P     0            @  X  0  \  X            x  8    >      h        T  <               L  T                  p@- Pp00 @P  
d 0 0 0  S    p  m p808  0N?    P
      @      A-`P p @5/00 P	  
  ht P I \ 0 0 0  S   P <0<  0R?  g  P
   n4     t  8  d  O-M@|U|5 Pp0` (   >P5 0 M pP  
450 0 0  ST   5  
00    ! 0P09  
0 04 R !   P
,0 S0C8,0  
  L p` W 1 P  P5  
D 0 RE  
	 
0   P440 0 0  S  $4$$0V?   P	  
    30 0 0  SW   3# 0V?    P
  H 3 H  `0	  0# 0  `d` T \   l`hpT dp % p `F  
0   R0 r  \ 
0   PM  20 0 0  S2"0V?   P
  2"0 V?   P
  8$ 
0  r PH  20 0 0  SH2H"0V? q  P
0  x10 0 0	 S'2"0 V?		 ]	 P
  d0$  D`` 
0  > P7  L10 0 0  SW1!0V? =  PO
  0 !(0D` $ ( 
0   P  00 0 0  S1 1 !0V?   P)
   %0  @` 0   $0(  @0 p0ip 4                X  d  t  D  @  d  8        \  l    H  X  P          0  @  P  MO-TM4p ``` |00, T4 p04` ````0@2  
  
$ (0$  S *  
3P00  L d  P  
(0 S   0 @
 4DH0 p	 `P 0P#       R   TO/`X3  [040L  
 0  SI  
0 L4 @ 0B S0D <0A  |0
  Y@  tU  
 0 
 (,0 s  T  
(P  U  
0 `   U  
  ^0^$`48 S N !N"  #  L"0
    TO/ 04L03 @ S,  
1 0 0 0  SW  2 TO/ t  
<0  S@
 10401 
 ,0 s    t1  
 w0(0, 0  1@ <0(41 0	 0 @P `
( !x(  P0(  $@#!!(  ( # A
 (,(, 0  0[?    P
l   `  [?T    P)
D   $D $    d  T  @      |    t        `  <O-`M0    @0DPT@00 @`|p H P, 0`dlt
  XT0|@P@X@\@h@x@@@@HD P   
; 0(  0` P  ;0 0 0  Sd   00 p0+;  00 0 s0 ?  
,0  0],  X[ 
@; 0  0v 0P$0  
; 0  0l 0P$0@  
: 0  0b 0P$0Q 
  Z:0 0 0 P,   S  :*0c?   P  

  	  0  P  
H:0 0 0  S 2@ s @:@*0_?   P
0$
(   0 @ 40   0 P 
   4  @P- 3  S0  
   3@ T <0   	   P3 L)<   0    P <   
3 C R1   C ^  00 1 	3< !    R  
(03 0 R  < Z000T 0 E 
 8!  0 0 0 S    C0 S	  C R5  S  8@@  	0   P @ k  
0 0	 7       <0 @ 40   0 P) 
T   4 h @Pz 3  S0  
   3@ T  <0   	 ,  P3 &<   0    P<   
0L S1     Sx6 !  0T  < e  S  @@50 0 0  S6&0 c?   P
   0 @ 40   0 P  
   4  @P	 3  S0  
   3@ Ty  <0   	   P3 %<   0    P < 
3 C R1   C \  00	 1Nx0   >  < Fl4l$0 _? 	 n  P
L	  t N004@@  	0   P g
3         3#0 c? >  P5
  E1 3@  	0 @  P @ 7
0  0	0 0  S-
2     X20 0 0  S*   @(20 0 0  S,   @2"0 c?   P
  10 0 0  S   h X2$T"0 c?   P
8  ,2$("0 c?   P
   2$!0 c?   P
  00 0 0  S    @00 0 0  S    71! 0c?    P
p1pp0l!  \1$X!0 c?   P
<1<<08!    l 8  4    P  @    ,  X    ,  T  d         X  `  <  X  (  ,  8    $    (  @  P  `      ,      `  `  P    |           ,    @         $    4  h            <    L    @        Dt      $  ,  @  s  k  O-P#M    c` @Pz  
3p 0 0 S  i  p  c  
#r   Pg  
l300    }L:P,0   P4 R  
 3 PQ0   P F  
2 P, 0 L H0H00 P W2" 0   ( P0PP \ h l t |  XP`PdPpPYxWP20  $  0P0  
 0 0 Sa    0 0  SG   x  1!( $ 0, @ 48<D0  0 0,P (   PA  
 0 0  Sh1d!0 > z  P
Hx  818!0 >  k  PM
  rI1! 0>  ]  P
       _0 0 > J P
   Q0
 (    
 PP   p               <         @    D              L            O-%$M  pUP @PD  
5P 0 0 SX  	  p  *  
 0   `  D  P   ,  
X%r   P"  

 
  PF  
$   P"  
 0 0  S       0 0  S;    $ $ 0 0  S    $  1 P4  
 0 0  S  h | T4T$0 n?    P
4   0 0  S   d 4$ 0n?    P
M  	    :03 0   P 
   S  * ,  R  :|#|3  t#0  pP    0  P    _  RP M  *0,0 RI  
 (Qp P	 	 u
3 PP 0 0  Se    c2"0n? (  Pd
x	  ._h2h" 0n?    P=
H	    7424"0 n? 	  PU
  	!	 0   LP  0 0  S5  0 ( C     1! 0n?    PD
	  ?P 0 0  S%  \  H1H! 0n?    P
(  1!0 n?    P
 	  0  0n?    P
       \ P  L  $       T  p  h       (            |  d    t      <  \  d           X                    p      O-@<M `  4`dhpM p  
 P  (0    r  
    P  
x  y  P  
 04  0 R  <p 	0    0H     0  0@-M (@, @4@0P8P@0@4/0@- `M P\@p    P  $0 0 0  0 @04/h00 0 0  S  T   L0L   0   P
0000 0R   L   \          e   0@-03/ @-@4/@-M @@@4/ M@-M @0  T2   
 4/@/ @-M@  T2   
 4/ @-M@  T2   
 4/ 0,0  S  
@-3/2 / 0(0  S  
@-3/2 / 0$0  S  
@-3/2 / 00  S  
@-3/ /M  Q-MW 0  
  /  R  
-M zW /@- @-0-M -M   R  
@-W /  R  
@->W /@- 0@-M(,P0@4 8P@0A-`X  P p @P  
8  ,    `P   8  (  <  A-@l` pi0  S    0  S  
   RP  U  0%   P    O-$M  @0F"  T  00  
 0  S  W	 $ 
  0P0^  
\p  W Ps  
 \20 
 B pPN  
0   Qu  
0G @  )0@a    Q 001 0@    P\K    U -  
0  S P(  
  U  0 
  @ pP  
Z 0   Q
 `  
  PH0 00 
 U	 $ '@   ` 5   0 L0  	 $@`0  0 0 0 S   k @``0` 0   +  P
	 "  4   .@  h $      X  `      t  <  4  O-,M  @0|"  T  0$0  
 0  S  W
 , 	  0P0R  
\p  W Pg  
 420 	 x pPB  
0   Qj  
G @  _0@a    Q 001$ 0@     0   Q	 `  
$f\  P2    U   
0  S P  
  U 0 	  @ pP
 , i$@   ` w   0 0  
 ,@`0  @0 0 0 S	   Hv @`d0d 0 0  k  P
 b  4   n  @       0  8      x      8 @- @  P  
0  0 0     t G-P @!  p  `P6  
 @  Y P@@,  
 0 S)  
	 @00    P !  
  Q   
 P   P   @  Q  000    S` ` 0`0` 00 @0      |  @- @   P  
4 00   P  
 00       @-M`  p0 @  p  [00 PP  
 0 0 0 S   0    x   \0\ 0   P
  @   $     P   X  l         !@-M`  p0 @  p  00 PP  
 0 0 0 S   0    T|  : `0` 0 0 ` P
 l @ ]  $   `  ,         P  8  G-  ` P$p  V 0 0  U 0 0  W @   0 0  S  
0 S    V	  
0|   	     U	  
0P   	     (  3  P
 /d        A-M @R p`(P	  
"          @   @D `
 T^  O  N  [  /  .  X  W  V  U  T    P\  
    A!  @` a  P    
 @ 0$$( 0$L&  0&&,@ 0` 0  0 0 00  P3  
    L   @ 9  P  	  
 @ 0$$( 0$L  0@00  P  
  0 P      J  P  
H0 0 0	  0 00[    D  @    $    dC-$M P pD10 ` @ 0    10	 P  
 0 0 0	 S"   $  0  S  
0 0  S	  
@0  W  S  	  $ $ 0 0 " d0d 0  0		 "	 P
 . @   (   "  H t   H        h  O-,M  XPP p 0  Z 0  Y000 0 0  X 0 0T0  S @T   0   U 0 0  V 0 0  W 0 00 0  0 j  
,0  Ss  
0  Si  
  Z0 0  Y0 0  X  
 0  R 00 0  U  
0  S  
0	Q 0   S01 00	 S  W  V;  
   PB    W  
0  S  
 0  S01 00  S*  
  
P 00  V
  
0 $ 0   S01  W 0  
	0    q 0$ 
 S01 0  B0P S\ :  ,   P
    P
 |`  T     4  0  C-P  M,p@ p(0	  `   P    T  
@D0  S  
0 TH %  *0	  (0 p&     P
     @-M @  0   [00A-  P `r  Vp @  "   PPu  
{  P  p  
0  k 0P>  
  l `     P"  
 | P   UR  
  U  
\10 0 0  SH1H!0 80    P
        0 0  % P  ` v V  
  V
|00 0 0  S0 080    P
  X       L   d            <  H    @      \  \  O-@`M      R)  
0 P  S-  
0  S  
pp @  0 S  0   d!@ P0	 
0  <  00 0	 
0  P
   P  X  MG-M4@0P p  %  `    @P  
	  P= 
d   P# 0J
 S^  >  =  [  '  &  X  W  V  U  T     R  
0  S  
 R    P $ 8(, <   P 
 >  0  S  
   R  
 S  x     P 
` *  0  Sr  
0  So  
8$   PP  
 0"     p 0P  
  0   0  SZ  
0  SW  
  0 {  P?  
    P  
   P     P P  /  
 0  SM     P  
 0" R0 P   P P]  
 U H  
 9  UF  
20 0 0  Sj   - G/ $ G/ 0   0  l 0  T 0  	 0   .  P    @ @ G/  P U  *020 SP   U:  Pt  l[`1`!0 H0    P
  4  (    | w r m h c   P  8    \J    I       (    \    ,    X  H      x  \        x    h    p  h      0       <    `  (  0DG- p P @ `f PP5  
    `h 0P0  
 _ 0P1  
 0  S&  
\
    F
P   h  P  
0  S  
 e @P  2h   T  P  P  ` 8 `$ `  L      `  l  O-@(r$Mp P `  b`   P#  
 @
0@@ @   0P      Q  10 0 0 SR   $x10 0 0 S1   $ $   0 @P
4!   (! q       a0          0 @ 0 0X0   P

  @   x   l0l 0X0    P  

  D         L           p          }  O-P$M ` p 0  P @P  
 $   PP 
3p00@ p0 
  P  
x30 0 0  S(   $X300 0
  @P/  
(30 0 0  S3#0 h0 M  P
 Y @
 J    M2"0 h0 8  P
 D @
 5    8
  pP  
X20 0 0  S`2`"0 h0   P

  4       R  
      R    @p   _ @P

 mn  0  S  
 p     Q    @p    @P
 XP 
  @P  
00 0 0  S$  
 =[
  PP  
00 0 0  S0 0 h0   P

      u P0 0 h0    P

  h     P      @        4        l  d                         G-` pQP P,  
 A @P(  
 
 l  V  
  e F|  &D Z2  
d1  Z0 0 0  
  S=    S(  8!    @P   ! 1!0 0	       $0  @  0 0 0 0
t0    P
	 $    t0t 0 t0    P
  H             h                 p  l  d  A-  QaM`W@?  
 @0@, ( P pP;  
 `P4  
@!   P  -  
((          0 0  0 P7  U   00  P @ 00 0 0 S  @ \0\ 00   P
<            D     |      t    A-@P `
T 0 0 p   +  
0!   ! T  R 000!  X  
 H    P  
  0  `,0 0  8/x00 0 0  S  d  XP0P 0  5  P
4   ;                   0D@-<M p P `0 ` @ 0 $ (0,00 4  08@0 $  ,0(000 PP
  00   40  <x 0 0 0 S    0 <L0L 00   P
 y        L    X      O- 
 `P(,0p-, @ q  
  V   U      Y,0 0  X$   W  $0 040  S4 00 080  S8 40 0
 v  P
@  C-TM ` Plq) 0 0p, @ q.  
$,    $0$00(00 00@0040D0 0,P<P80H0 @P  <H0    @ @  0    p L0  T , 0P
 Tp00 0 0  S   j 0L0L 0 (0  9  P
      =x  8 l          G-XM @
 pxPa) `,0  s 00;  
|1$04  
  00$00 ,0@0040H0080L0
 0(0PDP<0P0 P"  @0   DP0 @H      0 b | T0  X
  0P
 Xx00 0 0  S    0T0T 0 @0    P
 _ (      d7              O-DM P hpl` 0  T @ 	$   7000  $0000(040 ,800 @P    X  
00   X    W  
40   O    V80  < Dx 0 0 0	 S   DT0T 0	X0  Q	 P
  (   U  5         <      0p@-M ` P @@ P@  O00 PP   pl 0 0 0 S   DpH0H 0p0   P
           D  |  |  A-0A0M@ p k H@@ ` 0   P  4  $0 pP  0, 0L0 P0| p00 0 0  S   0L0L 0 |0    P
 e     0             C-A$M@  ` Hpp P m P   
  0   0 @ 0 0,0@@P @ 4P`0 PP   $h00 0 0 S   H0H 00  r P
     v           0@-M @  @Y00 PP   0h 0 0 0 S   r0D0D 00  A P
     E         0@-M @  @00 PP   0h 0 0 0 S   B0D0D 00   P
        <    L  0@-M @  @00 PP   0h 0 0 0 S   0D0D 00   P
         |      0@-M @  @00 PP   0h 0 0 0 S   0D0D 00   P
 R    @     P    0@-M @  @00 PP   0h 0 0 0 S   0D0D 00   P
 "             0@-M @  @00 PP   0h 0 0 0 S   0D0D 00  Q P
     U   <    L  0@-M @  @00 PP   0h 0 0 0 S   R0D0D 00  ! P
     %    |  |    @-M @`p,!  QP @P   
40  S(  
 10 4 0 8  p  1 S p
  
 0   0  @ 000 0 0  S    0  0l4 \0\ 0 0    P
 k4  ,     8        h     X  L  @-0M @0P``  PQ    e  PK    _  PE      P?    S  P9    M  P3     G  P-  $  A  P'  (  ;  P!  ,  5  P  0  /  P  0  04  0   P  8pqo   V  
  p  P
  p@-M0 0 0 @P-  PI     PD     P?     P:  ``   P3     P.      P)   $`  P#  ( }  P  , x  P  000 q  P    0  4   P
  8`q_   U  
 _`  P
p W@-M0p0 p0 `@P  PA      P;      P5      P/      P)      P#       P   0 0  BN0  SOoB @  T$     S  
   0 0C S  $  @  P
  _  p@-M0 0 0 `P{  P-     P(     P#     P     P     P     @P   0  S    0 0C S  $ @  P
p  pA-M00  @P`  Ph      Pb  0 0 F  PZ      PT      PN      PH      PB       P<  $    P6  (    P0  ,    P*  0    P$  4    P  8pL  p  P   W    P  N    P  4 P  P@-M   0 @P  PY     PT   #  PO   3  PJ   .  PE   )  P@   $  P;      P6  $   P1  (   P,  ,   P'  0   P"  4   P  8`Lp `  P   VP 0 6  P  N 1  P  0$  0P0k@-M0p0 p `@P.  P9    h  P3    -  P-    '  P'    !  P!      P  0 0 0 @@  P @  T     S  
   0 S    U@  P
  _  p@-M   0 `P  P'     P"     P     P   z  P   u @P   0  S    0 S   ^@  P
p  pA-M00  @p  P*      P$  0 0 w0 PP  P P  U     S  
 @   0P  0 S  @a  P  0P 
   _}  @-M   0 p`  P   U PP   0  S     0P  0 S  @ AP 0P 
   p@-M00  `@P@  P!    z  P  0 0 0 @@  P @  T     S  
   0 S  ! *@  P
p  p_|  p@-M   0 `P=  P    @P   0  S    0 S   @  P
p  pp@-M00  `@P  P!    !  P  0 0 0 @@  P @  T     S  
   0 S  ! @  P
p  p_z  p@-M   0 `P  P    @P   0  S    0 S   L@  P
p  pA-Mpp0  P`@  P*      P$      P      P      P      P      P  0p   `p@-M` ` 0 P@  P&   5  ;  P     P     P     P   '  P
   "  P     `0]pO-M	0  @p  P.    Y  P(  0 0 0 PP  P P  U     S  
 @    P  0 S  @a  P0  P 
   _w  G-M  0 p`  P    PP   0  S      P  0 S  @ AoP
0	  P 
   0@- @M  P P  #  *
 0   ;     P 0_   00 7   0  Q  
   Q  :       //p@-P @$  Pp  000p@-M 0  0@4/  u   Q   0  Q  :-   
      q  /     @-p@-P @  Pp0     
 0"$ 0  00p0 #40 0  0 @-0@- M 0@4/  lt   Q   0  Q  :@-    @  1      /p@-P @  Pp0   0    0  0"$  0 0  0 0 0  00p 0  3? #40 0  3? #80 0  3? #<0@-M 0  0@4/  r   s@- P$M`p  
  S/  
8  T  0  Q  *1 $<0  S  
 S'   A 6 0   0    <  P  
  0@ @$ A  00 00   $71 $4  @-M  r @pP   
  `P    p = 00 ( 00 0   P7  
  U	  0  PP  % 	 0  E- 0 @-@4/  p  0@- S    S  :0  0@P04DH   P@p`048 `@Pp@ a 4O P@p`0483?p@-P @  Pp0   07    0  0"$  0 0  0 0 0  0<  
 04!  0 0@!8h4&!<8#80  0 $0"$ 0  00p 0  3? #40 0  3? #80 0  3? #<00  0 0  0 0"$  0 0  0 0   @-j@-@-(@-M@   P0 0 0p@-P Q @
  `4  0 6/  p@ 4/  pm  tm  p@-`  @P  0 5/  p0m  p@-@ ,P05/   R  
 
   pm  0p@-  @P  
000  `P  	     p   
000c0   
000c00@- M  
0    P Q  *1  %  
0P
PeA  PA UP! Q: Q:`   @p   0   0P  P   
0P
PeA 71

 PAk    hk    dk  A-   `pQP @P  
6/ P"  
  0 P	  *00 0 0  S	  _   0 0     P
   `00 0 0  S  \ H0H 0     P
,   $}   Xk  j  k  k  j  i  dj  `j   -G-M00 ` @,   @10 p%  
   R8  PpP 0	
P 0  @ R    S0	     P   0  @ R 0  S   G/
 \0\  00  n  P
<   t 0 0 0{   h  4j  Hj  Xh  i  P  @-reg_get_predefined_key_by_name  reg_open_key    reg_key_add_name    reg_val_set HKEY_CURRENT_USER   HKEY_CLASSES_ROOT   ../source4/lib/registry/interface.c:70  No predefined key with name '%s'
   ../source4/lib/registry/interface.c:92  Invalid parent key specified for open of '%s'
  ../source4/lib/registry/interface.c:97  Registry backend doesn't have open_key!
    ../source4/lib/registry/interface.c:214 Backend '%s' doesn't support method add_key
    ../source4/lib/registry/interface.c:234 Backend '%s' doesn't support method set_value
  HKEY_LOCAL_MACHINE  HKEY_PERFORMANCE_DATA   HKEY_USERS  HKEY_CURRENT_CONFIG HKEY_DYN_DATA   HKEY_PERFORMANCE_TEXT   HKEY_PERFORMANCE_NLSTEXT    reg_val_data_string reg_string_to_val   reg_strhex_to_data_blob reg_key_add_abs ../source4/lib/registry/util.c:45   data.length == sizeof(uint32_t) ../source4/lib/registry/util.c  PANIC: assert failed at %s(%d): %s
 assert failed: data.length == sizeof(uint32_t)  0x%8.8x ../source4/lib/registry/util.c:50   data.length == sizeof(uint64_t) assert failed: data.length == sizeof(uint64_t)  0x%16.16llx <No Name>   %s = %s : %s    hex(    %x  ../source4/lib/registry/util.c:144  Could not convert hex to int
   ../source4/lib/registry/util.c:147  dword   0123456789ABCDEF    ../source4/lib/registry/util.c:112  Trouble converting hex string to bin
   DATA_BLOB: ../source4/lib/registry/util.c:176   DATA_BLOB: ../source4/lib/registry/util.c:183   ../source4/lib/registry/util.c:216  ../source4/lib/registry/util.c:245  reg_key_del_abs ../source4/lib/registry/util.c:272  ../source4/lib/registry/util.c:295  Opening parent of %s failed with %s
    %s/%s.ldb   ../source4/lib/registry/samba.c:51  hklm    hkcr    hkcu    hku reg_val_dotreg_string   reg_dotreg_diff_save    reg_dotreg_diff_load    "%s"=-
 
[-%s]
 
[%s]
  ../source4/lib/registry/patchfile_dotreg.c:176  ../source4/lib/registry/patchfile_dotreg.c:88   ../source4/lib/registry/patchfile_dotreg.c  %08x    char    %02X,   "%s"    dword:%s    hex:%s  hex(%x):%s  @=%s
   "%s"=%s
    ../source4/lib/registry/patchfile_dotreg.c:156  struct dotreg_data  ../source4/lib/registry/patchfile_dotreg.c:202  Unable to open %s
  REGEDIT4    %s

    struct reg_diff_callbacks   REG_SZ  reg_dotreg_diff_load    ../source4/lib/registry/patchfile_dotreg.c:244  Can't read from file.
  ../source4/lib/registry/patchfile_dotreg.c:245  ../source4/lib/registry/patchfile_dotreg.c:258  ../source4/lib/registry/patchfile_dotreg.c:261  ../source4/lib/registry/patchfile_dotreg.c:270  Missing ']' on line: %s
    ../source4/lib/registry/patchfile_dotreg.c:271  ../source4/lib/registry/patchfile_dotreg.c:285  Error deleting key %s
  ../source4/lib/registry/patchfile_dotreg.c:286  ../source4/lib/registry/patchfile_dotreg.c:290  ../source4/lib/registry/patchfile_dotreg.c:299  Error adding key %s
    ../source4/lib/registry/patchfile_dotreg.c:300  ../source4/lib/registry/patchfile_dotreg.c:304  ../source4/lib/registry/patchfile_dotreg.c:314  Malformed line: %s
 ../source4/lib/registry/patchfile_dotreg.c:315  ../source4/lib/registry/patchfile_dotreg.c:325  ../source4/lib/registry/patchfile_dotreg.c:332  ../source4/lib/registry/patchfile_dotreg.c:333  ../source4/lib/registry/patchfile_dotreg.c:341  Value change without key
   ../source4/lib/registry/patchfile_dotreg.c:342  ../source4/lib/registry/patchfile_dotreg.c:348  Malformed line
 ../source4/lib/registry/patchfile_dotreg.c:349  ../source4/lib/registry/patchfile_dotreg.c:366  Error deleting value %s in key %s
  ../source4/lib/registry/patchfile_dotreg.c:367  ../source4/lib/registry/patchfile_dotreg.c:371  ../source4/lib/registry/patchfile_dotreg.c:372  ../source4/lib/registry/patchfile_dotreg.c:396  ../source4/lib/registry/patchfile_dotreg.c:401  About to write %s with type %s, length %ld: %s
 ../source4/lib/registry/patchfile_dotreg.c:407  Error converting string to value for line:
%s
  ../source4/lib/registry/patchfile_dotreg.c:415  Error setting value for %s in %s
   ../source4/lib/registry/patchfile_dotreg.c:416  ../source4/lib/registry/patchfile_dotreg.c:422  ../source4/lib/registry/patchfile_dotreg.c:425  ../source4/lib/registry/patchfile_dotreg.c:426  ../source4/lib/registry/patchfile_dotreg.c:427  ../source4/lib/registry/patchfile_dotreg.c:432  reg_preg_diff_save  reg_preg_diff_load  ../source4/lib/registry/patchfile_preg.c:160    [   ;   ]   uint32_t    **DelVals.  ../source4/lib/registry/patchfile_preg.c:150    **Del.%s    ../source4/lib/registry/patchfile_preg.c:130    ../source4/lib/registry/patchfile_preg.c:131    **DeleteKeys    ../source4/lib/registry/patchfile_preg.c:107    ../source4/lib/registry/patchfile_preg.c:108    struct preg_data    ../source4/lib/registry/patchfile_preg.c:184    reg_preg_diff_load  ../source4/lib/registry/patchfile_preg.c:234    Could not read PReg file: %s
   PReg    ../source4/lib/registry/patchfile_preg.c:241    This file is not a valid preg registry file
    ../source4/lib/registry/patchfile_preg.c:246    Warning: file format version is higher than expected.
  ../source4/lib/registry/patchfile_preg.c:257    Error in PReg file.
    ../source4/lib/registry/patchfile_preg.c:282    Error while reading PReg
   ../source4/lib/registry/patchfile_preg.c:292    ../source4/lib/registry/patchfile_preg.c:299    ../source4/lib/registry/patchfile_preg.c:309    ../source4/lib/registry/patchfile_preg.c:318    DATA_BLOB: ../source4/lib/registry/patchfile_preg.c:322 ../source4/lib/registry/patchfile_preg.c:329    Warning: Missing ']' in PReg file, expected ']', got '%c' 0x%x.
    **DelVals   **Del.  **DeleteValues  %s\%s   ../source4/lib/registry/patchfile_preg.c:364    ../source4/lib/registry/patchfile_preg.c:370    ../source4/lib/registry/patchfile_preg.c:379    ../source4/lib/registry/patchfile_preg.c:380    ../source4/lib/registry/patchfile_preg.c:381    ../source4/lib/registry/patchfile_preg.c:382    reg_diff_apply_del_all_values   reg_diff_apply_del_value    reg_diff_apply_set_value    reg_diff_apply_add_key  reg_generate_diff_key   reg_generate_diff   reg_diff_load   ../source4/lib/registry/patchfile.c:505 Error opening key '%s'
 ../source4/lib/registry/patchfile.c:516 Error deleting value '%s'
  ../source4/lib/registry/patchfile.c:519 ../source4/lib/registry/patchfile.c:522 ../source4/lib/registry/patchfile.c:480 ../source4/lib/registry/patchfile.c:486 ../source4/lib/registry/patchfile.c:490 ../source4/lib/registry/patchfile.c:452 ../source4/lib/registry/patchfile.c:460 Error setting value '%s'
   ../source4/lib/registry/patchfile.c:464 ../source4/lib/registry/patchfile.c:402 Error adding new key '%s': %s
  ../source4/lib/registry/patchfile.c:406 ../source4/lib/registry/patchfile.c:410 ../source4/lib/registry/patchfile.c:418 ../source4/lib/registry/patchfile.c:421 writediff   ../source4/lib/registry/patchfile.c:60  Error occurred while getting key info: %s
  ../source4/lib/registry/patchfile.c:61  ../source4/lib/registry/patchfile.c:75  Error occurred while getting subkey by index: %s
   ../source4/lib/registry/patchfile.c:88  Error occurred while getting subkey by name: %s
    ../source4/lib/registry/patchfile.c:89  ../source4/lib/registry/patchfile.c:97  Out of memory
  ../source4/lib/registry/patchfile.c:98  ../source4/lib/registry/patchfile.c:108 ../source4/lib/registry/patchfile.c:109 ../source4/lib/registry/patchfile.c:114 ../source4/lib/registry/patchfile.c:123 ../source4/lib/registry/patchfile.c:124 ../source4/lib/registry/patchfile.c:138 ../source4/lib/registry/patchfile.c:139 ../source4/lib/registry/patchfile.c:155 ../source4/lib/registry/patchfile.c:156 ../source4/lib/registry/patchfile.c:163 ../source4/lib/registry/patchfile.c:164 ../source4/lib/registry/patchfile.c:173 ../source4/lib/registry/patchfile.c:174 ../source4/lib/registry/patchfile.c:179 ../source4/lib/registry/patchfile.c:192 Unable to get value by index: %s
   ../source4/lib/registry/patchfile.c:193 ../source4/lib/registry/patchfile.c:207 Error occurred while getting value by name: %s
 ../source4/lib/registry/patchfile.c:208 ../source4/lib/registry/patchfile.c:215 ../source4/lib/registry/patchfile.c:216 ../source4/lib/registry/patchfile.c:217 ../source4/lib/registry/patchfile.c:224 ../source4/lib/registry/patchfile.c:225 ../source4/lib/registry/patchfile.c:226 ../source4/lib/registry/patchfile.c:269 ../source4/lib/registry/patchfile.c:239 ../source4/lib/registry/patchfile.c:240 ../source4/lib/registry/patchfile.c:251 ../source4/lib/registry/patchfile.c:252 ../source4/lib/registry/patchfile.c:258 ../source4/lib/registry/patchfile.c:259 ../source4/lib/registry/patchfile.c:265 ../source4/lib/registry/patchfile.c:266 ../source4/lib/registry/patchfile.c:292 Unable to open hive %s for backend 1
   ../source4/lib/registry/patchfile.c:301 Unable to open hive %s for backend 2
   ../source4/lib/registry/patchfile.c:325 Unable to determine diff: %s
   ../source4/lib/registry/patchfile.c:348 Error opening registry patch file `%s'
 ../source4/lib/registry/patchfile.c:354 Error reading registry patch file `%s'
 hbin_get    hbin_free   hbin_alloc  hbin_store_resize   hbin_get_tdr    regf_get_key    regf_get_sec_desc   regf_get_value  regf_match_subkey_by_name   regf_get_subkey_by_name regf_get_subkey_by_index    regf_save_hbin  regf_flush_key  hbin_store_tdr_resize   regf_del_value  regf_del_key    regf_sl_del_entry   regf_destruct   hbin_store_tdr  regf_set_sec_desc   regf_set_value  regf_add_key    regf_sl_add_entry   reg_create_regf_file    reg_open_regf_file  ../source4/lib/registry/regf.c:114  Can't find HBIN at 0x%04x
  ../source4/lib/registry/regf.c:120  Trying to use dirty block at 0x%04x
    ../source4/lib/registry/regf.c:308  ../source4/lib/registry/regf.c  assert failed: offset > 0   ../source4/lib/registry/regf.c:320  Trying to free already freed block at 0x%04x
   DATA_BLOB: ../source4/lib/registry/regf.c:171   ../source4/lib/registry/regf.c:188  Invalid zero-length block! File is corrupt.
    ../source4/lib/registry/regf.c:193  Encountered non-aligned block!
 ../source4/lib/registry/regf.c:201  Found free block of exact size %d in middle of HBIN
    ../source4/lib/registry/regf.c:208  Found free block of size %d (needing %d) in middle of HBIN
 ../source4/lib/registry/regf.c:221  No space available in other HBINs for block of size %d, allocating new HBIN
    struct hbin_block * struct hbin_block   ../source4/lib/registry/regf.c:227  hbin != NULL    assert failed: hbin != NULL hbin    uint8_t ../source4/lib/registry/regf.c:258  hbin_by_offset(data, *offset, &new_rel_offset) == hbin  assert failed: hbin_by_offset(data, *offset, &new_rel_offset) == hbin   ../source4/lib/registry/regf.c:259  new_rel_offset == rel_offset    assert failed: new_rel_offset == rel_offset ../source4/lib/registry/regf.c:354  orig_offset > 0 assert failed: orig_offset > 0  ../source4/lib/registry/regf.c:389  ../source4/lib/registry/regf.c:141  Unable to get data at 0x%04x
   ../source4/lib/registry/regf.c:142  ../source4/lib/registry/regf.c:148  Error parsing record at 0x%04x using tdr
   ../source4/lib/registry/regf.c:149  ../source4/lib/registry/regf.c:152  struct regf_key_data    ../source4/lib/registry/regf.c:492  struct nk_block ../source4/lib/registry/regf.c:502  Unable to find HBIN data for offset 0x%x
   ../source4/lib/registry/regf.c:507  Expected nk record, got %s
 ../source4/lib/registry/regf.c:508  ../source4/lib/registry/regf.c:1225 Unable to find security descriptor
 ../source4/lib/registry/regf.c:1230 Expected 'sk', got '%s'
    struct security_descriptor  ../source4/lib/registry/regf.c:1241 Error parsing security descriptor
  ../source4/lib/registry/regf.c:533  Unable to find value list at 0x%x
  ../source4/lib/registry/regf.c:538  Value counts mismatch
  struct vk_block ../source4/lib/registry/regf.c:548  Unable to get VK block at 0x%x
 ../source4/lib/registry/regf.c:549  ../source4/lib/registry/regf.c:564  ../source4/lib/registry/regf.c:573  Read data less than indicated data length!
 ../source4/lib/registry/regf.c:576  ../source4/lib/registry/regf.c:826  Unable to retrieve subkey HBIN
 ../source4/lib/registry/regf.c:835  Error parsing NK structure.
    ../source4/lib/registry/regf.c:836  ../source4/lib/registry/regf.c:839  nk  ../source4/lib/registry/regf.c:842  Not an NK structure.
   ../source4/lib/registry/regf.c:437  ../source4/lib/registry/regf.c:872  Unable to find subkey list
 li  ../source4/lib/registry/regf.c:881  Subkeys in LI list
 ../source4/lib/registry/regf.c:885  Error parsing LI list
  ../source4/lib/registry/regf.c:886  ../source4/lib/registry/regf.c:889  ../source4/lib/registry/regf.c:890  !strncmp(li.header, "li", 2)    assert failed: !strncmp(li.header, "li", 2) ../source4/lib/registry/regf.c:893  Subkey counts don't match
  lf  ../source4/lib/registry/regf.c:912  Subkeys in LF list
 ../source4/lib/registry/regf.c:916  Error parsing LF list
  ../source4/lib/registry/regf.c:917  ../source4/lib/registry/regf.c:920  ../source4/lib/registry/regf.c:921  !strncmp(lf.header, "lf", 2)    assert failed: !strncmp(lf.header, "lf", 2) ../source4/lib/registry/regf.c:924  lh  ../source4/lib/registry/regf.c:948  Subkeys in LH list
 ../source4/lib/registry/regf.c:952  Error parsing LH list
  ../source4/lib/registry/regf.c:953  ../source4/lib/registry/regf.c:956  ../source4/lib/registry/regf.c:957  !strncmp(lh.header, "lh", 2)    assert failed: !strncmp(lh.header, "lh", 2) ../source4/lib/registry/regf.c:960  ri  ../source4/lib/registry/regf.c:984  Subkeys in RI list
 ../source4/lib/registry/regf.c:988  Error parsing RI list
  ../source4/lib/registry/regf.c:989  ../source4/lib/registry/regf.c:992  !strncmp(ri.header, "ri", 2)    assert failed: !strncmp(ri.header, "ri", 2) ../source4/lib/registry/regf.c:1000 Error getting RI list.  ../source4/lib/registry/regf.c:1001 ../source4/lib/registry/regf.c:1013 Error parsing LI list from RI
  ../source4/lib/registry/regf.c:1014 ../source4/lib/registry/regf.c:1017 ../source4/lib/registry/regf.c:1034 Error parsing LH list from RI
  ../source4/lib/registry/regf.c:1035 ../source4/lib/registry/regf.c:1038 ../source4/lib/registry/regf.c:1056 ../source4/lib/registry/regf.c:1060 Unknown subkey list type.
  ../source4/lib/registry/regf.c:628  Unable to find subkey list at 0x%x
 ../source4/lib/registry/regf.c:636  ../source4/lib/registry/regf.c:640  ../source4/lib/registry/regf.c:641  ../source4/lib/registry/regf.c:644  ../source4/lib/registry/regf.c:645  ../source4/lib/registry/regf.c:648  ../source4/lib/registry/regf.c:657  ../source4/lib/registry/regf.c:661  ../source4/lib/registry/regf.c:662  ../source4/lib/registry/regf.c:665  ../source4/lib/registry/regf.c:666  ../source4/lib/registry/regf.c:669  ../source4/lib/registry/regf.c:678  ../source4/lib/registry/regf.c:682  ../source4/lib/registry/regf.c:683  ../source4/lib/registry/regf.c:686  ../source4/lib/registry/regf.c:687  ../source4/lib/registry/regf.c:690  ../source4/lib/registry/regf.c:700  ../source4/lib/registry/regf.c:704  ../source4/lib/registry/regf.c:705  ../source4/lib/registry/regf.c:708  ../source4/lib/registry/regf.c:716  ../source4/lib/registry/regf.c:717  ../source4/lib/registry/regf.c:726  Subkeys in RI->LI list
 ../source4/lib/registry/regf.c:731  ../source4/lib/registry/regf.c:732  ../source4/lib/registry/regf.c:735  ../source4/lib/registry/regf.c:748  Subkeys in RI->LH list
 ../source4/lib/registry/regf.c:753  ../source4/lib/registry/regf.c:754  ../source4/lib/registry/regf.c:757  ../source4/lib/registry/regf.c:768  Unknown sublist in ri block
    ../source4/lib/registry/regf.c:769  ../source4/lib/registry/regf.c:775  ../source4/lib/registry/regf.c:784  Unknown type for subkey list (0x%04x): %c%c
    ../source4/lib/registry/regf.c:806  ../source4/lib/registry/regf.c:808  ../source4/lib/registry/regf.c:2000 Error lseeking in regf file
    ../source4/lib/registry/regf.c:2006 Failed to push regf header
 ../source4/lib/registry/regf.c:2010 ../source4/lib/registry/regf.c:2015 Error writing registry file header
 ../source4/lib/registry/regf.c:2020 Error lseeking to 0x1000 in regf file
  ../source4/lib/registry/regf.c:2028 Error writing HBIN block
   ../source4/lib/registry/regf.c:2169 Failed to flush regf to disk
   ../source4/lib/registry/regf.c:415  Error during push
  ../source4/lib/registry/regf.c:421  ../source4/lib/registry/regf.c:1665 Unable to get VK block at %d
   ../source4/lib/registry/regf.c:1706 private_data    assert failed: private_data ../source4/lib/registry/regf.c:1711 Subkey list is empty, this key cannot contain subkeys.
 ../source4/lib/registry/regf.c:1718 Key '%s' not found
 ../source4/lib/registry/regf.c:1734 Can't retrieve subkey by index.
    ../source4/lib/registry/regf.c:1742 Can't delete key '%s'.
 ../source4/lib/registry/regf.c:1746 ../source4/lib/registry/regf.c:1763 Can't retrieve value by index.
 ../source4/lib/registry/regf.c:1771 Can't delete value '%s'.
   ../source4/lib/registry/regf.c:1775 ../source4/lib/registry/regf.c:1487 ../source4/lib/registry/regf.c:1497 ../source4/lib/registry/regf.c:1502 ../source4/lib/registry/regf.c:1503 ../source4/lib/registry/regf.c:1506 ../source4/lib/registry/regf.c:1508 ../source4/lib/registry/regf.c:1520 Subkey not found
   ../source4/lib/registry/regf.c:1541 ../source4/lib/registry/regf.c:1546 ../source4/lib/registry/regf.c:1547 ../source4/lib/registry/regf.c:1550 ../source4/lib/registry/regf.c:1552 ../source4/lib/registry/regf.c:1565 ../source4/lib/registry/regf.c:1587 ../source4/lib/registry/regf.c:1592 ../source4/lib/registry/regf.c:1593 ../source4/lib/registry/regf.c:1596 ../source4/lib/registry/regf.c:1598 ../source4/lib/registry/regf.c:1611 ../source4/lib/registry/regf.c:1629 Sorry, deletion from ri block is not supported yet.
    ../source4/lib/registry/regf.c:1632 Unknown header found in subkey list.
   ../source4/lib/registry/regf.c:1783 Can't store new subkey list for parent key. Won't delete.
  ../source4/lib/registry/regf.c:2183 Failed to flush registry to disk
   ../source4/lib/registry/regf.c:288  ../source4/lib/registry/regf.c:294  ../source4/lib/registry/regf.c:1088 Unable to push security descriptor
 ../source4/lib/registry/regf.c:1095 Unable to find security descriptor for current key
 ../source4/lib/registry/regf.c:1109 Unable to find prev security descriptor for current key
    ../source4/lib/registry/regf.c:1120 Unable to find next security descriptor for current key
    ../source4/lib/registry/regf.c:1141 sk  ../source4/lib/registry/regf.c:1171 Error storing sk block
 ../source4/lib/registry/regf.c:1185 Unable to find security descriptor for previous key
    ../source4/lib/registry/regf.c:1197 ../source4/lib/registry/regf.c:1888 vk  ../source4/lib/registry/regf.c:1922 DWORD or DWORD_BIG_ENDIAN value with size other than 4 byte!
   ../source4/lib/registry/regf.c:1837 ../source4/lib/registry/regf.c:1841 ../source4/lib/registry/regf.c:1257 Can't store keys in unknown registry format
    ../source4/lib/registry/regf.c:1275 struct hash_record  ../source4/lib/registry/regf.c:1294 struct lh_hash  ../source4/lib/registry/regf.c:1311 ../source4/lib/registry/regf.c:1318 ../source4/lib/registry/regf.c:1331 ../source4/lib/registry/regf.c:1332 ../source4/lib/registry/regf.c:1335 ../source4/lib/registry/regf.c:1372 ../source4/lib/registry/regf.c:1382 ../source4/lib/registry/regf.c:1383 ../source4/lib/registry/regf.c:1386 ../source4/lib/registry/regf.c:1387 ../source4/lib/registry/regf.c:1420 ../source4/lib/registry/regf.c:1430 ../source4/lib/registry/regf.c:1431 ../source4/lib/registry/regf.c:1434 ../source4/lib/registry/regf.c:1435 ../source4/lib/registry/regf.c:1467 ../source4/lib/registry/regf.c:1470 Adding to 'ri' subkey list is not supported yet.
   ../source4/lib/registry/regf.c:1473 Cannot add to unknown subkey list
  ../source4/lib/registry/regf.c:1861 Storing key %s
 struct regf_data    ../source4/lib/registry/regf.c:2053 Attempting to create registry file
 ../source4/lib/registry/regf.c:2060 Could not create file: %s, %s
  ../source4/lib/registry/regf.c:2061 struct regf_hdr regf    Registry created by Samba 4 SambaRootKey    S-1-5-11    ../source4/lib/registry/regf.c:2121 ../source4/lib/registry/regf.c:2142 Error storing sk block, should be at 0x80, stored at 0x%x
  ../source4/lib/registry/regf.c:2206 Attempting to load registry file
   ../source4/lib/registry/regf.c:2213 Could not load file: %s, %s
    ../source4/lib/registry/regf.c:2214 ../source4/lib/registry/regf.c:2223 Error reading data from file: %s
   ../source4/lib/registry/regf.c:2224 ../source4/lib/registry/regf.c:2232 Failed to pull regf header from file: %s
   ../source4/lib/registry/regf.c:2233 ../source4/lib/registry/regf.c:2241 Unrecognized NT registry header id: %s, %s
 ../source4/lib/registry/regf.c:2242 ../source4/lib/registry/regf.c:2250 Registry file checksum error: %s: %d,%d
    ../source4/lib/registry/regf.c:2251 ../source4/lib/registry/regf.c:2272 [%d] Error parsing HBIN block
  ../source4/lib/registry/regf.c:2273 ../source4/lib/registry/regf.c:2279 [%d] Expected 'hbin', got '%s'
 ../source4/lib/registry/regf.c:2280 ../source4/lib/registry/regf.c:2291 ../source4/lib/registry/regf.c:2293 %d HBIN blocks read
    hive_key_add_name   TDB file    ../source4/lib/registry/hive.c:82   strchr(name, '\\') == NULL  ../source4/lib/registry/hive.c  assert failed: strchr(name, '\\') == NULL   local_create_key    local_open_key  struct local_key    ../source4/lib/registry/local.c:61  ../source4/lib/registry/local.c:62  struct registry_local   const char *    ../source4/lib/registry/local.c:202 ../source4/lib/registry/local.c:228 Open/Creation of key %s failed: %s
 ../source4/lib/registry/local.c:229 ../source4/lib/registry/local.c:237 ../source4/lib/registry/local.c:241 ../source4/lib/registry/local.c:98  ../source4/lib/registry/local.c:119 Opening key %s failed: %s
  ../source4/lib/registry/local.c:120 ../source4/lib/registry/local.c:128 ../source4/lib/registry/local.c:132 struct mountpoint   ../source4/lib/registry/local.c:398 cache_subkeys   cache_values    ldb_get_default_value   ldb_del_value   ldb_set_value   ldb_open_key    ldb_del_key ldb_add_key reg_open_ldb_file   ../source4/lib/registry/ldb.c:263   ../source4/lib/registry/ldb.c:268   (key=*) ../source4/lib/registry/ldb.c:332   Error getting subkeys for '%s': %s
 ../source4/lib/registry/ldb.c:337   ../source4/lib/registry/ldb.c:338   (value=*)   ../source4/lib/registry/ldb.c:353   Error getting values for '%s': %s
  ../source4/lib/registry/ldb.c:358   ../source4/lib/registry/ldb.c:359   struct ldb_key_data key classname   type    ../source4/lib/registry/ldb.c:80    ../source4/lib/registry/ldb.c:95    ../source4/lib/registry/ldb.c:110   ../source4/lib/registry/ldb.c:416   Error getting default value for '%s': %s
   ../source4/lib/registry/ldb.c:421   ../source4/lib/registry/ldb.c:430   ../source4/lib/registry/ldb.c:975   ../source4/lib/registry/ldb.c:970   struct ldb_message  ../source4/lib/registry/ldb.c:661   ../source4/lib/registry/ldb.c:666   ldb_del_value: %s
  value=%s    ../source4/lib/registry/ldb.c:675   ../source4/lib/registry/ldb.c:681   ../source4/lib/registry/ldb.c:686   ../source4/lib/registry/ldb.c:692   ldb_set_value   ../source4/lib/registry/ldb.c:136   ../source4/lib/registry/ldb.c:142   struct ldb_val  ../source4/lib/registry/ldb.c:155   ../source4/lib/registry/ldb.c:183   ../source4/lib/registry/ldb.c:189   ../source4/lib/registry/ldb.c:205   ../source4/lib/registry/ldb.c:211   ../source4/lib/registry/ldb.c:231   ../source4/lib/registry/ldb.c:237   ../source4/lib/registry/ldb.c:243   ../source4/lib/registry/ldb.c:828   ../source4/lib/registry/ldb.c:856   ../source4/lib/registry/ldb.c:859   ldb_set_value: %s
  ../source4/lib/registry/ldb.c:860   ../source4/lib/registry/ldb.c:865   ../source4/lib/registry/ldb.c:868   ../source4/lib/registry/ldb.c:291   ../source4/lib/registry/ldb.c:296   key=%s  ../source4/lib/registry/ldb.c:308   ../source4/lib/registry/ldb.c:512   Error opening key '%s': %s
 ../source4/lib/registry/ldb.c:516   ../source4/lib/registry/ldb.c:517   ../source4/lib/registry/ldb.c:524   ../source4/lib/registry/ldb.c:527   ../source4/lib/registry/ldb.c:529   ../source4/lib/registry/ldb.c:726   ../source4/lib/registry/ldb.c:736   ../source4/lib/registry/ldb.c:744   ldb_transaction_start: %s
  ../source4/lib/registry/ldb.c:776   ../source4/lib/registry/ldb.c:777   ../source4/lib/registry/ldb.c:784   ldb_del_key: %s
    ../source4/lib/registry/ldb.c:794   ldb_transaction_commit: %s
 ../source4/lib/registry/ldb.c:800   ../source4/lib/registry/ldb.c:606   ../source4/lib/registry/ldb.c:613   ldb_add: %s
    ../source4/lib/registry/ldb.c:617   key added: %s
  ../source4/lib/registry/ldb.c:621   ../source4/lib/registry/ldb.c:623   ../source4/lib/registry/ldb.c:624   ../source4/lib/registry/ldb.c:629   ../source4/lib/registry/ldb.c:554   ../source4/lib/registry/ldb.c: unable to connect
   @ATTRIBUTES CASE_INSENSITIVE    ../source4/lib/registry/ldb.c:571   hive=NONE   ldb rpc_get_predefined_key  rpc_query_key   rpc_get_value_by_name   rpc_get_value_by_index  rpc_get_subkey_by_index rpc_del_key rpc_add_key rpc_open_key    open_HKCC   open_HKDD   open_HKU    open_HKPD   open_HKCR   open_HKCU   open_HKLM   reg_open_remote struct rpc_registry_context ../source4/lib/registry/rpc.c:115   No such hive %d
    struct rpc_key  ../source4/lib/registry/rpc.c:395   QueryInfoKey failed - %s
   ../source4/lib/registry/rpc.c:399   ../source4/lib/registry/rpc.c:278   QueryValue failed - %s
 DATA_BLOB: ../source4/lib/registry/rpc.c:283    ../source4/lib/registry/rpc.c:230   EnumValue failed - %s
  ../source4/lib/registry/rpc.c:234   DATA_BLOB: ../source4/lib/registry/rpc.c:236    ../source4/lib/registry/rpc.c:319   EnumKey failed - %s
    ../source4/lib/registry/rpc.c:324   ../source4/lib/registry/rpc.c:326   ../source4/lib/registry/rpc.c:418   DeleteKey failed - %s
  ../source4/lib/registry/rpc.c:359   ../source4/lib/registry/rpc.c:360   CreateKey failed - %s
  ../source4/lib/registry/rpc.c:182   OpenKey failed - %s
    ../source4/lib/registry/rpc.c:80    OpenHive failed - %s
   ../source4/lib/registry/rpc.c:79    ../source4/lib/registry/rpc.c:77    ../source4/lib/registry/rpc.c:76    ../source4/lib/registry/rpc.c:78    ../source4/lib/registry/rpc.c:75    ../source4/lib/registry/rpc.c:74    ncalrpc:    ../source4/lib/registry/rpc.c:505   Unable to open '%s': %s
    ../source4/lib/registry/rpc.c:506   rpc default/source4/lib/registry/tdr_regf.c:78  default/source4/lib/registry/tdr_regf.c:176 default/source4/lib/registry/tdr_regf.c:217 default/source4/lib/registry/tdr_regf.c:240 default/source4/lib/registry/tdr_regf.c:263 default/source4/lib/registry/tdr_regf.c:327 tdr_push_to_fd  tdr_print_debug_helper  %-25s: 0x%02x (%u)  %-25s: %s   %-25s: (time_t)%d   %-25s: DATA_BLOB length=%u  DATA_BLOB: ../lib/tdr/tdr.c:343 struct tdr_push struct tdr_pull ../lib/tdr/tdr.c:376    Error pushing data
 ../lib/tdr/tdr.c:377    ../lib/tdr/tdr.c:382    Error writing all data
 ../lib/tdr/tdr.c:386    ../lib/tdr/tdr.c:405            ../lib/tdr/tdr.c:407                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        =  <         b   lb   <d   Pd   hd   td   d P  d `  d           p>   =    <   0<   p;   :   9                (    | T ,                    D     T     g     v                                             '     6     B     Q     [               2     b    0          4       o     T       
   ~                          ,     (*             o'  o          o   o'  o   o%  oB                                                    2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2                                                                                                  ,      p          `               ` P " ) %     (             L  \0     - 8 l7 6     4 2                     $1     A,   aeabi "   6 	
"1798bd32c587e655ef5c116c78ca465e71159a.debug     .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o                      (             p              0         T  T  ~                 8   o   %  %                 E   o   '  '  8                T   o   '  '  0               c   	      (*  (*                 l   	   B   ,  ,                u         2  2                    p         2  2                  {         ;  ;  $&                         b b                            b b pi                                                       0 0                           4 4                           8 8                            < <                                                        `                                                                                 p         -                                 4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   :742    IKI ../source3/libsmb/pylibsmb.c:712    s#  ../source3/libsmb/pylibsmb.c:717    Is#K|I  ../source3/libsmb/pylibsmb.c:674    K   ../source3/libsmb/pylibsmb.c:638    s|IIIIIII   ../source3/libsmb/pylibsmb.c:614    level   fnum    {s:i,s:i}   samba.credentials   Unable to import %s to check type %s    Unable to find type %s in module %s poll_mt pylibsmb_tevent_mt  struct py_cli_thread    ../source3/libsmb/pylibsmb.c:220    py_cli_state_shutdown_handler   ../source3/libsmb/pylibsmb.c:236    ../source3/libsmb/pylibsmb.c:248    ../source3/libsmb/pylibsmb.c:249    myname  ?????   ../source3/libsmb/pylibsmb.c:455    ss|O!   ../source3/libsmb/pylibsmb.c:894    libsmb wrapper  libsmb_samba_internal   Conn    Name    CreateFlags DesiredAccess   FileAttributes  ShareAccess CreateDisposition   CreateOptions   SecurityFlags   buffer  offset  size    flag    mask    attribute   info_level  host    share   libsmb_samba_internal.Conn  libsmb connection   create  Open a file close   Close a file handle write   Write to a file handle  Read from a file handle truncate    Truncate a file delete_on_close Set/Reset the delete on close flag  readdir List a directory    get_oplock_break    Wait for an oplock break                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            h*   *                                                 %     4     C     Y     c               #     R     |l          l       o     h
     x  
              m                                        o   o(  o   o  o                                           l         #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #                                              ELF          (    db  4   Q   4    (                  : :          \I \I \I <  H           I I I                       $   $         Qtd                          Rtd\I \I \I                    GNU ?8a%	: q      @        x !	    d          0",L   @!m@D@(@  5(    ( 
@#@ @          @   `a  @G	    !  0$   @P `U0 !Pb@0 P @   B P(
  &A   d $   
@!  @ E S@                                                                                                                                       	                                                              !  #  $              &  '  *  +  ,  -  /  0      2  4  5                  7  8  9      :  =  ?  @      B                      C  D  E  F  G      H      I  J      K  M  P  R  S      U  W  Z                      [  \  ^  a  b  d  e  h  k  l  m  n  p  s  t      u  v      w      x  z          |  }          ~                                                                                                                          @iP,NeoV0XGOJ'X?B9*|`Y&Ea?Q4FmSA,O!	v:vXZ[hy~K	=G2HQRF9;e{SwC)L&6FzY|l/nL:J}l/""B]65r|+Mshz\vk7:eTm9g1J-w-YzS%[X o>lQm{({W "3LTG;1Wj:dQ_
g)k~|fe`7]SNiWC\
CEA;?Fm*|<O6AC+@^yGYT$'GsEKY*6*FN`n%qu*9wb_]C7>*}lHEIUK)KDJ{r#65l}6BclqQ9z\Xyq>&_a=l%b<53tGs"Kc-%7d_81wMqX\"'$dD{wT<N|'>Z%h"/+
Y 4DWkaW;c;Wp/P                    lU       
     dI       [                          F                                                    :                          &             +             ^
             	                                                    c                                       1                                                                    [                            L                          
                          <	                                                                 J             +             s                                       h             ^	                                                                                                         {             d                          ;             3             o                          m                                                    1                          }                                         	             C                          L                          P                                                    ~	                           W                          H
                           2                            .                                                                                           R             0                          0             ,             x             L             v                                                    
             "             *                           	                                                    d                          
                                                                                                         C                          	             \                                        n                                       
             .                          q             &                          Q             R	                                       ^                           h                                       V             	                                       Q             _                                                                 z                                                                 z             B             1                          u	             N                           j
             =             z                           R             d                          o                                        o             5                          _                          2             h                                       ]                                       l                          X                                       (                                                                              F                                       c                                                                                                                                     _             L           "   	             c             !             ?             e                                       E         =    L      _     y  p         8                #  3 \     2  T  h     T  (  4    Q                   |      m  {         `          r       	  0  t       L~         d       p  \             q  (     *   8       lU       
     P      f X        8     M   m 	    k    T        4    N            8     !         d    h     !           n     P     v  u       E           H       u       N   (     N    P       Dv       e   (     M  D         t            <  H4      X  L        > `        p                 ,E     ~  P        ,         >         p     .
  <  P     8  P  8                o       R                     h      `      -  D |    
  y  l       `W       p                P         ,    &         q  dz ,      $      u  T P    s        j  h<       D       0  `        x          @     p  ,  L    z   H       r  |              :  G 4      \                 <n                 p}                 (                 X       |               )             $    C            x    7   {       !  P                 $  L    2  ,     X           \ d        P    I  0  ,       `y  x       1 @              4y  ,     C  @  t     	    L        L    +           T 8       L  <     t           p       !    l     `    X      (w         y  ,                ,       p           <  $                 @       |       #  Dz       g          
    X         @      d P    	  8         t/ 8    
    <        `         D       @       *    X     <!  P          ,       ps       6  h  ,     D               x  t  \     d  p  (       d  d    
  <  X     :  x  \       @  x                              d  n  0     [  v       $        $       L  h     x   T    v  L       !  P         ~       \  (            n  \          Hx  8     "!  P         0      D!  P                        
    X     >  T  D     K   t              >    t     R         1!  P          t                  <       r  H       H  p             0!  P         h        y           (     i  x  (               	  (  d      __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _talloc_get_type_abort _tevent_req_data read memmove memchr dbghdrclass dbgtext waitpid __errno_location _tevent_req_error _talloc_free _tevent_req_done DEBUGLEVEL_CLASS kill samba_runcmd_send _tevent_req_create talloc_strdup _tevent_req_nomem pipe fork set_blocking smb_set_close_on_exec _talloc_set_destructor _tevent_add_fd tevent_fd_set_auto_close timeval_is_zero tevent_req_set_endtime tevent_req_post tevent_re_initialise dup2 str_list_copy str_list_add execvp __fprintf_chk _exit fwrite stderr samba_runcmd_recv tevent_req_is_unix_error tevent_req_received samdb_set_password_callback ldb_request_done ldb_reply_get_control _talloc_steal_loc drsuapi_DsReplicaCursor2_compare GUID_compare ldb_dn_compare ldb_msg_find_element ldb_msg_add_empty ldb_msg_add_string smb_panic samdb_search_string_v gendb_search_v ldb_msg_find_attr_as_string samdb_search_string samdb_search_dn samdb_search_count samdb_search_uint ldb_msg_find_attr_as_uint samdb_search_int64 ldb_msg_find_attr_as_int64 samdb_search_string_multiple _talloc_array samdb_result_dn ldb_msg_find_attr_as_dn samdb_result_dom_sid ldb_msg_find_ldb_val talloc_named_const sid_parse samdb_search_domain dom_sid_in_domain samdb_search_dom_sid samdb_result_rid_from_sid samdb_result_guid GUID_from_ndr_blob GUID_zero samdb_result_sid_prefix samdb_result_nttime ldb_msg_find_attr_as_uint64 samdb_result_last_logoff samdb_result_account_expires samdb_result_allow_password_change samdb_result_hash memcpy samdb_result_hashes samdb_result_passwords_from_history lpcfg_lanman_auth samdb_result_passwords_no_lockout samdb_result_logon_hours memset samdb_result_acct_flags ds_uf2acb ldb_dn_get_linearized samdb_result_passwords samdb_result_parameters samdb_find_attribute strcasecmp samdb_find_or_add_attribute samdb_msg_add_dom_sid ndr_push_struct_blob ldb_msg_add_value ldb_error_at ndr_push_dom_sid samdb_msg_add_delete samdb_msg_add_addval strlen _talloc_realloc_array samdb_msg_add_delval samdb_msg_add_int talloc_asprintf samdb_msg_add_uint samdb_msg_add_int64 samdb_msg_add_uint64 samdb_msg_add_hash _talloc_memdup samdb_msg_add_hashes samdb_msg_add_acct_flags ds_acb2uf samdb_msg_add_logon_hours samdb_msg_add_parameters ldb_msg_add_steal_value samdb_msg_set_uint dsdb_autotransaction_request ldb_transaction_start ldb_request ldb_transaction_cancel ldb_wait ldb_transaction_commit ldb_msg_new ldb_build_mod_req ldb_request_add_control _talloc_zero ldb_errstring strtol samdb_default_security_descriptor security_descriptor_initialise samdb_aggregate_schema_dn ldb_get_schema_basedn ldb_dn_copy ldb_dn_add_child_fmt samdb_partitions_dn ldb_get_config_basedn samdb_infrastructure_dn ldb_get_default_basedn samdb_sites_dn samdb_domain_sid ldb_get_opaque ldb_search ldb_set_opaque samdb_domain_sid_cache_only samdb_set_domain_sid talloc_check_name dom_sid_dup samdb_set_ntds_settings_dn samdb_ntds_settings_dn ldb_dn_new samdb_ntds_invocation_id GUID_all_zero samdb_set_ntds_invocation_id samdb_ntds_objectGUID samdb_set_ntds_objectGUID samdb_server_dn ldb_dn_get_parent samdb_server_site_dn samdb_server_site_name ldb_dn_get_rdn_val samdb_client_site_name socket_allow_access samdb_search_for_parent_domain samdb_check_password strlen_m lpcfg_check_password_script check_password_quality tevent_context_init tevent_timeval_current_ofs _tevent_add_timer tevent_req_poll samdb_set_password samdb_dns_domain_to_dn str_list_make ldb_binary_encode_string ldb_dn_add_base_fmt ldb_dn_validate samdb_dn_to_dns_domain ldb_dn_get_comp_num talloc_asprintf_append_buffer ldb_dn_get_component_val samdb_ntds_msdcs_dns_name ldb_get_root_basedn samdb_domain_to_dn dsdb_msg_add_guid talloc_init GUID_to_ndr_blob dsdb_load_partition_usn ldb_build_search_req ldb_search_default_callback drsuapi_DsReplicaCursor_compare samdb_set_am_rodc samdb_ntds_site_settings_options samdb_ntds_options samdb_is_gc samdb_ntds_object_category samdb_cn_to_lDAPDisplayName __ctype_tolower_loc __ctype_toupper_loc dsdb_functional_level dsdb_forest_functional_level dsdb_set_extended_dn_guid ldb_dn_set_extended_component data_blob_free dsdb_get_extended_dn_guid ldb_dn_get_extended_component samdb_dn_is_our_ntdsa GUID_equal dsdb_get_extended_dn_uint64 strtoull __stack_chk_fail __stack_chk_guard dsdb_get_extended_dn_nttime dsdb_get_extended_dn_uint32 strtoul dsdb_get_extended_dn_sid ndr_pull_struct_blob_all_noalloc ndr_map_error2ntstatus ndr_pull_dom_sid dsdb_dn_rmd_flags dsdb_dn_val_rmd_flags memmem dsdb_dn_is_deleted_val dsdb_dn_is_upgraded_link_val dsdb_find_nc_root ldb_dn_alloc_linearized ldb_msg_add_steal_string ldb_dn_from_ldb_val qsort ldb_dn_compare_base dsdb_tombstone_lifetime samdb_ldb_val_case_cmp strncasecmp dsdb_request_add_controls dsdb_add ldb_build_add_req ldb_op_default_callback dsdb_modify dsdb_savereps ndr_push_repsFromToBlob dsdb_delete ldb_build_del_req dsdb_replace dsdb_search_dn dsdb_find_guid_attr_by_dn dsdb_find_guid_by_dn dsdb_find_sid_by_dn dsdb_loadreps ndr_pull_struct_blob ndr_pull_repsFromToBlob dsdb_wellknown_dn ldb_dn_new_fmt samdb_create_foreign_security_principal dom_sid_string ldb_add dsdb_get_deleted_objects_dn dsdb_load_udv_v2 timeval_to_nttime ldb_sequence_number ndr_pull_replUpToDateVectorBlob dsdb_load_udv_v1 dsdb_search_by_dn_guid dsdb_search talloc_vasprintf ldb_reset_err_string samdb_reference_dn ldb_asprintf_errstring samdb_find_site_for_computer ldb_dn_remove_child_components talloc_strndup samdb_find_ntdsguid_for_computer samdb_reference_dn_is_our_ntdsa samdb_is_pdc samdb_server_reference_dn samdb_rid_manager_dn samdb_rid_set_dn dsdb_find_dn_by_guid dsdb_find_dn_by_sid ldap_encode_ndr_dom_sid samdb_is_rodc ldb_msg_find_attr_as_bool samdb_rodc dsdb_search_one samdb_forest_name ldb_dn_canonical_string strchr samdb_default_domain_name dsdb_validate_dsa_guid dom_sid_equal dsdb_get_fsmo_role_info samdb_dn_to_dnshostname dsdb_attr_in_parse_tree is_attr_in_list dsdb_attr_in_rodc_fas dsdb_werror_at win_errstr dsdb_ldb_err_to_ntstatus samdb_set_password_sid _talloc_stackframe timeval_current dsdb_trust_search_tdo_by_type ldb_msg_find_attr_as_int ldb_strerror _talloc_zero_array ldb_modify nt_errstr ndr_map_error2string ndr_pull_trustAuthInOutBlob ndr_push_trustAuthInOutBlob dsdb_create_partial_replica_NC ldb_msg_add_fmt NS_GUID_from_string sscanf NS_GUID_string samdb_result_effective_badPwdCount dsdb_update_bad_pwd_count dom_sid_split_rid dsdb_user_obj_set_defaults dsdb_user_obj_set_account_type ds_uf2atype ldb_set_errstring dsdb_user_obj_set_primary_group_id ds_uf2prim_group_rid _talloc_move strchr_m strcasecmp_m dsdb_trust_forest_info_from_lsa dsdb_trust_forest_info_to_lsa dsdb_trust_xref_tdo_info dsdb_trust_xref_forest_info ldb_msg_normalize dsdb_trust_parse_tdo_info dsdb_trust_parse_forest_info ndr_pull_struct_blob_all ndr_pull_ForestTrustInfo dsdb_trust_normalize_forest_info_step1 strstr_m dom_sid_compare dsdb_trust_normalize_forest_info_step2 dsdb_trust_verify_forest_info dsdb_trust_merge_forest_info dsdb_trust_search_tdo dsdb_trust_get_incoming_passwords mdfour dsdb_trust_search_tdos dsdb_trust_routing_table_load dsdb_trust_routing_by_name dsdb_expand_nested_groups ldb_dn_minimise ldb_dn_get_extended_linearized dsdb_add_user dsdb_add_domain_group dsdb_add_domain_alias dsdb_enum_group_mem dsdb_lookup_rids ds_atype_map dom_sid_add_rid data_blob_hex_string_upper dsdb_dn_oid_to_format strcmp dsdb_dn_construct dsdb_dn_parse data_blob_named strhex_to_str data_blob_null dsdb_dn_get_linearized dsdb_dn_get_casefold ldb_dn_get_casefold dsdb_dn_binary_canonicalise data_blob_string_const dsdb_dn_string_canonicalise dsdb_dn_get_extended_linearized dsdb_dn_binary_comparison ldb_any_comparison dsdb_dn_string_comparison drs_ObjectIdentifier_to_string talloc_asprintf_append drs_ObjectIdentifier_to_dn dsdb_acl_debug ndr_print_struct_string ndr_print_security_descriptor ndr_print_security_token dsdb_get_sd_from_ldb_message ndr_pull_security_descriptor dsdb_check_access_on_dn_internal insert_in_object_tree sec_access_check_ds dsdb_check_access_on_dn gendb_search gendb_search_dn libpthread.so.0 libflag-mapping.so.0 libcli-ldap-common.so.0 libndr-samba.so.0 libsamba-hostconfig.so.0 libsamba-sockets.so.0 libsamba-util.so.0 libsamba-errors.so.1 libndr.so.0 libsamba-security.so.0 libsocket-blocking.so.0 libtevent-util.so.0 libutil-tdb.so.0 libsamba-debug.so.0 libldb.so.1 libtalloc.so.2 libtevent.so.0 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end libsamdb-common.so.0 /usr/lib/arm-linux-gnueabihf/samba SAMBA_4.5.16_DEBIAN GLIBC_2.4 TEVENT_UTIL_0.0.1 SAMBA_ERRORS_1 TEVENT_0.9.9 TALLOC_2.0.2 LDB_0.9.23 LDB_0.9.15 LDB_0.9.10 SAMBA_UTIL_0.0.1 NDR_0.0.7 NDR_0.0.1 SAMBA_HOSTCONFIG_0.0.1                 	      
     
        
             
                          
 
 
  
                     
        
                  
                             
        
                   
                            
    
  
   
        
                                                                                                                                                                                                               
      I!                  !                  ii   !                     !                     !                    !                 ii   !        v             !                     !        >             !                    !                  )   !                  "  
 !                   	 !              @   4   !     4   !     4   !        +          T   !        _             !                  ii   !        S      0   A#   "     A#   "                 Q5    "      \I    `I    hI    lI    pI    tI    xI    |I    I    I    I    I    I    I    I    I     P    P    P    P    P    P     P    (P    0P    4P    8P    <P    @P    HP    LP    TP    XP    \P    `P    dP    hP    lP    tP    xP    P    P    P    P    O   O   O   O   O )  O 3  O 5 O B  O  O R  O V  O X  O l  O s  O ~  O   O  O   O   O   O   O   O   O 
 O   O   PK   TK   XK H \K   `K  dK   hK   lK ' pK   tK 	  xK $ |K 
  K ? K   K   K   K   K @ K   K J K p K   K   K 0 K   K   K   K   K   K   K   K m K   K   K   K   K   K    K   K !  K "  K #  K $  K %   L &  L '  L ) L (  L *  L +  L ,  L -   L * $L  (L .  ,L /  0L 0  4L 1  8L 2  <L 4  @L 5  DL 6  HL 7  LL 8  PL 9  TL :  XL ;  \L <  `L R dL =  hL >  lL ?  pL @  tL   xL A  |L  L C  L  L D  L E  L F  L G  L - L H  L b L I  L J  L K  L L  L M  L e L N  L 4 L G L O  L P  L   L  L Q  L S  L T  L U  L   L w L W  L f L  L Y   M   M  M Z  M [  M \  M ]  M ^  M _   M `  $M a  (M   ,M } 0M  4M b  8M c  <M d  @M e  DM 7 HM  LM f  PM g  TM h  XM i  \M j  `M k  dM m  hM n  lM o  pM d tM p  xM q  |M r  M t  M u  M v  M w  M  M x  M y  M z  M {  M |  M }  M  M   M   M   M   M   M   M I M   M   M   M  M   M   M W M   M   M   M # M   M   N   N = N   N   N   N   N   N    N   $N   (N L ,N   0N V 4N   8N  <N   @N   DN  HN x LN   PN   TN  XN   \N   `N   dN   hN   lN   pN   tN v xN   |N   N   N   N  N   N   N , N   N  N  N   N   N   N  N  N k N 	 N   N  N   N Y N   N   N   N   N r N   N  N O N   N   N   N    O   O   O   O   O   O o O   O    O   $O   (O   ,O   0O   4O 3 8O   <O   @O   DO   HO   LO [ PO   TO   XO   \O   `O  dO   hO   lO   pO   tO   xO   |O   O c O  O   O   O   O   @-; -  / / / / / / / / /| /t /l /d /\ /T /L /D /< /4 /, /$ / / / / / / / / / / / / / / / / / / / / /| /t /l /d /\ /T /L /D /< /4 /, /$ / / / / / / / / / / / / / / / / / / / / /| /t /l /d /\ /T /L /D /< /4 /, /$ / / / / / / / / / / / / / / / / / / / / /| /t /l /d /\ /T /L /D /< /4 /, /$ / / / / / / / / / / / / / / / / / / / / /| /t /l /d /\ /T /L /D /< /4 /, /$ / / / / / / / / / / / / / / / / / / / / /| /t /l /d /\ /T /L /D /< /4 /, /$ / / / / . . . . . . . . . . . . . . . . .| .t .l .d .\ .T .L .D .< .4 ., .$ . . . . . . . . . . . . . . . . . . . . .| .t .l .d .\ .T .L .D .< .4 ., .$ . . . . . . . . . . . . . . . . . . . . .| .t .l .d .\ .T .L .D .< .40 0   R/" X  404 0  0 0C S 00/ 0  S//    p  88    A,0A0/ 0  S//  L x  L0L 0  0  S/80@-0  S  
(0 0 0  d     $ 8 80    0  R     0  S
@-3/@  \  O-P@XX$ $M D p8$8 0 ` SP  
0 U  
$  
B $+bQ P_  @@t@@  T
3$p00300300	  +d 0@Ct@  T@
 
 h PPH0E   
  U@  $  RPZ0 0 0 Z0  
 3  P
0 p    TZ  20 0 0 Z  2"
 0   P  
0   p  00&  0 U%  
  U*  
  S  R     0 P2  
20 0 0   @
 R   
  S8    R
0  01 0 0?ki@y   U   0 R0V  S*  1 0 0?NL L1 0 0 0 S5    R.  
H1 0 0?=;010!  0   P  
  P     *  0   0   P	  
  P `  0      Y0 0     P  
|      6 5 8 6 (6 @5 7 7 d  4 6 t6 5 3 3 04 4 x2 3 3 ,2 2 2 4 1 3 3 @- @    P  	     0 0  p   
#  G-8M`t  Y p  
$4   `0$a @P  
PX  0  \ 0   0L$     P|      Pp  (   P  0  Pw  P0   P u  
  U  
$ , 0 04 (    
0
s 0
 0p	 	0 0 T %PD   0 @p  0#   0  P   P20  0 0 0"   0  P      P    -  t20   0 ?- E @ 8  t$ r( p, n20  h$ fy 20 @  ^( \4 Z X V T <0 $ , $ G, E0 C	   Pd@  @  i  P   
@@  Q0  010 @@  >!  0 l   0   @0  0   0 	  $ 
( , 0 4 00{ }\0h  0   0 $ T3 1 (  3 3 x$2 2 2 2 H1 ,1 0   1 0 / ,0 p@- PG @P    p  pp@- @Q  
 ` P  V  0 S  
  p@t h    X   p@8 u,    4 h4 4 4  4 ,4 <4    ol-Md  0 0 0 0  S  808   0   P
   ( d  . H4 X4 A- @SM1 P0'  
 `p  P   
  U     @  
  0  @P  X  
    P    U0 0 @  @l 0 0 0  S  X   P0P 0 0 \  P
0000 0/  x d  (4 p- 3 3 3 3 @-$MP8`<0 0 @0@P@@00 P   0 0 0 S   a  $0   $L0L 0 p40   P
( 0    d  3 h,  3  3 -M >0-0@-M($0 @0 @0@P] P  08   0  $ @  0@/2 2 0-@-M($0 @00 @:@/0@-$M840P@ 0 0 0P% P  
 $00   h @ $0p@- M<84`P0 0 @00 ` P  
  p  0   @P  pC-$MHDP@`p0 @  00@@`@ P@%    0@    @ Q   \ 1  0  P  1  
 P     0	 P T 0  ! $00 0 0  S  | @s $d0d 0 L0  4  P  
D     , [ @ x1 d  0 ( \0 X0 0 @-@  P 0p@- @ * PP  
P   D @P  
   PP  
 p @ /@T0 $0 O-$MTH@P@pW PP%  00	0
 @	   0E PE
 T   0	  & `PL 
  P
 @ T $ 0 / / A- M<8`@0 0@0 P@P00 P   0 0 0 S    @  0   l @   P0P 0 pl0   P
, 0    d  X/ H/ & . , @-@  P  
00A . 00@-M @ z  P  
  P     0 D 0@-  P0  S0C0  A  0@-  ;0  @.   0@-  00   . A-M `p  0(  ! @P0  
40  00      0-  T- 0p@- P % @P  
0 S  4     R #g 0 p 0 pt- A-  `	 @ @ pP  
P%R   P l0 0 J  P  
       00 @0@  X0 , C-M,Pp  U` (@	  
 0  P 002 0  T  
   P   0 0  4 	 0 y  V* 0  b `h, , A-Mp @`  TP   
 0 a  P    
 P  p 0 0  U  
 W  P   0 0  4  0 F  P
 P 0 0+   l+ A- @M x 0P0 0 pP  
`0 a0   P   
 `     H0 0   P 
 0  0 00000 + * A-P   p  Up @	  
   P `  
   @ `00 0 0  SL0L  00    P
  /     T*  d    ) ) @-`M P p@<00  
 0 0 0 S  x  0  00 #L0L 0 0    P
       L)  d  4 4 ) ) A- p P  U 0 00  P `  
 @  
| x0  0  P   
0 00  
  @0 0$   S  _  D) A- ` P  
P  U  
p @   T  
 @  P   -M    0|@-tM@ `Pp 0( ' 0P    ,0,  0(0 0  `    ' l#    0O-M @ P P7  
w P	 1  
`  V  
p @ @}@  P  "  R  
 V0  j  P  p 0 0     0P  
   0L0L  0H0 0 >000  0,0 0 4& ?  & " ]  X& ! O-M @ P P7  
 P	 1  
`  V  
p @ @@  P  "  R  
 V0    P  p 0 0     0P  
   0L0L  0H0 0 000  0,0 0 % w  %     $ l  p@- ` P@ P  P  
 p@$0$ 0 0 0 p@$   `$  p@- ` P@P!  P  
 p@$0$ 0 0 0 p@L$   # t p@-PMt0 `@  0 :  P   
  0 p(0(  0$0 0 rp#   P#  A-M`,@0 p0 P x20  P   
  T  
(0       p  Tp0  0 ? 0 0 0 8h# h"  A- @ P`p0   Az@-M @@. 0 x@-M @p   
`0 P0   P    
0 0  
0      0      ,  S  p   A- `p P@   P 000 A$p@-` P @P  
 p 0 @P  
  p,  @P p@GO-M  `@PX?up @P  
  Z D0	  
  U  S  
 7  S  U 
  U  
l P0  8  P   D0  S0 0  
(UD0P 0 0 %  P   0 04       0   P  L0H   R  S    Z    Y  
 0    P  x 0    Pf   8 P   Y  
<$<	  ;,$,  5$      T0  S  
#    P7  
  Y	  
   T0  P0  S  
  Y  
P 00 0t	  U  
  UH  
2 U`
  U ]
@30 0 0  S  U$S
 P 0M Ps
 _  _<"  ` 0P  
L   H    m  Ph
  _ p _\X L _8 0  I  PF
  ~_ x_ r_ l h_  Y|
w  @@ `P
 410 0 0  S P!  0 Vx
V U
T1 UPrP0 ^<1<!0 0  
  Pd
  4 @ f     Y0 0@0    P
   u  P
   o    P l  H!  ! ! ! ! ! ! " " ! d       d X l @ j    , ( <  t 0 D -  l  ( p X    Df .@-@ P
  
  @P  
   P  
  @ 8 p@-@J  0 @ PP  
 p @  p@-@  0 @ PP  
 p @  p@-@  z0 @ PP  
 p @  A- MaQ` 0PP0 p @P  
     * P*  
 0 @0000  0   P  0   R  0    PP  
  U  P
  H   8 @U$ P  |   , 8 Tt G-a P`L@,   @   pP	  
 P  
    P  
00 0 0  S        t h	  T0T 0 0    P
4   QX < $  d      <   G-a P`@   @   pP	  
 P  
    P  
00 0 0  S        Vt h	  T0T 0 A?  |  P
4       d  t    	   C-`Q$M 0PP0 qp @P  
 ^ @ $!  + P%  
h! 00@ @ 	 0   P#  0   R   	0   6!  @  	 ] $0P 0 0  S  	 P $0P 0 0  S0 0 >   P
 j l   `0` 0 >    P
@   |        d   ,      O-4Mrbp` (`, RP @P  
 P   4" 	  P6  
	 (00@ @$  0	 W P(  $0 0 S$  ("   @P  
$0
 0       P*   	   P
  ! 	 _  10 0 0  S     x1x!0 N?  }  P
X  $00  $1@ 0 0 P  
  S1!0 N? b  P  
    0 0  S0 0N? R  P
    0 000 0 0 S     0 0 N? 9 P
p0pp 0l   0  | h 4   d     |    @ $ 4      0 o  G-@ pQ!  xa`   P  
`!  PP  
   P0        P  
10 0 0  S  	      	 
  0 0 U?    P
   Qx00 0 0  S     Wx0x  0U?    P
X0XX 0T   5  D l d     ( < 0 4 L    	 ,	   C-4Maq` 0p(p,0 lQP @P   
4T!  _ P2  
	 (00@ @$ 	 0   P$  $0 0 S     	 F @P  
$0 p0  t      P
     	  |00 0 0  S  h	 w  T0T 0 ]?  9  P
4     P     d  l     G-P pc !  ``   P  
   @P  
    2  P  
00 0 0  S  	 2     t	 'h
 # T0T 0 c?    P
4   g    d  <        \ p@- @ `   PP  
   o  @  p@  p@-`~ PP  
 \D @   T	  
 R  P  p Pp l @-(  P  O- P DM4@ `  X  0,`0`	 z  
 0P0  
 L  pPr  
0( X 0	 
  PU  
  Pr  (0    R N  
!  @ p,$0  	0
  ` ,`  P  0@ S.  
(0( $0  !A 0P
0  0@ p d  W  
 @  T  
    W  S( O D0 0	 g P   
  ` p p D 3 /pl (` p#	  ` p(  h ,    t        < P O-,M ` "   0 `$`10 PPl  
p@ $  @Y  P'   0   R<  
 a	  @P0  0   R/  
 l   %\1P   0 0 0  S1  @ p , p  `  @  0    P0    ,0   0  p ;0    ,0 0 j? b  P
P0h    X0X  0T0 0  p D  P d     , 8   | x      G-8M P  X`p5 P\c 3`  *8   
  P @   8	  pP  
 0  S	  P %  P
  8"2 0  0p( ,04 PK  

  %      	 	0
  
d (    		 K 4"4 /     T	  
  	 
   00	
   P   	 
  
 
  @	 0n Sp1  
P 0 0 S)    T  
 0 0  S  @ n0 0 0  S)   
 \  V0 0 r?    P
   0 0 r?  r  P
    0  0r?  b  P
t    x P T 0 P          d  (      P T         0@-$M480<P@@D H0 00P@00$0G-@!P `    	 pPR  
! H @PN  
   j   Q `  
|    Q  
 p   P   PD10 0 0 S  0 , `    P  
 ! 00 0 0 S     ` 0 0 >    P
       T` `l0l 0 >    P
  @   ;    d     X    x     C- @M p?  ] `P/  
  X   P	      a @P  
 X`  
 P	 @P l @ 0  S
  0  0@ (  @L  x X A-@ `  p  5 Pz @P  
 @ 0P  
 - 0P  
p  ` @ t H n8 @h$ @b@      1G-@ M0 P`   0  T
 p D1000p0   0  pP  0   Y
  
 Y2  00 0 0  S       0 0000  0   P0   R0 0   p0p 0 ~?  P
T    S 0   ,0 p0( t  d   H  D D D C-  M  `pw   @ `` P!    } PP  
x00 0 0 S  d  L0L 0	?    P
,   P  d    0    G-"(M p  PO" 
 @) `PU  
l"  \" 00000 0 ` 0$ _ P"  " $ + 0P"  
 
 p$ 9 P'   $ PP:  
0  Sd     0  g
 ( `
 ( Yx1x! 0t1 0 n X J
 (@ C> 0,!,1 0 X 
 ($0, '0  S P
  P"   0  S     0  Y    
 (    0    Y 
 |   0   `     T      @   @    @ h   t     t  A-   p@@ PP  
   `P  
     P  
00 0 0  S     t   Wd  P0P 0 ">    P
0   d  h T d    (   0 4 C- 0LL!$M 0 P@(a` @P  
  0P  
!       pP  0   R%  
00 0 0  S   t0  00  /0  p $0 0 ?  *  P
`   0   @   N@ @  , d  t     0      d C- @@@!$M @ `qp PP  
 E0@ @0  0  @P  
00 0 0  S    0  00  ).0 + @ $0   R0   h   T0T 0 ?    P
4   @   d     d         -M  P     @-Pp$M @  `p @p0@ @0 @@ 0 &  P  0   R  
t00 0 0  S    $T0T 0 ?  t  P
4   0     X d    \ `  A-  P `P*  
 @  T)  
   01 0@  T  
A0   !  @  T     R @	  
LpPp    R @( f   ` .  @-h|It00 @P  
  ` 0 0 0 S    D0D 0 =   P
$       d  0  d h @-=xp00 @P  
  \ 0 0 0  S    @0@ 0 ?  P
$   d     d    < D p@- PM `   P	     P  pP p@-@  P  
C- Mp   `` @P!   | P  
    p00 0 0  S  \0\ 0?   P	  
  @   (   @   d  ,  X L 00H-M`P 00c @PA  
 ? R7A  00pM  0 @ @ /  0  Q  Kc   @-00H-M`P 003 @PA  
  R7A  00pM  0 @ @    0  Q  K30   @-@8    P  
,0  0P   Np h  @-M   @@!  P  |  Q  X -0M     P	  
 
 @0  S  
 0> S   
    /H @-   @-0  u   
 O-$4M @ 0(,@ PTtp `P  
H$ 
(0@ @0$  0 G @P  
40 0 0  Sw    4$0    R
0   P  
  R.  30 0 0 S   l pP  
 {     A @P]        6 @P        + @P   20  pP  
0  SG @  e   Q:   ! @  P  x2" 02 0  @l2l" 0h2 0  @ 4D2D"0 1>  $  P}
    v Ku Q  1 0    Q 0      R    	0p0p0  @P !  0|   #Mh \1\! 0X1  /0 2 @=8 8( 	1! 01 0  @)0 0 1>    P5
   D1  0  00 0  @
 
    d  
 	  
 y    H  B          	 <	 	 	        T X           L l r  x    p@-M` @$ P*  
  PP2  
  P  
 0 0  0 0      p 0  00 0 pp0p  0l0  /0 pL0L  0H0 0   \ p `             l      D  A-P pr@ P   P `    P V(       p@-@ P  
,   3  :   A   H   q    x  @      N  U  
\  	    	  pp"  0Ps  
\       P
p8 0    P
p 0    P
p 0    P
p 0    P
p!   0P>  
      P
p 0    P
p` 0    P
p@ 0    P
p  0    P
p  0  w  P~
p 0  n  Pw
p p 0  c  Pn
p 0  p@Y 0  S  Pf
p` 0  J  P_
p     | t t        <   0p@-M P @0P `     PP  
 p  PP
   c< P P p  I p   \  0p@-M P @0P `     PP  
 p  PP
   1< P  p   pH     O-@M!     D p0  @ $\10`0 @P%  H1 0
 P&0 0  S  
  X  
1@P`
    01@ X   
 	0 rP  P
  
    i @P  
0 0 0 0  St0t  05>    P
    D   8   <     H    d        0p@-M P @0P `    U PP  
 p   PP
   < P v p  o p~   <    \	  
@- 0@0 S@@-pd!,M `  PH @P4  
<       @ 0 @ $  PP  D$  PP   $ PP%  
$ , ( , ! ,  ,|0|  0x0 0 , P ,$0, D P$   U @
  } T  x  (  U  8     A-@!(Mp  `  0        @$  P F pP$  0    R  
0 @     | (h \0\  0X0  6.0  p (0  (    l     h    0  y  A-`l1l!M @0 0@ p; V P  
D  (!0       @P'  0    R  
0     P"  
 D  m  f0  00  /0 z @ x T ` MT0T  0P0  /0 a @     d      D      ,  X  I  <    O-M " @P   pD`0@%@@0  @@0 @   
   PB  
  P P  
10 0 0  SC  p d0	0  ( @P'  
 <1  0 *@0  P  ;  
 0  S   
1     0	 S  @0    
0!P  P
       |0| 0 9>   P

  P   D    x d             T  t  $      8  C-$!M  Pp  0`= 00 @	  0      V!  
  0       PP  0  0  0    n l g T `H0H  0D0 0 u P (        ,        H    O-M P Wb` @PF  
 P?  
 [0 010   -  P  
10 0 0  S4   $      P  
! 	 u P.  	 7 pP/  
D10 0 0  S5  D $0 _ _1! 0:>    P
     6 _    k    0 0 :>   P
   `   T   Lu |  d            @  X  h        ,      P      @-Mp0 P`A @P  40  p 0 @       O- `DM @ P  pB\#\ 0 LSP   @P  
 D00  N  P  
3, 0  P  ,0 S  
@ D Uh0 @ @ M  0P0@  
     0P0h0,   0  S0N  
 
p  h0 0 S=   b ]  P
	h    b0 Qa10    @   Q1    0   10 0 0  S<    t1t! 0p1 0  @`
p	0@!         P   -  
h0 0  h0  " Q!h0 ^0 h40  0 < Z  r0 0 ?   P
  |   p0p  0l0 0  @6w ,w   4r     T  |  t  d        \    D     `  d      8  C-M@0`0 ` P pP       R   
0 0  P     
 0  S 	
  
2A A   0 St	 g \ `  p@ X404  000 0 m p@        <  <    G- M  P`  p(, @'   0  0P  
   \ P $ @ 404 (000 0 G0      T    P    O-#,M    p\@b  W` P  
X0   "  | Pb  
  T  
`0  $0 @Py  
2    T  P @  0    @P  X  P @P    T @P  
(  ,  > ,  , 0,  @PX0  
 0  S'  
 S	  
   @ ,|!	 
 )l    ,P D1D! 0@1 0  @$ z 1! 01  /0  @ h0  00 0 } @00 0 0  S     0  0?    P
0 0   4  @l   T      8  t  p    @               @      |    d    \            A- M`!.   @ 0  @ P pP   0    80  P    
      ` ' 0   R  00    P   
X  0 @D p  $  0 1(  ,  \  p    0@-@M 0 00 00P0  P  
0 C  P  ` " 0  0P 
  w(     o0H  (    @-$M@ ` pPN    0 0 @P  
 $d }  P  
  @ @ t $$ m@ $l      p  G- M   `@@ pPP  
0 0	 0 P PP  
00 0 0  S   
  | P ; `0`  0?    P
	 & @ X  0    v|  e d  |        0@-M P: 0 @@  e  P  
00 0 0  S    0 0`0` 0A> 0    P
  @      >  d d        @-Mp P`s @P  
p00  p X P  <0<  0 40B.  0  P       @    p@-M`P @0 `0   p,  @-Mp  P`# @P  40  p 0 @      A-P M   `@`v pP&  
 !>   0 0 0p . @ o  T  0t  0  0 80X   _  <0<  080 0 q @            8    A-@ M   PpP `P$  
    0  `  P )  U  0t  0  0 \     @0@  0<0 0 , P            ]  $    O-!,M `  @ $`qp P c P5  
	 x!    0      P @2  
  P  
010 0 0  S1   0  0 ,0  0  H @o    , 0  00 0  @ , ` @p0p 0=  c  P
	  @       ` X  d        T    4          @-PAM@ `  P  
 0   0  P!  
  A  P   
 pP  
 0  0 M  P
 S|0|  0x0 0 h`0`  0\0 0 ^D0D  0@0 0 T  x  4                  d  G-! M ` p  H@L!  P  P M  
  ZL.  
P0
  0  P3  
D0D!0@0  @ 0 	0   @  T  0! 0          D0@0@0 0 	0  @ |0|  0x0 0  @\ P0P  0L0 0  @      p               D      p  @-@a   @P  
/  P 0 0 @-@   @P  
/  P 0 0 O-|M $%   P+ `	,(`0`$ @ 
 p e$ (0 `  tp   P  
40 0 0 SN   X4$ 0|4 0 m ` |$0 `   P%  
< ,0     `P>  
30 0 0  Su   +J= 0#3 0 @ ` | 3# 03 0 / ` |3#0E>   P

  `   <  J	0$   P   
#4   PJ    P@  20 0 0  ST   2" 02 0  `P20 0 0  SY   2" 0|2 0  `j`2`"0E>  }  P

  `     r N10 0 0  SC   1! 01 0  `91!0E> N  P

 n `  p   0l  `1`!0E>  3  P
$0  \
 ` O p p  0   1 !0E>    P

 7 ` X       8    Y d     p  (      X  t    L  v  0    D  `  H  D  $    ,          x        \  l        0  L  $    p  D  \      A- @4dMPp` R    i  4  M     0   03  0   Pl  
30 0 0  S     0   03  0   PR  
l30 0 0  S  d L   0   043  0   P8  
30 0 0  Sr      0   02  0   P  
20 0 0  SF   |   0 P  
T20 0 0  S"  ` 4   0   0$20 x  P
10 0 0  S_   k1!0 F>0  ,  P
    1!0 F>0    P
 y t  h1h!0 F>0    P
 g 8  z,1,!0 F>0    PU
 U    uN0 0 F>0    P)
 C    c"0 0F> 0   P
 1    QlT   d  h     t  \              (        l  P  T  $        H  L        L       @-$MP @0`  P @ @@@P p300  P  
 0 0 0 S	    $00  0$\0\ 0 = |  P
  P        8  xO d        p@- P` 00C	 S                
        op   P    pP0  S
 @  0 S05@  P
    P pp@- @    PpP     P  
  P pp@- @<   -  P  0   P      K p@-M P$@  \ `  
<H  0 p 0 Z0     D P \  O  Z  Q  R  A  T  S  <  C  R  =  :  7  >  =  L  7  <  ;  :  5  8  E  D  C  B  A  @  ?  >  =  <  7  :  +  8  7  6  5  4  3  2  1  0  /  .  -  ,          '    %  $  #  "  !                   
    ` //T /P //7/  /4 /0 /, //  //  % q       Y  O- pM  $00tx@0 \`o` P    P  
@?0 0 0 S    U  
$  
(  a.  (0 \    @P  
 >0 0 0 S    U  
 v \ ;   
v  
0 40 p0h 8(0`@@d@@h@@@@@@@@@@@@@l@(0 0   S  R s  
0   S  R@ @  0  S  
0   }S  *  \  0P<0 
`   P40<  e  P4 @  44 `     K<0 0 0  S   U  
 i<,0I>0   PW
 &   FP\0     $0  D @P     P6  
<0 0 0  S   U4
 / ;0 0 0  S   U  
 7   U  
   $`;$0 0 0  S    U/
 *  U  
h   T;T+0I>	0  \  P

  `  @   0    $:$0 0 0  S   U
 n P:0 0 0 S   U  
 _
|` >  P  
h: 0 P   ^ 
1 1(0C 40N    Q  S( B0C0  
   Q  \@ h`90 0 0 S   U
 #9)0I>0    Po

 +\0 @   	 0T	  ^a00  T  Sd000  X  
00  0 R 00 I ^3@ 0(   P B 
0 (   [D   
  Z 
0 TDLPP @PH0  X(@     T@LP
 TP  H 
1D H`Dp1 ( bb    Z0  


 T  `DpH`  T.  
44P0@P0`@pb(   U   000P0 T(0    U`0  Sf  
   0  004P@p0`(0  S	     P  
m0 0 6	 08  @P  ` 0@  S  
 X` @F 0@ w 0P_  
   U  
\ F_H6H&0I> 0   Pf
\0  0 @ b    Z dP50 0 0  S    U
 0 0 00 005%0I>0    PF

 \0 @    T  Q9 440 0 0  S    U
  8 ` h Pb  
   U
 4$0I>0    P`

 \0 @      S 30 0 0  S8   U
`  30 0 0  S    U  
(    U^
 Y3#0I> 0 c  P/
0
 @\0 `    0  `   P
l @ 20 0 0  S   U
P p@3@#0I> 0  2  P:
0
 @u\0 `  U  0  *2"0I>0    P<
\0  @`0 `  <0< 
    -00  Sd000;@ j  U
X +H2H"0I><0    P

 2\0 @       f1!0I> 0    P
4 e
 @ \0 `  0<     I1!0I> 0    P8
 \0 @  `0 `  0<   0  ,&H  O K d  <   (  h  d       0         x  x            t  \  8  p    j               \      @             \  d      h        h  P  h  4    8        8    `              X  4           ,             0  0I>40  J  P
 ~\0 @  p`0 `  l0<   |   0 0I>0  -  P
\0  V`0 `  R     0 <    "C- M  pb`  @Pj  
R"P    P5  |"    P  d"d0  ~ PP@  ) L820 0 0  PD P @*  
  Se     	1! 01 0  @  1! 01 0  @   S)   @ p d1d! 0`1 0  @ < O= 0(!(1 0  @ 1!0 K>   P
	     0 0 K> r  P
	  P  `   0     L9           d  <  t                H        P    (               P  (    P0  
0@-\M@00T0 0P00L00H00D00<P80@( 40 0, 00u P7  
\04 ,  0 	0 
0@ T  \07/   p@-(MP@0` P
P@	@   `P@ Pt(p,  G-M@ ` pPy _|0 @0     0     0pD `  P Y  X     h      O-$M@  J 0x# 0 0lSP 
	  X   ` ^  V  
@f  
4 (   ; `0P  
0}SM  
	 t @Pu  
   P  r  
    0   0 
   P	 S  R    
 x2 0    PB     H2 0 Pl  ? Y0	 E   20 0 0 Sg  0  S   
" SH0 @  10 0 0 S
    $0    P@1!0 M>  +  P
  U l  ` R_L L_8 F_   1 0L  P00 0 0 S0 0 M>   P
  "	     v _0 0 M>   P
  
	  h   ^$  3 X    0      l  T    d                      (        C-YM P . @'!1 0 !000L0h00000141P1p1   0d \!, HTT0P1   0 <! 44001   0(!(D~ `D1!   0  R!  
0 	    P#    U  
0  S  
  Q  
  0 U  P  @ T  
  U`
 0 S 0  R   R  S@ T  Y`     X  $      $    x      $      $  A- @M Pp `P  h `5@ L  `0  @P x  W0 0  `    A- pM @OLP P0   `  pP   Z  X0 0 ` |  O- TM  p @`D @ P UH" @	    P U  
("     y P@  
 0 0  SQ  
  j PQ  
 0 0  S;  
1 @ 
 0  PG  
!  @PO  @ .0    R?  
  	    U    
        U  
  T U  
 _T  U
   U
   U
   U
   U
h   U  
P      ,  D  h  d      $      l      D    8  G-M @p`	0   @ P  
`     P @  
 p`(1 0  S  
  _T  D  0"C-M 0  @  ` 0PL  
 "0 ( PPE  
    Q    
  : Q@  0@   0@p  WJ  
 /  P3  
   P    
  T  
p  WA  
    P1  
 P)     P ;  
    Q  
Q  P  9  
 0    Q _7 7 7 7t 7` 7L _8 _    <       p  ,  d    <  |  O-MM `"P   "   V  
    U  
  Z   0J . R [  0K . R0J  0@.   T L  
@ T  
0@	0  P0K  0.   Z ?  
 Zb  
0@	0  P p	   X	 Z  ?o4   2 +    P     R,    Q 00  S+  "  P,  /   YpGH7  
	 T	 Z  0 W     @  P 0@0    P     2      Z0J . R}p   d0d  S 0	 0A  P
 00  S 0	 04  Pv
 j      G-  @ `@ P Q   p L  & p  
 P @@  
t dpp   `     Y  V  
  X  P@  @          G-   X"  
p` P @  @ X    \
 ^ 0   V  
 V  p  
  P  
 @ X   O- dM  pP\H`   W48<@ @   50 $0G  
0   S 0  0 00  S 0  0x P/  
 $ P!  
 F<5<%0 0 !> p0  `0@    pP  
  T  
 0 d  T  
 &_d  T  
 dtp@ 40 
 ,0   pP  X$4  0  Sf  
<4 p0  0  S   
4 p 0   X(   
3`p 0` '0  0l P0  80D 
  0P  #8  e(0  S  
t3 00`  (0 DL P0  
43$ 0 0 0 S p    T  
  ~2$ 0 0 0 S p`    T
 0  SG  
0  020 X 0P(0  
Dp<0D 
 ` pPr  h"<  ,
 0  S    
8
 0  0  S  

 <0    T  
 f  5  P 00(0o,
 p8    T
 S,
 c    T  
 $0F$0 l1l!0   P
 2 `   a  0$  1!0   Pl
(  ` }  I  0   g]  Ta
 \,
   ,
   (0  So  ' !             l  X        l    d  8  D  H      X    4  p  X          O- P P!  _ pP`  
0   01 0x	   P P  
0  SS  
0 `  V @D'  
  P S 0%  
2  : S   ,  0 S@  
	 : 0  S	 h0=  
 3  Pp >  
0e S+  0@aA  V 7	   P   _ 	   P   x_| r_ p  \ i7H c_4 ]_  t          X         0O- S PM P7  
 !`  @ PK  
 1   0  P b  
0  S p  G  ;  : \ 1  ~ 0  S
 0A  
h 0  S
 0?  
p  P  ?  
0p W+  * (
 @@xP P  
! \  
   P  	 _ 
 |  P  0   d T D 4	 _          p          p@- PM @`  P,   
(  0   /p    O- pM  PxL`0X
  <@DH @     4'   	 P< $  
'    S P  
@0@   `P  
  T  
 o Z  T  
 e_	 T
 \_p&p6 0   0   0H   `P  
  T
  @H0  Q   5 0H0 M@00  W  P500@00  M  P500@ D0     `P  
  T
t dD 5 0P`,0  
 Q  <5 0 0  MH0    RU  
%   $(@4p@0p0D 	a ( 	
 	  J	  pP   
D  0 `P   
 $   P  
0 	  Po  <  pU  
( 	
 0
< p`t0e  Pf  H0   R,0(@  Sj  
, 0  Sf  
0    `  (   V  
 P@$p(,@ p  0P S
 	   0a  V  
0 	<  p
 	 < `'  P
@ `  T  
 d ( 	
 
< p  P
(@ 0  T  
  O0 (@ P  T  
l D (@ `  T
H :H0    R><$2   00 @  ZP  *0

   R  Z*`
P    P P`0 @  T f< p 		   P  
	< 		@  0 P 01@Q!  00 U @   (@  T  
 }(@  T
  (@  T
  < @  T    
   `@  T
 @$p     l  t         8    H          t  L\      D  X    (  X    t    $  \  `    A- @ @p\!`  # PP8  
D   P 9  
  P (  
   P 2  
  P 3  
     P   
          P  ^_A p Wd@`X@QPD@L@ G_A         $                   A- @  0 0`xPP pP  
l    @P  
T0  0n  P   @0 ,   _4       %     O-4M P  @   p%    ` 	 P,   
%    0  S  
0   Qu  
5	P0050050 0|50$0,   P @  ,00	0 S	  
  : S  
  Vx  
4 s   00@  P   @ 0. S 0 0 0. S  
 6  P    Up
p  -  @ Te  
,00  [
0 S S/  
.  : S?     P,  
0  l  P  
   P,0 p0	   P  
 ~,00	 0P SA  0	  Q  V  
 l     P,0p0	   P
],0  0	   V  
h R74	 V  
H I_40000}p  V   
 7 ,  0  S  
 pQ  U  
@  T    S     0@ S  01  S U
  P i 08  , p W:  S p  y  p WH  *Q  U
 Q  S8  
 @   0@ S2  01 U  S
  Q @,  p 0,  p 	   Pe
$, 0 	0^  V
|   V~
d y  Vw
L r  Vp
4 k  S+  
 p  p W&  *Q  U
 Q  S  
 @   0@ S  01 U  S
  Q ,  0 0  VB
 = ,0  V    
T   1  t                h    H           l  h  O- |DM  pPP@   P" @ @  	  P N  
("       R	`i  
0J0  \  
0 S
   S  
  X  
 ;7D    " 0  "   P'    @ R  R	p=  
 @0J0  \.  
0 S+   S  
  X
 
 X  
 _D  X `  
      " 0  "   P    @ R	p	   X    
L     X `
, ,    (              O-,MP   \ 
 `$0   0Q  U7  
@  T4  0  S  
  
  p    P(  
    P  
 w             S  
  @ P  0  Y
0  S  Q
    0  @ P  Xu   ` \  \  
 00P  00 \0  P0 0Q  U
0 S0  S  
    R  
   R   
  
  pp  \  
 2   P-      @  ` 00  Q   
   @`  PG  
0  S  
  X	  
   P     P000  Q  
    P9  
  \C     Q
    @ @ ` `  P @  `     0  0 0$      P}
,  0  P N_, }  P _ u  P  
  V 000 \0  S  
  0 0 0   $  Y  PP0 Q0    p%
  97,  ,O-LM @   `p0' P P P  . P   
d'   0 0  S' 
0 	  @(   TM  
0  S>  p  W 
0   P^  
 0  SG   	    \    @   ]   @ \  0  [
0  S0  S
  P   @" \00 0  S=  
 	  PH   0P SO  0( 
A	   T0  S  
 :7L 0@@01@   P
 P
 0 S@   P
0   S  
T  L0 0   0"0 S  
 _L0 @  S  
  L  S  
0(   P	 0  U p`     0p St  0( 
Q	    U  
0 S0  S  
0  S  
 `  V  
@ 0  S      0 S  01  R <  P
@ 0 S 	      ^  /  
P@@`   V  
P  U
0 S 0  S
  P  0  V  0   S  
 	C  P
0 @  S
    0 "0  S<
 s7` 0  S p  t  p SC     X
  R   R
    R
   R
  P 0P  S @     0@ S  01  R   P  
 @ 0 S  U   0  P
0 @  S5
 .00  S
 &  S+  
 P  P S&   q  W
  R  X
  0  S	  
 @01   R	  
 0@ S  P0   0 P  P  
 P  0  Sp0    
   0  S
 0  S
 0  S
h 0 @  S
H   ,    L    (      \               @  O- M  `PD   U  V 0 0 @   P  
	   l P;  
|  P-  
  UI  
  pPf  
  VD  
   Pf  
  U-  ,  PP{  
   P0D @	   P7    T  
 f    T  
 ^_  T
 U0  PP  T
h Gp  U
H   PP  T
( 5 10 0 0 S `    T  
 &   T
   T
 0 0  0    P
 j p	 6  0p   T  T
\ <   $  H      h  |             d  <            4  G- ppM  @`0D S P    P  
@7 T .$ `P1  
 P   @  Z    
 0	 S  
  U  
   U
  T   , (0   Y @P    U  
`     U  
D _  U  
(        d         O-XcX`  LLM   p  DT 0$@4P  Y 0  W0$000400000000000 0 0 
 5  P{  
2 0  P_    ^{  
( 0    Qc  
  ^r  0 (  Q@  ^f  
 ( 0    P_  *0 (  QO  
 Q  o  Y  
!    P  c  
  0  0  W`  
!    P `  ?  
    0    0000 0  X 0000  
<       X  
   0D  0 R6  L  &P  X  
  P  X
   Y  
    P  
 `  X  
| _  X
`  pppp0   $      L  L  8  <      r       0    O- PM  @`p 0 0qp @   R P4  
x  P    T  
 r_  ZB  

  0P6  
   P9  
h      	0    P    T  
$ K    T
 B-00 0 0 S `    T  
 3   T
 +
  T
 !0 0 80    P
 t p @ 
 0D   ^  d       H      d      \  T    h    O- `TM  0$	 @ @ @$@(@ P      P  
@$  d  P   
$$   f$  W P  
$00 0  00D @P   p  W  
   0  S  0  0(0  	  0 0X @P  (0 0  S  
h3, 0 `  " "  W     h  Pn  (0@ 0 S  
   `P  
(   PH       R ` `   
   Q  `  `  
   `  Q ` `  
( 0  ,0	L2 P
  P`  ,  Q
    P
  U B  
 J=    U  
 C_T U  
 :T  U    
  /  T  U
 %    P    P    P~
  U   
, 	 $p  WG 
  @PA
  U  
    U 
   U
    U    
     U
p   U
X P   D  p      %                  @  H  |  T  d  O- `Q  
 @  T  
 p  @  T+  
0  RP (  
 PP%P*  
  U  
   Pz  
0   Pt  
 p     
0  XPm  
  p@  T  Ze  
  c     P"P
   P	
0 	 p0    R
   U    
 P    P R   !  R
 Q      R
  P.  
0P   R  R
 P    P  
0  P R !  R
  Q    [
  p  X  
 y0 p h  PP%PqO-|M `   0   Pu0p    V@,04  
%     A 0P0  
T%4P P @  
  P'   u  P  
  Y|  0 @0  T 0'  
	   T"  

 D  P
   |40 0 0  S  s|40 0 0  S    l4  0  0,0  0(  _ 0  S  
  S  
40 0 0  S   |( 0  Q    Ye  
0   pP  
0  S  
 P   0 S       
0	  YP  P
\ @ g ,0(@ 0 0   P 0 j 0P  
 $0r$0000   0  0 :|20 0 0  Sv  t|| -l (  c 0  H" 0 0  D 0  P  p  
0D  02E0(  00 0|1!  0   PE
  s P Y    G8 0 )1!0    P
h  3\   H   414!0     P/
  = @      "0 0    P
     y 00   X  
 _\  d   P}    d  `    @    d  8  4    h  @  ;  8                  h                O- p 4M$@  X(  LXP `P.  
 { P  
080 0 0  S'   Z4	 7 0 070  # P!  
  B4 v 9_47'  0   P
 Z p  z	  0P0
6 0P  
 00  P     
 Z  
 Z  
Zm  
6@ Z0 0 0  
 S   > 7 6 7 0C $ R`    006
0 	   d
0       PJ  
D	   54   00   060 8X0  S  
   050   P    2 P [  
>  5 PX  
D Pd   T50 0 0  S   DG0C $ R
      0\0XX50
 3 0 +50
 Sx    v7  P'  0 02   
0 PK  
 040 0 0  S   Z 30 0 0  Sn  ` L 30 0 0  Su  , > s 6_ k .3#0     P
< 0
0   n#   5 @P q  
  PW  
20 0 0  S  h 0T3T#0     P}
8  Jy,3,#  0   PE
 0   @     592"  0   P
 0   @      {2"  0   P
 0   @   `  tT"
  F\0  S`0    
0"  <\0     F10 0 0  S.   p91!0 		 X  P+

  @      1!0  D  Pl
 0  m @   T  `H1H!0  /  P
 0  X   d P   d    U        c                  "  8    e  8          "     "  T  X                         3         ,        \          8          ,    p    X  D    `  \  O-pD#M P   $c` @P  
5#	   	0     P	  
 _  0P0
   0   0 0  S
 p	 4d"d  . 2 P p  
D P8  
  P  
,20 0 0  SQ   10 0 0  S/   0   1 p0 PP
0!   -80!    &    P10 0 0  S0  X H1H!0 0 D  P
0  m `     0 0 0 .  P
0  W `      0 0 0   P
0  A ` s  p     h Hx    e    P  P  ]  d      p  .        t          |    0  \  D  O-#M` P   C@ pP,  
 ' P  
d30 0 0  S%  P 7<<

0     0P0 !  
 )   _2" 0(0    P
    ' P
   x    0  S(  
 
 !L"L  1 042 0 - 2 PD  
D P:  
  P  
10 0 0  SU      _1  0     6 P&  
<10 0 0  Sul1l! 0(0  D  Pk
  @  d4 k  ] c U    80 
       N B0 0 (0   P
  : @ l        d    Pt  D  8  T <  l  T  \      Y          )                    \  L  O-p4MTcT# P`   0(`,P( PX  
00(00P P0$ 	   P @M  
  P  
20 0 0  SW  4$  PPs  
2 0D  0P01  
p  WX  
20p`  0 SN   A 	 ` P$  
,0   P
   
P
  Pp
1 @0 0 0  SH    _4 10 0 0  SI   1!0@0  Z  P
  @	   D  8!  0$  X0  pt  0   PX0 Pj z0 0 @0  ,  P

   P      0 0 @0    P
0l     0    h d    &  d  4  h  (  8  <  0            d  $      pO-LM    <P0  <"  t," 0  @Pg  
  U}  
20  T0$40p0  ( ,`xPpC   8 ue P  (00(00` SP@  
0 0      0 D 8  0P %  
   TZ$  P   
  P/  8 ;,    \ 	 00 0 0 0	 S 40 
 ~  P
     _L (0  S  
(0 x  S  #Lh \ LTL L P   T    x        d  x              T  s  @-Mp    ` @P  
h  0 V   `	  
$0< 0     S @         @- @RM  
0P S  
  : S#   @  0  @ @ ` L @  p0 s0 @ !  @   x  l  t@- @  P\   P  
H   P    $   P   d  h  h  X  @-M@(P ` p P    mO-4M pU `  ZPo  
 @    Pk  
  Yh  
 Ta  
i  : Tc   Ya   0S S^  0: S[    YX  0%   d 0P0P  
 I P  
i     
 
 0   Q   0  S  
  : R  
CI
I	 P  *  0: S   TD  
 T(  t4  
0  Q $@	 (( ,   P  
  P  
 0$@  `    @ m   Y   0B S
 @ 4
   @PB  
  P?  
3 0 `   @ 4    P  0`#@  0 0P0  
0 
 0.0  S @
30 0 0	 S  2" 0 
   P  
  s  @  @20 0 0	 S2"0 
   P
|  VL20 0 0	 SX2X"0 
   P
@  C 20 0 0	 S2" 0 
   P
  010 0 0	 S1!0  
   P
  h10 0 0	 S1!0 
   P
	   	10  0  @$      	 R0!01 0
 l  P}
  y00 0 0	 Ss0 0  
 Y  Pj
   e\00 0 0	 S_0  0 
 E  PV
   R   0  D      d      (       p      (     ,    h  x    x    D                  4    $  p@- P  @D   p@p@- P  @J   p@p@-Pl0@M 0  `P  
 j    , $    P    p    h  p@-Pl0@M 0  `P  
 I    ,     P    p      p@-P  `k   @  P  p  (- M 00 %   (- M 00     A- @  pmP `  P  
 P0  S  
0  S   \0  S  
`   R  
  P x   7    P
L  P   P
$ { Pl  W  <  T      p@-` P   @  P v p  G-  SQ pP @"  
T1` 0 0 Tp1p!0   '  PJ   0 0 TM  D1D!0     P1   0 0 S  T `     T 0 0   P
	 .    0  0    P 0   :G    m 0   . h   b	  P   [  d      X    `    `      |        `      A-`M p P@@ P  
     P      
0 0  P  O0 0 0 0 E0 0\ \0 0 2I0 08 80 0    (          `    4  A-@ M   `p0 g PP  0!   80  S `  
0 0 04 8  P  
0 4 H 0  P   f0 0 0 0  P m0 0p p0 0  P 
00   00(0 S(2P       (        G-(M(L	  \P `p6  
@ w  P  0-0 0 0   P  H00@ P0   
 (00 0 0	 Sx0x 0 0 
   P
 	 L   ^@0-0 0 0 m P
@l t d  p  8  8   G-M,r<@p  T` ?  
@   PPx  
1 80  P "0 	0
 >  P  10 0 0 S4  0  V @  
!  Z0  x l  P@10 0 0 S1    V @ 0 0 @80 0@@ @	0@"
 PP
  U  V  
P @0 0   _  P
  Y  
	    U   
0  0  P@|0| 0   E  P

  T   H @8   XP  d            x  $          @-M( @$@-M  @-samba_runcmd_io_handler ../lib/util/util_runcmd.c:227   struct tevent_req   ../lib/util/util_runcmd.c:229   struct samba_runcmd_state   ../lib/util/util_runcmd.c:254   ../lib/util/util_runcmd.c:258   ../lib/util/util_runcmd.c:282   Error in waitpid() unexpectedly got ECHILD for %s child %d - %s, someone has set SIGCHLD to SIG_IGN!
   ../lib/util/util_runcmd.c:283   ../lib/util/util_runcmd.c:287   Error in waitpid() for child %s - %s 
  ../lib/util/util_runcmd.c:291   ../lib/util/util_runcmd.c:296   Child %s exited with status %d
 ../lib/util/util_runcmd.c:298   ../lib/util/util_runcmd.c:302   ../lib/util/util_runcmd.c:316   %s: %*.*s
  ../lib/util/util_runcmd.c:326   ../lib/util/util_runcmd.c:76    ../lib/util/util_runcmd.c:86    ../lib/util/util_runcmd.c:91    ../lib/util/util_runcmd.c:97    ../lib/util/util_runcmd.c:105   ../lib/util/util_runcmd.c:117   ../lib/util/util_runcmd.c:144   samba_runcmd_io_handler ../lib/util/util_runcmd.c:145   ../lib/util/util_runcmd.c:156   ../lib/util/util_runcmd.c:157   Out of memory in child
 Failed to exec child - %s
  pwd_timeout_debug   samdb_find_or_add_attribute_ex  samdb_search_string_v   samdb_search_string_multiple    samdb_search_dom_sid    samdb_result_acct_flags samdb_result_passwords  samdb_set_password_internal samdb_set_password_internal samdb_set_domain_sid    samdb_set_ntds_settings_dn  samdb_ntds_settings_dn  samdb_ntds_invocation_id    samdb_set_ntds_invocation_id    samdb_ntds_objectGUID   samdb_set_ntds_objectGUID   samdb_search_for_parent_domain  samdb_check_password    samdb_dns_domain_to_dn  samdb_domain_to_dn  dsdb_msg_add_guid   samdb_set_am_rodc   samdb_ntds_site_settings_options    samdb_ntds_site_settings_options    samdb_ntds_options  samdb_ntds_options  samdb_ntds_object_category  dsdb_functional_level   dsdb_forest_functional_level    samdb_dn_is_our_ntdsa   dsdb_find_nc_root   dsdb_find_nc_root   dsdb_tombstone_lifetime dsdb_savereps   dsdb_find_guid_attr_by_dn   dsdb_find_sid_by_dn dsdb_loadreps   samdb_create_foreign_security_principal dsdb_load_udv_v2    dsdb_search dsdb_search samdb_reference_dn_is_our_ntdsa samdb_is_pdc    samdb_server_reference_dn   samdb_is_rodc   dsdb_validate_dsa_guid  dsdb_get_fsmo_role_info samdb_dn_to_dnshostname samdb_set_password_sid  dsdb_create_partial_replica_NC  dsdb_update_bad_pwd_count   1.3.6.1.4.1.7165.4.3.8  ../source4/dsdb/common/util.c:2128  ../source4/dsdb/common/util.c:2129  ../source4/dsdb/common/util.c:2134  ../source4/dsdb/common/util.c:2139  ../source4/dsdb/common/util.c:2140  ../source4/dsdb/common/util.c:2003  WARNING: check_password_complexity: password script took more than 1 second to run
 ../source4/dsdb/common/util.c:748   attr_flags != 0 ../source4/dsdb/common/util.c   PANIC: assert failed at %s(%d): %s
 assert failed: attr_flags != 0  ../source4/dsdb/common/util.c:110   samdb: search for %s %s not single valued (count=%d)
   ../source4/dsdb/common/util.c:113   ../source4/dsdb/common/util.c:155   ../source4/dsdb/common/util.c:156   ../source4/dsdb/common/util.c:300   samdb: search for %s %s not single valued
  ../source4/dsdb/common/util.c:301   const char *    ../source4/dsdb/common/util.c:308   struct dom_sid  ../source4/dsdb/common/util.c:367   objectSid   ../source4/dsdb/common/util.c:82    ../source4/dsdb/common/util.c:85    ../source4/dsdb/common/util.c:183   ../source4/dsdb/common/util.c:186   ../source4/dsdb/common/util.c:190   ../source4/dsdb/common/util.c:344   lastLogoff  accountExpires  minPwdAge   struct samr_Password    ntPwdHistory    lmPwdHistory    unicodePwd  dBCSPwd uint8_t userAccountControl  ../source4/dsdb/common/util.c:666   Attribute %s not found, disabling account %s!
  msDS-User-Account-Control-Computed  ../source4/dsdb/common/util.c:614   samdb_result_passwords: Account for user %s was locked out.
    uint16_t    operations error    ldb out of memory   struct ldb_val  %d  %lld    ../source4/dsdb/common/util.c:995   ../source4/dsdb/common/util.c:1013  clearTextPassword   ../source4/dsdb/common/util.c:2188  ../source4/dsdb/common/util.c:2196  ../source4/dsdb/common/util.c:2202  ../source4/dsdb/common/util.c:2209  ../source4/dsdb/common/util.c:2217  struct dsdb_control_password_change ../source4/dsdb/common/util.c:2227  ../source4/dsdb/common/util.c:2228  1.3.6.1.4.1.7165.4.3.10 ../source4/dsdb/common/util.c:2239  ../source4/dsdb/common/util.c:2240  1.3.6.1.4.1.7165.4.3.9  ../source4/dsdb/common/util.c:2249  ../source4/dsdb/common/util.c:2250  1.3.6.1.4.1.7165.4.3.23 ../source4/dsdb/common/util.c:2259  ../source4/dsdb/common/util.c:2260  ../source4/dsdb/common/util.c:2268  ../source4/dsdb/common/util.c:2269  ../source4/dsdb/common/util.c:2277  struct ldb_control  ../source4/dsdb/common/util.c:2279  struct dsdb_control_password_change_status  ../source4/dsdb/common/util.c:2280  ../source4/dsdb/common/util.c:2283  ../source4/dsdb/common/util.c:2284  struct samr_DomInfo1    ../source4/dsdb/common/util.c:2315  ../source4/dsdb/common/util.c:2325  %s:     ../source4/dsdb/common/util.c:2343  Failed to set password on %s: %s
   CN=Aggregate    CN=Partitions   ../source4/dsdb/common/util.c:1160  CN=Infrastructure   ../source4/dsdb/common/util.c:1172  CN=Sites    ../source4/dsdb/common/util.c:1184  cache.domain_sid    talloc_new: ../source4/dsdb/common/util.c:1210  objectSid=* ../source4/dsdb/common/util.c:1235  ../source4/dsdb/common/util.c:1236  ../source4/dsdb/common/util.c:1241  talloc_new: ../source4/dsdb/common/util.c:1263  ../source4/dsdb/common/util.c:1278  ../source4/dsdb/common/util.c:1279  ../source4/dsdb/common/util.c:1280  ../source4/dsdb/common/util.c:1285  Failed to set our own cached domain SID in the ldb!
    ../source4/dsdb/common/util.c:1286  forced.ntds_settings_dn struct ldb_dn   talloc_new: ../source4/dsdb/common/util.c:1300  ../source4/dsdb/common/util.c:1315  ../source4/dsdb/common/util.c:1316  ../source4/dsdb/common/util.c:1317  ../source4/dsdb/common/util.c:1322  Failed to set our NTDS Settings DN in the ldb!
 ../source4/dsdb/common/util.c:1323  dsServiceName   talloc_new: ../source4/dsdb/common/util.c:1344  ../source4/dsdb/common/util.c:1352  Searching for dsServiceName in rootDSE failed: %s
  ../source4/dsdb/common/util.c:1366  ../source4/dsdb/common/util.c:1367  ../source4/dsdb/common/util.c:1372  Failed to find our own NTDS Settings DN in the ldb!
    ../source4/dsdb/common/util.c:1373  invocationId    cache.invocation_id ../source4/dsdb/common/util.c:1391  !GUID_all_zero(invocation_id)   assert failed: !GUID_all_zero(invocation_id)    talloc_new: ../source4/dsdb/common/util.c:1395  struct GUID ../source4/dsdb/common/util.c:1417  Failed to find our own NTDS Settings invocationId in the ldb!
  ../source4/dsdb/common/util.c:1419  Failed to find parse own NTDS Settings invocationId from the ldb!
  ../source4/dsdb/common/util.c:1429  ../source4/dsdb/common/util.c:1430  ../source4/dsdb/common/util.c:1435  ../source4/dsdb/common/util.c:1436  talloc_new: ../source4/dsdb/common/util.c:1450  ../source4/dsdb/common/util.c:1460  !GUID_all_zero(invocation_id_in)    assert failed: !GUID_all_zero(invocation_id_in) ../source4/dsdb/common/util.c:1468  ../source4/dsdb/common/util.c:1469  ../source4/dsdb/common/util.c:1470  ../source4/dsdb/common/util.c:1475  Failed to set our own cached invocationId in the ldb!
  ../source4/dsdb/common/util.c:1476  objectGUID  cache.ntds_guid talloc_new: ../source4/dsdb/common/util.c:1497  ../source4/dsdb/common/util.c:1523  ../source4/dsdb/common/util.c:1524  ../source4/dsdb/common/util.c:1529  Failed to find our own NTDS Settings objectGUID in the ldb!
    ../source4/dsdb/common/util.c:1530  talloc_new: ../source4/dsdb/common/util.c:1543  ../source4/dsdb/common/util.c:1560  ../source4/dsdb/common/util.c:1561  ../source4/dsdb/common/util.c:1562  ../source4/dsdb/common/util.c:1567  ../source4/dsdb/common/util.c:1568  talloc_new: ../source4/dsdb/common/util.c:1577  ../source4/dsdb/common/util.c:1583  ../source4/dsdb/common/util.c:1602  ../source4/dsdb/common/util.c:1606  CN=Subnets  ../source4/dsdb/common/util.c:1849  ../source4/dsdb/common/util.c:1850  (objectClass=site)  ../source4/dsdb/common/util.c:1859  ../source4/dsdb/common/util.c:1860  cn  siteObject  ../source4/dsdb/common/util.c:1886  ../source4/dsdb/common/util.c:1912  ../source4/dsdb/common/util.c:1913  ../source4/dsdb/common/util.c:1914  talloc_new: ../source4/dsdb/common/util.c:1961  (|(objectClass=domain)(objectClass=builtinDomain))  Invalid dn (%s), not child of a domain object   ../source4/dsdb/common/util.c:1987  ../source4/dsdb/common/util.c:1987: %s
 ../source4/dsdb/common/util.c:1988  ../source4/dsdb/common/util.c:1992  ../source4/dsdb/common/util.c:1993  Error searching for parent domain of %s, failed searching for %s: %s    ../source4/dsdb/common/util.c:1981  /bin/sh -c  ../source4/dsdb/common/util.c:2053  ../source4/dsdb/common/util.c:2060  pwd_timeout_debug   ../source4/dsdb/common/util.c:2065  ../source4/dsdb/common/util.c:2067  ../source4/dsdb/common/util.c:2068  ../source4/dsdb/common/util.c:2076  ../source4/dsdb/common/util.c:2077  ../source4/dsdb/common/util.c:2082  ../source4/dsdb/common/util.c:2085  check_password_complexity: check password script took too long!
    ../source4/dsdb/common/util.c:2086  ../source4/dsdb/common/util.c:2090  check_password_complexity: check password script (%s) returned [%d]
    ../source4/dsdb/common/util.c:2095  check_password_complexity: check password script said new password is not good enough!
 ../source4/dsdb/common/util.c:2096  ../source4/dsdb/common/util.c:2101  ../source4/dsdb/common/util.c:2105  talloc_new: ../source4/dsdb/common/util.c:2847  .   ../source4/dsdb/common/util.c:2858  dc=%s   ../source4/dsdb/common/util.c:2866  Failed to add dc=%s element to DN %s
   ../source4/dsdb/common/util.c:2867  ../source4/dsdb/common/util.c:2873  Failed to validated DN %s
  ../source4/dsdb/common/util.c:2874  ../source4/dsdb/common/util.c:2877  ../source4/dsdb/common/util.c:2897  %*.*s.  ../source4/dsdb/common/util.c:2903  talloc_new: ../source4/dsdb/common/util.c:2925  ../source4/dsdb/common/util.c:2933  ../source4/dsdb/common/util.c:2938  ../source4/dsdb/common/util.c:2943  %s._msdcs.%s    ../source4/dsdb/common/util.c:2947  ncName  (&(nETBIOSName=%s)(objectclass=crossRef))   (objectclass=domain)    ../source4/dsdb/common/util.c:2997  Found %d records matching domain [%s]
  nCName  dsdb_msg_add_guid   ../source4/dsdb/common/util.c:3104  ../source4/dsdb/common/util.c:3104: Failed to add %s to the message
    ../source4/dsdb/common/util.c:3111  talloc_new: ../source4/dsdb/common/util.c:3305  struct ldb_result   ../source4/dsdb/common/util.c:3311  @REPLCHANGED    ../source4/dsdb/common/util.c:3323  struct dsdb_control_current_partition   ../source4/dsdb/common/util.c:3329  1.3.6.1.4.1.7165.4.3.2  ../source4/dsdb/common/util.c:3339  ../source4/dsdb/common/util.c:3354  ../source4/dsdb/common/util.c:3359  uSNHighest  uSNUrgent   ../source4/dsdb/common/util.c:3375  talloc_new: ../source4/dsdb/common/util.c:3486  bool    cache.am_rodc   ../source4/dsdb/common/util.c:3501  ../source4/dsdb/common/util.c:3502  ../source4/dsdb/common/util.c:3506  Failed to set our own cached am_rodc in the ldb!
   ../source4/dsdb/common/util.c:3507  options talloc_new: ../source4/dsdb/common/util.c:3525  objectClass=nTDSSiteSettings    ../source4/dsdb/common/util.c:3550  ../source4/dsdb/common/util.c:3555  Failed to find our NTDS Site Settings options in ldb!
  ../source4/dsdb/common/util.c:3556  talloc_new: ../source4/dsdb/common/util.c:3572  ../source4/dsdb/common/util.c:3588  ../source4/dsdb/common/util.c:3593  Failed to find our own NTDS Settings options in the ldb!
   ../source4/dsdb/common/util.c:3594  objectCategory  ../source4/dsdb/common/util.c:3616  Failed to find our own NTDS Settings objectCategory in the ldb!
     -_ ../source4/dsdb/common/util.c:3643  domainFunctionality int ../source4/dsdb/common/util.c:3657  ../source4/dsdb/common/util.c:3657: WARNING: domainFunctionality not setup
 forestFunctionality ../source4/dsdb/common/util.c:3671  ../source4/dsdb/common/util.c:3671: WARNING: forestFunctionality not setup
 GUID    ../source4/dsdb/common/util.c:1726  Failed to find our NTDS Settings GUID for comparison with %s - %s
  RMD_FLAGS   <RMD_FLAGS= <RMD_VERSION=   namingContexts  talloc_new: ../source4/dsdb/common/util.c:3904  ../source4/dsdb/common/util.c:3912  Searching for namingContexts in rootDSE failed: %s
 ../source4/dsdb/common/util.c:3913  ../source4/dsdb/common/util.c:3921  dsdb_find_nc_root: Finding a valid 'namingContexts' element in the RootDSE failed. Using a temporary list.  ../source4/dsdb/common/util.c:3927  ../source4/dsdb/common/util.c:3933  ../source4/dsdb/common/util.c:3939  ../source4/dsdb/common/util.c:3945  struct ldb_dn * ../source4/dsdb/common/util.c:3953  ../source4/dsdb/common/util.c:3960  ../source4/dsdb/common/util.c:3975  ../source4/dsdb/common/util.c:3969  ../source4/dsdb/common/util.c:3970  CN=Directory Service,CN=Windows NT,CN=Services  ../source4/dsdb/common/util.c:4018  objectClass=nTDSService tombstoneLifetime   ../source4/dsdb/common/util.c:4023  struct ldb_search_options_control   1.2.840.113556.1.4.1340 1.3.6.1.4.1.7165.4.3.17 1.2.840.113556.1.4.417  1.2.840.113556.1.4.2064 1.3.6.1.4.1.7165.4.3.4  struct ldb_extended_dn_control  1.2.840.113556.1.4.529  1.3.6.1.4.1.7165.4.3.6  1.3.6.1.4.1.4203.666.5.12   1.2.840.113556.1.4.1413 1.3.6.1.4.1.7165.4.3.7  1.2.840.113556.1.4.805  1.3.6.1.4.1.7165.4.3.16 1.3.6.1.4.1.7165.4.3.12 1.3.6.1.4.1.7165.4.3.20 1.3.6.1.4.1.7165.4.3.29 1.3.6.1.4.1.7165.4.3.18 ../source4/dsdb/common/util.c:4334  ../source4/dsdb/common/util.c:4340  ../source4/dsdb/common/util.c:4364  ../source4/dsdb/common/util.c:4370  talloc_new: ../source4/dsdb/common/util.c:3250  ../source4/dsdb/common/util.c:3282  Failed to store %s - %s
    ../source4/dsdb/common/util.c:3286  ../source4/dsdb/common/util.c:3291  ../source4/dsdb/common/util.c:4394  ../source4/dsdb/common/util.c:4400  ../source4/dsdb/common/util.c:4450  ../source4/dsdb/common/util.c:4456  ../source4/dsdb/common/util.c:4465  ../source4/dsdb/common/util.c:4467  talloc_new: ../source4/dsdb/common/util.c:3050  ../source4/dsdb/common/util.c:3059  ../source4/dsdb/common/util.c:3063  ../source4/dsdb/common/util.c:3067  talloc_new: ../source4/dsdb/common/util.c:3126  ../source4/dsdb/common/util.c:3135  ../source4/dsdb/common/util.c:3139  ../source4/dsdb/common/util.c:3144  ../source4/dsdb/common/util.c:3148  talloc_new: ../source4/dsdb/common/util.c:3193  ../source4/dsdb/common/util.c:3207  dsdb_loadreps: failed to read partition object: %s
 ../source4/dsdb/common/util.c:3208  ../source4/dsdb/common/util.c:3215  struct repsFromToBlob   ../source4/dsdb/common/util.c:3238  ../source4/dsdb/common/util.c:3222  ../source4/dsdb/common/util.c:3233  talloc_new: ../source4/dsdb/common/util.c:3857  <WKGUID=%s,%s>  ../source4/dsdb/common/util.c:3867  ../source4/dsdb/common/util.c:3875  ../source4/dsdb/common/util.c:3879  ../source4/dsdb/common/util.c:3880  ../source4/dsdb/common/util.c:2793  22B70C67D56E4EFB91E9300FCA3DC1AA    ../source4/dsdb/common/util.c:2803  Failed to find DN for ForeignSecurityPrincipal container - %s
  ../source4/dsdb/common/util.c:2804  CN=%s   ../source4/dsdb/common/util.c:2811  foreignSecurityPrincipal    objectClass ../source4/dsdb/common/util.c:2818  ../source4/dsdb/common/util.c:2828  Failed to create foreignSecurityPrincipal record %s: %s
    ../source4/dsdb/common/util.c:2829  ../source4/dsdb/common/util.c:2833  ../source4/dsdb/common/util.c:2834  18E2EA80684F11D2B9AA00C04F79F805    ../source4/dsdb/common/util.c:3997  replUpToDateVector  ../source4/dsdb/common/util.c:4074  ../source4/dsdb/common/util.c:4085  ../source4/dsdb/common/util.c:4091  ../source4/dsdb/common/util.c:4095  ../source4/dsdb/common/util.c:4095: No invocationID on samdb - %s
  ../source4/dsdb/common/util.c:4096  struct drsuapi_DsReplicaCursor2 ../source4/dsdb/common/util.c:4148  struct drsuapi_DsReplicaCursor  ../source4/dsdb/common/util.c:4155  ../source4/dsdb/common/util.c:4163  talloc_new: ../source4/dsdb/common/util.c:4486  <GUID=%s>   ../source4/dsdb/common/util.c:4492  ../source4/dsdb/common/util.c:4497  talloc_new: ../source4/dsdb/common/util.c:4518  ../source4/dsdb/common/util.c:4521  basedn == NULL || (dsdb_flags & DSDB_SEARCH_SEARCH_ALL_PARTITIONS) == 0 assert failed: basedn == NULL || (dsdb_flags & DSDB_SEARCH_SEARCH_ALL_PARTITIONS) == 0  ../source4/dsdb/common/util.c:4525  ../source4/dsdb/common/util.c:4535  ../source4/dsdb/common/util.c:4550  ../source4/dsdb/common/util.c:4556  ../source4/dsdb/common/util.c:4567  ../source4/dsdb/common/util.c:4573  ../source4/dsdb/common/util.c:4578  ../source4/dsdb/common/util.c:4584  ../source4/dsdb/common/util.c:4585  Cannot find DN %s to get attribute %s for reference dn: %s  Cannot find attribute %s of %s to calculate reference dn    Cannot interpret attribute %s of %s as a dn ../source4/dsdb/common/util.c:1703  ../source4/dsdb/common/util.c:1707  serverReferenceBL   ../source4/dsdb/common/util.c:1630  ../source4/dsdb/common/util.c:1640  CN=NTDS Settings    ../source4/dsdb/common/util.c:1664  ../source4/dsdb/common/util.c:1669  talloc_new: ../source4/dsdb/common/util.c:1742  ../source4/dsdb/common/util.c:1748  Failed to find object %s for attribute %s - %s
 ../source4/dsdb/common/util.c:1754  fsmoRoleOwner   ../source4/dsdb/common/util.c:1932  Failed to find if we are the PDC for this ldb: Searching for fSMORoleOwner in %s failed: %s
    serverReference ../source4/dsdb/common/util.c:1773  rIDManagerReference rIDSetReferences    ../source4/dsdb/common/util.c:1802  objectGUID=%s   ../source4/dsdb/common/util.c:3029  ../source4/dsdb/common/util.c:3034  ../source4/dsdb/common/util.c:3035  objectSid=%s    ../source4/dsdb/common/util.c:3173  ../source4/dsdb/common/util.c:3178  ../source4/dsdb/common/util.c:3179  msDS-isRODC talloc_new: ../source4/dsdb/common/util.c:3407  ../source4/dsdb/common/util.c:3411  ../source4/dsdb/common/util.c:3420  ../source4/dsdb/common/util.c:3426  Failed to find our own NTDS Settings object by objectGUID=%s!
  ../source4/dsdb/common/util.c:3428  ../source4/dsdb/common/util.c:3435  ../source4/dsdb/common/util.c:3474  talloc_new: ../source4/dsdb/common/util.c:4608  ../source4/dsdb/common/util.c:4614  ../source4/dsdb/common/util.c:4624  ../source4/dsdb/common/util.c:4635  ../source4/dsdb/common/util.c:4639  ../source4/dsdb/common/util.c:4640  talloc_new: ../source4/dsdb/common/util.c:4703  (&(objectGUID=%s)(objectClass=nTDSDSA)) ../source4/dsdb/common/util.c:4718  ../source4/dsdb/common/util.c:4718: Failed to find DSA objectGUID %s for sid %s
    ../source4/dsdb/common/util.c:4719  ../source4/dsdb/common/util.c:4725  (objectClass=server)    ../source4/dsdb/common/util.c:4734  ../source4/dsdb/common/util.c:4734: Failed to find server record for DSA with objectGUID %s, sid %s
    ../source4/dsdb/common/util.c:4735  ../source4/dsdb/common/util.c:4746  ../source4/dsdb/common/util.c:4746: Failed to find account dn (serverReference) for %s, parent of DSA with objectGUID %s, sid %s
   ../source4/dsdb/common/util.c:4747  SID ../source4/dsdb/common/util.c:4754  ../source4/dsdb/common/util.c:4754: Failed to find SID for DSA with objectGUID %s, sid %s
  ../source4/dsdb/common/util.c:4755  ../source4/dsdb/common/util.c:4764  ../source4/dsdb/common/util.c:4764: Bad DSA objectGUID %s for sid %s - expected sid %s
 ../source4/dsdb/common/util.c:4765  ../source4/dsdb/common/util.c:4769  fSMORoleOwner   ../source4/dsdb/common/util.c:4818  ../source4/dsdb/common/util.c:4818: Failed to find fSMORoleOwner in Naming Master object - %s   ../source4/dsdb/common/util.c:4819  ../source4/dsdb/common/util.c:4828  ../source4/dsdb/common/util.c:4828: Failed to find fSMORoleOwner in Schema Master object - %s   ../source4/dsdb/common/util.c:4829  ../source4/dsdb/common/util.c:4836  ../source4/dsdb/common/util.c:4836: Failed to find RID Manager object - %s  ../source4/dsdb/common/util.c:4837  ../source4/dsdb/common/util.c:4844  ../source4/dsdb/common/util.c:4844: Failed to find fSMORoleOwner in RID Manager object - %s ../source4/dsdb/common/util.c:4845  ../source4/dsdb/common/util.c:4854  ../source4/dsdb/common/util.c:4854: Failed to find fSMORoleOwner in Schema Master object - %s   ../source4/dsdb/common/util.c:4855  ../source4/dsdb/common/util.c:4864  ../source4/dsdb/common/util.c:4864: Failed to find fSMORoleOwner in Pd Master object - %s   ../source4/dsdb/common/util.c:4865  dNSHostName ../source4/dsdb/common/util.c:4889  Failed to find dNSHostName for dn %s, ldb error: %s %08X: %s at %s:%s   ../source4/dsdb/common/util.c:2398  ../source4/dsdb/common/util.c:2411  Failed to start transaction: %s
    ../source4/dsdb/common/util.c:2412  (&(objectSid=%s)(objectClass=user)) ../source4/dsdb/common/util.c:2425  samdb_set_password_sid: SID[%s] not found in samdb %s - %s, returning NO_SUCH_USER
 ../source4/dsdb/common/util.c:2426  ../source4/dsdb/common/util.c:2437  samdb_set_password_sid: invalid userAccountControl[0x%08X] for SID[%s] DN[%s], returning NO_SUCH_USER
  ../source4/dsdb/common/util.c:2438  ../source4/dsdb/common/util.c:2470  samdb_set_password_sid: no new password provided sAMAccountName for SID[%s] DN[%s], returning INVALID_PARAMETER
    ../source4/dsdb/common/util.c:2471  ../source4/dsdb/common/util.c:2482  samdb_set_password_sid: two new passwords provided sAMAccountName for SID[%s] DN[%s], returning INVALID_PARAMETER
  ../source4/dsdb/common/util.c:2483  ../source4/dsdb/common/util.c:2495  samdb_set_password_sid: invalid utf16 length (%zu) sAMAccountName for SID[%s] DN[%s], returning WRONG_PASSWORD
 ../source4/dsdb/common/util.c:2496  ../source4/dsdb/common/util.c:2508  samdb_set_password_sid: utf16 password too long (%zu) sAMAccountName for SID[%s] DN[%s], returning WRONG_PASSWORD
  ../source4/dsdb/common/util.c:2509  sAMAccountName  ../source4/dsdb/common/util.c:2521  samdb_set_password_sid: missing sAMAccountName for SID[%s] DN[%s], returning NO_SUCH_USER
  ../source4/dsdb/common/util.c:2522  ../source4/dsdb/common/util.c:2538  samdb_set_password_sid: dsdb_trust_search_tdo failed(%s) for sAMAccountName[%s] SID[%s] DN[%s], returning INTERNAL_DB_CORRUPTION
   ../source4/dsdb/common/util.c:2539  trustDirection  ../source4/dsdb/common/util.c:2554  samdb_set_password_sid: direction[0x%08X] is not inbound for sAMAccountName[%s] DN[%s] TDO[%s], returning INTERNAL_DB_CORRUPTION
   ../source4/dsdb/common/util.c:2555  trustAuthIncoming   ../source4/dsdb/common/util.c:2573  samdb_set_password_sid: failed(%s) to parse trustAuthOutgoing sAMAccountName[%s] DN[%s] TDO[%s], returning INTERNAL_DB_CORRUPTION
  ../source4/dsdb/common/util.c:2575  struct AuthenticationInformation    ../source4/dsdb/common/util.c:2624  ../source4/dsdb/common/util.c:2632  ../source4/dsdb/common/util.c:2693  ../source4/dsdb/common/util.c:2709  samdb_set_password_sid: failed(%s) to generate trustAuthOutgoing sAMAccountName[%s] DN[%s] TDO[%s], returning UNSUCCESSFUL
 ../source4/dsdb/common/util.c:2710  ../source4/dsdb/common/util.c:2715  ../source4/dsdb/common/util.c:2721  ../source4/dsdb/common/util.c:2728  ../source4/dsdb/common/util.c:2744  samdb_set_password_sid: failed to replace trustAuthOutgoing sAMAccountName[%s] DN[%s] TDO[%s], %s - %s
 ../source4/dsdb/common/util.c:2745  ../source4/dsdb/common/util.c:2759  ../source4/dsdb/common/util.c:2767  Failed to commit transaction to change password on %s: %s
  ../source4/dsdb/common/util.c:2768  ../source4/dsdb/common/util.c:2772  talloc_new: ../source4/dsdb/common/util.c:5049  ../source4/dsdb/common/util.c:5055  top ../source4/dsdb/common/util.c:5062  domainDNS   ../source4/dsdb/common/util.c:5075  %u  instanceType    ../source4/dsdb/common/util.c:5084  ../source4/dsdb/common/util.c:5092  Failed to create new NC for %s - %s (%s)
   ../source4/dsdb/common/util.c:5093  ../source4/dsdb/common/util.c:5097  Created new NC for %s
  ../source4/dsdb/common/util.c:5099  %08x-%04x%04x-%02x%02x%02x%02x-%02x%02x%02x%02x lockOutObservationWindow    badPasswordTime badPwdCount pwdProperties   lockoutThreshold    ../source4/dsdb/common/util.c:5252  Not updating badPwdCount on %s after wrong password
    ../source4/dsdb/common/util.c:5262  ../source4/dsdb/common/util.c:5275  ../source4/dsdb/common/util.c:5280  lockoutTime ../source4/dsdb/common/util.c:5287  ../source4/dsdb/common/util.c:5291  Locked out user %s after %d wrong passwords
    ../source4/dsdb/common/util.c:5294  Updated badPwdCount on %s after %d wrong passwords
 ../source4/dsdb/common/util.c:5241  9223372036854775807 codePage    countryCode lastLogon   logonCount  logonHours  pwdLastSet  1.3.6.1.4.1.7165.4.3.26 adminCount  operatorCount   dsdb: Unrecognized account type!    sAMAccountType  primaryGroupID  pekList msDS-ExecuteScriptPassword  currentValue    initialAuthIncoming initialAuthOutgoing priorValue  supplementalCredentials trustAuthOutgoing   dsdb_trust_crossref_tdo_info    dsdb_trust_search_tdo   dsdb_trust_search_tdos  ../source4/dsdb/common/util_trusts.c:379    struct lsa_TrustDomainInfoInfoEx    ../source4/dsdb/common/util_trusts.c:390    ../source4/dsdb/common/util_trusts.c:393    dnsRoot ../source4/dsdb/common/util_trusts.c:397    ../source4/dsdb/common/util_trusts.c:402    nETBIOSName ../source4/dsdb/common/util_trusts.c:408    ../source4/dsdb/common/util_trusts.c:413    ../source4/dsdb/common/util_trusts.c:419    ../source4/dsdb/common/util_trusts.c:425    ../source4/dsdb/common/util_trusts.c:430    ../source4/dsdb/common/util_trusts.c:440    struct lsa_ForestTrustCollisionRecord * struct lsa_ForestTrustCollisionRecord   struct lsa_ForestTrustRecord *  struct lsa_ForestTrustRecord    ../source4/dsdb/common/util_trusts.c:317    ../source4/dsdb/common/util_trusts.c:323    ../source4/dsdb/common/util_trusts.c:329    ../source4/dsdb/common/util_trusts.c:338    ../source4/dsdb/common/util_trusts.c:344    ../source4/dsdb/common/util_trusts.c:348    ../source4/dsdb/common/util_trusts.c:354    ../source4/dsdb/common/util_trusts.c:359    ../source4/dsdb/common/util_trusts.c:365    ../source4/dsdb/common/util_trusts.c:750    rootTrust   trustParent ../source4/dsdb/common/util_trusts.c:452    ../source4/dsdb/common/util_trusts.c:486    ../source4/dsdb/common/util_trusts.c:492    1.2.840.113556.1.4.803  (&(ncName=%s)(objectClass=crossRef)(systemFlags:%s:=%u)%s)  ../source4/dsdb/common/util_trusts.c:512    ../source4/dsdb/common/util_trusts.c:519    ../source4/dsdb/common/util_trusts.c:522    (objectClass=crossRef)  ../source4/dsdb/common/util_trusts.c:547    Failed to search for %s: %s - %s
   ../source4/dsdb/common/util_trusts.c:548    ../source4/dsdb/common/util_trusts.c:556    ../source4/dsdb/common/util_trusts.c:559    ../source4/dsdb/common/util_trusts.c:576    ../source4/dsdb/common/util_trusts.c:577    ../source4/dsdb/common/util_trusts.c:585    ../source4/dsdb/common/util_trusts.c:588    ../source4/dsdb/common/util_trusts.c:598    struct ForestTrustInfo  struct ForestTrustInfoRecordArmor   ../source4/dsdb/common/util_trusts.c:70 ../source4/dsdb/common/util_trusts.c:57 ../source4/dsdb/common/util_trusts.c:85 ../source4/dsdb/common/util_trusts.c:97 ../source4/dsdb/common/util_trusts.c:108    ../source4/dsdb/common/util_trusts.c:117    ../source4/dsdb/common/util_trusts.c:125    struct lsa_ForestTrustInformation   ../source4/dsdb/common/util_trusts.c:245    ../source4/dsdb/common/util_trusts.c:168    ../source4/dsdb/common/util_trusts.c:180    ../source4/dsdb/common/util_trusts.c:192    ../source4/dsdb/common/util_trusts.c:200    ../source4/dsdb/common/util_trusts.c:208    ../source4/dsdb/common/util_trusts.c:257    (!(|(rootTrust=*)(trustParent=*)))  ../source4/dsdb/common/util_trusts.c:910    ../source4/dsdb/common/util_trusts.c:939    ../source4/dsdb/common/util_trusts.c:942    ../source4/dsdb/common/util_trusts.c:946    ../source4/dsdb/common/util_trusts.c:953    (&(objectClass=crossRef)(systemFlags:%s:=%u))   ../source4/dsdb/common/util_trusts.c:966    uPNSuffixes __tln__ msDS-SPNSuffixes    ../source4/dsdb/common/util_trusts.c:986    ../source4/dsdb/common/util_trusts.c:1012   ../source4/dsdb/common/util_trusts.c:1018   ../source4/dsdb/common/util_trusts.c:1024   ../source4/dsdb/common/util_trusts.c:1030   ../source4/dsdb/common/util_trusts.c:1050   ../source4/dsdb/common/util_trusts.c:1070   ../source4/dsdb/common/util_trusts.c:1084   ../source4/dsdb/common/util_trusts.c:1106   ../source4/dsdb/common/util_trusts.c:1147   ../source4/dsdb/common/util_trusts.c:1160   trustPartner    ../source4/dsdb/common/util_trusts.c:1181   ../source4/dsdb/common/util_trusts.c:1186   flatName    ../source4/dsdb/common/util_trusts.c:1192   ../source4/dsdb/common/util_trusts.c:1197   securityIdentifier  ../source4/dsdb/common/util_trusts.c:1203   trustType   trustAttributes msDS-TrustForestTrustInfo   ../source4/dsdb/common/util_trusts.c:1239   ../source4/dsdb/common/util_trusts.c:1251   ../source4/dsdb/common/util_trusts.c:1259   ../source4/dsdb/common/util_trusts.c:1262   ../source4/dsdb/common/util_trusts.c:1285   ../source4/dsdb/common/util_trusts.c:1291   ../source4/dsdb/common/util_trusts.c:1314   ../source4/dsdb/common/util_trusts.c:1338   ..  ../source4/dsdb/common/util_trusts.c:1343   ../source4/dsdb/common/util_trusts.c:1380   ../source4/dsdb/common/util_trusts.c:1387   ../source4/dsdb/common/util_trusts.c:1398   ../source4/dsdb/common/util_trusts.c:1405   ../source4/dsdb/common/util_trusts.c:1453   ../source4/dsdb/common/util_trusts.c:1507   ../source4/dsdb/common/util_trusts.c:1566   ../source4/dsdb/common/util_trusts.c:1571   ../source4/dsdb/common/util_trusts.c:1579   ../source4/dsdb/common/util_trusts.c:1589   ../source4/dsdb/common/util_trusts.c:1592   ../source4/dsdb/common/util_trusts.c:1621   ../source4/dsdb/common/util_trusts.c:1637   ../source4/dsdb/common/util_trusts.c:1662   ../source4/dsdb/common/util_trusts.c:1678   ../source4/dsdb/common/util_trusts.c:1684   ../source4/dsdb/common/util_trusts.c:2005   ../source4/dsdb/common/util_trusts.c:2015   ../source4/dsdb/common/util_trusts.c:2018   ../source4/dsdb/common/util_trusts.c:2036   ../source4/dsdb/common/util_trusts.c:2046   ../source4/dsdb/common/util_trusts.c:2054   ../source4/dsdb/common/util_trusts.c:2133   ../source4/dsdb/common/util_trusts.c:2153   ../source4/dsdb/common/util_trusts.c:2163   ../source4/dsdb/common/util_trusts.c:2168   ../source4/dsdb/common/util_trusts.c:2173   ../source4/dsdb/common/util_trusts.c:2251   ../source4/dsdb/common/util_trusts.c:2336   ../source4/dsdb/common/util_trusts.c:2407   ../source4/dsdb/common/util_trusts.c:2413   ../source4/dsdb/common/util_trusts.c:2423   ../source4/dsdb/common/util_trusts.c:2433   ../source4/dsdb/common/util_trusts.c:2439   CN=System   ../source4/dsdb/common/util_trusts.c:2444   ../source4/dsdb/common/util_trusts.c:2451   ../source4/dsdb/common/util_trusts.c:2459   (&(objectClass=trustedDomain)(|(trustPartner=%s)(flatName=%s))) ../source4/dsdb/common/util_trusts.c:2471   (&(objectClass=trustedDomain)(flatName=%s)) ../source4/dsdb/common/util_trusts.c:2479   ../source4/dsdb/common/util_trusts.c:2487   ../source4/dsdb/common/util_trusts.c:2500   ../source4/dsdb/common/util_trusts.c:2501   ../source4/dsdb/common/util_trusts.c:2505   (&(objectClass=trustedDomain)(trustPartner=%s)) ../source4/dsdb/common/util_trusts.c:2516   ../source4/dsdb/common/util_trusts.c:2526   ../source4/dsdb/common/util_trusts.c:2537   ../source4/dsdb/common/util_trusts.c:2543   ../source4/dsdb/common/util_trusts.c:2548   ../source4/dsdb/common/util_trusts.c:2562   ../source4/dsdb/common/util_trusts.c:2566   ../source4/dsdb/common/util_trusts.c:2575   ../source4/dsdb/common/util_trusts.c:2594   ../source4/dsdb/common/util_trusts.c:2602   ../source4/dsdb/common/util_trusts.c:2631   ../source4/dsdb/common/util_trusts.c:2666   ../source4/dsdb/common/util_trusts.c:2675   ../source4/dsdb/common/util_trusts.c:2677   ../source4/dsdb/common/util_trusts.c:2684   (objectClass=trustedDomain) ../source4/dsdb/common/util_trusts.c:2694   ../source4/dsdb/common/util_trusts.c:2704   ../source4/dsdb/common/util_trusts.c:2709   ../source4/dsdb/common/util_trusts.c:2716   (&(objectClass=trustedDomain)(!(|(trustPartner=%s)(flatName=%s))))  ../source4/dsdb/common/util_trusts.c:2726   ../source4/dsdb/common/util_trusts.c:2741   ../source4/dsdb/common/util_trusts.c:2742   ../source4/dsdb/common/util_trusts.c:2746   ../source4/dsdb/common/util_trusts.c:2767   ../source4/dsdb/common/util_trusts.c:2792   struct dsdb_trust_routing_table ../source4/dsdb/common/util_trusts.c:2798   ../source4/dsdb/common/util_trusts.c:2801   struct dsdb_trust_routing_domain    ../source4/dsdb/common/util_trusts.c:2805   ../source4/dsdb/common/util_trusts.c:2815   ../source4/dsdb/common/util_trusts.c:2829   ../source4/dsdb/common/util_trusts.c:2839   ../source4/dsdb/common/util_trusts.c:2849   ../source4/dsdb/common/util_trusts.c:2857   ../source4/dsdb/common/util_trusts.c:2874   ../source4/dsdb/common/util_trusts.c:2884   ../source4/dsdb/common/util_trusts.c:2919   ../source4/dsdb/common/util_trusts.c:2925   dsdb_expand_nested_groups   memberOf    ../source4/dsdb/common/util_groups.c:78 No SAM available, cannot determine local groups
    talloc_new: ../source4/dsdb/common/util_groups.c:82 ../source4/dsdb/common/util_groups.c:86 ../source4/dsdb/common/util_groups.c:88 ../source4/dsdb/common/util_groups.c:88: we failed parsing DN %.*s, so we cannot calculate the group token
 ../source4/dsdb/common/util_groups.c:97 ../source4/dsdb/common/util_groups.c:102    ../source4/dsdb/common/util_groups.c:102: when parsing DN '%s' we failed to parse it's SID component, so we cannot calculate the group token: %s
   ../source4/dsdb/common/util_groups.c:103    ../source4/dsdb/common/util_groups.c:108    ../source4/dsdb/common/util_groups.c:142    (&(objectClass=foreignSecurityPrincipal)(objectSID=%s)) ../source4/dsdb/common/util_groups.c:155    ../source4/dsdb/common/util_groups.c:162    ../source4/dsdb/common/util_groups.c:162: dsdb_search for %s failed: %s
    ../source4/dsdb/common/util_groups.c:163    ../source4/dsdb/common/util_groups.c:169    ../source4/dsdb/common/util_groups.c:178    ../source4/dsdb/common/util_groups.c:196    ../source4/dsdb/common/util_groups.c:191    ../source4/dsdb/common/util_groups.c:120    dsdb_add_user   dsdb_add_domain_group   dsdb_add_domain_alias   dsdb_enum_group_mem dsdb_lookup_rids    user    CN=Users    computer    CN=Computers    OU=Domain Controllers   talloc_new: ../source4/dsdb/common/util_samr.c:60   ../source4/dsdb/common/util_samr.c:71   Failed to start a transaction for user creation: %s
    ../source4/dsdb/common/util_samr.c:72   (&(sAMAccountName=%s)(objectclass=user))    ../source4/dsdb/common/util_samr.c:83   ../source4/dsdb/common/util_samr.c:90   ../source4/dsdb/common/util_samr.c:97   ../source4/dsdb/common/util_samr.c:104  ../source4/dsdb/common/util_samr.c:133  Invalid account flags specified:  cannot create domain trusts via this interface (must use LSA CreateTrustedDomain calls
   ../source4/dsdb/common/util_samr.c:135  ../source4/dsdb/common/util_samr.c:141  Invalid account flags specified 0x%08X, must be exactly one of 
ACB_NORMAL (0x%08X) ACB_WSTRUST (0x%08X) or ACB_SVRTRUST (0x%08X)
  ../source4/dsdb/common/util_samr.c:143  CN=%s,%s    ../source4/dsdb/common/util_samr.c:153  objectSID   ../source4/dsdb/common/util_samr.c:170  ../source4/dsdb/common/util_samr.c:184  Failed to create user record %s: %s
    ../source4/dsdb/common/util_samr.c:185  ../source4/dsdb/common/util_samr.c:192  ../source4/dsdb/common/util_samr.c:193  ../source4/dsdb/common/util_samr.c:199  ../source4/dsdb/common/util_samr.c:200  ../source4/dsdb/common/util_samr.c:213  Can't locate the account we just created %s: %s
    ../source4/dsdb/common/util_samr.c:214  ../source4/dsdb/common/util_samr.c:221  Apparently we failed to get the objectSid of the just created account record %s
    ../source4/dsdb/common/util_samr.c:222  ../source4/dsdb/common/util_samr.c:230  Failed to commit transaction to add and modify account record %s: %s
   ../source4/dsdb/common/util_samr.c:231  ../source4/dsdb/common/util_samr.c:234  ../source4/dsdb/common/util_samr.c:236  ../source4/dsdb/common/util_samr.c:238  talloc_new: ../source4/dsdb/common/util_samr.c:256  (&(sAMAccountName=%s)(objectclass=group))   CN=%s,CN=Users  ../source4/dsdb/common/util_samr.c:277  group   ../source4/dsdb/common/util_samr.c:291  Failed to create group record %s: %s
   ../source4/dsdb/common/util_samr.c:292  ../source4/dsdb/common/util_samr.c:297  ../source4/dsdb/common/util_samr.c:298  ../source4/dsdb/common/util_samr.c:303  ../source4/dsdb/common/util_samr.c:304  ../source4/dsdb/common/util_samr.c:315  ../source4/dsdb/common/util_samr.c:316  ../source4/dsdb/common/util_samr.c:317  talloc_new: ../source4/dsdb/common/util_samr.c:332  ../source4/dsdb/common/util_samr.c:336  Failed to start transaction in dsdb_add_domain_alias(): %s
 (sAMAccountName=%s)(objectclass=group)) ../source4/dsdb/common/util_samr.c:347  ../source4/dsdb/common/util_samr.c:354  ../source4/dsdb/common/util_samr.c:363  groupType   ../source4/dsdb/common/util_samr.c:378  ../source4/dsdb/common/util_samr.c:382  ../source4/dsdb/common/util_samr.c:388  Failed to create alias record %s: %s
   ../source4/dsdb/common/util_samr.c:389  ../source4/dsdb/common/util_samr.c:400  Failed to commit transaction in dsdb_add_domain_alias(): %s
    ../source4/dsdb/common/util_samr.c:404  ../source4/dsdb/common/util_samr.c:405  ../source4/dsdb/common/util_samr.c:406  member  talloc_new: ../source4/dsdb/common/util_samr.c:426  ../source4/dsdb/common/util_samr.c:432  ../source4/dsdb/common/util_samr.c:437  dsdb_enum_group_mem: dsdb_search for %s failed: %s
 ../source4/dsdb/common/util_samr.c:445  ../source4/dsdb/common/util_samr.c:462  Could not parse %*.*s as a DN
  ../source4/dsdb/common/util_samr.c:463  ../source4/dsdb/common/util_samr.c:476  When parsing DN '%s' we failed to parse it's SID component, so we cannot fetch the membership: %s
  ../source4/dsdb/common/util_samr.c:477  ../source4/dsdb/common/util_samr.c:484  ../source4/dsdb/common/util_samr.c:486  talloc_new: ../source4/dsdb/common/util_samr.c:501  <SID=%s>    ../source4/dsdb/common/util_samr.c:519  samAccountName=*    ../source4/dsdb/common/util_samr.c:526  samAccountName  ../source4/dsdb/common/util_samr.c:532  no samAccountName
  ../source4/dsdb/common/util_samr.c:535  samAccountType  ../source4/dsdb/common/util_samr.c:543  dsdb_dn_parse   struct dsdb_dn  ../source4/dsdb/common/dsdb_dn.c:53 ../source4/dsdb/common/dsdb_dn.c:58 ../source4/dsdb/common/dsdb_dn.c:63 B:%u:%s:%s  ../source4/dsdb/common/dsdb_dn.c:242    S:%u:%*.*s:%s   1.3.6.1.4.1.1466.115.121.1.12   1.2.840.113556.1.4.903  1.2.840.113556.1.4.904  1.2.840.113556.1.4.1221 ../source4/dsdb/common/dsdb_dn.c:101    talloc_new: ../source4/dsdb/common/dsdb_dn.c:125    ../source4/dsdb/common/dsdb_dn.c:139    ../source4/dsdb/common/dsdb_dn.c:139: failed
   ../source4/dsdb/common/dsdb_dn.c:143    ../source4/dsdb/common/dsdb_dn.c:143: failed
   ../source4/dsdb/common/dsdb_dn.c:147    ../source4/dsdb/common/dsdb_dn.c:147: failed
   ../source4/dsdb/common/dsdb_dn.c:155    ../source4/dsdb/common/dsdb_dn.c:155: blen=%u len=%u
   ../source4/dsdb/common/dsdb_dn.c:161    ../source4/dsdb/common/dsdb_dn.c:161: %s    ../source4/dsdb/common/dsdb_dn.c:170    ../source4/dsdb/common/dsdb_dn.c:170: blen=%u - not an even number
 ../source4/dsdb/common/dsdb_dn.c:176    ../source4/dsdb/common/dsdb_dn.c:178    ../source4/dsdb/common/dsdb_dn.c:178: err
  ../source4/dsdb/common/dsdb_dn.c:186    ../source4/dsdb/common/dsdb_dn.c:186: non hexidecimal characters found in binary prefix
    DATA_BLOB: ../source4/dsdb/common/dsdb_dn.c:195 ../source4/dsdb/common/dsdb_dn.c:208    ../source4/dsdb/common/dsdb_dn.c:208: err
  ../source4/dsdb/common/dsdb_dn.c:214    ../source4/dsdb/common/dsdb_dn.c:218    ../source4/dsdb/common/dsdb_dn.c:292    ../source4/dsdb/common/dsdb_dn.c:315    ../source4/dsdb/common/dsdb_dn.c:279    talloc_new: ../source4/dsdb/common/dsdb_dn.c:336    <GUID=%s>;  <SID=%s>;   ../source4/dsdb/common/dsdb_dn.c:352    ../source4/dsdb/common/dsdb_dn.c:353    ../source4/dsdb/common/dsdb_dn.c:364    dsdb_acl_debug  dsdb_check_access_on_dn ../source4/dsdb/common/dsdb_access.c:47 Access on %s denied ../source4/dsdb/common/dsdb_access.c:49 Access on %s granted    ../source4/dsdb/common/dsdb_access.c:53 Security context: %s
   ../source4/dsdb/common/dsdb_access.c:55 Security descriptor: %s
    nTSecurityDescriptor    ../source4/dsdb/common/dsdb_access.c    nTSecurityDescriptor is missing struct security_descriptor  dsdb_access: Access check failed on %s  ../source4/dsdb/common/dsdb_access.c:167    access_check: failed to find object %s
 gendb_search_v  NULL    ../lib/util/util_ldb.c:60   gendb_search_v: %s %s -> %d
    ../lib/util/util_ldb.c:64   ../lib/util/util_ldb.c:66   ../lib/util/util_ldb.c:72   gendb_search_v: search failed: %s
  ../lib/util/util_ldb.c:77                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   c  $c                    d                                       +      >      S      _      v                                                      I!     ^!     lU         \I          `I       o     "     T  
   7"           DK               L     J     0        oH  o          o   o<H  o   oD  o,                                           I         xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU  xU                                                                                                           P        @                $  \       0 D     
 	 <	 T
  H
 d
     |      x @     ,8 |     A,   aeabi "   6 	
"c43f9938c5df61dc9f25c409fc033a8520f371.debug    L" .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       <               (         T  T  0              0         "  "  7"                 8   o   D  D  F               E   o   H  H  8                T   o   <H  <H  p               c   	      J  J  0               l   	   B   L  L                u         lU  lU                    p         xU  xU                  {         db  db  t7                                                        ,                          : :                            \I \I                           `I `I                           dI dI                            hI hI <                           I I                         DK DK                           P  P                            P P                        p        P -                                P 4                                P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        p             U                                                                                                                                                                                               U                                                                                                   q                                     *                                      U  7     V  <V  5     LV  V  d7     V  V  H5     V  0W  h4     DW  W  47     W  W   4     W  LX  7     dX  X  7     X  X  3     Y  TY  6     `Y  Y  03     Y  Y  6     Y  Z  2     $Z  TZ  2         dZ  x2     tZ  Z  t6         Z  2         Z  1         Z  1     Z  D[  1     \[  [  $1     [  \  0         (\  0         <\  <0         P\  /         d\  .         l\  |-         \  +         \  l+         \  L+         \  D6     \   ]  *     8]                  `c  hc  tc      `  Xc      `  Pc      `  Hc  Pc      `  @c  Hc  _      b  b  b  b   c  c   c  0c      c  c  0U                 c          <                                                           c                          t                             M      0:                                      c  I     c  c  H     c  c  hG     c  a  F     d  (d  D     4d  Dd  C     Td  xd  PA     d  d  K     d                  A,   aeabi "   6 	
"e83eb759c35895d4e8fbda33742f4f92bb043c.debug     .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       `                (         x  x                0         h
  h
                   8   o                      E   o   (  (                 T   	                         ]   	   B                     f         #  #                    a         #  #                  l         @)  @)  L)                 r         R  R                    x         R  R  0                          d  d                             |l |l                            l l                            l l                             l l  `                        m m                            p  p                            u u                         p        u  -                                u  4                                u                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ELF          (      4   d    4    (                  4  4                                (  (                    $   $         Qtd                          Rtd                       GNU ];!	Bj!Q              1 B          4|CEWqXvT<Yy                           	                                                       a                                                          8                                                                      u              R           "     ,         ,         $         ,         $                 	    D
           	         $         ,        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses talloc_named_const loadparm_s3_helpers loadparm_init_s3 pytalloc_steal _talloc_free PyErr_NoMemory initparam Py_InitModule4 PyImport_ImportModule PyObject_GetAttrString libsamba-hostconfig.so.0 libsmbconf.so.0 libtalloc.so.2 libpytalloc-util.so.2 libpython2.7.so.1.0 libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/samba3/param.so /usr/lib/arm-linux-gnueabihf/samba GLIBC_2.4 PYTALLOC_UTIL_2.0.6 SMBCONF_0 TALLOC_2.0.2 SAMBA_HOSTCONFIG_0.0.1                                                   ii           V         Y           7         0t           G         "   %                 Q5   2                                         
                  	                    @-&  -         | t l d0 0   R/ 8   404 0  0 0C S 00/ 0  S//h d  @   88    A,0A0/ 0  S//   D   L0L 0  0  S/80@-0  S  
(0 0 0   X H   |  8 80    0  R     0  S
@-3/@  <   |  p@-   @P  
  u P
  
H0  PP   
4m pp Pej8   @     @-M      0   e  P  
h   c @P
  
XU 0L 0C   S 0    
0 0@/  H (         , @-talloc_new: ../source3/param/pyparam.c:37   ../source3/param/pyparam.c:53   ../source3/param/pyparam.c:58   Parsing and writing Samba3 configuration files. param   samba.param LoadParm    get_context Returns LoadParm context.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     H              7     G     V     l                         D
                      o          d  
   I               X                 4     X                o   o  o   o^  o                                                                                                                         A,   aeabi "   6 	
"3b21e209b4d71142bed46aaf0b1d21ebd151fe.debug    q@ .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       L                (         d  d                0             I                 8   o   ^  ^  6                E   o                       T   	      4  4  X                ]   	   B       X               f                               a                              l                              r         D
  D
                    x      2   L
  L
                            0  0                                                                                                                        (                           L                               $                           $ $                         p        $  -                                Q  4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          (    $  4   PB    4    (                  \:  \:           =  = =              =  = = `  `                    $   $         Qtd                          Rtd=  = = p  p                 GNU 5}5.3OpJj   ?           1 ?   B   E    4|CEWqXvT<Xyes                           	     =       \                                                                                  [                                                                     e                                                                                I                           <             r             2                            o                                                     *                          H             ,                          0                                                     0             h             B                          v                                                    P             c                           X             ~                                                     {                          c                                       3             L           "                  A         A       ^  A         A       e  A                 	    (.        q  A         A       Z  -  H      __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _talloc_stackframe posix_locking_init lp_servicenumber create_conn_struct _talloc_free _talloc_set_destructor PyErr_NoMemory PyImport_ImportModule PyObject_GetAttrString get_friendly_nt_error_msg _Py_BuildValue_SizeT PyErr_SetObject PyErr_SetString PyExc_RuntimeError _PyArg_ParseTupleAndKeywords_SizeT lp_posix_pathnames synthetic_smb_fname_split smb_vfs_call_unlink __errno_location PyErr_SetFromErrno PyExc_OSError _Py_NoneStruct conn_free umask _talloc_tos synthetic_smb_fname smb_vfs_call_chown talloc_named_const smb_vfs_call_sys_acl_get_file py_return_ndr_struct py_check_dcerpc_type _pytalloc_get_type _talloc_zero smb_vfs_call_open smb_vfs_call_fstat map_nt_error_from_unix vfs_file_id_from_sbuf smb_vfs_call_fset_nt_acl smb_vfs_call_close strerror __printf_chk dbghdrclass smb_fname_str_dbg dbgtext nt_errstr DEBUGLEVEL_CLASS PyBool_FromLong smb_vfs_call_sys_acl_set_file sys_acl_init sys_acl_create_entry sys_acl_set_tag_type sys_acl_set_permset sys_acl_set_qualifier smb_vfs_call_get_nt_acl initsmbd Py_InitModule4 libpthread.so.0 libsmbd-base.so.0 libsamba-python.so.0 libsmbregistry.so.0 libsamba-errors.so.1 libsmbd-conn.so.0 libsamba-util.so.0 libsmbconf.so.0 libsamba-debug.so.0 libpython2.7.so.1.0 libtalloc.so.2 libpytalloc-util.so.2 libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/samba3/smbd.so /usr/lib/arm-linux-gnueabihf/samba GLIBC_2.4 PYTALLOC_UTIL_2.1.6 SAMBA_UTIL_0.0.1 SAMBA_4.5.16_DEBIAN SMBCONF_0 SAMBA_ERRORS_1 TALLOC_2.0.2                                	     
  
                                        	                  r         ii           >         Y                    T                      
                  0t  	                                                                     /         "   ,                                                T         ii         =    =     @    @    @    @    @    @    @    $@    (@    ,@    4@    8@    <@    @@    H@    L@    P@    T@    \@    `@    d@    h@    p@    t@    x@    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    ?   ?   ? 	  ?   ?   ?   ? (  ? .  ? =  ?   ?   ?   ?   ?   ? 
   ?   $?   (?   ,?   0?   4?   8?   <?   @?   D?   H?   L?   P?   T?   X?   \?   `?   d?   h?    l? !  p? "  t? #  x? $  |? %  ? &  ? '  ? )  ? *  ? +  ? ,  ? -  ? /  ? 0  ? 1  ? 2  ? 3  ? 4  ? 5  ? 6  ? 7  ? 8  ? 9  ? :  ? ;  ? <  ? =  ? >  @-  -X-  X P H @ 8 0 (                        x p h ` X P H @ 8 0 (                0 0   R/e*    404 0  0 0C S 00/ 0  S//, , *    88    A,0A0/ 0  S//l, h, D*    L0L 0  0  S/80@-0  S  
(0 0 0  , *    * + 8 80    0  R     0  S
@-3/@<( )    A- lM  `2\qp P  x @P$  
  V+  
  p<  
,1 @0    0 ?1 S `  
  U  
  0  " $0   U
      7+ P   t   M     U  
P D0D0      <)                       1A-0p  M@ P  0`0%     L!P0 <QP `  @P    V  
 }      g @P   
p    P  
8  @P  
  V  
 `0 @0    V  
 Sa  V
d K   V  
H C<00      ( p  p  P' D  0              @-,  G-@P 8M$``  00 0!00 0 $0 @  @dQP P@  
X  7 ` P8  
 < 0  S p0   P       P'  
8  0 S @P	   "  V  
 00      8  V  
 ]0 @0  O8  8	    V  
P J80   0  ;8& <  l%                <  1C-0 0 4M @q p  !   P  00 `PY  
       d!0	    P1  
 w  P:  
08   0P  
     U @  
 n j 4  U  
 a ]00   @ 4  U  
 O K @ 4  U  
d AX = @I@$ #   $                    (  8  0  @  dO-0@` dML  <    @D@00H00%D00<0 0 L0d` P  @P   U  
  d  dX @	 @	    z  )  d$ H  @P    U
`  d@  @Pe  
4H HD0<0   $N   pPE  
#  ?  P T  
 @ :
   $ PP  
,08     0 s  
0
 8  pC  \30 0<0  S    X  
@       U  1	S
30      {  X  
 s_  Ut
 l  U~
 e e  X
 ]  X  
 V 
  
 
      	0       $  Ao 8 x PJ  08 H %  X  
 " Y    R  
    0 #  X  
d  B< 0 98 Z 00 s[0  1!0     P]
 _ @u       /Q00 0<0
 S0 
 0 
 P
	     " l  T  T! (        D                        ,              8  p  T    h  d   G- p` P   @  	0  `   P   T  
  0    @-D@p <M$Q P    0000|! 000 0 $0  `  @P    V  
< c <$!$   @P    V    < O < < @P$  
 80     @P  
  V  
 60 @0    V  
p )d00        V
D  ` 4           P  `  @     ,       A-XPp PM< @ `   $ <0  `@lTP P)  
0  @ 0$#1 0@( ,00@$ `  P8   
4p8@ 0  P4  
  V  
     @  P    P  80  `  V  
  T  
 83 `0  *P  T  
 t30      P4   P  
  V
< (4   P  
  V
    P  
  V
 v4 l  P  
  V
 j,4   P  
  V
 ]   P  
  V
\ Q4 G  P  
  V
0 E{04 t  P  
  Vt
 9o 0 s  
   P  
  Ve
 *`   P  
  VY
 T4   P  
  VM
t H4   P  
  VA
H < 4 D  P(  
  V5
 0$4 ) P  
  V)
 $ 8p   @ 0P#
80  3  W `$
 4   P
  V
t \ l   H                (                    X      h  t  P    2O-0l0 4M @ P 0`T"  P&"     0"`0	  b` p  @P   W9  
   4 u @PS  
      0   P     	  P    X  
| d_Al  d P   H     @ 408 
  00 @P     X  
 @1S
0    f  W @
 / 4  W
 &00 0<0  S0 0 0 >  P
 ( T   Z   4  |         p  l  \  h    (  D  4        |  x  -M( (  $ $  0   W  t   h  @-set_nt_acl_conn get_nt_acl_conn ../source3/smbd/pysmbd.c:48 ../source3/smbd/pysmbd.c:54 ../source3/smbd/pysmbd.c:61 unknown service /   samba   NTSTATUSError   (i,s)   ../source3/smbd/pysmbd.c:71 ../source3/smbd/pysmbd.c:440    s|z ../source3/smbd/pysmbd.c:445    ../source3/smbd/pysmbd.c:451    ../source3/smbd/pysmbd.c:459    ../source3/smbd/pysmbd.c:465    ../source3/smbd/pysmbd.c:470    sii|z   ../source3/smbd/pysmbd.c:389    ../source3/smbd/pysmbd.c:400    ../source3/smbd/pysmbd.c:408    ../source3/smbd/pysmbd.c:416    ../source3/smbd/pysmbd.c:423    ../source3/smbd/pysmbd.c:621    talloc_new: ../source3/smbd/pysmbd.c:622    si|z    ../source3/smbd/pysmbd.c:633    ../source3/smbd/pysmbd.c:634    ../source3/smbd/pysmbd.c:640    ../source3/smbd/pysmbd.c:641    ../source3/smbd/pysmbd.c:647    ../source3/smbd/pysmbd.c:648    t   samba.dcerpc.smb_acl    ../source3/smbd/pysmbd.c:654    ../source3/smbd/pysmbd.c:655    ../source3/smbd/pysmbd.c:501    siO|z   ../source3/smbd/pysmbd.c:506    samba.dcerpc.security   ../source3/smbd/pysmbd.c:511    ../source3/smbd/pysmbd.c:517    struct security_descriptor  ../source3/smbd/pysmbd.c:104    struct files_struct ../source3/smbd/pysmbd.c:113    struct fd_handle    ../source3/smbd/pysmbd.c:118    ../source3/smbd/pysmbd.c:131    open: error=%d (%s)
    ../source3/smbd/pysmbd.c:151    ../source3/smbd/pysmbd.c:162    Error doing fstat on open file %s (%s)
 ../source3/smbd/pysmbd.c:163    ../source3/smbd/pysmbd.c:181    set_nt_acl_no_snum: fset_nt_acl returned %s.
   ../source3/smbd/pysmbd.c:187    ../source3/smbd/pysmbd.c:524    ../source3/smbd/pysmbd.c:86 ../source3/smbd/pysmbd.c:96 ../source3/smbd/pysmbd.c:572    ../source3/smbd/pysmbd.c:583    ../source3/smbd/pysmbd.c:588    ../source3/smbd/pysmbd.c:594    struct smb_acl_t    ../source3/smbd/pysmbd.c:602    ../source3/smbd/pysmbd.c:607    si|iz   ../source3/smbd/pysmbd.c:230    ../source3/smbd/pysmbd.c:245    ../source3/smbd/pysmbd.c:250    ../source3/smbd/pysmbd.c:255    ../source3/smbd/pysmbd.c:260    ../source3/smbd/pysmbd.c:265    ../source3/smbd/pysmbd.c:270    ../source3/smbd/pysmbd.c:275    ../source3/smbd/pysmbd.c:280    ../source3/smbd/pysmbd.c:285    ../source3/smbd/pysmbd.c:291    ../source3/smbd/pysmbd.c:296    ../source3/smbd/pysmbd.c:301    ../source3/smbd/pysmbd.c:306    ../source3/smbd/pysmbd.c:312    ../source3/smbd/pysmbd.c:317    ../source3/smbd/pysmbd.c:322    ../source3/smbd/pysmbd.c:348    ../source3/smbd/pysmbd.c:356    ../source3/smbd/pysmbd.c:359    ../source3/smbd/pysmbd.c:364    talloc_new: ../source3/smbd/pysmbd.c:540    ../source3/smbd/pysmbd.c:546    ../source3/smbd/pysmbd.c:552    ../source3/smbd/pysmbd.c:199    ../source3/smbd/pysmbd.c:201    ../source3/smbd/pysmbd.c:209    ../source3/smbd/pysmbd.c:219    get_nt_acl_conn: get_nt_acl returned %s.
   ../source3/smbd/pysmbd.c:222    ../source3/smbd/pysmbd.c:561    Python bindings for the smbd file server.   smbd    fname   mode    gid security_info_sent  sd  security_info_wanted    acl_type    uid have_posix_acls set_simple_acl  set_nt_acl  get_nt_acl  get_sys_acl set_sys_acl chown   unlink                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          L           r                                                  /     >     T                    (.     =          =       o          d  
   9           >                    @                    o   o  o   o.  o+                                           =                                                                                                                                                        @ 9  .      9  9  9  .      9  9  .      9  9  9  .      9  9  8:  .      9  9  9  .      9  9  .      9  #         :  %         :  (         $:  +         0:           <:  #         H:           P:  H                         A,   aeabi "   6 	
"107d352e10c233a4cdfdffb24fa1fd704a6a03.debug    u .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       L                (         d  d                0             9                 8   o   .  .                  E   o                      T   	      @  @                 ]   	   B                     f                               a                             l         $  $                   r         (.  (.                    x         0.  0.  (                          X:  X:                             = =                            = =                            = =                             = =  `                        > >                            @  @                            A A                         p        A  -                                =A  4                                qA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2010
# Copyright (C) Matthias Dieter Wallnoefer 2009
#
# Based on the original in EJS:
# Copyright (C) Andrew Tridgell <tridge@samba.org> 2005
# Copyright (C) Giampaolo Lauria <lauria2@yahoo.com> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Convenience functions for using the SAM."""

import samba
import ldb
import time
import base64
import os
from samba import dsdb, dsdb_dns
from samba.ndr import ndr_unpack, ndr_pack
from samba.dcerpc import drsblobs, misc
from samba.common import normalise_int32

__docformat__ = "restructuredText"


class SamDB(samba.Ldb):
    """The SAM database."""

    hash_oid_name = {}
    hash_well_known = {}

    def __init__(self, url=None, lp=None, modules_dir=None, session_info=None,
                 credentials=None, flags=0, options=None, global_schema=True,
                 auto_connect=True, am_rodc=None):
        self.lp = lp
        if not auto_connect:
            url = None
        elif url is None and lp is not None:
            url = lp.samdb_url()

        self.url = url

        super(SamDB, self).__init__(url=url, lp=lp, modules_dir=modules_dir,
            session_info=session_info, credentials=credentials, flags=flags,
            options=options)

        if global_schema:
            dsdb._dsdb_set_global_schema(self)

        if am_rodc is not None:
            dsdb._dsdb_set_am_rodc(self, am_rodc)

    def connect(self, url=None, flags=0, options=None):
        '''connect to the database'''
        if self.lp is not None and not os.path.exists(url):
            url = self.lp.private_path(url)
        self.url = url

        super(SamDB, self).connect(url=url, flags=flags,
                options=options)

    def am_rodc(self):
        '''return True if we are an RODC'''
        return dsdb._am_rodc(self)

    def am_pdc(self):
        '''return True if we are an PDC emulator'''
        return dsdb._am_pdc(self)

    def domain_dn(self):
        '''return the domain DN'''
        return str(self.get_default_basedn())

    def disable_account(self, search_filter):
        """Disables an account

        :param search_filter: LDAP filter to find the user (eg
            samccountname=name)
        """

        flags = samba.dsdb.UF_ACCOUNTDISABLE
        self.toggle_userAccountFlags(search_filter, flags, on=True)

    def enable_account(self, search_filter):
        """Enables an account

        :param search_filter: LDAP filter to find the user (eg
            samccountname=name)
        """

        flags = samba.dsdb.UF_ACCOUNTDISABLE | samba.dsdb.UF_PASSWD_NOTREQD
        self.toggle_userAccountFlags(search_filter, flags, on=False)

    def toggle_userAccountFlags(self, search_filter, flags, flags_str=None,
                                on=True, strict=False):
        """Toggle_userAccountFlags

        :param search_filter: LDAP filter to find the user (eg
            samccountname=name)
        :param flags: samba.dsdb.UF_* flags
        :param on: on=True (default) => set, on=False => unset
        :param strict: strict=False (default) ignore if no action is needed
                 strict=True raises an Exception if...
        """
        res = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                          expression=search_filter, attrs=["userAccountControl"])
        if len(res) == 0:
                raise Exception("Unable to find account where '%s'" % search_filter)
        assert(len(res) == 1)
        account_dn = res[0].dn

        old_uac = int(res[0]["userAccountControl"][0])
        if on:
            if strict and (old_uac & flags):
                error = "Account flag(s) '%s' already set" % flags_str
                raise Exception(error)

            new_uac = old_uac | flags
        else:
            if strict and not (old_uac & flags):
                error = "Account flag(s) '%s' already unset" % flags_str
                raise Exception(error)

            new_uac = old_uac & ~flags

        if old_uac == new_uac:
            return

        mod = """
dn: %s
changetype: modify
delete: userAccountControl
userAccountControl: %u
add: userAccountControl
userAccountControl: %u
""" % (account_dn, old_uac, new_uac)
        self.modify_ldif(mod)

    def force_password_change_at_next_login(self, search_filter):
        """Forces a password change at next login

        :param search_filter: LDAP filter to find the user (eg
            samccountname=name)
        """
        res = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                          expression=search_filter, attrs=[])
        if len(res) == 0:
                raise Exception('Unable to find user "%s"' % search_filter)
        assert(len(res) == 1)
        user_dn = res[0].dn

        mod = """
dn: %s
changetype: modify
replace: pwdLastSet
pwdLastSet: 0
""" % (user_dn)
        self.modify_ldif(mod)

    def newgroup(self, groupname, groupou=None, grouptype=None,
                 description=None, mailaddress=None, notes=None, sd=None,
                 gidnumber=None, nisdomain=None):
        """Adds a new group with additional parameters

        :param groupname: Name of the new group
        :param grouptype: Type of the new group
        :param description: Description of the new group
        :param mailaddress: Email address of the new group
        :param notes: Notes of the new group
        :param gidnumber: GID Number of the new group
        :param nisdomain: NIS Domain Name of the new group
        :param sd: security descriptor of the object
        """

        group_dn = "CN=%s,%s,%s" % (groupname, (groupou or "CN=Users"), self.domain_dn())

        # The new user record. Note the reliance on the SAMLDB module which
        # fills in the default informations
        ldbmessage = {"dn": group_dn,
            "sAMAccountName": groupname,
            "objectClass": "group"}

        if grouptype is not None:
            ldbmessage["groupType"] = normalise_int32(grouptype)

        if description is not None:
            ldbmessage["description"] = description

        if mailaddress is not None:
            ldbmessage["mail"] = mailaddress

        if notes is not None:
            ldbmessage["info"] = notes

        if gidnumber is not None:
            ldbmessage["gidNumber"] = normalise_int32(gidnumber)

        if nisdomain is not None:
            ldbmessage["msSFU30Name"] = groupname
            ldbmessage["msSFU30NisDomain"] = nisdomain

        if sd is not None:
            ldbmessage["nTSecurityDescriptor"] = ndr_pack(sd)

        self.add(ldbmessage)

    def deletegroup(self, groupname):
        """Deletes a group

        :param groupname: Name of the target group
        """

        groupfilter = "(&(sAMAccountName=%s)(objectCategory=%s,%s))" % (ldb.binary_encode(groupname), "CN=Group,CN=Schema,CN=Configuration", self.domain_dn())
        self.transaction_start()
        try:
            targetgroup = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                               expression=groupfilter, attrs=[])
            if len(targetgroup) == 0:
                raise Exception('Unable to find group "%s"' % groupname)
            assert(len(targetgroup) == 1)
            self.delete(targetgroup[0].dn)
        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()

    def add_remove_group_members(self, groupname, members,
                                  add_members_operation=True):
        """Adds or removes group members

        :param groupname: Name of the target group
        :param members: list of group members
        :param add_members_operation: Defines if its an add or remove
            operation
        """

        groupfilter = "(&(sAMAccountName=%s)(objectCategory=%s,%s))" % (
            ldb.binary_encode(groupname), "CN=Group,CN=Schema,CN=Configuration", self.domain_dn())

        self.transaction_start()
        try:
            targetgroup = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                               expression=groupfilter, attrs=['member'])
            if len(targetgroup) == 0:
                raise Exception('Unable to find group "%s"' % groupname)
            assert(len(targetgroup) == 1)

            modified = False

            addtargettogroup = """
dn: %s
changetype: modify
""" % (str(targetgroup[0].dn))

            for member in members:
                targetmember = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                                    expression="(|(sAMAccountName=%s)(CN=%s))" % (
                    ldb.binary_encode(member), ldb.binary_encode(member)), attrs=[])

                if len(targetmember) != 1:
                    raise Exception('Unable to find "%s". Operation cancelled.' % member)

                if add_members_operation is True and (targetgroup[0].get('member') is None or str(targetmember[0].dn) not in targetgroup[0]['member']):
                    modified = True
                    addtargettogroup += """add: member
member: %s
""" % (str(targetmember[0].dn))

                elif add_members_operation is False and (targetgroup[0].get('member') is not None and str(targetmember[0].dn) in targetgroup[0]['member']):
                    modified = True
                    addtargettogroup += """delete: member
member: %s
""" % (str(targetmember[0].dn))

            if modified is True:
                self.modify_ldif(addtargettogroup)

        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()

    def newuser(self, username, password,
            force_password_change_at_next_login_req=False,
            useusernameascn=False, userou=None, surname=None, givenname=None,
            initials=None, profilepath=None, scriptpath=None, homedrive=None,
            homedirectory=None, jobtitle=None, department=None, company=None,
            description=None, mailaddress=None, internetaddress=None,
            telephonenumber=None, physicaldeliveryoffice=None, sd=None,
            setpassword=True, uidnumber=None, gidnumber=None, gecos=None,
            loginshell=None, uid=None, nisdomain=None, unixhome=None,
            smartcard_required=False):
        """Adds a new user with additional parameters

        :param username: Name of the new user
        :param password: Password for the new user
        :param force_password_change_at_next_login_req: Force password change
        :param useusernameascn: Use username as cn rather that firstname +
            initials + lastname
        :param userou: Object container (without domainDN postfix) for new user
        :param surname: Surname of the new user
        :param givenname: First name of the new user
        :param initials: Initials of the new user
        :param profilepath: Profile path of the new user
        :param scriptpath: Logon script path of the new user
        :param homedrive: Home drive of the new user
        :param homedirectory: Home directory of the new user
        :param jobtitle: Job title of the new user
        :param department: Department of the new user
        :param company: Company of the new user
        :param description: of the new user
        :param mailaddress: Email address of the new user
        :param internetaddress: Home page of the new user
        :param telephonenumber: Phone number of the new user
        :param physicaldeliveryoffice: Office location of the new user
        :param sd: security descriptor of the object
        :param setpassword: optionally disable password reset
        :param uidnumber: RFC2307 Unix numeric UID of the new user
        :param gidnumber: RFC2307 Unix primary GID of the new user
        :param gecos: RFC2307 Unix GECOS field of the new user
        :param loginshell: RFC2307 Unix login shell of the new user
        :param uid: RFC2307 Unix username of the new user
        :param nisdomain: RFC2307 Unix NIS domain of the new user
        :param unixhome: RFC2307 Unix home directory of the new user
        :param smartcard_required: set the UF_SMARTCARD_REQUIRED bit of the new user
        """

        displayname = ""
        if givenname is not None:
            displayname += givenname

        if initials is not None:
            displayname += ' %s.' % initials

        if surname is not None:
            displayname += ' %s' % surname

        cn = username
        if useusernameascn is None and displayname is not "":
            cn = displayname

        user_dn = "CN=%s,%s,%s" % (cn, (userou or "CN=Users"), self.domain_dn())

        dnsdomain = ldb.Dn(self, self.domain_dn()).canonical_str().replace("/", "")
        user_principal_name = "%s@%s" % (username, dnsdomain)
        # The new user record. Note the reliance on the SAMLDB module which
        # fills in the default informations
        ldbmessage = {"dn": user_dn,
                      "sAMAccountName": username,
                      "userPrincipalName": user_principal_name,
                      "objectClass": "user"}

        if smartcard_required:
            ldbmessage["userAccountControl"] = str(dsdb.UF_NORMAL_ACCOUNT|dsdb.UF_SMARTCARD_REQUIRED)
            setpassword = False

        if surname is not None:
            ldbmessage["sn"] = surname

        if givenname is not None:
            ldbmessage["givenName"] = givenname

        if displayname is not "":
            ldbmessage["displayName"] = displayname
            ldbmessage["name"] = displayname

        if initials is not None:
            ldbmessage["initials"] = '%s.' % initials

        if profilepath is not None:
            ldbmessage["profilePath"] = profilepath

        if scriptpath is not None:
            ldbmessage["scriptPath"] = scriptpath

        if homedrive is not None:
            ldbmessage["homeDrive"] = homedrive

        if homedirectory is not None:
            ldbmessage["homeDirectory"] = homedirectory

        if jobtitle is not None:
            ldbmessage["title"] = jobtitle

        if department is not None:
            ldbmessage["department"] = department

        if company is not None:
            ldbmessage["company"] = company

        if description is not None:
            ldbmessage["description"] = description

        if mailaddress is not None:
            ldbmessage["mail"] = mailaddress

        if internetaddress is not None:
            ldbmessage["wWWHomePage"] = internetaddress

        if telephonenumber is not None:
            ldbmessage["telephoneNumber"] = telephonenumber

        if physicaldeliveryoffice is not None:
            ldbmessage["physicalDeliveryOfficeName"] = physicaldeliveryoffice

        if sd is not None:
            ldbmessage["nTSecurityDescriptor"] = ndr_pack(sd)

        ldbmessage2 = None
        if any(map(lambda b: b is not None, (uid, uidnumber, gidnumber, gecos,
                loginshell, nisdomain, unixhome))):
            ldbmessage2 = ldb.Message()
            ldbmessage2.dn = ldb.Dn(self, user_dn)
            if uid is not None:
                ldbmessage2["uid"] = ldb.MessageElement(str(uid), ldb.FLAG_MOD_REPLACE, 'uid')
            if uidnumber is not None:
                ldbmessage2["uidNumber"] = ldb.MessageElement(str(uidnumber), ldb.FLAG_MOD_REPLACE, 'uidNumber')
            if gidnumber is not None:
                ldbmessage2["gidNumber"] = ldb.MessageElement(str(gidnumber), ldb.FLAG_MOD_REPLACE, 'gidNumber')
            if gecos is not None:
                ldbmessage2["gecos"] = ldb.MessageElement(str(gecos), ldb.FLAG_MOD_REPLACE, 'gecos')
            if loginshell is not None:
                ldbmessage2["loginShell"] = ldb.MessageElement(str(loginshell), ldb.FLAG_MOD_REPLACE, 'loginShell')
            if unixhome is not None:
                ldbmessage2["unixHomeDirectory"] = ldb.MessageElement(
                    str(unixhome), ldb.FLAG_MOD_REPLACE, 'unixHomeDirectory')
            if nisdomain is not None:
                ldbmessage2["msSFU30NisDomain"] = ldb.MessageElement(
                    str(nisdomain), ldb.FLAG_MOD_REPLACE, 'msSFU30NisDomain')
                ldbmessage2["msSFU30Name"] = ldb.MessageElement(
                    str(username), ldb.FLAG_MOD_REPLACE, 'msSFU30Name')
                ldbmessage2["unixUserPassword"] = ldb.MessageElement(
                    'ABCD!efgh12345$67890', ldb.FLAG_MOD_REPLACE,
                    'unixUserPassword')

        self.transaction_start()
        try:
            self.add(ldbmessage)
            if ldbmessage2:
                self.modify(ldbmessage2)

            # Sets the password for it
            if setpassword:
                self.setpassword("(samAccountName=%s)" % ldb.binary_encode(username), password,
                                 force_password_change_at_next_login_req)
        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()


    def deleteuser(self, username):
        """Deletes a user

        :param username: Name of the target user
        """

        filter = "(&(sAMAccountName=%s)(objectCategory=%s,%s))" % (ldb.binary_encode(username), "CN=Person,CN=Schema,CN=Configuration", self.domain_dn())
        self.transaction_start()
        try:
            target = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                                 expression=filter, attrs=[])
            if len(target) == 0:
                raise Exception('Unable to find user "%s"' % username)
            assert(len(target) == 1)
            self.delete(target[0].dn)
        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()

    def setpassword(self, search_filter, password,
            force_change_at_next_login=False, username=None):
        """Sets the password for a user

        :param search_filter: LDAP filter to find the user (eg
            samccountname=name)
        :param password: Password for the user
        :param force_change_at_next_login: Force password change
        """
        self.transaction_start()
        try:
            res = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                              expression=search_filter, attrs=[])
            if len(res) == 0:
                raise Exception('Unable to find user "%s"' % (username or search_filter))
            if len(res) > 1:
                raise Exception('Matched %u multiple users with filter "%s"' % (len(res), search_filter))
            user_dn = res[0].dn
            pw = unicode('"' + password.encode('utf-8') + '"', 'utf-8').encode('utf-16-le')
            setpw = """
dn: %s
changetype: modify
replace: unicodePwd
unicodePwd:: %s
""" % (user_dn, base64.b64encode(pw))

            self.modify_ldif(setpw)

            if force_change_at_next_login:
                self.force_password_change_at_next_login(
                  "(distinguishedName=" + str(user_dn) + ")")

            #  modify the userAccountControl to remove the disabled bit
            self.enable_account(search_filter)
        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()

    def setexpiry(self, search_filter, expiry_seconds, no_expiry_req=False):
        """Sets the account expiry for a user

        :param search_filter: LDAP filter to find the user (eg
            samaccountname=name)
        :param expiry_seconds: expiry time from now in seconds
        :param no_expiry_req: if set, then don't expire password
        """
        self.transaction_start()
        try:
            res = self.search(base=self.domain_dn(), scope=ldb.SCOPE_SUBTREE,
                          expression=search_filter,
                          attrs=["userAccountControl", "accountExpires"])
            if len(res) == 0:
                raise Exception('Unable to find user "%s"' % search_filter)
            assert(len(res) == 1)
            user_dn = res[0].dn

            userAccountControl = int(res[0]["userAccountControl"][0])
            accountExpires     = int(res[0]["accountExpires"][0])
            if no_expiry_req:
                userAccountControl = userAccountControl | 0x10000
                accountExpires = 0
            else:
                userAccountControl = userAccountControl & ~0x10000
                accountExpires = samba.unix2nttime(expiry_seconds + int(time.time()))

            setexp = """
dn: %s
changetype: modify
replace: userAccountControl
userAccountControl: %u
replace: accountExpires
accountExpires: %u
""" % (user_dn, userAccountControl, accountExpires)

            self.modify_ldif(setexp)
        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()

    def set_domain_sid(self, sid):
        """Change the domain SID used by this LDB.

        :param sid: The new domain sid to use.
        """
        dsdb._samdb_set_domain_sid(self, sid)

    def get_domain_sid(self):
        """Read the domain SID used by this LDB. """
        return dsdb._samdb_get_domain_sid(self)

    domain_sid = property(get_domain_sid, set_domain_sid,
        "SID for the domain")

    def set_invocation_id(self, invocation_id):
        """Set the invocation id for this SamDB handle.

        :param invocation_id: GUID of the invocation id.
        """
        dsdb._dsdb_set_ntds_invocation_id(self, invocation_id)

    def get_invocation_id(self):
        """Get the invocation_id id"""
        return dsdb._samdb_ntds_invocation_id(self)

    invocation_id = property(get_invocation_id, set_invocation_id,
        "Invocation ID GUID")

    def get_oid_from_attid(self, attid):
        return dsdb._dsdb_get_oid_from_attid(self, attid)

    def get_attid_from_lDAPDisplayName(self, ldap_display_name,
            is_schema_nc=False):
        '''return the attribute ID for a LDAP attribute as an integer as found in DRSUAPI'''
        return dsdb._dsdb_get_attid_from_lDAPDisplayName(self,
            ldap_display_name, is_schema_nc)

    def get_syntax_oid_from_lDAPDisplayName(self, ldap_display_name):
        '''return the syntax OID for a LDAP attribute as a string'''
        return dsdb._dsdb_get_syntax_oid_from_lDAPDisplayName(self, ldap_display_name)

    def get_systemFlags_from_lDAPDisplayName(self, ldap_display_name):
        '''return the systemFlags for a LDAP attribute as a integer'''
        return dsdb._dsdb_get_systemFlags_from_lDAPDisplayName(self, ldap_display_name)

    def get_linkId_from_lDAPDisplayName(self, ldap_display_name):
        '''return the linkID for a LDAP attribute as a integer'''
        return dsdb._dsdb_get_linkId_from_lDAPDisplayName(self, ldap_display_name)

    def get_lDAPDisplayName_by_attid(self, attid):
        '''return the lDAPDisplayName from an integer DRS attribute ID'''
        return dsdb._dsdb_get_lDAPDisplayName_by_attid(self, attid)

    def get_backlink_from_lDAPDisplayName(self, ldap_display_name):
        '''return the attribute name of the corresponding backlink from the name
        of a forward link attribute. If there is no backlink return None'''
        return dsdb._dsdb_get_backlink_from_lDAPDisplayName(self, ldap_display_name)

    def set_ntds_settings_dn(self, ntds_settings_dn):
        """Set the NTDS Settings DN, as would be returned on the dsServiceName
        rootDSE attribute.

        This allows the DN to be set before the database fully exists

        :param ntds_settings_dn: The new DN to use
        """
        dsdb._samdb_set_ntds_settings_dn(self, ntds_settings_dn)

    def get_ntds_GUID(self):
        """Get the NTDS objectGUID"""
        return dsdb._samdb_ntds_objectGUID(self)

    def server_site_name(self):
        """Get the server site name"""
        return dsdb._samdb_server_site_name(self)

    def host_dns_name(self):
        """return the DNS name of this host"""
        res = self.search(base='', scope=ldb.SCOPE_BASE, attrs=['dNSHostName'])
        return res[0]['dNSHostName'][0]

    def domain_dns_name(self):
        """return the DNS name of the domain root"""
        domain_dn = self.get_default_basedn()
        return domain_dn.canonical_str().split('/')[0]

    def forest_dns_name(self):
        """return the DNS name of the forest root"""
        forest_dn = self.get_root_basedn()
        return forest_dn.canonical_str().split('/')[0]

    def load_partition_usn(self, base_dn):
        return dsdb._dsdb_load_partition_usn(self, base_dn)

    def set_schema(self, schema, write_indices_and_attributes=True):
        self.set_schema_from_ldb(schema.ldb, write_indices_and_attributes=write_indices_and_attributes)

    def set_schema_from_ldb(self, ldb_conn, write_indices_and_attributes=True):
        dsdb._dsdb_set_schema_from_ldb(self, ldb_conn, write_indices_and_attributes)

    def dsdb_DsReplicaAttribute(self, ldb, ldap_display_name, ldif_elements):
        '''convert a list of attribute values to a DRSUAPI DsReplicaAttribute'''
        return dsdb._dsdb_DsReplicaAttribute(ldb, ldap_display_name, ldif_elements)

    def dsdb_normalise_attributes(self, ldb, ldap_display_name, ldif_elements):
        '''normalise a list of attribute values'''
        return dsdb._dsdb_normalise_attributes(ldb, ldap_display_name, ldif_elements)

    def get_attribute_from_attid(self, attid):
        """ Get from an attid the associated attribute

        :param attid: The attribute id for searched attribute
        :return: The name of the attribute associated with this id
        """
        if len(self.hash_oid_name.keys()) == 0:
            self._populate_oid_attid()
        if self.hash_oid_name.has_key(self.get_oid_from_attid(attid)):
            return self.hash_oid_name[self.get_oid_from_attid(attid)]
        else:
            return None

    def _populate_oid_attid(self):
        """Populate the hash hash_oid_name.

        This hash contains the oid of the attribute as a key and
        its display name as a value
        """
        self.hash_oid_name = {}
        res = self.search(expression="objectClass=attributeSchema",
                           controls=["search_options:1:2"],
                           attrs=["attributeID",
                           "lDAPDisplayName"])
        if len(res) > 0:
            for e in res:
                strDisplay = str(e.get("lDAPDisplayName"))
                self.hash_oid_name[str(e.get("attributeID"))] = strDisplay

    def get_attribute_replmetadata_version(self, dn, att):
        """Get the version field trom the replPropertyMetaData for
        the given field

        :param dn: The on which we want to get the version
        :param att: The name of the attribute
        :return: The value of the version field in the replPropertyMetaData
            for the given attribute. None if the attribute is not replicated
        """

        res = self.search(expression="distinguishedName=%s" % dn,
                            scope=ldb.SCOPE_SUBTREE,
                            controls=["search_options:1:2"],
                            attrs=["replPropertyMetaData"])
        if len(res) == 0:
            return None

        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        ctr = repl.ctr
        if len(self.hash_oid_name.keys()) == 0:
            self._populate_oid_attid()
        for o in ctr.array:
            # Search for Description
            att_oid = self.get_oid_from_attid(o.attid)
            if self.hash_oid_name.has_key(att_oid) and\
               att.lower() == self.hash_oid_name[att_oid].lower():
                return o.version
        return None

    def set_attribute_replmetadata_version(self, dn, att, value,
            addifnotexist=False):
        res = self.search(expression="distinguishedName=%s" % dn,
                            scope=ldb.SCOPE_SUBTREE,
                            controls=["search_options:1:2"],
                            attrs=["replPropertyMetaData"])
        if len(res) == 0:
            return None

        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        ctr = repl.ctr
        now = samba.unix2nttime(int(time.time()))
        found = False
        if len(self.hash_oid_name.keys()) == 0:
            self._populate_oid_attid()
        for o in ctr.array:
            # Search for Description
            att_oid = self.get_oid_from_attid(o.attid)
            if self.hash_oid_name.has_key(att_oid) and\
               att.lower() == self.hash_oid_name[att_oid].lower():
                found = True
                seq = self.sequence_number(ldb.SEQ_NEXT)
                o.version = value
                o.originating_change_time = now
                o.originating_invocation_id = misc.GUID(self.get_invocation_id())
                o.originating_usn = seq
                o.local_usn = seq

        if not found and addifnotexist and len(ctr.array) >0:
            o2 = drsblobs.replPropertyMetaData1()
            o2.attid = 589914
            att_oid = self.get_oid_from_attid(o2.attid)
            seq = self.sequence_number(ldb.SEQ_NEXT)
            o2.version = value
            o2.originating_change_time = now
            o2.originating_invocation_id = misc.GUID(self.get_invocation_id())
            o2.originating_usn = seq
            o2.local_usn = seq
            found = True
            tab = ctr.array
            tab.append(o2)
            ctr.count = ctr.count + 1
            ctr.array = tab

        if found :
            replBlob = ndr_pack(repl)
            msg = ldb.Message()
            msg.dn = res[0].dn
            msg["replPropertyMetaData"] = ldb.MessageElement(replBlob,
                                                ldb.FLAG_MOD_REPLACE,
                                                "replPropertyMetaData")
            self.modify(msg, ["local_oid:1.3.6.1.4.1.7165.4.3.14:0"])

    def write_prefixes_from_schema(self):
        dsdb._dsdb_write_prefixes_from_schema_to_ldb(self)

    def get_partitions_dn(self):
        return dsdb._dsdb_get_partitions_dn(self)

    def get_nc_root(self, dn):
        return dsdb._dsdb_get_nc_root(self, dn)

    def get_wellknown_dn(self, nc_root, wkguid):
        h_nc = self.hash_well_known.get(str(nc_root))
        dn = None
        if h_nc is not None:
            dn = h_nc.get(wkguid)
        if dn is None:
            dn = dsdb._dsdb_get_wellknown_dn(self, nc_root, wkguid)
            if dn is None:
                return dn
            if h_nc is None:
                self.hash_well_known[str(nc_root)] = {}
                h_nc = self.hash_well_known[str(nc_root)]
            h_nc[wkguid] = dn
        return dn

    def set_minPwdAge(self, value):
        m = ldb.Message()
        m.dn = ldb.Dn(self, self.domain_dn())
        m["minPwdAge"] = ldb.MessageElement(value, ldb.FLAG_MOD_REPLACE, "minPwdAge")
        self.modify(m)

    def get_minPwdAge(self):
        res = self.search(self.domain_dn(), scope=ldb.SCOPE_BASE, attrs=["minPwdAge"])
        if len(res) == 0:
            return None
        elif not "minPwdAge" in res[0]:
            return None
        else:
            return res[0]["minPwdAge"][0]

    def set_minPwdLength(self, value):
        m = ldb.Message()
        m.dn = ldb.Dn(self, self.domain_dn())
        m["minPwdLength"] = ldb.MessageElement(value, ldb.FLAG_MOD_REPLACE, "minPwdLength")
        self.modify(m)

    def get_minPwdLength(self):
        res = self.search(self.domain_dn(), scope=ldb.SCOPE_BASE, attrs=["minPwdLength"])
        if len(res) == 0:
            return None
        elif not "minPwdLength" in res[0]:
            return None
        else:
            return res[0]["minPwdLength"][0]

    def set_pwdProperties(self, value):
        m = ldb.Message()
        m.dn = ldb.Dn(self, self.domain_dn())
        m["pwdProperties"] = ldb.MessageElement(value, ldb.FLAG_MOD_REPLACE, "pwdProperties")
        self.modify(m)

    def get_pwdProperties(self):
        res = self.search(self.domain_dn(), scope=ldb.SCOPE_BASE, attrs=["pwdProperties"])
        if len(res) == 0:
            return None
        elif not "pwdProperties" in res[0]:
            return None
        else:
            return res[0]["pwdProperties"][0]

    def set_dsheuristics(self, dsheuristics):
        m = ldb.Message()
        m.dn = ldb.Dn(self, "CN=Directory Service,CN=Windows NT,CN=Services,%s"
                      % self.get_config_basedn().get_linearized())
        if dsheuristics is not None:
            m["dSHeuristics"] = ldb.MessageElement(dsheuristics,
                ldb.FLAG_MOD_REPLACE, "dSHeuristics")
        else:
            m["dSHeuristics"] = ldb.MessageElement([], ldb.FLAG_MOD_DELETE,
                "dSHeuristics")
        self.modify(m)

    def get_dsheuristics(self):
        res = self.search("CN=Directory Service,CN=Windows NT,CN=Services,%s"
                          % self.get_config_basedn().get_linearized(),
                          scope=ldb.SCOPE_BASE, attrs=["dSHeuristics"])
        if len(res) == 0:
            dsheuristics = None
        elif "dSHeuristics" in res[0]:
            dsheuristics = res[0]["dSHeuristics"][0]
        else:
            dsheuristics = None

        return dsheuristics

    def create_ou(self, ou_dn, description=None, name=None, sd=None):
        """Creates an organizationalUnit object
        :param ou_dn: dn of the new object
        :param description: description attribute
        :param name: name atttribute
        :param sd: security descriptor of the object, can be
        an SDDL string or security.descriptor type
        """
        m = {"dn": ou_dn,
             "objectClass": "organizationalUnit"}

        if description:
            m["description"] = description
        if name:
            m["name"] = name

        if sd:
            m["nTSecurityDescriptor"] = ndr_pack(sd)
        self.add(m)

    def sequence_number(self, seq_type):
        """Returns the value of the sequence number according to the requested type
        :param seq_type: type of sequence number
         """
        self.transaction_start()
        try:
            seq = super(SamDB, self).sequence_number(seq_type)
        except:
            self.transaction_cancel()
            raise
        else:
            self.transaction_commit()
        return seq

    def get_dsServiceName(self):
        '''get the NTDS DN from the rootDSE'''
        res = self.search(base="", scope=ldb.SCOPE_BASE, attrs=["dsServiceName"])
        return res[0]["dsServiceName"][0]

    def get_serverName(self):
        '''get the server DN from the rootDSE'''
        res = self.search(base="", scope=ldb.SCOPE_BASE, attrs=["serverName"])
        return res[0]["serverName"][0]

    def dns_lookup(self, dns_name):
        '''Do a DNS lookup in the database, returns the NDR database structures'''
        return dsdb_dns.lookup(self, dns_name)

    def dns_extract(self, el):
        '''Return the NDR database structures from a dnsRecord element'''
        return dsdb_dns.extract(el)

    def dns_replace(self, dns_name, new_records):
        '''Do a DNS modification on the database, sets the NDR database
        structures on a DNS name
        '''
        return dsdb_dns.replace(self, dns_name, new_records)

    def dns_replace_by_dn(self, dn, new_records):
        '''Do a DNS modification on the database, sets the NDR database
        structures on a LDB DN

        This routine is important because if the last record on the DN
        is removed, this routine will put a tombstone in the record.
        '''
        return dsdb_dns.replace_by_dn(self, dn, new_records)

    def garbage_collect_tombstones(self, dn, current_time,
                                   tombstone_lifetime=None):
        '''garbage_collect_tombstones(lp, samdb, [dn], current_time, tombstone_lifetime)
        -> (num_objects_expunged, num_links_expunged)'''


        if tombstone_lifetime is None:
            return dsdb._dsdb_garbage_collect_tombstones(self, dn,
                                                         current_time)
        else:
            return dsdb._dsdb_garbage_collect_tombstones(self, dn,
                                                         current_time,
                                                         tombstone_lifetime)

    def create_own_rid_set(self):
        '''create a RID set for this DSA'''
        return dsdb._dsdb_create_own_rid_set(self)

    def allocate_rid(self):
        '''return a new RID from the RID Pool on this DSA'''
        return dsdb._dsdb_allocate_rid(self)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #
# Unix SMB/CIFS implementation.
# backend code for provisioning a Samba4 server
#
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2008
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2008-2009
# Copyright (C) Oliver Liebel <oliver@itc.li> 2008-2009
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Functions for setting up a Samba Schema."""

from base64 import b64encode
from samba import read_and_sub_file, substitute_var, check_all_substituted
from samba.dcerpc import security
from samba.ms_schema import read_ms_schema
from samba.ndr import ndr_pack
from samba.samdb import SamDB
from samba import dsdb
from ldb import SCOPE_SUBTREE, SCOPE_ONELEVEL
import os

def get_schema_descriptor(domain_sid, name_map={}):
    sddl = "O:SAG:SAD:AI(OA;;CR;e12b56b6-0a95-11d1-adbb-00c04fd8d5cd;;SA)" \
           "(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)" \
           "(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)" \
           "(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)" \
           "(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)" \
           "(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)" \
           "(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)" \
           "(A;CI;RPLCLORC;;;AU)" \
           "(A;CI;RPWPCRCCLCLORCWOWDSW;;;SA)" \
           "(A;CI;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)" \
           "(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;ED)" \
           "(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;ED)" \
           "(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)" \
           "(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;BA)" \
           "(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ER)" \
           "(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;ER)" \
           "(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;ER)" \
           "S:(AU;SA;WPCCDCWOWDSDDTSW;;;WD)" \
           "(AU;CISA;WP;;;WD)" \
           "(AU;SA;CR;;;BA)" \
           "(AU;SA;CR;;;DU)" \
           "(OU;SA;CR;e12b56b6-0a95-11d1-adbb-00c04fd8d5cd;;WD)" \
           "(OU;SA;CR;45ec5156-db7e-47bb-b53f-dbeb2d03c40f;;WD)"
    sec = security.descriptor.from_sddl(sddl, domain_sid)
    return ndr_pack(sec)


class Schema(object):

    def __init__(self, domain_sid, invocationid=None, schemadn=None,
                 files=None, override_prefixmap=None, additional_prefixmap=None):
        from samba.provision import setup_path

        """Load schema for the SamDB from the AD schema files and
        samba4_schema.ldif

        :param samdb: Load a schema into a SamDB.
        :param schemadn: DN of the schema

        Returns the schema data loaded, to avoid double-parsing when then
        needing to add it to the db
        """

        self.schemadn = schemadn
        # We need to have the am_rodc=False just to keep some warnings quiet -
        # this isn't a real SAM, so it's meaningless.
        self.ldb = SamDB(global_schema=False, am_rodc=False)
        if invocationid is not None:
            self.ldb.set_invocation_id(invocationid)

        self.schema_data = read_ms_schema(
            setup_path('ad-schema/MS-AD_Schema_2K8_R2_Attributes.txt'),
            setup_path('ad-schema/MS-AD_Schema_2K8_R2_Classes.txt'))

        if files is not None:
            for file in files:
                self.schema_data += open(file, 'r').read()

        self.schema_data = substitute_var(self.schema_data,
            {"SCHEMADN": schemadn})
        check_all_substituted(self.schema_data)

        self.schema_dn_modify = read_and_sub_file(
            setup_path("provision_schema_basedn_modify.ldif"),
            {"SCHEMADN": schemadn})

        descr = b64encode(get_schema_descriptor(domain_sid))
        self.schema_dn_add = read_and_sub_file(
            setup_path("provision_schema_basedn.ldif"),
            {"SCHEMADN": schemadn, "DESCRIPTOR": descr})

        if override_prefixmap is not None:
            self.prefixmap_data = override_prefixmap
        else:
            self.prefixmap_data = open(setup_path("prefixMap.txt"), 'r').read()

        if additional_prefixmap is not None:
            for map in additional_prefixmap:
                self.prefixmap_data += "%s\n" % map

        self.prefixmap_data = b64encode(self.prefixmap_data)

        # We don't actually add this ldif, just parse it
        prefixmap_ldif = "dn: %s\nprefixMap:: %s\n\n" % (self.schemadn, self.prefixmap_data)
        self.set_from_ldif(prefixmap_ldif, self.schema_data, self.schemadn)

    def set_from_ldif(self, pf, df, dn):
        dsdb._dsdb_set_schema_from_ldif(self.ldb, pf, df, dn)

    def write_to_tmp_ldb(self, schemadb_path):
        self.ldb.connect(url=schemadb_path)
        self.ldb.transaction_start()
        try:
            self.ldb.add_ldif("""dn: @ATTRIBUTES
linkID: INTEGER

dn: @INDEXLIST
@IDXATTR: linkID
@IDXATTR: attributeSyntax
""")
            # These bits of LDIF are supplied when the Schema object is created
            self.ldb.add_ldif(self.schema_dn_add)
            self.ldb.modify_ldif(self.schema_dn_modify)
            self.ldb.add_ldif(self.schema_data)
        except:
            self.ldb.transaction_cancel()
            raise
        else:
            self.ldb.transaction_commit()

    # Return a hash with the forward attribute as a key and the back as the
    # value
    def linked_attributes(self):
        return get_linked_attributes(self.schemadn, self.ldb)

    def dnsyntax_attributes(self):
        return get_dnsyntax_attributes(self.schemadn, self.ldb)

    def convert_to_openldap(self, target, mapping):
        return dsdb._dsdb_convert_schema_to_openldap(self.ldb, target, mapping)


# Return a hash with the forward attribute as a key and the back as the value
def get_linked_attributes(schemadn, schemaldb):
    attrs = ["linkID", "lDAPDisplayName"]
    res = schemaldb.search(
        expression="(&(linkID=*)"
                   "(!(linkID:1.2.840.113556.1.4.803:=1))"
                   "(objectclass=attributeSchema)"
                   "(attributeSyntax=2.5.5.1))",
        base=schemadn, scope=SCOPE_ONELEVEL, attrs=attrs)
    attributes = {}
    for i in range(0, len(res)):
        expression = ("(&(objectclass=attributeSchema)(linkID=%d)"
                      "(attributeSyntax=2.5.5.1))" %
                      (int(res[i]["linkID"][0])+1))
        target = schemaldb.searchone(basedn=schemadn,
                                     expression=expression,
                                     attribute="lDAPDisplayName",
                                     scope=SCOPE_SUBTREE)
        if target is not None:
            attributes[str(res[i]["lDAPDisplayName"])]=str(target)

    return attributes


def get_dnsyntax_attributes(schemadn,schemaldb):
    res = schemaldb.search(
        expression="(&(!(linkID=*))(objectclass=attributeSchema)(attributeSyntax=2.5.5.1))",
        base=schemadn, scope=SCOPE_ONELEVEL,
        attrs=["linkID", "lDAPDisplayName"])
    attributes = []
    for i in range(0, len(res)):
        attributes.append(str(res[i]["lDAPDisplayName"]))
    return attributes


def ldb_with_schema(schemadn="cn=schema,cn=configuration,dc=example,dc=com",
                    domainsid=None,
                    override_prefixmap=None):
    """Load schema for the SamDB from the AD schema files and samba4_schema.ldif

    :param schemadn: DN of the schema
    :param serverdn: DN of the server

    Returns the schema data loaded as an object, with .ldb being a
    new ldb with the schema loaded.  This allows certain tests to
    operate without a remote or local schema.
    """

    if domainsid is None:
        domainsid = security.random_sid()
    else:
        domainsid = security.dom_sid(domainsid)
    return Schema(domainsid, schemadn=schemadn,
        override_prefixmap=override_prefixmap)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Utility methods for security descriptor manipulation
#
# Copyright Nadezhda Ivanova 2010 <nivanova@samba.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Utility methods for security descriptor manipulation."""

import samba
from ldb import Message, MessageElement, Dn
from ldb import FLAG_MOD_REPLACE, SCOPE_BASE
from samba.ndr import ndr_pack, ndr_unpack
from samba.dcerpc import security


class SDUtils(object):
    """Some utilities for manipulation of security descriptors on objects."""

    def __init__(self, samdb):
        self.ldb = samdb
        self.domain_sid = security.dom_sid(self.ldb.get_domain_sid())

    def modify_sd_on_dn(self, object_dn, sd, controls=None):
        """Modify security descriptor using either SDDL string
            or security.descriptor object
        """
        m = Message()
        m.dn = Dn(self.ldb, object_dn)
        assert(isinstance(sd, str) or isinstance(sd, security.descriptor))
        if isinstance(sd, str):
            tmp_desc = security.descriptor.from_sddl(sd, self.domain_sid)
        elif isinstance(sd, security.descriptor):
            tmp_desc = sd

        m["nTSecurityDescriptor"] = MessageElement(ndr_pack(tmp_desc),
                                                       FLAG_MOD_REPLACE,
                                                       "nTSecurityDescriptor")
        self.ldb.modify(m, controls)

    def read_sd_on_dn(self, object_dn, controls=None):
        res = self.ldb.search(object_dn, SCOPE_BASE, None,
                              ["nTSecurityDescriptor"], controls=controls)
        desc = res[0]["nTSecurityDescriptor"][0]
        return ndr_unpack(security.descriptor, desc)

    def get_object_sid(self, object_dn):
        res = self.ldb.search(object_dn)
        return ndr_unpack(security.dom_sid, res[0]["objectSid"][0])

    def dacl_add_ace(self, object_dn, ace):
        """Add an ACE to an objects security descriptor
        """
        desc = self.read_sd_on_dn(object_dn,["show_deleted:1"])
        desc_sddl = desc.as_sddl(self.domain_sid)
        if ace in desc_sddl:
            return
        if desc_sddl.find("(") >= 0:
            desc_sddl = (desc_sddl[:desc_sddl.index("(")] + ace +
                         desc_sddl[desc_sddl.index("("):])
        else:
            desc_sddl = desc_sddl + ace
        self.modify_sd_on_dn(object_dn, desc_sddl, ["show_deleted:1"])

    def get_sd_as_sddl(self, object_dn, controls=[]):
        """Return object nTSecutiryDescriptor in SDDL format
        """
        desc = self.read_sd_on_dn(object_dn, controls + ["show_deleted:1"])
        return desc.as_sddl(self.domain_sid)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ELF          (      4   t    4    (                  \  \           h  h h              t  t t (  (                    $   $         Qtd                          Rtdh  h h                    GNU '(m&_p              1B          4BE|WqXvT<Yy                           	     p       I             R           "                                '             u                                                                                   7                           f             u              a                             Y                          8               2  8         4       E  8       1  8         4                 	 #  4          l          $  H     =  8        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _PyArg_ParseTupleAndKeywords_SizeT _pytalloc_get_type se_access_check PyLong_FromLong PyImport_ImportModule PyObject_GetAttrString get_friendly_nt_error_msg _Py_BuildValue_SizeT PyErr_SetObject _pytalloc_get_ptr talloc_get_name PyErr_Format _Py_NoneStruct PyExc_TypeError initsecurity Py_InitModule4 libsamba-security.so.0 libsamba-errors.so.1 libtalloc.so.2 libpytalloc-util.so.2 libpython2.7.so.1.0 libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/security.so /usr/lib/arm-linux-gnueabihf/samba SAMBA_4.5.16_DEBIAN SAMBA_ERRORS_1 PYTALLOC_UTIL_2.1.6 GLIBC_2.4 TALLOC_2.0.2                                                                                                       Y                    ii                    "         h    l                                                                    	   
                             @-2  -d  d \ T L D < 4 , $      0 0   R/ T   404 0  0 0C S 00/ 0  S//  ` L   88    A,0A0/ 0  S//   `   L0L 0  0  S/80@-0  S  
(0 0 0  t  H    4 8 80    0  R     0  S
@-3/@H l \   1p@-0@` 0MpQ lP        H!0  {  P  
$ f @P&  
 ` `P-  
 0 k @P   R0p1S   Y> P J     Z  6  0 0 PA%p   G P0 0 @4@   :   X               P        -M( (  $ $  0          @-OOi struct security_descriptor  Expected dcerpc.security.descriptor for security_descriptor argument got  %s    struct security_token   Expected dcerpc.security.token for token argument, got %s   samba   NTSTATUSError   (i,s)   Security support.   security    security_descriptor access_desired  access_check    access_check(security_descriptor, token, access_desired) -> access_granted.  Raises NT_STATUS on error, including on access check failure, returns access granted bitmask                   
  	                                       J     \          l     h          l       o     t     d  
                  x                 $                     o   o  o   oB  o	                                           t         (  (  (  (  (  (  (  (  (  (  (  (  (  (  (                                x            d
                       A,   aeabi "   6 	
"a80c28cbd46dde26a3fc5f709ae91dce981582.debug    `4 .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       L                (         d  d                0         t  t                   8   o   B  B  B                E   o                       T   	      $  $                  ]   	   B       x               f                               a         (  (                   l             |                 r         l  l                    x      2   t  t                           X  X                             h h                            l l                            p p                             t t  (                           d                               4                           4 4                         p        4  -                                a  4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # python site manipulation code
# Copyright Matthieu Patou <mat@matws.net> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Manipulating sites."""

import ldb
from ldb import FLAG_MOD_ADD, LdbError


class SiteException(Exception):
    """Base element for Sites errors"""

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return "%s: %s" % (self.__class__.__name__, self.value)


class SiteNotFoundException(SiteException):
    """Raised when the site is not found and it's expected to exists."""


class SiteAlreadyExistsException(SiteException):
    """Raised when the site is not found and it's expected not to exists."""


class SiteServerNotEmptyException(SiteException):
    """Raised when the site still has servers attached."""


def create_site(samdb, configDn, siteName):
    """
    Create a site

    :param samdb: A samdb connection
    :param configDn: The DN of the configuration partition
    :param siteName: Name of the site to create
    :return: True upon success
    :raise SiteAlreadyExists: if the site to be created already exists.
    """

    ret = samdb.search(base=configDn, scope=ldb.SCOPE_SUBTREE,
                    expression='(&(objectclass=Site)(cn=%s))' % siteName)
    if len(ret) != 0:
        raise SiteAlreadyExistsException('A site with the name %s already exists' % siteName)

    m = ldb.Message()
    m.dn = ldb.Dn(samdb, "Cn=%s,CN=Sites,%s" % (siteName, str(configDn)))
    m["objectclass"] = ldb.MessageElement("site", FLAG_MOD_ADD, "objectclass")

    samdb.add(m)

    m2 = ldb.Message()
    m2.dn = ldb.Dn(samdb, "Cn=NTDS Site Settings,%s" % str(m.dn))
    m2["objectclass"] = ldb.MessageElement("nTDSSiteSettings", FLAG_MOD_ADD, "objectclass")

    samdb.add(m2)

    m3 = ldb.Message()
    m3.dn = ldb.Dn(samdb, "Cn=Servers,%s" % str(m.dn))
    m3["objectclass"] = ldb.MessageElement("serversContainer", FLAG_MOD_ADD, "objectclass")

    samdb.add(m3)

    return True


def delete_site(samdb, configDn, siteName):
    """
    Delete a site

    :param samdb: A samdb connection
    :param configDn: The DN of the configuration partition
    :param siteName: Name of the site to delete
    :return: True upon success
    :raise SiteNotFoundException: if the site to be deleted do not exists.
    :raise SiteServerNotEmpty: if the site has still servers in it.
    """

    dnsite = ldb.Dn(samdb, "CN=Sites")
    if dnsite.add_base(configDn) == False:
        raise SiteException("dnsites.add_base() failed")
    if dnsite.add_child("CN=X") == False:
        raise SiteException("dnsites.add_child() failed")
    dnsite.set_component(0, "CN", siteName)

    dnservers = ldb.Dn(samdb, "CN=Servers")
    dnservers.add_base(dnsite)

    try:
        ret = samdb.search(base=dnsite, scope=ldb.SCOPE_BASE,
                           expression="objectClass=site")
        if len(ret) != 1:
            raise SiteNotFoundException('Site %s does not exist' % siteName)
    except LdbError as (enum, estr):
        if enum == ldb.ERR_NO_SUCH_OBJECT:
            raise SiteNotFoundException('Site %s does not exist' % siteName)

    ret = samdb.search(base=dnservers, scope=ldb.SCOPE_ONELEVEL,
                       expression='(objectclass=server)')
    if len(ret) != 0:
        raise SiteServerNotEmptyException('Site %s still has servers in it, move them before removal' % siteName)

    samdb.delete(dnsite, ["tree_delete:0"])

    return True
                                                                  ELF          (      4   B    4    (                  05  05           p=  p= p= <  @           |=  |= |= h  h                    $   $         Qtd                          Rtdp=  p= p=                    GNU 5jYgA\;   E           1 BE   H   K    4|CEWqXvT<Xy;                           	     x=                                                           p                                                                    [               N                          @                                       [                           {             ;                                       n                                                                    2               A                           &                          #             /                          a             g                          e                          1                           P                                                    ?                                                                                           f                                        x                           o                            P                          R                                        L           "                  A          A         A         A         A                 	    +          A         A         )       __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses _PyArg_ParseTupleAndKeywords_SizeT _talloc_stackframe _talloc_zero lpcfg_from_py_object _pytalloc_get_type s4_event_context_init gensec_init smbcli_state_init lpcfg_smbcli_options lpcfg_smbcli_session_options lpcfg_smb_ports lpcfg_socket_options lpcfg_resolve_context lpcfg_gensec_settings smbcli_full_connection pytalloc_steal _talloc_free PyErr_NoMemory PyImport_ImportModule PyObject_GetAttrString get_friendly_nt_error_msg _Py_BuildValue_SizeT PyErr_SetObject _Py_NoneStruct _PyArg_ParseTuple_SizeT _pytalloc_get_ptr smbcli_close smbcli_deltree smbcli_rmdir smbcli_mkdir PyDict_New PyString_FromString PyDict_SetItemString PyLong_FromUnsignedLongLong PyInt_FromLong PyList_Append _pytalloc_get_mem_ctx talloc_asprintf string_replace PyList_New smbcli_list strlen smb_composite_savefile memset talloc_named_const smb_raw_open __stack_chk_fail __stack_chk_guard smb_raw_set_secdesc talloc_get_name PyErr_Format PyExc_TypeError smb_raw_query_secdesc py_return_ndr_struct smb_composite_loadfile smbcli_chkpath _Py_TrueStruct _Py_ZeroStruct initsmb pytalloc_BaseObject_PyType_Ready Py_InitModule4 PyModule_AddObject libsamba-python.so.0 libsmbclient-raw.so.0 libevents.so.0 libsamba-hostconfig.so.0 libgensec.so.0 libdcerpc.so.0 libsamba-util.so.0 libsamba-errors.so.1 libcli-ldap.so.0 libpython2.7.so.1.0 libtalloc.so.2 libpytalloc-util.so.2 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end samba/smb.so /usr/lib/arm-linux-gnueabihf/samba SAMBA_4.5.16_DEBIAN GLIBC_2.4 SAMBA_ERRORS_1 SAMBA_UTIL_0.0.1 PYTALLOC_UTIL_2.0.6 PYTALLOC_UTIL_2.1.6 SAMBA_HOSTCONFIG_0.0.1 DCERPC_0.0.1 TALLOC_2.0.2                                              	 	 
                                       
                                     5                 ii   I        N            S        c            5                   
 5        ;         T  	 b             0   Y   s     Y                    ii   I                 Q5           ,         Q                       5                 "                       5      p=    t=     @    @    @    @    @    @    @     @    4@    @    @    @    @    @    @    @     A    A    A    A    A    A     A    (A    ,A    0A    8A    <A    @A    HA    LA    PA    XA    \A    `A    hA    lA    pA    xA    |A    A    A    A    A    A    ?   ?   ?   ?   ?   ?   ? %  ? -  ? 0  ? C  >   >   >   >    ?   ? 	  ? 
  ?   ?   ?   ?   ?    ?   $?   (?   ,?   0?   4?   8?   <?   @?   D?   H?   L?   P?    T? !  X? "  \? #  `? $  d? &  h? '  l? (  p? )  t? *  x? +  |? ,  ? .  ? /  ? 1  ? 2  ? 3  ? 4  ? 5  ? 6  ? 7  ? 8  ? 9  ? :  ? ;  ? <  ? =  ? >  ? ?  ? @  ? A  ? B  ? C  ? D  @-  -+           x p h ` X P H @ 8 0 (                        x p h ` X P H @ 8 0 (        0 0   R/_(    404 0  0 0C S 00/ 0  S//+ + (   88    A,0A0/ 0  S//L+ H+ p(   L0L 0  0  S/80@-0  S  
(0 0 0  * 0(   $) * 8 80    0  R     0  S
@-3/@`& '    O-P p B M@\ `	 H00D00"P00L0 0  P\0  `DHLPPPc Pn  
  x"  ` @Ph  
HX  P 0  Q  
HD D  Y  P p P  
P0L P,0<  ;pXp	T            0  48  ,00  0480p0 
0< PT    pP9  T0<00P  U&  
   V P  
  {   V
  
  Pq   V   P {  V
 P_  V
 X PR1Sp   h @   L     ( `'           <        <  <  8  (  0@- P PM 1@@@  P
  
   00      0  $   0@- P dM T@@  P  
 { {  P  ,00      0  0  #   0@- P M @@  P  
 Z 1 S P  
l00      0P   ?H- @ $  ,   ^    ,  $#   P  L  <  0@- P M @@  P  
 $ 1 S P  
l00      0P   	H @   ,   (    \  L"   x  t  d  A-0a `. Q-  
p @ PP    n   P'  
   e i   ^    W p   P A  Q. Q0  S,0,  =!   D  4           ,1@-00`p P 4M 0  4@An@    0     P*  
0   S  
=0 h `\ / B  P   @P  
p0 !0 @X  4< I ` @ 4 |! 8        0@- P M0 @@  P  
  0   G 1 S P  
l00      0P   ,H @   ,   K    h            1!0A-M`$  p       p  $  @0  $@  P2  
(P.  !   $ 0Hd    \00`p X0A0h@l@ (00@ p   X  \1S	  
   ! 0 R  `   X P   <         <        @
  <
  ,
  O-M`r`2p 0 0 H  @0 <@+  PL  
	   PPp  
`. 4	  0 00 0A@@@@ 	    	 1 S #  
	  E0L!  S200	4P @ R  Z1	S  
10      <" 0 R4     6$ P	 	     U      # @	 	  |   B    `0 0 @L    @   
  
      ,  (             	  4"42 C-M P0  0  @0 \@  PJ  
`.  0 00  10 0AAAA@    py   E1 S p)  
p  Eh0,!  S2 00@ `a   0 p 1S!  
 T80     b\" 0 R'     z P q       T l   ydg @ ^  H     A  \       0  x      p  8  4  $  @- ` M   P  
 0 @ 0@@TPp    1 S P  
d    dL   5D# `   (   T     0  (  $    0@- P `M P@@  P  
  3  P  (00      00  (      0@-M(RP   P  "  " 0    @Px  
 00 0 j    c    \    U    N t   G  \   @@ D   9 ,   2   +   $   {   
t   
m   	f   t _p   0@0    (    l                                    @-zz|OO   ../source4/libcli/pysmb.c:587   struct smb_private_data ../source4/libcli/pysmb.c:592   ../source4/libcli/pysmb.c:598   struct cli_credentials  ../source4/libcli/pysmb.c:605   samba   NTSTATUSError   (i,s)   ../source4/libcli/pysmb.c:612   ../source4/libcli/pysmb.c:617   i:close_file    s:deltree   s:rmdir s:mkdir short_name  size    attrib  mtime   z|sH:list   %s\*    %s\%s   ../source4/libcli/pysmb.c:216   ss:savefile s|iiii:open_file    talloc_new: ../source4/libcli/pysmb.c:480   ../source4/libcli/pysmb.c:496   i   sO|I:get_acl    struct security_descriptor  Expected dcerpc.security.descriptor as argument, got %s s|Ii:get_acl    samba.dcerpc.security   s:loadfile  s#  s:chkpath   SMB File I/O support    smb FILE_ATTRIBUTE_READONLY FILE_ATTRIBUTE_HIDDEN   FILE_ATTRIBUTE_SYSTEM   FILE_ATTRIBUTE_VOLUME   FILE_ATTRIBUTE_DIRECTORY    FILE_ATTRIBUTE_ARCHIVE  FILE_ATTRIBUTE_DEVICE   FILE_ATTRIBUTE_NORMAL   FILE_ATTRIBUTE_TEMPORARY    FILE_ATTRIBUTE_SPARSE   FILE_ATTRIBUTE_REPARSE_POINT    FILE_ATTRIBUTE_COMPRESSED   FILE_ATTRIBUTE_OFFLINE  FILE_ATTRIBUTE_NONINDEXED   FILE_ATTRIBUTE_ENCRYPTED    FILE_ATTRIBUTE_ALL_MASK directory   mask    attribs hostname    service creds   lp  loadfile    loadfile(path) -> file contents as a string

 		Read contents of a file.    savefile    savefile(path, str) -> None

 		Write string str to file.   list    list(path) -> directory contents as a dictionary

 		List contents of a directory. The keys are, 
 			name: Long name of the directory item
 			short_name: Short name of the directory item
 			size: File size in bytes
 			attrib: Attributes
 			mtime: Modification time
  mkdir   mkdir(path) -> None

 		Create a directory. rmdir   rmdir(path) -> None

 		Delete a directory. deltree deltree(path) -> None

 		Delete a directory and all its contents.  chkpath chkpath(path) -> True or False

 		Return true if path exists, false otherwise. get_acl get_acl(path[, security_info=0]) -> security_descriptor object

 		Get security descriptor for file.    set_acl set_acl(path, security_descriptor[, security_info=0]) -> None

 		Set security descriptor for file. open_file   open_file(path, access_mask[, share_access[, open_disposition[, create_options]]] -> fnum

 		Open a file. Throws NTSTATUS exceptions on errors.    close_file  close_file(fnum) -> None

 		Close the file based on fnum.  smb.SMB SMB(hostname, service[, creds[, lp]]) -> SMB connection object
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ,     ;     N     c     t                                        +     p=          t=       o     T     d  
              >               8     p                    o   o  o   o   o/                                           |=                                                                                                                                                                      @ <0  H0  P0  X0       0  ,0  40                  4                                                                       4                          @                                     T                                      \0  '     h0  0       0  0  x     1  2  l     2  H2       P2  |2       2  2  (     2   3  4%     (3  3  "     3  3        4  4       4                  A,   aeabi "   6 	
"8506356a5967b4aeeeb3de41eef05cec3b8ba7.debug    Wm7 .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       L                (         d  d                0         T  T                   8   o                         E   o                      T   	      p  p                 ]   	   B   8  8                f                               a                             l                              r         +  +                    x      2   +  +  	                         ,5  ,5                             p= p=                            t= t=                            x= x=                             |= |=  h                        > >                            @  @                            A A                         p        A  -                                A  4                                B                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Add/remove subnets to sites.
#
# Copyright (C) Catalyst.Net Ltd 2015
# Copyright Matthieu Patou <mat@matws.net> 2011
#
# Catalyst.Net's contribution was written by Douglas Bagnall
# <douglas.bagnall@catalyst.net.nz>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import ldb
from ldb import FLAG_MOD_ADD, FLAG_MOD_REPLACE, LdbError
from sites import SiteNotFoundException

class SubnetException(Exception):
    """Base element for Subnet errors"""
    pass


class SubnetNotFound(SubnetException):
    """The subnet requested does not exist."""
    pass


class SubnetAlreadyExists(SubnetException):
    """The subnet being added already exists."""
    pass


class SubnetInvalid(SubnetException):
    """The subnet CIDR is invalid."""
    pass


class SiteNotFound(SubnetException):
    """The site to be used for the subnet does not exist."""
    pass


def create_subnet(samdb, configDn, subnet_name, site_name):
    """Create a subnet and associate it with a site.

    :param samdb: A samdb connection
    :param configDn: The DN of the configuration partition
    :param subnet_name: name of the subnet to create (a CIDR range)
    :return: None
    :raise SubnetAlreadyExists: if the subnet to be created already exists.
    :raise SiteNotFound: if the site does not exist.
    """
    ret = samdb.search(base=configDn, scope=ldb.SCOPE_SUBTREE,
                       expression='(&(objectclass=Site)(cn=%s))' %
                       ldb.binary_encode(site_name))
    if len(ret) != 1:
        raise SiteNotFound('A site with the name %s does not exist' %
                           site_name)
    dn_site = ret[0].dn

    if not isinstance(subnet_name, str):
        raise SubnetInvalid("%s is not a valid subnet (not a string)" % subnet_name)

    dnsubnet = ldb.Dn(samdb, "CN=Subnets,CN=Sites")
    if dnsubnet.add_base(configDn) == False:
        raise SubnetException("dnsubnet.add_base() failed")
    if dnsubnet.add_child("CN=X") == False:
        raise SubnetException("dnsubnet.add_child() failed")
    dnsubnet.set_component(0, "CN", subnet_name)

    try:
        m = ldb.Message()
        m.dn = dnsubnet
        m["objectclass"] = ldb.MessageElement("subnet", FLAG_MOD_ADD,
                                              "objectclass")
        m["siteObject"] = ldb.MessageElement(str(dn_site), FLAG_MOD_ADD,
                                             "siteObject")
        samdb.add(m)
    except ldb.LdbError as (enum, estr):
        if enum == ldb.ERR_INVALID_DN_SYNTAX:
            raise SubnetInvalid("%s is not a valid subnet: %s" % (subnet_name, estr))
        elif enum == ldb.ERR_ENTRY_ALREADY_EXISTS:
            # Subnet collisions are checked by exact match only, not
            # overlapping range. This won't stop you creating
            # 10.1.1.0/24 when there is already 10.1.0.0/16, or
            # prevent you from having numerous IPv6 subnets that refer
            # to the same range (e.g 5::0/16, 5::/16, 5:0:0::/16).
            raise SubnetAlreadyExists('A subnet with the CIDR %s already exists'
                                      % subnet_name)
        else:
            raise


def delete_subnet(samdb, configDn, subnet_name):
    """Delete a subnet.

    :param samdb: A samdb connection
    :param configDn: The DN of the configuration partition
    :param subnet_name: Name of the subnet to delete
    :return: None
    :raise SubnetNotFound: if the subnet to be deleted does not exist.
    """
    dnsubnet = ldb.Dn(samdb, "CN=Subnets,CN=Sites")
    if dnsubnet.add_base(configDn) == False:
        raise SubnetException("dnsubnet.add_base() failed")
    if dnsubnet.add_child("CN=X") == False:
        raise SubnetException("dnsubnet.add_child() failed")
    dnsubnet.set_component(0, "CN", subnet_name)

    try:
        ret = samdb.search(base=dnsubnet, scope=ldb.SCOPE_BASE,
                           expression="objectClass=subnet")
        if len(ret) != 1:
            raise SubnetNotFound('Subnet %s does not exist' % subnet_name)
    except LdbError as (enum, estr):
        if enum == ldb.ERR_NO_SUCH_OBJECT:
            raise SubnetNotFound('Subnet %s does not exist' % subnet_name)

    samdb.delete(dnsubnet)


def set_subnet_site(samdb, configDn, subnet_name, site_name):
    """Assign a subnet to a site.

    This dissociates the subnet from its previous site.

    :param samdb: A samdb connection
    :param configDn: The DN of the configuration partition
    :param subnet_name: Name of the subnet
    :param site_name: Name of the site
    :return: None
    :raise SubnetNotFound: if the subnet does not exist.
    :raise SiteNotFound: if the site does not exist.
    """

    dnsubnet = ldb.Dn(samdb, "CN=Subnets,CN=Sites")
    if dnsubnet.add_base(configDn) == False:
        raise SubnetException("dnsubnet.add_base() failed")
    if dnsubnet.add_child("CN=X") == False:
        raise SubnetException("dnsubnet.add_child() failed")
    dnsubnet.set_component(0, "CN", subnet_name)

    try:
        ret = samdb.search(base=dnsubnet, scope=ldb.SCOPE_BASE,
                           expression="objectClass=subnet")
        if len(ret) != 1:
            raise SubnetNotFound('Subnet %s does not exist' % subnet_name)
    except LdbError as (enum, estr):
        if enum == ldb.ERR_NO_SUCH_OBJECT:
            raise SubnetNotFound('Subnet %s does not exist' % subnet_name)

    dnsite = ldb.Dn(samdb, "CN=Sites")
    if dnsite.add_base(configDn) == False:
        raise SubnetException("dnsites.add_base() failed")
    if dnsite.add_child("CN=X") == False:
        raise SubnetException("dnsites.add_child() failed")
    dnsite.set_component(0, "CN", site_name)

    dnservers = ldb.Dn(samdb, "CN=Servers")
    dnservers.add_base(dnsite)

    try:
        ret = samdb.search(base=dnsite, scope=ldb.SCOPE_BASE,
                           expression="objectClass=site")
        if len(ret) != 1:
            raise SiteNotFoundException('Site %s does not exist' % site_name)
    except LdbError as (enum, estr):
        if enum == ldb.ERR_NO_SUCH_OBJECT:
            raise SiteNotFoundException('Site %s does not exist' % site_name)

    siteDn = str(ret[0].dn)

    m = ldb.Message()
    m.dn = dnsubnet
    m["siteObject"] = ldb.MessageElement(siteDn, FLAG_MOD_REPLACE,
                                         "siteObject")
    samdb.modify(m)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Subunit handling
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2014
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Subunit test protocol."""

import samba

samba.ensure_third_party_module("iso8601", "pyiso8601")
import iso8601

import unittest


PROGRESS_SET = 0
PROGRESS_CUR = 1
PROGRESS_PUSH = 2
PROGRESS_POP = 3


def RemoteError(description=""):
    return (Exception, Exception(description), None)


class RemotedTestCase(unittest.TestCase):
    """A class to represent test cases run in child processes.

    Instances of this class are used to provide the Python test API a TestCase
    that can be printed to the screen, introspected for metadata and so on.
    However, as they are a simply a memoisation of a test that was actually
    run in the past by a separate process, they cannot perform any interactive
    actions.
    """

    def __eq__ (self, other):
        try:
            return self.__description == other.__description
        except AttributeError:
            return False

    def __init__(self, description):
        """Create a psuedo test case with description description."""
        self.__description = description

    def error(self, label):
        raise NotImplementedError("%s on RemotedTestCases is not permitted." %
            label)

    def setUp(self):
        self.error("setUp")

    def tearDown(self):
        self.error("tearDown")

    def shortDescription(self):
        return self.__description

    def id(self):
        return "%s" % (self.__description,)

    def __str__(self):
        return "%s (%s)" % (self.__description, self._strclass())

    def __repr__(self):
        return "<%s description='%s'>" % \
               (self._strclass(), self.__description)

    def run(self, result=None):
        if result is None: result = self.defaultTestResult()
        result.startTest(self)
        result.addError(self, RemoteError("Cannot run RemotedTestCases.\n"))
        result.stopTest(self)

    def _strclass(self):
        cls = self.__class__
        return "%s.%s" % (cls.__module__, cls.__name__)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #!/usr/bin/python
#
# Simple subunit testrunner for python
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2014

# Cobbled together from testtools and subunit:
# Copyright (C) 2005-2011 Robert Collins <robertc@robertcollins.net>
# Copyright (c) 2008-2011 testtools developers.
#
#  Licensed under either the Apache License, Version 2.0 or the BSD 3-clause
#  license at the users choice. A copy of both licenses are available in the
#  project source as Apache-2.0 and BSD. You may not use this file except in
#  compliance with one of these two licences.
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under these licenses is distributed on an "AS IS" BASIS, WITHOUT
#  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
#  license you chose for the specific language governing permissions and
#  limitations under that license.
#

"""Run a unittest testcase reporting results as Subunit.

  $ python -m samba.subunit.run mylib.tests.test_suite
"""

from iso8601.iso8601 import Utc

import datetime
import os
import sys
import traceback
import unittest


# Whether or not to hide layers of the stack trace that are
# unittest/testtools internal code.  Defaults to True since the
# system-under-test is rarely unittest or testtools.
HIDE_INTERNAL_STACK = True


def write_traceback(stream, err, test):
    """Converts a sys.exc_info()-style tuple of values into a string.

    Copied from Python 2.7's unittest.TestResult._exc_info_to_string.
    """
    def _is_relevant_tb_level(tb):
        return '__unittest' in tb.tb_frame.f_globals

    def _count_relevant_tb_levels(tb):
        length = 0
        while tb and not _is_relevant_tb_level(tb):
            length += 1
            tb = tb.tb_next
        return length

    exctype, value, tb = err
    # Skip test runner traceback levels
    if HIDE_INTERNAL_STACK:
        while tb and _is_relevant_tb_level(tb):
            tb = tb.tb_next

    format_exception = traceback.format_exception

    if (HIDE_INTERNAL_STACK and test.failureException
        and isinstance(value, test.failureException)):
        # Skip assert*() traceback levels
        length = _count_relevant_tb_levels(tb)
        msgLines = format_exception(exctype, value, tb, length)
    else:
        msgLines = format_exception(exctype, value, tb)
    stream.writelines(msgLines)


class TestProtocolClient(unittest.TestResult):
    """A TestResult which generates a subunit stream for a test run.

    # Get a TestSuite or TestCase to run
    suite = make_suite()
    # Create a stream (any object with a 'write' method). This should accept
    # bytes not strings: subunit is a byte orientated protocol.
    stream = file('tests.log', 'wb')
    # Create a subunit result object which will output to the stream
    result = subunit.TestProtocolClient(stream)
    # Optionally, to get timing data for performance analysis, wrap the
    # serialiser with a timing decorator
    result = subunit.test_results.AutoTimingTestResultDecorator(result)
    # Run the test suite reporting to the subunit result object
    suite.run(result)
    # Close the stream.
    stream.close()
    """

    def __init__(self, stream):
        unittest.TestResult.__init__(self)
        self._stream = stream

    def addError(self, test, error=None):
        """Report an error in test test.

        :param error: Standard unittest positional argument form - an
            exc_info tuple.
        """
        self._addOutcome("error", test, error=error)

    def addExpectedFailure(self, test, error=None):
        """Report an expected failure in test test.

        :param error: Standard unittest positional argument form - an
            exc_info tuple.
        """
        self._addOutcome("xfail", test, error=error)

    def addFailure(self, test, error=None):
        """Report a failure in test test.

        :param error: Standard unittest positional argument form - an
            exc_info tuple.
        """
        self._addOutcome("failure", test, error=error)

    def _addOutcome(self, outcome, test, error=None, error_permitted=True):
        """Report a failure in test test.

        :param outcome: A string describing the outcome - used as the
            event name in the subunit stream.
        :param error: Standard unittest positional argument form - an
            exc_info tuple.
        :param error_permitted: If True then error must be supplied.
            If False then error must not be supplied.
        """
        self._stream.write(("%s: " % outcome) + self._test_id(test))
        if error_permitted:
            if error is None:
                raise ValueError
        else:
            if error is not None:
                raise ValueError
        if error is not None:
            self._stream.write(" [\n")
            write_traceback(self._stream, error, test)
        else:
            self._stream.write("\n")
        if error is not None:
            self._stream.write("]\n")

    def addSkip(self, test, reason=None):
        """Report a skipped test."""
        if reason is None:
            self._addOutcome("skip", test, error=None)
        else:
            self._stream.write("skip: %s [\n" % test.id())
            self._stream.write("%s\n" % reason)
            self._stream.write("]\n")

    def addSuccess(self, test):
        """Report a success in a test."""
        self._addOutcome("successful", test, error_permitted=False)

    def addUnexpectedSuccess(self, test):
        """Report an unexpected success in test test.
        """
        self._addOutcome("uxsuccess", test, error_permitted=False)

    def _test_id(self, test):
        result = test.id()
        if type(result) is not bytes:
            result = result.encode('utf8')
        return result

    def startTest(self, test):
        """Mark a test as starting its test run."""
        super(TestProtocolClient, self).startTest(test)
        self._stream.write("test: " + self._test_id(test) + "\n")
        self._stream.flush()

    def stopTest(self, test):
        super(TestProtocolClient, self).stopTest(test)
        self._stream.flush()

    def time(self, a_datetime):
        """Inform the client of the time.

        ":param datetime: A datetime.datetime object.
        """
        time = a_datetime.astimezone(Utc())
        self._stream.write("time: %04d-%02d-%02d %02d:%02d:%02d.%06dZ\n" % (
            time.year, time.month, time.day, time.hour, time.minute,
            time.second, time.microsecond))


def _flatten_tests(suite_or_case, unpack_outer=False):
    try:
        tests = iter(suite_or_case)
    except TypeError:
        # Not iterable, assume it's a test case.
        return [(suite_or_case.id(), suite_or_case)]
    if (type(suite_or_case) in (unittest.TestSuite,) or
        unpack_outer):
        # Plain old test suite (or any others we may add).
        result = []
        for test in tests:
            # Recurse to flatten.
            result.extend(_flatten_tests(test))
        return result
    else:
        # Find any old actual test and grab its id.
        suite_id = None
        tests = iterate_tests(suite_or_case)
        for test in tests:
            suite_id = test.id()
            break
        # If it has a sort_tests method, call that.
        if getattr(suite_or_case, 'sort_tests', None) is not None:
            suite_or_case.sort_tests()
        return [(suite_id, suite_or_case)]


def sorted_tests(suite_or_case, unpack_outer=False):
    """Sort suite_or_case while preserving non-vanilla TestSuites."""
    tests = _flatten_tests(suite_or_case, unpack_outer=unpack_outer)
    tests.sort()
    return unittest.TestSuite([test for (sort_key, test) in tests])


def iterate_tests(test_suite_or_case):
    """Iterate through all of the test cases in 'test_suite_or_case'."""
    try:
        suite = iter(test_suite_or_case)
    except TypeError:
        yield test_suite_or_case
    else:
        for test in suite:
            for subtest in iterate_tests(test):
                yield subtest


defaultTestLoader = unittest.defaultTestLoader
defaultTestLoaderCls = unittest.TestLoader

if getattr(defaultTestLoader, 'discover', None) is None:
    try:
        import discover
        defaultTestLoader = discover.DiscoveringTestLoader()
        defaultTestLoaderCls = discover.DiscoveringTestLoader
        have_discover = True
    except ImportError:
        have_discover = False
else:
    have_discover = True


####################
# Taken from python 2.7 and slightly modified for compatibility with
# older versions. Delete when 2.7 is the oldest supported version.
# Modifications:
#  - Use have_discover to raise an error if the user tries to use
#    discovery on an old version and doesn't have discover installed.
#  - If --catch is given check that installHandler is available, as
#    it won't be on old python versions.
#  - print calls have been been made single-source python3 compatibile.
#  - exception handling likewise.
#  - The default help has been changed to USAGE_AS_MAIN and USAGE_FROM_MODULE
#    removed.
#  - A tweak has been added to detect 'python -m *.run' and use a
#    better progName in that case.
#  - self.module is more comprehensively set to None when being invoked from
#    the commandline - __name__ is used as a sentinel value.
#  - --list has been added which can list tests (should be upstreamed).
#  - --load-list has been added which can reduce the tests used (should be
#    upstreamed).
#  - The limitation of using getopt is declared to the user.
#  - http://bugs.python.org/issue16709 is worked around, by sorting tests when
#    discover is used.

CATCHBREAK   = "  -c, --catch      Catch control-C and display results\n"
BUFFEROUTPUT = "  -b, --buffer     Buffer stdout and stderr during test runs\n"

USAGE_AS_MAIN = """\
Usage: %(progName)s [options] [tests]

Options:
  -h, --help       Show this message
  -v, --verbose    Verbose output
  -q, --quiet      Minimal output
  -l, --list       List tests rather than executing them.
  --load-list      Specifies a file containing test ids, only tests matching
                   those ids are executed.
%(catchbreak)s%(buffer)s
Examples:
  %(progName)s test_module               - run tests from test_module
  %(progName)s module.TestClass          - run tests from module.TestClass
  %(progName)s module.Class.test_method  - run specified test method

All options must come before [tests].  [tests] can be a list of any number of
test modules, classes and test methods.

Alternative Usage: %(progName)s discover [options]

Options:
  -v, --verbose    Verbose output
s%(catchbreak)s%(buffer)s  -s directory     Directory to start discovery ('.' default)
  -p pattern       Pattern to match test files ('test*.py' default)
  -t directory     Top level directory of project (default to
                   start directory)
  -l, --list       List tests rather than executing them.
  --load-list      Specifies a file containing test ids, only tests matching
                   those ids are executed.

For test discovery all test modules must be importable from the top
level directory of the project.
"""


# NOT a TestResult, because we are implementing the interface, not inheriting
# it.
class TestResultDecorator(object):
    """General pass-through decorator.

    This provides a base that other TestResults can inherit from to
    gain basic forwarding functionality. It also takes care of
    handling the case where the target doesn't support newer methods
    or features by degrading them.
    """

    def __init__(self, decorated):
        """Create a TestResultDecorator forwarding to decorated."""
        # Make every decorator degrade gracefully.
        self.decorated = decorated

    def startTest(self, test):
        return self.decorated.startTest(test)

    def startTestRun(self):
        return self.decorated.startTestRun()

    def stopTest(self, test):
        return self.decorated.stopTest(test)

    def stopTestRun(self):
        return self.decorated.stopTestRun()

    def addError(self, test, err=None):
        return self.decorated.addError(test, err)

    def addFailure(self, test, err=None):
        return self.decorated.addFailure(test, err)

    def addSuccess(self, test):
        return self.decorated.addSuccess(test)

    def addSkip(self, test, reason=None):
        return self.decorated.addSkip(test, reason)

    def addExpectedFailure(self, test, err=None):
        return self.decorated.addExpectedFailure(test, err)

    def addUnexpectedSuccess(self, test):
        return self.decorated.addUnexpectedSuccess(test)

    def wasSuccessful(self):
        return self.decorated.wasSuccessful()

    @property
    def shouldStop(self):
        return self.decorated.shouldStop

    def stop(self):
        return self.decorated.stop()

    @property
    def testsRun(self):
        return self.decorated.testsRun

    def time(self, a_datetime):
        return self.decorated.time(a_datetime)


class HookedTestResultDecorator(TestResultDecorator):
    """A TestResult which calls a hook on every event."""

    def __init__(self, decorated):
        self.super = super(HookedTestResultDecorator, self)
        self.super.__init__(decorated)

    def startTest(self, test):
        self._before_event()
        return self.super.startTest(test)

    def startTestRun(self):
        self._before_event()
        return self.super.startTestRun()

    def stopTest(self, test):
        self._before_event()
        return self.super.stopTest(test)

    def stopTestRun(self):
        self._before_event()
        return self.super.stopTestRun()

    def addError(self, test, err=None):
        self._before_event()
        return self.super.addError(test, err)

    def addFailure(self, test, err=None):
        self._before_event()
        return self.super.addFailure(test, err)

    def addSuccess(self, test):
        self._before_event()
        return self.super.addSuccess(test)

    def addSkip(self, test, reason=None):
        self._before_event()
        return self.super.addSkip(test, reason)

    def addExpectedFailure(self, test, err=None):
        self._before_event()
        return self.super.addExpectedFailure(test, err)

    def addUnexpectedSuccess(self, test):
        self._before_event()
        return self.super.addUnexpectedSuccess(test)

    def wasSuccessful(self):
        self._before_event()
        return self.super.wasSuccessful()

    @property
    def shouldStop(self):
        self._before_event()
        return self.super.shouldStop

    def stop(self):
        self._before_event()
        return self.super.stop()

    def time(self, a_datetime):
        self._before_event()
        return self.super.time(a_datetime)


class AutoTimingTestResultDecorator(HookedTestResultDecorator):
    """Decorate a TestResult to add time events to a test run.

    By default this will cause a time event before every test event,
    but if explicit time data is being provided by the test run, then
    this decorator will turn itself off to prevent causing confusion.
    """

    def __init__(self, decorated):
        self._time = None
        super(AutoTimingTestResultDecorator, self).__init__(decorated)

    def _before_event(self):
        time = self._time
        if time is not None:
            return
        time = datetime.datetime.utcnow().replace(tzinfo=Utc())
        self.decorated.time(time)

    @property
    def shouldStop(self):
        return self.decorated.shouldStop

    def time(self, a_datetime):
        """Provide a timestamp for the current test activity.

        :param a_datetime: If None, automatically add timestamps before every
            event (this is the default behaviour if time() is not called at
            all).  If not None, pass the provided time onto the decorated
            result object and disable automatic timestamps.
        """
        self._time = a_datetime
        return self.decorated.time(a_datetime)


class SubunitTestRunner(object):

    def __init__(self, verbosity=None, buffer=None, stream=None):
        """Create a SubunitTestRunner.

        :param verbosity: Ignored.
        :param buffer: Ignored.
        """
        self.stream = stream or sys.stdout

    def run(self, test):
        "Run the given test case or test suite."
        result = TestProtocolClient(self.stream)
        result = AutoTimingTestResultDecorator(result)
        test(result)
        return result


class TestProgram(object):
    """A command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    """
    USAGE = USAGE_AS_MAIN

    # defaults for testing
    catchbreak = buffer = progName = None

    def __init__(self, module=__name__, defaultTest=None, argv=None,
                    testRunner=None, testLoader=defaultTestLoader,
                    exit=True, verbosity=1, catchbreak=None,
                    buffer=None, stdout=None):
        if module == __name__:
            self.module = None
        elif isinstance(module, str):
            self.module = __import__(module)
            for part in module.split('.')[1:]:
                self.module = getattr(self.module, part)
        else:
            self.module = module
        if argv is None:
            argv = sys.argv
        if stdout is None:
            stdout = sys.stdout
        if testRunner is None:
            testRunner = SubunitTestRunner()

        self.exit = exit
        self.catchbreak = catchbreak
        self.verbosity = verbosity
        self.buffer = buffer
        self.defaultTest = defaultTest
        self.listtests = False
        self.load_list = None
        self.testRunner = testRunner
        self.testLoader = testLoader
        progName = argv[0]
        if progName.endswith('%srun.py' % os.path.sep):
            elements = progName.split(os.path.sep)
            progName = '%s.run' % elements[-2]
        else:
            progName = os.path.basename(argv[0])
        self.progName = progName
        self.parseArgs(argv)
        if self.load_list:
            # TODO: preserve existing suites (like testresources does in
            # OptimisingTestSuite.add, but with a standard protocol).
            # This is needed because the load_tests hook allows arbitrary
            # suites, even if that is rarely used.
            source = open(self.load_list, 'rb')
            try:
                lines = source.readlines()
            finally:
                source.close()
            test_ids = set(line.strip().decode('utf-8') for line in lines)
            filtered = unittest.TestSuite()
            for test in iterate_tests(self.test):
                if test.id() in test_ids:
                    filtered.addTest(test)
            self.test = filtered
        if not self.listtests:
            self.runTests()
        else:
            for test in iterate_tests(self.test):
                stdout.write('%s\n' % test.id())

    def parseArgs(self, argv):
        if len(argv) > 1 and argv[1].lower() == 'discover':
            self._do_discovery(argv[2:])
            return

        import getopt
        long_opts = ['help', 'verbose', 'quiet', 'catch', 'buffer',
            'list', 'load-list=']
        try:
            options, args = getopt.getopt(argv[1:], 'hHvqfcbl', long_opts)
            for opt, value in options:
                if opt in ('-h','-H','--help'):
                    self.usageExit()
                if opt in ('-q','--quiet'):
                    self.verbosity = 0
                if opt in ('-v','--verbose'):
                    self.verbosity = 2
                if opt in ('-c','--catch'):
                    if self.catchbreak is None:
                        self.catchbreak = True
                    # Should this raise an exception if -c is not valid?
                if opt in ('-b','--buffer'):
                    if self.buffer is None:
                        self.buffer = True
                    # Should this raise an exception if -b is not valid?
                if opt in ('-l', '--list'):
                    self.listtests = True
                if opt == '--load-list':
                    self.load_list = value
            if len(args) == 0 and self.defaultTest is None:
                # createTests will load tests from self.module
                self.testNames = None
            elif len(args) > 0:
                self.testNames = args
            else:
                self.testNames = (self.defaultTest,)
            self.createTests()
        except getopt.error:
            self.usageExit(sys.exc_info()[1])

    def createTests(self):
        if self.testNames is None:
            self.test = self.testLoader.loadTestsFromModule(self.module)
        else:
            self.test = self.testLoader.loadTestsFromNames(self.testNames,
                                                           self.module)

    def _do_discovery(self, argv, Loader=defaultTestLoaderCls):
        # handle command line args for test discovery
        if not have_discover:
            raise AssertionError("Unable to use discovery, must use python 2.7 "
                    "or greater, or install the discover package.")
        self.progName = '%s discover' % self.progName
        import optparse
        parser = optparse.OptionParser()
        parser.prog = self.progName
        parser.add_option('-v', '--verbose', dest='verbose', default=False,
                          help='Verbose output', action='store_true')
        if self.catchbreak != False:
            parser.add_option('-c', '--catch', dest='catchbreak', default=False,
                              help='Catch ctrl-C and display results so far',
                              action='store_true')
        if self.buffer != False:
            parser.add_option('-b', '--buffer', dest='buffer', default=False,
                              help='Buffer stdout and stderr during tests',
                              action='store_true')
        parser.add_option('-s', '--start-directory', dest='start', default='.',
                          help="Directory to start discovery ('.' default)")
        parser.add_option('-p', '--pattern', dest='pattern', default='test*.py',
                          help="Pattern to match tests ('test*.py' default)")
        parser.add_option('-t', '--top-level-directory', dest='top', default=None,
                          help='Top level directory of project (defaults to start directory)')
        parser.add_option('-l', '--list', dest='listtests', default=False, action="store_true",
                          help='List tests rather than running them.')
        parser.add_option('--load-list', dest='load_list', default=None,
                          help='Specify a filename containing the test ids to use.')

        options, args = parser.parse_args(argv)
        if len(args) > 3:
            self.usageExit()

        for name, value in zip(('start', 'pattern', 'top'), args):
            setattr(options, name, value)

        # only set options from the parsing here
        # if they weren't set explicitly in the constructor
        if self.catchbreak is None:
            self.catchbreak = options.catchbreak
        if self.buffer is None:
            self.buffer = options.buffer
        self.listtests = options.listtests
        self.load_list = options.load_list

        if options.verbose:
            self.verbosity = 2

        start_dir = options.start
        pattern = options.pattern
        top_level_dir = options.top

        loader = Loader()
        # See http://bugs.python.org/issue16709
        # While sorting here is intrusive, its better than being random.
        # Rules for the sort:
        # - standard suites are flattened, and the resulting tests sorted by
        #   id.
        # - non-standard suites are preserved as-is, and sorted into position
        #   by the first test found by iterating the suite.
        # We do this by a DSU process: flatten and grab a key, sort, strip the
        # keys.
        loaded = loader.discover(start_dir, pattern, top_level_dir)
        self.test = sorted_tests(loaded)

    def runTests(self):
        if (self.catchbreak
            and getattr(unittest, 'installHandler', None) is not None):
            unittest.installHandler()
        self.result = self.testRunner.run(self.test)
        if self.exit:
            sys.exit(not self.result.wasSuccessful())

    def usageExit(self, msg=None):
        if msg:
            print (msg)
        usage = {'progName': self.progName, 'catchbreak': '',
                 'buffer': ''}
        if self.catchbreak != False:
            usage['catchbreak'] = CATCHBREAK
        if self.buffer != False:
            usage['buffer'] = BUFFEROUTPUT
        usage_text = self.USAGE % usage
        usage_lines = usage_text.split('\n')
        usage_lines.insert(2, "Run a test suite with a subunit reporter.")
        usage_lines.insert(3, "")
        print('\n'.join(usage_lines))
        sys.exit(2)


if __name__ == '__main__':
    TestProgram(module=None, argv=sys.argv, stdout=sys.stdout)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Unix SMB/CIFS implementation.
# tdb util helpers
#
# Copyright (C) Kai Blin <kai@samba.org> 2011
# Copyright (C) Amitay Isaacs <amitay@gmail.com> 2011
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2013
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import samba
import subprocess
import os

def tdb_copy(file1, file2):
    """Copy tdb file using tdbbackup utility and rename it
    """
    # Find the location of tdbbackup tool
    dirs = ["bin", samba.param.bin_dir()] + os.getenv('PATH').split(os.pathsep)
    for d in dirs:
        toolpath = os.path.join(d, "tdbbackup")
        if os.path.exists(toolpath):
            break

    tdbbackup_cmd = [toolpath, "-s", ".copy.tdb", file1]
    status = subprocess.call(tdbbackup_cmd, close_fds=True, shell=False)

    if status == 0:
        os.rename("%s.copy.tdb" % file1, file2)
    else:
        raise Exception("Error copying %s" % file1)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2010
# Copyright (C) Stefan Metzmacher 2014,2015
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Samba Python tests."""

import os
import ldb
import samba
import samba.auth
from samba import param
from samba.samdb import SamDB
from samba import credentials
import samba.ndr
import samba.dcerpc.dcerpc
import samba.dcerpc.base
import samba.dcerpc.epmapper
import socket
import struct
import subprocess
import sys
import tempfile
import unittest

try:
    from unittest import SkipTest
except ImportError:
    class SkipTest(Exception):
        """Test skipped."""

HEXDUMP_FILTER=''.join([(len(repr(chr(x)))==3) and chr(x) or '.' for x in range(256)])

class TestCase(unittest.TestCase):
    """A Samba test case."""

    def setUp(self):
        super(TestCase, self).setUp()
        test_debug_level = os.getenv("TEST_DEBUG_LEVEL")
        if test_debug_level is not None:
            test_debug_level = int(test_debug_level)
            self._old_debug_level = samba.get_debug_level()
            samba.set_debug_level(test_debug_level)
            self.addCleanup(samba.set_debug_level, test_debug_level)

    def get_loadparm(self):
        return env_loadparm()

    def get_credentials(self):
        return cmdline_credentials

    def hexdump(self, src):
        N = 0
        result = ''
        while src:
            ll = src[:8]
            lr = src[8:16]
            src = src[16:]
            hl = ' '.join(["%02X" % ord(x) for x in ll])
            hr = ' '.join(["%02X" % ord(x) for x in lr])
            ll = ll.translate(HEXDUMP_FILTER)
            lr = lr.translate(HEXDUMP_FILTER)
            result += "[%04X] %-*s  %-*s  %s %s\n" % (N, 8*3, hl, 8*3, hr, ll, lr)
            N += 16
        return result

    # These functions didn't exist before Python2.7:
    if sys.version_info < (2, 7):
        import warnings

        def skipTest(self, reason):
            raise SkipTest(reason)

        def assertIn(self, member, container, msg=None):
            self.assertTrue(member in container, msg)

        def assertIs(self, a, b, msg=None):
            self.assertTrue(a is b, msg)

        def assertIsNot(self, a, b, msg=None):
            self.assertTrue(a is not b, msg)

        def assertIsNotNone(self, a, msg=None):
            self.assertTrue(a is not None)

        def assertIsInstance(self, a, b, msg=None):
            self.assertTrue(isinstance(a, b), msg)

        def assertIsNone(self, a, msg=None):
            self.assertTrue(a is None, msg)

        def assertGreater(self, a, b, msg=None):
            self.assertTrue(a > b, msg)

        def assertGreaterEqual(self, a, b, msg=None):
            self.assertTrue(a >= b, msg)

        def assertLess(self, a, b, msg=None):
            self.assertTrue(a < b, msg)

        def assertLessEqual(self, a, b, msg=None):
            self.assertTrue(a <= b, msg)

        def addCleanup(self, fn, *args, **kwargs):
            self._cleanups = getattr(self, "_cleanups", []) + [
                (fn, args, kwargs)]

        def _addSkip(self, result, reason):
            addSkip = getattr(result, 'addSkip', None)
            if addSkip is not None:
                addSkip(self, reason)
            else:
                warnings.warn("TestResult has no addSkip method, skips not reported",
                              RuntimeWarning, 2)
                result.addSuccess(self)

        def run(self, result=None):
            if result is None: result = self.defaultTestResult()
            result.startTest(self)
            testMethod = getattr(self, self._testMethodName)
            try:
                try:
                    self.setUp()
                except SkipTest, e:
                    self._addSkip(result, str(e))
                    return
                except KeyboardInterrupt:
                    raise
                except:
                    result.addError(self, self._exc_info())
                    return

                ok = False
                try:
                    testMethod()
                    ok = True
                except SkipTest, e:
                    self._addSkip(result, str(e))
                    return
                except self.failureException:
                    result.addFailure(self, self._exc_info())
                except KeyboardInterrupt:
                    raise
                except:
                    result.addError(self, self._exc_info())

                try:
                    self.tearDown()
                except SkipTest, e:
                    self._addSkip(result, str(e))
                except KeyboardInterrupt:
                    raise
                except:
                    result.addError(self, self._exc_info())
                    ok = False

                for (fn, args, kwargs) in reversed(getattr(self, "_cleanups", [])):
                    fn(*args, **kwargs)
                if ok: result.addSuccess(self)
            finally:
                result.stopTest(self)


class LdbTestCase(TestCase):
    """Trivial test case for running tests against a LDB."""

    def setUp(self):
        super(LdbTestCase, self).setUp()
        self.filename = os.tempnam()
        self.ldb = samba.Ldb(self.filename)

    def set_modules(self, modules=[]):
        """Change the modules for this Ldb."""
        m = ldb.Message()
        m.dn = ldb.Dn(self.ldb, "@MODULES")
        m["@LIST"] = ",".join(modules)
        self.ldb.add(m)
        self.ldb = samba.Ldb(self.filename)


class TestCaseInTempDir(TestCase):

    def setUp(self):
        super(TestCaseInTempDir, self).setUp()
        self.tempdir = tempfile.mkdtemp()
        self.addCleanup(self._remove_tempdir)

    def _remove_tempdir(self):
        self.assertEquals([], os.listdir(self.tempdir))
        os.rmdir(self.tempdir)
        self.tempdir = None


def env_loadparm():
    lp = param.LoadParm()
    try:
        lp.load(os.environ["SMB_CONF_PATH"])
    except KeyError:
        raise KeyError("SMB_CONF_PATH not set")
    return lp


def env_get_var_value(var_name):
    """Returns value for variable in os.environ

    Function throws AssertionError if variable is defined.
    Unit-test based python tests require certain input params
    to be set in environment, otherwise they can't be run
    """
    assert var_name in os.environ.keys(), "Please supply %s in environment" % var_name
    return os.environ[var_name]


cmdline_credentials = None

class RpcInterfaceTestCase(TestCase):
    """DCE/RPC Test case."""

class RawDCERPCTest(TestCase):
    """A raw DCE/RPC Test case."""

    def _disconnect(self, reason):
        if self.s is None:
            return
        self.s.close()
        self.s = None
        if self.do_hexdump:
            sys.stderr.write("disconnect[%s]\n" % reason)

    def connect(self):
        try:
            self.a = socket.getaddrinfo(self.host, self.tcp_port, socket.AF_UNSPEC,
                                        socket.SOCK_STREAM, socket.SOL_TCP,
                                        0)
            self.s = socket.socket(self.a[0][0], self.a[0][1], self.a[0][2])
            self.s.settimeout(10)
            self.s.connect(self.a[0][4])
        except socket.error as e:
            self.s.close()
            raise
        except IOError as e:
            self.s.close()
            raise
        except Exception as e:
            raise
        finally:
            pass

    def setUp(self):
        super(RawDCERPCTest, self).setUp()
        self.do_ndr_print = False
        self.do_hexdump = False

        self.host = samba.tests.env_get_var_value('SERVER')
        self.tcp_port = 135

        self.settings = {}
        self.settings["lp_ctx"] = self.lp_ctx = samba.tests.env_loadparm()
        self.settings["target_hostname"] = self.host

        self.connect()

    def epmap_reconnect(self, abstract):
        ndr32 = samba.dcerpc.base.transfer_syntax_ndr()

        tsf0_list = [ndr32]
        ctx0 = samba.dcerpc.dcerpc.ctx_list()
        ctx0.context_id = 1
        ctx0.num_transfer_syntaxes = len(tsf0_list)
        ctx0.abstract_syntax = samba.dcerpc.epmapper.abstract_syntax()
        ctx0.transfer_syntaxes = tsf0_list

        req = self.generate_bind(call_id=0, ctx_list=[ctx0])
        self.send_pdu(req)
        rep = self.recv_pdu()
        self.verify_pdu(rep, samba.dcerpc.dcerpc.DCERPC_PKT_BIND_ACK,
                        req.call_id, auth_length=0)
        self.assertEqual(rep.u.max_xmit_frag, req.u.max_xmit_frag)
        self.assertEqual(rep.u.max_recv_frag, req.u.max_recv_frag)
        self.assertNotEqual(rep.u.assoc_group_id, req.u.assoc_group_id)
        self.assertEqual(rep.u.secondary_address_size, 4)
        self.assertEqual(rep.u.secondary_address, "%d" % self.tcp_port)
        self.assertEqual(len(rep.u._pad1), 2)
        self.assertEqual(rep.u._pad1, '\0' * 2)
        self.assertEqual(rep.u.num_results, 1)
        self.assertEqual(rep.u.ctx_list[0].result,
                samba.dcerpc.dcerpc.DCERPC_BIND_ACK_RESULT_ACCEPTANCE)
        self.assertEqual(rep.u.ctx_list[0].reason,
                samba.dcerpc.dcerpc.DCERPC_BIND_ACK_REASON_NOT_SPECIFIED)
        self.assertNDRSyntaxEquals(rep.u.ctx_list[0].syntax, ndr32)
        self.assertEqual(rep.u.auth_info, '\0' * 0)

        # And now try a request
        data1 = samba.ndr.ndr_pack(abstract)
        lhs1 = samba.dcerpc.epmapper.epm_lhs()
        lhs1.protocol = samba.dcerpc.epmapper.EPM_PROTOCOL_UUID
        lhs1.lhs_data = data1[:18]
        rhs1 = samba.dcerpc.epmapper.epm_rhs_uuid()
        rhs1.unknown = data1[18:]
        floor1 = samba.dcerpc.epmapper.epm_floor()
        floor1.lhs = lhs1
        floor1.rhs = rhs1
        data2 = samba.ndr.ndr_pack(ndr32)
        lhs2 = samba.dcerpc.epmapper.epm_lhs()
        lhs2.protocol = samba.dcerpc.epmapper.EPM_PROTOCOL_UUID
        lhs2.lhs_data = data2[:18]
        rhs2 = samba.dcerpc.epmapper.epm_rhs_uuid()
        rhs2.unknown = data1[18:]
        floor2 = samba.dcerpc.epmapper.epm_floor()
        floor2.lhs = lhs2
        floor2.rhs = rhs2
        lhs3 = samba.dcerpc.epmapper.epm_lhs()
        lhs3.protocol = samba.dcerpc.epmapper.EPM_PROTOCOL_NCACN
        lhs3.lhs_data = ""
        floor3 = samba.dcerpc.epmapper.epm_floor()
        floor3.lhs = lhs3
        floor3.rhs.minor_version = 0
        lhs4 = samba.dcerpc.epmapper.epm_lhs()
        lhs4.protocol = samba.dcerpc.epmapper.EPM_PROTOCOL_TCP
        lhs4.lhs_data = ""
        floor4 = samba.dcerpc.epmapper.epm_floor()
        floor4.lhs = lhs4
        floor4.rhs.port = self.tcp_port
        lhs5 = samba.dcerpc.epmapper.epm_lhs()
        lhs5.protocol = samba.dcerpc.epmapper.EPM_PROTOCOL_IP
        lhs5.lhs_data = ""
        floor5 = samba.dcerpc.epmapper.epm_floor()
        floor5.lhs = lhs5
        floor5.rhs.ipaddr = "0.0.0.0"

        floors = [floor1,floor2,floor3,floor4,floor5]
        req_tower = samba.dcerpc.epmapper.epm_tower()
        req_tower.num_floors = len(floors)
        req_tower.floors = floors
        req_twr = samba.dcerpc.epmapper.epm_twr_t()
        req_twr.tower = req_tower

        pack_twr = samba.ndr.ndr_pack(req_twr)

        # object
        stub =  "\x01\x00\x00\x00"
        stub += "\x00" * 16
        # tower
        stub += "\x02\x00\x00\x00"
        stub += pack_twr
        # padding?
        stub += "\x00" * 1
        # handle
        stub += "\x00" * 20
        # max_towers
        stub += "\x04\x00\x00\x00"

        # we do an epm_Map() request
        req = self.generate_request(call_id = 1,
                                    context_id=ctx0.context_id,
                                    opnum=3,
                                    stub=stub)
        self.send_pdu(req)
        rep = self.recv_pdu()
        self.verify_pdu(rep, samba.dcerpc.dcerpc.DCERPC_PKT_RESPONSE,
                        req.call_id, auth_length=0)
        self.assertNotEqual(rep.u.alloc_hint, 0)
        self.assertEqual(rep.u.context_id, req.u.context_id)
        self.assertEqual(rep.u.cancel_count, 0)
        self.assertGreaterEqual(len(rep.u.stub_and_verifier), rep.u.alloc_hint)

        num_towers = struct.unpack_from("<I", rep.u.stub_and_verifier, 20)
        (array_max, array_ofs, array_cnt) = struct.unpack_from("<III", rep.u.stub_and_verifier, 24)
        status = struct.unpack_from("<I", rep.u.stub_and_verifier, len(rep.u.stub_and_verifier) - 4)
        self.assertEqual(status[0], 0)
        self.assertGreaterEqual(num_towers[0], 1)
        self.assertEqual(array_max, 4)
        self.assertEqual(array_ofs, 0)
        self.assertGreaterEqual(array_cnt, 1)

        unpack_twr = rep.u.stub_and_verifier[(36 + 4 * array_cnt):-4]
        rep_twr = samba.ndr.ndr_unpack(samba.dcerpc.epmapper.epm_twr_t, unpack_twr, allow_remaining=True)
        self.assertEqual(rep_twr.tower_length, 75)
        self.assertEqual(rep_twr.tower.num_floors, 5)
        self.assertEqual(len(rep_twr.tower.floors), 5)
        self.assertEqual(rep_twr.tower.floors[3].lhs.protocol,
                          samba.dcerpc.epmapper.EPM_PROTOCOL_TCP)
        self.assertEqual(rep_twr.tower.floors[3].lhs.protocol,
                          samba.dcerpc.epmapper.EPM_PROTOCOL_TCP)

        # reconnect to the given port
        self._disconnect("epmap_reconnect")
        self.tcp_port = rep_twr.tower.floors[3].rhs.port
        self.connect()

    def send_pdu(self, req, ndr_print=None, hexdump=None):
        if ndr_print is None:
            ndr_print = self.do_ndr_print
        if hexdump is None:
            hexdump = self.do_hexdump
        try:
            req_pdu = samba.ndr.ndr_pack(req)
            if ndr_print:
                sys.stderr.write("send_pdu: %s" % samba.ndr.ndr_print(req))
            if hexdump:
                sys.stderr.write("send_pdu: %d\n%s" % (len(req_pdu), self.hexdump(req_pdu)))
            while True:
                sent = self.s.send(req_pdu, 0)
                if sent == len(req_pdu):
                    break
                req_pdu = req_pdu[sent:]
        except socket.error as e:
            self._disconnect("send_pdu: %s" % e)
            raise
        except IOError as e:
            self._disconnect("send_pdu: %s" % e)
            raise
        finally:
            pass

    def recv_raw(self, hexdump=None, timeout=None):
        rep_pdu = None
        if hexdump is None:
            hexdump = self.do_hexdump
        try:
            if timeout is not None:
                self.s.settimeout(timeout)
            rep_pdu = self.s.recv(0xffff, 0)
            self.s.settimeout(10)
            if len(rep_pdu) == 0:
                self._disconnect("recv_raw: EOF")
                return None
            if hexdump:
                sys.stderr.write("recv_raw: %d\n%s" % (len(rep_pdu), self.hexdump(rep_pdu)))
        except socket.timeout as e:
            self.s.settimeout(10)
            sys.stderr.write("recv_raw: TIMEOUT\n")
            pass
        except socket.error as e:
            self._disconnect("recv_raw: %s" % e)
            raise
        except IOError as e:
            self._disconnect("recv_raw: %s" % e)
            raise
        finally:
            pass
        return rep_pdu

    def recv_pdu(self, ndr_print=None, hexdump=None, timeout=None):
        rep = None
        if ndr_print is None:
            ndr_print = self.do_ndr_print
        if hexdump is None:
            hexdump = self.do_hexdump
        try:
            rep_pdu = self.recv_raw(hexdump=hexdump, timeout=timeout)
            if rep_pdu is None:
                return None
            rep = samba.ndr.ndr_unpack(samba.dcerpc.dcerpc.ncacn_packet, rep_pdu, allow_remaining=True)
            if ndr_print:
                sys.stderr.write("recv_pdu: %s" % samba.ndr.ndr_print(rep))
            self.assertEqual(rep.frag_length, len(rep_pdu))
        finally:
            pass
        return rep

    def generate_auth(self,
                      auth_type=None,
                      auth_level=None,
                      auth_pad_length=0,
                      auth_context_id=None,
                      auth_blob=None,
                      ndr_print=None, hexdump=None):
        if ndr_print is None:
            ndr_print = self.do_ndr_print
        if hexdump is None:
            hexdump = self.do_hexdump

        if auth_type is not None:
            a = samba.dcerpc.dcerpc.auth()
            a.auth_type = auth_type
            a.auth_level = auth_level
            a.auth_pad_length = auth_pad_length
            a.auth_context_id= auth_context_id
            a.credentials = auth_blob

            ai = samba.ndr.ndr_pack(a)
            if ndr_print:
                sys.stderr.write("generate_auth: %s" % samba.ndr.ndr_print(a))
            if hexdump:
                sys.stderr.write("generate_auth: %d\n%s" % (len(ai), self.hexdump(ai)))
        else:
            ai = ""

        return ai

    def parse_auth(self, auth_info, ndr_print=None, hexdump=None):
        if ndr_print is None:
            ndr_print = self.do_ndr_print
        if hexdump is None:
            hexdump = self.do_hexdump

        if (len(auth_info) <= samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH):
            return None

        if hexdump:
            sys.stderr.write("parse_auth: %d\n%s" % (len(auth_info), self.hexdump(auth_info)))
        a = samba.ndr.ndr_unpack(samba.dcerpc.dcerpc.auth, auth_info, allow_remaining=True)
        if ndr_print:
            sys.stderr.write("parse_auth: %s" % samba.ndr.ndr_print(a))

        return a

    def generate_pdu(self, ptype, call_id, payload,
                     rpc_vers=5,
                     rpc_vers_minor=0,
                     pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                 samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                     drep = [samba.dcerpc.dcerpc.DCERPC_DREP_LE, 0, 0, 0],
                     ndr_print=None, hexdump=None):

        if getattr(payload, 'auth_info', None):
            ai = payload.auth_info
        else:
            ai = ""

        p = samba.dcerpc.dcerpc.ncacn_packet()
        p.rpc_vers = rpc_vers
        p.rpc_vers_minor = rpc_vers_minor
        p.ptype = ptype
        p.pfc_flags = pfc_flags
        p.drep = drep
        p.frag_length = 0
        if len(ai) > samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH:
            p.auth_length = len(ai) - samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH
        else:
            p.auth_length = 0
        p.call_id = call_id
        p.u = payload

        pdu = samba.ndr.ndr_pack(p)
        p.frag_length = len(pdu)

        return p

    def verify_pdu(self, p, ptype, call_id,
                   rpc_vers=5,
                   rpc_vers_minor=0,
                   pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                               samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                   drep = [samba.dcerpc.dcerpc.DCERPC_DREP_LE, 0, 0, 0],
                   auth_length=None):

        self.assertIsNotNone(p, "No valid pdu")

        if getattr(p.u, 'auth_info', None):
            ai = p.u.auth_info
        else:
            ai = ""

        self.assertEqual(p.rpc_vers, rpc_vers)
        self.assertEqual(p.rpc_vers_minor, rpc_vers_minor)
        self.assertEqual(p.ptype, ptype)
        self.assertEqual(p.pfc_flags, pfc_flags)
        self.assertEqual(p.drep, drep)
        self.assertGreaterEqual(p.frag_length,
                samba.dcerpc.dcerpc.DCERPC_NCACN_PAYLOAD_OFFSET)
        if len(ai) > samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH:
            self.assertEqual(p.auth_length,
                    len(ai) - samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH)
        elif auth_length is not None:
            self.assertEqual(p.auth_length, auth_length)
        else:
            self.assertEqual(p.auth_length, 0)
        self.assertEqual(p.call_id, call_id)

        return

    def generate_bind(self, call_id,
                      pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                  samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                      max_xmit_frag=5840,
                      max_recv_frag=5840,
                      assoc_group_id=0,
                      ctx_list=[],
                      auth_info="",
                      ndr_print=None, hexdump=None):

        b = samba.dcerpc.dcerpc.bind()
        b.max_xmit_frag = max_xmit_frag
        b.max_recv_frag = max_recv_frag
        b.assoc_group_id = assoc_group_id
        b.num_contexts = len(ctx_list)
        b.ctx_list = ctx_list
        b.auth_info = auth_info

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_BIND,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=b,
                              ndr_print=ndr_print, hexdump=hexdump)

        return p

    def generate_alter(self, call_id,
                       pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                   samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                       max_xmit_frag=5840,
                       max_recv_frag=5840,
                       assoc_group_id=0,
                       ctx_list=[],
                       auth_info="",
                       ndr_print=None, hexdump=None):

        a = samba.dcerpc.dcerpc.bind()
        a.max_xmit_frag = max_xmit_frag
        a.max_recv_frag = max_recv_frag
        a.assoc_group_id = assoc_group_id
        a.num_contexts = len(ctx_list)
        a.ctx_list = ctx_list
        a.auth_info = auth_info

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_ALTER,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=a,
                              ndr_print=ndr_print, hexdump=hexdump)

        return p

    def generate_auth3(self, call_id,
                       pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                   samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                       auth_info="",
                       ndr_print=None, hexdump=None):

        a = samba.dcerpc.dcerpc.auth3()
        a.auth_info = auth_info

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_AUTH3,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=a,
                              ndr_print=ndr_print, hexdump=hexdump)

        return p

    def generate_request(self, call_id,
                         pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                     samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                         alloc_hint=None,
                         context_id=None,
                         opnum=None,
                         object=None,
                         stub=None,
                         auth_info="",
                         ndr_print=None, hexdump=None):

        if alloc_hint is None:
            alloc_hint = len(stub)

        r = samba.dcerpc.dcerpc.request()
        r.alloc_hint = alloc_hint
        r.context_id = context_id
        r.opnum = opnum
        if object is not None:
            r.object = object
        r.stub_and_verifier = stub + auth_info

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_REQUEST,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=r,
                              ndr_print=ndr_print, hexdump=hexdump)

        if len(auth_info) > samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH:
            p.auth_length = len(auth_info) - samba.dcerpc.dcerpc.DCERPC_AUTH_TRAILER_LENGTH

        return p

    def generate_co_cancel(self, call_id,
                           pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                       samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                           auth_info="",
                           ndr_print=None, hexdump=None):

        c = samba.dcerpc.dcerpc.co_cancel()
        c.auth_info = auth_info

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_CO_CANCEL,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=c,
                              ndr_print=ndr_print, hexdump=hexdump)

        return p

    def generate_orphaned(self, call_id,
                          pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                      samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                          auth_info="",
                          ndr_print=None, hexdump=None):

        o = samba.dcerpc.dcerpc.orphaned()
        o.auth_info = auth_info

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_ORPHANED,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=o,
                              ndr_print=ndr_print, hexdump=hexdump)

        return p

    def generate_shutdown(self, call_id,
                          pfc_flags = samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_FIRST |
                                      samba.dcerpc.dcerpc.DCERPC_PFC_FLAG_LAST,
                          ndr_print=None, hexdump=None):

        s = samba.dcerpc.dcerpc.shutdown()

        p = self.generate_pdu(ptype=samba.dcerpc.dcerpc.DCERPC_PKT_SHUTDOWN,
                              pfc_flags=pfc_flags,
                              call_id=call_id,
                              payload=s,
                              ndr_print=ndr_print, hexdump=hexdump)

        return p

    def assertIsConnected(self):
        self.assertIsNotNone(self.s, msg="Not connected")
        return

    def assertNotConnected(self):
        self.assertIsNone(self.s, msg="Is connected")
        return

    def assertNDRSyntaxEquals(self, s1, s2):
        self.assertEqual(s1.uuid, s2.uuid)
        self.assertEqual(s1.if_version, s2.if_version)
        return

class ValidNetbiosNameTests(TestCase):

    def test_valid(self):
        self.assertTrue(samba.valid_netbios_name("FOO"))

    def test_too_long(self):
        self.assertFalse(samba.valid_netbios_name("FOO"*10))

    def test_invalid_characters(self):
        self.assertFalse(samba.valid_netbios_name("*BLA"))


class BlackboxProcessError(Exception):
    """This is raised when check_output() process returns a non-zero exit status

    Exception instance should contain the exact exit code (S.returncode),
    command line (S.cmd), process output (S.stdout) and process error stream
    (S.stderr)
    """

    def __init__(self, returncode, cmd, stdout, stderr):
        self.returncode = returncode
        self.cmd = cmd
        self.stdout = stdout
        self.stderr = stderr

    def __str__(self):
        return "Command '%s'; exit status %d; stdout: '%s'; stderr: '%s'" % (self.cmd, self.returncode,
                                                                             self.stdout, self.stderr)

class BlackboxTestCase(TestCaseInTempDir):
    """Base test case for blackbox tests."""

    def _make_cmdline(self, line):
        bindir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../../../bin"))
        parts = line.split(" ")
        if os.path.exists(os.path.join(bindir, parts[0])):
            parts[0] = os.path.join(bindir, parts[0])
        line = " ".join(parts)
        return line

    def check_run(self, line):
        self.check_exit_code(line, 0)

    def check_exit_code(self, line, expected):
        line = self._make_cmdline(line)
        p = subprocess.Popen(line,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             shell=True)
        stdoutdata, stderrdata = p.communicate()
        retcode = p.returncode
        if retcode != expected:
            raise BlackboxProcessError(retcode,
                                       line,
                                       stdoutdata,
                                       stderrdata)

    def check_output(self, line):
        line = self._make_cmdline(line)
        p = subprocess.Popen(line, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, close_fds=True)
        stdoutdata, stderrdata = p.communicate()
        retcode = p.returncode
        if retcode:
            raise BlackboxProcessError(retcode, line, stdoutdata, stderrdata)
        return stdoutdata


def connect_samdb(samdb_url, lp=None, session_info=None, credentials=None,
                  flags=0, ldb_options=None, ldap_only=False, global_schema=True):
    """Create SamDB instance and connects to samdb_url database.

    :param samdb_url: Url for database to connect to.
    :param lp: Optional loadparm object
    :param session_info: Optional session information
    :param credentials: Optional credentials, defaults to anonymous.
    :param flags: Optional LDB flags
    :param ldap_only: If set, only remote LDAP connection will be created.
    :param global_schema: Whether to use global schema.

    Added value for tests is that we have a shorthand function
    to make proper URL for ldb.connect() while using default
    parameters for connection based on test environment
    """
    if not "://" in samdb_url:
        if not ldap_only and os.path.isfile(samdb_url):
            samdb_url = "tdb://%s" % samdb_url
        else:
            samdb_url = "ldap://%s" % samdb_url
    # use 'paged_search' module when connecting remotely
    if samdb_url.startswith("ldap://"):
        ldb_options = ["modules:paged_searches"]
    elif ldap_only:
        raise AssertionError("Trying to connect to %s while remote "
                             "connection is required" % samdb_url)

    # set defaults for test environment
    if lp is None:
        lp = env_loadparm()
    if session_info is None:
        session_info = samba.auth.system_session(lp)
    if credentials is None:
        credentials = cmdline_credentials

    return SamDB(url=samdb_url,
                 lp=lp,
                 session_info=session_info,
                 credentials=credentials,
                 flags=flags,
                 options=ldb_options,
                 global_schema=global_schema)


def connect_samdb_ex(samdb_url, lp=None, session_info=None, credentials=None,
                     flags=0, ldb_options=None, ldap_only=False):
    """Connects to samdb_url database

    :param samdb_url: Url for database to connect to.
    :param lp: Optional loadparm object
    :param session_info: Optional session information
    :param credentials: Optional credentials, defaults to anonymous.
    :param flags: Optional LDB flags
    :param ldap_only: If set, only remote LDAP connection will be created.
    :return: (sam_db_connection, rootDse_record) tuple
    """
    sam_db = connect_samdb(samdb_url, lp, session_info, credentials,
                           flags, ldb_options, ldap_only)
    # fetch RootDse
    res = sam_db.search(base="", expression="", scope=ldb.SCOPE_BASE,
                        attrs=["*"])
    return (sam_db, res[0])


def connect_samdb_env(env_url, env_username, env_password, lp=None):
    """Connect to SamDB by getting URL and Credentials from environment

    :param env_url: Environment variable name to get lsb url from
    :param env_username: Username environment variable
    :param env_password: Password environment variable
    :return: sam_db_connection
    """
    samdb_url = env_get_var_value(env_url)
    creds = credentials.Credentials()
    if lp is None:
        # guess Credentials parameters here. Otherwise workstation
        # and domain fields are NULL and gencache code segfalts
        lp = param.LoadParm()
        creds.guess(lp)
    creds.set_username(env_get_var_value(env_username))
    creds.set_password(env_get_var_value(env_password))
    return connect_samdb(samdb_url, credentials=creds, lp=lp)


def delete_force(samdb, dn):
    try:
        samdb.delete(dn)
    except ldb.LdbError, (num, errstr):
        assert num == ldb.ERR_NO_SUCH_OBJECT, "ldb.delete() failed: %s" % errstr
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for the Auth Python bindings.

Note that this just tests the bindings work. It does not intend to test
the functionality, that's already done in other tests.
"""

from samba import auth
import samba.tests

class AuthTests(samba.tests.TestCase):

    def test_system_session(self):
        auth.system_session()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2008

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Blackbox tests. """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Blackbox tests for ndrdump
# Copyright (C) 2008 Andrew Tridgell <tridge@samba.org>
# Copyright (C) 2008 Andrew Bartlett <abartlet@samba.org>
# Copyright (C) 2010 Jelmer Vernooij <jelmer@samba.org>
# based on test_smbclient.sh

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Blackbox tests for ndrdump."""

import os
from samba.tests import BlackboxTestCase

for p in [ "../../../../../source4/librpc/tests", "../../../../../librpc/tests"]:
    data_path_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), p))
    print data_path_dir
    if os.path.exists(data_path_dir):
        break


class NdrDumpTests(BlackboxTestCase):
    """Blackbox tests for ndrdump."""

    def data_path(self, name):
        return os.path.join(data_path_dir, name)

    def test_ndrdump_with_in(self):
        self.check_run("ndrdump samr samr_CreateUser in %s" % (self.data_path("samr-CreateUser-in.dat")))

    def test_ndrdump_with_out(self):
        self.check_run("ndrdump samr samr_CreateUser out %s" % (self.data_path("samr-CreateUser-out.dat")))

    def test_ndrdump_context_file(self):
        self.check_run("ndrdump --context-file %s samr samr_CreateUser out %s" % (self.data_path("samr-CreateUser-in.dat"), self.data_path("samr-CreateUser-out.dat")))

    def test_ndrdump_with_validate(self):
        self.check_run("ndrdump --validate samr samr_CreateUser in %s" % (self.data_path("samr-CreateUser-in.dat")))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Blackbox tests for "samba_dnsupdate" command
# Copyright (C) Kamen Mazdrashki <kamenim@samba.org> 2011
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2015
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import samba.tests

class SambaDnsUpdateTests(samba.tests.BlackboxTestCase):
    """Blackbox test case for samba_dnsupdate."""

    def setUp(self):
        self.server_ip = samba.tests.env_get_var_value("DNS_SERVER_IP")
        super(SambaDnsUpdateTests, self).setUp()
        try:
            out = self.check_output("samba_dnsupdate --verbose")
            self.assertTrue("Looking for DNS entry" in out, out)
        except samba.tests.BlackboxProcessError:
            pass

    def test_samba_dnsupate_no_change(self):
        out = self.check_output("samba_dnsupdate --verbose")
        self.assertTrue("No DNS updates needed" in out, out)

    def test_samba_dnsupate_set_ip(self):
        try:
            out = self.check_output("samba_dnsupdate --verbose --current-ip=10.0.0.1")
            self.assertTrue(" DNS updates and" in out, out)
            self.assertTrue(" DNS deletes needed" in out, out)
        except samba.tests.BlackboxProcessError:
            pass

        try:
            out = self.check_output("samba_dnsupdate --verbose --use-nsupdate --current-ip=10.0.0.1")
        except samba.tests.BlackboxProcessError as e:
            self.fail("Error calling samba_dnsupdate: %s" % e)

        self.assertTrue("No DNS updates needed" in out, out)
        try:
            out = self.check_output("samba_dnsupdate --verbose --use-samba-tool --rpc-server-ip=%s" % self.server_ip)
        except samba.tests.BlackboxProcessError as e:
            self.fail("Error calling samba_dnsupdate: %s" % e)

        self.assertTrue(" DNS updates and" in out, out)
        self.assertTrue(" DNS deletes needed" in out, out)
        out = self.check_output("samba_dnsupdate --verbose")
        self.assertTrue("No DNS updates needed" in out, out)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Blackbox tests for "samba-tool drs" command
# Copyright (C) Kamen Mazdrashki <kamenim@samba.org> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Blackbox tests for samba-tool drs."""

import samba.tests
import shutil
import os
import ldb

class SambaToolDrsTests(samba.tests.BlackboxTestCase):
    """Blackbox test case for samba-tool drs."""

    def setUp(self):
        super(SambaToolDrsTests, self).setUp()

        self.dc1 = samba.tests.env_get_var_value("DC1")
        self.dc2 = samba.tests.env_get_var_value("DC2")

        creds = self.get_credentials()
        self.cmdline_creds = "-U%s/%s%%%s" % (creds.get_domain(),
                                              creds.get_username(), creds.get_password())

    def _get_rootDSE(self, dc, ldap_only=True):
        samdb = samba.tests.connect_samdb(dc, lp=self.get_loadparm(),
                                          credentials=self.get_credentials(),
                                          ldap_only=ldap_only)
        return samdb.search(base="", scope=samba.tests.ldb.SCOPE_BASE)[0]

    def test_samba_tool_bind(self):
        """Tests 'samba-tool drs bind' command."""

        # Output should be like:
        #      Extensions supported:
        #        <list-of-supported-extensions>
        #      Site GUID: <GUID>
        #      Repl epoch: 0
        out = self.check_output("samba-tool drs bind %s %s" % (self.dc1,
                                                               self.cmdline_creds))
        self.assertTrue("Site GUID:" in out)
        self.assertTrue("Repl epoch:" in out)

    def test_samba_tool_kcc(self):
        """Tests 'samba-tool drs kcc' command."""

        # Output should be like 'Consistency check on <DC> successful.'
        out = self.check_output("samba-tool drs kcc %s %s" % (self.dc1,
                                                              self.cmdline_creds))
        self.assertTrue("Consistency check on" in out)
        self.assertTrue("successful" in out)

    def test_samba_tool_showrepl(self):
        """Tests 'samba-tool drs showrepl' command.
        """
        # Output should be like:
        #      <site-name>/<domain-name>
        #      DSA Options: <hex-options>
        #      DSA object GUID: <DSA-object-GUID>
        #      DSA invocationId: <DSA-invocationId>
        #      <Inbound-connections-list>
        #      <Outbound-connections-list>
        #      <KCC-objects>
        #      ...
        #   TODO: Perhaps we should check at least for
        #         DSA's objectGUDI and invocationId
        out = self.check_output("samba-tool drs showrepl %s %s" % (self.dc1,
                                                                   self.cmdline_creds))
        self.assertTrue("DSA Options:" in out)
        self.assertTrue("DSA object GUID:" in out)
        self.assertTrue("DSA invocationId:" in out)

    def test_samba_tool_options(self):
        """Tests 'samba-tool drs options' command
        """
        # Output should be like 'Current DSA options: IS_GC <OTHER_FLAGS>'
        out = self.check_output("samba-tool drs options %s %s" % (self.dc1,
                                                                  self.cmdline_creds))
        self.assertTrue("Current DSA options:" in out)

    def test_samba_tool_replicate(self):
        """Tests 'samba-tool drs replicate' command."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was successful.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate %s %s %s %s" % (self.dc1,
                                                                          self.dc2,
                                                                          nc_name,
                                                                          self.cmdline_creds))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was successful" in out)

    def test_samba_tool_replicate_async(self):
        """Tests 'samba-tool drs replicate --async-op' command."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was started.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate --async-op %s %s %s %s" % (self.dc1,
                                                                          self.dc2,
                                                                          nc_name,
                                                                          self.cmdline_creds))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was started" in out)

    def test_samba_tool_replicate_local_online(self):
        """Tests 'samba-tool drs replicate --local-online' command."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was successful.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate --local-online %s %s %s" % (self.dc1,
                                                                                      self.dc2,
                                                                                      nc_name))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was successful" in out)

    def test_samba_tool_replicate_local_online_async(self):
        """Tests 'samba-tool drs replicate --local-online --async-op' command."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was started.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate --local-online --async-op %s %s %s" % (self.dc1,
                                                                                      self.dc2,
                                                                                      nc_name))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was started" in out)

    def test_samba_tool_replicate_local_machine_creds(self):
        """Tests 'samba-tool drs replicate --local -P' command (uses machine creds)."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was successful.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate -P --local %s %s %s" % (self.dc1,
                                                                                  self.dc2,
                                                                                  nc_name))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was successful" in out)

    def test_samba_tool_replicate_local(self):
        """Tests 'samba-tool drs replicate --local' command (uses machine creds)."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was successful.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate --local %s %s %s %s" % (self.dc1,
                                                                                  self.dc2,
                                                                                  nc_name,
                                                                                  self.cmdline_creds))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was successful" in out)

    def test_samba_tool_replicate_machine_creds_P(self):
        """Tests 'samba-tool drs replicate -P' command with machine creds."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was successful.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate -P %s %s %s" % (self.dc1,
                                                                          self.dc2,
                                                                          nc_name))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was successful" in out)

    def test_samba_tool_replicate_machine_creds(self):
        """Tests 'samba-tool drs replicate' command with implicit machine creds."""

        # Output should be like 'Replicate from <DC-SRC> to <DC-DEST> was successful.'
        nc_name = self._get_rootDSE(self.dc1)["defaultNamingContext"]
        out = self.check_output("samba-tool drs replicate %s %s %s" % (self.dc1,
                                                                       self.dc2,
                                                                       nc_name))
        self.assertTrue("Replicate from" in out)
        self.assertTrue("was successful" in out)

    def test_samba_tool_drs_clone_dc(self):
        """Tests 'samba-tool drs clone-dc-database' command."""
        server_rootdse = self._get_rootDSE(self.dc1)
        server_nc_name = server_rootdse["defaultNamingContext"]
        server_ds_name = server_rootdse["dsServiceName"]
        server_ldap_service_name = str(server_rootdse["ldapServiceName"][0])
        server_realm = server_ldap_service_name.split(":")[0]
        creds = self.get_credentials()
        out = self.check_output("samba-tool drs clone-dc-database %s --server=%s %s --targetdir=%s"
                                % (server_realm,
                                   self.dc1,
                                   self.cmdline_creds,
                                   self.tempdir))
        ldb_rootdse = self._get_rootDSE("tdb://" + os.path.join(self.tempdir, "private", "sam.ldb"), ldap_only=False)
        nc_name = ldb_rootdse["defaultNamingContext"]
        ds_name = ldb_rootdse["dsServiceName"]
        ldap_service_name = str(server_rootdse["ldapServiceName"][0])
        self.assertEqual(nc_name, server_nc_name)
        # The clone should pretend to be the source server
        self.assertEqual(ds_name, server_ds_name)
        self.assertEqual(ldap_service_name, server_ldap_service_name)

        samdb = samba.tests.connect_samdb("tdb://" + os.path.join(self.tempdir, "private", "sam.ldb"),
                                          ldap_only=False, lp=self.get_loadparm())
        def get_krbtgt_pw():
            krbtgt_pw = samdb.searchone("unicodePwd", "cn=krbtgt,CN=users,%s" % nc_name)
        self.assertRaises(KeyError, get_krbtgt_pw)

        server_dn = samdb.searchone("serverReferenceBL", "cn=%s,ou=domain controllers,%s" % (self.dc2, server_nc_name))
        ntds_guid = samdb.searchone("objectGUID", "cn=ntds settings,%s" % server_dn)

        res = samdb.search(base=str(server_nc_name),
                           expression="(&(objectclass=user)(cn=dns-%s))" % (self.dc2),
                           attrs=[], scope=ldb.SCOPE_SUBTREE)
        if len(res) == 1:
            dns_obj = res[0]
        else:
            dns_obj = None

        # While we have this cloned, try demoting the other server on the clone, by GUID
        out = self.check_output("samba-tool domain demote --remove-other-dead-server=%s -H %s/private/sam.ldb"
                                % (ntds_guid,
                                   self.tempdir))

        # Check some of the objects that should have been removed
        def check_machine_obj():
            samdb.searchone("CN", "cn=%s,ou=domain controllers,%s" % (self.dc2, server_nc_name))
        self.assertRaises(ldb.LdbError, check_machine_obj)

        def check_server_obj():
            samdb.searchone("CN", server_dn)
        self.assertRaises(ldb.LdbError, check_server_obj)

        def check_ntds_guid():
            samdb.searchone("CN", "<GUID=%s>" % ntds_guid)
        self.assertRaises(ldb.LdbError, check_ntds_guid)

        if dns_obj is not None:
            # Check some of the objects that should have been removed
            def check_dns_account_obj():
                samdb.search(base=dns_obj.dn, scope=ldb.SCOPE_BASE,
                             attrs=[])
            self.assertRaises(ldb.LdbError, check_dns_account_obj)

        shutil.rmtree(os.path.join(self.tempdir, "private"))
        shutil.rmtree(os.path.join(self.tempdir, "etc"))
        shutil.rmtree(os.path.join(self.tempdir, "msg.lock"))
        os.remove(os.path.join(self.tempdir, "names.tdb"))
        shutil.rmtree(os.path.join(self.tempdir, "state"))

    def test_samba_tool_drs_clone_dc_secrets(self):
        """Tests 'samba-tool drs clone-dc-database --include-secrets' command ."""
        server_rootdse = self._get_rootDSE(self.dc1)
        server_nc_name = server_rootdse["defaultNamingContext"]
        server_ds_name = server_rootdse["dsServiceName"]
        server_ldap_service_name = str(server_rootdse["ldapServiceName"][0])
        server_realm = server_ldap_service_name.split(":")[0]
        creds = self.get_credentials()
        out = self.check_output("samba-tool drs clone-dc-database %s --server=%s %s --targetdir=%s --include-secrets"
                                % (server_realm,
                                   self.dc1,
                                   self.cmdline_creds,
                                   self.tempdir))
        ldb_rootdse = self._get_rootDSE("tdb://" + os.path.join(self.tempdir, "private", "sam.ldb"), ldap_only=False)
        nc_name = ldb_rootdse["defaultNamingContext"]
        config_nc_name = ldb_rootdse["configurationNamingContext"]
        ds_name = ldb_rootdse["dsServiceName"]
        ldap_service_name = str(server_rootdse["ldapServiceName"][0])

        samdb = samba.tests.connect_samdb("tdb://" + os.path.join(self.tempdir, "private", "sam.ldb"),
                                          ldap_only=False, lp=self.get_loadparm())
        krbtgt_pw = samdb.searchone("unicodePwd", "cn=krbtgt,CN=users,%s" % nc_name)
        self.assertIsNotNone(krbtgt_pw)

        self.assertEqual(nc_name, server_nc_name)
        # The clone should pretend to be the source server
        self.assertEqual(ds_name, server_ds_name)
        self.assertEqual(ldap_service_name, server_ldap_service_name)

        server_dn = samdb.searchone("serverReferenceBL", "cn=%s,ou=domain controllers,%s" % (self.dc2, server_nc_name))
        ntds_guid = samdb.searchone("objectGUID", "cn=ntds settings,%s" % server_dn)

        res = samdb.search(base=str(server_nc_name),
                           expression="(&(objectclass=user)(cn=dns-%s))" % (self.dc2),
                           attrs=[], scope=ldb.SCOPE_SUBTREE)
        if len(res) == 1:
            dns_obj = res[0]
        else:
            dns_obj = None

        def demote_self():
            # While we have this cloned, try demoting the other server on the clone
            out = self.check_output("samba-tool domain demote --remove-other-dead-server=%s -H %s/private/sam.ldb"
                                % (self.dc1,
                                   self.tempdir))
        self.assertRaises(samba.tests.BlackboxProcessError, demote_self)

        # While we have this cloned, try demoting the other server on the clone
        out = self.check_output("samba-tool domain demote --remove-other-dead-server=%s -H %s/private/sam.ldb"
                                % (self.dc2,
                                   self.tempdir))

        # Check some of the objects that should have been removed
        def check_machine_obj():
            samdb.searchone("CN", "cn=%s,ou=domain controllers,%s" % (self.dc2, server_nc_name))
        self.assertRaises(ldb.LdbError, check_machine_obj)

        def check_server_obj():
            samdb.searchone("CN", server_dn)
        self.assertRaises(ldb.LdbError, check_server_obj)

        def check_ntds_guid():
            samdb.searchone("CN", "<GUID=%s>" % ntds_guid)
        self.assertRaises(ldb.LdbError, check_ntds_guid)

        if dns_obj is not None:
            # Check some of the objects that should have been removed
            def check_dns_account_obj():
                samdb.search(base=dns_obj.dn, scope=ldb.SCOPE_BASE,
                             attrs=[])
            self.assertRaises(ldb.LdbError, check_dns_account_obj)

        shutil.rmtree(os.path.join(self.tempdir, "private"))
        shutil.rmtree(os.path.join(self.tempdir, "etc"))
        shutil.rmtree(os.path.join(self.tempdir, "msg.lock"))
        os.remove(os.path.join(self.tempdir, "names.tdb"))
        shutil.rmtree(os.path.join(self.tempdir, "state"))

    def test_samba_tool_drs_clone_dc_secrets_without_targetdir(self):
        """Tests 'samba-tool drs clone-dc-database' command without --targetdir."""
        server_rootdse = self._get_rootDSE(self.dc1)
        server_ldap_service_name = str(server_rootdse["ldapServiceName"][0])
        server_realm = server_ldap_service_name.split(":")[0]
        creds = self.get_credentials()
        def attempt_clone():
            out = self.check_output("samba-tool drs clone-dc-database %s --server=%s %s"
                                    % (server_realm,
                                       self.dc1,
                                       self.cmdline_creds))
        self.assertRaises(samba.tests.BlackboxProcessError, attempt_clone)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Unix SMB/CIFS implementation. Tests for common.py routines
# Copyright (C) Andrew Tridgell 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.common"""

import samba, os
import samba.tests
from samba.common import *
from samba.samdb import SamDB


class CommonTests(samba.tests.TestCase):

    def test_normalise_int32(self):
        self.assertEquals('17', normalise_int32(17))
        self.assertEquals('17', normalise_int32('17'))
        self.assertEquals('-123', normalise_int32('-123'))
        self.assertEquals('-1294967296', normalise_int32('3000000000'))

    def test_dsdb_Dn(self):
        sam = samba.Ldb(url='dntest.ldb')
        dn1 = dsdb_Dn(sam, "DC=foo,DC=bar")
        dn2 = dsdb_Dn(sam, "B:8:0000000D:<GUID=b3f0ec29-17f4-452a-b002-963e1909d101>;DC=samba,DC=example,DC=com")
        self.assertEquals(dn2.binary, "0000000D")
        self.assertEquals(13, dn2.get_binary_integer())
        os.unlink('dntest.ldb')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Samba Python tests."""

import ldb
import os
import samba
from samba import arcfour_encrypt, string_to_byte_array
from samba.tests import TestCase, TestCaseInTempDir

class SubstituteVarTestCase(TestCase):

    def test_empty(self):
        self.assertEquals("", samba.substitute_var("", {}))

    def test_nothing(self):
        self.assertEquals("foo bar",
                samba.substitute_var("foo bar", {"bar": "bla"}))

    def test_replace(self):
        self.assertEquals("foo bla",
                samba.substitute_var("foo ${bar}", {"bar": "bla"}))

    def test_broken(self):
        self.assertEquals("foo ${bdkjfhsdkfh sdkfh ",
            samba.substitute_var("foo ${bdkjfhsdkfh sdkfh ", {"bar": "bla"}))

    def test_unknown_var(self):
        self.assertEquals("foo ${bla} gsff",
                samba.substitute_var("foo ${bla} gsff", {"bar": "bla"}))

    def test_check_all_substituted(self):
        samba.check_all_substituted("nothing to see here")
        self.assertRaises(Exception, samba.check_all_substituted,
                "Not subsituted: ${FOOBAR}")

class ArcfourTestCase(TestCase):

    def test_arcfour_direct(self):
        key = '12345678'
        plain = 'abcdefghi'
        crypt_expected = '\xda\x91Z\xb0l\xd7\xb9\xcf\x99'
        crypt_calculated = arcfour_encrypt(key, plain)
        self.assertEquals(crypt_expected, crypt_calculated)

class StringToByteArrayTestCase(TestCase):

    def test_byte_array(self):
        expected = [218, 145, 90, 176, 108, 215, 185, 207, 153]
        calculated = string_to_byte_array('\xda\x91Z\xb0l\xd7\xb9\xcf\x99')
        self.assertEquals(expected, calculated)

class LdbExtensionTests(TestCaseInTempDir):

    def test_searchone(self):
        path = self.tempdir + "/searchone.ldb"
        l = samba.Ldb(path)
        try:
            l.add({"dn": "foo=dc", "bar": "bla"})
            self.assertEquals("bla",
                l.searchone(basedn=ldb.Dn(l, "foo=dc"), attribute="bar"))
        finally:
            del l
            os.unlink(path)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for the Credentials Python bindings.

Note that this just tests the bindings work. It does not intend to test
the functionality, that's already done in other tests.
"""

from samba import credentials
import samba.tests

class CredentialsTests(samba.tests.TestCase):

    def setUp(self):
        super(CredentialsTests, self).setUp()
        self.creds = credentials.Credentials()

    def test_set_username(self):
        self.creds.set_username("somebody")
        self.assertEquals("somebody", self.creds.get_username())

    def test_set_password(self):
        self.creds.set_password("S3CreT")
        self.assertEquals("S3CreT", self.creds.get_password())

    def test_set_domain(self):
        self.creds.set_domain("ABMAS")
        self.assertEquals("ABMAS", self.creds.get_domain())

    def test_set_realm(self):
        self.creds.set_realm("myrealm")
        self.assertEquals("MYREALM", self.creds.get_realm())

    def test_parse_string_anon(self):
        self.creds.parse_string("%")
        self.assertEquals("", self.creds.get_username())
        self.assertEquals(None, self.creds.get_password())

    def test_parse_string_user_pw_domain(self):
        self.creds.parse_string("dom\\someone%secr")
        self.assertEquals("someone", self.creds.get_username())
        self.assertEquals("secr", self.creds.get_password())
        self.assertEquals("DOM", self.creds.get_domain())

    def test_bind_dn(self):
        self.assertEquals(None, self.creds.get_bind_dn())
        self.creds.set_bind_dn("dc=foo,cn=bar")
        self.assertEquals("dc=foo,cn=bar", self.creds.get_bind_dn())

    def test_is_anon(self):
        self.creds.set_username("")
        self.assertTrue(self.creds.is_anonymous())
        self.creds.set_username("somebody")
        self.assertFalse(self.creds.is_anonymous())
        self.creds.set_anonymous()
        self.assertTrue(self.creds.is_anonymous())

    def test_workstation(self):
        # FIXME: This is uninitialised, it should be None
        #self.assertEquals(None, self.creds.get_workstation())
        self.creds.set_workstation("myworksta")
        self.assertEquals("myworksta", self.creds.get_workstation())

    def test_get_nt_hash(self):
        self.creds.set_password("geheim")
        self.assertEquals('\xc2\xae\x1f\xe6\xe6H\x84cRE>\x81o*\xeb\x93',
                          self.creds.get_nt_hash())

    def test_guess(self):
        # Just check the method is there and doesn't raise an exception
        self.creds.guess()

    def test_set_cmdline_callbacks(self):
        self.creds.set_cmdline_callbacks()

    def test_authentication_requested(self):
        self.creds.set_username("")
        self.assertFalse(self.creds.authentication_requested())
        self.creds.set_username("somebody")
        self.assertTrue(self.creds.authentication_requested())

    def test_wrong_password(self):
        self.assertFalse(self.creds.wrong_password())
                                                                                                                                                                                                                                                                                                                                                                                                                                             # -*- coding: utf-8 -*-
#
# Unix SMB/CIFS implementation.
# Copyright  Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Tests for the DCE/RPC Python bindings."""

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Unix SMB/CIFS implementation.
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2016
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for array handling in PIDL generated bindings samba.dcerpc.*"""

from samba.dcerpc import drsblobs
import samba.tests
from samba.ndr import ndr_unpack, ndr_pack
import talloc
import gc

class ArrayTests(samba.tests.TestCase):

    def setUp(self):
        super(ArrayTests, self).setUp()
        talloc.enable_null_tracking()
        self.startup_blocks = talloc.total_blocks()

    def tearDown(self):
        super(ArrayTests, self).tearDown()
        gc.collect()
        if talloc.total_blocks() != self.startup_blocks:
            talloc.report_full()
            self.fail("it appears we are leaking memory")

    def test_array_from_python(self):
        rmd = drsblobs.replPropertyMetaDataBlob()

        rmd.version = 1
        rmd.ctr = drsblobs.replPropertyMetaDataCtr1()
        rmd.ctr.count = 3

        rmd1 = drsblobs.replPropertyMetaData1()
        rmd1.attid = 1
        rmd1.version = 2

        rmd2 = drsblobs.replPropertyMetaData1()
        rmd2.attid = 2
        rmd2.version = 2

        rmd3 = drsblobs.replPropertyMetaData1()
        rmd3.attid = 3
        rmd3.version = 2

        rmd.ctr.array = [rmd1, rmd2, rmd3]
        gc.collect()

        self.assertIsNotNone(rmd)
        self.assertEqual(rmd.version, 1)
        self.assertIsNotNone(rmd.ctr)
        self.assertEqual(rmd.ctr.count, 3)
        self.assertEqual(len(rmd.ctr.array), rmd.ctr.count)
        self.assertIsNotNone(rmd.ctr.array[0])
        self.assertEqual(rmd.ctr.array[0].attid, 1)

    def test_array_with_exception(self):
        try:
            rmd = drsblobs.replPropertyMetaDataBlob()

            rmd.version = 1
            rmd.ctr = drsblobs.replPropertyMetaDataCtr1()
            rmd.ctr.count = 3

            rmd1 = drsblobs.replPropertyMetaData1()
            rmd1.attid = 1
            rmd1.version = 2

            rmd2 = drsblobs.replPropertyMetaData1()
            rmd2.attid = 2
            rmd2.version = 2

            rmd3 = drsblobs.replPropertyMetaData1()
            rmd3.attid = 3
            rmd3.version = 2

            rmd.ctr.array = [rmd1, rmd2, rmd3]

            gc.collect()

            self.assertIsNotNone(rmd)
            self.assertEqual(rmd.version, 1)
            self.assertIsNotNone(rmd.ctr)
            self.assertEqual(rmd.ctr.count, 3)
            self.assertEqual(len(rmd.ctr.array), rmd.ctr.count)
            self.assertIsNotNone(rmd.ctr.array[0])
            self.assertEqual(rmd.ctr.array[0].attid, 1)

            raise Exception()
        except:
            pass

    def test_array_from_python_function(self):
        def get_rmd():
            rmd = drsblobs.replPropertyMetaDataBlob()

            rmd.version = 1
            rmd.ctr = drsblobs.replPropertyMetaDataCtr1()
            rmd.ctr.count = 3

            rmd1 = drsblobs.replPropertyMetaData1()
            rmd1.attid = 1
            rmd1.version = 2

            rmd2 = drsblobs.replPropertyMetaData1()
            rmd2.attid = 2
            rmd2.version = 2

            rmd3 = drsblobs.replPropertyMetaData1()
            rmd3.attid = 3
            rmd3.version = 2

            rmd.ctr.array = [rmd1, rmd2, rmd3]
            return rmd

        rmd = get_rmd()
        gc.collect()
        self.assertIsNotNone(rmd)
        self.assertEqual(rmd.version, 1)
        self.assertIsNotNone(rmd.ctr)
        self.assertEqual(rmd.ctr.count, 3)
        self.assertEqual(len(rmd.ctr.array), rmd.ctr.count)
        self.assertIsNotNone(rmd.ctr.array[0])
        self.assertEqual(rmd.ctr.array[0].attid, 1)

    def test_array_from_ndr(self):
        rmd = drsblobs.replPropertyMetaDataBlob()

        rmd.version = 1
        rmd.ctr = drsblobs.replPropertyMetaDataCtr1()
        rmd.ctr.count = 3

        rmd1 = drsblobs.replPropertyMetaData1()
        rmd1.attid = 1
        rmd1.version = 2

        rmd2 = drsblobs.replPropertyMetaData1()
        rmd2.attid = 2
        rmd2.version = 2

        rmd3 = drsblobs.replPropertyMetaData1()
        rmd3.attid = 3
        rmd3.version = 2

        rmd.ctr.array = [rmd1, rmd2, rmd3]

        packed = ndr_pack(rmd)
        gc.collect()

        rmd_unpacked = ndr_unpack(drsblobs.replPropertyMetaDataBlob, packed)
        self.assertIsNotNone(rmd_unpacked)
        self.assertEqual(rmd_unpacked.version, 1)
        self.assertIsNotNone(rmd_unpacked.ctr)
        self.assertEqual(rmd_unpacked.ctr.count, 3)
        self.assertEqual(len(rmd_unpacked.ctr.array), rmd_unpacked.ctr.count)
        self.assertIsNotNone(rmd_unpacked.ctr.array[0])
        self.assertEqual(rmd_unpacked.ctr.array[0].attid, 1)

        self.assertEqual(rmd.ctr.array[0].attid,
                         rmd_unpacked.ctr.array[0].attid)

    def test_array_delete(self):
        rmd = drsblobs.replPropertyMetaDataBlob()

        rmd.version = 1
        rmd.ctr = drsblobs.replPropertyMetaDataCtr1()
        rmd.ctr.count = 3

        rmd1 = drsblobs.replPropertyMetaData1()
        rmd1.attid = 1
        rmd1.version = 2

        rmd2 = drsblobs.replPropertyMetaData1()
        rmd2.attid = 2
        rmd2.version = 2

        rmd3 = drsblobs.replPropertyMetaData1()
        rmd3.attid = 3
        rmd3.version = 2

        rmd.ctr.array = [rmd1, rmd2, rmd3]
        try:
            del rmd1.version
            self.fail("succeeded in deleting rmd1.version")
        except AttributeError, e:
            pass

        try:
            del rmd.ctr.array
            self.fail("succeeded in deleting rmd.ctr.array")
        except AttributeError, e:
            pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # -*- coding: utf-8 -*-
#
# Unix SMB/CIFS implementation.
# Copyright  Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.tests.dcerpc.bare."""

from samba.dcerpc import ClientConnection
import samba.tests

class BareTestCase(samba.tests.TestCase):

    def test_bare(self):
        # Connect to the echo pipe
        x = ClientConnection("ncalrpc:localhost[DEFAULT]",
                ("60a15ec5-4de8-11d7-a637-005056a20182", 1),
                lp_ctx=samba.tests.env_loadparm())
        self.assertEquals("\x01\x00\x00\x00", x.request(0, chr(0) * 4))

    def test_two_contexts(self):
        x = ClientConnection("ncalrpc:localhost[DEFAULT]",
                ("12345778-1234-abcd-ef00-0123456789ac", 1),
                lp_ctx=samba.tests.env_loadparm())
        y = ClientConnection("ncalrpc:localhost",
                ("60a15ec5-4de8-11d7-a637-005056a20182", 1),
                basis_connection=x, lp_ctx=samba.tests.env_loadparm())
        self.assertEquals(24, len(x.request(0, chr(0) * 8)))
        self.assertEquals("\x01\x00\x00\x00", y.request(0, chr(0) * 4))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Unix SMB/CIFS implementation.
# Copyright (C) Amitay Isaacs <amitay@gmail.com> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dcerpc.dnsserver"""

from samba.dcerpc import dnsp, dnsserver
from samba.tests import RpcInterfaceTestCase, env_get_var_value
from samba.netcmd.dns import ARecord, NSRecord

class DnsserverTests(RpcInterfaceTestCase):

    def setUp(self):
        super(DnsserverTests, self).setUp()
        self.server = env_get_var_value("SERVER_IP")
        self.zone = env_get_var_value("REALM").lower()
        self.conn = dnsserver.dnsserver("ncacn_ip_tcp:%s[sign]" % (self.server),
                                        self.get_loadparm(),
                                        self.get_credentials())

    def test_query2(self):
        typeid, result = self.conn.DnssrvQuery2(dnsserver.DNS_CLIENT_VERSION_W2K,
                                                0,
                                                self.server,
                                                None,
                                                'ServerInfo')
        self.assertEquals(dnsserver.DNSSRV_TYPEID_SERVER_INFO_W2K, typeid)

        typeid, result = self.conn.DnssrvQuery2(dnsserver.DNS_CLIENT_VERSION_DOTNET,
                                                0,
                                                self.server,
                                                None,
                                                'ServerInfo')
        self.assertEquals(dnsserver.DNSSRV_TYPEID_SERVER_INFO_DOTNET, typeid)

        typeid, result = self.conn.DnssrvQuery2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                                0,
                                                self.server,
                                                None,
                                                'ServerInfo')
        self.assertEquals(dnsserver.DNSSRV_TYPEID_SERVER_INFO, typeid)

    def test_operation2(self):
        client_version = dnsserver.DNS_CLIENT_VERSION_LONGHORN
        rev_zone = '1.168.192.in-addr.arpa'

        zone_create = dnsserver.DNS_RPC_ZONE_CREATE_INFO_LONGHORN()
        zone_create.pszZoneName = rev_zone
        zone_create.dwZoneType = dnsp.DNS_ZONE_TYPE_PRIMARY
        zone_create.fAllowUpdate = dnsp.DNS_ZONE_UPDATE_SECURE
        zone_create.fAging = 0
        zone_create.dwDpFlags = dnsserver.DNS_DP_DOMAIN_DEFAULT

        # Create zone
        self.conn.DnssrvOperation2(client_version,
                                    0,
                                    self.server,
                                    None,
                                    0,
                                    'ZoneCreate',
                                    dnsserver.DNSSRV_TYPEID_ZONE_CREATE,
                                    zone_create)

        request_filter = (dnsserver.DNS_ZONE_REQUEST_REVERSE |
                            dnsserver.DNS_ZONE_REQUEST_PRIMARY)
        typeid, zones = self.conn.DnssrvComplexOperation2(client_version,
                                                            0,
                                                            self.server,
                                                            None,
                                                            'EnumZones',
                                                            dnsserver.DNSSRV_TYPEID_DWORD,
                                                            request_filter)
        self.assertEquals(1, zones.dwZoneCount)

        # Delete zone
        self.conn.DnssrvOperation2(client_version,
                                    0,
                                    self.server,
                                    rev_zone,
                                    0,
                                    'DeleteZoneFromDs',
                                    dnsserver.DNSSRV_TYPEID_NULL,
                                    None)

        typeid, zones = self.conn.DnssrvComplexOperation2(client_version,
                                                            0,
                                                            self.server,
                                                            None,
                                                            'EnumZones',
                                                            dnsserver.DNSSRV_TYPEID_DWORD,
                                                            request_filter)
        self.assertEquals(0, zones.dwZoneCount)


    def test_complexoperation2(self):
        client_version = dnsserver.DNS_CLIENT_VERSION_LONGHORN
        request_filter = (dnsserver.DNS_ZONE_REQUEST_FORWARD |
                            dnsserver.DNS_ZONE_REQUEST_PRIMARY)
        typeid, zones = self.conn.DnssrvComplexOperation2(client_version,
                                                            0,
                                                            self.server,
                                                            None,
                                                            'EnumZones',
                                                            dnsserver.DNSSRV_TYPEID_DWORD,
                                                            request_filter)
        self.assertEquals(dnsserver.DNSSRV_TYPEID_ZONE_LIST, typeid)
        self.assertEquals(2, zones.dwZoneCount)

        request_filter = (dnsserver.DNS_ZONE_REQUEST_REVERSE |
                            dnsserver.DNS_ZONE_REQUEST_PRIMARY)
        typeid, zones = self.conn.DnssrvComplexOperation2(client_version,
                                                            0,
                                                            self.server,
                                                            None,
                                                            'EnumZones',
                                                            dnsserver.DNSSRV_TYPEID_DWORD,
                                                            request_filter)
        self.assertEquals(dnsserver.DNSSRV_TYPEID_ZONE_LIST, typeid)
        self.assertEquals(0, zones.dwZoneCount)


    def test_enumrecords2(self):
        client_version = dnsserver.DNS_CLIENT_VERSION_LONGHORN
        record_type = dnsp.DNS_TYPE_NS
        select_flags = (dnsserver.DNS_RPC_VIEW_ROOT_HINT_DATA |
                        dnsserver.DNS_RPC_VIEW_ADDITIONAL_DATA)
        buflen, roothints = self.conn.DnssrvEnumRecords2(client_version,
                                                            0,
                                                            self.server,
                                                            '..RootHints',
                                                            '.',
                                                            None,
                                                            record_type,
                                                            select_flags,
                                                            None,
                                                            None)
        self.assertEquals(14, roothints.count)  # 1 NS + 13 A records (a-m)


    def test_updaterecords2(self):
        client_version = dnsserver.DNS_CLIENT_VERSION_LONGHORN
        record_type = dnsp.DNS_TYPE_A
        select_flags = dnsserver.DNS_RPC_VIEW_AUTHORITY_DATA

        name = 'dummy'
        rec = ARecord('1.2.3.4')
        rec2 = ARecord('5.6.7.8')

        # Add record
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        self.conn.DnssrvUpdateRecord2(client_version,
                                        0,
                                        self.server,
                                        self.zone,
                                        name,
                                        add_rec_buf,
                                        None)

        buflen, result = self.conn.DnssrvEnumRecords2(client_version,
                                                        0,
                                                        self.server,
                                                        self.zone,
                                                        name,
                                                        None,
                                                        record_type,
                                                        select_flags,
                                                        None,
                                                        None)
        self.assertEquals(1, result.count)
        self.assertEquals(1, result.rec[0].wRecordCount)
        self.assertEquals(dnsp.DNS_TYPE_A, result.rec[0].records[0].wType)
        self.assertEquals('1.2.3.4', result.rec[0].records[0].data)

        # Update record
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec2
        del_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        del_rec_buf.rec = rec
        self.conn.DnssrvUpdateRecord2(client_version,
                                        0,
                                        self.server,
                                        self.zone,
                                        name,
                                        add_rec_buf,
                                        del_rec_buf)

        buflen, result = self.conn.DnssrvEnumRecords2(client_version,
                                                        0,
                                                        self.server,
                                                        self.zone,
                                                        name,
                                                        None,
                                                        record_type,
                                                        select_flags,
                                                        None,
                                                        None)
        self.assertEquals(1, result.count)
        self.assertEquals(1, result.rec[0].wRecordCount)
        self.assertEquals(dnsp.DNS_TYPE_A, result.rec[0].records[0].wType)
        self.assertEquals('5.6.7.8', result.rec[0].records[0].data)

        # Delete record
        del_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        del_rec_buf.rec = rec2
        self.conn.DnssrvUpdateRecord2(client_version,
                                        0,
                                        self.server,
                                        self.zone,
                                        name,
                                        None,
                                        del_rec_buf)

        self.assertRaises(RuntimeError, self.conn.DnssrvEnumRecords2,
                                        client_version,
                                        0,
                                        self.server,
                                        self.zone,
                                        name,
                                        None,
                                        record_type,
                                        select_flags,
                                        None,
                                        None)

    def test_updaterecords2_soa(self):
        client_version = dnsserver.DNS_CLIENT_VERSION_LONGHORN
        record_type = dnsp.DNS_TYPE_NS
        select_flags = (dnsserver.DNS_RPC_VIEW_AUTHORITY_DATA |
                        dnsserver.DNS_RPC_VIEW_NO_CHILDREN)

        nameserver = 'ns.example.local'
        rec = NSRecord(nameserver)

        # Add record
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        self.conn.DnssrvUpdateRecord2(client_version,
                                        0,
                                        self.server,
                                        self.zone,
                                        '.',
                                        add_rec_buf,
                                        None)

        buflen, result = self.conn.DnssrvEnumRecords2(client_version,
                                                        0,
                                                        self.server,
                                                        self.zone,
                                                        '@',
                                                        None,
                                                        record_type,
                                                        select_flags,
                                                        None,
                                                        None)
        self.assertEquals(1, result.count)
        self.assertEquals(2, result.rec[0].wRecordCount)
        match = False
        for i in range(2):
            self.assertEquals(dnsp.DNS_TYPE_NS, result.rec[0].records[i].wType)
            if result.rec[0].records[i].data.str.rstrip('.') == nameserver:
                match = True
        self.assertEquals(match, True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Unix SMB/CIFS implementation.
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2015
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for integer handling in PIDL generated bindings samba.dcerpc.*"""

from samba.dcerpc import server_id, misc, srvsvc, samr
import samba.tests

class IntegerTests(samba.tests.TestCase):

    def test_uint32_into_hyper(self):
        s = server_id.server_id()
        s.unique_id = server_id.NONCLUSTER_VNN
        self.assertEquals(s.unique_id, 0xFFFFFFFFL)

    def test_int_into_hyper(self):
        s = server_id.server_id()
        s.unique_id = 1
        self.assertEquals(s.unique_id, 1)

    def test_negative_int_into_hyper(self):
        s = server_id.server_id()
        def assign():
            s.unique_id = -1
        self.assertRaises(OverflowError, assign)

    def test_hyper_into_uint32(self):
        s = server_id.server_id()
        def assign():
            s.vnn = server_id.SERVERID_UNIQUE_ID_NOT_TO_VERIFY
        self.assertRaises(OverflowError, assign)

    def test_hyper_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        def assign():
            s.timezone = server_id.SERVERID_UNIQUE_ID_NOT_TO_VERIFY
        self.assertRaises(OverflowError, assign)

    def test_int_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        s.timezone = 5
        self.assertEquals(s.timezone, 5)

    def test_uint32_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        def assign():
            s.timezone = server_id.NONCLUSTER_VNN
        self.assertRaises(OverflowError, assign)

    def test_long_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        s.timezone = 5L
        self.assertEquals(s.timezone, 5)

    def test_larger_long_int_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        def assign():
            s.timezone = 2147483648
        self.assertRaises(OverflowError, assign)

    def test_larger_int_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        s.timezone = 2147483647
        self.assertEquals(s.timezone, 2147483647)

    def test_float_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        def assign():
            s.timezone = 2.5
        self.assertRaises(TypeError, assign)

    def test_int_float_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        def assign():
            s.timezone = 2.0
        self.assertRaises(TypeError, assign)

    def test_negative_int_into_int32(self):
        s = srvsvc.NetRemoteTODInfo()
        s.timezone = -2147483648
        self.assertEquals(s.timezone, -2147483648)

    def test_negative_into_uint32(self):
        s = server_id.server_id()
        def assign():
            s.vnn = -1
        self.assertRaises(OverflowError, assign)

    def test_hyper_into_uint16(self):
        g = misc.GUID()
        def assign():
            g.time_mid = server_id.SERVERID_UNIQUE_ID_NOT_TO_VERIFY
        self.assertRaises(OverflowError, assign)

    def test_int_into_uint16(self):
        g = misc.GUID()
        def assign():
            g.time_mid = 200000
        self.assertRaises(OverflowError, assign)

    def test_negative_int_into_uint16(self):
        g = misc.GUID()
        def assign():
            g.time_mid = -2
        self.assertRaises(OverflowError, assign)

    def test_int_into_uint16(self):
        g = misc.GUID()
        def assign():
            g.time_mid = 200000
        self.assertRaises(OverflowError, assign)

    def test_negative_int_into_uint16(self):
        g = misc.GUID()
        def assign():
            g.time_mid = -2
        self.assertRaises(OverflowError, assign)

    def test_enum_into_uint16(self):
        g = misc.GUID()
        g.time_mid = misc.SEC_CHAN_DOMAIN
        self.assertEquals(g.time_mid, misc.SEC_CHAN_DOMAIN)

    def test_bitmap_into_uint16(self):
        g = misc.GUID()
        g.time_mid = misc.SV_TYPE_WFW
        self.assertEqual(g.time_mid, misc.SV_TYPE_WFW)

    def test_overflow_bitmap_into_uint16(self):
        g = misc.GUID()
        def assign():
            g.time_mid = misc.SV_TYPE_LOCAL_LIST_ONLY
        self.assertRaises(OverflowError, assign)

    def test_overflow_bitmap_into_uint16_2(self):
        g = misc.GUID()
        def assign():
            g.time_mid = misc.SV_TYPE_DOMAIN_ENUM
        self.assertRaises(OverflowError, assign)

    def test_hyper_into_int64(self):
        s = samr.DomInfo1()
        def assign():
            s.max_password_age = server_id.SERVERID_UNIQUE_ID_NOT_TO_VERIFY
        self.assertRaises(OverflowError, assign)

    def test_int_into_int64(self):
        s = samr.DomInfo1()
        s.max_password_age = 5
        self.assertEquals(s.max_password_age, 5)

    def test_negative_int_into_int64(self):
        s = samr.DomInfo1()
        s.max_password_age = -5
        self.assertEquals(s.max_password_age, -5)

    def test_larger_int_into_int64(self):
        s = samr.DomInfo1()
        s.max_password_age = server_id.NONCLUSTER_VNN
        self.assertEquals(s.max_password_age, 0xFFFFFFFFL)

    def test_larger_negative_int_into_int64(self):
        s = samr.DomInfo1()
        s.max_password_age = -2147483649
        self.assertEquals(s.max_password_age, -2147483649L)

    def test_int_list_over_list(self):
        g = misc.GUID()
        g.node = [5, 0, 5, 0, 7, 4]
        self.assertEqual(g.node[0], 5)

    def test_long_int_list_over_uint8_list(self):
        g = misc.GUID()
        g.node = [5L, 0, 5, 0, 7, 4]
        self.assertEqual(g.node[0], 5)

    def test_negative_list_over_uint8_list(self):
        g = misc.GUID()
        def assign():
            g.node = [-1, 0, 5, 0, 7, 4]
        self.assertRaises(OverflowError, assign)

    def test_overflow_list_over_uint8_list(self):
        g = misc.GUID()
        def assign():
            g.node = [256, 0, 5, 0, 7, 4]
        self.assertRaises(OverflowError, assign)

    def test_short_list_over_uint8_list(self):
        g = misc.GUID()
        def assign():
            g.node = [5, 0, 5]
        self.assertRaises(TypeError, assign)

    def test_long_list_over_uint8_list(self):
        g = misc.GUID()
        def assign():
            g.node = [5, 0, 5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
        self.assertRaises(TypeError, assign)

    # Due to our PIDL bindings generating a python List, modifications
    # to a list of non-objects are not reflected in the C list
    # (modifications objects in lists of objects work because the
    # objects are modified), so changes essentially vanish and are not
    # type checked either.
    def test_assign_into_uint8_list(self):
        g = misc.GUID()
        g.node[1] = 5
        self.assertEqual(g.node[1], 5)

    def test_negative_into_uint8_list(self):
        g = misc.GUID()
        def assign():
            g.node[1] = -1
        self.assertRaises(OverflowError, assign)

    def test_overflow_into_uint8_list(self):
        g = misc.GUID()
        def assign():
            g.node[1] = 256
        self.assertRaises(OverflowError, assign)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dcerpc.misc."""

from samba.dcerpc import misc
import samba.tests

text1 = "76f53846-a7c2-476a-ae2c-20e2b80d7b34"
text2 = "344edffa-330a-4b39-b96e-2c34da52e8b1"

class GUIDTests(samba.tests.TestCase):

    def test_str(self):
        guid = misc.GUID(text1)
        self.assertEquals(text1, str(guid))

    def test_repr(self):
        guid = misc.GUID(text1)
        self.assertEquals("GUID('%s')" % text1, repr(guid))

    def test_compare_different(self):
        guid1 = misc.GUID(text1)
        guid2 = misc.GUID(text2)
        self.assertTrue(cmp(guid1, guid2) > 0)

    def test_compare_same(self):
        guid1 = misc.GUID(text1)
        guid2 = misc.GUID(text1)
        self.assertEquals(0, cmp(guid1, guid2))
        self.assertEquals(guid1, guid2)


class PolicyHandleTests(samba.tests.TestCase):

    def test_init(self):
        x = misc.policy_handle(text1, 1)
        self.assertEquals(1, x.handle_type)
        self.assertEquals(text1, str(x.uuid))

    def test_repr(self):
        x = misc.policy_handle(text1, 42)
        self.assertEquals("policy_handle(%d, '%s')" % (42, text1), repr(x))

    def test_str(self):
        x = misc.policy_handle(text1, 42)
        self.assertEquals("%d, %s" % (42, text1), str(x))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dcerpc.registry."""

from samba.dcerpc import winreg
from samba.tests import RpcInterfaceTestCase


class WinregTests(RpcInterfaceTestCase):

    def setUp(self):
        super(WinregTests, self).setUp()
        self.conn = winreg.winreg("ncalrpc:", self.get_loadparm(),
                                  self.get_credentials())

    def get_hklm(self):
        return self.conn.OpenHKLM(None,
             winreg.KEY_QUERY_VALUE | winreg.KEY_ENUMERATE_SUB_KEYS)

    def test_hklm(self):
        handle = self.conn.OpenHKLM(None,
                 winreg.KEY_QUERY_VALUE | winreg.KEY_ENUMERATE_SUB_KEYS)
        self.conn.CloseKey(handle)

    def test_getversion(self):
        handle = self.get_hklm()
        version = self.conn.GetVersion(handle)
        self.assertEquals(int, version.__class__)
        self.conn.CloseKey(handle)

    def test_getkeyinfo(self):
        handle = self.conn.OpenHKLM(None,
                 winreg.KEY_QUERY_VALUE | winreg.KEY_ENUMERATE_SUB_KEYS)
        x = self.conn.QueryInfoKey(handle, winreg.String())
        self.assertEquals(9, len(x)) # should return a 9-tuple
        self.conn.CloseKey(handle)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # test generated python code from pidl
# Copyright (C) Andrew Tridgell August 2010
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# to run this test, use one of these:
#
#    python -m unittest samba.tests.dcerpc.rpc_talloc
#
# or if you have trial installed (from twisted), use
#
#    trial samba.tests.dcerpc.rpc_talloc

"""Tests for the talloc handling in the generated Python DCE/RPC bindings."""

import sys

sys.path.insert(0, "bin/python")

import samba
import samba.tests
from samba.dcerpc import drsuapi
import talloc

talloc.enable_null_tracking()


class TallocTests(samba.tests.TestCase):
    '''test talloc behaviour of pidl generated python code'''

    def check_blocks(self, object, num_expected):
        '''check that the number of allocated blocks is correct'''
        nblocks = talloc.total_blocks(object)
        if object is None:
            nblocks -= self.initial_blocks
        self.assertEquals(nblocks, num_expected)

    def get_rodc_partial_attribute_set(self):
        '''get a list of attributes for RODC replication'''
        partial_attribute_set = drsuapi.DsPartialAttributeSet()

        # we expect one block for the object
        self.check_blocks(partial_attribute_set, 1)

        attids = [1, 2, 3]
        partial_attribute_set.version = 1
        partial_attribute_set.attids     = attids
        partial_attribute_set.num_attids = len(attids)

        # we expect one block for the object, a structure, and a
        # reference to the array
        self.check_blocks(partial_attribute_set, 2)

        return partial_attribute_set

    def pas_test(self):
        pas = self.get_rodc_partial_attribute_set()
        self.check_blocks(pas, 2)
        req8 = drsuapi.DsGetNCChangesRequest8()
        self.check_blocks(req8, 1)

        # We expect the pas and req8, plus one block for each python object
        self.check_blocks(None, 5)
        req8.partial_attribute_set = pas
        if req8.partial_attribute_set.attids[1] != 2:
            raise Exception("Wrong value in attids[2]")
        # we now get an additional reference
        self.check_blocks(None, 6)

    def test_run(self):
        self.initial_blocks = talloc.total_blocks(None)
        self.check_blocks(None, 0)
        self.pas_test()
        self.check_blocks(None, 0)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dceprc.rpcecho."""

from samba.dcerpc import echo
from samba.ndr import ndr_pack, ndr_unpack
from samba.tests import RpcInterfaceTestCase, TestCase


class RpcEchoTests(RpcInterfaceTestCase):

    def setUp(self):
        super(RpcEchoTests, self).setUp()
        self.conn = echo.rpcecho("ncalrpc:", self.get_loadparm())

    def test_two_contexts(self):
        self.conn2 = echo.rpcecho("ncalrpc:", self.get_loadparm(), basis_connection=self.conn)
        self.assertEquals(3, self.conn2.AddOne(2))

    def test_abstract_syntax(self):
        self.assertEquals(("60a15ec5-4de8-11d7-a637-005056a20182", 1),
                          self.conn.abstract_syntax)

    def test_addone(self):
        self.assertEquals(2, self.conn.AddOne(1))

    def test_echodata(self):
        self.assertEquals([1,2,3], self.conn.EchoData([1, 2, 3]))

    def test_call(self):
        self.assertEquals(u"foobar", self.conn.TestCall(u"foobar"))

    def test_surrounding(self):
        surrounding_struct = echo.Surrounding()
        surrounding_struct.x = 4
        surrounding_struct.surrounding = [1,2,3,4]
        y = self.conn.TestSurrounding(surrounding_struct)
        self.assertEquals(8 * [0], y.surrounding)

    def test_manual_request(self):
        self.assertEquals("\x01\x00\x00\x00", self.conn.request(0, chr(0) * 4))

    def test_server_name(self):
        self.assertEquals(None, self.conn.server_name)


class NdrEchoTests(TestCase):

    def test_info1_push(self):
        x = echo.info1()
        x.v = 42
        self.assertEquals("\x2a", ndr_pack(x))

    def test_info1_pull(self):
        x = ndr_unpack(echo.info1, "\x42")
        self.assertEquals(x.v, 66)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # -*- coding: utf-8 -*-
#
# Unix SMB/CIFS implementation.
# Copyright  Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dcerpc.sam."""

from samba.dcerpc import samr, security
from samba.tests import RpcInterfaceTestCase

# FIXME: Pidl should be doing this for us
def toArray((handle, array, num_entries)):
    ret = []
    for x in range(num_entries):
        ret.append((array.entries[x].idx, array.entries[x].name))
    return ret


class SamrTests(RpcInterfaceTestCase):

    def setUp(self):
        super(SamrTests, self).setUp()
        self.conn = samr.samr("ncalrpc:", self.get_loadparm())

    def test_connect5(self):
        (level, info, handle) = self.conn.Connect5(None, 0, 1, samr.ConnectInfo1())

    def test_connect2(self):
        handle = self.conn.Connect2(None, security.SEC_FLAG_MAXIMUM_ALLOWED)
        self.assertTrue(handle is not None)

    def test_EnumDomains(self):
        handle = self.conn.Connect2(None, security.SEC_FLAG_MAXIMUM_ALLOWED)
        domains = toArray(self.conn.EnumDomains(handle, 0, 4294967295L))
        self.conn.Close(handle)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # -*- coding: utf-8 -*-
#
# Unix SMB/CIFS implementation.
# Copyright  Dhananjay Sathe <dhanajaysathe@gmail.com> 2011
# Copyright  Jelmer Vernooij <jelmer@samba.org> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dcerpc.srvsvc."""

from samba.dcerpc import srvsvc
from samba.tests import RpcInterfaceTestCase


class SrvsvcTests(RpcInterfaceTestCase):

    def setUp(self):
        super(SrvsvcTests, self).setUp()
        self.conn = srvsvc.srvsvc("ncalrpc:", self.get_loadparm())
        self.server_unc = "\\\\."

    def getDummyShareObject(self):
        share = srvsvc.NetShareInfo2()

        share.name = u'test'
        share.comment = u'test share'
        share.type = srvsvc.STYPE_DISKTREE
        share.current_users = 0x00000000
        share.max_users = -1
        share.password = None
        share.path = u'C:\\tmp' # some random path
        share.permissions = 123434566
        return share

    def test_NetShareAdd(self):
        self.skipTest("Dangerous test")
        share = self.getDummyShareObject()
        self.conn.NetShareAdd(self.server_unc, 2, share, None)

    def test_NetShareSetInfo(self):
        self.skipTest("Dangerous test")
        share = self.getDummyShareObject()
        parm_error = 0x00000000
        self.conn.NetShareAdd(self.server_unc, 502, share, parm_error)
        name = share.name
        share.comment = "now sucessfully modified "
        parm_error = self.pipe.NetShareSetInfo(self.server_unc, name,
                502, share, parm_error)

    def test_NetShareDel(self):
        self.skipTest("Dangerous test")
        share = self.getDummyShareObject()
        parm_error = 0x00000000
        self.expectFailure("NetShareAdd doesn't work properly from Python",
            self.conn.NetShareAdd, self.server_unc, 502, share, parm_error)
        self.conn.NetShareDel(self.server_unc, share.name, 0)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Unix SMB/CIFS implementation.
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2016
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for string and unicode handling in PIDL generated bindings
samba.dcerpc.*"""

from samba.dcerpc import drsblobs
import samba.tests
from samba.ndr import ndr_unpack, ndr_pack
import talloc
import gc


class TestException(Exception):
    pass


class StringTests(samba.tests.TestCase):

    def setUp(self):
        super(StringTests, self).setUp()
        talloc.enable_null_tracking()
        self.startup_blocks = talloc.total_blocks()

    def tearDown(self):
        super(StringTests, self).tearDown()
        gc.collect()
        if talloc.total_blocks() != self.startup_blocks:
            talloc.report_full()
            self.fail("it appears we are leaking memory")

    def test_string_from_python(self):
        info = drsblobs.repsFromTo2OtherInfo()
        info.dns_name1 = "hello.example.com"
        info.dns_name2 = "goodbye.example.com"
        gc.collect()
        self.assertIsNotNone(info)
        self.assertEqual(info.dns_name1, "hello.example.com")
        self.assertEqual(info.dns_name2, "goodbye.example.com")

        info.dns_name1 = ""
        info.dns_name2 = "goodbye.example.com"

        self.assertEqual(info.dns_name1, "")
        self.assertEqual(info.dns_name2, "goodbye.example.com")

        info.dns_name2 = None

        self.assertEqual(info.dns_name1, "")
        self.assertIsNone(info.dns_name2)

    def test_string_with_exception(self):
        try:
            self.test_string_from_python()
            raise TestException()
        except TestException:
            pass

    def test_string_from_python_function(self):
        def get_info():
            info = drsblobs.repsFromTo2OtherInfo()
            info.dns_name1 = "1.example.com"
            info.dns_name2 = "2.example.com"
            return info

        info = get_info()
        gc.collect()
        self.assertIsNotNone(info)
        self.assertEqual(info.dns_name1, "1.example.com")
        self.assertEqual(info.dns_name2, "2.example.com")

    def test_string_modify_in_place(self):
        info = drsblobs.repsFromTo2OtherInfo()
        info.dns_name1 = "1.example.com"
        info.dns_name2 = "%s.example.com"
        gc.collect()
        self.assertIsNotNone(info)
        self.assertEqual(info.dns_name1, "1.example.com")
        self.assertEqual(info.dns_name2, "%s.example.com")
        info.dns_name1 += ".co.nz"
        info.dns_name2 %= 2
        self.assertEqual(info.dns_name1, "1.example.com.co.nz")
        self.assertEqual(info.dns_name2, "2.example.com")
        del info


    def test_string_delete(self):
        gc.collect()
        info = drsblobs.repsFromTo2OtherInfo()
        info.dns_name1 = "1.example.com"
        info.dns_name2 = "2.example.com"
        info.dns_name1 = None
        try:
            del info.dns_name2
        except AttributeError:
            pass

        self.assertIsNotNone(info)
        self.assertIsNone(info.dns_name1)
        self.assertIsNotNone(info.dns_name2)


class StringTestsWithoutLeakCheck(samba.tests.TestCase):
    """We know that the ndr unpacking test leaves stuff in the
    autofree_context, and we don't want to worry about that. So for
    this test we don't make meory leak assertions."""

    def test_string_from_ndr(self):
        info = drsblobs.repsFromTo2OtherInfo()
        info.dns_name1 = "1.example.com"
        info.dns_name2 = "2.example.com"
        packed = ndr_pack(info)
        gc.collect()

        info_unpacked = ndr_unpack(drsblobs.repsFromTo2OtherInfo, packed)

        self.assertIsNotNone(info_unpacked)
        self.assertEqual(info_unpacked.dns_name1, "1.example.com")
        self.assertEqual(info_unpacked.dns_name2, "2.example.com")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # test generated python code from pidl
# Copyright (C) Andrew Tridgell August 2010
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import sys

sys.path.insert(0, "bin/python")

import samba
import samba.tests
from samba.dcerpc import drsuapi
import talloc

talloc.enable_null_tracking()

class RpcTests(object):
    '''test type behaviour of pidl generated python RPC code'''

    def check_blocks(self, object, num_expected):
        '''check that the number of allocated blocks is correct'''
        nblocks = talloc.total_blocks(object)
        if object is None:
            nblocks -= self.initial_blocks
        leaked_blocks = (nblocks - num_expected)
        if leaked_blocks != 0:
            print "Leaked %d blocks" % leaked_blocks

    def check_type(self, interface, typename, type):
        print "Checking type %s" % typename
        v = type()
        for n in dir(v):
            if n[0] == '_':
                continue
            try:
                value = getattr(v, n)
            except TypeError, errstr:
                if str(errstr) == "unknown union level":
                    print "ERROR: Unknown union level in %s.%s" % (typename, n)
                    self.errcount += 1
                    continue
                print str(errstr)[1:21]
                if str(errstr)[0:21] == "Can not convert C Type":
                    print "ERROR: Unknown C type for %s.%s" % (typename, n)
                    self.errcount += 1
                    continue
                else:
                    print "ERROR: Failed to instantiate %s.%s" % (typename, n)
                    self.errcount += 1
                    continue
            except Exception:
                print "ERROR: Failed to instantiate %s.%s" % (typename, n)
                self.errcount += 1
                continue

            # now try setting the value back
            try:
                print "Setting %s.%s" % (typename, n)
                setattr(v, n, value)
            except Exception, e:
                if isinstance(e, AttributeError) and str(e).endswith("is read-only"):
                    # readonly, ignore
                    continue
                else:
                    print "ERROR: Failed to set %s.%s: %r: %s" % (typename, n, e.__class__, e)
                    self.errcount += 1
                    continue

            # and try a comparison
            try:
                if value != getattr(v, n):
                    print "ERROR: Comparison failed for %s.%s: %r != %r" % (typename, n, value, getattr(v, n))
                    continue
            except Exception, e:
                print "ERROR: compare exception for %s.%s: %r: %s" % (typename, n, e.__class__, e)
                continue

    def check_interface(self, interface, iname):
        errcount = self.errcount
        for n in dir(interface):
            if n[0] == '_' or n == iname:
                # skip the special ones
                continue
            value = getattr(interface, n)
            if isinstance(value, str):
                #print "%s=\"%s\"" % (n, value)
                pass
            elif isinstance(value, int) or isinstance(value, long):
                #print "%s=%d" % (n, value)
                pass
            elif isinstance(value, type):
                try:
                    initial_blocks = talloc.total_blocks(None)
                    self.check_type(interface, n, value)
                    self.check_blocks(None, initial_blocks)
                except Exception, e:
                    print "ERROR: Failed to check_type %s.%s: %r: %s" % (iname, n, e.__class__, e)
                    self.errcount += 1
            elif callable(value):
                pass # Method
            else:
                print "UNKNOWN: %s=%s" % (n, value)
        if self.errcount - errcount != 0:
            print "Found %d errors in %s" % (self.errcount - errcount, iname)

    def check_all_interfaces(self):
        for iname in dir(samba.dcerpc):
            if iname[0] == '_':
                continue
            if iname == 'ClientConnection' or iname == 'base':
                continue
            print "Checking interface %s" % iname
            iface = getattr(samba.dcerpc, iname)
            initial_blocks = talloc.total_blocks(None)
            self.check_interface(iface, iname)
            self.check_blocks(None, initial_blocks)

    def run(self):
        self.initial_blocks = talloc.total_blocks(None)
        self.errcount = 0
        self.check_all_interfaces()
        return self.errcount

tests = RpcTests()
errcount = tests.run()
if errcount == 0:
    sys.exit(0)
else:
    print "%d failures" % errcount
    sys.exit(1)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dcerpc.unixinfo."""


from samba.dcerpc import unixinfo
from samba.tests import RpcInterfaceTestCase

class UnixinfoTests(RpcInterfaceTestCase):

    def setUp(self):
        super(UnixinfoTests, self).setUp()
        self.conn = unixinfo.unixinfo("ncalrpc:", self.get_loadparm())

    def test_getpwuid_int(self):
        infos = self.conn.GetPWUid(range(512))
        self.assertEquals(512, len(infos))
        self.assertEquals("/bin/false", infos[0].shell)
        self.assertTrue(isinstance(infos[0].homedir, unicode))

    def test_getpwuid(self):
        infos = self.conn.GetPWUid(map(long, range(512)))
        self.assertEquals(512, len(infos))
        self.assertEquals("/bin/false", infos[0].shell)
        self.assertTrue(isinstance(infos[0].homedir, unicode))

    def test_gidtosid(self):
        self.conn.GidToSid(1000L)

    def test_uidtosid(self):
        self.conn.UidToSid(1000)

    def test_uidtosid_fail(self):
        self.assertRaises(TypeError, self.conn.UidToSid, "100")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Unix SMB/CIFS implementation.
# Copyright (C) Kai Blin  <kai@samba.org> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import sys
import struct
import random
import socket
import samba.ndr as ndr
from samba import credentials, param
from samba.tests import TestCase
from samba.dcerpc import dns, dnsp, dnsserver
from samba.netcmd.dns import TXTRecord, dns_record_match, data_to_dns_record
from samba.tests.subunitrun import SubunitOptions, TestProgram
import samba.getopt as options
import optparse

parser = optparse.OptionParser("dns.py <server name> <server ip> [options]")
sambaopts = options.SambaOptions(parser)
parser.add_option_group(sambaopts)

# This timeout only has relevance when testing against Windows
# Format errors tend to return patchy responses, so a timeout is needed.
parser.add_option("--timeout", type="int", dest="timeout",
                  help="Specify timeout for DNS requests")

# use command line creds if available
credopts = options.CredentialsOptions(parser)
parser.add_option_group(credopts)
subunitopts = SubunitOptions(parser)
parser.add_option_group(subunitopts)

opts, args = parser.parse_args()

lp = sambaopts.get_loadparm()
creds = credopts.get_credentials(lp)

timeout = opts.timeout

if len(args) < 2:
    parser.print_usage()
    sys.exit(1)

server_name = args[0]
server_ip = args[1]
creds.set_krb_forwardable(credentials.NO_KRB_FORWARDABLE)

def make_txt_record(records):
    rdata_txt = dns.txt_record()
    s_list = dnsp.string_list()
    s_list.count = len(records)
    s_list.str = records
    rdata_txt.txt = s_list
    return rdata_txt

class DNSTest(TestCase):

    def setUp(self):
        global server, server_ip, lp, creds
        super(DNSTest, self).setUp()
        self.server = server_name
        self.server_ip = server_ip
        self.lp = lp
        self.creds = creds

    def errstr(self, errcode):
        "Return a readable error code"
        string_codes = [
            "OK",
            "FORMERR",
            "SERVFAIL",
            "NXDOMAIN",
            "NOTIMP",
            "REFUSED",
            "YXDOMAIN",
            "YXRRSET",
            "NXRRSET",
            "NOTAUTH",
            "NOTZONE",
        ]

        return string_codes[errcode]


    def assert_dns_rcode_equals(self, packet, rcode):
        "Helper function to check return code"
        p_errcode = packet.operation & 0x000F
        self.assertEquals(p_errcode, rcode, "Expected RCODE %s, got %s" %
                            (self.errstr(rcode), self.errstr(p_errcode)))

    def assert_dns_opcode_equals(self, packet, opcode):
        "Helper function to check opcode"
        p_opcode = packet.operation & 0x7800
        self.assertEquals(p_opcode, opcode, "Expected OPCODE %s, got %s" %
                            (opcode, p_opcode))

    def make_name_packet(self, opcode, qid=None):
        "Helper creating a dns.name_packet"
        p = dns.name_packet()
        if qid is None:
            p.id = random.randint(0x0, 0xffff)
        p.operation = opcode
        p.questions = []
        return p

    def finish_name_packet(self, packet, questions):
        "Helper to finalize a dns.name_packet"
        packet.qdcount = len(questions)
        packet.questions = questions

    def make_name_question(self, name, qtype, qclass):
        "Helper creating a dns.name_question"
        q = dns.name_question()
        q.name = name
        q.question_type = qtype
        q.question_class = qclass
        return q

    def get_dns_domain(self):
        "Helper to get dns domain"
        return self.creds.get_realm().lower()

    def dns_transaction_udp(self, packet, host=server_ip,
                            dump=False, timeout=timeout):
        "send a DNS query and read the reply"
        s = None
        try:
            send_packet = ndr.ndr_pack(packet)
            if dump:
                print self.hexdump(send_packet)
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
            s.settimeout(timeout)
            s.connect((host, 53))
            s.send(send_packet, 0)
            recv_packet = s.recv(2048, 0)
            if dump:
                print self.hexdump(recv_packet)
            return ndr.ndr_unpack(dns.name_packet, recv_packet)
        finally:
            if s is not None:
                s.close()

    def dns_transaction_tcp(self, packet, host=server_ip,
                            dump=False, timeout=timeout):
        "send a DNS query and read the reply"
        s = None
        try:
            send_packet = ndr.ndr_pack(packet)
            if dump:
                print self.hexdump(send_packet)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
            s.settimeout(timeout)
            s.connect((host, 53))
            tcp_packet = struct.pack('!H', len(send_packet))
            tcp_packet += send_packet
            s.send(tcp_packet, 0)
            recv_packet = s.recv(0xffff + 2, 0)
            if dump:
                print self.hexdump(recv_packet)
            return ndr.ndr_unpack(dns.name_packet, recv_packet[2:])
        finally:
                if s is not None:
                    s.close()

    def make_txt_update(self, prefix, txt_array):
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()
        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = "%s.%s" % (prefix, self.get_dns_domain())
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = make_txt_record(txt_array)
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        return p

    def check_query_txt(self, prefix, txt_array):
        name = "%s.%s" % (prefix, self.get_dns_domain())
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assertEquals(response.ancount, 1)
        self.assertEquals(response.answers[0].rdata.txt.str, txt_array)

class TestSimpleQueries(DNSTest):

    def test_one_a_query(self):
        "create a query packet containing one query record"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 1)
        self.assertEquals(response.answers[0].rdata,
                          self.server_ip)

    def test_one_a_query_tcp(self):
        "create a query packet containing one query record via TCP"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_tcp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 1)
        self.assertEquals(response.answers[0].rdata,
                          self.server_ip)

    def test_one_mx_query(self):
        "create a query packet causing an empty RCODE_OK answer"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_MX, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 0)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "invalid-%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_MX, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXDOMAIN)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 0)

    def test_two_queries(self):
        "create a query packet containing two query records"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        questions.append(q)

        name = "%s.%s" % ('bogusname', self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        try:
            response = self.dns_transaction_udp(p)
            self.assert_dns_rcode_equals(response, dns.DNS_RCODE_FORMERR)
        except socket.timeout:
            # Windows chooses not to respond to incorrectly formatted queries.
            # Although this appears to be non-deterministic even for the same
            # request twice, it also appears to be based on a how poorly the
            # request is formatted.
            pass

    def test_qtype_all_query(self):
        "create a QTYPE_ALL query"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_ALL, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)

        num_answers = 1
        dc_ipv6 = os.getenv('SERVER_IPV6')
        if dc_ipv6 is not None:
            num_answers += 1

        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, num_answers)
        self.assertEquals(response.answers[0].rdata,
                          self.server_ip)
        if dc_ipv6 is not None:
            self.assertEquals(response.answers[1].rdata, dc_ipv6)

    def test_qclass_none_query(self):
        "create a QCLASS_NONE query"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_ALL, dns.DNS_QCLASS_NONE)
        questions.append(q)

        self.finish_name_packet(p, questions)
        try:
            response = self.dns_transaction_udp(p)
            self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NOTIMP)
        except socket.timeout:
            # Windows chooses not to respond to incorrectly formatted queries.
            # Although this appears to be non-deterministic even for the same
            # request twice, it also appears to be based on a how poorly the
            # request is formatted.
            pass

    def test_soa_hostname_query(self):
        "create a SOA query for a hostname"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        # We don't get SOA records for single hosts
        self.assertEquals(response.ancount, 0)
        # But we do respond with an authority section
        self.assertEqual(response.nscount, 1)

    def test_soa_domain_query(self):
        "create a SOA query for a domain"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = self.get_dns_domain()
        q = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 1)
        self.assertEquals(response.answers[0].rdata.minimum, 3600)


class TestDNSUpdates(DNSTest):

    def test_two_updates(self):
        "create two update requests"
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        u = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        updates.append(u)

        name = self.get_dns_domain()
        u = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        updates.append(u)

        self.finish_name_packet(p, updates)
        try:
            response = self.dns_transaction_udp(p)
            self.assert_dns_rcode_equals(response, dns.DNS_RCODE_FORMERR)
        except socket.timeout:
            # Windows chooses not to respond to incorrectly formatted queries.
            # Although this appears to be non-deterministic even for the same
            # request twice, it also appears to be based on a how poorly the
            # request is formatted.
            pass

    def test_update_wrong_qclass(self):
        "create update with DNS_QCLASS_NONE"
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()
        u = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_NONE)
        updates.append(u)

        self.finish_name_packet(p, updates)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NOTIMP)

    def test_update_prereq_with_non_null_ttl(self):
        "test update with a non-null TTL"
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        prereqs = []
        r = dns.res_rec()
        r.name = "%s.%s" % (self.server, self.get_dns_domain())
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_NONE
        r.ttl = 1
        r.length = 0
        prereqs.append(r)

        p.ancount = len(prereqs)
        p.answers = prereqs

        try:
            response = self.dns_transaction_udp(p)
            self.assert_dns_rcode_equals(response, dns.DNS_RCODE_FORMERR)
        except socket.timeout:
            # Windows chooses not to respond to incorrectly formatted queries.
            # Although this appears to be non-deterministic even for the same
            # request twice, it also appears to be based on a how poorly the
            # request is formatted.
            pass

    def test_update_prereq_with_non_null_length(self):
        "test update with a non-null length"
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        prereqs = []
        r = dns.res_rec()
        r.name = "%s.%s" % (self.server, self.get_dns_domain())
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_ANY
        r.ttl = 0
        r.length = 1
        prereqs.append(r)

        p.ancount = len(prereqs)
        p.answers = prereqs

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXRRSET)

    def test_update_prereq_nonexisting_name(self):
        "test update with a nonexisting name"
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        prereqs = []
        r = dns.res_rec()
        r.name = "idontexist.%s" % self.get_dns_domain()
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_ANY
        r.ttl = 0
        r.length = 0
        prereqs.append(r)

        p.ancount = len(prereqs)
        p.answers = prereqs

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXRRSET)

    def test_update_add_txt_record(self):
        "test adding records works"
        prefix, txt = 'textrec', ['"This is a test"']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)

    def test_delete_record(self):
        "Test if deleting records works"

        NAME = "deleterec.%s" % self.get_dns_domain()

        # First, create a record to make sure we have a record to delete.
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = NAME
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = make_txt_record(['"This is a test"'])
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # Now check the record is around
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(NAME, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # Now delete the record
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = NAME
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_NONE
        r.ttl = 0
        r.length = 0xffff
        rdata = make_txt_record(['"This is a test"'])
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # And finally check it's gone
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(NAME, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXDOMAIN)

    def test_readd_record(self):
        "Test if adding, deleting and then readding a records works"

        NAME = "readdrec.%s" % self.get_dns_domain()

        # Create the record
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = NAME
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = make_txt_record(['"This is a test"'])
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # Now check the record is around
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(NAME, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # Now delete the record
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = NAME
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_NONE
        r.ttl = 0
        r.length = 0xffff
        rdata = make_txt_record(['"This is a test"'])
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # check it's gone
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(NAME, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXDOMAIN)

        # recreate the record
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = NAME
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = make_txt_record(['"This is a test"'])
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        # Now check the record is around
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(NAME, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

    def test_update_add_mx_record(self):
        "test adding MX records works"
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = "%s" % self.get_dns_domain()
        r.rr_type = dns.DNS_QTYPE_MX
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = dns.mx_record()
        rdata.preference = 10
        rdata.exchange = 'mail.%s' % self.get_dns_domain()
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s" % self.get_dns_domain()
        q = self.make_name_question(name, dns.DNS_QTYPE_MX, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assertEqual(response.ancount, 1)
        ans = response.answers[0]
        self.assertEqual(ans.rr_type, dns.DNS_QTYPE_MX)
        self.assertEqual(ans.rdata.preference, 10)
        self.assertEqual(ans.rdata.exchange, 'mail.%s' % self.get_dns_domain())


class TestComplexQueries(DNSTest):
    def make_dns_update(self, key, value, qtype):
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)

        name = self.get_dns_domain()
        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        self.finish_name_packet(p, [u])

        r = dns.res_rec()
        r.name = key
        r.rr_type = qtype
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = value
        r.rdata = rdata
        updates = [r]
        p.nscount = 1
        p.nsrecs = updates
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

    def setUp(self):
        super(TestComplexQueries, self).setUp()
        name = "cname_test.%s" % self.get_dns_domain()
        rdata = "%s.%s" % (self.server, self.get_dns_domain())
        self.make_dns_update(name, rdata, dns.DNS_QTYPE_CNAME)

    def tearDown(self):
        super(TestComplexQueries, self).tearDown()
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        updates = []

        name = self.get_dns_domain()

        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        updates.append(u)
        self.finish_name_packet(p, updates)

        updates = []
        r = dns.res_rec()
        r.name = "cname_test.%s" % self.get_dns_domain()
        r.rr_type = dns.DNS_QTYPE_CNAME
        r.rr_class = dns.DNS_QCLASS_NONE
        r.ttl = 0
        r.length = 0xffff
        r.rdata = "%s.%s" % (self.server, self.get_dns_domain())
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

    def test_one_a_query(self):
        "create a query packet containing one query record"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "cname_test.%s" % self.get_dns_domain()
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 2)
        self.assertEquals(response.answers[0].rr_type, dns.DNS_QTYPE_CNAME)
        self.assertEquals(response.answers[0].rdata, "%s.%s" %
                          (self.server, self.get_dns_domain()))
        self.assertEquals(response.answers[1].rr_type, dns.DNS_QTYPE_A)
        self.assertEquals(response.answers[1].rdata,
                          self.server_ip)

    def test_cname_two_chain(self):
        name0 = "cnamechain0.%s" % self.get_dns_domain()
        name1 = "cnamechain1.%s" % self.get_dns_domain()
        name2 = "cnamechain2.%s" % self.get_dns_domain()
        self.make_dns_update(name1, name2, dns.DNS_QTYPE_CNAME)
        self.make_dns_update(name2, name0, dns.DNS_QTYPE_CNAME)
        self.make_dns_update(name0, server_ip, dns.DNS_QTYPE_A)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(name1, dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 3)

        self.assertEquals(response.answers[0].rr_type, dns.DNS_QTYPE_CNAME)
        self.assertEquals(response.answers[0].name, name1)
        self.assertEquals(response.answers[0].rdata, name2)

        self.assertEquals(response.answers[1].rr_type, dns.DNS_QTYPE_CNAME)
        self.assertEquals(response.answers[1].name, name2)
        self.assertEquals(response.answers[1].rdata, name0)

        self.assertEquals(response.answers[2].rr_type, dns.DNS_QTYPE_A)
        self.assertEquals(response.answers[2].rdata,
                          self.server_ip)

    def test_cname_two_chain_not_matching_qtype(self):
        name0 = "cnamechain0.%s" % self.get_dns_domain()
        name1 = "cnamechain1.%s" % self.get_dns_domain()
        name2 = "cnamechain2.%s" % self.get_dns_domain()
        self.make_dns_update(name1, name2, dns.DNS_QTYPE_CNAME)
        self.make_dns_update(name2, name0, dns.DNS_QTYPE_CNAME)
        self.make_dns_update(name0, server_ip, dns.DNS_QTYPE_A)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(name1, dns.DNS_QTYPE_TXT,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)

        # CNAME should return all intermediate results!
        # Only the A records exists, not the TXT.
        self.assertEquals(response.ancount, 2)

        self.assertEquals(response.answers[0].rr_type, dns.DNS_QTYPE_CNAME)
        self.assertEquals(response.answers[0].name, name1)
        self.assertEquals(response.answers[0].rdata, name2)

        self.assertEquals(response.answers[1].rr_type, dns.DNS_QTYPE_CNAME)
        self.assertEquals(response.answers[1].name, name2)
        self.assertEquals(response.answers[1].rdata, name3)

    def test_cname_loop(self):
        cname1 = "cnamelooptestrec." + self.get_dns_domain()
        cname2 = "cnamelooptestrec2." + self.get_dns_domain()
        cname3 = "cnamelooptestrec3." + self.get_dns_domain()
        self.make_dns_update(cname1, cname2, dnsp.DNS_TYPE_CNAME)
        self.make_dns_update(cname2, cname3, dnsp.DNS_TYPE_CNAME)
        self.make_dns_update(cname3, cname1, dnsp.DNS_TYPE_CNAME)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(cname1,
                                    dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)
        self.finish_name_packet(p, questions)

        response = self.dns_transaction_udp(p, host=self.server_ip)

        max_recursion_depth = 20
        self.assertEquals(len(response.answers), max_recursion_depth)

    # Make sure cname limit doesn't count other records.  This is a generic
    # test called in tests below
    def max_rec_test(self, rtype, rec_gen):
        name = "limittestrec{0}.{1}".format(rtype, self.get_dns_domain())
        limit = 20
        num_recs_to_enter = limit + 5

        for i in range(1, num_recs_to_enter+1):
            ip = rec_gen(i)
            self.make_dns_update(name, ip, rtype)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name,
                                    rtype,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)
        self.finish_name_packet(p, questions)

        response = self.dns_transaction_udp(p, host=self.server_ip)

        self.assertEqual(len(response.answers), num_recs_to_enter)

    def test_record_limit_A(self):
        def ip4_gen(i):
            return "127.0.0." + str(i)
        self.max_rec_test(rtype=dns.DNS_QTYPE_A, rec_gen=ip4_gen)

    def test_record_limit_AAAA(self):
        def ip6_gen(i):
            return "AAAA:0:0:0:0:0:0:" + str(i)
        self.max_rec_test(rtype=dns.DNS_QTYPE_AAAA, rec_gen=ip6_gen)

    def test_record_limit_SRV(self):
        def srv_gen(i):
            rec = dns.srv_record()
            rec.priority = 1
            rec.weight = 1
            rec.port = 92
            rec.target = "srvtestrec" + str(i)
            return rec
        self.max_rec_test(rtype=dns.DNS_QTYPE_SRV, rec_gen=srv_gen)

    # Same as test_record_limit_A but with a preceding CNAME follow
    def test_cname_limit(self):
        cname1 = "cnamelimittestrec." + self.get_dns_domain()
        cname2 = "cnamelimittestrec2." + self.get_dns_domain()
        cname3 = "cnamelimittestrec3." + self.get_dns_domain()
        ip_prefix = '127.0.0.'
        limit = 20
        num_recs_to_enter = limit + 5

        self.make_dns_update(cname1, cname2, dnsp.DNS_TYPE_CNAME)
        self.make_dns_update(cname2, cname3, dnsp.DNS_TYPE_CNAME)
        num_arecs_to_enter = num_recs_to_enter - 2
        for i in range(1, num_arecs_to_enter+1):
            ip = ip_prefix + str(i)
            self.make_dns_update(cname3, ip, dns.DNS_QTYPE_A)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(cname1,
                                    dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)
        self.finish_name_packet(p, questions)

        response = self.dns_transaction_udp(p, host=self.server_ip)

        self.assertEqual(len(response.answers), num_recs_to_enter)

    # ANY query on cname record shouldn't follow the link
    def test_cname_any_query(self):
        cname1 = "cnameanytestrec." + self.get_dns_domain()
        cname2 = "cnameanytestrec2." + self.get_dns_domain()
        cname3 = "cnameanytestrec3." + self.get_dns_domain()

        self.make_dns_update(cname1, cname2, dnsp.DNS_TYPE_CNAME)
        self.make_dns_update(cname2, cname3, dnsp.DNS_TYPE_CNAME)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(cname1,
                                    dns.DNS_QTYPE_ALL,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)
        self.finish_name_packet(p, questions)

        response = self.dns_transaction_udp(p, host=self.server_ip)

        self.assertEqual(len(response.answers), 1)
        self.assertEqual(response.answers[0].name, cname1)
        self.assertEqual(response.answers[0].rdata, cname2)


class TestInvalidQueries(DNSTest):

    def test_one_a_query(self):
        "send 0 bytes follows by create a query packet containing one query record"

        s = None
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
            s.connect((self.server_ip, 53))
            s.send("", 0)
        finally:
            if s is not None:
                s.close()

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % (self.server, self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 1)
        self.assertEquals(response.answers[0].rdata,
                          self.server_ip)

    def test_one_a_reply(self):
        "send a reply instead of a query"
        global timeout

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        name = "%s.%s" % ('fakefakefake', self.get_dns_domain())
        q = self.make_name_question(name, dns.DNS_QTYPE_A, dns.DNS_QCLASS_IN)
        print "asking for ", q.name
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_REPLY
        s = None
        try:
            send_packet = ndr.ndr_pack(p)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
            s.settimeout(timeout)
            host=self.server_ip
            s.connect((host, 53))
            tcp_packet = struct.pack('!H', len(send_packet))
            tcp_packet += send_packet
            s.send(tcp_packet, 0)
            recv_packet = s.recv(0xffff + 2, 0)
            self.assertEquals(0, len(recv_packet))
        except socket.timeout:
            # Windows chooses not to respond to incorrectly formatted queries.
            # Although this appears to be non-deterministic even for the same
            # request twice, it also appears to be based on a how poorly the
            # request is formatted.
            pass
        finally:
            if s is not None:
                s.close()

class TestZones(DNSTest):
    def setUp(self):
        super(TestZones, self).setUp()
        self.zone = "test.lan"
        self.rpc_conn = dnsserver.dnsserver("ncacn_ip_tcp:%s[sign]" % (self.server_ip),
                                            self.lp, self.creds)

    def tearDown(self):
        super(TestZones, self).tearDown()
        try:
            self.delete_zone(self.zone)
        except RuntimeError, (num, string):
            if num != 9601: #WERR_DNS_ERROR_ZONE_DOES_NOT_EXIST
                raise

    def create_zone(self, zone):
        zone_create = dnsserver.DNS_RPC_ZONE_CREATE_INFO_LONGHORN()
        zone_create.pszZoneName = zone
        zone_create.dwZoneType = dnsp.DNS_ZONE_TYPE_PRIMARY
        zone_create.fAllowUpdate = dnsp.DNS_ZONE_UPDATE_SECURE
        zone_create.fAging = 0
        zone_create.dwDpFlags = dnsserver.DNS_DP_DOMAIN_DEFAULT
        self.rpc_conn.DnssrvOperation2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                       0,
                                       self.server_ip,
                                       None,
                                       0,
                                       'ZoneCreate',
                                       dnsserver.DNSSRV_TYPEID_ZONE_CREATE,
                                       zone_create)

    def delete_zone(self, zone):
        self.rpc_conn.DnssrvOperation2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                       0,
                                       self.server_ip,
                                       zone,
                                       0,
                                       'DeleteZoneFromDs',
                                       dnsserver.DNSSRV_TYPEID_NULL,
                                       None)

    def test_soa_query(self):
        zone = "test.lan"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(zone, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        questions.append(q)
        self.finish_name_packet(p, questions)

        response = self.dns_transaction_udp(p)
        # Windows returns OK while BIND logically seems to return NXDOMAIN
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXDOMAIN)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 0)

        self.create_zone(zone)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 1)
        self.assertEquals(response.answers[0].rr_type, dns.DNS_QTYPE_SOA)

        self.delete_zone(zone)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NXDOMAIN)
        self.assert_dns_opcode_equals(response, dns.DNS_OPCODE_QUERY)
        self.assertEquals(response.ancount, 0)

class TestRPCRoundtrip(DNSTest):
    def setUp(self):
        super(TestRPCRoundtrip, self).setUp()
        self.rpc_conn = dnsserver.dnsserver("ncacn_ip_tcp:%s[sign]" % (self.server_ip),
                                            self.lp, self.creds)

    def tearDown(self):
        super(TestRPCRoundtrip, self).tearDown()

    def test_update_add_txt_rpc_to_dns(self):
        prefix, txt = 'rpctextrec', ['"This is a test"']

        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"\\"This is a test\\""')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

    def test_update_add_null_padded_txt_record(self):
        "test adding records works"
        prefix, txt = 'pad1textrec', ['"This is a test"', '', '']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"\\"This is a test\\"" "" ""'))

        prefix, txt = 'pad2textrec', ['"This is a test"', '', '', 'more text']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"\\"This is a test\\"" "" "" "more text"'))

        prefix, txt = 'pad3textrec', ['', '', '"This is a test"']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"" "" "\\"This is a test\\""'))

    def test_update_add_padding_rpc_to_dns(self):
        prefix, txt = 'pad1textrec', ['"This is a test"', '', '']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"\\"This is a test\\"" "" ""')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

        prefix, txt = 'pad2textrec', ['"This is a test"', '', '', 'more text']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"\\"This is a test\\"" "" "" "more text"')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

        prefix, txt = 'pad3textrec', ['', '', '"This is a test"']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"" "" "\\"This is a test\\""')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

    # Test is incomplete due to strlen against txt records
    def test_update_add_null_char_txt_record(self):
        "test adding records works"
        prefix, txt = 'nulltextrec', ['NULL\x00BYTE']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, ['NULL'])
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"NULL"'))

        prefix, txt = 'nulltextrec2', ['NULL\x00BYTE', 'NULL\x00BYTE']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, ['NULL', 'NULL'])
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"NULL" "NULL"'))

    def test_update_add_null_char_rpc_to_dns(self):
        prefix, txt = 'nulltextrec', ['NULL\x00BYTE']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"NULL"')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, ['NULL'])
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

    def test_update_add_hex_char_txt_record(self):
        "test adding records works"
        prefix, txt = 'hextextrec', ['HIGH\xFFBYTE']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"HIGH\xFFBYTE"'))

    def test_update_add_hex_rpc_to_dns(self):
        prefix, txt = 'hextextrec', ['HIGH\xFFBYTE']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"HIGH\xFFBYTE"')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

    def test_update_add_slash_txt_record(self):
        "test adding records works"
        prefix, txt = 'slashtextrec', ['Th\\=is=is a test']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"Th\\\\=is=is a test"'))

    # This test fails against Windows as it eliminates slashes in RPC
    # One typical use for a slash is in records like 'var=value' to
    # escape '=' characters.
    def test_update_add_slash_rpc_to_dns(self):
        prefix, txt = 'slashtextrec', ['Th\\=is=is a test']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '"Th\\\\=is=is a test"')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

    def test_update_add_two_txt_records(self):
        "test adding two txt records works"
        prefix, txt = 'textrec2', ['"This is a test"',
                                   '"and this is a test, too"']
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, '"\\"This is a test\\""' +
                             ' "\\"and this is a test, too\\""'))

    def test_update_add_two_rpc_to_dns(self):
        prefix, txt = 'textrec2', ['"This is a test"',
                                   '"and this is a test, too"']
        prefix = 'rpc' + prefix
        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT,
                                '"\\"This is a test\\""' +
                                ' "\\"and this is a test, too\\""')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

    def test_update_add_empty_txt_records(self):
        "test adding two txt records works"
        prefix, txt = 'emptytextrec', []
        p = self.make_txt_update(prefix, txt)
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.check_query_txt(prefix, txt)
        self.assertIsNotNone(dns_record_match(self.rpc_conn, self.server_ip,
                             self.get_dns_domain(),
                             "%s.%s" % (prefix, self.get_dns_domain()),
                             dnsp.DNS_TYPE_TXT, ''))

    def test_update_add_empty_rpc_to_dns(self):
        prefix, txt = 'rpcemptytextrec', []

        name = "%s.%s" % (prefix, self.get_dns_domain())

        rec = data_to_dns_record(dnsp.DNS_TYPE_TXT, '')
        add_rec_buf = dnsserver.DNS_RPC_RECORD_BUF()
        add_rec_buf.rec = rec
        try:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                     0, self.server_ip, self.get_dns_domain(),
                                     name, add_rec_buf, None)

            self.check_query_txt(prefix, txt)
        finally:
            self.rpc_conn.DnssrvUpdateRecord2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
                                              0, self.server_ip, self.get_dns_domain(),
                                              name, None, add_rec_buf)

TestProgram(module=__name__, opts=subunitopts)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Unix SMB/CIFS implementation.
# Copyright (C) Kai Blin  <kai@samba.org> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import sys
import struct
import random
import socket
import samba
import time
import errno
import samba.ndr as ndr
from samba import credentials, param
from samba.tests import TestCase
from samba.dcerpc import dns, dnsp, dnsserver
from samba.netcmd.dns import TXTRecord, dns_record_match, data_to_dns_record
from samba.tests.subunitrun import SubunitOptions, TestProgram
import samba.getopt as options
import optparse
import subprocess

parser = optparse.OptionParser("dns_forwarder.py <server name> <server ip> (dns forwarder)+ [options]")
sambaopts = options.SambaOptions(parser)
parser.add_option_group(sambaopts)

# This timeout only has relevance when testing against Windows
# Format errors tend to return patchy responses, so a timeout is needed.
parser.add_option("--timeout", type="int", dest="timeout",
                  help="Specify timeout for DNS requests")

# use command line creds if available
credopts = options.CredentialsOptions(parser)
parser.add_option_group(credopts)
subunitopts = SubunitOptions(parser)
parser.add_option_group(subunitopts)

opts, args = parser.parse_args()

lp = sambaopts.get_loadparm()
creds = credopts.get_credentials(lp)

timeout = opts.timeout

if len(args) < 3:
    parser.print_usage()
    sys.exit(1)

server_name = args[0]
server_ip = args[1]
dns_servers = args[2:]

creds.set_krb_forwardable(credentials.NO_KRB_FORWARDABLE)

def make_txt_record(records):
    rdata_txt = dns.txt_record()
    s_list = dnsp.string_list()
    s_list.count = len(records)
    s_list.str = records
    rdata_txt.txt = s_list
    return rdata_txt


class DNSTest(TestCase):

    errcodes = dict((v, k) for k, v in vars(dns).items() if k.startswith('DNS_RCODE_'))

    def assert_dns_rcode_equals(self, packet, rcode):
        "Helper function to check return code"
        p_errcode = packet.operation & 0x000F
        self.assertEquals(p_errcode, rcode, "Expected RCODE %s, got %s" %
                          (self.errcodes[rcode], self.errcodes[p_errcode]))

    def assert_dns_opcode_equals(self, packet, opcode):
        "Helper function to check opcode"
        p_opcode = packet.operation & 0x7800
        self.assertEquals(p_opcode, opcode, "Expected OPCODE %s, got %s" %
                            (opcode, p_opcode))

    def make_name_packet(self, opcode, qid=None):
        "Helper creating a dns.name_packet"
        p = dns.name_packet()
        if qid is None:
            p.id = random.randint(0x0, 0xffff)
        p.operation = opcode
        p.questions = []
        return p

    def finish_name_packet(self, packet, questions):
        "Helper to finalize a dns.name_packet"
        packet.qdcount = len(questions)
        packet.questions = questions

    def make_name_question(self, name, qtype, qclass):
        "Helper creating a dns.name_question"
        q = dns.name_question()
        q.name = name
        q.question_type = qtype
        q.question_class = qclass
        return q

    def get_dns_domain(self):
        "Helper to get dns domain"
        return self.creds.get_realm().lower()

    def dns_transaction_udp(self, packet, host=server_ip,
                            dump=False, timeout=timeout):
        "send a DNS query and read the reply"
        s = None
        try:
            send_packet = ndr.ndr_pack(packet)
            if dump:
                print self.hexdump(send_packet)
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
            s.settimeout(timeout)
            s.connect((host, 53))
            s.send(send_packet, 0)
            recv_packet = s.recv(2048, 0)
            if dump:
                print self.hexdump(recv_packet)
            return ndr.ndr_unpack(dns.name_packet, recv_packet)
        finally:
            if s is not None:
                s.close()

    def make_cname_update(self, key, value):
        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)

        name = self.get_dns_domain()
        u = self.make_name_question(name, dns.DNS_QTYPE_SOA, dns.DNS_QCLASS_IN)
        self.finish_name_packet(p, [u])

        r = dns.res_rec()
        r.name = key
        r.rr_type = dns.DNS_QTYPE_CNAME
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 900
        r.length = 0xffff
        rdata = value
        r.rdata = rdata
        p.nscount = 1
        p.nsrecs = [r]
        response = self.dns_transaction_udp(p)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)



def contact_real_server(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
    s.connect((host, port))
    return s


class TestDnsForwarding(DNSTest):
    def __init__(self, *args, **kwargs):
        super(TestDnsForwarding, self).__init__(*args, **kwargs)
        self.subprocesses = []

    def setUp(self):
        super(TestDnsForwarding, self).setUp()
        self.server = server_name
        self.server_ip = server_ip
        self.lp = lp
        self.creds = creds

    def start_toy_server(self, host, port, id):
        python = sys.executable
        p = subprocess.Popen([python,
                              os.path.join(samba.source_tree_topdir(),
                                           'python/samba/tests/'
                                           'dns_forwarder_helpers/server.py'),
                             host, str(port), id])
        self.subprocesses.append(p)
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        for i in xrange(300):
            time.sleep(0.05)
            s.connect((host, port))
            try:
                s.send('timeout 0', 0)
            except socket.error, e:
                if e.errno in (errno.ECONNREFUSED, errno.EHOSTUNREACH):
                    continue

            if p.returncode is not None:
                self.fail("Toy server has managed to die already!")

            return s

    def tearDown(self):
        super(TestDnsForwarding, self).tearDown()
        for p in self.subprocesses:
            p.kill()

    def test_comatose_forwarder(self):
        s = self.start_toy_server(dns_servers[0], 53, 'forwarder1')
        s.send("timeout 1000000", 0)

        # make DNS query
        name = "an-address-that-will-not-resolve"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        send_packet = ndr.ndr_pack(p)

        s.send(send_packet, 0)
        s.settimeout(1)
        try:
            s.recv(0xffff + 2, 0)
            self.fail("DNS forwarder should have been inactive")
        except socket.timeout:
            # Expected forwarder to be dead
            pass

    def test_no_active_forwarder(self):
        ad = contact_real_server(server_ip, 53)

        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        send_packet = ndr.ndr_pack(p)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_SERVFAIL)
            self.assertEqual(data.ancount, 0)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_no_flag_recursive_forwarder(self):
        ad = contact_real_server(server_ip, 53)

        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        send_packet = ndr.ndr_pack(p)

        self.finish_name_packet(p, questions)
        # Leave off the recursive flag
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_NXDOMAIN)
            self.assertEqual(data.ancount, 0)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_single_forwarder(self):
        s = self.start_toy_server(dns_servers[0], 53, 'forwarder1')
        ad = contact_real_server(server_ip, 53)
        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder1', data.answers[0].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_single_forwarder_not_actually_there(self):
        ad = contact_real_server(server_ip, 53)
        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_SERVFAIL)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)


    def test_single_forwarder_waiting_forever(self):
        s = self.start_toy_server(dns_servers[0], 53, 'forwarder1')
        s.send('timeout 10000', 0)
        ad = contact_real_server(server_ip, 53)
        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_SERVFAIL)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_double_forwarder_first_frozen(self):
        if len(dns_servers) < 2:
            print "Ignoring test_double_forwarder_first_frozen"
            return
        s1 = self.start_toy_server(dns_servers[0], 53, 'forwarder1')
        s2 = self.start_toy_server(dns_servers[1], 53, 'forwarder2')
        s1.send('timeout 1000', 0)
        ad = contact_real_server(server_ip, 53)
        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder2', data.answers[0].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_double_forwarder_first_down(self):
        if len(dns_servers) < 2:
            print "Ignoring test_double_forwarder_first_down"
            return
        s2 = self.start_toy_server(dns_servers[1], 53, 'forwarder2')
        ad = contact_real_server(server_ip, 53)
        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder2', data.answers[0].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_double_forwarder_both_slow(self):
        if len(dns_servers) < 2:
            print "Ignoring test_double_forwarder_both_slow"
            return
        s1 = self.start_toy_server(dns_servers[0], 53, 'forwarder1')
        s2 = self.start_toy_server(dns_servers[1], 53, 'forwarder2')
        s1.send('timeout 1.5', 0)
        s2.send('timeout 1.5', 0)
        ad = contact_real_server(server_ip, 53)
        name = "dsfsfds.dsfsdfs"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder1', data.answers[0].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_cname(self):
        s1 = self.start_toy_server(dns_servers[0], 53, 'forwarder1')

        ad = contact_real_server(server_ip, 53)
        name = "resolve.cname"
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_CNAME,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual(len(data.answers), 1)
            self.assertEqual('forwarder1', data.answers[0].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_double_cname(self):
        s1 = self.start_toy_server(dns_servers[0], 53, 'forwarder1')

        name = 'resolve.cname.%s' % self.get_dns_domain()
        self.make_cname_update(name, "dsfsfds.dsfsdfs")

        ad = contact_real_server(server_ip, 53)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(name, dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder1', data.answers[1].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_cname_forwarding_with_slow_server(self):
        if len(dns_servers) < 2:
            print "Ignoring test_cname_forwarding_with_slow_server"
            return
        s1 = self.start_toy_server(dns_servers[0], 53, 'forwarder1')
        s2 = self.start_toy_server(dns_servers[1], 53, 'forwarder2')
        s1.send('timeout 10000', 0)

        name = 'resolve.cname.%s' % self.get_dns_domain()
        self.make_cname_update(name, "dsfsfds.dsfsdfs")

        ad = contact_real_server(server_ip, 53)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(name, dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder2', data.answers[-1].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_cname_forwarding_with_server_down(self):
        if len(dns_servers) < 2:
            print "Ignoring test_cname_forwarding_with_server_down"
            return
        s2 = self.start_toy_server(dns_servers[1], 53, 'forwarder2')

        name1 = 'resolve1.cname.%s' % self.get_dns_domain()
        name2 = 'resolve2.cname.%s' % self.get_dns_domain()
        self.make_cname_update(name1, name2)
        self.make_cname_update(name2, "dsfsfds.dsfsdfs")

        ad = contact_real_server(server_ip, 53)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(name1, dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual('forwarder2', data.answers[-1].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

    def test_cname_forwarding_with_lots_of_cnames(self):
        name3 = 'resolve3.cname.%s' % self.get_dns_domain()
        s1 = self.start_toy_server(dns_servers[0], 53, name3)

        name1 = 'resolve1.cname.%s' % self.get_dns_domain()
        name2 = 'resolve2.cname.%s' % self.get_dns_domain()
        self.make_cname_update(name1, name2)
        self.make_cname_update(name3, name1)
        self.make_cname_update(name2, "dsfsfds.dsfsdfs")

        ad = contact_real_server(server_ip, 53)

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []
        q = self.make_name_question(name1, dns.DNS_QTYPE_A,
                                    dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        p.operation |= dns.DNS_FLAG_RECURSION_DESIRED
        send_packet = ndr.ndr_pack(p)

        ad.send(send_packet, 0)
        ad.settimeout(timeout)
        try:
            data = ad.recv(0xffff + 2, 0)
            data = ndr.ndr_unpack(dns.name_packet, data)
            # This should cause a loop in Windows
            # (which is restricted by a 20 CNAME limit)
            #
            # The reason it doesn't here is because forwarded CNAME have no
            # additional processing in the internal DNS server.
            self.assert_dns_rcode_equals(data, dns.DNS_RCODE_OK)
            self.assertEqual(name3, data.answers[-1].rdata)
        except socket.timeout:
            self.fail("DNS server is too slow (timeout %s)" % timeout)

TestProgram(module=__name__, opts=subunitopts)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Unix SMB/CIFS implementation.
# Copyright (C) Catalyst.Net Ltd 2016
# Catalyst.Net's contribution was written by Douglas Bagnall
# <douglas.bagnall@catalyst.net.nz> and Garming Sam <garming@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Based on the EchoServer example from python docs
import SocketServer
import time
import sys
from threading import Timer
from samba.dcerpc import dns
import samba.ndr as ndr
import random
import re

VERBOSE = False

def debug(msg):
    if VERBOSE:
        sys.stdout.flush()
        print "\033[00;36m%s\033[00m" % msg
        sys.stdout.flush()

timeout = 0


def answer_question(data, question):
    r = dns.res_rec()
    r.name = question.name
    r.rr_type = dns.DNS_QTYPE_CNAME
    r.rr_class = dns.DNS_QCLASS_IN
    r.ttl = 900
    r.length = 0xffff
    r.rdata = SERVER_ID
    return r


class DnsHandler(SocketServer.BaseRequestHandler):
    def make_answer(self, data):
        data = ndr.ndr_unpack(dns.name_packet, data)

        debug('answering this question:')
        debug(data.__ndr_print__())

        answer = answer_question(data, data.questions[0])
        if answer is not None:
            data.answers = [answer] * 1
            data.ancount += 1
            debug('the answer was: ')
            debug(data.__ndr_print__())

        data.operation |= dns.DNS_FLAG_REPLY

        return ndr.ndr_pack(data)

    def really_handle(self, data, socket):
        answer = self.make_answer(data)
        socket.sendto(answer, self.client_address)

    def handle(self):
        data, socket = self.request
        debug("%s: %s wrote:" % (SERVER_ID, self.client_address[0]))

        global timeout
        m = re.match('^timeout\s+([\d.]+)$', data.strip())
        if m:
            timeout = float(m.group(1))
            debug("timing out at %s" % timeout)
            return

        t = Timer(timeout, self.really_handle, [data, socket])
        t.start()

def main():
    global SERVER_ID
    host, port, SERVER_ID = sys.argv[1:]
    server = SocketServer.UDPServer((host, int(port)), DnsHandler)
    server.serve_forever()

main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Unix SMB/CIFS implementation.
# Copyright (C) Kai Blin  <kai@samba.org> 2011
# Copyright (C) Ralph Boehme  <slow@samba.org> 2016
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
import struct
import random
import socket
import optparse
import uuid
import time
import samba.ndr as ndr
import samba.getopt as options
from samba import credentials
from samba.dcerpc import dns, dnsp
from samba.tests.subunitrun import SubunitOptions, TestProgram
from samba import gensec, tests

parser = optparse.OptionParser("dns.py <server name> <server ip> [options]")
sambaopts = options.SambaOptions(parser)
parser.add_option_group(sambaopts)

# This timeout only has relevance when testing against Windows
# Format errors tend to return patchy responses, so a timeout is needed.
parser.add_option("--timeout", type="int", dest="timeout",
                  help="Specify timeout for DNS requests")

# use command line creds if available
credopts = options.CredentialsOptions(parser)
parser.add_option_group(credopts)
subunitopts = SubunitOptions(parser)
parser.add_option_group(subunitopts)

opts, args = parser.parse_args()
timeout = opts.timeout

if len(args) < 2:
    parser.print_usage()
    sys.exit(1)

server_name = args[0]
server_ip = args[1]


class DNSTest(tests.TestCase):
    def setUp(self):
        super(DNSTest, self).setUp()
        self.server = server_name
        self.server_ip = server_ip
        self.settings = {}
        self.settings["lp_ctx"] = self.lp_ctx = tests.env_loadparm()
        self.settings["target_hostname"] = self.server

        self.creds = credentials.Credentials()
        self.creds.guess(self.lp_ctx)
        self.creds.set_username(tests.env_get_var_value('USERNAME'))
        self.creds.set_password(tests.env_get_var_value('PASSWORD'))
        self.creds.set_kerberos_state(credentials.MUST_USE_KERBEROS)
        self.newrecname = "tkeytsig.%s" % self.get_dns_domain()

    def errstr(self, errcode):
        "Return a readable error code"
        string_codes = [
            "OK",
            "FORMERR",
            "SERVFAIL",
            "NXDOMAIN",
            "NOTIMP",
            "REFUSED",
            "YXDOMAIN",
            "YXRRSET",
            "NXRRSET",
            "NOTAUTH",
            "NOTZONE",
            "0x0B",
            "0x0C",
            "0x0D",
            "0x0E",
            "0x0F",
            "BADSIG",
            "BADKEY"
        ]

        return string_codes[errcode]

    def assert_rcode_equals(self, rcode, expected):
        "Helper function to check return code"
        self.assertEquals(rcode, expected, "Expected RCODE %s, got %s" %
                          (self.errstr(expected), self.errstr(rcode)))

    def assert_dns_rcode_equals(self, packet, rcode):
        "Helper function to check return code"
        p_errcode = packet.operation & 0x000F
        self.assertEquals(p_errcode, rcode, "Expected RCODE %s, got %s" %
                          (self.errstr(rcode), self.errstr(p_errcode)))

    def assert_dns_opcode_equals(self, packet, opcode):
        "Helper function to check opcode"
        p_opcode = packet.operation & 0x7800
        self.assertEquals(p_opcode, opcode, "Expected OPCODE %s, got %s" %
                          (opcode, p_opcode))

    def make_name_packet(self, opcode, qid=None):
        "Helper creating a dns.name_packet"
        p = dns.name_packet()
        if qid is None:
            p.id = random.randint(0x0, 0xff00)
        p.operation = opcode
        p.questions = []
        p.additional = []
        return p

    def finish_name_packet(self, packet, questions):
        "Helper to finalize a dns.name_packet"
        packet.qdcount = len(questions)
        packet.questions = questions

    def make_name_question(self, name, qtype, qclass):
        "Helper creating a dns.name_question"
        q = dns.name_question()
        q.name = name
        q.question_type = qtype
        q.question_class = qclass
        return q

    def make_txt_record(self, records):
        rdata_txt = dns.txt_record()
        s_list = dnsp.string_list()
        s_list.count = len(records)
        s_list.str = records
        rdata_txt.txt = s_list
        return rdata_txt

    def get_dns_domain(self):
        "Helper to get dns domain"
        return self.creds.get_realm().lower()

    def dns_transaction_udp(self, packet, host,
                            dump=False, timeout=timeout):
        "send a DNS query and read the reply"
        s = None
        try:
            send_packet = ndr.ndr_pack(packet)
            if dump:
                print self.hexdump(send_packet)
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
            s.settimeout(timeout)
            s.connect((host, 53))
            s.sendall(send_packet, 0)
            recv_packet = s.recv(2048, 0)
            if dump:
                print self.hexdump(recv_packet)
            response = ndr.ndr_unpack(dns.name_packet, recv_packet)
            return (response, recv_packet)
        finally:
            if s is not None:
                s.close()

    def dns_transaction_tcp(self, packet, host,
                            dump=False, timeout=timeout):
        "send a DNS query and read the reply, also return the raw packet"
        s = None
        try:
            send_packet = ndr.ndr_pack(packet)
            if dump:
                print self.hexdump(send_packet)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
            s.settimeout(timeout)
            s.connect((host, 53))
            tcp_packet = struct.pack('!H', len(send_packet))
            tcp_packet += send_packet
            s.sendall(tcp_packet)

            recv_packet = s.recv(0xffff + 2, 0)
            if dump:
                print self.hexdump(recv_packet)
            response = ndr.ndr_unpack(dns.name_packet, recv_packet[2:])

        finally:
            if s is not None:
                s.close()

        # unpacking and packing again should produce same bytestream
        my_packet = ndr.ndr_pack(response)
        self.assertEquals(my_packet, recv_packet[2:])

        return (response, recv_packet[2:])

    def tkey_trans(self):
        "Do a TKEY transaction and establish a gensec context"

        self.key_name = "%s.%s" % (uuid.uuid4(), self.get_dns_domain())

        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        q = self.make_name_question(self.key_name,
                                    dns.DNS_QTYPE_TKEY,
                                    dns.DNS_QCLASS_IN)
        questions = []
        questions.append(q)
        self.finish_name_packet(p, questions)

        r = dns.res_rec()
        r.name = self.key_name
        r.rr_type = dns.DNS_QTYPE_TKEY
        r.rr_class = dns.DNS_QCLASS_IN
        r.ttl = 0
        r.length = 0xffff
        rdata = dns.tkey_record()
        rdata.algorithm = "gss-tsig"
        rdata.inception = int(time.time())
        rdata.expiration = int(time.time()) + 60*60
        rdata.mode = dns.DNS_TKEY_MODE_GSSAPI
        rdata.error = 0
        rdata.other_size = 0

        self.g = gensec.Security.start_client(self.settings)
        self.g.set_credentials(self.creds)
        self.g.set_target_service("dns")
        self.g.set_target_hostname(self.server)
        self.g.want_feature(gensec.FEATURE_SIGN)
        self.g.start_mech_by_name("spnego")

        finished = False
        client_to_server = ""

        (finished, server_to_client) = self.g.update(client_to_server)
        self.assertFalse(finished)

        data = [ord(x) for x in list(server_to_client)]
        rdata.key_data = data
        rdata.key_size = len(data)
        r.rdata = rdata

        additional = [r]
        p.arcount = 1
        p.additional = additional

        (response, response_packet) = self.dns_transaction_tcp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)

        tkey_record = response.answers[0].rdata
        data = [chr(x) for x in tkey_record.key_data]
        server_to_client = ''.join(data)
        (finished, client_to_server) = self.g.update(server_to_client)
        self.assertTrue(finished)

        self.verify_packet(response, response_packet)

    def verify_packet(self, response, response_packet, request_mac=""):
        self.assertEqual(response.additional[0].rr_type, dns.DNS_QTYPE_TSIG)

        tsig_record = response.additional[0].rdata
        mac = ''.join([chr(x) for x in tsig_record.mac])

        # Cut off tsig record from dns response packet for MAC verification
        # and reset additional record count.
        key_name_len = len(self.key_name) + 2
        tsig_record_len = len(ndr.ndr_pack(tsig_record)) + key_name_len + 10

        response_packet_list = list(response_packet)
        del response_packet_list[-tsig_record_len:]
        response_packet_list[11] = chr(0)
        response_packet_wo_tsig = ''.join(response_packet_list)

        fake_tsig = dns.fake_tsig_rec()
        fake_tsig.name = self.key_name
        fake_tsig.rr_class = dns.DNS_QCLASS_ANY
        fake_tsig.ttl = 0
        fake_tsig.time_prefix = tsig_record.time_prefix
        fake_tsig.time = tsig_record.time
        fake_tsig.algorithm_name = tsig_record.algorithm_name
        fake_tsig.fudge = tsig_record.fudge
        fake_tsig.error = 0
        fake_tsig.other_size = 0
        fake_tsig_packet = ndr.ndr_pack(fake_tsig)

        data = request_mac + response_packet_wo_tsig + fake_tsig_packet
        self.g.check_packet(data, data, mac)

    def sign_packet(self, packet, key_name):
        "Sign a packet, calculate a MAC and add TSIG record"
        packet_data = ndr.ndr_pack(packet)

        fake_tsig = dns.fake_tsig_rec()
        fake_tsig.name = key_name
        fake_tsig.rr_class = dns.DNS_QCLASS_ANY
        fake_tsig.ttl = 0
        fake_tsig.time_prefix = 0
        fake_tsig.time = int(time.time())
        fake_tsig.algorithm_name = "gss-tsig"
        fake_tsig.fudge = 300
        fake_tsig.error = 0
        fake_tsig.other_size = 0
        fake_tsig_packet = ndr.ndr_pack(fake_tsig)

        data = packet_data + fake_tsig_packet
        mac = self.g.sign_packet(data, data)
        mac_list = [ord(x) for x in list(mac)]

        rdata = dns.tsig_record()
        rdata.algorithm_name = "gss-tsig"
        rdata.time_prefix = 0
        rdata.time = fake_tsig.time
        rdata.fudge = 300
        rdata.original_id = packet.id
        rdata.error = 0
        rdata.other_size = 0
        rdata.mac = mac_list
        rdata.mac_size = len(mac_list)

        r = dns.res_rec()
        r.name = key_name
        r.rr_type = dns.DNS_QTYPE_TSIG
        r.rr_class = dns.DNS_QCLASS_ANY
        r.ttl = 0
        r.length = 0xffff
        r.rdata = rdata

        additional = [r]
        packet.additional = additional
        packet.arcount = 1

        return mac

    def bad_sign_packet(self, packet, key_name):
        '''Add bad signature for a packet by bitflipping
        the final byte in the MAC'''

        mac_list = [ord(x) for x in list("badmac")]

        rdata = dns.tsig_record()
        rdata.algorithm_name = "gss-tsig"
        rdata.time_prefix = 0
        rdata.time = int(time.time())
        rdata.fudge = 300
        rdata.original_id = packet.id
        rdata.error = 0
        rdata.other_size = 0
        rdata.mac = mac_list
        rdata.mac_size = len(mac_list)

        r = dns.res_rec()
        r.name = key_name
        r.rr_type = dns.DNS_QTYPE_TSIG
        r.rr_class = dns.DNS_QCLASS_ANY
        r.ttl = 0
        r.length = 0xffff
        r.rdata = rdata

        additional = [r]
        packet.additional = additional
        packet.arcount = 1

    def search_record(self, name):
        p = self.make_name_packet(dns.DNS_OPCODE_QUERY)
        questions = []

        q = self.make_name_question(name, dns.DNS_QTYPE_TXT, dns.DNS_QCLASS_IN)
        questions.append(q)

        self.finish_name_packet(p, questions)
        (response, response_packet) = self.dns_transaction_udp(p, self.server_ip)
        return response.operation & 0x000F

    def make_update_request(self, delete=False):
        "Create a DNS update request"

        rr_class = dns.DNS_QCLASS_IN
        ttl = 900

        if delete:
            rr_class = dns.DNS_QCLASS_NONE
            ttl = 0

        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        q = self.make_name_question(self.get_dns_domain(),
                                    dns.DNS_QTYPE_SOA,
                                    dns.DNS_QCLASS_IN)
        questions = []
        questions.append(q)
        self.finish_name_packet(p, questions)

        updates = []
        r = dns.res_rec()
        r.name = self.newrecname
        r.rr_type = dns.DNS_QTYPE_TXT
        r.rr_class = rr_class
        r.ttl = ttl
        r.length = 0xffff
        rdata = self.make_txt_record(['"This is a test"'])
        r.rdata = rdata
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        return p


class TestDNSUpdates(DNSTest):
    def test_tkey(self):
        "test DNS TKEY handshake"

        self.tkey_trans()

    def test_update_wo_tsig(self):
        "test DNS update without TSIG record"

        p = self.make_update_request()
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_REFUSED)

        rcode = self.search_record(self.newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_NXDOMAIN)

    def test_update_tsig_bad_keyname(self):
        "test DNS update with a TSIG record with a bad keyname"

        self.tkey_trans()

        p = self.make_update_request()
        self.sign_packet(p, "badkey")
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NOTAUTH)
        tsig_record = response.additional[0].rdata
        self.assertEquals(tsig_record.error, dns.DNS_RCODE_BADKEY)
        self.assertEquals(tsig_record.mac_size, 0)

        rcode = self.search_record(self.newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_NXDOMAIN)

    def test_update_tsig_bad_mac(self):
        "test DNS update with a TSIG record with a bad MAC"

        self.tkey_trans()

        p = self.make_update_request()
        self.bad_sign_packet(p, self.key_name)
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_NOTAUTH)
        tsig_record = response.additional[0].rdata
        self.assertEquals(tsig_record.error, dns.DNS_RCODE_BADSIG)
        self.assertEquals(tsig_record.mac_size, 0)

        rcode = self.search_record(self.newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_NXDOMAIN)

    def test_update_tsig(self):
        "test DNS update with correct TSIG record"

        self.tkey_trans()

        p = self.make_update_request()
        mac = self.sign_packet(p, self.key_name)
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.verify_packet(response, response_p, mac)

        # Check the record is around
        rcode = self.search_record(self.newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_OK)

        # Now delete the record
        p = self.make_update_request(delete=True)
        mac = self.sign_packet(p, self.key_name)
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.verify_packet(response, response_p, mac)

        # check it's gone
        rcode = self.search_record(self.newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_NXDOMAIN)

    def test_update_tsig_windows(self):
        "test DNS update with correct TSIG record (follow Windows pattern)"

        newrecname = "win" + self.newrecname
        rr_class = dns.DNS_QCLASS_IN
        ttl = 1200

        p = self.make_name_packet(dns.DNS_OPCODE_UPDATE)
        q = self.make_name_question(self.get_dns_domain(),
                                    dns.DNS_QTYPE_SOA,
                                    dns.DNS_QCLASS_IN)
        questions = []
        questions.append(q)
        self.finish_name_packet(p, questions)

        updates = []
        r = dns.res_rec()
        r.name = newrecname
        r.rr_type = dns.DNS_QTYPE_A
        r.rr_class = dns.DNS_QCLASS_ANY
        r.ttl = 0
        r.length = 0
        updates.append(r)
        r = dns.res_rec()
        r.name = newrecname
        r.rr_type = dns.DNS_QTYPE_AAAA
        r.rr_class = dns.DNS_QCLASS_ANY
        r.ttl = 0
        r.length = 0
        updates.append(r)
        r = dns.res_rec()
        r.name = newrecname
        r.rr_type = dns.DNS_QTYPE_A
        r.rr_class = rr_class
        r.ttl = ttl
        r.length = 0xffff
        r.rdata = "10.1.45.64"
        updates.append(r)
        p.nscount = len(updates)
        p.nsrecs = updates

        prereqs = []
        r = dns.res_rec()
        r.name = newrecname
        r.rr_type = dns.DNS_QTYPE_CNAME
        r.rr_class = dns.DNS_QCLASS_NONE
        r.ttl = 0
        r.length = 0
        prereqs.append(r)
        p.ancount = len(prereqs)
        p.answers = prereqs

        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_REFUSED)

        self.tkey_trans()
        mac = self.sign_packet(p, self.key_name)
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.verify_packet(response, response_p, mac)

        # Check the record is around
        rcode = self.search_record(newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_OK)

        # Now delete the record
        p = self.make_update_request(delete=True)
        mac = self.sign_packet(p, self.key_name)
        (response, response_p) = self.dns_transaction_udp(p, self.server_ip)
        self.assert_dns_rcode_equals(response, dns.DNS_RCODE_OK)
        self.verify_packet(response, response_p, mac)

        # check it's gone
        rcode = self.search_record(self.newrecname)
        self.assert_rcode_equals(rcode, dns.DNS_RCODE_NXDOMAIN)

TestProgram(module=__name__, opts=subunitopts)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2012
#
# Tests for documentation.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for presence of documentation."""

import samba
import samba.tests

import os
import re
import subprocess
import xml.etree.ElementTree as ET

class TestCase(samba.tests.TestCaseInTempDir):

    def _format_message(self, parameters, message):
        parameters = list(parameters)
        parameters = map(str, parameters)
        parameters.sort()
        return message + '\n\n    %s' % ('\n    '.join(parameters))


def get_documented_parameters(sourcedir):
    path = os.path.join(sourcedir, "bin", "default", "docs-xml", "smbdotconf")
    if not os.path.exists(os.path.join(path, "parameters.all.xml")):
        raise Exception("Unable to find parameters.all.xml")
    try:
        p = open(os.path.join(path, "parameters.all.xml"), 'r')
    except IOError, e:
        raise Exception("Error opening parameters file")
    out = p.read()

    root = ET.fromstring(out)
    for parameter in root:
        name = parameter.attrib.get('name')
        if parameter.attrib.get('removed') == "1":
           continue
        yield name
        syn = parameter.findall('synonym')
        if syn is not None:
            for sy in syn:
                yield sy.text
    p.close()


def get_documented_tuples(sourcedir, omit_no_default=True):
    path = os.path.join(sourcedir, "bin", "default", "docs-xml", "smbdotconf")
    if not os.path.exists(os.path.join(path, "parameters.all.xml")):
        raise Exception("Unable to find parameters.all.xml")
    try:
        p = open(os.path.join(path, "parameters.all.xml"), 'r')
    except IOError, e:
        raise Exception("Error opening parameters file")
    out = p.read()

    root = ET.fromstring(out)
    for parameter in root:
        name = parameter.attrib.get("name")
        param_type = parameter.attrib.get("type")
        if parameter.attrib.get('removed') == "1":
           continue
        values = parameter.findall("value")
        defaults = []
        for value in values:
            if value.attrib.get("type") == "default":
                defaults.append(value)

        default_text = None
        if len(defaults) == 0:
            if omit_no_default:
                continue
        elif len(defaults) > 1:
            raise Exception("More than one default found for parameter %s" % name)
        else:
            default_text = defaults[0].text

        if default_text is None:
            default_text = ""
        context = parameter.attrib.get("context")
        yield name, default_text, context, param_type
    p.close()

class SmbDotConfTests(TestCase):

    # defines the cases where the defaults may differ from the documentation
    special_cases = set(['log level', 'path', 'ldapsam:trusted', 'spoolss: architecture',
                         'share:fake_fscaps', 'ldapsam:editposix', 'rpc_daemon:DAEMON',
                         'rpc_server:SERVER', 'panic action', 'homedir map', 'NIS homedir',
                         'server string', 'netbios name', 'socket options', 'use mmap',
                         'ctdbd socket', 'printing', 'printcap name', 'queueresume command',
                         'queuepause command','lpresume command', 'lppause command',
                         'lprm command', 'lpq command', 'print command', 'template homedir',
                         'spoolss: os_major', 'spoolss: os_minor', 'spoolss: os_build',
                         'max open files', 'fss: prune stale', 'fss: sequence timeout',
                         'include system krb5 conf'])

    def setUp(self):
        super(SmbDotConfTests, self).setUp()
        # create a minimal smb.conf file for testparm
        self.smbconf = os.path.join(self.tempdir, "paramtestsmb.conf")
        f = open(self.smbconf, 'w')
        try:
            f.write("""
[test]
   path = /
""")
        finally:
            f.close()

        self.blankconf = os.path.join(self.tempdir, "emptytestsmb.conf")
        f = open(self.blankconf, 'w')
        try:
            f.write("")
        finally:
            f.close()

        self.topdir = os.path.abspath(samba.source_tree_topdir())

        try:
            self.documented = set(get_documented_parameters(self.topdir))
        except:
            self.fail("Unable to load documented parameters")

        try:
            self.defaults = set(get_documented_tuples(self.topdir))
        except:
            self.fail("Unable to load parameters")

        try:
            self.defaults_all = set(get_documented_tuples(self.topdir, False))
        except:
            self.fail("Unable to load parameters")


    def tearDown(self):
        super(SmbDotConfTests, self).tearDown()
        os.unlink(self.smbconf)
        os.unlink(self.blankconf)

    def test_default_s3(self):
        self._test_default(['bin/testparm'])
        self._set_defaults(['bin/testparm'])

        # registry shares appears to need sudo
        self._set_arbitrary(['bin/testparm'],
            exceptions = ['client lanman auth',
                          'client plaintext auth',
                          'registry shares',
                          'smb ports'])
        self._test_empty(['bin/testparm'])

    def test_default_s4(self):
        self._test_default(['bin/samba-tool', 'testparm'])
        self._set_defaults(['bin/samba-tool', 'testparm'])
        self._set_arbitrary(['bin/samba-tool', 'testparm'],
            exceptions = ['smb ports'])
        self._test_empty(['bin/samba-tool', 'testparm'])

    def _test_default(self, program):
        failset = set()
        count = 0

        for tuples in self.defaults:
            param, default, context, param_type = tuples
            if param in self.special_cases:
                continue
            section = None
            if context == "G":
                section = "global"
            elif context == "S":
                section = "test"
            else:
                 self.fail("%s has no valid context" % param)
            p = subprocess.Popen(program + ["-s", self.smbconf,
                    "--section-name", section, "--parameter-name", param],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=self.topdir).communicate()
            if p[0].upper().strip() != default.upper():
                if not (p[0].upper().strip() == "" and default == '""'):
                    doc_triple = "%s\n      Expected: %s" % (param, default)
                    failset.add("%s\n      Got: %s" % (doc_triple, p[0].upper().strip()))

        if len(failset) > 0:
            self.fail(self._format_message(failset,
                "Parameters that do not have matching defaults:"))

    def _set_defaults(self, program):
        failset = set()
        count = 0

        for tuples in self.defaults:
            param, default, context, param_type = tuples

            if param in ['printing']:
                continue

            section = None
            if context == "G":
                section = "global"
            elif context == "S":
                section = "test"
            else:
                 self.fail("%s has no valid context" % param)
            p = subprocess.Popen(program + ["-s", self.smbconf,
                    "--section-name", section, "--parameter-name", param,
                    "--option", "%s = %s" % (param, default)],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=self.topdir).communicate()
            if p[0].upper().strip() != default.upper():
                if not (p[0].upper().strip() == "" and default == '""'):
                    doc_triple = "%s\n      Expected: %s" % (param, default)
                    failset.add("%s\n      Got: %s" % (doc_triple, p[0].upper().strip()))

        if len(failset) > 0:
            self.fail(self._format_message(failset,
                "Parameters that do not have matching defaults:"))

    def _set_arbitrary(self, program, exceptions=None):
        arbitrary = {'string': 'string', 'boolean': 'yes', 'integer': '5',
                     'boolean-rev': 'yes',
                     'cmdlist': 'a b c',
                     'bytes': '10',
                     'octal': '0123',
                     'ustring': 'ustring',
                     'enum':'', 'boolean-auto': '', 'char': 'a', 'list': 'a, b, c'}
        opposite_arbitrary = {'string': 'string2', 'boolean': 'no', 'integer': '6',
                              'boolean-rev': 'no',
                              'cmdlist': 'd e f',
                              'bytes': '11',
                              'octal': '0567',
                              'ustring': 'ustring2',
                              'enum':'', 'boolean-auto': '', 'char': 'b', 'list': 'd, e, f'}

        failset = set()
        count = 0

        for tuples in self.defaults_all:
            param, default, context, param_type = tuples

            if param in ['printing', 'copy', 'include', 'log level']:
                continue

            # currently no easy way to set an arbitrary value for these
            if param_type in ['enum', 'boolean-auto']:
                continue

            if exceptions is not None:
                if param in exceptions:
                    continue

            section = None
            if context == "G":
                section = "global"
            elif context == "S":
                section = "test"
            else:
                 self.fail("%s has no valid context" % param)

            value_to_use = arbitrary.get(param_type)
            if value_to_use is None:
                self.fail("%s has an invalid type" % param)

            p = subprocess.Popen(program + ["-s", self.smbconf,
                    "--section-name", section, "--parameter-name", param,
                    "--option", "%s = %s" % (param, value_to_use)],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=self.topdir).communicate()
            if p[0].upper().strip() != value_to_use.upper():
                # currently no way to distinguish command lists
                if param_type == 'list':
                    if ", ".join(p[0].upper().strip().split()) == value_to_use.upper():
                        continue

                # currently no way to identify octal
                if param_type == 'integer':
                    try:
                        if int(value_to_use, 8) == int(p[0].strip(), 8):
                            continue
                    except:
                        pass

                doc_triple = "%s\n      Expected: %s" % (param, value_to_use)
                failset.add("%s\n      Got: %s" % (doc_triple, p[0].upper().strip()))

            opposite_value = opposite_arbitrary.get(param_type)
            tempconf = os.path.join(self.tempdir, "tempsmb.conf")
            g = open(tempconf, 'w')
            try:
                towrite = section + "\n"
                towrite += param + " = " + opposite_value
                g.write(towrite)
            finally:
                g.close()

            p = subprocess.Popen(program + ["-s", tempconf, "--suppress-prompt",
                    "--option", "%s = %s" % (param, value_to_use)],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=self.topdir).communicate()

            os.unlink(tempconf)

            # testparm doesn't display a value if they are equivalent
            if (value_to_use.lower() != opposite_value.lower()):
                for line in p[0].splitlines():
                    if not line.strip().startswith(param):
                        continue

                    value_found = line.split("=")[1].upper().strip()
                    if value_found != value_to_use.upper():
                        # currently no way to distinguish command lists
                        if param_type == 'list':
                            if ", ".join(value_found.split()) == value_to_use.upper():
                                continue

                        # currently no way to identify octal
                        if param_type == 'integer':
                            try:
                                if int(value_to_use, 8) == int(value_found, 8):
                                    continue
                            except:
                                pass

                        doc_triple = "%s\n      Expected: %s" % (param, value_to_use)
                        failset.add("%s\n      Got: %s" % (doc_triple, value_found))


        if len(failset) > 0:
            self.fail(self._format_message(failset,
                "Parameters that were unexpectedly not set:"))

    def _test_empty(self, program):
        p = subprocess.Popen(program + ["-s", self.blankconf, "--suppress-prompt"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=self.topdir).communicate()
        output = ""

        for line in p[0].splitlines():
            if line.strip().startswith('#'):
                continue
            if line.strip().startswith("idmap config *"):
                continue
            output += line.strip().lower() + '\n'

        if output.strip() != '[global]' and output.strip() != '[globals]':
            self.fail("Testparm returned unexpected output on an empty smb.conf.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Unix SMB/CIFS implementation. Tests for dsdb
# Copyright (C) Matthieu Patou <mat@matws.net> 2010
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.dsdb."""

from samba.credentials import Credentials
from samba.samdb import SamDB
from samba.auth import system_session
from samba.tests import TestCase
from samba.ndr import ndr_unpack, ndr_pack
from samba.dcerpc import drsblobs
import ldb
import os
import samba


class DsdbTests(TestCase):

    def setUp(self):
        super(DsdbTests, self).setUp()
        self.lp = samba.param.LoadParm()
        self.lp.load(os.path.join(os.path.join(self.baseprovpath(), "etc"), "smb.conf"))
        self.creds = Credentials()
        self.creds.guess(self.lp)
        self.session = system_session()
        self.samdb = SamDB(os.path.join(self.baseprovpath(), "private", "sam.ldb"),
            session_info=self.session, credentials=self.creds,lp=self.lp)

    def baseprovpath(self):
        return os.path.join(os.environ['SELFTEST_PREFIX'], "ad_dc_ntvfs")

    def test_get_oid_from_attrid(self):
        oid = self.samdb.get_oid_from_attid(591614)
        self.assertEquals(oid, "1.2.840.113556.1.4.1790")

    def test_error_replpropertymetadata(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["replPropertyMetaData"])
        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        ctr = repl.ctr
        for o in ctr.array:
            # Search for Description
            if o.attid == 13:
                old_version = o.version
                o.version = o.version + 1
        replBlob = ndr_pack(repl)
        msg = ldb.Message()
        msg.dn = res[0].dn
        msg["replPropertyMetaData"] = ldb.MessageElement(replBlob, ldb.FLAG_MOD_REPLACE, "replPropertyMetaData")
        self.assertRaises(ldb.LdbError, self.samdb.modify, msg, ["local_oid:1.3.6.1.4.1.7165.4.3.14:0"])

    def test_error_replpropertymetadata_nochange(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["replPropertyMetaData"])
        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        replBlob = ndr_pack(repl)
        msg = ldb.Message()
        msg.dn = res[0].dn
        msg["replPropertyMetaData"] = ldb.MessageElement(replBlob, ldb.FLAG_MOD_REPLACE, "replPropertyMetaData")
        self.assertRaises(ldb.LdbError, self.samdb.modify, msg, ["local_oid:1.3.6.1.4.1.7165.4.3.14:0"])

    def test_error_replpropertymetadata_allow_sort(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["replPropertyMetaData"])
        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        replBlob = ndr_pack(repl)
        msg = ldb.Message()
        msg.dn = res[0].dn
        msg["replPropertyMetaData"] = ldb.MessageElement(replBlob, ldb.FLAG_MOD_REPLACE, "replPropertyMetaData")
        self.samdb.modify(msg, ["local_oid:1.3.6.1.4.1.7165.4.3.14:0", "local_oid:1.3.6.1.4.1.7165.4.3.25:0"])

    def test_twoatt_replpropertymetadata(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["replPropertyMetaData", "uSNChanged"])
        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        ctr = repl.ctr
        for o in ctr.array:
            # Search for Description
            if o.attid == 13:
                old_version = o.version
                o.version = o.version + 1
                o.local_usn = long(str(res[0]["uSNChanged"])) + 1
        replBlob = ndr_pack(repl)
        msg = ldb.Message()
        msg.dn = res[0].dn
        msg["replPropertyMetaData"] = ldb.MessageElement(replBlob, ldb.FLAG_MOD_REPLACE, "replPropertyMetaData")
        msg["description"] = ldb.MessageElement("new val", ldb.FLAG_MOD_REPLACE, "description")
        self.assertRaises(ldb.LdbError, self.samdb.modify, msg, ["local_oid:1.3.6.1.4.1.7165.4.3.14:0"])

    def test_set_replpropertymetadata(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["replPropertyMetaData", "uSNChanged"])
        repl = ndr_unpack(drsblobs.replPropertyMetaDataBlob,
                            str(res[0]["replPropertyMetaData"]))
        ctr = repl.ctr
        for o in ctr.array:
            # Search for Description
            if o.attid == 13:
                old_version = o.version
                o.version = o.version + 1
                o.local_usn = long(str(res[0]["uSNChanged"])) + 1
                o.originating_usn = long(str(res[0]["uSNChanged"])) + 1
        replBlob = ndr_pack(repl)
        msg = ldb.Message()
        msg.dn = res[0].dn
        msg["replPropertyMetaData"] = ldb.MessageElement(replBlob, ldb.FLAG_MOD_REPLACE, "replPropertyMetaData")
        self.samdb.modify(msg, ["local_oid:1.3.6.1.4.1.7165.4.3.14:0"])

    def test_ok_get_attribute_from_attid(self):
        self.assertEquals(self.samdb.get_attribute_from_attid(13), "description")

    def test_ko_get_attribute_from_attid(self):
        self.assertEquals(self.samdb.get_attribute_from_attid(11979), None)

    def test_get_attribute_replmetadata_version(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["dn"])
        self.assertEquals(len(res), 1)
        dn = str(res[0].dn)
        self.assertEqual(self.samdb.get_attribute_replmetadata_version(dn, "unicodePwd"), 1)

    def test_set_attribute_replmetadata_version(self):
        res = self.samdb.search(expression="cn=Administrator",
                            scope=ldb.SCOPE_SUBTREE,
                            attrs=["dn"])
        self.assertEquals(len(res), 1)
        dn = str(res[0].dn)
        version = self.samdb.get_attribute_replmetadata_version(dn, "description")
        self.samdb.set_attribute_replmetadata_version(dn, "description", version + 2)
        self.assertEqual(self.samdb.get_attribute_replmetadata_version(dn, "description"), version + 2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2009
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for GENSEC.

Note that this just tests the bindings work. It does not intend to test
the functionality, that's already done in other tests.
"""

from samba.credentials import Credentials
from samba import gensec, auth
import samba.tests

class GensecTests(samba.tests.TestCase):

    def setUp(self):
        super(GensecTests, self).setUp()
        self.settings = {}
        self.settings["lp_ctx"] = self.lp_ctx = samba.tests.env_loadparm()
        self.settings["target_hostname"] = self.lp_ctx.get("netbios name")
        """This is just for the API tests"""
        self.gensec = gensec.Security.start_client(self.settings)

    def test_start_mech_by_unknown_name(self):
        self.assertRaises(RuntimeError, self.gensec.start_mech_by_name, "foo")

    def test_start_mech_by_name(self):
        self.gensec.start_mech_by_name("spnego")

    def test_info_uninitialized(self):
        self.assertRaises(RuntimeError, self.gensec.session_info)

    def test_update(self):
        """Test GENSEC by doing an exchange with ourselves using GSSAPI against a KDC"""

        """Start up a client and server GENSEC instance to test things with"""

        self.gensec_client = gensec.Security.start_client(self.settings)
        self.gensec_client.set_credentials(self.get_credentials())
        self.gensec_client.want_feature(gensec.FEATURE_SEAL)
        self.gensec_client.start_mech_by_sasl_name("GSSAPI")

        self.gensec_server = gensec.Security.start_server(settings=self.settings,
                                                          auth_context=auth.AuthContext(lp_ctx=self.lp_ctx))
        creds = Credentials()
        creds.guess(self.lp_ctx)
        creds.set_machine_account(self.lp_ctx)
        self.gensec_server.set_credentials(creds)

        self.gensec_server.want_feature(gensec.FEATURE_SEAL)
        self.gensec_server.start_mech_by_sasl_name("GSSAPI")

        client_finished = False
        server_finished = False
        server_to_client = ""

        """Run the actual call loop"""
        while not client_finished and not server_finished:
            if not client_finished:
                print "running client gensec_update"
                (client_finished, client_to_server) = self.gensec_client.update(server_to_client)
            if not server_finished:
                print "running server gensec_update"
                (server_finished, server_to_client) = self.gensec_server.update(client_to_server)
        session_info = self.gensec_server.session_info()

        test_string = "Hello Server"
        test_wrapped = self.gensec_client.wrap(test_string)
        test_unwrapped = self.gensec_server.unwrap(test_wrapped)
        self.assertEqual(test_string, test_unwrapped)
        test_string = "Hello Client"
        test_wrapped = self.gensec_server.wrap(test_string)
        test_unwrapped = self.gensec_client.unwrap(test_wrapped)
        self.assertEqual(test_string, test_unwrapped)

        client_session_key = self.gensec_client.session_key()
        server_session_key = self.gensec_server.session_key()
        self.assertEqual(client_session_key, server_session_key)

    def test_max_update_size(self):
        """Test GENSEC by doing an exchange with ourselves using GSSAPI against a KDC"""

        """Start up a client and server GENSEC instance to test things with"""

        self.gensec_client = gensec.Security.start_client(self.settings)
        self.gensec_client.set_credentials(self.get_credentials())
        self.gensec_client.want_feature(gensec.FEATURE_SIGN)
        self.gensec_client.set_max_update_size(5)
        self.gensec_client.start_mech_by_name("spnego")

        self.gensec_server = gensec.Security.start_server(settings=self.settings,
                                                          auth_context=auth.AuthContext(lp_ctx=self.lp_ctx))
        creds = Credentials()
        creds.guess(self.lp_ctx)
        creds.set_machine_account(self.lp_ctx)
        self.gensec_server.set_credentials(creds)
        self.gensec_server.want_feature(gensec.FEATURE_SIGN)
        self.gensec_server.set_max_update_size(5)
        self.gensec_server.start_mech_by_name("spnego")

        client_finished = False
        server_finished = False
        server_to_client = ""

        """Run the actual call loop"""
        i = 0
        while not client_finished or not server_finished:
            i += 1
            if not client_finished:
                print "running client gensec_update: %d: %r" % (len(server_to_client), server_to_client)
                (client_finished, client_to_server) = self.gensec_client.update(server_to_client)
            if not server_finished:
                print "running server gensec_update: %d: %r" % (len(client_to_server), client_to_server)
                (server_finished, server_to_client) = self.gensec_server.update(client_to_server)

        """Here we expect a lot more than the typical 1 or 2 roundtrips"""
        self.assertTrue(i > 10)

        session_info = self.gensec_server.session_info()

        test_string = "Hello Server"
        test_wrapped = self.gensec_client.wrap(test_string)
        test_unwrapped = self.gensec_server.unwrap(test_wrapped)
        self.assertEqual(test_string, test_unwrapped)
        test_string = "Hello Client"
        test_wrapped = self.gensec_server.wrap(test_string)
        test_unwrapped = self.gensec_client.unwrap(test_wrapped)
        self.assertEqual(test_string, test_unwrapped)

        client_session_key = self.gensec_client.session_key()
        server_session_key = self.gensec_server.session_key()
        self.assertEqual(client_session_key, server_session_key)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for option parsing.

"""

import optparse
from samba.getopt import (
    AUTO_USE_KERBEROS,
    DONT_USE_KERBEROS,
    MUST_USE_KERBEROS,
    parse_kerberos_arg,
    )
import samba.tests

class KerberosOptionTests(samba.tests.TestCase):

    def test_parse_true(self):
        self.assertEquals(
            MUST_USE_KERBEROS, parse_kerberos_arg("yes", "--kerberos"))
        self.assertEquals(
            MUST_USE_KERBEROS, parse_kerberos_arg("true", "--kerberos"))
        self.assertEquals(
            MUST_USE_KERBEROS, parse_kerberos_arg("1", "--kerberos"))

    def test_parse_false(self):
        self.assertEquals(
            DONT_USE_KERBEROS, parse_kerberos_arg("no", "--kerberos"))
        self.assertEquals(
            DONT_USE_KERBEROS, parse_kerberos_arg("false", "--kerberos"))
        self.assertEquals(
            DONT_USE_KERBEROS, parse_kerberos_arg("0", "--kerberos"))

    def test_parse_auto(self):
        self.assertEquals(
            AUTO_USE_KERBEROS, parse_kerberos_arg("auto", "--kerberos"))

    def test_parse_invalid(self):
        self.assertRaises(optparse.OptionValueError,
            parse_kerberos_arg, "blah?", "--kerberos")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # Unix SMB/CIFS implementation. Tests for shares
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2009
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.hostconfig."""

from samba.hostconfig import SharesContainer
from samba.tests import TestCase


class MockService(object):

    def __init__(self, data):
        self.data = data

    def __getitem__(self, name):
        return self.data[name]


class MockLoadParm(object):

    def __init__(self, data):
        self.data = data

    def __getitem__(self, name):
        return MockService(self.data[name])

    def __len__(self):
        return len(self.data)

    def services(self):
        return self.data.keys()


class ShareTests(TestCase):

    def _get_shares(self, conf):
        return SharesContainer(MockLoadParm(conf))

    def test_len_no_global(self):
        shares = self._get_shares({})
        self.assertEquals(0, len(shares))

    def test_iter(self):
        self.assertEquals([], list(self._get_shares({})))
        self.assertEquals([], list(self._get_shares({"global":{}})))
        self.assertEquals(
            ["bla"],
            list(self._get_shares({"global":{}, "bla":{}})))

    def test_len(self):
        shares = self._get_shares({"global": {}})
        self.assertEquals(0, len(shares))

    def test_getitem_nonexistent(self):
        shares = self._get_shares({"global": {}})
        self.assertRaises(KeyError, shares.__getitem__, "bla")

    def test_getitem_global(self):
        shares = self._get_shares({"global": {}})
        self.assertRaises(KeyError, shares.__getitem__, "global")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Unix SMB/CIFS implementation. Tests for samba.kcc core.
# Copyright (C) Andrew Bartlett 2015
#
# Written by Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.kcc"""

import samba
import os
import time
from tempfile import mkdtemp

import samba.tests
from samba import kcc
from samba import ldb
from samba.dcerpc import misc


from samba.param import LoadParm
from samba.credentials import Credentials
from samba.samdb import SamDB

unix_now = int(time.time())
unix_once_upon_a_time = 1000000000 #2001-09-09

ENV_DSAS = {
    'ad_dc_ntvfs' : ['CN=LOCALDC,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba,DC=example,DC=com'],
    'fl2000dc': ['CN=DC5,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba2000,DC=example,DC=com'],
    'fl2003dc': ['CN=DC6,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba2003,DC=example,DC=com'],
    'fl2008r2dc': ['CN=DC7,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba2008r2,DC=example,DC=com'],
    'promoted_dc': ['CN=PROMOTEDVDC,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba,DC=example,DC=com',
                    'CN=LOCALDC,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba,DC=example,DC=com'],
    'vampire_dc': ['CN=LOCALDC,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba,DC=example,DC=com',
                   'CN=LOCALVAMPIREDC,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=samba,DC=example,DC=com'],
}

class KCCTests(samba.tests.TestCase):
    def setUp(self):
        super(KCCTests, self).setUp()
        self.lp = LoadParm()
        self.creds = Credentials()
        self.creds.guess(self.lp)
        self.creds.set_username(os.environ["USERNAME"])
        self.creds.set_password(os.environ["PASSWORD"])


    def test_list_dsas(self):
        my_kcc = kcc.KCC(unix_now, False, False, False, False)
        my_kcc.load_samdb("ldap://%s" % os.environ["SERVER"],
                          self.lp, self.creds)
        dsas = my_kcc.list_dsas()
        env = os.environ['TEST_ENV']
        for expected_dsa in ENV_DSAS[env]:
            self.assertIn(expected_dsa, dsas)

    def test_verify(self):
        """check that the KCC generates graphs that pass its own verify
        option. This is not a spectacular acheivement when there are
        only a couple of nodes to connect, but it shows something.
        """
        my_kcc = kcc.KCC(unix_now, readonly=True, verify=True,
                         debug=False, dot_file_dir=None)

        my_kcc.run("ldap://%s" % os.environ["SERVER"],
                   self.lp, self.creds,
                   attempt_live_connections=False)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Unix SMB/CIFS implementation. Tests for kcc.graph routines
# Copyright (C) Andrew Bartlett 2015
#
# Written by Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.kcc.graph"""

import samba
import samba.tests
from samba.kcc.graph import *

import itertools


def ntdsconn_schedule(times):
    if times is None:
        return None
    from samba.dcerpc import drsblobs
    schedule = drsblobs.schedule()
    schedule.size = 188
    schedule.bandwidth = 0
    schedule.numberOfSchedules = 1
    header = drsblobs.scheduleHeader()
    header.type = 0
    header.offset = 20
    schedule.headerArray = [header]
    data = drsblobs.scheduleSlots()
    data.slots = times
    schedule.dataArray = [data]
    return schedule


class GraphFunctionTests(samba.tests.TestCase):

    def test_total_schedule(self):
        schedule = [0x81] * 84
        for schedule, total in (
                ([0x81] * 84, 168),
                ([0xff] * 84, 84 * 8),
                ([0xaa] * 84, 84 * 4),
                ([0x03, 0x33] * 42, 42 * 6),
                (range(7) * 12, 12 * 9),
                (range(4) * 21, 21 * 4)):
            self.assertEquals(total_schedule(schedule), total)

    def test_convert_schedule_to_repltimes(self):
        for ntdsconn_times, repltimes in (
                ([0x01] * 168, [0x11] * 84),
                (None, [0x11] * 84),
                ([0x06] * 168, [0x66] * 84),
                ([0x03, 0xa] * 84, [0x3a] * 84),
                (range(7) * 24,
                 [0x01, 0x23, 0x45, 0x60, 0x12, 0x34, 0x56] * 12)):
            schedule = ntdsconn_schedule(ntdsconn_times)
            self.assertEquals(convert_schedule_to_repltimes(schedule),
                              repltimes)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Unix SMB/CIFS implementation. Tests for kcc.graph_utils routines
# Copyright (C) Andrew Bartlett 2015
#
# Written by Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.kcc.graph_utils"""

import samba
import samba.tests
from samba.kcc.graph_utils import *

import itertools


def make_tree(vertices):
    if len(vertices) < 2:
        return ()
    remaining = set(vertices)
    used = set()
    edges = set()
    used.add(remaining.pop())
    used.add(remaining.pop())
    edges.add(tuple(used))
    while remaining:
        v = remaining.pop()
        w = used.pop()
        e = (w, v)
        edges.add(e)
        used.update(e)
    return tuple(edges)

# TODO: test directed graphs


class UndirectedGraphTests(samba.tests.TestCase):

    def setUp(self):
        super(UndirectedGraphTests, self).setUp()
        vertices = tuple('abcdefgh')
        vertices2 = tuple('ijk')
        edges = tuple(itertools.combinations(vertices, 2))
        edges2 = tuple(itertools.combinations(vertices2, 2))
        line_edges = zip(vertices[1:], vertices[:-1])
        ring_edges = line_edges + [(vertices[0], vertices[-1])]

        tree = make_tree(vertices)
        tree2 = make_tree(vertices2)

        self.complete_graph = [edges, vertices, vertices]

        self.disconnected_clusters = [edges + edges2,
                                      vertices + vertices2,
                                      vertices + vertices2]

        self.graph_with_unreachables = [edges,
                                        vertices + vertices2,
                                        vertices]

        self.ring = [ring_edges, vertices, vertices]
        self.line = [line_edges, vertices, vertices]

        self.tree = [tree, vertices, vertices]
        self.forest = [tree + tree2,
                       vertices + vertices2,
                       vertices + vertices2]

        self.unconnected_graph = ((), vertices, ())

    def assertGraphError(self, fn, *args):
        return self.assertRaises(GraphError, fn, *args)

    def test_graph_complete(self):
        fn = verify_graph_complete

        self.assertGraphError(fn, *self.disconnected_clusters)
        self.assertGraphError(fn, *self.graph_with_unreachables)
        self.assertGraphError(fn, *self.ring)
        self.assertGraphError(fn, *self.tree)

        self.assertIsNone(fn(*self.complete_graph))

    def test_graph_connected(self):
        fn = verify_graph_connected

        self.assertGraphError(fn, *self.disconnected_clusters)
        self.assertGraphError(fn, *self.graph_with_unreachables)
        self.assertGraphError(fn, *self.forest)
        self.assertGraphError(fn, *self.unconnected_graph)

        self.assertIsNone(fn(*self.line))
        self.assertIsNone(fn(*self.ring))
        self.assertIsNone(fn(*self.complete_graph))
        self.assertIsNone(fn(*self.tree))

    def test_graph_forest(self):
        fn = verify_graph_forest

        self.assertGraphError(fn, *self.disconnected_clusters)
        self.assertGraphError(fn, *self.graph_with_unreachables)
        self.assertGraphError(fn, *self.ring)

        self.assertIsNone(fn(*self.line))
        self.assertIsNone(fn(*self.tree))
        self.assertIsNone(fn(*self.forest))
        self.assertIsNone(fn(*self.unconnected_graph))

    def test_graph_connected_under_edge_failures(self):
        fn = verify_graph_connected_under_edge_failures

        self.assertGraphError(fn, *self.line)
        self.assertGraphError(fn, *self.tree)
        self.assertGraphError(fn, *self.forest)
        self.assertGraphError(fn, *self.disconnected_clusters)

        self.assertIsNone(fn(*self.ring))
        self.assertIsNone(fn(*self.complete_graph))

    def test_graph_connected_under_vertex_failures(self):
        #XXX no tests to distinguish this from the edge_failures case
        fn = verify_graph_connected_under_vertex_failures

        self.assertGraphError(fn, *self.line)
        self.assertGraphError(fn, *self.tree)
        self.assertGraphError(fn, *self.forest)
        self.assertGraphError(fn, *self.disconnected_clusters)

        self.assertIsNone(fn(*self.ring))
        self.assertIsNone(fn(*self.complete_graph))

    def test_graph_multi_edge_forest(self):
        pass

    def test_graph_no_lonely_vertices(self):
        fn = verify_graph_no_lonely_vertices
        self.assertGraphError(fn, *self.unconnected_graph)
        self.assertGraphError(fn, *self.graph_with_unreachables)

        self.assertIsNone(fn(*self.ring))
        self.assertIsNone(fn(*self.complete_graph))
        self.assertIsNone(fn(*self.line))
        self.assertIsNone(fn(*self.tree))
        self.assertIsNone(fn(*self.forest))

    def test_graph_no_unknown_vertices(self):
        pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Unix SMB/CIFS implementation. Tests for samba.kcc.kcc_utils.
# Copyright (C) Andrew Bartlett 2015
#
# Written by Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.kcc.kcc_utils"""
import samba
import samba.tests
from samba.kcc.kcc_utils import *


class ScheduleTests(samba.tests.TestCase):

    def test_new_connection_schedule(self):
        schedule = new_connection_schedule()
        self.assertIsInstance(schedule, drsblobs.schedule)
        self.assertEquals(schedule.size, 188)
        self.assertEquals(len(schedule.dataArray[0].slots), 168)


# OK, this is pathetic, but the rest of it looks really hard, with the
# classes all intertwingled with each other and the samdb. That is to say:
# XXX later.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Unix SMB/CIFS implementation. Tests for samba.kcc.ldif_import_export.
# Copyright (C) Andrew Bartlett 2015
#
# Written by Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.kcc.ldif_import_export"""

import samba
import os
import time
import shutil
import sys
import subprocess
import logging
import samba.tests
from samba.kcc import ldif_import_export, KCC
from samba import ldb
from samba.dcerpc import misc


from samba.param import LoadParm
from samba.credentials import Credentials
from samba.samdb import SamDB

unix_now = int(time.time())

MULTISITE_LDIF = os.path.join(os.environ['SRCDIR_ABS'],
                              "testdata/ldif-utils-test-multisite.ldif")

MULTISITE_LDIF_DSAS = (
    ("CN=WIN08,CN=Servers,CN=Site-4,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-4"),
    ("CN=WIN07,CN=Servers,CN=Site-4,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-4"),
    ("CN=WIN06,CN=Servers,CN=Site-3,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-3"),
    ("CN=WIN09,CN=Servers,CN=Site-5,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-5"),
    ("CN=WIN10,CN=Servers,CN=Site-5,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-5"),
    ("CN=WIN02,CN=Servers,CN=Site-2,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-2"),
    ("CN=WIN04,CN=Servers,CN=Site-2,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-2"),
    ("CN=WIN03,CN=Servers,CN=Site-2,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-2"),
    ("CN=WIN05,CN=Servers,CN=Site-2,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Site-2"),
    ("CN=WIN01,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=ad,DC=samba,DC=example,DC=com",
     "Default-First-Site-Name"),
)


class LdifImportExportTests(samba.tests.TestCaseInTempDir):
    def setUp(self):
        super(LdifImportExportTests, self).setUp()
        self.lp = LoadParm()
        self.creds = Credentials()
        self.creds.guess(self.lp)

    def remove_files(self, *files):
        for f in files:
            assert(f.startswith(self.tempdir))
            os.unlink(f)

    def test_write_search_url(self):
        pass

    def test_ldif_to_samdb(self):
        dburl = os.path.join(self.tempdir, "ldap")
        samdb = ldif_import_export.ldif_to_samdb(dburl, self.lp,
                                                 MULTISITE_LDIF)
        self.assertIsInstance(samdb, SamDB)

        dsa = ("CN=WIN01,CN=Servers,CN=Default-First-Site-Name,CN=Sites,"
               "CN=Configuration,DC=ad,DC=samba,DC=example,DC=com")
        res = samdb.search(ldb.Dn(samdb, "CN=NTDS Settings," + dsa),
                           scope=ldb.SCOPE_BASE, attrs=["objectGUID"])

        ntds_guid = misc.GUID(samdb.get_ntds_GUID())
        self.assertEqual(misc.GUID(res[0]["objectGUID"][0]), ntds_guid)

        service_name_res = samdb.search(base="",
                                        scope=ldb.SCOPE_BASE,
                                        attrs=["dsServiceName"])
        dn = ldb.Dn(samdb,
                    service_name_res[0]["dsServiceName"][0])
        self.assertEqual(dn, ldb.Dn(samdb, "CN=NTDS Settings," + dsa))
        self.remove_files(dburl)

    def test_ldif_to_samdb_forced_local_dsa(self):
        for dsa, site in MULTISITE_LDIF_DSAS:
            dburl = os.path.join(self.tempdir, "ldif-to-samba-forced-local-dsa"
                                 "-%s" % dsa)
            samdb = ldif_import_export.ldif_to_samdb(dburl, self.lp,
                                                     MULTISITE_LDIF,
                                                     forced_local_dsa=dsa)
            self.assertIsInstance(samdb, SamDB)
            self.assertEqual(samdb.server_site_name(), site)

            res = samdb.search(ldb.Dn(samdb, "CN=NTDS Settings," + dsa),
                               scope=ldb.SCOPE_BASE, attrs=["objectGUID"])

            ntds_guid = misc.GUID(samdb.get_ntds_GUID())
            self.assertEqual(misc.GUID(res[0]["objectGUID"][0]), ntds_guid)

            service_name_res = samdb.search(base="",
                                            scope=ldb.SCOPE_BASE,
                                            attrs=["dsServiceName"])
            dn = ldb.Dn(samdb,
                        service_name_res[0]["dsServiceName"][0])
            self.assertEqual(dn, ldb.Dn(samdb, "CN=NTDS Settings," + dsa))
            self.remove_files(dburl)


    def test_samdb_to_ldif_file(self):
        dburl = os.path.join(self.tempdir, "ldap")
        dburl2 = os.path.join(self.tempdir, "ldap_roundtrip")
        ldif_file = os.path.join(self.tempdir, "ldif")
        samdb = ldif_import_export.ldif_to_samdb(dburl, self.lp,
                                                 MULTISITE_LDIF)
        self.assertIsInstance(samdb, SamDB)
        ldif_import_export.samdb_to_ldif_file(samdb, dburl,
                                              lp=self.lp, creds=None,
                                              ldif_file=ldif_file)
        self.assertGreater(os.path.getsize(ldif_file), 1000,
                           "LDIF should be larger than 1000 bytes")
        samdb = ldif_import_export.ldif_to_samdb(dburl2, self.lp,
                                                 ldif_file)
        self.assertIsInstance(samdb, SamDB)
        dsa = ("CN=WIN01,CN=Servers,CN=Default-First-Site-Name,CN=Sites,"
               "CN=Configuration,DC=ad,DC=samba,DC=example,DC=com")
        res = samdb.search(ldb.Dn(samdb, "CN=NTDS Settings," + dsa),
                           scope=ldb.SCOPE_BASE, attrs=["objectGUID"])
        self.remove_files(dburl)
        self.remove_files(dburl2)
        self.remove_files(ldif_file)


class KCCMultisiteLdifTests(samba.tests.TestCaseInTempDir):
    def setUp(self):
        super(KCCMultisiteLdifTests, self).setUp()
        self.lp = LoadParm()
        self.creds = Credentials()
        self.creds.guess(self.lp)

    def remove_files(self, *files):
        for f in files:
            assert(f.startswith(self.tempdir))
            os.unlink(f)

    def _get_kcc(self, name, readonly=False, verify=False, dot_file_dir=None):
        # Note that setting read-only to False won't affect the ldif,
        # only the temporary database that is created from it.
        my_kcc = KCC(unix_now, readonly=readonly, verify=verify,
                     dot_file_dir=dot_file_dir)
        tmpdb = os.path.join(self.tempdir, 'tmpdb')
        my_kcc.import_ldif(tmpdb, self.lp, MULTISITE_LDIF)
        self.remove_files(tmpdb)
        return my_kcc

    def test_list_dsas(self):
        my_kcc = self._get_kcc('test-list')
        dsas = set(my_kcc.list_dsas())
        expected_dsas = set(x[0] for x in MULTISITE_LDIF_DSAS)
        self.assertEqual(dsas, expected_dsas)

    def test_verify(self):
        """Check that the KCC generates graphs that pass its own verify
        option.
        """
        my_kcc = self._get_kcc('test-verify', verify=True)
        tmpdb = os.path.join(self.tempdir, 'verify-tmpdb')
        my_kcc.import_ldif(tmpdb, self.lp, MULTISITE_LDIF)

        my_kcc.run(None,
                   self.lp, self.creds,
                   attempt_live_connections=False)
        self.remove_files(tmpdb)

    def test_dotfiles(self):
        """Check that KCC writes dot_files when asked.
        """
        my_kcc = self._get_kcc('test-dotfiles', dot_file_dir=self.tempdir)
        tmpdb = os.path.join(self.tempdir, 'dotfile-tmpdb')
        files = [tmpdb]
        my_kcc.import_ldif(tmpdb, self.lp, MULTISITE_LDIF)
        my_kcc.run(None,
                   self.lp, self.creds,
                   attempt_live_connections=False)

        dot = '/usr/bin/dot'
        for fn in os.listdir(self.tempdir):
            if fn.endswith('.dot'):
                ffn = os.path.join(self.tempdir, fn)
                if os.path.exists(dot) and subprocess.call([dot, '-?']) == 0:
                    r = subprocess.call([dot, '-Tcanon', ffn])
                    self.assertEqual(r, 0)

                #even if dot is not there, at least check the file is non-empty
                size = os.stat(ffn).st_size
                self.assertNotEqual(size, 0)
                files.append(ffn)

        self.remove_files(*files)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Unix SMB/CIFS implementation.
# Copyright Volker Lendecke <vl@samba.org> 2012
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.samba3.libsmb_samba_internal."""

from samba.samba3 import libsmb_samba_internal
from samba.dcerpc import security
from samba.samba3 import param as s3param
from samba import credentials
import samba.tests
import threading
import sys
import os

class LibsmbTestCase(samba.tests.TestCase):

    class OpenClose(threading.Thread):

        def __init__(self, conn, filename, num_ops):
            threading.Thread.__init__(self)
            self.conn = conn
            self.filename = filename
            self.num_ops = num_ops
            self.exc = False

        def run(self):
            c = self.conn
            try:
                for i in range(self.num_ops):
                    f = c.create(self.filename, CreateDisposition=3,
                                 DesiredAccess=security.SEC_STD_DELETE)
                    c.delete_on_close(f, True)
                    c.close(f)
            except Exception:
                self.exc = sys.exc_info()

    def test_OpenClose(self):

        lp = s3param.get_context()
        lp.load(os.getenv("SMB_CONF_PATH"))

        creds = credentials.Credentials()
        creds.set_username(os.getenv("USERNAME"))
        creds.set_password(os.getenv("PASSWORD"))

        c = libsmb_samba_internal.Conn(os.getenv("SERVER_IP"), "tmp", creds)

        mythreads = []

        for i in range(3):
            t = LibsmbTestCase.OpenClose(c, "test" + str(i), 10)
            mythreads.append(t)

        for t in mythreads:
            t.start()

        for t in mythreads:
            t.join()
            if t.exc:
                raise t.exc[0](t.exc[1])

if __name__ == "__main__":
    import unittest
    unittest.main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # -*- coding: utf-8 -*-
#
# Unix SMB/CIFS implementation.
# Copyright  Jelmer Vernooij <jelmer@samba.org> 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.messaging."""
import samba
from samba.messaging import Messaging
from samba.tests import TestCase
from samba.dcerpc.server_id import server_id

class MessagingTests(TestCase):

    def get_context(self, *args, **kwargs):
        kwargs['lp_ctx'] = samba.tests.env_loadparm()
        return Messaging(*args, **kwargs)

    def test_register(self):
        x = self.get_context()
        def callback():
            pass
        msg_type = x.register(callback)
        x.deregister(callback, msg_type)

    def test_all_servers(self):
        x = self.get_context()
        self.assertTrue(isinstance(x.irpc_all_servers(), list))

    def test_by_name(self):
        x = self.get_context()
        for name in x.irpc_all_servers():
            self.assertTrue(isinstance(x.irpc_servers_byname(name.name), list))

    def test_assign_server_id(self):
        x = self.get_context()
        self.assertTrue(isinstance(x.server_id, server_id))

    def test_ping_speed(self):
        server_ctx = self.get_context((0, 1))
        def ping_callback(src, data):
                server_ctx.send(src, data)
        def exit_callback():
                print "received exit"
        msg_ping = server_ctx.register(ping_callback)
        msg_exit = server_ctx.register(exit_callback)

        def pong_callback():
                print "received pong"
        client_ctx = self.get_context((0, 2))
        msg_pong = client_ctx.register(pong_callback)

        client_ctx.send((0, 1), msg_ping, "testing")
        client_ctx.send((0, 1), msg_ping, "")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2009-2011
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.netcmd."""

from cStringIO import StringIO
from samba.netcmd import Command
from samba.netcmd.testparm import cmd_testparm
from samba.netcmd.main import cmd_sambatool
import samba.tests

class NetCmdTestCase(samba.tests.TestCase):

    def run_netcmd(self, cmd_klass, args, retcode=0):
        cmd = cmd_klass(outf=StringIO(), errf=StringIO())
        try:
            retval = cmd._run(cmd_klass.__name__, *args)
        except Exception, e:
            cmd.show_command_error(e)
            retval = 1
        self.assertEquals(retcode, retval)
        return cmd.outf.getvalue(), cmd.errf.getvalue()

    def iter_all_subcommands(self):
        todo = []
        todo.extend(cmd_sambatool.subcommands.items())
        while todo:
            (path, cmd) = todo.pop()
            yield path, cmd
            subcmds = getattr(cmd, "subcommands", {})
            todo.extend([(path + " " + k, v) for (k, v) in
                subcmds.iteritems()])


class TestParmTests(NetCmdTestCase):

    def test_no_client_ip(self):
        out, err = self.run_netcmd(cmd_testparm, ["--client-name=foo"],
            retcode=-1)
        self.assertEquals("", out)
        self.assertEquals(
            "ERROR: Both a DNS name and an IP address are "
            "required for the host access check\n", err)


class CommandTests(NetCmdTestCase):

    def test_description(self):
        class cmd_foo(Command):
            """Mydescription"""
        self.assertEquals("Mydescription", cmd_foo().short_description)

    def test_name(self):
        class cmd_foo(Command):
            pass
        self.assertEquals("foo", cmd_foo().name)

    def test_synopsis_everywhere(self):
        missing = []
        for path, cmd in self.iter_all_subcommands():
            if cmd.synopsis is None:
                missing.append(path)
        if missing:
            self.fail("The following commands do not have a synopsis set: %r" %
                    missing)

    def test_short_description_everywhere(self):
        missing = []
        for path, cmd in self.iter_all_subcommands():
            if cmd.short_description is None:
                missing.append(path)
        if not missing:
            return
        self.fail(
            "The following commands do not have a short description set: %r" %
                missing)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Unix SMB/CIFS implementation. Tests for ntacls manipulation
# Copyright (C) Matthieu Patou <mat@matws.net> 2009-2010
# Copyright (C) Andrew Bartlett 2012
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.ntacls."""

from samba.ntacls import setntacl, getntacl, XattrBackendError
from samba.param import LoadParm
from samba.dcerpc import security
from samba.tests import TestCaseInTempDir, SkipTest
import os

class NtaclsTests(TestCaseInTempDir):

    def test_setntacl(self):
        lp = LoadParm()
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        open(self.tempf, 'w').write("empty")
        lp.set("posix:eadb",os.path.join(self.tempdir,"eadbtest.tdb"))
        setntacl(lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467")
        os.unlink(os.path.join(self.tempdir,"eadbtest.tdb"))

    def test_setntacl_getntacl(self):
        lp = LoadParm()
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        open(self.tempf, 'w').write("empty")
        lp.set("posix:eadb",os.path.join(self.tempdir,"eadbtest.tdb"))
        setntacl(lp,self.tempf,acl,"S-1-5-21-2212615479-2695158682-2101375467")
        facl = getntacl(lp,self.tempf)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(facl.as_sddl(anysid),acl)
        os.unlink(os.path.join(self.tempdir,"eadbtest.tdb"))

    def test_setntacl_getntacl_param(self):
        lp = LoadParm()
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        open(self.tempf, 'w').write("empty")
        setntacl(lp,self.tempf,acl,"S-1-5-21-2212615479-2695158682-2101375467","tdb",os.path.join(self.tempdir,"eadbtest.tdb"))
        facl=getntacl(lp,self.tempf,"tdb",os.path.join(self.tempdir,"eadbtest.tdb"))
        domsid=security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(facl.as_sddl(domsid),acl)
        os.unlink(os.path.join(self.tempdir,"eadbtest.tdb"))

    def test_setntacl_invalidbackend(self):
        lp = LoadParm()
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        open(self.tempf, 'w').write("empty")
        self.assertRaises(XattrBackendError, setntacl, lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467","ttdb", os.path.join(self.tempdir,"eadbtest.tdb"))

    def test_setntacl_forcenative(self):
        if os.getuid() == 0:
            raise SkipTest("Running test as root, test skipped")
        lp = LoadParm()
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        open(self.tempf, 'w').write("empty")
        lp.set("posix:eadb", os.path.join(self.tempdir,"eadbtest.tdb"))
        self.assertRaises(Exception, setntacl, lp, self.tempf ,acl,
            "S-1-5-21-2212615479-2695158682-2101375467","native")


    def setUp(self):
        super(NtaclsTests, self).setUp()
        self.tempf = os.path.join(self.tempdir, "test")
        open(self.tempf, 'w').write("empty")

    def tearDown(self):
        os.unlink(self.tempf)
        super(NtaclsTests, self).tearDown()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.param."""

from samba import param
import samba.tests

class LoadParmTestCase(samba.tests.TestCase):

    def test_init(self):
        file = param.LoadParm()
        self.assertTrue(file is not None)

    def test_length(self):
        file = param.LoadParm()
        self.assertEquals(0, len(file))

    def test_set_workgroup(self):
        file = param.LoadParm()
        file.set("workgroup", "bla")
        self.assertEquals("BLA", file.get("workgroup"))

    def test_is_mydomain(self):
        file = param.LoadParm()
        file.set("workgroup", "bla")
        self.assertTrue(file.is_mydomain("BLA"))
        self.assertFalse(file.is_mydomain("FOOBAR"))

    def test_is_myname(self):
        file = param.LoadParm()
        file.set("netbios name", "bla")
        self.assertTrue(file.is_myname("BLA"))
        self.assertFalse(file.is_myname("FOOBAR"))

    def test_load_default(self):
        file = param.LoadParm()
        file.load_default()

    def test_section_nonexistent(self):
        samba_lp = param.LoadParm()
        samba_lp.load_default()
        self.assertRaises(KeyError, samba_lp.__getitem__, "nonexistent")

    def test_log_level(self):
        samba_lp = param.LoadParm()
        samba_lp.set("log level", "5 auth:4")
        self.assertEquals(5, samba_lp.log_level())

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2010
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for the libpolicy Python bindings.

"""

from samba.tests import TestCase
from samba import policy


class PolicyTests(TestCase):

    def test_get_gpo_flags(self):
        self.assertEquals(["GPO_FLAG_USER_DISABLE"],
            policy.get_gpo_flags(policy.GPO_FLAG_USER_DISABLE))

    def test_get_gplink_options(self):
        self.assertEquals(["GPLINK_OPT_DISABLE"],
            policy.get_gplink_options(policy.GPLINK_OPT_DISABLE))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Unix SMB/CIFS implementation. Tests for NT and posix ACL manipulation
# Copyright (C) Matthieu Patou <mat@matws.net> 2009-2010
# Copyright (C) Andrew Bartlett 2012
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for the Samba3 NT -> posix ACL layer"""

from samba.ntacls import setntacl, getntacl, checkset_backend
from samba.dcerpc import xattr, security, smb_acl, idmap
from samba.param import LoadParm
from samba.tests import TestCaseInTempDir
from samba import provision
import random
import os
from samba.samba3 import smbd, passdb
from samba.samba3 import param as s3param

# To print a posix ACL use:
#        for entry in posix_acl.acl:
#            print "a_type: %d" % entry.a_type
#            print "a_perm: %o" % entry.a_perm
#            if entry.a_type == smb_acl.SMB_ACL_USER:
#                print "uid: %d" % entry.uid
#            if entry.a_type == smb_acl.SMB_ACL_GROUP:
#                print "gid: %d" % entry.gid

class PosixAclMappingTests(TestCaseInTempDir):

    def test_setntacl(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)

    def test_setntacl_smbd_getntacl(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=True)
        facl = getntacl(self.lp, self.tempf, direct_db_access=True)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(facl.as_sddl(anysid),acl)

    def test_setntacl_smbd_setposixacl_getntacl(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=True)

        # This will invalidate the ACL, as we have a hook!
        smbd.set_simple_acl(self.tempf, 0640)

        # However, this only asks the xattr
        try:
            facl = getntacl(self.lp, self.tempf, direct_db_access=True)
            self.assertTrue(False)
        except TypeError:
            pass

    def test_setntacl_invalidate_getntacl(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=True)

        # This should invalidate the ACL, as we include the posix ACL in the hash
        (backend_obj, dbname) = checkset_backend(self.lp, None, None)
        backend_obj.wrap_setxattr(dbname,
                                  self.tempf, "system.fake_access_acl", "")

        #however, as this is direct DB access, we do not notice it
        facl = getntacl(self.lp, self.tempf, direct_db_access=True)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(acl, facl.as_sddl(anysid))

    def test_setntacl_invalidate_getntacl_smbd(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)

        # This should invalidate the ACL, as we include the posix ACL in the hash
        (backend_obj, dbname) = checkset_backend(self.lp, None, None)
        backend_obj.wrap_setxattr(dbname,
                                  self.tempf, "system.fake_access_acl", "")

        #the hash would break, and we return an ACL based only on the mode, except we set the ACL using the 'ntvfs' mode that doesn't include a hash
        facl = getntacl(self.lp, self.tempf)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(acl, facl.as_sddl(anysid))

    def test_setntacl_smbd_invalidate_getntacl_smbd(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        simple_acl_from_posix = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)(A;;0x001200a9;;;S-1-5-21-2212615479-2695158682-2101375467-513)(A;;;;;WD)"
        os.chmod(self.tempf, 0750)
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)

        # This should invalidate the ACL, as we include the posix ACL in the hash
        (backend_obj, dbname) = checkset_backend(self.lp, None, None)
        backend_obj.wrap_setxattr(dbname,
                                  self.tempf, "system.fake_access_acl", "")

        #the hash will break, and we return an ACL based only on the mode
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(simple_acl_from_posix, facl.as_sddl(anysid))

    def test_setntacl_smbd_dont_invalidate_getntacl_smbd(self):
        # set an ACL on a tempfile
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        os.chmod(self.tempf, 0750)
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)

        # now influence the POSIX ACL->SD mapping it returns something else than
        # what was set previously
        # this should not invalidate the hash and the complete ACL should still
        # be returned
        self.lp.set("profile acls", "yes")
        # we should still get back the ACL (and not one mapped from POSIX ACL)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        self.lp.set("profile acls", "no")
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(acl, facl.as_sddl(anysid))

    def test_setntacl_getntacl_smbd(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=True)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(facl.as_sddl(anysid),acl)

    def test_setntacl_smbd_getntacl_smbd(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(facl.as_sddl(anysid),acl)

    def test_setntacl_smbd_setposixacl_getntacl_smbd(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        simple_acl_from_posix = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;;0x001f019f;;;S-1-5-21-2212615479-2695158682-2101375467-512)(A;;0x00120089;;;S-1-5-21-2212615479-2695158682-2101375467-513)(A;;;;;WD)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)
        # This invalidates the hash of the NT acl just set because there is a hook in the posix ACL set code
        smbd.set_simple_acl(self.tempf, 0640)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(simple_acl_from_posix, facl.as_sddl(anysid))

    def test_setntacl_smbd_setposixacl_group_getntacl_smbd(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        simple_acl_from_posix = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;;0x001f019f;;;S-1-5-21-2212615479-2695158682-2101375467-512)(A;;0x00120089;;;BA)(A;;0x00120089;;;S-1-5-21-2212615479-2695158682-2101375467-513)(A;;;;;WD)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)
        # This invalidates the hash of the NT acl just set because there is a hook in the posix ACL set code
        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        smbd.set_simple_acl(self.tempf, 0640, BA_gid)

        # This should re-calculate an ACL based on the posix details
        facl = getntacl(self.lp,self.tempf, direct_db_access=False)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(simple_acl_from_posix, facl.as_sddl(anysid))

    def test_setntacl_smbd_getntacl_smbd_gpo(self):
        acl = "O:DAG:DUD:P(A;OICI;0x001f01ff;;;DA)(A;OICI;0x001f01ff;;;EA)(A;OICIIO;0x001f01ff;;;CO)(A;OICI;0x001f01ff;;;DA)(A;OICI;0x001f01ff;;;SY)(A;OICI;0x001200a9;;;AU)(A;OICI;0x001200a9;;;ED)S:AI(OU;CIIDSA;WP;f30e3bbe-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)(OU;CIIDSA;WP;f30e3bbf-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        domsid = security.dom_sid("S-1-5-21-2212615479-2695158682-2101375467")
        self.assertEquals(facl.as_sddl(domsid),acl)

    def test_setntacl_getposixacl(self):
        acl = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
        setntacl(self.lp, self.tempf, acl, "S-1-5-21-2212615479-2695158682-2101375467", use_ntvfs=False)
        facl = getntacl(self.lp, self.tempf)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(facl.as_sddl(anysid),acl)
        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)

    def test_setposixacl_getposixacl(self):
        smbd.set_simple_acl(self.tempf, 0640)
        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
        self.assertEquals(posix_acl.count, 4)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_USER_OBJ)
        self.assertEquals(posix_acl.acl[0].a_perm, 6)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[1].a_perm, 4)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[3].a_perm, 6)

    def test_setposixacl_getntacl(self):
        acl = ""
        smbd.set_simple_acl(self.tempf, 0750)
        try:
            facl = getntacl(self.lp, self.tempf)
            self.assertTrue(False)
        except TypeError:
            # We don't expect the xattr to be filled in in this case
            pass

    def test_setposixacl_getntacl_smbd(self):
        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
        group_SID = s4_passdb.gid_to_sid(os.stat(self.tempf).st_gid)
        user_SID = s4_passdb.uid_to_sid(os.stat(self.tempf).st_uid)
        smbd.set_simple_acl(self.tempf, 0640)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        acl = "O:%sG:%sD:(A;;0x001f019f;;;%s)(A;;0x00120089;;;%s)(A;;;;;WD)" % (user_SID, group_SID, user_SID, group_SID)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(acl, facl.as_sddl(anysid))

    def test_setposixacl_dir_getntacl_smbd(self):
        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
        user_SID = s4_passdb.uid_to_sid(os.stat(self.tempdir).st_uid)
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
        (BA_id,BA_type) = s4_passdb.sid_to_id(BA_sid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        SO_sid = security.dom_sid(security.SID_BUILTIN_SERVER_OPERATORS)
        (SO_id,SO_type) = s4_passdb.sid_to_id(SO_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        smbd.chown(self.tempdir, BA_id, SO_id)
        smbd.set_simple_acl(self.tempdir, 0750)
        facl = getntacl(self.lp, self.tempdir, direct_db_access=False)
        acl = "O:BAG:SOD:(A;;0x001f01ff;;;BA)(A;;0x001200a9;;;SO)(A;;;;;WD)(A;OICIIO;0x001f01ff;;;CO)(A;OICIIO;0x001200a9;;;CG)(A;OICIIO;0x001200a9;;;WD)"

        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(acl, facl.as_sddl(anysid))

    def test_setposixacl_group_getntacl_smbd(self):
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        group_SID = s4_passdb.gid_to_sid(os.stat(self.tempf).st_gid)
        user_SID = s4_passdb.uid_to_sid(os.stat(self.tempf).st_uid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        smbd.set_simple_acl(self.tempf, 0640, BA_gid)
        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
        domsid = passdb.get_global_sam_sid()
        acl = "O:%sG:%sD:(A;;0x001f019f;;;%s)(A;;0x00120089;;;BA)(A;;0x00120089;;;%s)(A;;;;;WD)" % (user_SID, group_SID, user_SID, group_SID)
        anysid = security.dom_sid(security.SID_NT_SELF)
        self.assertEquals(acl, facl.as_sddl(anysid))

    def test_setposixacl_getposixacl(self):
        smbd.set_simple_acl(self.tempf, 0640)
        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
        self.assertEquals(posix_acl.count, 4)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_USER_OBJ)
        self.assertEquals(posix_acl.acl[0].a_perm, 6)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[1].a_perm, 4)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[3].a_perm, 7)

    def test_setposixacl_dir_getposixacl(self):
        smbd.set_simple_acl(self.tempdir, 0750)
        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS)
        self.assertEquals(posix_acl.count, 4)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_USER_OBJ)
        self.assertEquals(posix_acl.acl[0].a_perm, 7)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[1].a_perm, 5)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[3].a_perm, 7)

    def test_setposixacl_group_getposixacl(self):
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        smbd.set_simple_acl(self.tempf, 0670, BA_gid)
        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)

        self.assertEquals(posix_acl.count, 5)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_USER_OBJ)
        self.assertEquals(posix_acl.acl[0].a_perm, 6)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[1].a_perm, 7)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[3].a_perm, 7)
        self.assertEquals(posix_acl.acl[3].info.gid, BA_gid)

        self.assertEquals(posix_acl.acl[4].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[4].a_perm, 7)

    def test_setntacl_sysvol_check_getposixacl(self):
        acl = provision.SYSVOL_ACL
        domsid = passdb.get_global_sam_sid()
        setntacl(self.lp, self.tempf,acl,str(domsid), use_ntvfs=False)
        facl = getntacl(self.lp, self.tempf)
        self.assertEquals(facl.as_sddl(domsid),acl)
        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)

        nwrap_module_so_path = os.getenv('NSS_WRAPPER_MODULE_SO_PATH')
        nwrap_module_fn_prefix = os.getenv('NSS_WRAPPER_MODULE_FN_PREFIX')

        nwrap_winbind_active = (nwrap_module_so_path != "" and
                nwrap_module_fn_prefix == "winbind")

        LA_sid = security.dom_sid(str(domsid)+"-"+str(security.DOMAIN_RID_ADMINISTRATOR))
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        SO_sid = security.dom_sid(security.SID_BUILTIN_SERVER_OPERATORS)
        SY_sid = security.dom_sid(security.SID_NT_SYSTEM)
        AU_sid = security.dom_sid(security.SID_NT_AUTHENTICATED_USERS)

        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))

        # These assertions correct for current ad_dc selftest
        # configuration.  When other environments have a broad range of
        # groups mapped via passdb, we can relax some of these checks
        (LA_uid,LA_type) = s4_passdb.sid_to_id(LA_sid)
        self.assertEquals(LA_type, idmap.ID_TYPE_UID)
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        (SO_gid,SO_type) = s4_passdb.sid_to_id(SO_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (SY_gid,SY_type) = s4_passdb.sid_to_id(SY_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (AU_gid,AU_type) = s4_passdb.sid_to_id(AU_sid)
        self.assertEquals(AU_type, idmap.ID_TYPE_BOTH)

        self.assertEquals(posix_acl.count, 13)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[0].a_perm, 7)
        self.assertEquals(posix_acl.acl[0].info.gid, BA_gid)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_USER)
        if nwrap_winbind_active:
            self.assertEquals(posix_acl.acl[1].a_perm, 7)
        else:
            self.assertEquals(posix_acl.acl[1].a_perm, 6)
        self.assertEquals(posix_acl.acl[1].info.uid, LA_uid)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_USER_OBJ)
        if nwrap_winbind_active:
            self.assertEquals(posix_acl.acl[3].a_perm, 7)
        else:
            self.assertEquals(posix_acl.acl[3].a_perm, 6)

        self.assertEquals(posix_acl.acl[4].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[4].a_perm, 7)
        self.assertEquals(posix_acl.acl[4].info.uid, BA_gid)

        self.assertEquals(posix_acl.acl[5].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[5].a_perm, 7)

        self.assertEquals(posix_acl.acl[6].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[6].a_perm, 5)
        self.assertEquals(posix_acl.acl[6].info.uid, SO_gid)

        self.assertEquals(posix_acl.acl[7].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[7].a_perm, 5)
        self.assertEquals(posix_acl.acl[7].info.gid, SO_gid)

        self.assertEquals(posix_acl.acl[8].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[8].a_perm, 7)
        self.assertEquals(posix_acl.acl[8].info.uid, SY_gid)

        self.assertEquals(posix_acl.acl[9].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[9].a_perm, 7)
        self.assertEquals(posix_acl.acl[9].info.gid, SY_gid)

        self.assertEquals(posix_acl.acl[10].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[10].a_perm, 5)
        self.assertEquals(posix_acl.acl[10].info.uid, AU_gid)

        self.assertEquals(posix_acl.acl[11].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[11].a_perm, 5)
        self.assertEquals(posix_acl.acl[11].info.gid, AU_gid)

        self.assertEquals(posix_acl.acl[12].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[12].a_perm, 7)


# check that it matches:
# user::rwx
# user:root:rwx (selftest user actually)
# group::rwx
# group:Local Admins:rwx
# group:3000000:r-x
# group:3000001:rwx
# group:3000002:r-x
# mask::rwx
# other::---

#
# This is in this order in the NDR smb_acl (not re-orderded for display)
# a_type: GROUP
# a_perm: 7
# uid: -1
# gid: 10
# a_type: USER
# a_perm: 6
# uid: 0 (selftest user actually)
# gid: -1
# a_type: OTHER
# a_perm: 0
# uid: -1
# gid: -1
# a_type: USER_OBJ
# a_perm: 6
# uid: -1
# gid: -1
# a_type: GROUP_OBJ
# a_perm: 7
# uid: -1
# gid: -1
# a_type: GROUP
# a_perm: 5
# uid: -1
# gid: 3000020
# a_type: GROUP
# a_perm: 7
# uid: -1
# gid: 3000000
# a_type: GROUP
# a_perm: 5
# uid: -1
# gid: 3000001
# a_type: MASK
# a_perm: 7
# uid: -1
# gid: -1

#


    def test_setntacl_sysvol_dir_check_getposixacl(self):
        acl = provision.SYSVOL_ACL
        domsid = passdb.get_global_sam_sid()
        setntacl(self.lp, self.tempdir,acl,str(domsid), use_ntvfs=False)
        facl = getntacl(self.lp, self.tempdir)
        self.assertEquals(facl.as_sddl(domsid),acl)
        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS)

        LA_sid = security.dom_sid(str(domsid)+"-"+str(security.DOMAIN_RID_ADMINISTRATOR))
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        SO_sid = security.dom_sid(security.SID_BUILTIN_SERVER_OPERATORS)
        SY_sid = security.dom_sid(security.SID_NT_SYSTEM)
        AU_sid = security.dom_sid(security.SID_NT_AUTHENTICATED_USERS)

        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))

        # These assertions correct for current ad_dc selftest
        # configuration.  When other environments have a broad range of
        # groups mapped via passdb, we can relax some of these checks
        (LA_uid,LA_type) = s4_passdb.sid_to_id(LA_sid)
        self.assertEquals(LA_type, idmap.ID_TYPE_UID)
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        (SO_gid,SO_type) = s4_passdb.sid_to_id(SO_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (SY_gid,SY_type) = s4_passdb.sid_to_id(SY_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (AU_gid,AU_type) = s4_passdb.sid_to_id(AU_sid)
        self.assertEquals(AU_type, idmap.ID_TYPE_BOTH)

        self.assertEquals(posix_acl.count, 13)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[0].a_perm, 7)
        self.assertEquals(posix_acl.acl[0].info.gid, BA_gid)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[1].a_perm, 7)
        self.assertEquals(posix_acl.acl[1].info.uid, LA_uid)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_USER_OBJ)
        self.assertEquals(posix_acl.acl[3].a_perm, 7)

        self.assertEquals(posix_acl.acl[4].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[4].a_perm, 7)
        self.assertEquals(posix_acl.acl[4].info.uid, BA_gid)

        self.assertEquals(posix_acl.acl[5].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[5].a_perm, 7)

        self.assertEquals(posix_acl.acl[6].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[6].a_perm, 5)
        self.assertEquals(posix_acl.acl[6].info.uid, SO_gid)

        self.assertEquals(posix_acl.acl[7].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[7].a_perm, 5)
        self.assertEquals(posix_acl.acl[7].info.gid, SO_gid)

        self.assertEquals(posix_acl.acl[8].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[8].a_perm, 7)
        self.assertEquals(posix_acl.acl[8].info.uid, SY_gid)

        self.assertEquals(posix_acl.acl[9].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[9].a_perm, 7)
        self.assertEquals(posix_acl.acl[9].info.gid, SY_gid)

        self.assertEquals(posix_acl.acl[10].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[10].a_perm, 5)
        self.assertEquals(posix_acl.acl[10].info.uid, AU_gid)

        self.assertEquals(posix_acl.acl[11].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[11].a_perm, 5)
        self.assertEquals(posix_acl.acl[11].info.gid, AU_gid)

        self.assertEquals(posix_acl.acl[12].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[12].a_perm, 7)


# check that it matches:
# user::rwx
# user:root:rwx (selftest user actually)
# group::rwx
# group:3000000:rwx
# group:3000001:r-x
# group:3000002:rwx
# group:3000003:r-x
# mask::rwx
# other::---


    def test_setntacl_policies_dir_check_getposixacl(self):
        acl = provision.POLICIES_ACL
        domsid = passdb.get_global_sam_sid()
        setntacl(self.lp, self.tempdir,acl,str(domsid), use_ntvfs=False)
        facl = getntacl(self.lp, self.tempdir)
        self.assertEquals(facl.as_sddl(domsid),acl)
        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS)

        LA_sid = security.dom_sid(str(domsid)+"-"+str(security.DOMAIN_RID_ADMINISTRATOR))
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        SO_sid = security.dom_sid(security.SID_BUILTIN_SERVER_OPERATORS)
        SY_sid = security.dom_sid(security.SID_NT_SYSTEM)
        AU_sid = security.dom_sid(security.SID_NT_AUTHENTICATED_USERS)
        PA_sid = security.dom_sid(str(domsid)+"-"+str(security.DOMAIN_RID_POLICY_ADMINS))

        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))

        # These assertions correct for current ad_dc selftest
        # configuration.  When other environments have a broad range of
        # groups mapped via passdb, we can relax some of these checks
        (LA_uid,LA_type) = s4_passdb.sid_to_id(LA_sid)
        self.assertEquals(LA_type, idmap.ID_TYPE_UID)
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        (SO_gid,SO_type) = s4_passdb.sid_to_id(SO_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (SY_gid,SY_type) = s4_passdb.sid_to_id(SY_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (AU_gid,AU_type) = s4_passdb.sid_to_id(AU_sid)
        self.assertEquals(AU_type, idmap.ID_TYPE_BOTH)
        (PA_gid,PA_type) = s4_passdb.sid_to_id(PA_sid)
        self.assertEquals(PA_type, idmap.ID_TYPE_BOTH)

        self.assertEquals(posix_acl.count, 15)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[0].a_perm, 7)
        self.assertEquals(posix_acl.acl[0].info.gid, BA_gid)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[1].a_perm, 7)
        self.assertEquals(posix_acl.acl[1].info.uid, LA_uid)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_USER_OBJ)
        self.assertEquals(posix_acl.acl[3].a_perm, 7)

        self.assertEquals(posix_acl.acl[4].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[4].a_perm, 7)
        self.assertEquals(posix_acl.acl[4].info.uid, BA_gid)

        self.assertEquals(posix_acl.acl[5].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[5].a_perm, 7)

        self.assertEquals(posix_acl.acl[6].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[6].a_perm, 5)
        self.assertEquals(posix_acl.acl[6].info.uid, SO_gid)

        self.assertEquals(posix_acl.acl[7].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[7].a_perm, 5)
        self.assertEquals(posix_acl.acl[7].info.gid, SO_gid)

        self.assertEquals(posix_acl.acl[8].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[8].a_perm, 7)
        self.assertEquals(posix_acl.acl[8].info.uid, SY_gid)

        self.assertEquals(posix_acl.acl[9].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[9].a_perm, 7)
        self.assertEquals(posix_acl.acl[9].info.gid, SY_gid)

        self.assertEquals(posix_acl.acl[10].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[10].a_perm, 5)
        self.assertEquals(posix_acl.acl[10].info.uid, AU_gid)

        self.assertEquals(posix_acl.acl[11].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[11].a_perm, 5)
        self.assertEquals(posix_acl.acl[11].info.gid, AU_gid)

        self.assertEquals(posix_acl.acl[12].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[12].a_perm, 7)
        self.assertEquals(posix_acl.acl[12].info.uid, PA_gid)

        self.assertEquals(posix_acl.acl[13].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[13].a_perm, 7)
        self.assertEquals(posix_acl.acl[13].info.gid, PA_gid)

        self.assertEquals(posix_acl.acl[14].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[14].a_perm, 7)


# check that it matches:
# user::rwx
# user:root:rwx  (selftest user actually)
# group::rwx
# group:3000000:rwx
# group:3000001:r-x
# group:3000002:rwx
# group:3000003:r-x
# group:3000004:rwx
# mask::rwx
# other::---



    def test_setntacl_policies_check_getposixacl(self):
        acl = provision.POLICIES_ACL

        domsid = passdb.get_global_sam_sid()
        setntacl(self.lp, self.tempf, acl, str(domsid), use_ntvfs=False)
        facl = getntacl(self.lp, self.tempf)
        self.assertEquals(facl.as_sddl(domsid),acl)
        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)

        nwrap_module_so_path = os.getenv('NSS_WRAPPER_MODULE_SO_PATH')
        nwrap_module_fn_prefix = os.getenv('NSS_WRAPPER_MODULE_FN_PREFIX')

        nwrap_winbind_active = (nwrap_module_so_path != "" and
                nwrap_module_fn_prefix == "winbind")

        LA_sid = security.dom_sid(str(domsid)+"-"+str(security.DOMAIN_RID_ADMINISTRATOR))
        BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
        SO_sid = security.dom_sid(security.SID_BUILTIN_SERVER_OPERATORS)
        SY_sid = security.dom_sid(security.SID_NT_SYSTEM)
        AU_sid = security.dom_sid(security.SID_NT_AUTHENTICATED_USERS)
        PA_sid = security.dom_sid(str(domsid)+"-"+str(security.DOMAIN_RID_POLICY_ADMINS))

        s4_passdb = passdb.PDB(self.lp.get("passdb backend"))

        # These assertions correct for current ad_dc selftest
        # configuration.  When other environments have a broad range of
        # groups mapped via passdb, we can relax some of these checks
        (LA_uid,LA_type) = s4_passdb.sid_to_id(LA_sid)
        self.assertEquals(LA_type, idmap.ID_TYPE_UID)
        (BA_gid,BA_type) = s4_passdb.sid_to_id(BA_sid)
        self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
        (SO_gid,SO_type) = s4_passdb.sid_to_id(SO_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (SY_gid,SY_type) = s4_passdb.sid_to_id(SY_sid)
        self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
        (AU_gid,AU_type) = s4_passdb.sid_to_id(AU_sid)
        self.assertEquals(AU_type, idmap.ID_TYPE_BOTH)
        (PA_gid,PA_type) = s4_passdb.sid_to_id(PA_sid)
        self.assertEquals(PA_type, idmap.ID_TYPE_BOTH)

        self.assertEquals(posix_acl.count, 15)

        self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[0].a_perm, 7)
        self.assertEquals(posix_acl.acl[0].info.gid, BA_gid)

        self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_USER)
        if nwrap_winbind_active:
            self.assertEquals(posix_acl.acl[1].a_perm, 7)
        else:
            self.assertEquals(posix_acl.acl[1].a_perm, 6)
        self.assertEquals(posix_acl.acl[1].info.uid, LA_uid)

        self.assertEquals(posix_acl.acl[2].a_type, smb_acl.SMB_ACL_OTHER)
        self.assertEquals(posix_acl.acl[2].a_perm, 0)

        self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_USER_OBJ)
        if nwrap_winbind_active:
            self.assertEquals(posix_acl.acl[3].a_perm, 7)
        else:
            self.assertEquals(posix_acl.acl[3].a_perm, 6)

        self.assertEquals(posix_acl.acl[4].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[4].a_perm, 7)
        self.assertEquals(posix_acl.acl[4].info.uid, BA_gid)

        self.assertEquals(posix_acl.acl[5].a_type, smb_acl.SMB_ACL_GROUP_OBJ)
        self.assertEquals(posix_acl.acl[5].a_perm, 7)

        self.assertEquals(posix_acl.acl[6].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[6].a_perm, 5)
        self.assertEquals(posix_acl.acl[6].info.uid, SO_gid)

        self.assertEquals(posix_acl.acl[7].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[7].a_perm, 5)
        self.assertEquals(posix_acl.acl[7].info.gid, SO_gid)

        self.assertEquals(posix_acl.acl[8].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[8].a_perm, 7)
        self.assertEquals(posix_acl.acl[8].info.uid, SY_gid)

        self.assertEquals(posix_acl.acl[9].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[9].a_perm, 7)
        self.assertEquals(posix_acl.acl[9].info.gid, SY_gid)

        self.assertEquals(posix_acl.acl[10].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[10].a_perm, 5)
        self.assertEquals(posix_acl.acl[10].info.uid, AU_gid)

        self.assertEquals(posix_acl.acl[11].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[11].a_perm, 5)
        self.assertEquals(posix_acl.acl[11].info.gid, AU_gid)

        self.assertEquals(posix_acl.acl[12].a_type, smb_acl.SMB_ACL_USER)
        self.assertEquals(posix_acl.acl[12].a_perm, 7)
        self.assertEquals(posix_acl.acl[12].info.uid, PA_gid)

        self.assertEquals(posix_acl.acl[13].a_type, smb_acl.SMB_ACL_GROUP)
        self.assertEquals(posix_acl.acl[13].a_perm, 7)
        self.assertEquals(posix_acl.acl[13].info.gid, PA_gid)

        self.assertEquals(posix_acl.acl[14].a_type, smb_acl.SMB_ACL_MASK)
        self.assertEquals(posix_acl.acl[14].a_perm, 7)


# check that it matches:
# user::rwx
# user:root:rwx (selftest user actually)
# group::rwx
# group:Local Admins:rwx
# group:3000000:r-x
# group:3000001:rwx
# group:3000002:r-x
# group:3000003:rwx
# mask::rwx
# other::---

#
# This is in this order in the NDR smb_acl (not re-orderded for display)
# a_type: GROUP
# a_perm: 7
# uid: -1
# gid: 10
# a_type: USER
# a_perm: 6
# uid: 0 (selftest user actually)
# gid: -1
# a_type: OTHER
# a_perm: 0
# uid: -1
# gid: -1
# a_type: USER_OBJ
# a_perm: 6
# uid: -1
# gid: -1
# a_type: GROUP_OBJ
# a_perm: 7
# uid: -1
# gid: -1
# a_type: GROUP
# a_perm: 5
# uid: -1
# gid: 3000020
# a_type: GROUP
# a_perm: 7
# uid: -1
# gid: 3000000
# a_type: GROUP
# a_perm: 5
# uid: -1
# gid: 3000001
# a_type: GROUP
# a_perm: 7
# uid: -1
# gid: 3000003
# a_type: MASK
# a_perm: 7
# uid: -1
# gid: -1

#

    def setUp(self):
        super(PosixAclMappingTests, self).setUp()
        s3conf = s3param.get_context()
        s3conf.load(self.get_loadparm().configfile)
        s3conf.set("xattr_tdb:file", os.path.join(self.tempdir,"xattr.tdb"))
        self.lp = s3conf
        self.tempf = os.path.join(self.tempdir, "test")
        open(self.tempf, 'w').write("empty")

    def tearDown(self):
        smbd.unlink(self.tempf)
        os.unlink(os.path.join(self.tempdir,"xattr.tdb"))
        super(PosixAclMappingTests, self).tearDown()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2012
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.provision."""

import os
from samba.provision import (
    ProvisionNames,
    ProvisionPaths,
    ProvisionResult,
    determine_netbios_name,
    sanitize_server_role,
    setup_secretsdb,
    findnss,
    )
import samba.tests
from samba.tests import env_loadparm, TestCase

def create_dummy_secretsdb(path, lp=None):
    """Create a dummy secrets database for use in tests.

    :param path: Path to store the secrets db
    :param lp: Optional loadparm context. A simple one will
        be generated if not specified.
    """
    if lp is None:
        lp = env_loadparm()
    paths = ProvisionPaths()
    paths.secrets = path
    paths.private_dir = os.path.dirname(path)
    paths.keytab = "no.keytab"
    paths.dns_keytab = "no.dns.keytab"
    secrets_ldb = setup_secretsdb(paths, None, None, lp=lp)
    secrets_ldb.transaction_commit()
    return secrets_ldb


class ProvisionTestCase(samba.tests.TestCaseInTempDir):
    """Some simple tests for individual functions in the provisioning code.
    """

    def test_setup_secretsdb(self):
        path = os.path.join(self.tempdir, "secrets.ldb")
        paths = ProvisionPaths()
        secrets_tdb_path = os.path.join(self.tempdir, "secrets.tdb")
        paths.secrets = path
        paths.private_dir = os.path.dirname(path)
        paths.keytab = "no.keytab"
        paths.dns_keytab = "no.dns.keytab"
        ldb = setup_secretsdb(paths, None, None, lp=env_loadparm())
        try:
            self.assertEquals("LSA Secrets",
                 ldb.searchone(basedn="CN=LSA Secrets", attribute="CN"))
        finally:
            del ldb
            os.unlink(path)
            if os.path.exists(secrets_tdb_path):
                os.unlink(secrets_tdb_path)

class FindNssTests(TestCase):
    """Test findnss() function."""

    def test_nothing(self):
        def x(y):
            raise KeyError
        self.assertRaises(KeyError, findnss, x, [])

    def test_first(self):
        self.assertEquals("bla", findnss(lambda x: "bla", ["bla"]))

    def test_skip_first(self):
        def x(y):
            if y != "bla":
                raise KeyError
            return "ha"
        self.assertEquals("ha", findnss(x, ["bloe", "bla"]))


class Disabled(object):

    def test_setup_templatesdb(self):
        raise NotImplementedError(self.test_setup_templatesdb)

    def test_setup_registry(self):
        raise NotImplementedError(self.test_setup_registry)

    def test_setup_samdb_rootdse(self):
        raise NotImplementedError(self.test_setup_samdb_rootdse)

    def test_setup_samdb_partitions(self):
        raise NotImplementedError(self.test_setup_samdb_partitions)

    def test_provision_dns(self):
        raise NotImplementedError(self.test_provision_dns)

    def test_provision_ldapbase(self):
        raise NotImplementedError(self.test_provision_ldapbase)

    def test_provision_guess(self):
        raise NotImplementedError(self.test_provision_guess)

    def test_join_domain(self):
        raise NotImplementedError(self.test_join_domain)


class SanitizeServerRoleTests(TestCase):

    def test_same(self):
        self.assertEquals("standalone server",
            sanitize_server_role("standalone server"))
        self.assertEquals("member server",
            sanitize_server_role("member server"))

    def test_invalid(self):
        self.assertRaises(ValueError, sanitize_server_role, "foo")

    def test_valid(self):
        self.assertEquals(
            "standalone server",
            sanitize_server_role("ROLE_STANDALONE"))
        self.assertEquals(
            "standalone server",
            sanitize_server_role("standalone"))
        self.assertEquals(
            "active directory domain controller",
            sanitize_server_role("domain controller"))


class DummyLogger(object):

    def __init__(self):
        self.entries = []

    def info(self, text, *args):
        self.entries.append(("INFO", text % args))


class ProvisionResultTests(TestCase):

    def report_logger(self, result):
        logger = DummyLogger()
        result.report_logger(logger)
        return logger.entries

    def base_result(self):
        result = ProvisionResult()
        result.server_role = "domain controller"
        result.names = ProvisionNames()
        result.names.hostname = "hostnaam"
        result.names.domain = "DOMEIN"
        result.names.dnsdomain = "dnsdomein"
        result.domainsid = "S1-1-1"
        result.paths = ProvisionPaths()
        return result

    def test_basic_report_logger(self):
        result = self.base_result()
        entries = self.report_logger(result)
        self.assertEquals(entries, [
            ('INFO', 'Once the above files are installed, your Samba4 server '
                'will be ready to use'),
            ('INFO', 'Server Role:           domain controller'),
            ('INFO', 'Hostname:              hostnaam'),
            ('INFO', 'NetBIOS Domain:        DOMEIN'),
            ('INFO', 'DNS Domain:            dnsdomein'),
            ('INFO', 'DOMAIN SID:            S1-1-1')])

    def test_report_logger_adminpass(self):
        result = self.base_result()
        result.adminpass_generated = True
        result.adminpass = "geheim"
        entries = self.report_logger(result)
        self.assertEquals(entries[1],
                ("INFO", 'Admin password:        geheim'))


class DetermineNetbiosNameTests(TestCase):

    def test_limits_to_15(self):
        self.assertEquals("A" * 15, determine_netbios_name("a" * 30))

    def test_strips_invalid(self):
        self.assertEquals("BLABLA", determine_netbios_name("bla/bla"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.registry."""

import os
from samba import registry
import samba.tests

class HelperTests(samba.tests.TestCase):

    def test_predef_to_name(self):
        self.assertEquals("HKEY_LOCAL_MACHINE",
                          registry.get_predef_name(0x80000002))

    def test_str_regtype(self):
        self.assertEquals("REG_DWORD", registry.str_regtype(4))



class HiveTests(samba.tests.TestCaseInTempDir):

    def setUp(self):
        super(HiveTests, self).setUp()
        self.hive_path = os.path.join(self.tempdir, "ldb_new.ldb")
        self.hive = registry.open_ldb(self.hive_path)

    def tearDown(self):
        del self.hive
        os.unlink(self.hive_path)
        super(HiveTests, self).tearDown()

    def test_ldb_new(self):
        self.assertTrue(self.hive is not None)

    #def test_flush(self):
    #    self.hive.flush()

    #def test_del_value(self):
    #    self.hive.del_value("FOO")


class RegistryTests(samba.tests.TestCase):

    def test_new(self):
        self.registry = registry.Registry()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for samba.samba3."""

from samba.samba3 import (
    Registry,
    WinsDatabase,
    IdmapDatabase,
    )
from samba.samba3 import passdb
from samba.samba3 import param as s3param
from samba.tests import TestCase, TestCaseInTempDir
from samba.dcerpc.security import dom_sid
import os


for p in [ "../../../../../testdata/samba3", "../../../../testdata/samba3" ]:
    DATADIR = os.path.join(os.path.dirname(__file__), p)
    if os.path.exists(DATADIR):
        break


class RegistryTestCase(TestCase):

    def setUp(self):
        super(RegistryTestCase, self).setUp()
        self.registry = Registry(os.path.join(DATADIR, "registry"))

    def tearDown(self):
        self.registry.close()
        super(RegistryTestCase, self).tearDown()

    def test_length(self):
        self.assertEquals(28, len(self.registry))

    def test_keys(self):
        self.assertTrue("HKLM" in self.registry.keys())

    def test_subkeys(self):
        self.assertEquals(["SOFTWARE", "SYSTEM"], self.registry.subkeys("HKLM"))

    def test_values(self):
        self.assertEquals({'DisplayName': (1L, 'E\x00v\x00e\x00n\x00t\x00 \x00L\x00o\x00g\x00\x00\x00'),
                           'ErrorControl': (4L, '\x01\x00\x00\x00')},
                           self.registry.values("HKLM/SYSTEM/CURRENTCONTROLSET/SERVICES/EVENTLOG"))


class PassdbTestCase(TestCaseInTempDir):

    def setUp(self):
        super(PassdbTestCase, self).setUp()
        os.system("cp -r %s %s" % (DATADIR, self.tempdir))
        datadir = os.path.join(self.tempdir, "samba3")

        self.lp = s3param.get_context()
        self.lp.load(os.path.join(datadir, "smb.conf"))
        self.lp.set("private dir", datadir)
        self.lp.set("state directory", datadir)
        self.lp.set("lock directory", datadir)
        self.lp.set("cache directory", datadir)
        passdb.set_secrets_dir(datadir)
        self.pdb = passdb.PDB("tdbsam")

    def tearDown(self):
        self.lp = []
        self.pdb = []
        os.system("rm -rf %s" % os.path.join(self.tempdir, "samba3"))
        super(PassdbTestCase, self).tearDown()

    def test_param(self):
        self.assertEquals("BEDWYR", self.lp.get("netbios name"))
        self.assertEquals("SAMBA", self.lp.get("workgroup"))
        self.assertEquals("USER", self.lp.get("security"))

    def test_policy(self):
        policy = self.pdb.get_account_policy()
        self.assertEquals(0, policy['bad lockout attempt'])
        self.assertEquals(-1, policy['disconnect time'])
        self.assertEquals(0, policy['lockout duration'])
        self.assertEquals(999999999, policy['maximum password age'])
        self.assertEquals(0, policy['minimum password age'])
        self.assertEquals(5, policy['min password length'])
        self.assertEquals(0, policy['password history'])
        self.assertEquals(0, policy['refuse machine password change'])
        self.assertEquals(0, policy['reset count minutes'])
        self.assertEquals(0, policy['user must logon to change password'])

    def test_get_sid(self):
        domain_sid = passdb.get_global_sam_sid()
        self.assertEquals(dom_sid("S-1-5-21-2470180966-3899876309-2637894779"), domain_sid)

    def test_usernames(self):
        userlist = self.pdb.search_users(0)
        self.assertEquals(3, len(userlist))

    def test_getuser(self):
        user = self.pdb.getsampwnam("root")

        self.assertEquals(16, user.acct_ctrl)
        self.assertEquals("", user.acct_desc)
        self.assertEquals(0, user.bad_password_count)
        self.assertEquals(0, user.bad_password_time)
        self.assertEquals(0, user.code_page)
        self.assertEquals(0, user.country_code)
        self.assertEquals("", user.dir_drive)
        self.assertEquals("BEDWYR", user.domain)
        self.assertEquals("root", user.full_name)
        self.assertEquals(dom_sid('S-1-5-21-2470180966-3899876309-2637894779-513'), user.group_sid)
        self.assertEquals("\\\\BEDWYR\\root", user.home_dir)
        self.assertEquals([-1 for i in range(21)], user.hours)
        self.assertEquals(21, user.hours_len)
        self.assertEquals(9223372036854775807, user.kickoff_time)
        self.assertEquals(None, user.lanman_passwd)
        self.assertEquals(9223372036854775807, user.logoff_time)
        self.assertEquals(0, user.logon_count)
        self.assertEquals(168, user.logon_divs)
        self.assertEquals("", user.logon_script)
        self.assertEquals(0, user.logon_time)
        self.assertEquals("", user.munged_dial)
        self.assertEquals('\x87\x8d\x80\x14`l\xda)gzD\xef\xa15?\xc7', user.nt_passwd)
        self.assertEquals("", user.nt_username)
        self.assertEquals(1125418267, user.pass_can_change_time)
        self.assertEquals(1125418267, user.pass_last_set_time)
        self.assertEquals(2125418266, user.pass_must_change_time)
        self.assertEquals(None, user.plaintext_passwd)
        self.assertEquals("\\\\BEDWYR\\root\\profile", user.profile_path)
        self.assertEquals(None, user.pw_history)
        self.assertEquals(dom_sid("S-1-5-21-2470180966-3899876309-2637894779-1000"), user.user_sid)
        self.assertEquals("root", user.username)
        self.assertEquals("", user.workstations)

    def test_group_length(self):
        grouplist = self.pdb.enum_group_mapping()
        self.assertEquals(13, len(grouplist))

    def test_get_group(self):
        group = self.pdb.getgrsid(dom_sid("S-1-5-32-544"))
        self.assertEquals("Administrators", group.nt_name)
        self.assertEquals(-1, group.gid)
        self.assertEquals(5, group.sid_name_use)

    def test_groupsids(self):
        grouplist = self.pdb.enum_group_mapping()
        sids = []
        for g in grouplist:
            sids.append(str(g.sid))
        self.assertTrue("S-1-5-32-544" in sids)
        self.assertTrue("S-1-5-32-545" in sids)
        self.assertTrue("S-1-5-32-546" in sids)
        self.assertTrue("S-1-5-32-548" in sids)
        self.assertTrue("S-1-5-32-549" in sids)
        self.assertTrue("S-1-5-32-550" in sids)
        self.assertTrue("S-1-5-32-551" in sids)

    def test_alias_length(self):
        aliaslist = self.pdb.search_aliases()
        self.assertEquals(1, len(aliaslist))
        self.assertEquals("Jelmers NT Group", aliaslist[0]['account_name'])


class WinsDatabaseTestCase(TestCase):

    def setUp(self):
        super(WinsDatabaseTestCase, self).setUp()
        self.winsdb = WinsDatabase(os.path.join(DATADIR, "wins.dat"))

    def test_length(self):
        self.assertEquals(22, len(self.winsdb))

    def test_first_entry(self):
        self.assertEqual((1124185120, ["192.168.1.5"], 0x64), self.winsdb["ADMINISTRATOR#03"])

    def tearDown(self):
        self.winsdb.close()
        super(WinsDatabaseTestCase, self).tearDown()


class IdmapDbTestCase(TestCase):

    def setUp(self):
        super(IdmapDbTestCase, self).setUp()
        self.idmapdb = IdmapDatabase(os.path.join(DATADIR,
            "winbindd_idmap"))

    def test_user_hwm(self):
        self.assertEquals(10000, self.idmapdb.get_user_hwm())

    def test_group_hwm(self):
        self.assertEquals(10002, self.idmapdb.get_group_hwm())

    def test_uids(self):
        self.assertEquals(1, len(list(self.idmapdb.uids())))

    def test_gids(self):
        self.assertEquals(3, len(list(self.idmapdb.gids())))

    def test_get_user_sid(self):
        self.assertEquals("S-1-5-21-58189338-3053988021-627566699-501", self.idmapdb.get_user_sid(65534))

    def test_get_group_sid(self):
        self.assertEquals("S-1-5-21-2447931902-1787058256-3961074038-3007", self.idmapdb.get_group_sid(10001))

    def tearDown(self):
        self.idmapdb.close()
        super(IdmapDbTestCase, self).tearDown()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2005-2008
# Copyright (C) Martin Kuehl <mkhl@samba.org> 2006
#
# This is a Python port of the original in testprogs/ejs/samba3sam.js
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Tests for the samba3sam LDB module, which maps Samba3 LDAP to AD LDAP."""

import os
import ldb
from ldb import SCOPE_DEFAULT, SCOPE_BASE
from samba import Ldb, substitute_var
from samba.tests import TestCaseInTempDir, env_loadparm
import samba.dcerpc.security
import samba.ndr
from samba.auth import system_session
from operator import attrgetter


def read_datafile(filename):
    paths = [ "../../../../../testdata/samba3",
              "../../../../testdata/samba3" ]
    for p in paths:
        datadir = os.path.join(os.path.dirname(__file__), p)
        if os.path.exists(datadir):
            break
    return open(os.path.join(datadir, filename), 'r').read()

def ldb_debug(l, text):
    print text


class MapBaseTestCase(TestCaseInTempDir):
    """Base test case for mapping tests."""

    def setup_modules(self, ldb, s3, s4):
        ldb.add({"dn": "@MAP=samba3sam",
                 "@FROM": s4.basedn,
                 "@TO": "sambaDomainName=TESTS," + s3.basedn})

        ldb.add({"dn": "@MODULES",
                 "@LIST": "rootdse,paged_results,server_sort,asq,samldb,password_hash,operational,objectguid,rdn_name,samba3sam,samba3sid,show_deleted,dsdb_flags_ignore,partition"})

        ldb.add({"dn": "@PARTITION",
            "partition": ["%s" % (s4.basedn_casefold),
                          "%s" % (s3.basedn_casefold)],
            "replicateEntries": ["@ATTRIBUTES", "@INDEXLIST"],
            "modules": "*:"})

    def setUp(self):
        self.lp = env_loadparm()
        self.lp.set("workgroup", "TESTS")
        self.lp.set("netbios name", "TESTS")
        super(MapBaseTestCase, self).setUp()

        def make_dn(basedn, rdn):
            return "%s,sambaDomainName=TESTS,%s" % (rdn, basedn)

        def make_s4dn(basedn, rdn):
            return "%s,%s" % (rdn, basedn)

        self.ldbfile = os.path.join(self.tempdir, "test.ldb")
        self.ldburl = "tdb://" + self.ldbfile

        tempdir = self.tempdir

        class Target:
            """Simple helper class that contains data for a specific SAM
            connection."""

            def __init__(self, basedn, dn, lp):
                self.db = Ldb(lp=lp, session_info=system_session())
                self.db.set_opaque("skip_allocate_sids", "true");
                self.basedn = basedn
                self.basedn_casefold = ldb.Dn(self.db, basedn).get_casefold()
                self.substvars = {"BASEDN": self.basedn}
                self.file = os.path.join(tempdir, "%s.ldb" % self.basedn_casefold)
                self.url = "tdb://" + self.file
                self._dn = dn

            def dn(self, rdn):
                return self._dn(self.basedn, rdn)

            def connect(self):
                return self.db.connect(self.url)

            def setup_data(self, path):
                self.add_ldif(read_datafile(path))

            def subst(self, text):
                return substitute_var(text, self.substvars)

            def add_ldif(self, ldif):
                self.db.add_ldif(self.subst(ldif))

            def modify_ldif(self, ldif):
                self.db.modify_ldif(self.subst(ldif))

        self.samba4 = Target("dc=vernstok,dc=nl", make_s4dn, self.lp)
        self.samba3 = Target("cn=Samba3Sam", make_dn, self.lp)

        self.samba3.connect()
        self.samba4.connect()

    def tearDown(self):
        os.unlink(self.ldbfile)
        os.unlink(self.samba3.file)
        os.unlink(self.samba4.file)
        pdir = "%s.d" % self.ldbfile
        mdata = os.path.join(pdir, "metadata.tdb")
        if os.path.exists(mdata):
            os.unlink(mdata)
            os.rmdir(pdir)
        super(MapBaseTestCase, self).tearDown()

    def assertSidEquals(self, text, ndr_sid):
        sid_obj1 = samba.ndr.ndr_unpack(samba.dcerpc.security.dom_sid,
                                        str(ndr_sid[0]))
        sid_obj2 = samba.dcerpc.security.dom_sid(text)
        self.assertEquals(sid_obj1, sid_obj2)


class Samba3SamTestCase(MapBaseTestCase):

    def setUp(self):
        super(Samba3SamTestCase, self).setUp()
        ldb = Ldb(self.ldburl, lp=self.lp, session_info=system_session())
        ldb.set_opaque("skip_allocate_sids", "true");
        self.samba3.setup_data("samba3.ldif")
        ldif = read_datafile("provision_samba3sam.ldif")
        ldb.add_ldif(self.samba4.subst(ldif))
        self.setup_modules(ldb, self.samba3, self.samba4)
        del ldb
        self.ldb = Ldb(self.ldburl, lp=self.lp, session_info=system_session())
        self.ldb.set_opaque("skip_allocate_sids", "true");

    def test_search_non_mapped(self):
        """Looking up by non-mapped attribute"""
        msg = self.ldb.search(expression="(cn=Administrator)")
        self.assertEquals(len(msg), 1)
        self.assertEquals(msg[0]["cn"], "Administrator")

    def test_search_non_mapped(self):
        """Looking up by mapped attribute"""
        msg = self.ldb.search(expression="(name=Backup Operators)")
        self.assertEquals(len(msg), 1)
        self.assertEquals(str(msg[0]["name"]), "Backup Operators")

    def test_old_name_of_renamed(self):
        """Looking up by old name of renamed attribute"""
        msg = self.ldb.search(expression="(displayName=Backup Operators)")
        self.assertEquals(len(msg), 0)

    def test_mapped_containing_sid(self):
        """Looking up mapped entry containing SID"""
        msg = self.ldb.search(expression="(cn=Replicator)")
        self.assertEquals(len(msg), 1)
        self.assertEquals(str(msg[0].dn),
                          "cn=Replicator,ou=Groups,dc=vernstok,dc=nl")
        self.assertTrue("objectSid" in msg[0])
        self.assertSidEquals("S-1-5-21-4231626423-2410014848-2360679739-1052",
                             msg[0]["objectSid"])
        oc = set(msg[0]["objectClass"])
        self.assertEquals(oc, set(["group"]))

    def test_search_by_objclass(self):
        """Looking up by objectClass"""
        msg = self.ldb.search(expression="(|(objectClass=user)(cn=Administrator))")
        self.assertEquals(set([str(m.dn) for m in msg]),
                set(["unixName=Administrator,ou=Users,dc=vernstok,dc=nl",
                     "unixName=nobody,ou=Users,dc=vernstok,dc=nl"]))

    def test_s3sam_modify(self):
        # Adding a record that will be fallbacked
        self.ldb.add({
            "dn": "cn=Foo",
            "foo": "bar",
            "blah": "Blie",
            "cn": "Foo",
            "showInAdvancedViewOnly": "TRUE"})

        # Checking for existence of record (local)
        # TODO: This record must be searched in the local database, which is
        # currently only supported for base searches
        # msg = ldb.search(expression="(cn=Foo)", ['foo','blah','cn','showInAdvancedViewOnly')]
        # TODO: Actually, this version should work as well but doesn't...
        #
        #
        msg = self.ldb.search(expression="(cn=Foo)", base="cn=Foo",
                scope=SCOPE_BASE,
                attrs=['foo','blah','cn','showInAdvancedViewOnly'])
        self.assertEquals(len(msg), 1)
        self.assertEquals(str(msg[0]["showInAdvancedViewOnly"]), "TRUE")
        self.assertEquals(str(msg[0]["foo"]), "bar")
        self.assertEquals(str(msg[0]["blah"]), "Blie")

        # Adding record that will be mapped
        self.ldb.add({"dn": "cn=Niemand,cn=Users,dc=vernstok,dc=nl",
                 "objectClass": "user",
                 "unixName": "bin",
                 "sambaUnicodePwd": "geheim",
                 "cn": "Niemand"})

        # Checking for existence of record (remote)
        msg = self.ldb.search(expression="(unixName=bin)",
                              attrs=['unixName','cn','dn', 'sambaUnicodePwd'])
        self.assertEquals(len(msg), 1)
        self.assertEquals(str(msg[0]["cn"]), "Niemand")
        self.assertEquals(str(msg[0]["sambaUnicodePwd"]), "geheim")

        # Checking for existence of record (local && remote)
        msg = self.ldb.search(expression="(&(unixName=bin)(sambaUnicodePwd=geheim))",
                         attrs=['unixName','cn','dn', 'sambaUnicodePwd'])
        self.assertEquals(len(msg), 1)           # TODO: should check with more records
        self.assertEquals(str(msg[0]["cn"]), "Niemand")
        self.assertEquals(str(msg[0]["unixName"]), "bin")
        self.assertEquals(str(msg[0]["sambaUnicodePwd"]), "geheim")

        # Checking for existence of record (local || remote)
        msg = self.ldb.search(expression="(|(unixName=bin)(sambaUnicodePwd=geheim))",
                         attrs=['unixName','cn','dn', 'sambaUnicodePwd'])
        #print "got %d replies" % len(msg)
        self.assertEquals(len(msg), 1)        # TODO: should check with more records
        self.assertEquals(str(msg[0]["cn"]), "Niemand")
        self.assertEquals(str(msg[0]["unixName"]), "bin")
        self.assertEquals(str(msg[0]["sambaUnicodePwd"]), "geheim")

        # Checking for data in destination database
        msg = self.samba3.db.search(expression="(cn=Niemand)")
        self.assertTrue(len(msg) >= 1)
        self.assertEquals(str(msg[0]["sambaSID"]),
                "S-1-5-21-4231626423-2410014848-2360679739-2001")
        self.assertEquals(str(msg[0]["displayName"]), "Niemand")

        # Adding attribute...
        self.ldb.modify_ldif("""
dn: cn=Niemand,cn=Users,dc=vernstok,dc=nl
changetype: modify
add: description
description: Blah
""")

        # Checking whether changes are still there...
        msg = self.ldb.search(expression="(cn=Niemand)")
        self.assertTrue(len(msg) >= 1)
        self.assertEquals(str(msg[0]["cn"]), "Niemand")
        self.assertEquals(str(msg[0]["description"]), "Blah")

        # Modifying attribute...
        self.ldb.modify_ldif("""
dn: cn=Niemand,cn=Users,dc=vernstok,dc=nl
changetype: modify
replace: description
description: Blie
""")

        # Checking whether changes are still there...
        msg = self.ldb.search(expression="(cn=Niemand)")
        self.assertTrue(len(msg) >= 1)
        self.assertEquals(str(msg[0]["description"]), "Blie")

        # Deleting attribute...
        self.ldb.modify_ldif("""
dn: cn=Niemand,cn=Users,dc=vernstok,dc=nl
changetype: modify
delete: description
""")

        # Checking whether changes are no longer there...
        msg = self.ldb.search(expression="(cn=Niemand)")
        self.assertTrue(len(msg) >= 1)
        self.assertTrue(not "description" in msg[0])

        # Renaming record...
        self.ldb.rename("cn=Niemand,cn=Users,dc=vernstok,dc=nl",
                        "cn=Niemand2,cn=Users,dc=vernstok,dc=nl")

        # Checking whether DN has changed...
        msg = self.ldb.search(expression="(cn=Niemand2)")
        self.assertEquals(len(msg), 1)
        self.assertEquals(str(msg[0].dn),
                          "cn=Niemand2,cn=Users,dc=vernstok,dc=nl")

        # Deleting record...
        self.ldb.delete("cn=Niemand2,cn=Users,dc=vernstok,dc=nl")

        # Checking whether record is gone...
        msg = self.ldb.search(expression="(cn=Niemand2)")
        self.assertEquals(len(msg), 0)


class MapTestCase(MapBaseTestCase):

    def setUp(self):
        super(MapTestCase, self).setUp()
        ldb = Ldb(self.ldburl, lp=self.lp, session_info=system_session())
        ldb.set_opaque("skip_allocate_sids", "true");
        ldif = read_datafile("provision_samba3sam.ldif")
        ldb.add_ldif(self.samba4.subst(ldif))
        self.setup_modules(ldb, self.samba3, self.samba4)
        del ldb
        self.ldb = Ldb(self.ldburl, lp=self.lp, session_info=system_session())
        self.ldb.set_opaque("skip_allocate_sids", "true");

    def test_map_search(self):
        """Running search tests on mapped data."""
        self.samba3.db.add({
            "dn": "sambaDomainName=TESTS," + self.samba3.basedn,
            "objectclass": ["sambaDomain", "top"],
            "sambaSID": "S-1-5-21-4231626423-2410014848-2360679739",
            "sambaNextRid": "2000",
            "sambaDomainName": "TESTS"
            })

        # Add a set of split records
        self.ldb.add_ldif("""
dn: """+ self.samba4.dn("cn=Domain Users") + """
objectClass: group
cn: Domain Users
objectSid: S-1-5-21-4231626423-2410014848-2360679739-513
""")

        # Add a set of split records
        self.ldb.add_ldif("""
dn: """+ self.samba4.dn("cn=X") + """
objectClass: user
cn: X
codePage: x
revision: x
dnsHostName: x
nextRid: y
lastLogon: x
description: x
objectSid: S-1-5-21-4231626423-2410014848-2360679739-1052
""")

        self.ldb.add({
            "dn": self.samba4.dn("cn=Y"),
            "objectClass": "top",
            "cn": "Y",
            "codePage": "x",
            "revision": "x",
            "dnsHostName": "y",
            "nextRid": "y",
            "lastLogon": "y",
            "description": "x"})

        self.ldb.add({
            "dn": self.samba4.dn("cn=Z"),
            "objectClass": "top",
            "cn": "Z",
            "codePage": "x",
            "revision": "y",
            "dnsHostName": "z",
            "nextRid": "y",
            "lastLogon": "z",
            "description": "y"})

        # Add a set of remote records

        self.samba3.db.add({
            "dn": self.samba3.dn("cn=A"),
            "objectClass": "posixAccount",
            "cn": "A",
            "sambaNextRid": "x",
            "sambaBadPasswordCount": "x",
            "sambaLogonTime": "x",
            "description": "x",
            "sambaSID": "S-1-5-21-4231626423-2410014848-2360679739-1052",
            "sambaPrimaryGroupSID": "S-1-5-21-4231626423-2410014848-2360679739-512"})

        self.samba3.db.add({
            "dn": self.samba3.dn("cn=B"),
            "objectClass": "top",
            "cn": "B",
            "sambaNextRid": "x",
            "sambaBadPasswordCount": "x",
            "sambaLogonTime": "y",
            "description": "x"})

        self.samba3.db.add({
            "dn": self.samba3.dn("cn=C"),
            "objectClass": "top",
            "cn": "C",
            "sambaNextRid": "x",
            "sambaBadPasswordCount": "y",
            "sambaLogonTime": "z",
            "description": "y"})

        # Testing search by DN

        # Search remote record by local DN
        dn = self.samba4.dn("cn=A")
        res = self.ldb.search(dn, scope=SCOPE_BASE,
                attrs=["dnsHostName", "lastLogon"])
        self.assertEquals(len(res), 1)
        self.assertEquals(str(res[0].dn), dn)
        self.assertTrue(not "dnsHostName" in res[0])
        self.assertEquals(str(res[0]["lastLogon"]), "x")

        # Search remote record by remote DN
        dn = self.samba3.dn("cn=A")
        res = self.samba3.db.search(dn, scope=SCOPE_BASE,
                attrs=["dnsHostName", "lastLogon", "sambaLogonTime"])
        self.assertEquals(len(res), 1)
        self.assertEquals(str(res[0].dn), dn)
        self.assertTrue(not "dnsHostName" in res[0])
        self.assertTrue(not "lastLogon" in res[0])
        self.assertEquals(str(res[0]["sambaLogonTime"]), "x")

        # Search split record by local DN
        dn = self.samba4.dn("cn=X")
        res = self.ldb.search(dn, scope=SCOPE_BASE,
                attrs=["dnsHostName", "lastLogon"])
        self.assertEquals(len(res), 1)
        self.assertEquals(str(res[0].dn), dn)
        self.assertEquals(str(res[0]["dnsHostName"]), "x")
        self.assertEquals(str(res[0]["lastLogon"]), "x")

        # Search split record by remote DN
        dn = self.samba3.dn("cn=X")
        res = self.samba3.db.search(dn, scope=SCOPE_BASE,
                attrs=["dnsHostName", "