" netrw.vim: Handles file transfer and remote directory listing across
"            AUTOLOAD SECTION
" Date:		Apr 20, 2016
" Version:	156
" Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
" GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
" Copyright:    Copyright (C) 2016 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
"               *as is* and come with no warranty of any kind, either
"               expressed or implied. By using this plugin, you agree that
"               in no event will the copyright holder be liable for any damages
"               resulting from the use of this software.
"redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
"
"  But be doers of the Word, and not only hearers, deluding your own selves {{{1
"  (James 1:22 RSV)
" =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
" Load Once: {{{1
if &cp || exists("g:loaded_netrw")
  finish
endif
" netrw requires vim having patch 7.4.213; netrw will benefit from vim's having patch#656, too
if v:version < 704 || (v:version == 704 && !has("patch213"))
 if !exists("s:needpatch213")
  unsilent echomsg "***sorry*** this version of netrw requires vim v7.4 with patch 213"
 endif
 let s:needpatch213= 1
 finish
endif
let g:loaded_netrw = "v156"
if !exists("s:NOTE")
 let s:NOTE    = 0
 let s:WARNING = 1
 let s:ERROR   = 2
endif

let s:keepcpo= &cpo
setl cpo&vim
"let g:dechofuncname= 1
"DechoRemOn
"call Decho("doing autoload/netrw.vim version ".g:loaded_netrw,'~'.expand("<slnum>"))

" ======================
"  Netrw Variables: {{{1
" ======================

" ---------------------------------------------------------------------
" netrw#ErrorMsg: {{{2
"   0=note     = s:NOTE
"   1=warning  = s:WARNING
"   2=error    = s:ERROR
"   Usage: netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,"some message",error-number)
"          netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,["message1","message2",...],error-number)
"          (this function can optionally take a list of messages)
"  Jan 19, 2016 : max errnum currently is 103
fun! netrw#ErrorMsg(level,msg,errnum)
"  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)

  if a:level < g:netrw_errorlvl
"   call Dret("netrw#ErrorMsg : suppressing level=".a:level." since g:netrw_errorlvl=".g:netrw_errorlvl)
   return
  endif

  if a:level == 1
   let level= "**warning** (netrw) "
  elseif a:level == 2
   let level= "**error** (netrw) "
  else
   let level= "**note** (netrw) "
  endif
"  call Decho("level=".level,'~'.expand("<slnum>"))

  if g:netrw_use_errorwindow
   " (default) netrw creates a one-line window to show error/warning
   " messages (reliably displayed)

   " record current window number
   let s:winBeforeErr= winnr()
"   call Decho("s:winBeforeErr=".s:winBeforeErr,'~'.expand("<slnum>"))

   " getting messages out reliably is just plain difficult!
   " This attempt splits the current window, creating a one line window.
   if bufexists("NetrwMessage") && bufwinnr("NetrwMessage") > 0
"    call Decho("write to NetrwMessage buffer",'~'.expand("<slnum>"))
    exe bufwinnr("NetrwMessage")."wincmd w"
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    setl ma noro
    if type(a:msg) == 3
     for msg in a:msg
      NetrwKeepj call setline(line("$")+1,level.msg)
     endfor
    else
     NetrwKeepj call setline(line("$")+1,level.a:msg)
    endif
    NetrwKeepj $
   else
"    call Decho("create a NetrwMessage buffer window",'~'.expand("<slnum>"))
    bo 1split
    sil! call s:NetrwEnew()
    sil! NetrwKeepj call s:NetrwSafeOptions()
    setl bt=nofile
    NetrwKeepj file NetrwMessage
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    setl ma noro
    if type(a:msg) == 3
     for msg in a:msg
      NetrwKeepj call setline(line("$")+1,level.msg)
     endfor
    else
     NetrwKeepj call setline(line("$"),level.a:msg)
    endif
    NetrwKeepj $
   endif
"   call Decho("wrote msg<".level.a:msg."> to NetrwMessage win#".winnr(),'~'.expand("<slnum>"))
   if &fo !~ '[ta]'
    syn clear
    syn match netrwMesgNote	"^\*\*note\*\*"
    syn match netrwMesgWarning	"^\*\*warning\*\*"
    syn match netrwMesgError	"^\*\*error\*\*"
    hi link netrwMesgWarning WarningMsg
    hi link netrwMesgError   Error
   endif
"   call Decho("setl noma ro bh=wipe",'~'.expand("<slnum>"))
   setl ro nomod noma bh=wipe

  else
   " (optional) netrw will show messages using echomsg.  Even if the
   " message doesn't appear, at least it'll be recallable via :messages
"   redraw!
   if a:level == s:WARNING
    echohl WarningMsg
   elseif a:level == s:ERROR
    echohl Error
   endif

   if type(a:msg) == 3
     for msg in a:msg
      unsilent echomsg level.msg
     endfor
   else
    unsilent echomsg level.a:msg
   endif

"   call Decho("echomsg ***netrw*** ".a:msg,'~'.expand("<slnum>"))
   echohl None
  endif

"  call Dret("netrw#ErrorMsg")
endfun

" ---------------------------------------------------------------------
" s:NetrwInit: initializes variables if they haven't been defined {{{2
"            Loosely,  varname = value.
fun s:NetrwInit(varname,value)
" call Decho("varname<".a:varname."> value=".a:value,'~'.expand("<slnum>"))
  if !exists(a:varname)
   if type(a:value) == 0
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1 && a:value =~ '^[{[]'
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1
    exe "let ".a:varname."="."'".a:value."'"
   else
    exe "let ".a:varname."=".a:value
   endif
  endif
endfun

" ---------------------------------------------------------------------
"  Netrw Constants: {{{2
call s:NetrwInit("g:netrw_dirhist_cnt",0)
if !exists("s:LONGLIST")
 call s:NetrwInit("s:THINLIST",0)
 call s:NetrwInit("s:LONGLIST",1)
 call s:NetrwInit("s:WIDELIST",2)
 call s:NetrwInit("s:TREELIST",3)
 call s:NetrwInit("s:MAXLIST" ,4)
endif

" ---------------------------------------------------------------------
" Default values for netrw's global protocol variables {{{2
call s:NetrwInit("g:netrw_use_errorwindow",1)

if !exists("g:netrw_dav_cmd")
 if executable("cadaver")
  let g:netrw_dav_cmd	= "cadaver"
 elseif executable("curl")
  let g:netrw_dav_cmd	= "curl"
 else
  let g:netrw_dav_cmd   = ""
 endif
endif
if !exists("g:netrw_fetch_cmd")
 if executable("fetch")
  let g:netrw_fetch_cmd	= "fetch -o"
 else
  let g:netrw_fetch_cmd	= ""
 endif
endif
if !exists("g:netrw_file_cmd")
 if executable("elinks")
  call s:NetrwInit("g:netrw_file_cmd","elinks")
 elseif executable("links")
  call s:NetrwInit("g:netrw_file_cmd","links")
 endif
endif
if !exists("g:netrw_ftp_cmd")
  let g:netrw_ftp_cmd	= "ftp"
endif
let s:netrw_ftp_cmd= g:netrw_ftp_cmd
if !exists("g:netrw_ftp_options")
 let g:netrw_ftp_options= "-i -n"
endif
if !exists("g:netrw_http_cmd")
 if executable("elinks")
  let g:netrw_http_cmd = "elinks"
  call s:NetrwInit("g:netrw_http_xcmd","-source >")
 elseif executable("links")
  let g:netrw_http_cmd = "links"
  call s:NetrwInit("g:netrw_http_xcmd","-source >")
 elseif executable("curl")
  let g:netrw_http_cmd	= "curl"
  call s:NetrwInit("g:netrw_http_xcmd","-o")
 elseif executable("wget")
  let g:netrw_http_cmd	= "wget"
  call s:NetrwInit("g:netrw_http_xcmd","-q -O")
 elseif executable("fetch")
  let g:netrw_http_cmd	= "fetch"
  call s:NetrwInit("g:netrw_http_xcmd","-o")
 else
  let g:netrw_http_cmd	= ""
 endif
endif
call s:NetrwInit("g:netrw_http_put_cmd","curl -T")
call s:NetrwInit("g:netrw_keepj","keepj")
call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
if !exists("g:netrw_scp_cmd")
 if executable("scp")
  call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
 elseif executable("pscp")
  if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable('c:\private.ppk')
   call s:NetrwInit("g:netrw_scp_cmd", 'pscp -i c:\private.ppk')
  else
   call s:NetrwInit("g:netrw_scp_cmd", 'pscp -q')
  endif
 else
  call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
 endif
endif

call s:NetrwInit("g:netrw_sftp_cmd" , "sftp")
call s:NetrwInit("g:netrw_ssh_cmd"  , "ssh")

if (has("win32") || has("win95") || has("win64") || has("win16"))
  \ && exists("g:netrw_use_nt_rcp")
  \ && g:netrw_use_nt_rcp
  \ && executable( $SystemRoot .'/system32/rcp.exe')
 let s:netrw_has_nt_rcp = 1
 let s:netrw_rcpmode    = '-b'
else
 let s:netrw_has_nt_rcp = 0
 let s:netrw_rcpmode    = ''
endif

" ---------------------------------------------------------------------
" Default values for netrw's global variables {{{2
" Cygwin Detection ------- {{{3
if !exists("g:netrw_cygwin")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if  has("win32unix") && &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
   let g:netrw_cygwin= 1
  else
   let g:netrw_cygwin= 0
  endif
 else
  let g:netrw_cygwin= 0
 endif
endif
" Default values - a-c ---------- {{{3
call s:NetrwInit("g:netrw_alto"        , &sb)
call s:NetrwInit("g:netrw_altv"        , &spr)
call s:NetrwInit("g:netrw_banner"      , 1)
call s:NetrwInit("g:netrw_browse_split", 0)
call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro nornu")
call s:NetrwInit("g:netrw_chgwin"      , -1)
call s:NetrwInit("g:netrw_compress"    , "gzip")
call s:NetrwInit("g:netrw_ctags"       , "ctags")
if exists("g:netrw_cursorline") && !exists("g:netrw_cursor")
 call netrw#ErrorMsg(s:NOTE,'g:netrw_cursorline is deprecated; use g:netrw_cursor instead',77)
 let g:netrw_cursor= g:netrw_cursorline
endif
call s:NetrwInit("g:netrw_cursor"      , 2)
let s:netrw_usercul = &cursorline
let s:netrw_usercuc = &cursorcolumn
call s:NetrwInit("g:netrw_cygdrive","/cygdrive")
" Default values - d-g ---------- {{{3
call s:NetrwInit("s:didstarstar",0)
call s:NetrwInit("g:netrw_dirhist_cnt"      , 0)
call s:NetrwInit("g:netrw_decompress"       , '{ ".gz" : "gunzip", ".bz2" : "bunzip2", ".zip" : "unzip", ".tar" : "tar -xf", ".xz" : "unxz" }')
call s:NetrwInit("g:netrw_dirhistmax"       , 10)
call s:NetrwInit("g:netrw_errorlvl"  , s:NOTE)
call s:NetrwInit("g:netrw_fastbrowse"       , 1)
call s:NetrwInit("g:netrw_ftp_browse_reject", '^total\s\+\d\+$\|^Trying\s\+\d\+.*$\|^KERBEROS_V\d rejected\|^Security extensions not\|No such file\|: connect to address [0-9a-fA-F:]*: No route to host$')
if !exists("g:netrw_ftp_list_cmd")
 if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
  let g:netrw_ftp_list_cmd     = "ls -lF"
  let g:netrw_ftp_timelist_cmd = "ls -tlF"
  let g:netrw_ftp_sizelist_cmd = "ls -slF"
 else
  let g:netrw_ftp_list_cmd     = "dir"
  let g:netrw_ftp_timelist_cmd = "dir"
  let g:netrw_ftp_sizelist_cmd = "dir"
 endif
endif
call s:NetrwInit("g:netrw_ftpmode",'binary')
" Default values - h-lh ---------- {{{3
call s:NetrwInit("g:netrw_hide",1)
if !exists("g:netrw_ignorenetrc")
 if &shell =~ '\c\<\%(cmd\|4nt\)\.exe$'
  let g:netrw_ignorenetrc= 1
 else
  let g:netrw_ignorenetrc= 0
 endif
endif
call s:NetrwInit("g:netrw_keepdir",1)
if !exists("g:netrw_list_cmd")
 if g:netrw_scp_cmd =~ '^pscp' && executable("pscp")
  if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable("c:\\private.ppk")
   " provide a pscp-based listing command
   let g:netrw_scp_cmd ="pscp -i C:\\private.ppk"
  endif
  if exists("g:netrw_list_cmd_options")
   let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME: ".g:netrw_list_cmd_options
  else
   let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME:"
  endif
 elseif executable(g:netrw_ssh_cmd)
  " provide a scp-based default listing command
  if exists("g:netrw_list_cmd_options")
   let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa ".g:netrw_list_cmd_options
  else
   let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa"
  endif
 else
"  call Decho(g:netrw_ssh_cmd." is not executable",'~'.expand("<slnum>"))
  let g:netrw_list_cmd= ""
 endif
endif
call s:NetrwInit("g:netrw_list_hide","")
" Default values - lh-lz ---------- {{{3
if exists("g:netrw_local_copycmd")
 let g:netrw_localcopycmd= g:netrw_local_copycmd
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_copycmd is deprecated in favor of g:netrw_localcopycmd",84)
endif
if !exists("g:netrw_localcmdshell")
 let g:netrw_localcmdshell= ""
endif
if !exists("g:netrw_localcopycmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localcopycmd= "cp"
  else
   let g:netrw_localcopycmd= expand("$COMSPEC")." /c copy"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localcopycmd= "cp"
 else
  let g:netrw_localcopycmd= ""
 endif
endif
if !exists("g:netrw_localcopydircmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localcopydircmd= "cp -R"
  else
   let g:netrw_localcopycmd= expand("$COMSPEC")." /c xcopy /e /c /h /i /k"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localcopydircmd= "cp -R"
 else
  let g:netrw_localcopycmd= ""
 endif
endif
if exists("g:netrw_local_mkdir")
 let g:netrw_localmkdir= g:netrw_local_mkdir
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_mkdir is deprecated in favor of g:netrw_localmkdir",87)
endif
if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   call s:NetrwInit("g:netrw_localmkdir","mkdir")
  else
   let g:netrw_localmkdir= expand("$COMSPEC")." /c mkdir"
  endif
else
 call s:NetrwInit("g:netrw_localmkdir","mkdir")
endif
call s:NetrwInit("g:netrw_remote_mkdir","mkdir")
if exists("g:netrw_local_movecmd")
 let g:netrw_localmovecmd= g:netrw_local_movecmd
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_movecmd is deprecated in favor of g:netrw_localmovecmd",88)
endif
if !exists("g:netrw_localmovecmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localmovecmd= "mv"
  else
   let g:netrw_localmovecmd= expand("$COMSPEC")." /c move"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localmovecmd= "mv"
 else
  let g:netrw_localmovecmd= ""
 endif
endif
if v:version < 704 || !has("patch1109")
 if exists("g:netrw_local_rmdir")
  let g:netrw_localrmdir= g:netrw_local_rmdir
  call netrw#ErrorMsg(s:NOTE,"g:netrw_local_rmdir is deprecated in favor of g:netrw_localrmdir",86)
 endif
 if has("win32") || has("win95") || has("win64") || has("win16")
   if g:netrw_cygwin
    call s:NetrwInit("g:netrw_localrmdir","rmdir")
   else
    let g:netrw_localrmdir= expand("$COMSPEC")." /c rmdir"
   endif
 else
  call s:NetrwInit("g:netrw_localrmdir","rmdir")
 endif
endif
call s:NetrwInit("g:netrw_liststyle"  , s:THINLIST)
" sanity checks
if g:netrw_liststyle < 0 || g:netrw_liststyle >= s:MAXLIST
 let g:netrw_liststyle= s:THINLIST
endif
if g:netrw_liststyle == s:LONGLIST && g:netrw_scp_cmd !~ '^pscp'
 let g:netrw_list_cmd= g:netrw_list_cmd." -l"
endif
" Default values - m-r ---------- {{{3
call s:NetrwInit("g:netrw_markfileesc"   , '*./[\~')
call s:NetrwInit("g:netrw_maxfilenamelen", 32)
call s:NetrwInit("g:netrw_menu"          , 1)
call s:NetrwInit("g:netrw_mkdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME mkdir")
call s:NetrwInit("g:netrw_mousemaps"     , (exists("+mouse") && &mouse =~# '[anh]'))
call s:NetrwInit("g:netrw_retmap"        , 0)
if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
 call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
elseif has("win32") || has("win95") || has("win64") || has("win16")
 call s:NetrwInit("g:netrw_chgperm"       , "cacls FILENAME /e /p PERM")
else
 call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
endif
call s:NetrwInit("g:netrw_preview"       , 0)
call s:NetrwInit("g:netrw_scpport"       , "-P")
call s:NetrwInit("g:netrw_servername"    , "NETRWSERVER")
call s:NetrwInit("g:netrw_sshport"       , "-p")
call s:NetrwInit("g:netrw_rename_cmd"    , g:netrw_ssh_cmd." USEPORT HOSTNAME mv")
call s:NetrwInit("g:netrw_rm_cmd"        , g:netrw_ssh_cmd." USEPORT HOSTNAME rm")
call s:NetrwInit("g:netrw_rmdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME rmdir")
call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f ")
" Default values - q-s ---------- {{{3
call s:NetrwInit("g:netrw_quickhelp",0)
let s:QuickHelp= ["-:go up dir  D:delete  R:rename  s:sort-by  x:special",
   \              "(create new)  %:file  d:directory",
   \              "(windows split&open) o:horz  v:vert  p:preview",
   \              "i:style  qf:file info  O:obtain  r:reverse",
   \              "(marks)  mf:mark file  mt:set target  mm:move  mc:copy",
   \              "(bookmarks)  mb:make  mB:delete  qb:list  gb:go to",
   \              "(history)  qb:list  u:go up  U:go down",
   \              "(targets)  mt:target Tb:use bookmark  Th:use history"]
" g:netrw_sepchr: picking a character that doesn't appear in filenames that can be used to separate priority from filename
call s:NetrwInit("g:netrw_sepchr"        , (&enc == "euc-jp")? "\<Char-0x01>" : "\<Char-0xff>")
if !exists("g:netrw_keepj") || g:netrw_keepj == "keepj"
 call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil keepj " : "keepj ")
else
 call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil " : " ")
endif
call s:NetrwInit("g:netrw_sort_by"       , "name") " alternatives: date                                      , size
call s:NetrwInit("g:netrw_sort_options"  , "")
call s:NetrwInit("g:netrw_sort_direction", "normal") " alternative: reverse  (z y x ...)
if !exists("g:netrw_sort_sequence")
 if has("unix")
  let g:netrw_sort_sequence= '[\/]$,\<core\%(\.\d\+\)\=\>,\.h$,\.c$,\.cpp$,\~\=\*$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
 else
  let g:netrw_sort_sequence= '[\/]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
 endif
endif
call s:NetrwInit("g:netrw_special_syntax"   , 0)
call s:NetrwInit("g:netrw_ssh_browse_reject", '^total\s\+\d\+$')
call s:NetrwInit("g:netrw_suppress_gx_mesg",  1)
call s:NetrwInit("g:netrw_use_noswf"        , 1)
call s:NetrwInit("g:netrw_sizestyle"        ,"b")
" Default values - t-w ---------- {{{3
call s:NetrwInit("g:netrw_timefmt","%c")
if !exists("g:netrw_xstrlen")
 if exists("g:Align_xstrlen")
  let g:netrw_xstrlen= g:Align_xstrlen
 elseif exists("g:drawit_xstrlen")
  let g:netrw_xstrlen= g:drawit_xstrlen
 elseif &enc == "latin1" || !has("multi_byte")
  let g:netrw_xstrlen= 0
 else
  let g:netrw_xstrlen= 1
 endif
endif
call s:NetrwInit("g:NetrwTopLvlMenu","Netrw.")
call s:NetrwInit("g:netrw_win95ftp",1)
call s:NetrwInit("g:netrw_winsize",50)
call s:NetrwInit("g:netrw_wiw",1)
if g:netrw_winsize > 100|let g:netrw_winsize= 100|endif
" ---------------------------------------------------------------------
" Default values for netrw's script variables: {{{2
call s:NetrwInit("g:netrw_fname_escape",' ?&;%')
if has("win32") || has("win95") || has("win64") || has("win16")
 call s:NetrwInit("g:netrw_glob_escape",'*?`{[]$')
else
 call s:NetrwInit("g:netrw_glob_escape",'*[]?`{~$\')
endif
call s:NetrwInit("g:netrw_menu_escape",'.&? \')
call s:NetrwInit("g:netrw_tmpfile_escape",' &;')
call s:NetrwInit("s:netrw_map_escape","<|\n\r\\\<C-V>\"")
if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
 let s:treedepthstring= "â”‚ "
else
 let s:treedepthstring= "| "
endif
call s:NetrwInit("s:netrw_nbcd",'{}')

" BufEnter event ignored by decho when following variable is true
"  Has a side effect that doau BufReadPost doesn't work, so
"  files read by network transfer aren't appropriately highlighted.
"let g:decho_bufenter = 1	"Decho

" ======================
"  Netrw Initialization: {{{1
" ======================
if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
" call Decho("installed beval events",'~'.expand("<slnum>"))
 let &l:bexpr = "netrw#BalloonHelp()"
 au FileType netrw	setl beval
 au WinLeave *		if &ft == "netrw" && exists("s:initbeval")|let &beval= s:initbeval|endif
 au VimEnter * 		let s:initbeval= &beval
"else " Decho
" if v:version < 700           | call Decho("did not install beval events: v:version=".v:version." < 700","~".expand("<slnum>"))     | endif
" if !has("balloon_eval")      | call Decho("did not install beval events: does not have balloon_eval","~".expand("<slnum>"))        | endif
" if exists("s:initbeval")     | call Decho("did not install beval events: s:initbeval exists","~".expand("<slnum>"))                | endif
" if exists("g:netrw_nobeval") | call Decho("did not install beval events: g:netrw_nobeval exists","~".expand("<slnum>"))            | endif
" if !has("syntax")            | call Decho("did not install beval events: does not have syntax highlighting","~".expand("<slnum>")) | endif
" if exists("g:syntax_on")     | call Decho("did not install beval events: g:syntax_on exists","~".expand("<slnum>"))                | endif
endif
au WinEnter *	if &ft == "netrw"|call s:NetrwInsureWinVars()|endif

if g:netrw_keepj =~# "keepj"
 com! -nargs=*	NetrwKeepj	keepj <args>
else
 let g:netrw_keepj= ""
 com! -nargs=*	NetrwKeepj	<args>
endif

" ==============================
"  Netrw Utility Functions: {{{1
" ==============================

" ---------------------------------------------------------------------
" netrw#BalloonHelp: {{{2
if v:version >= 700 && has("balloon_eval") && has("syntax") && exists("g:syntax_on") && !exists("g:netrw_nobeval")
" call Decho("loading netrw#BalloonHelp()",'~'.expand("<slnum>"))
 fun! netrw#BalloonHelp()
   if &ft != "netrw"
    return ""
   endif
   if !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
    let mesg= ""
   elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
    let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
   elseif     getline(v:beval_lnum) =~ '^"\s*/'
    let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
   elseif     v:beval_text == "Sorted" || v:beval_text == "by"
    let mesg = 's: sort by name, time, file size, extension   r: reverse sorting order   mt: mark target'
   elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
    let mesg = "S: edit sorting sequence"
   elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
    let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
   elseif v:beval_text == "Quick" || v:beval_text == "Help"
    let mesg = "Help: press <F1>"
   elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
    let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
   else
    let mesg= ""
   endif
   return mesg
 endfun
"else " Decho
" if v:version < 700            |call Decho("did not load netrw#BalloonHelp(): vim version ".v:version." < 700 -","~".expand("<slnum>"))|endif
" if !has("balloon_eval")       |call Decho("did not load netrw#BalloonHelp(): does not have balloon eval","~".expand("<slnum>"))       |endif
" if !has("syntax")             |call Decho("did not load netrw#BalloonHelp(): syntax disabled","~".expand("<slnum>"))                  |endif
" if !exists("g:syntax_on")     |call Decho("did not load netrw#BalloonHelp(): g:syntax_on n/a","~".expand("<slnum>"))                  |endif
" if  exists("g:netrw_nobeval") |call Decho("did not load netrw#BalloonHelp(): g:netrw_nobeval exists","~".expand("<slnum>"))           |endif
endif

" ------------------------------------------------------------------------
" netrw#Explore: launch the local browser in the directory of the current file {{{2
"          indx:  == -1: Nexplore
"                 == -2: Pexplore
"                 ==  +: this is overloaded:
"                      * If Nexplore/Pexplore is in use, then this refers to the
"                        indx'th item in the w:netrw_explore_list[] of items which
"                        matched the */pattern **/pattern *//pattern **//pattern
"                      * If Hexplore or Vexplore, then this will override
"                        g:netrw_winsize to specify the qty of rows or columns the
"                        newly split window should have.
"          dosplit==0: the window will be split iff the current file has been modified and hidden not set
"          dosplit==1: the window will be split before running the local browser
"          style == 0: Explore     style == 1: Explore!
"                == 2: Hexplore    style == 3: Hexplore!
"                == 4: Vexplore    style == 5: Vexplore!
"                == 6: Texplore
fun! netrw#Explore(indx,dosplit,style,...)
"  call Dfunc("netrw#Explore(indx=".a:indx." dosplit=".a:dosplit." style=".a:style.",a:1<".a:1.">) &modified=".&modified." modifiable=".&modifiable." a:0=".a:0." win#".winnr()." buf#".bufnr("%")." ft=".&ft)
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)",'~'.expand("<slnum>"))
  endif

  " record current file for Rexplore's benefit
  if &ft != "netrw"
   let w:netrw_rexfile= expand("%:p")
  endif

  " record current directory
  let curdir     = simplify(b:netrw_curdir)
  let curfiledir = substitute(expand("%:p"),'^\(.*[/\\]\)[^/\\]*$','\1','e')
  if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
   let curdir= substitute(curdir,'\','/','g')
  endif
"  call Decho("curdir<".curdir.">  curfiledir<".curfiledir.">",'~'.expand("<slnum>"))

  " using completion, directories with spaces in their names (thanks, Bill Gates, for a truly dumb idea)
  " will end up with backslashes here.  Solution: strip off backslashes that precede white space and
  " try Explore again.
  if a:0 > 0
"   call Decho('considering retry: a:1<'.a:1.'>: '.
     \ ((a:1 =~ "\\\s")?                   'has backslash whitespace' : 'does not have backslash whitespace').', '.
     \ ((filereadable(s:NetrwFile(a:1)))?  'is readable'              : 'is not readable').', '.
     \ ((isdirectory(s:NetrwFile(a:1))))?  'is a directory'           : 'is not a directory',
     \ '~'.expand("<slnum>"))
   if a:1 =~ "\\\s" && !filereadable(s:NetrwFile(a:1)) && !isdirectory(s:NetrwFile(a:1))
"    call Decho("re-trying Explore with <".substitute(a:1,'\\\(\s\)','\1','g').">",'~'.expand("<slnum>"))
    call netrw#Explore(a:indx,a:dosplit,a:style,substitute(a:1,'\\\(\s\)','\1','g'))
"    call Dret("netrw#Explore : returning from retry")
    return
"   else " Decho
"    call Decho("retry not needed",'~'.expand("<slnum>"))
   endif
  endif

  " save registers
  if has("clipboard")
   sil! let keepregstar = @*
   sil! let keepregplus = @+
  endif
  sil! let keepregslash= @/

  " if   dosplit
  " -or- file has been modified AND file not hidden when abandoned
  " -or- Texplore used
  if a:dosplit || (&modified && &hidden == 0 && &bufhidden != "hide") || a:style == 6
"   call Decho("case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified",'~'.expand("<slnum>"))
   call s:SaveWinVars()
   let winsz= g:netrw_winsize
   if a:indx > 0
    let winsz= a:indx
   endif

   if a:style == 0      " Explore, Sexplore
"    call Decho("style=0: Explore or Sexplore",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "noswapfile ".winsz."wincmd s"
"    call Decho("exe noswapfile ".winsz."wincmd s",'~'.expand("<slnum>"))

   elseif a:style == 1  "Explore!, Sexplore!
"    call Decho("style=1: Explore! or Sexplore!",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile ".winsz."wincmd v",'~'.expand("<slnum>"))

   elseif a:style == 2  " Hexplore
"    call Decho("style=2: Hexplore",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile bel ".winsz."wincmd s"
"    call Decho("exe keepalt noswapfile bel ".winsz."wincmd s",'~'.expand("<slnum>"))

   elseif a:style == 3  " Hexplore!
"    call Decho("style=3: Hexplore!",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile abo ".winsz."wincmd s"
"    call Decho("exe keepalt noswapfile abo ".winsz."wincmd s",'~'.expand("<slnum>"))

   elseif a:style == 4  " Vexplore
"    call Decho("style=4: Vexplore",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile lefta ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile lefta ".winsz."wincmd v",'~'.expand("<slnum>"))

   elseif a:style == 5  " Vexplore!
"    call Decho("style=5: Vexplore!",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile rightb ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile rightb ".winsz."wincmd v",'~'.expand("<slnum>"))

   elseif a:style == 6  " Texplore
    call s:SaveBufVars()
"    call Decho("style  = 6: Texplore",'~'.expand("<slnum>"))
    exe "keepalt tabnew ".fnameescape(curdir)
"    call Decho("exe keepalt tabnew ".fnameescape(curdir),'~'.expand("<slnum>"))
    call s:RestoreBufVars()
   endif
   call s:RestoreWinVars()
"  else " Decho
"   call Decho("case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6",'~'.expand("<slnum>"))
  endif
  NetrwKeepj norm! 0

  if a:0 > 0
"   call Decho("case [a:0=".a:0."] > 0: a:1<".a:1.">",'~'.expand("<slnum>"))
   if a:1 =~ '^\~' && (has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin))
"    call Decho("..case a:1<".a:1.">: starts with ~ and unix or cygwin",'~'.expand("<slnum>"))
    let dirname= simplify(substitute(a:1,'\~',expand("$HOME"),''))
"    call Decho("..using dirname<".dirname.">  (case: ~ && unix||cygwin)",'~'.expand("<slnum>"))
   elseif a:1 == '.'
"    call Decho("..case a:1<".a:1.">: matches .",'~'.expand("<slnum>"))
    let dirname= simplify(exists("b:netrw_curdir")? b:netrw_curdir : getcwd())
    if dirname !~ '/$'
     let dirname= dirname."/"
    endif
"    call Decho("..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")",'~'.expand("<slnum>"))
   elseif a:1 =~ '\$'
"    call Decho("..case a:1<".a:1.">: matches ending $",'~'.expand("<slnum>"))
    let dirname= simplify(expand(a:1))
"    call Decho("..using user-specified dirname<".dirname."> with $env-var",'~'.expand("<slnum>"))
   elseif a:1 !~ '^\*\{1,2}/' && a:1 !~ '^\a\{3,}://'
"    call Decho("..case a:1<".a:1.">: other, not pattern or filepattern",'~'.expand("<slnum>"))
    let dirname= simplify(a:1)
"    call Decho("..using user-specified dirname<".dirname.">",'~'.expand("<slnum>"))
   else
"    call Decho("..case a:1: pattern or filepattern",'~'.expand("<slnum>"))
    let dirname= a:1
   endif
  else
   " clear explore
"   call Decho("case a:0=".a:0.": clearing Explore list",'~'.expand("<slnum>"))
   call s:NetrwClearExplore()
"   call Dret("netrw#Explore : cleared list")
   return
  endif

"  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))
  if dirname =~ '\.\./\=$'
   let dirname= simplify(fnamemodify(dirname,':p:h'))
  elseif dirname =~ '\.\.' || dirname == '.'
   let dirname= simplify(fnamemodify(dirname,':p'))
  endif
"  call Decho("dirname<".dirname.">  (after simplify)",'~'.expand("<slnum>"))

  if dirname =~ '^\*//'
   " starpat=1: Explore *//pattern   (current directory only search for files containing pattern)
"   call Decho("case starpat=1: Explore *//pattern",'~'.expand("<slnum>"))
   let pattern= substitute(dirname,'^\*//\(.*\)$','\1','')
   let starpat= 1
"   call Decho("..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">",'~'.expand("<slnum>"))
   if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

  elseif dirname =~ '^\*\*//'
   " starpat=2: Explore **//pattern  (recursive descent search for files containing pattern)
"   call Decho("case starpat=2: Explore **//pattern",'~'.expand("<slnum>"))
   let pattern= substitute(dirname,'^\*\*//','','')
   let starpat= 2
"   call Decho("..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">",'~'.expand("<slnum>"))

  elseif dirname =~ '/\*\*/'
   " handle .../**/.../filepat
"   call Decho("case starpat=4: Explore .../**/.../filepat",'~'.expand("<slnum>"))
   let prefixdir= substitute(dirname,'^\(.\{-}\)\*\*.*$','\1','')
   if prefixdir =~ '^/' || (prefixdir =~ '^\a:/' && (has("win32") || has("win95") || has("win64") || has("win16")))
    let b:netrw_curdir = prefixdir
   else
    let b:netrw_curdir= getcwd().'/'.prefixdir
   endif
   let dirname= substitute(dirname,'^.\{-}\(\*\*/.*\)$','\1','')
   let starpat= 4
"   call Decho("..pwd<".getcwd()."> dirname<".dirname.">",'~'.expand("<slnum>"))
"   call Decho("..case Explore ../**/../filepat (starpat=".starpat.")",'~'.expand("<slnum>"))

  elseif dirname =~ '^\*/'
   " case starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
   let starpat= 3
"   call Decho("case starpat=3: Explore */filepat (starpat=".starpat.")",'~'.expand("<slnum>"))

  elseif dirname=~ '^\*\*/'
   " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
   let starpat= 4
"   call Decho("case starpat=4: Explore **/filepat (starpat=".starpat.")",'~'.expand("<slnum>"))

  else
   let starpat= 0
"   call Decho("case starpat=0: default",'~'.expand("<slnum>"))
  endif

  if starpat == 0 && a:indx >= 0
   " [Explore Hexplore Vexplore Sexplore] [dirname]
"   call Decho("case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore",'~'.expand("<slnum>"))
   if dirname == ""
    let dirname= curfiledir
"    call Decho("..empty dirname, using current file's directory<".dirname.">",'~'.expand("<slnum>"))
   endif
   if dirname =~# '^scp://' || dirname =~ '^ftp://'
    call netrw#Nread(2,dirname)
   else
    if dirname == ""
     let dirname= getcwd()
    elseif (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
     " Windows : check for a drive specifier, or else for a remote share name ('\\Foo' or '//Foo',
     " depending on whether backslashes have been converted to forward slashes by earlier code).
     if dirname !~ '^[a-zA-Z]:' && dirname !~ '^\\\\\w\+' && dirname !~ '^//\w\+'
      let dirname= b:netrw_curdir."/".dirname
     endif
    elseif dirname !~ '^/'
     let dirname= b:netrw_curdir."/".dirname
    endif
"    call Decho("..calling LocalBrowseCheck(dirname<".dirname.">)",'~'.expand("<slnum>"))
    call netrw#LocalBrowseCheck(dirname)
"    call Decho(" modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
"    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
   endif
   if exists("w:netrw_bannercnt")
    " done to handle P08-Ingelrest. :Explore will _Always_ go to the line just after the banner.
    " If one wants to return the same place in the netrw window, use :Rex instead.
    exe w:netrw_bannercnt
   endif

"   call Decho("curdir<".curdir.">",'~'.expand("<slnum>"))
   " ---------------------------------------------------------------------
   " Jan 24, 2013: not sure why the following was present.  See P08-Ingelrest
"   if has("win32") || has("win95") || has("win64") || has("win16")
"    NetrwKeepj call search('\<'.substitute(curdir,'^.*[/\\]','','e').'\>','cW')
"   else
"    NetrwKeepj call search('\<'.substitute(curdir,'^.*/','','e').'\>','cW')
"   endif
   " ---------------------------------------------------------------------

  " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
  " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
  " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
  " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
  elseif a:indx <= 0
   " Nexplore, Pexplore, Explore: handle starpat
"   call Decho("case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx,'~'.expand("<slnum>"))
   if !mapcheck("<s-up>","n") && !mapcheck("<s-down>","n") && exists("b:netrw_curdir")
"    call Decho("..set up <s-up> and <s-down> maps",'~'.expand("<slnum>"))
    let s:didstarstar= 1
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   endif

   if has("path_extra")
"    call Decho("..starpat=".starpat.": has +path_extra",'~'.expand("<slnum>"))
    if !exists("w:netrw_explore_indx")
     let w:netrw_explore_indx= 0
    endif

    let indx = a:indx
"    call Decho("..starpat=".starpat.": set indx= [a:indx=".indx."]",'~'.expand("<slnum>"))

    if indx == -1
     " Nexplore
"     call Decho("..case Nexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
     if !exists("w:netrw_explore_list") " sanity check
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Nexplore or <s-down> improperly; see help for netrw-starstar",40)
      if has("clipboard")
       sil! let @* = keepregstar
       sil! let @+ = keepregstar
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
     while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
      let indx= indx + 1
"      call Decho("....indx=".indx." (Nexplore while loop)",'~'.expand("<slnum>"))
     endwhile
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
"     call Decho("....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))

    elseif indx == -2
     " Pexplore
"     call Decho("case Pexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
     if !exists("w:netrw_explore_list") " sanity check
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
      if has("clipboard")
       sil! let @* = keepregstar
       sil! let @+ = keepregstar
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
     while indx >= 0 && curfile == w:netrw_explore_list[indx]
      let indx= indx - 1
"      call Decho("....indx=".indx." (Pexplore while loop)",'~'.expand("<slnum>"))
     endwhile
     if indx < 0                        | let indx= 0                           | endif
"     call Decho("....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))

    else
     " Explore -- initialize
     " build list of files to Explore with Nexplore/Pexplore
"     call Decho("..starpat=".starpat.": case Explore: initialize (indx=".indx.")",'~'.expand("<slnum>"))
     NetrwKeepj keepalt call s:NetrwClearExplore()
     let w:netrw_explore_indx= 0
     if !exists("b:netrw_curdir")
      let b:netrw_curdir= getcwd()
     endif
"     call Decho("....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))

     " switch on starpat to build the w:netrw_explore_list of files
     if starpat == 1
      " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls,'~'.expand("<slnum>"))
"      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
      try
       exe "NetrwKeepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pattern.">",76)
"       call Dret("netrw#Explore : unable to find pattern<".pattern.">")
       return
      endtry
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(getqflist(),'bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 2
      " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)",'~'.expand("<slnum>"))
"      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
      try
       exe "sil NetrwKeepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
       if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
       if has("clipboard")
        sil! let @* = keepregstar
        sil! let @+ = keepregstar
       endif
       sil! let @/ = keepregslash
"       call Dret("netrw#Explore : no files matched pattern")
       return
      endtry
      let s:netrw_curdir       = b:netrw_curdir
      let w:netrw_explore_list = getqflist()
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(w:netrw_explore_list,'s:netrw_curdir."/".bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 3
      " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
      let filepat= substitute(dirname,'^\*/','','')
      let filepat= substitute(filepat,'^[%#<]','\\&','')
"      call Decho("....b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
"      call Decho("....filepat<".filepat.">",'~'.expand("<slnum>"))
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif

     elseif starpat == 4
      " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
     endif " switch on starpat to build w:netrw_explore_list

     let w:netrw_explore_listlen = len(w:netrw_explore_list)
"     call Decho("....w:netrw_explore_list<".string(w:netrw_explore_list).">",'~'.expand("<slnum>"))
"     call Decho("....w:netrw_explore_listlen=".w:netrw_explore_listlen,'~'.expand("<slnum>"))

     if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
      keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
      if has("clipboard")
       sil! let @* = keepregstar
       sil! let @+ = keepregstar
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore : no files matched")
      return
     endif
    endif  " if indx ... endif

    " NetrwStatusLine support - for exploring support
    let w:netrw_explore_indx= indx
"    call Decho("....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen,'~'.expand("<slnum>"))

    " wrap the indx around, but issue a note
    if indx >= w:netrw_explore_listlen || indx < 0
"     call Decho("....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")",'~'.expand("<slnum>"))
     let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
     let w:netrw_explore_indx= indx
     keepalt NetrwKeepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
    endif

    exe "let dirfile= w:netrw_explore_list[".indx."]"
"    call Decho("....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">",'~'.expand("<slnum>"))
    let newdir= substitute(dirfile,'/[^/]*$','','e')
"    call Decho("....newdir<".newdir.">",'~'.expand("<slnum>"))

"    call Decho("....calling LocalBrowseCheck(newdir<".newdir.">)",'~'.expand("<slnum>"))
    call netrw#LocalBrowseCheck(newdir)
    if !exists("w:netrw_liststyle")
     let w:netrw_liststyle= g:netrw_liststyle
    endif
    if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:LONGLIST
     keepalt NetrwKeepj call search('^'.substitute(dirfile,"^.*/","","").'\>',"W")
    else
     keepalt NetrwKeepj call search('\<'.substitute(dirfile,"^.*/","","").'\>',"w")
    endif
    let w:netrw_explore_mtchcnt = indx + 1
    let w:netrw_explore_bufnr   = bufnr("%")
    let w:netrw_explore_line    = line(".")
    keepalt NetrwKeepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
"    call Decho("....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line,'~'.expand("<slnum>"))

   else
"    call Decho("..your vim does not have +path_extra",'~'.expand("<slnum>"))
    if !exists("g:netrw_quiet")
     keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
    endif
    if has("clipboard")
     sil! let @* = keepregstar
     sil! let @+ = keepregstar
    endif
    sil! let @/ = keepregslash
"    call Dret("netrw#Explore : missing +path_extra")
    return
   endif

  else
"   call Decho("..default case: Explore newdir<".dirname.">",'~'.expand("<slnum>"))
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
    sil! unlet w:netrw_treedict
    sil! unlet w:netrw_treetop
   endif
   let newdir= dirname
   if !exists("b:netrw_curdir")
    NetrwKeepj call netrw#LocalBrowseCheck(getcwd())
   else
    NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,newdir))
   endif
  endif

  " visual display of **/ **// */ Exploration files
"  call Decho("w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">",'~'.expand("<slnum>"))
  if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
"   call Decho("s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"),'~'.expand("<slnum>"))
   if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
    " only update match list when current directory isn't the same as before
"    call Decho("only update match list when current directory not the same as before",'~'.expand("<slnum>"))
    let s:explore_prvdir = b:netrw_curdir
    let s:explore_match  = ""
    let dirlen           = strlen(b:netrw_curdir)
    if b:netrw_curdir !~ '/$'
     let dirlen= dirlen + 1
    endif
    let prvfname= ""
    for fname in w:netrw_explore_list
"     call Decho("fname<".fname.">",'~'.expand("<slnum>"))
     if fname =~ '^'.b:netrw_curdir
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      endif
     elseif fname !~ '^/' && fname != prvfname
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(fname,g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(fname,g:netrw_markfileesc).'\>'
      endif
     endif
     let prvfname= fname
    endfor
"    call Decho("explore_match<".s:explore_match.">",'~'.expand("<slnum>"))
    exe "2match netrwMarkFile /".s:explore_match."/"
   endif
   echo "<s-up>==Pexplore  <s-down>==Nexplore"
  else
   2match none
   if exists("s:explore_match")  | unlet s:explore_match  | endif
   if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
   echo " "
"   call Decho("cleared explore match list",'~'.expand("<slnum>"))
  endif

  " since Explore may be used to initialize netrw's browser,
  " there's no danger of a late FocusGained event on initialization.
  " Consequently, set s:netrw_events to 2.
  let s:netrw_events= 2
  if has("clipboard")
   sil! let @* = keepregstar
   sil! let @+ = keepregstar
  endif
  sil! let @/ = keepregslash
"  call Dret("netrw#Explore : @/<".@/.">")
endfun

" ---------------------------------------------------------------------
" netrw#Lexplore: toggle Explorer window, keeping it on the left of the current tab {{{2
fun! netrw#Lexplore(count,rightside,...)
"  call Dfunc("netrw#Lexplore(count=".a:count."rightside=".a:rightside.",...) a:0=".a:0." ft=".&ft)
  let curwin= winnr()

  if a:0 > 0 && a:1 != ""
   " if a netrw window is already on the left-side of the tab
   " and a directory has been specified, explore with that
   " directory.
   let a1 = expand(a:1)
"   call Decho("a:1<".a:1.">  curwin#".curwin,'~'.expand("<slnum>"))
   exe "1wincmd w"
   if &ft == "netrw"
"    call Decho("exe Explore ".fnameescape(a:1),'~'.expand("<slnum>"))
    exe "Explore ".fnameescape(a1)
    exe curwin."wincmd w"
    if exists("t:netrw_lexposn")
"     call Decho("forgetting t:netrw_lexposn",'~'.expand("<slnum>"))
     unlet t:netrw_lexposn
    endif
"    call Dret("netrw#Lexplore")
    return
   endif
   exe curwin."wincmd w"
  else
   let a1= ""
  endif

  if exists("t:netrw_lexbufnr")
   " check if t:netrw_lexbufnr refers to a netrw window
   let lexwinnr = bufwinnr(t:netrw_lexbufnr)
  else
   let lexwinnr= 0
  endif

  if lexwinnr > 0
   " close down netrw explorer window
"  call Decho("t:netrw_lexbufnr#".t:netrw_lexbufnr.": close down netrw window",'~'.expand("<slnum>"))
   exe lexwinnr."wincmd w"
   let g:netrw_winsize = -winwidth(0)
   let t:netrw_lexposn = winsaveview()
"   call Decho("saving posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
"   call Decho("saving t:netrw_lexposn",'~'.expand("<slnum>"))
   close
   if lexwinnr < curwin
    let curwin= curwin - 1
   endif
   exe curwin."wincmd w"
   unlet t:netrw_lexbufnr

  else
   " open netrw explorer window
"   call Decho("t:netrw_lexbufnr<n/a>: open netrw explorer window",'~'.expand("<slnum>"))
   exe "1wincmd w"
   let keep_altv    = g:netrw_altv
   let g:netrw_altv = 0
   if a:count != 0
    let netrw_winsize   = g:netrw_winsize
    let g:netrw_winsize = a:count
   endif
   let curfile= expand("%")
"   call Decho("curfile<".curfile.">",'~'.expand("<slnum>"))
   exe (a:rightside? "botright" : "topleft")." vertical ".((g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize) . " new"
   if a:0 > 0 && a1 != ""
"    call Decho("case 1: Explore ".a1,'~'.expand("<slnum>"))
    exe "Explore ".fnameescape(a1)
   elseif curfile =~ '^\a\{3,}://'
"    call Decho("case 2: Explore ".substitute(curfile,'[^/\\]*$','',''),'~'.expand("<slnum>"))
    exe "Explore ".substitute(curfile,'[^/\\]*$','','')
   else
"    call Decho("case 3: Explore .",'~'.expand("<slnum>"))
    Explore .
   endif
   if a:count != 0
    let g:netrw_winsize = netrw_winsize
   endif
   setlocal winfixwidth
   let g:netrw_altv     = keep_altv
   let t:netrw_lexbufnr = bufnr("%")
   if exists("t:netrw_lexposn")
"    call Decho("restoring to t:netrw_lexposn",'~'.expand("<slnum>"))
"    call Decho("restoring posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
    call winrestview(t:netrw_lexposn)
    unlet t:netrw_lexposn
   endif
  endif

  " set up default window for editing via <cr>
  if exists("g:netrw_chgwin") && g:netrw_chgwin == -1
   if a:rightside
    let g:netrw_chgwin= 1
   else
    let g:netrw_chgwin= 2
   endif
  endif

"  call Dret("netrw#Lexplore")
endfun

" ---------------------------------------------------------------------
" netrw#Clean: remove netrw {{{2
" supports :NetrwClean  -- remove netrw from first directory on runtimepath
"          :NetrwClean! -- remove netrw from all directories on runtimepath
fun! netrw#Clean(sys)
"  call Dfunc("netrw#Clean(sys=".a:sys.")")

  if a:sys
   let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
  else
   let choice= confirm("Remove personal copy of netrw?","&Yes\n&No")
  endif
"  call Decho("choice=".choice,'~'.expand("<slnum>"))
  let diddel= 0
  let diddir= ""

  if choice == 1
   for dir in split(&rtp,',')
    if filereadable(dir."/plugin/netrwPlugin.vim")
"     call Decho("removing netrw-related files from ".dir,'~'.expand("<slnum>"))
     if s:NetrwDelete(dir."/plugin/netrwPlugin.vim")        |call netrw#ErrorMsg(1,"unable to remove ".dir."/plugin/netrwPlugin.vim",55)        |endif
     if s:NetrwDelete(dir."/autoload/netrwFileHandlers.vim")|call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwFileHandlers.vim",55)|endif
     if s:NetrwDelete(dir."/autoload/netrwSettings.vim")    |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwSettings.vim",55)    |endif
     if s:NetrwDelete(dir."/autoload/netrw.vim")            |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrw.vim",55)            |endif
     if s:NetrwDelete(dir."/syntax/netrw.vim")              |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrw.vim",55)              |endif
     if s:NetrwDelete(dir."/syntax/netrwlist.vim")          |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrwlist.vim",55)          |endif
     let diddir= dir
     let diddel= diddel + 1
     if !a:sys|break|endif
    endif
   endfor
  endif

   echohl WarningMsg
  if diddel == 0
   echomsg "netrw is either not installed or not removable"
  elseif diddel == 1
   echomsg "removed one copy of netrw from <".diddir.">"
  else
   echomsg "removed ".diddel." copies of netrw"
  endif
   echohl None

"  call Dret("netrw#Clean")
endfun

" ---------------------------------------------------------------------
" netrw#MakeTgt: make a target out of the directory name provided {{{2
fun! netrw#MakeTgt(dname)
"  call Dfunc("netrw#MakeTgt(dname<".a:dname.">)")
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
  let svpos               = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let s:netrwmftgt_islocal= (a:dname !~ '^\a\{3,}://')
"  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
  if s:netrwmftgt_islocal
   let netrwmftgt= simplify(a:dname)
  else
   let netrwmftgt= a:dname
  endif
  if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
   " re-selected target, so just clear it
   unlet s:netrwmftgt s:netrwmftgt_islocal
  else
   let s:netrwmftgt= netrwmftgt
  endif
  if g:netrw_fastbrowse <= 1
   call s:NetrwRefresh((b:netrw_curdir !~ '\a\{3,}://'),b:netrw_curdir)
  endif
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
  call winrestview(svpos)
"  call Dret("netrw#MakeTgt")
endfun

" ---------------------------------------------------------------------
" netrw#Obtain: {{{2
"   netrw#Obtain(islocal,fname[,tgtdirectory])
"     islocal=0  obtain from remote source
"            =1  obtain from local source
"     fname  :   a filename or a list of filenames
"     tgtdir :   optional place where files are to go  (not present, uses getcwd())
fun! netrw#Obtain(islocal,fname,...)
"  call Dfunc("netrw#Obtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
  " NetrwStatusLine support - for obtaining support

  if type(a:fname) == 1
   let fnamelist= [ a:fname ]
  elseif type(a:fname) == 3
   let fnamelist= a:fname
  else
   call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
"   call Dret("netrw#Obtain")
   return
  endif
"  call Decho("fnamelist<".string(fnamelist).">",'~'.expand("<slnum>"))
  if a:0 > 0
   let tgtdir= a:1
  else
   let tgtdir= getcwd()
  endif
"  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))

  if exists("b:netrw_islocal") && b:netrw_islocal
   " obtain a file from local b:netrw_curdir to (local) tgtdir
"   call Decho("obtain a file from local ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
   if exists("b:netrw_curdir") && getcwd() != b:netrw_curdir
    let topath= s:ComposePath(tgtdir,"")
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     " transfer files one at time
"     call Decho("transfer files one at a time",'~'.expand("<slnum>"))
     for fname in fnamelist
"      call Decho("system(".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
      call system(g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"       call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
       return
      endif
     endfor
    else
     " transfer files with one command
"     call Decho("transfer files with one command",'~'.expand("<slnum>"))
     let filelist= join(map(deepcopy(fnamelist),"s:ShellEscape(v:val)"))
"     call Decho("system(".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
     call system(g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath))
     if v:shell_error != 0
      call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"      call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath))
      return
     endif
    endif
   elseif !exists("b:netrw_curdir")
    call netrw#ErrorMsg(s:ERROR,"local browsing directory doesn't exist!",36)
   else
    call netrw#ErrorMsg(s:WARNING,"local browsing directory and current directory are identical",37)
   endif

  else
   " obtain files from remote b:netrw_curdir to local tgtdir
"   call Decho("obtain a file from remote ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
   if type(a:fname) == 1
    call s:SetupNetrwStatusLine('%f %h%m%r%=%9*Obtaining '.a:fname)
   endif
   call s:NetrwMethod(b:netrw_curdir)

   if b:netrw_method == 4
    " obtain file using scp
"    call Decho("obtain via scp (method#4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    if b:netrw_fname =~ '/'
     let path= substitute(b:netrw_fname,'^\(.*/\).\{-}$','\1','')
    else
     let path= ""
    endif
    let filelist= join(map(deepcopy(fnamelist),'s:ShellEscape(g:netrw_machine.":".path.v:val,1)'))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".filelist." ".s:ShellEscape(tgtdir,1))

   elseif b:netrw_method == 2
    " obtain file using ftp + .netrc
"     call Decho("obtain via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
     call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix
     if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
      NetrwKeepj put =g:netrw_ftpmode
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("b:netrw_fname") && b:netrw_fname != ""
      call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif
     for fname in fnamelist
      call setline(line("$")+1,'get "'.fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor
     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug= debugkeep
     endif

   elseif b:netrw_method == 3
    " obtain with ftp + machine, id, passwd, and fname (ie. no .netrc)
"    call Decho("obtain via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
    let tmpbufnr= bufnr("%")
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("b:netrw_fname") && b:netrw_fname != ""
     NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif
    for fname in fnamelist
     NetrwKeepj call setline(line("$")+1,'get "'.fname.'"')
    endfor
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    NetrwKeepj norm! 1Gdd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif

   elseif b:netrw_method == 9
    " obtain file using sftp
"    call Decho("obtain via sftp (method #9)",'~'.expand("<slnum>"))
    if a:fname =~ '/'
     let localfile= substitute(a:fname,'^.*/','','')
    else
     let localfile= a:fname
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1).s:ShellEscape(localfile)." ".s:ShellEscape(tgtdir))

   elseif !exists("b:netrw_method") || b:netrw_method < 0
    " probably a badly formed url; protocol not recognized
"    call Dret("netrw#Obtain : unsupported method")
    return

   else
    " protocol recognized but not supported for Obtain (yet?)
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"current protocol not supported for obtaining file",97)
    endif
"    call Dret("netrw#Obtain : current protocol not supported for obtaining file")
    return
   endif

   " restore status line
   if type(a:fname) == 1 && exists("s:netrw_users_stl")
    NetrwKeepj call s:SetupNetrwStatusLine(s:netrw_users_stl)
   endif

  endif

  " cleanup
  if exists("tmpbufnr")
   if bufnr("%") != tmpbufnr
    exe tmpbufnr."bw!"
   else
    q!
   endif
  endif

"  call Dret("netrw#Obtain")
endfun

" ---------------------------------------------------------------------
" netrw#Nread: save position, call netrw#NetRead(), and restore position {{{2
fun! netrw#Nread(mode,fname)
"  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call netrw#NetRead(a:mode,a:fname)
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)

  if exists("w:netrw_liststyle") && w:netrw_liststyle != s:TREELIST
   if exists("w:netrw_bannercnt")
    " start with cursor just after the banner
    exe w:netrw_bannercnt
   endif
  endif
"  call Dret("netrw#Nread")
endfun

" ------------------------------------------------------------------------
" s:NetrwOptionRestore: restore options (based on prior s:NetrwOptionSave) {{{2
fun! s:NetrwOptionRestore(vt)
"  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
  if !exists("{a:vt}netrw_optionsave")
   call s:RestorePosn(s:netrw_nbcd)
"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
   return
  endif
  unlet {a:vt}netrw_optionsave

  if exists("+acd")
   if exists("{a:vt}netrw_acdkeep")
"    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
    let curdir = getcwd()
    let &l:acd = {a:vt}netrw_acdkeep
    unlet {a:vt}netrw_acdkeep
    if &l:acd
     call s:NetrwLcd(curdir)
    endif
   endif
  endif
  if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
  if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
  if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
  if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
  if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
  if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
  if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
  if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
  if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
  if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
  if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
  if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
  if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
  if exists("g:netrw_ffkep") && g:netrw_ffkeep
   if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
  endif
  if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
  if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
  if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
  if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
  if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
  if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
  if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
  if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
  if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
  if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
  if exists("{a:vt}netrw_rnukeep")  |let &l:rnu    = {a:vt}netrw_rnukeep     |unlet {a:vt}netrw_rnukeep  |endif
  if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
  if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
  if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
  if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
  if has("clipboard")
   if exists("{a:vt}netrw_starkeep") |let @*        = {a:vt}netrw_starkeep    |unlet {a:vt}netrw_starkeep |endif
  endif
  " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
"  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
  if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
  if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
  if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
  if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
  if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
  if exists("{a:vt}netrw_swfkeep")
   if &directory == ""
    " user hasn't specified a swapfile directory;
    " netrw will temporarily set the swapfile directory
    " to the current directory as returned by getcwd().
    let &l:directory= getcwd()
    sil! let &l:swf = {a:vt}netrw_swfkeep
    setl directory=
    unlet {a:vt}netrw_swfkeep
   elseif &l:swf != {a:vt}netrw_swfkeep
    if !g:netrw_use_noswf
     " following line causes a Press ENTER in windows -- can't seem to work around it!!!
     sil! let &l:swf= {a:vt}netrw_swfkeep
    endif
    unlet {a:vt}netrw_swfkeep
   endif
  endif
  if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
   let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   if exists("{a:vt}netrw_dirkeep")
    call s:NetrwLcd(dirkeep)
    unlet {a:vt}netrw_dirkeep
   endif
  endif
  if has("clipboard")
   if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
  endif
  if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
  call s:RestorePosn(s:netrw_nbcd)

"  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
  " Moved the filetype detect here from NetrwGetFile() because remote files
  " were having their filetype detect-generated settings overwritten by
  " NetrwOptionRestore.
  if &ft != "netrw"
"   call Decho("filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
   filetype detect
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
endfun

" ---------------------------------------------------------------------
" s:NetrwOptionSave: save options prior to setting to "netrw-buffer-standard" form {{{2
"             Options get restored by s:NetrwOptionRestore()
"  06/08/07 : removed call to NetrwSafeOptions(), either placed
"             immediately after NetrwOptionSave() calls in NetRead
"             and NetWrite, or after the s:NetrwEnew() call in
"             NetrwBrowse.
"             vt: normally its "w:" or "s:" (a variable type)
fun! s:NetrwOptionSave(vt)
"  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
"  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))

  if !exists("{a:vt}netrw_optionsave")
   let {a:vt}netrw_optionsave= 1
  else
"   call Dret("s:NetrwOptionSave : options already saved")
   return
  endif
"  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))

  " Save current settings and current directory
"  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
  let s:yykeep          = @@
  if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
  let {a:vt}netrw_aikeep    = &l:ai
  let {a:vt}netrw_awkeep    = &l:aw
  let {a:vt}netrw_bhkeep    = &l:bh
  let {a:vt}netrw_blkeep    = &l:bl
  let {a:vt}netrw_btkeep    = &l:bt
  let {a:vt}netrw_bombkeep  = &l:bomb
  let {a:vt}netrw_cedit     = &cedit
  let {a:vt}netrw_cikeep    = &l:ci
  let {a:vt}netrw_cinkeep   = &l:cin
  let {a:vt}netrw_cinokeep  = &l:cino
  let {a:vt}netrw_comkeep   = &l:com
  let {a:vt}netrw_cpokeep   = &l:cpo
  let {a:vt}netrw_diffkeep  = &l:diff
  let {a:vt}netrw_fenkeep   = &l:fen
  if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
   let {a:vt}netrw_ffkeep    = &l:ff
  endif
  let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
  let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
  let {a:vt}netrw_hidkeep   = &l:hidden
  let {a:vt}netrw_imkeep    = &l:im
  let {a:vt}netrw_iskkeep   = &l:isk
  let {a:vt}netrw_lskeep    = &l:ls
  let {a:vt}netrw_makeep    = &l:ma
  let {a:vt}netrw_magickeep = &l:magic
  let {a:vt}netrw_modkeep   = &l:mod
  let {a:vt}netrw_nukeep    = &l:nu
  let {a:vt}netrw_rnukeep   = &l:rnu
  let {a:vt}netrw_repkeep   = &l:report
  let {a:vt}netrw_rokeep    = &l:ro
  let {a:vt}netrw_selkeep   = &l:sel
  let {a:vt}netrw_spellkeep = &l:spell
  if !g:netrw_use_noswf
   let {a:vt}netrw_swfkeep  = &l:swf
  endif
  if has("clipboard")
   let {a:vt}netrw_starkeep = @*
  endif
  let {a:vt}netrw_tskeep    = &l:ts
  let {a:vt}netrw_twkeep    = &l:tw           " textwidth
  let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
  let {a:vt}netrw_wrapkeep  = &l:wrap
  let {a:vt}netrw_writekeep = &l:write

  " save a few selected netrw-related variables
"  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
  if g:netrw_keepdir
   let {a:vt}netrw_dirkeep  = getcwd()
  endif
  if has("clipboard")
   if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
  endif
  sil! let {a:vt}netrw_regslash= @/

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr())
endfun

" ------------------------------------------------------------------------
" s:NetrwSafeOptions: sets options to help netrw do its job {{{2
"                     Use  s:NetrwSaveOptions() to save user settings
"                     Use  s:NetrwOptionRestore() to restore user settings
fun! s:NetrwSafeOptions()
"  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
"  call Decho("win#".winnr()."'s ft=".&ft,'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
  if exists("+acd") | setl noacd | endif
  setl noai
  setl noaw
  setl nobl
  setl nobomb
  setl bt=nofile
  setl noci
  setl nocin
  setl bh=hide
  setl cino=
  setl com=
  setl cpo-=a
  setl cpo-=A
  setl fo=nroql2
  setl nohid
  setl noim
  setl isk+=@ isk+=* isk+=/
  setl magic
  if g:netrw_use_noswf
   setl noswf
  endif
  setl report=10000
  setl sel=inclusive
  setl nospell
  setl tw=0
  setl wig=
  setl cedit&
  call s:NetrwCursor()

  " allow the user to override safe options
"  call Decho("ft<".&ft."> ei=".&ei,'~'.expand("<slnum>"))
  if &ft == "netrw"
"   call Decho("do any netrw FileType autocmds (doau FileType netrw)",'~'.expand("<slnum>"))
   sil! keepalt NetrwKeepj doau FileType netrw
  endif

"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh." bt<".&bt.">",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dret("s:NetrwSafeOptions")
endfun

" ---------------------------------------------------------------------
" NetrwStatusLine: {{{2
fun! NetrwStatusLine()

" vvv NetrwStatusLine() debugging vvv
"  let g:stlmsg=""
"  if !exists("w:netrw_explore_bufnr")
"   let g:stlmsg="!X<explore_bufnr>"
"  elseif w:netrw_explore_bufnr != bufnr("%")
"   let g:stlmsg="explore_bufnr!=".bufnr("%")
"  endif
"  if !exists("w:netrw_explore_line")
"   let g:stlmsg=" !X<explore_line>"
"  elseif w:netrw_explore_line != line(".")
"   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
"  endif
"  if !exists("w:netrw_explore_list")
"   let g:stlmsg=" !X<explore_list>"
"  endif
" ^^^ NetrwStatusLine() debugging ^^^

  if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
   " restore user's status line
   let &stl        = s:netrw_users_stl
   let &laststatus = s:netrw_users_ls
   if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
   if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
   return ""
  else
   return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
  endif
endfun

" ---------------------------------------------------------------------
"  Netrw Transfer Functions: {{{1
" ===============================

" ------------------------------------------------------------------------
" netrw#NetRead: responsible for reading a file over the net {{{2
"   mode: =0 read remote file and insert before current line
"         =1 read remote file and insert after current line
"         =2 replace with remote file
"         =3 obtain file, but leave in temporary format
fun! netrw#NetRead(mode,...)
"  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))

  " NetRead: save options {{{3
  call s:NetrwOptionSave("w:")
  call s:NetrwSafeOptions()
  call s:RestoreCursorline()
  " NetrwSafeOptions sets a buffer up for a netrw listing, which includes buflisting off.
  " However, this setting is not wanted for a remote editing session.  The buffer should be "nofile", still.
  setl bl
"  call Decho("(netrw#NetRead) buf#".bufnr("%")."<".bufname("%")."> bl=".&bl." bt=".&bt." bh=".&bh,'~'.expand("<slnum>"))

  " NetRead: interpret mode into a readcmd {{{3
  if     a:mode == 0 " read remote file before current line
   let readcmd = "0r"
  elseif a:mode == 1 " read file after current line
   let readcmd = "r"
  elseif a:mode == 2 " replace with remote file
   let readcmd = "%r"
  elseif a:mode == 3 " skip read of file (leave as temporary)
   let readcmd = "t"
  else
   exe a:mode
   let readcmd = "r"
  endif
  let ichoice = (a:0 == 0)? 0 : 1
"  call Decho("readcmd<".readcmd."> ichoice=".ichoice,'~'.expand("<slnum>"))

  " NetRead: get temporary filename {{{3
  let tmpfile= s:GetTempfile("")
  if tmpfile == ""
"   call Dret("netrw#NetRead : unable to get a tempfile!")
   return
  endif

  while ichoice <= a:0

   " attempt to repeat with previous host-file-etc
   if exists("b:netrw_lastfile") && a:0 == 0
"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">",'~'.expand("<slnum>"))
    let choice = b:netrw_lastfile
    let ichoice= ichoice + 1

   else
    exe "let choice= a:" . ichoice
"    call Decho("no lastfile: choice<" . choice . ">",'~'.expand("<slnum>"))

    if match(choice,"?") == 0
     " give help
     echomsg 'NetRead Usage:'
     echomsg ':Nread machine:path                         uses rcp'
     echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
     echomsg ':Nread "machine id password path"           uses ftp'
     echomsg ':Nread dav://machine[:port]/path            uses cadaver'
     echomsg ':Nread fetch://machine/path                 uses fetch'
     echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
     echomsg ':Nread http://[user@]machine/path           uses http  wget'
     echomsg ':Nread file:///path           		  uses elinks'
     echomsg ':Nread https://[user@]machine/path          uses http  wget'
     echomsg ':Nread rcp://[user@]machine/path            uses rcp'
     echomsg ':Nread rsync://machine[:port]/path          uses rsync'
     echomsg ':Nread scp://[user@]machine[[:#]port]/path  uses scp'
     echomsg ':Nread sftp://[user@]machine[[:#]port]/path uses sftp'
     sleep 4
     break

    elseif match(choice,'^"') != -1
     " Reconstruct Choice if choice starts with '"'
"     call Decho("reconstructing choice",'~'.expand("<slnum>"))
     if match(choice,'"$') != -1
      " case "..."
      let choice= strpart(choice,1,strlen(choice)-2)
     else
       "  case "... ... ..."
      let choice      = strpart(choice,1,strlen(choice)-1)
      let wholechoice = ""

      while match(choice,'"$') == -1
       let wholechoice = wholechoice . " " . choice
       let ichoice     = ichoice + 1
       if ichoice > a:0
       	if !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",3)
	endif
"        call Dret("netrw#NetRead :2 getcwd<".getcwd().">")
        return
       endif
       let choice= a:{ichoice}
      endwhile
      let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
     endif
    endif
   endif

"   call Decho("choice<" . choice . ">",'~'.expand("<slnum>"))
   let ichoice= ichoice + 1

   " NetRead: Determine method of read (ftp, rcp, etc) {{{3
   call s:NetrwMethod(choice)
   if !exists("b:netrw_method") || b:netrw_method < 0
"    call Dfunc("netrw#NetRead : unsupported method")
    return
   endif
   let tmpfile= s:GetTempfile(b:netrw_fname) " apply correct suffix

   " Check whether or not NetrwBrowse() should be handling this request
"   call Decho("checking if NetrwBrowse() should handle choice<".choice."> with netrw_list_cmd<".g:netrw_list_cmd.">",'~'.expand("<slnum>"))
   if choice =~ "^.*[\/]$" && b:netrw_method != 5 && choice !~ '^https\=://'
"    call Decho("yes, choice matches '^.*[\/]$'",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwBrowse(0,choice)
"    call Dret("netrw#NetRead :3 getcwd<".getcwd().">")
    return
   endif

   " ============
   " NetRead: Perform Protocol-Based Read {{{3
   " ===========================
   if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
    echo "(netrw) Processing your read request..."
   endif

   ".........................................
   " NetRead: (rcp)  NetRead Method #1 {{{3
   if  b:netrw_method == 1 " read with rcp
"    call Decho("read via rcp (method #1)",'~'.expand("<slnum>"))
   " ER: nothing done with g:netrw_uid yet?
   " ER: on Win2K" rcp machine[.user]:file tmpfile
   " ER: when machine contains '.' adding .user is required (use $USERNAME)
   " ER: the tmpfile is full path: rcp sees C:\... as host C
   if s:netrw_has_nt_rcp == 1
    if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
     let uid_machine = g:netrw_machine .'.'. g:netrw_uid
    else
     " Any way needed it machine contains a '.'
     let uid_machine = g:netrw_machine .'.'. $USERNAME
    endif
   else
    if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
     let uid_machine = g:netrw_uid .'@'. g:netrw_machine
    else
     let uid_machine = g:netrw_machine
    endif
   endif
   call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".s:ShellEscape(uid_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
   let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
   let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (ftp + <.netrc>)  NetRead Method #2 {{{3
   elseif b:netrw_method  == 2		" read with ftp + <.netrc>
"     call Decho("read via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
     let netrw_fname= b:netrw_fname
     NetrwKeepj call s:SaveBufVars()|new|NetrwKeepj call s:RestoreBufVars()
     let filtbuf= bufnr("%")
     setl ff=unix
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
     endif
     call setline(line("$")+1,'get "'.netrw_fname.'" '.tmpfile)
"     call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep = &debug
      setl debug=msg
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug    = debugkeep
     endif
     call s:SaveBufVars()
     keepj bd!
     if bufname("%") == "" && getline("$") == "" && line('$') == 1
      " needed when one sources a file in a nolbl setting window via ftp
      q!
     endif
     call s:RestoreBufVars()
     let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
     let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (ftp + machine,id,passwd,filename)  NetRead Method #3 {{{3
   elseif b:netrw_method == 3		" read with ftp + machine, id, passwd, and fname
    " Construct execution string (four lines) which will be passed through filter
"    call Decho("read via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
    NetrwKeepj call s:SaveBufVars()|new|NetrwKeepj call s:RestoreBufVars()
    let filtbuf= bufnr("%")
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"       call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd")
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif
    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif
    NetrwKeepj put ='get \"'.netrw_fname.'\" '.tmpfile
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    NetrwKeepj norm! 1Gdd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif
    call s:SaveBufVars()|keepj bd!|call s:RestoreBufVars()
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (scp) NetRead Method #4 {{{3
   elseif     b:netrw_method  == 4	" read with scp
"    call Decho("read via scp (method #4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    " 'C' in 'C:\path\to\file' is handled as hostname on windows.
    " This is workaround to avoid mis-handle windows local-path:
    if g:netrw_scp_cmd =~ '^scp' && (has("win32") || has("win95") || has("win64") || has("win16"))
      let tmpfile_get = substitute(tr(tmpfile, '\', '/'), '^\(\a\):[/\\]\(.*\)$', '/\1/\2', '')
    else
      let tmpfile_get = tmpfile
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile_get,1))
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (http) NetRead Method #5 (wget) {{{3
   elseif     b:netrw_method  == 5
"    call Decho("read via http (method #5)",'~'.expand("<slnum>"))
    if g:netrw_http_cmd == ""
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,"neither the wget nor the fetch command is available",6)
     endif
"     call Dret("netrw#NetRead :4 getcwd<".getcwd().">")
     return
    endif

    if match(b:netrw_fname,"#") == -1 || exists("g:netrw_http_xcmd")
     " using g:netrw_http_cmd (usually elinks, links, curl, wget, or fetch)
"     call Decho('using '.g:netrw_http_cmd.' (# not in b:netrw_fname<'.b:netrw_fname.">)",'~'.expand("<slnum>"))
     if exists("g:netrw_http_xcmd")
      call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".s:ShellEscape(tmpfile,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1))
     endif
     let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)

    else
     " wget/curl/fetch plus a jump to an in-page marker (ie. http://abc/def.html#aMarker)
"     call Decho("wget/curl plus jump (# in b:netrw_fname<".b:netrw_fname.">)",'~'.expand("<slnum>"))
     let netrw_html= substitute(b:netrw_fname,"#.*$","","")
     let netrw_tag = substitute(b:netrw_fname,"^.*#","","")
"     call Decho("netrw_html<".netrw_html.">",'~'.expand("<slnum>"))
"     call Decho("netrw_tag <".netrw_tag.">",'~'.expand("<slnum>"))
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.netrw_html,1))
     let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
"     call Decho('<\s*a\s*name=\s*"'.netrw_tag.'"/','~'.expand("<slnum>"))
     exe 'NetrwKeepj norm! 1G/<\s*a\s*name=\s*"'.netrw_tag.'"/'."\<CR>"
    endif
    let b:netrw_lastfile = choice
"    call Decho("setl ro",'~'.expand("<slnum>"))
    setl ro nomod

   ".........................................
   " NetRead: (dav) NetRead Method #6 {{{3
   elseif     b:netrw_method  == 6
"    call Decho("read via cadaver (method #6)",'~'.expand("<slnum>"))

    if !executable(g:netrw_dav_cmd)
     call netrw#ErrorMsg(s:ERROR,g:netrw_dav_cmd." is not executable",73)
"     call Dret("netrw#NetRead : ".g:netrw_dav_cmd." not executable")
     return
    endif
    if g:netrw_dav_cmd =~ "curl"
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_dav_cmd." ".s:ShellEscape("dav://".g:netrw_machine.b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
    else
     " Construct execution string (four lines) which will be passed through filter
     let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
     new
     setl ff=unix
     if exists("g:netrw_port") && g:netrw_port != ""
      NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
     else
      NetrwKeepj put ='open '.g:netrw_machine
     endif
     if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
      NetrwKeepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
     endif
     NetrwKeepj put ='get '.netrw_fname.' '.tmpfile
     NetrwKeepj put ='quit'

     " perform cadaver operation:
     NetrwKeepj norm! 1Gdd
     call s:NetrwExe(s:netrw_silentxfer."%!".g:netrw_dav_cmd)
     keepj bd!
    endif
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (rsync) NetRead Method #7 {{{3
   elseif     b:netrw_method  == 7
"    call Decho("read via rsync (method #7)",'~'.expand("<slnum>"))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
    let result		 = s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (fetch) NetRead Method #8 {{{3
   "    fetch://[user@]host[:http]/path
   elseif     b:netrw_method  == 8
"    call Decho("read via fetch (method #8)",'~'.expand("<slnum>"))
    if g:netrw_fetch_cmd == ""
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,"fetch command not available",7)
     endif
"     call Dret("NetRead")
     return
    endif
    if exists("g:netrw_option") && g:netrw_option =~ ":https\="
     let netrw_option= "http"
    else
     let netrw_option= "ftp"
    endif
"    call Decho("read via fetch for ".netrw_option,'~'.expand("<slnum>"))

    if exists("g:netrw_uid") && g:netrw_uid != "" && exists("s:netrw_passwd") && s:netrw_passwd != ""
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1))
    else
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1))
    endif

    let result		= s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice
"    call Decho("setl ro",'~'.expand("<slnum>"))
    setl ro nomod

   ".........................................
   " NetRead: (sftp) NetRead Method #9 {{{3
   elseif     b:netrw_method  == 9
"    call Decho("read via sftp (method #9)",'~'.expand("<slnum>"))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile)
    let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (file) NetRead Method #10 {{{3
  elseif      b:netrw_method == 10 && exists("g:netrw_file_cmd")
"   "    call Decho("read via ".b:netrw_file_cmd." (method #10)",'~'.expand("<slnum>"))
   call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_file_cmd." ".s:ShellEscape(b:netrw_fname,1)." ".tmpfile)
   let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
   let b:netrw_lastfile = choice

   ".........................................
   " NetRead: Complain {{{3
   else
    call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",8)
   endif
  endwhile

  " NetRead: cleanup {{{3
  if exists("b:netrw_method")
"   call Decho("cleanup b:netrw_method and b:netrw_fname",'~'.expand("<slnum>"))
   unlet b:netrw_method
   unlet b:netrw_fname
  endif
  if s:FileReadable(tmpfile) && tmpfile !~ '.tar.bz2$' && tmpfile !~ '.tar.gz$' && tmpfile !~ '.zip' && tmpfile !~ '.tar' && readcmd != 't' && tmpfile !~ '.tar.xz$' && tmpfile !~ '.txz'
"   call Decho("cleanup by deleting tmpfile<".tmpfile.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwDelete(tmpfile)
  endif
  NetrwKeepj call s:NetrwOptionRestore("w:")

"  call Dret("netrw#NetRead :5 getcwd<".getcwd().">")
endfun

" ------------------------------------------------------------------------
" netrw#NetWrite: responsible for writing a file over the net {{{2
fun! netrw#NetWrite(...) range
"  call Dfunc("netrw#NetWrite(a:0=".a:0.") ".g:loaded_netrw)

  " NetWrite: option handling {{{3
  let mod= 0
  call s:NetrwOptionSave("w:")
  call s:NetrwSafeOptions()

  " NetWrite: Get Temporary Filename {{{3
  let tmpfile= s:GetTempfile("")
  if tmpfile == ""
"   call Dret("netrw#NetWrite : unable to get a tempfile!")
   return
  endif

  if a:0 == 0
   let ichoice = 0
  else
   let ichoice = 1
  endif

  let curbufname= expand("%")
"  call Decho("curbufname<".curbufname.">",'~'.expand("<slnum>"))
  if &binary
   " For binary writes, always write entire file.
   " (line numbers don't really make sense for that).
   " Also supports the writing of tar and zip files.
"   call Decho("(write entire file) sil exe w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile),'~'.expand("<slnum>"))
   exe "sil NetrwKeepj w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
  elseif g:netrw_cygwin
   " write (selected portion of) file to temporary
   let cygtmpfile= substitute(tmpfile,g:netrw_cygdrive.'/\(.\)','\1:','')
"   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile),'~'.expand("<slnum>"))
   exe "sil NetrwKeepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile)
  else
   " write (selected portion of) file to temporary
"   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile),'~'.expand("<slnum>"))
   exe "sil NetrwKeepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
  endif

  if curbufname == ""
   " when the file is [No Name], and one attempts to Nwrite it, the buffer takes
   " on the temporary file's name.  Deletion of the temporary file during
   " cleanup then causes an error message.
   0file!
  endif

  " NetWrite: while choice loop: {{{3
  while ichoice <= a:0

   " Process arguments: {{{4
   " attempt to repeat with previous host-file-etc
   if exists("b:netrw_lastfile") && a:0 == 0
"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">",'~'.expand("<slnum>"))
    let choice = b:netrw_lastfile
    let ichoice= ichoice + 1
   else
    exe "let choice= a:" . ichoice

    " Reconstruct Choice when choice starts with '"'
    if match(choice,"?") == 0
     echomsg 'NetWrite Usage:"'
     echomsg ':Nwrite machine:path                        uses rcp'
     echomsg ':Nwrite "machine path"                      uses ftp with <.netrc>'
     echomsg ':Nwrite "machine id password path"          uses ftp'
     echomsg ':Nwrite dav://[user@]machine/path           uses cadaver'
     echomsg ':Nwrite fetch://[user@]machine/path         uses fetch'
     echomsg ':Nwrite ftp://machine[#port]/path           uses ftp  (autodetects <.netrc>)'
     echomsg ':Nwrite rcp://machine/path                  uses rcp'
     echomsg ':Nwrite rsync://[user@]machine/path         uses rsync'
     echomsg ':Nwrite scp://[user@]machine[[:#]port]/path uses scp'
     echomsg ':Nwrite sftp://[user@]machine/path          uses sftp'
     sleep 4
     break

    elseif match(choice,"^\"") != -1
     if match(choice,"\"$") != -1
       " case "..."
      let choice=strpart(choice,1,strlen(choice)-2)
     else
      "  case "... ... ..."
      let choice      = strpart(choice,1,strlen(choice)-1)
      let wholechoice = ""

      while match(choice,"\"$") == -1
       let wholechoice= wholechoice . " " . choice
       let ichoice    = ichoice + 1
       if choice > a:0
       	if !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",13)
	endif
"        call Dret("netrw#NetWrite")
        return
       endif
       let choice= a:{ichoice}
      endwhile
      let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
     endif
    endif
   endif
   let ichoice= ichoice + 1
"   call Decho("choice<" . choice . "> ichoice=".ichoice,'~'.expand("<slnum>"))

   " Determine method of write (ftp, rcp, etc) {{{4
   NetrwKeepj call s:NetrwMethod(choice)
   if !exists("b:netrw_method") || b:netrw_method < 0
"    call Dfunc("netrw#NetWrite : unsupported method")
    return
   endif

   " =============
   " NetWrite: Perform Protocol-Based Write {{{3
   " ============================
   if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
    echo "(netrw) Processing your write request..."
"    call Decho("(netrw) Processing your write request...",'~'.expand("<slnum>"))
   endif

   ".........................................
   " NetWrite: (rcp) NetWrite Method #1 {{{3
   if  b:netrw_method == 1
"    call Decho("write via rcp (method #1)",'~'.expand("<slnum>"))
    if s:netrw_has_nt_rcp == 1
     if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
      let uid_machine = g:netrw_machine .'.'. g:netrw_uid
     else
      let uid_machine = g:netrw_machine .'.'. $USERNAME
     endif
    else
     if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
      let uid_machine = g:netrw_uid .'@'. g:netrw_machine
     else
      let uid_machine = g:netrw_machine
     endif
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(uid_machine.":".b:netrw_fname,1))
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (ftp + <.netrc>) NetWrite Method #2 {{{3
   elseif b:netrw_method == 2
"    call Decho("write via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
    let netrw_fname = b:netrw_fname

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let bhkeep      = &l:bh
    let curbuf      = bufnr("%")
    setl bh=hide
    keepj keepalt enew

"    call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
    setl ff=unix
    NetrwKeepj put =g:netrw_ftpmode
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
    endif
    NetrwKeepj call setline(line("$")+1,'put "'.tmpfile.'" "'.netrw_fname.'"')
"    call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
    else
"     call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
     call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
    endif
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),14)
     endif
     let mod=1
    endif

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"

    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (ftp + machine, id, passwd, filename) NetWrite Method #3 {{{3
   elseif b:netrw_method == 3
    " Construct execution string (three or more lines) which will be passed through filter
"    call Decho("read via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    let netrw_fname = b:netrw_fname
    let bhkeep      = &l:bh

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let curbuf      = bufnr("%")
    setl bh=hide
    keepj keepalt enew
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd") && s:netrw_passwd != ""
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     endif
    endif
    NetrwKeepj put =g:netrw_ftpmode
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
    endif
    NetrwKeepj put ='put \"'.tmpfile.'\" \"'.netrw_fname.'\"'
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    " save choice/id/password for future use
    let b:netrw_lastfile = choice

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    NetrwKeepj norm! 1Gdd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
     if  !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
     endif
     let mod=1
    endif

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh= bhkeep
    exe filtbuf."bw!"

   ".........................................
   " NetWrite: (scp) NetWrite Method #4 {{{3
   elseif     b:netrw_method == 4
"    call Decho("write via scp (method #4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".fnameescape(g:netrw_port)
    else
     let useport= ""
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1))
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (http) NetWrite Method #5 {{{3
   elseif     b:netrw_method == 5
"    call Decho("write via http (method #5)",'~'.expand("<slnum>"))
    let curl= substitute(g:netrw_http_put_cmd,'\s\+.*$',"","")
    if executable(curl)
     let url= g:netrw_choice
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(url,1) )
    elseif !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"can't write to http using <".g:netrw_http_put_cmd".">".",16)
    endif

   ".........................................
   " NetWrite: (dav) NetWrite Method #6 (cadaver) {{{3
   elseif     b:netrw_method == 6
"    call Decho("write via cadaver (method #6)",'~'.expand("<slnum>"))

    " Construct execution string (four lines) which will be passed through filter
    let netrw_fname = escape(b:netrw_fname,g:netrw_fname_escape)
    let bhkeep      = &l:bh

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let curbuf      = bufnr("%")
    setl bh=hide
    keepj keepalt enew

    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     NetrwKeepj put ='open '.g:netrw_machine
    endif
    if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
     NetrwKeepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
    endif
    NetrwKeepj put ='put '.tmpfile.' '.netrw_fname

    " perform cadaver operation:
    NetrwKeepj norm! 1Gdd
    call s:NetrwExe(s:netrw_silentxfer."%!".g:netrw_dav_cmd)

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"

    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (rsync) NetWrite Method #7 {{{3
   elseif     b:netrw_method == 7
"    call Decho("write via rsync (method #7)",'~'.expand("<slnum>"))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1))
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (sftp) NetWrite Method #9 {{{3
   elseif     b:netrw_method == 9
"    call Decho("write via sftp (method #9)",'~'.expand("<slnum>"))
    let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
    if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
     let uid_machine = g:netrw_uid .'@'. g:netrw_machine
    else
     let uid_machine = g:netrw_machine
    endif

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let bhkeep = &l:bh
    let curbuf = bufnr("%")
    setl bh=hide
    keepj keepalt enew

    setl ff=unix
    call setline(1,'put "'.escape(tmpfile,'\').'" '.netrw_fname)
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    let sftpcmd= substitute(g:netrw_sftp_cmd,"%TEMPFILE%",escape(tmpfile,'\'),"g")
    call s:NetrwExe(s:netrw_silentxfer."%!".sftpcmd.' '.s:ShellEscape(uid_machine,1))
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: Complain {{{3
   else
    call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",17)
    let leavemod= 1
   endif
  endwhile

  " NetWrite: Cleanup: {{{3
"  call Decho("cleanup",'~'.expand("<slnum>"))
  if s:FileReadable(tmpfile)
"   call Decho("tmpfile<".tmpfile."> readable, will now delete it",'~'.expand("<slnum>"))
   call s:NetrwDelete(tmpfile)
  endif
  call s:NetrwOptionRestore("w:")

  if a:firstline == 1 && a:lastline == line("$")
   " restore modifiability; usually equivalent to set nomod
   let &mod= mod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
  elseif !exists("leavemod")
   " indicate that the buffer has not been modified since last written
"   call Decho("set nomod",'~'.expand("<slnum>"))
   setl nomod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
  endif

"  call Dret("netrw#NetWrite")
endfun

" ---------------------------------------------------------------------
" netrw#NetSource: source a remotely hosted vim script {{{2
" uses NetRead to get a copy of the file into a temporarily file,
"              then sources that file,
"              then removes that file.
fun! netrw#NetSource(...)
"  call Dfunc("netrw#NetSource() a:0=".a:0)
  if a:0 > 0 && a:1 == '?'
   " give help
   echomsg 'NetSource Usage:'
   echomsg ':Nsource dav://machine[:port]/path            uses cadaver'
   echomsg ':Nsource fetch://machine/path                 uses fetch'
   echomsg ':Nsource ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
   echomsg ':Nsource http[s]://[user@]machine/path        uses http  wget'
   echomsg ':Nsource rcp://[user@]machine/path            uses rcp'
   echomsg ':Nsource rsync://machine[:port]/path          uses rsync'
   echomsg ':Nsource scp://[user@]machine[[:#]port]/path  uses scp'
   echomsg ':Nsource sftp://[user@]machine[[:#]port]/path uses sftp'
   sleep 4
  else
   let i= 1
   while i <= a:0
    call netrw#NetRead(3,a:{i})
"    call Decho("s:netread_tmpfile<".s:netrw_tmpfile.">",'~'.expand("<slnum>"))
    if s:FileReadable(s:netrw_tmpfile)
"     call Decho("exe so ".fnameescape(s:netrw_tmpfile),'~'.expand("<slnum>"))
     exe "so ".fnameescape(s:netrw_tmpfile)
"     call Decho("delete(".s:netrw_tmpfile.")",'~'.expand("<slnum>"))
     if delete(s:netrw_tmpfile)
      call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".s:netrw_tmpfile.">!",103)
     endif
     unlet s:netrw_tmpfile
    else
     call netrw#ErrorMsg(s:ERROR,"unable to source <".a:{i}.">!",48)
    endif
    let i= i + 1
   endwhile
  endif
"  call Dret("netrw#NetSource")
endfun

" ---------------------------------------------------------------------
" netrw#SetTreetop: resets the tree top to the current directory/specified directory {{{2
"                   (implements the :Ntree command)
fun! netrw#SetTreetop(...)
"  call Dfunc("netrw#SetTreetop(".((a:0 > 0)? a:1 : "").") a:0=".a:0)

  " clear out the current tree
  if exists("w:netrw_treetop")
"   call Decho("clearing out current tree",'~'.expand("<slnum>"))
   let inittreetop= w:netrw_treetop
   unlet w:netrw_treetop
  endif
  if exists("w:netrw_treedict")
"   call Decho("freeing w:netrw_treedict",'~'.expand("<slnum>"))
   unlet w:netrw_treedict
  endif

  if a:1 == "" && exists("inittreetop")
   let treedir= s:NetrwTreePath(inittreetop)
"   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  else
   if isdirectory(s:NetrwFile(a:1))
"    call Decho("a:1<".a:1."> is a directory",'~'.expand("<slnum>"))
    let treedir= a:1
   elseif exists("b:netrw_curdir") && (isdirectory(s:NetrwFile(b:netrw_curdir."/".a:1)) || a:1 =~ '^\a\{3,}://')
    let treedir= b:netrw_curdir."/".a:1
"    call Decho("a:1<".a:1."> is NOT a directory, trying treedir<".treedir.">",'~'.expand("<slnum>"))
   else
    " normally the cursor is left in the message window.
    " However, here this results in the directory being listed in the message window, which is not wanted.
    let netrwbuf= bufnr("%")
    call netrw#ErrorMsg(s:ERROR,"sorry, ".a:1." doesn't seem to be a directory!",95)
    exe bufwinnr(netrwbuf)."wincmd w"
    let treedir= "."
   endif
  endif
"  call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  let islocal= expand("%") !~ '^\a\{3,}://'
"  call Decho("islocal=".islocal,'~'.expand("<slnum>"))
  if islocal
   call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(islocal,treedir))
  else
   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,treedir))
  endif
"  call Dret("netrw#SetTreetop")
endfun

" ===========================================
" s:NetrwGetFile: Function to read temporary file "tfile" with command "readcmd". {{{2
"    readcmd == %r : replace buffer with newly read file
"            == 0r : read file at top of buffer
"            == r  : read file after current line
"            == t  : leave file in temporary form (ie. don't read into buffer)
fun! s:NetrwGetFile(readcmd, tfile, method)
"  call Dfunc("NetrwGetFile(readcmd<".a:readcmd.">,tfile<".a:tfile."> method<".a:method.">)")

  " readcmd=='t': simply do nothing
  if a:readcmd == 't'
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("NetrwGetFile : skip read of <".a:tfile.">")
   return
  endif

  " get name of remote filename (ie. url and all)
  let rfile= bufname("%")
"  call Decho("rfile<".rfile.">",'~'.expand("<slnum>"))

  if exists("*NetReadFixup")
   " for the use of NetReadFixup (not otherwise used internally)
   let line2= line("$")
  endif

  if a:readcmd[0] == '%'
  " get file into buffer
"   call Decho("get file into buffer",'~'.expand("<slnum>"))

   " rename the current buffer to the temp file (ie. tfile)
   if g:netrw_cygwin
    let tfile= substitute(a:tfile,g:netrw_cygdrive.'/\(.\)','\1:','')
   else
    let tfile= a:tfile
   endif
"   call Decho("exe sil! keepalt file ".fnameescape(tfile),'~'.expand("<slnum>"))
   exe "sil! keepalt file ".fnameescape(tfile)

   " edit temporary file (ie. read the temporary file in)
   if     rfile =~ '\.zip$'
"    call Decho("handling remote zip file with zip#Browse(tfile<".tfile.">)",'~'.expand("<slnum>"))
    call zip#Browse(tfile)
   elseif rfile =~ '\.tar$'
"    call Decho("handling remote tar file with tar#Browse(tfile<".tfile.">)",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.gz$'
"    call Decho("handling remote gzip-compressed tar file",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.bz2$'
"    call Decho("handling remote bz2-compressed tar file",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.xz$'
"    call Decho("handling remote xz-compressed tar file",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.txz$'
"    call Decho("handling remote xz-compressed tar file (.txz)",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   else
"    call Decho("edit temporary file",'~'.expand("<slnum>"))
    NetrwKeepj e!
   endif

   " rename buffer back to remote filename
"   call Decho("exe sil! keepalt file ".fnameescape(rfile),'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj keepalt file ".fnameescape(rfile)

   " Detect filetype of local version of remote file.
   " Note that isk must not include a "/" for scripts.vim
   " to process this detection correctly.
"   call Decho("detect filetype of local version of remote file",'~'.expand("<slnum>"))
   let iskkeep= &l:isk
   setl isk-=/
   let &l:isk= iskkeep
"   call Dredir("renamed buffer back to remote filename<".rfile."> : expand(%)<".expand("%").">","ls!")
   let line1 = 1
   let line2 = line("$")

  elseif !&ma
   " attempting to read a file after the current line in the file, but the buffer is not modifiable
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"attempt to read<".a:tfile."> into a non-modifiable buffer!",94)
"   call Dret("NetrwGetFile : attempt to read<".a:tfile."> into a non-modifiable buffer!")
   return

  elseif s:FileReadable(a:tfile)
   " read file after current line
"   call Decho("read file<".a:tfile."> after current line",'~'.expand("<slnum>"))
   let curline = line(".")
   let lastline= line("$")
"   call Decho("exe<".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile).">  line#".curline,'~'.expand("<slnum>"))
   exe "NetrwKeepj ".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile)
   let line1= curline + 1
   let line2= line("$") - lastline + 1

  else
   " not readable
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Decho("tfile<".a:tfile."> not readable",'~'.expand("<slnum>"))
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"file <".a:tfile."> not readable",9)
"   call Dret("NetrwGetFile : tfile<".a:tfile."> not readable")
   return
  endif

  " User-provided (ie. optional) fix-it-up command
  if exists("*NetReadFixup")
"   call Decho("calling NetReadFixup(method<".a:method."> line1=".line1." line2=".line2.")",'~'.expand("<slnum>"))
   NetrwKeepj call NetReadFixup(a:method, line1, line2)
"  else " Decho
"   call Decho("NetReadFixup() not called, doesn't exist  (line1=".line1." line2=".line2.")",'~'.expand("<slnum>"))
  endif

  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   " update the Buffers menu
   NetrwKeepj call s:UpdateBuffersMenu()
  endif

"  call Decho("readcmd<".a:readcmd."> cmdarg<".v:cmdarg."> tfile<".a:tfile."> readable=".s:FileReadable(a:tfile),'~'.expand("<slnum>"))

 " make sure file is being displayed
"  redraw!

"  call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Dret("NetrwGetFile")
endfun

" ------------------------------------------------------------------------
" s:NetrwMethod:  determine method of transfer {{{2
" Input:
"   choice = url   [protocol:]//[userid@]hostname[:port]/[path-to-file]
" Output:
"  b:netrw_method= 1: rcp
"                  2: ftp + <.netrc>
"	           3: ftp + machine, id, password, and [path]filename
"	           4: scp
"	           5: http[s] (wget)
"	           6: dav
"	           7: rsync
"	           8: fetch
"	           9: sftp
"	          10: file
"  g:netrw_machine= hostname
"  b:netrw_fname  = filename
"  g:netrw_port   = optional port number (for ftp)
"  g:netrw_choice = copy of input url (choice)
fun! s:NetrwMethod(choice)
"   call Dfunc("NetrwMethod(a:choice<".a:choice.">)")

   " sanity check: choice should have at least three slashes in it
   if strlen(substitute(a:choice,'[^/]','','g')) < 3
    call netrw#ErrorMsg(s:ERROR,"not a netrw-style url; netrw uses protocol://[user@]hostname[:port]/[path])",78)
    let b:netrw_method = -1
"    call Dret("NetrwMethod : incorrect url format<".a:choice.">")
    return
   endif

   " record current g:netrw_machine, if any
   " curmachine used if protocol == ftp and no .netrc
   if exists("g:netrw_machine")
    let curmachine= g:netrw_machine
"    call Decho("curmachine<".curmachine.">",'~'.expand("<slnum>"))
   else
    let curmachine= "N O T A HOST"
   endif
   if exists("g:netrw_port")
    let netrw_port= g:netrw_port
   endif

   " insure that netrw_ftp_cmd starts off every method determination
   " with the current g:netrw_ftp_cmd
   let s:netrw_ftp_cmd= g:netrw_ftp_cmd

  " initialization
  let b:netrw_method  = 0
  let g:netrw_machine = ""
  let b:netrw_fname   = ""
  let g:netrw_port    = ""
  let g:netrw_choice  = a:choice

  " Patterns:
  " mipf     : a:machine a:id password filename	     Use ftp
  " mf	    : a:machine filename		     Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
  " ftpurm   : ftp://[user@]host[[#:]port]/filename  Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
  " rcpurm   : rcp://[user@]host/filename	     Use rcp
  " rcphf    : [user@]host:filename		     Use rcp
  " scpurm   : scp://[user@]host[[#:]port]/filename  Use scp
  " httpurm  : http[s]://[user@]host/filename	     Use wget
  " davurm   : dav[s]://host[:port]/path             Use cadaver/curl
  " rsyncurm : rsync://host[:port]/path              Use rsync
  " fetchurm : fetch://[user@]host[:http]/filename   Use fetch (defaults to ftp, override for http)
  " sftpurm  : sftp://[user@]host/filename  Use scp
  " fileurm  : file://[user@]host/filename	     Use elinks or links
  let mipf     = '^\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)$'
  let mf       = '^\(\S\+\)\s\+\(\S\+\)$'
  let ftpurm   = '^ftp://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\([#:]\d\+\)\=/\(.*\)$'
  let rcpurm   = '^rcp://\%(\([^/]*\)@\)\=\([^/]\{-}\)/\(.*\)$'
  let rcphf    = '^\(\(\h\w*\)@\)\=\(\h\w*\):\([^@]\+\)$'
  let scpurm   = '^scp://\([^/#:]\+\)\%([#:]\(\d\+\)\)\=/\(.*\)$'
  let httpurm  = '^https\=://\([^/]\{-}\)\(/.*\)\=$'
  let davurm   = '^davs\=://\([^/]\+\)/\(.*/\)\([-_.~[:alnum:]]\+\)$'
  let rsyncurm = '^rsync://\([^/]\{-}\)/\(.*\)\=$'
  let fetchurm = '^fetch://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\(:http\)\=/\(.*\)$'
  let sftpurm  = '^sftp://\([^/]\{-}\)/\(.*\)\=$'
  let fileurm  = '^file\=://\(.*\)$'

"  call Decho("determine method:",'~'.expand("<slnum>"))
  " Determine Method
  " Method#1: rcp://user@hostname/...path-to-file {{{3
  if match(a:choice,rcpurm) == 0
"   call Decho("rcp://...",'~'.expand("<slnum>"))
   let b:netrw_method  = 1
   let userid          = substitute(a:choice,rcpurm,'\1',"")
   let g:netrw_machine = substitute(a:choice,rcpurm,'\2',"")
   let b:netrw_fname   = substitute(a:choice,rcpurm,'\3',"")
   if userid != ""
    let g:netrw_uid= userid
   endif

  " Method#4: scp://user@hostname/...path-to-file {{{3
  elseif match(a:choice,scpurm) == 0
"   call Decho("scp://...",'~'.expand("<slnum>"))
   let b:netrw_method  = 4
   let g:netrw_machine = substitute(a:choice,scpurm,'\1',"")
   let g:netrw_port    = substitute(a:choice,scpurm,'\2',"")
   let b:netrw_fname   = substitute(a:choice,scpurm,'\3',"")

  " Method#5: http[s]://user@hostname/...path-to-file {{{3
  elseif match(a:choice,httpurm) == 0
"   call Decho("http[s]://...",'~'.expand("<slnum>"))
   let b:netrw_method = 5
   let g:netrw_machine= substitute(a:choice,httpurm,'\1',"")
   let b:netrw_fname  = substitute(a:choice,httpurm,'\2',"")
   let b:netrw_http   = (a:choice =~ '^https:')? "https" : "http"

  " Method#6: dav://hostname[:port]/..path-to-file.. {{{3
  elseif match(a:choice,davurm) == 0
"   call Decho("dav://...",'~'.expand("<slnum>"))
   let b:netrw_method= 6
   if a:choice =~ 'davs:'
    let g:netrw_machine= 'https://'.substitute(a:choice,davurm,'\1/\2',"")
   else
    let g:netrw_machine= 'http://'.substitute(a:choice,davurm,'\1/\2',"")
   endif
   let b:netrw_fname  = substitute(a:choice,davurm,'\3',"")

   " Method#7: rsync://user@hostname/...path-to-file {{{3
  elseif match(a:choice,rsyncurm) == 0
"   call Decho("rsync://...",'~'.expand("<slnum>"))
   let b:netrw_method = 7
   let g:netrw_machine= substitute(a:choice,rsyncurm,'\1',"")
   let b:netrw_fname  = substitute(a:choice,rsyncurm,'\2',"")

   " Methods 2,3: ftp://[user@]hostname[[:#]port]/...path-to-file {{{3
  elseif match(a:choice,ftpurm) == 0
"   call Decho("ftp://...",'~'.expand("<slnum>"))
   let userid	      = substitute(a:choice,ftpurm,'\2',"")
   let g:netrw_machine= substitute(a:choice,ftpurm,'\3',"")
   let g:netrw_port   = substitute(a:choice,ftpurm,'\4',"")
   let b:netrw_fname  = substitute(a:choice,ftpurm,'\5',"")
"   call Decho("g:netrw_machine<".g:netrw_machine.">",'~'.expand("<slnum>"))
   if userid != ""
    let g:netrw_uid= userid
   endif

   if curmachine != g:netrw_machine
    if exists("s:netwr_hup[".g:netrw_machine."]")
     call NetUserPass("ftp:".g:netrw_machine)
    elseif exists("s:netrw_passwd")
     " if there's a change in hostname, require password re-entry
     unlet s:netrw_passwd
    endif
    if exists("netrw_port")
     unlet netrw_port
    endif
   endif

   if exists("g:netrw_uid") && exists("s:netrw_passwd")
    let b:netrw_method = 3
   else
    let host= substitute(g:netrw_machine,'\..*$','','')
    if exists("s:netrw_hup[host]")
     call NetUserPass("ftp:".host)

    elseif (has("win32") || has("win95") || has("win64") || has("win16")) && s:netrw_ftp_cmd =~# '-[sS]:'
"     call Decho("has -s: : s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">",'~'.expand("<slnum>"))
"     call Decho("          g:netrw_ftp_cmd<".g:netrw_ftp_cmd.">",'~'.expand("<slnum>"))
     if g:netrw_ftp_cmd =~# '-[sS]:\S*MACHINE\>'
      let s:netrw_ftp_cmd= substitute(g:netrw_ftp_cmd,'\<MACHINE\>',g:netrw_machine,'')
"      call Decho("s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">",'~'.expand("<slnum>"))
     endif
     let b:netrw_method= 2
    elseif s:FileReadable(expand("$HOME/.netrc")) && !g:netrw_ignorenetrc
"     call Decho("using <".expand("$HOME/.netrc")."> (readable)",'~'.expand("<slnum>"))
     let b:netrw_method= 2
    else
     if !exists("g:netrw_uid") || g:netrw_uid == ""
      call NetUserPass()
     elseif !exists("s:netrw_passwd") || s:netrw_passwd == ""
      call NetUserPass(g:netrw_uid)
    " else just use current g:netrw_uid and s:netrw_passwd
     endif
     let b:netrw_method= 3
    endif
   endif

  " Method#8: fetch {{{3
  elseif match(a:choice,fetchurm) == 0
"   call Decho("fetch://...",'~'.expand("<slnum>"))
   let b:netrw_method = 8
   let g:netrw_userid = substitute(a:choice,fetchurm,'\2',"")
   let g:netrw_machine= substitute(a:choice,fetchurm,'\3',"")
   let b:netrw_option = substitute(a:choice,fetchurm,'\4',"")
   let b:netrw_fname  = substitute(a:choice,fetchurm,'\5',"")

   " Method#3: Issue an ftp : "machine id password [path/]filename" {{{3
  elseif match(a:choice,mipf) == 0
"   call Decho("(ftp) host id pass file",'~'.expand("<slnum>"))
   let b:netrw_method  = 3
   let g:netrw_machine = substitute(a:choice,mipf,'\1',"")
   let g:netrw_uid     = substitute(a:choice,mipf,'\2',"")
   let s:netrw_passwd  = substitute(a:choice,mipf,'\3',"")
   let b:netrw_fname   = substitute(a:choice,mipf,'\4',"")
   call NetUserPass(g:netrw_machine,g:netrw_uid,s:netrw_passwd)

  " Method#3: Issue an ftp: "hostname [path/]filename" {{{3
  elseif match(a:choice,mf) == 0
"   call Decho("(ftp) host file",'~'.expand("<slnum>"))
   if exists("g:netrw_uid") && exists("s:netrw_passwd")
    let b:netrw_method  = 3
    let g:netrw_machine = substitute(a:choice,mf,'\1',"")
    let b:netrw_fname   = substitute(a:choice,mf,'\2',"")

   elseif s:FileReadable(expand("$HOME/.netrc"))
    let b:netrw_method  = 2
    let g:netrw_machine = substitute(a:choice,mf,'\1',"")
    let b:netrw_fname   = substitute(a:choice,mf,'\2',"")
   endif

  " Method#9: sftp://user@hostname/...path-to-file {{{3
  elseif match(a:choice,sftpurm) == 0
"   call Decho("sftp://...",'~'.expand("<slnum>"))
   let b:netrw_method = 9
   let g:netrw_machine= substitute(a:choice,sftpurm,'\1',"")
   let b:netrw_fname  = substitute(a:choice,sftpurm,'\2',"")

  " Method#1: Issue an rcp: hostname:filename"  (this one should be last) {{{3
  elseif match(a:choice,rcphf) == 0
"   call Decho("(rcp) [user@]host:file) rcphf<".rcphf.">",'~'.expand("<slnum>"))
   let b:netrw_method  = 1
   let userid          = substitute(a:choice,rcphf,'\2',"")
   let g:netrw_machine = substitute(a:choice,rcphf,'\3',"")
   let b:netrw_fname   = substitute(a:choice,rcphf,'\4',"")
"   call Decho('\1<'.substitute(a:choice,rcphf,'\1',"").">",'~'.expand("<slnum>"))
"   call Decho('\2<'.substitute(a:choice,rcphf,'\2',"").">",'~'.expand("<slnum>"))
"   call Decho('\3<'.substitute(a:choice,rcphf,'\3',"").">",'~'.expand("<slnum>"))
"   call Decho('\4<'.substitute(a:choice,rcphf,'\4',"").">",'~'.expand("<slnum>"))
   if userid != ""
    let g:netrw_uid= userid
   endif

   " Method#10: file://user@hostname/...path-to-file {{{3
  elseif match(a:choice,fileurm) == 0 && exists("g:netrw_file_cmd")
"   call Decho("http[s]://...",'~'.expand("<slnum>"))
   let b:netrw_method = 10
   let b:netrw_fname  = substitute(a:choice,fileurm,'\1',"")
"   call Decho('\1<'.substitute(a:choice,fileurm,'\1',"").">",'~'.expand("<slnum>"))

  " Cannot Determine Method {{{3
  else
   if !exists("g:netrw_quiet")
    call netrw#ErrorMsg(s:WARNING,"cannot determine method (format: protocol://[user@]hostname[:port]/[path])",45)
   endif
   let b:netrw_method  = -1
  endif
  "}}}3

  if g:netrw_port != ""
   " remove any leading [:#] from port number
   let g:netrw_port = substitute(g:netrw_port,'[#:]\+','','')
  elseif exists("netrw_port")
   " retain port number as implicit for subsequent ftp operations
   let g:netrw_port= netrw_port
  endif

"  call Decho("a:choice       <".a:choice.">",'~'.expand("<slnum>"))
"  call Decho("b:netrw_method <".b:netrw_method.">",'~'.expand("<slnum>"))
"  call Decho("g:netrw_machine<".g:netrw_machine.">",'~'.expand("<slnum>"))
"  call Decho("g:netrw_port   <".g:netrw_port.">",'~'.expand("<slnum>"))
"  if exists("g:netrw_uid")		"Decho
"   call Decho("g:netrw_uid    <".g:netrw_uid.">",'~'.expand("<slnum>"))
"  endif					"Decho
"  if exists("s:netrw_passwd")		"Decho
"   call Decho("s:netrw_passwd <".s:netrw_passwd.">",'~'.expand("<slnum>"))
"  endif					"Decho
"  call Decho("b:netrw_fname  <".b:netrw_fname.">",'~'.expand("<slnum>"))
"  call Dret("NetrwMethod : b:netrw_method=".b:netrw_method." g:netrw_port=".g:netrw_port)
endfun

" ------------------------------------------------------------------------
" NetReadFixup: this sort of function is typically written by the user {{{2
"               to handle extra junk that their system's ftp dumps
"               into the transfer.  This function is provided as an
"               example and as a fix for a Windows 95 problem: in my
"               experience, win95's ftp always dumped four blank lines
"               at the end of the transfer.
if has("win95") && exists("g:netrw_win95ftp") && g:netrw_win95ftp
 fun! NetReadFixup(method, line1, line2)
"   call Dfunc("NetReadFixup(method<".a:method."> line1=".a:line1." line2=".a:line2.")")

   " sanity checks -- attempt to convert inputs to integers
   let method = a:method + 0
   let line1  = a:line1 + 0
   let line2  = a:line2 + 0
   if type(method) != 0 || type(line1) != 0 || type(line2) != 0 || method < 0 || line1 <= 0 || line2 <= 0
"    call Dret("NetReadFixup")
    return
   endif

   if method == 3   " ftp (no <.netrc>)
    let fourblanklines= line2 - 3
    if fourblanklines >= line1
     exe "sil NetrwKeepj ".fourblanklines.",".line2."g/^\s*$/d"
     call histdel("/",-1)
    endif
   endif

"   call Dret("NetReadFixup")
 endfun
endif

" ---------------------------------------------------------------------
" NetUserPass: set username and password for subsequent ftp transfer {{{2
"   Usage:  :call NetUserPass()		               -- will prompt for userid and password
"	    :call NetUserPass("uid")	               -- will prompt for password
"	    :call NetUserPass("uid","password")        -- sets global userid and password
"	    :call NetUserPass("ftp:host")              -- looks up userid and password using hup dictionary
"	    :call NetUserPass("host","uid","password") -- sets hup dictionary with host, userid, password
fun! NetUserPass(...)

" call Dfunc("NetUserPass() a:0=".a:0)

 if !exists('s:netrw_hup')
  let s:netrw_hup= {}
 endif

 if a:0 == 0
  " case: no input arguments

  " change host and username if not previously entered; get new password
  if !exists("g:netrw_machine")
   let g:netrw_machine= input('Enter hostname: ')
  endif
  if !exists("g:netrw_uid") || g:netrw_uid == ""
   " get username (user-id) via prompt
   let g:netrw_uid= input('Enter username: ')
  endif
  " get password via prompting
  let s:netrw_passwd= inputsecret("Enter Password: ")

  " set up hup database
  let host = substitute(g:netrw_machine,'\..*$','','')
  if !exists('s:netrw_hup[host]')
   let s:netrw_hup[host]= {}
  endif
  let s:netrw_hup[host].uid    = g:netrw_uid
  let s:netrw_hup[host].passwd = s:netrw_passwd

 elseif a:0 == 1
  " case: one input argument

  if a:1 =~ '^ftp:'
   " get host from ftp:... url
   " access userid and password from hup (host-user-passwd) dictionary
"   call Decho("case a:0=1: a:1<".a:1."> (get host from ftp:... url)",'~'.expand("<slnum>"))
   let host = substitute(a:1,'^ftp:','','')
   let host = substitute(host,'\..*','','')
   if exists("s:netrw_hup[host]")
    let g:netrw_uid    = s:netrw_hup[host].uid
    let s:netrw_passwd = s:netrw_hup[host].passwd
"    call Decho("get s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">",'~'.expand("<slnum>"))
"    call Decho("get s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">",'~'.expand("<slnum>"))
   else
    let g:netrw_uid    = input("Enter UserId: ")
    let s:netrw_passwd = inputsecret("Enter Password: ")
   endif

  else
   " case: one input argument, not an url.  Using it as a new user-id.
"   call Decho("case a:0=1: a:1<".a:1."> (get host from input argument, not an url)",'~'.expand("<slnum>"))
   if exists("g:netrw_machine")
    if g:netrw_machine =~ '[0-9.]\+'
     let host= g:netrw_machine
    else
     let host= substitute(g:netrw_machine,'\..*$','','')
    endif
   else
    let g:netrw_machine= input('Enter hostname: ')
   endif
   let g:netrw_uid = a:1
"   call Decho("set g:netrw_uid= <".g:netrw_uid.">",'~'.expand("<slnum>"))
   if exists("g:netrw_passwd")
    " ask for password if one not previously entered
    let s:netrw_passwd= g:netrw_passwd
   else
    let s:netrw_passwd = inputsecret("Enter Password: ")
   endif
  endif

"  call Decho("host<".host.">",'~'.expand("<slnum>"))
  if exists("host")
   if !exists('s:netrw_hup[host]')
    let s:netrw_hup[host]= {}
   endif
   let s:netrw_hup[host].uid    = g:netrw_uid
   let s:netrw_hup[host].passwd = s:netrw_passwd
  endif

 elseif a:0 == 2
  let g:netrw_uid    = a:1
  let s:netrw_passwd = a:2

 elseif a:0 == 3
  " enter hostname, user-id, and password into the hup dictionary
  let host = substitute(a:1,'^\a\+:','','')
  let host = substitute(host,'\..*$','','')
  if !exists('s:netrw_hup[host]')
   let s:netrw_hup[host]= {}
  endif
  let s:netrw_hup[host].uid    = a:2
  let s:netrw_hup[host].passwd = a:3
  let g:netrw_uid              = s:netrw_hup[host].uid
  let s:netrw_passwd           = s:netrw_hup[host].passwd
"  call Decho("set s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">",'~'.expand("<slnum>"))
"  call Decho("set s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">",'~'.expand("<slnum>"))
 endif

" call Dret("NetUserPass : uid<".g:netrw_uid."> passwd<".s:netrw_passwd.">")
endfun

" ===========================================
"  Shared Browsing Support:    {{{1
" ===========================================

" ---------------------------------------------------------------------
" s:ExplorePatHls: converts an Explore pattern into a regular expression search pattern {{{2
fun! s:ExplorePatHls(pattern)
"  call Dfunc("s:ExplorePatHls(pattern<".a:pattern.">)")
  let repat= substitute(a:pattern,'^**/\{1,2}','','')
"  call Decho("repat<".repat.">",'~'.expand("<slnum>"))
  let repat= escape(repat,'][.\')
"  call Decho("repat<".repat.">",'~'.expand("<slnum>"))
  let repat= '\<'.substitute(repat,'\*','\\(\\S\\+ \\)*\\S\\+','g').'\>'
"  call Dret("s:ExplorePatHls repat<".repat.">")
  return repat
endfun

" ---------------------------------------------------------------------
"  s:NetrwBookHistHandler: {{{2
"    0: (user: <mb>)   bookmark current directory
"    1: (user: <gb>)   change to the bookmarked directory
"    2: (user: <qb>)   list bookmarks
"    3: (browsing)     records current directory history
"    4: (user: <u>)    go up   (previous) directory, using history
"    5: (user: <U>)    go down (next)     directory, using history
"    6: (user: <mB>)   delete bookmark
fun! s:NetrwBookHistHandler(chg,curdir)
"  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
"   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
   return
  endif

  let ykeep    = @@
  let curbufnr = bufnr("%")

  if a:chg == 0
   " bookmark the current directory
"   call Decho("(user: <b>) bookmark the current directory",'~'.expand("<slnum>"))
   if exists("s:netrwmarkfilelist_{curbufnr}")
    call s:NetrwBookmark(0)
    echo "bookmarked marked files"
   else
    call s:MakeBookmark(a:curdir)
    echo "bookmarked the current directory"
   endif

  elseif a:chg == 1
   " change to the bookmarked directory
"   call Decho("(user: <".v:count."gb>) change to the bookmarked directory",'~'.expand("<slnum>"))
   if exists("g:netrw_bookmarklist[v:count-1]")
"    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
    exe "NetrwKeepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
   else
    echomsg "Sorry, bookmark#".v:count." doesn't exist!"
   endif

  elseif a:chg == 2
"   redraw!
   let didwork= 0
   " list user's bookmarks
"   call Decho("(user: <q>) list user's bookmarks",'~'.expand("<slnum>"))
   if exists("g:netrw_bookmarklist")
"    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks','~'.expand("<slnum>"))
    let cnt= 1
    for bmd in g:netrw_bookmarklist
"     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1],'~'.expand("<slnum>"))
     echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
     let didwork = 1
     let cnt     = cnt + 1
    endfor
   endif

   " list directory history
   let cnt     = g:netrw_dirhist_cnt
   let first   = 1
   let histcnt = 0
   if g:netrw_dirhistmax > 0
    while ( first || cnt != g:netrw_dirhist_cnt )
"    call Decho("first=".first." cnt=".cnt." dirhist_cnt=".g:netrw_dirhist_cnt,'~'.expand("<slnum>"))
     if exists("g:netrw_dirhist_{cnt}")
"     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt},'~'.expand("<slnum>"))
      echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
      let didwork= 1
     endif
     let histcnt = histcnt + 1
     let first   = 0
     let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
     if cnt < 0
      let cnt= cnt + g:netrw_dirhistmax
     endif
    endwhile
   else
    let g:netrw_dirhist_cnt= 0
   endif
   if didwork
    call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   endif

  elseif a:chg == 3
   " saves most recently visited directories (when they differ)
"   call Decho("(browsing) record curdir history",'~'.expand("<slnum>"))
   if !exists("g:netrw_dirhist_cnt") || !exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}") || g:netrw_dirhist_{g:netrw_dirhist_cnt} != a:curdir
    if g:netrw_dirhistmax > 0
     let g:netrw_dirhist_cnt                   = ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
     let g:netrw_dirhist_{g:netrw_dirhist_cnt} = a:curdir
    endif
"    call Decho("save dirhist#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
   endif

  elseif a:chg == 4
   " u: change to the previous directory stored on the history list
"   call Decho("(user: <u>) chg to prev dir from history",'~'.expand("<slnum>"))
   if g:netrw_dirhistmax > 0
    let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - v:count1 ) % g:netrw_dirhistmax
    if g:netrw_dirhist_cnt < 0
     let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
    endif
   else
    let g:netrw_dirhist_cnt= 0
   endif
   if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
"    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
     setl ma noro
"     call Decho("setl ma noro",'~'.expand("<slnum>"))
     sil! NetrwKeepj %d _
     setl nomod
"     call Decho("setl nomod",'~'.expand("<slnum>"))
"     call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    endif
"    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}),'~'.expand("<slnum>"))
    exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
   else
    if g:netrw_dirhistmax > 0
     let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + v:count1 ) % g:netrw_dirhistmax
    else
     let g:netrw_dirhist_cnt= 0
    endif
    echo "Sorry, no predecessor directory exists yet"
   endif

  elseif a:chg == 5
   " U: change to the subsequent directory stored on the history list
"   call Decho("(user: <U>) chg to next dir from history",'~'.expand("<slnum>"))
   if g:netrw_dirhistmax > 0
    let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
    if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
"    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
"      call Decho("setl ma noro",'~'.expand("<slnum>"))
      setl ma noro
      sil! NetrwKeepj %d _
"      call Decho("removed all lines from buffer (%d)",'~'.expand("<slnum>"))
"      call Decho("setl nomod",'~'.expand("<slnum>"))
      setl nomod
"      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
     endif
"    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}),'~'.expand("<slnum>"))
     exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
    else
     let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - 1 ) % g:netrw_dirhistmax
     if g:netrw_dirhist_cnt < 0
      let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
     endif
     echo "Sorry, no successor directory exists yet"
    endif
   else
    let g:netrw_dirhist_cnt= 0
    echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
   endif

  elseif a:chg == 6
"   call Decho("(user: <mB>) delete bookmark'd directory",'~'.expand("<slnum>"))
   if exists("s:netrwmarkfilelist_{curbufnr}")
    call s:NetrwBookmark(1)
    echo "removed marked files from bookmarks"
   else
    " delete the v:count'th bookmark
    let iremove = v:count
    let dremove = g:netrw_bookmarklist[iremove - 1]
"    call Decho("delete bookmark#".iremove."<".g:netrw_bookmarklist[iremove - 1].">",'~'.expand("<slnum>"))
    call s:MergeBookmarks()
"    call Decho("remove g:netrw_bookmarklist[".(iremove-1)."]<".g:netrw_bookmarklist[(iremove-1)].">",'~'.expand("<slnum>"))
    NetrwKeepj call remove(g:netrw_bookmarklist,iremove-1)
    echo "removed ".dremove." from g:netrw_bookmarklist"
"    call Decho("g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
   endif
"   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
  endif
  call s:NetrwBookmarkMenu()
  call s:NetrwTgtMenu()
  let @@= ykeep
"  call Dret("s:NetrwBookHistHandler")
endfun

" ---------------------------------------------------------------------
" s:NetrwBookHistRead: this function reads bookmarks and history {{{2
"  Will source the history file (.netrwhist) only if the g:netrw_disthistmax is > 0.
"                      Sister function: s:NetrwBookHistSave()
fun! s:NetrwBookHistRead()
"  call Dfunc("s:NetrwBookHistRead()")
  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
"   "  call Dret("s:NetrwBookHistRead - suppressed due to g:netrw_dirhistmax")
   return
  endif
  let ykeep= @@
  if !exists("s:netrw_initbookhist")
   let home    = s:NetrwHome()
   let savefile= home."/.netrwbook"
   if filereadable(s:NetrwFile(savefile))
"    call Decho("sourcing .netrwbook",'~'.expand("<slnum>"))
    exe "keepalt NetrwKeepj so ".savefile
   endif
   if g:netrw_dirhistmax > 0
    let savefile= home."/.netrwhist"
    if filereadable(s:NetrwFile(savefile))
"    call Decho("sourcing .netrwhist",'~'.expand("<slnum>"))
     exe "keepalt NetrwKeepj so ".savefile
    endif
    let s:netrw_initbookhist= 1
    au VimLeave * call s:NetrwBookHistSave()
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwBookHistRead")
endfun

" ---------------------------------------------------------------------
" s:NetrwBookHistSave: this function saves bookmarks and history {{{2
"                      Sister function: s:NetrwBookHistRead()
"                      I used to do this via viminfo but that appears to
"                      be unreliable for long-term storage
"                      If g:netrw_dirhistmax is <= 0, no history or bookmarks
"                      will be saved.
fun! s:NetrwBookHistSave()
"  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax)
  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
"   call Dret("s:NetrwBookHistSave : dirhistmax=".g:netrw_dirhistmax)
   return
  endif

  let savefile= s:NetrwHome()."/.netrwhist"
  1split
  call s:NetrwEnew()
  if g:netrw_use_noswf
   setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
  else
   setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000
  endif
  setl nocin noai noci magic nospell nohid wig= noaw
  setl ma noro write
  if exists("+acd") | setl noacd | endif
  sil! NetrwKeepj keepalt %d _

  " save .netrwhist -- no attempt to merge
  sil! keepalt file .netrwhist
  call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
  call setline(2,"let g:netrw_dirhist_cnt =".g:netrw_dirhist_cnt)
  let lastline = line("$")
  let cnt      = 1
  while cnt <= g:netrw_dirhist_cnt
   call setline((cnt+lastline),'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
   let cnt= cnt + 1
  endwhile
  exe "sil! w! ".savefile

  sil NetrwKeepj %d _
  if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
   " merge and write .netrwbook
   let savefile= s:NetrwHome()."/.netrwbook"

   if filereadable(s:NetrwFile(savefile))
    let booklist= deepcopy(g:netrw_bookmarklist)
    exe "sil NetrwKeepj keepalt so ".savefile
    for bdm in booklist
     if index(g:netrw_bookmarklist,bdm) == -1
      call add(g:netrw_bookmarklist,bdm)
     endif
    endfor
    call sort(g:netrw_bookmarklist)
   endif

   " construct and save .netrwbook
   call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
   exe "sil! w! ".savefile
  endif
  let bgone= bufnr("%")
  q!
  exe "keepalt ".bgone."bwipe!"

"  call Dret("s:NetrwBookHistSave")
endfun

" ---------------------------------------------------------------------
" s:NetrwBrowse: This function uses the command in g:netrw_list_cmd to provide a {{{2
"  list of the contents of a local or remote directory.  It is assumed that the
"  g:netrw_list_cmd has a string, USEPORT HOSTNAME, that needs to be substituted
"  with the requested remote hostname first.
"    Often called via:  Explore/e dirname/etc -> netrw#LocalBrowseCheck() -> s:NetrwBrowse()
fun! s:NetrwBrowse(islocal,dirname)
  if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
"  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
"  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"  call Dredir("ls!")

  " save alternate-file's filename if w:netrw_rexlocal doesn't exist
  " This is useful when one edits a local file, then :e ., then :Rex
  if a:islocal && !exists("w:netrw_rexfile") && bufname("#") != ""
   let w:netrw_rexfile= bufname("#")
"   call Decho("setting w:netrw_rexfile<".w:netrw_rexfile."> win#".winnr(),'~'.expand("<slnum>"))
  endif

  " s:NetrwBrowse : initialize history {{{3
  if !exists("s:netrw_initbookhist")
   NetrwKeepj call s:NetrwBookHistRead()
  endif

  " s:NetrwBrowse : simplify the dirname (especially for ".."s in dirnames) {{{3
  if a:dirname !~ '^\a\{3,}://'
   let dirname= simplify(a:dirname)
  else
   let dirname= a:dirname
  endif

  if exists("s:netrw_skipbrowse")
   unlet s:netrw_skipbrowse
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." filename<".expand("%")."> win#".winnr()." ft<".&ft.">",'~'.expand("<slnum>"))
"   call Dret("s:NetrwBrowse : s:netrw_skipbrowse existed")
   return
  endif

  " s:NetrwBrowse : sanity checks: {{{3
  if !exists("*shellescape")
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
"   call Dret("s:NetrwBrowse : missing shellescape()")
   return
  endif
  if !exists("*fnameescape")
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
"   call Dret("s:NetrwBrowse : missing fnameescape()")
   return
  endif

  " s:NetrwBrowse : save options: {{{3
  call s:NetrwOptionSave("w:")

  " s:NetrwBrowse : re-instate any marked files {{{3
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("clearing marked files",'~'.expand("<slnum>"))
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  endif

  if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
   " s:NetrwBrowse : set up "safe" options for local directory/file {{{3
"   call Decho("handle w:netrw_acdkeep:",'~'.expand("<slnum>"))
"   call Decho("NetrwKeepj lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")",'~'.expand("<slnum>"))
   call s:NetrwLcd(dirname)
   call s:NetrwSafeOptions()
"   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))

  elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
   " s:NetrwBrowse :  remote regular file handler {{{3
"   call Decho("handle remote regular file: dirname<".dirname.">",'~'.expand("<slnum>"))
   if bufname(dirname) != ""
"    call Decho("edit buf#".bufname(dirname)." in win#".winnr(),'~'.expand("<slnum>"))
    exe "NetrwKeepj b ".bufname(dirname)
   else
    " attempt transfer of remote regular file
"    call Decho("attempt transfer as regular file<".dirname.">",'~'.expand("<slnum>"))

    " remove any filetype indicator from end of dirname, except for the
    " "this is a directory" indicator (/).
    " There shouldn't be one of those here, anyway.
    let path= substitute(dirname,'[*=@|]\r\=$','','e')
"    call Decho("new path<".path.">",'~'.expand("<slnum>"))
    call s:RemotePathAnalysis(dirname)

    " s:NetrwBrowse : remote-read the requested file into current buffer {{{3
    call s:NetrwEnew(dirname)
    call s:NetrwSafeOptions()
    setl ma noro
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    let b:netrw_curdir = dirname
    let url            = s:method."://".((s:user == "")? "" : s:user."@").s:machine.(s:port ? ":".s:port : "")."/".s:path
"    call Decho("exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")",'~'.expand("<slnum>"))
    exe "sil! NetrwKeepj keepalt file ".fnameescape(url)
    exe "sil! NetrwKeepj keepalt doau BufReadPre ".fnameescape(s:fname)
    sil call netrw#NetRead(2,url)
    " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
"    call Decho("url<".url.">",'~'.expand("<slnum>"))
"    call Decho("s:path<".s:path.">",'~'.expand("<slnum>"))
"    call Decho("s:fname<".s:fname.">",'~'.expand("<slnum>"))
    if s:path =~ '.bz2'
     exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.bz2$','',''))
    elseif s:path =~ '.gz'
     exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.gz$','',''))
    elseif s:path =~ '.gz'
     exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.txz$','',''))
    else
     exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(s:fname)
    endif
   endif

   " s:NetrwBrowse : save certain window-oriented variables into buffer-oriented variables {{{3
   call s:SetBufWinVars()
   call s:NetrwOptionRestore("w:")
"   call Decho("setl ma nomod",'~'.expand("<slnum>"))
   setl ma nomod noro
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))

"   call Dret("s:NetrwBrowse : file<".s:fname.">")
   return
  endif

  " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
  call s:UseBufWinVars()

  " set up some variables {{{3
  let b:netrw_browser_active = 1
  let dirname                = dirname
  let s:last_sort_by         = g:netrw_sort_by

  " set up menu {{{3
  NetrwKeepj call s:NetrwMenu(1)

  " get/set-up buffer {{{3
"  call Decho("saving position across a buffer refresh",'~'.expand("<slnum>"))
  let svpos  = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let reusing= s:NetrwGetBuffer(a:islocal,dirname)

  " maintain markfile highlighting
  if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
"   call Decho("bufnr(%)=".bufnr('%'),'~'.expand("<slnum>"))
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  else
"   call Decho("2match none",'~'.expand("<slnum>"))
   2match none
  endif
  if reusing && line("$") > 1
   call s:NetrwOptionRestore("w:")
"   call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
   setl noma nomod nowrap
"   call Decho("(set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("s:NetrwBrowse : re-using not-cleared buffer")
   return
  endif

  " set b:netrw_curdir to the new directory name {{{3
"  call Decho("set b:netrw_curdir to the new directory name<".dirname."> (buf#".bufnr("%").")",'~'.expand("<slnum>"))
  let b:netrw_curdir= dirname
  if b:netrw_curdir =~ '[/\\]$'
   let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
  endif
  if b:netrw_curdir =~ '\a:$' && (has("win32") || has("win95") || has("win64") || has("win16"))
   let b:netrw_curdir= b:netrw_curdir."/"
  endif
  if b:netrw_curdir == ''
   if has("amiga")
    " On the Amiga, the empty string connotes the current directory
    let b:netrw_curdir= getcwd()
   else
    " under unix, when the root directory is encountered, the result
    " from the preceding substitute is an empty string.
    let b:netrw_curdir= '/'
   endif
  endif
  if !a:islocal && b:netrw_curdir !~ '/$'
   let b:netrw_curdir= b:netrw_curdir.'/'
  endif
"  call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))

  " ------------
  " (local only) {{{3
  " ------------
  if a:islocal
"   call Decho("local only:",'~'.expand("<slnum>"))

   " Set up ShellCmdPost handling.  Append current buffer to browselist
   call s:LocalFastBrowser()

  " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
   if !g:netrw_keepdir
"    call Decho("handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
"    call Decho("l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"),'~'.expand("<slnum>"))
    if !exists("&l:acd") || !&l:acd
     call s:NetrwLcd(b:netrw_curdir)
    endif
   endif

  " --------------------------------
  " remote handling: {{{3
  " --------------------------------
  else
"   call Decho("remote only:",'~'.expand("<slnum>"))

   " analyze dirname and g:netrw_list_cmd {{{3
"   call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">",'~'.expand("<slnum>"))
   if dirname =~# "^NetrwTreeListing\>"
    let dirname= b:netrw_curdir
"    call Decho("(dirname was <NetrwTreeListing>) dirname<".dirname.">",'~'.expand("<slnum>"))
   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
    let dirname= substitute(b:netrw_curdir,'\\','/','g')
    if dirname !~ '/$'
     let dirname= dirname.'/'
    endif
    let b:netrw_curdir = dirname
"    call Decho("(liststyle is TREELIST) dirname<".dirname.">",'~'.expand("<slnum>"))
   else
    let dirname = substitute(dirname,'\\','/','g')
"    call Decho("(normal) dirname<".dirname.">",'~'.expand("<slnum>"))
   endif

   let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
   if dirname !~ dirpat
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
    endif
    NetrwKeepj call s:NetrwOptionRestore("w:")
"    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
    setl noma nomod nowrap
"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
    return
   endif
   let b:netrw_curdir= dirname
"   call Decho("b:netrw_curdir<".b:netrw_curdir."> (remote)",'~'.expand("<slnum>"))
  endif  " (additional remote handling)

  " -----------------------
  " Directory Listing: {{{3
  " -----------------------
  NetrwKeepj call s:NetrwMaps(a:islocal)
  NetrwKeepj call s:NetrwCommands(a:islocal)
  NetrwKeepj call s:PerformListing(a:islocal)

  " restore option(s)
  call s:NetrwOptionRestore("w:")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))

  " If there is a rexposn: restore position with rexposn
  " Otherwise            : set rexposn
  if exists("s:rexposn_".bufnr("%"))
"   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
    NetrwKeepj exe w:netrw_bannercnt
   endif
  else
   NetrwKeepj call s:SetRexDir(a:islocal,b:netrw_curdir)
  endif
  if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
   let &l:bexpr= "netrw#BalloonHelp()"
"   call Decho("set up balloon help: l:bexpr=".&l:bexpr,'~'.expand("<slnum>"))
   setl beval
  endif

  " restore position
  if reusing
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   call winrestview(svpos)
  endif

  " The s:LocalBrowseRefresh() function is called by an autocmd
  " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
  " However, s:NetrwBrowse() causes the FocusGained event to fire the firstt time.
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
  return
endfun

" ---------------------------------------------------------------------
" s:NetrwFile: because of g:netrw_keepdir, isdirectory(), type(), etc may or {{{2
" may not apply correctly; ie. netrw's idea of the current directory may
" differ from vim's.  This function insures that netrw's idea of the current
" directory is used.
fun! s:NetrwFile(fname)
"  call Dfunc("s:NetrwFile(fname<".a:fname.">) win#".winnr())
"  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("g:netrw_cygwin   =".(exists("g:netrw_cygwin")?    g:netrw_cygwin    : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("g:netrw_liststyle=".(exists("g:netrw_liststyle")? g:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))

  " clean up any leading treedepthstring
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
   let fname= substitute(a:fname,'^'.s:treedepthstring.'\+','','')
"   call Decho("clean up any leading treedepthstring: fname<".fname.">",'~'.expand("<slnum>"))
  else
   let fname= a:fname
  endif

  if g:netrw_keepdir
   " vim's idea of the current directory possibly may differ from netrw's
   if !exists("b:netrw_curdir")
    let b:netrw_curdir= getcwd()
   endif

   if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
    if fname =~ '^\' || fname =~ '^\a:\'
     " windows, but full path given
     let ret= fname
"     call Decho("windows+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
    else
     " windows, relative path given
     let ret= s:ComposePath(b:netrw_curdir,fname)
"     call Decho("windows+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
    endif

   elseif fname =~ '^/'
    " not windows, full path given
    let ret= fname
"    call Decho("unix+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
   else
    " not windows, relative path given
    let ret= s:ComposePath(b:netrw_curdir,fname)
"    call Decho("unix+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
   endif
  else
   " vim and netrw agree on the current directory
   let ret= fname
"   call Decho("vim and netrw agree on current directory (g:netrw_keepdir=".g:netrw_keepdir.")",'~'.expand("<slnum>"))
"   call Decho("vim   directory: ".getcwd(),'~'.expand("<slnum>"))
"   call Decho("netrw directory: ".(exists("b:netrw_curdir")? b:netrw_curdir : 'n/a'),'~'.expand("<slnum>"))
  endif

"  call Dret("s:NetrwFile ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:NetrwFileInfo: supports qf (query for file information) {{{2
fun! s:NetrwFileInfo(islocal,fname)
"  call Dfunc("s:NetrwFileInfo(islocal=".a:islocal." fname<".a:fname.">) b:netrw_curdir<".b:netrw_curdir.">")
  let ykeep= @@
  if a:islocal
   let lsopt= "-lsad"
   if g:netrw_sizestyle =~# 'H'
    let lsopt= "-lsadh"
   elseif g:netrw_sizestyle =~# 'h'
    let lsopt= "-lsadh --si"
   endif
   if (has("unix") || has("macunix")) && executable("/bin/ls")

    if getline(".") == "../"
     echo system("/bin/ls ".lsopt." ".s:ShellEscape(".."))
"     call Decho("#1: echo system(/bin/ls -lsad ".s:ShellEscape(..).")",'~'.expand("<slnum>"))

    elseif w:netrw_liststyle == s:TREELIST && getline(".") !~ '^'.s:treedepthstring
     echo system("/bin/ls ".lsopt." ".s:ShellEscape(b:netrw_curdir))
"     call Decho("#2: echo system(/bin/ls -lsad ".s:ShellEscape(b:netrw_curdir).")",'~'.expand("<slnum>"))

    elseif exists("b:netrw_curdir")
      echo system("/bin/ls ".lsopt." ".s:ShellEscape(s:ComposePath(b:netrw_curdir,a:fname)))
"      call Decho("#3: echo system(/bin/ls -lsad ".s:ShellEscape(b:netrw_curdir.a:fname).")",'~'.expand("<slnum>"))

    else
"     call Decho('using ls '.a:fname." using cwd<".getcwd().">",'~'.expand("<slnum>"))
     echo system("/bin/ls ".lsopt." ".s:ShellEscape(s:NetrwFile(a:fname)))
"     call Decho("#5: echo system(/bin/ls -lsad ".s:ShellEscape(a:fname).")",'~'.expand("<slnum>"))
    endif
   else
    " use vim functions to return information about file below cursor
"    call Decho("using vim functions to query for file info",'~'.expand("<slnum>"))
    if !isdirectory(s:NetrwFile(a:fname)) && !filereadable(s:NetrwFile(a:fname)) && a:fname =~ '[*@/]'
     let fname= substitute(a:fname,".$","","")
    else
     let fname= a:fname
    endif
    let t  = getftime(s:NetrwFile(fname))
    let sz = getfsize(s:NetrwFile(fname))
    if g:netrw_sizestyle =~# "[hH]"
     let sz= s:NetrwHumanReadable(sz)
    endif
    echo a:fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(s:NetrwFile(fname)))
"    call Decho("fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname)),'~'.expand("<slnum>"))
   endif
  else
   echo "sorry, \"qf\" not supported yet for remote files"
  endif
  let @@= ykeep
"  call Dret("s:NetrwFileInfo")
endfun

" ---------------------------------------------------------------------
" s:NetrwFullPath: returns the full path to a directory and/or file {{{2
fun! s:NetrwFullPath(filename)
"  " call Dfunc("s:NetrwFullPath(filename<".a:filename.">)")
  let filename= a:filename
  if filename !~ '^/'
   let filename= resolve(getcwd().'/'.filename)
  endif
  if filename != "/" && filename =~ '/$'
   let filename= substitute(filename,'/$','','')
  endif
"  " call Dret("s:NetrwFullPath <".filename.">")
  return filename
endfun

" ---------------------------------------------------------------------
" s:NetrwGetBuffer: {{{2
"   returns 0=cleared buffer
"           1=re-used buffer (buffer not cleared)
fun! s:NetrwGetBuffer(islocal,dirname)
"  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
  let dirname= a:dirname

  " re-use buffer if possible {{{3
"  call Decho("--re-use a buffer if possible--",'~'.expand("<slnum>"))
  if !exists("s:netrwbuf")
   let s:netrwbuf= {}
  endif
  if has_key(s:netrwbuf,s:NetrwFullPath(dirname))
   let bufnum= s:netrwbuf[s:NetrwFullPath(dirname)]
"   call Decho("lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnum)
   if !bufexists(bufnum)
    call remove(s:netrwbuf,s:NetrwFullPath(dirname))
    let bufnum= -1
   endif
  else
"   call Decho("lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."] not a key")
   let bufnum= -1
  endif

  " get enew buffer and name it -or- re-use buffer {{{3
  if bufnum < 0      " get enew buffer and name it
"   call Decho("--get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)",'~'.expand("<slnum>"))
   call s:NetrwEnew(dirname)
"   call Decho("  got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)",'~'.expand("<slnum>"))
   " name the buffer
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
    " Got enew buffer; transform into a NetrwTreeListing
"    call Decho("--transform enew buffer#".bufnr("%")." into a NetrwTreeListing --",'~'.expand("<slnum>"))
    if !exists("s:netrw_treelistnum")
     let s:netrw_treelistnum= 1
    else
     let s:netrw_treelistnum= s:netrw_treelistnum + 1
    endif
    let w:netrw_treebufnr= bufnr("%")
"    call Decho("  exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum),'~'.expand("<slnum>"))
    exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
    if g:netrw_use_noswf
     setl nobl bt=nofile noswf
    else
     setl nobl bt=nofile
    endif
    nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[[')<cr>
    nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']]')<cr>
    nnoremap <silent> <buffer> []       :sil call <SID>TreeListMove('[]')<cr>
    nnoremap <silent> <buffer> ][       :sil call <SID>TreeListMove('][')<cr>
"    call Decho("  tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr,'~'.expand("<slnum>"))
   else
"    let v:errmsg   = "" " Decho
    let escdirname = fnameescape(dirname)
"    call Decho("  errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">",'~'.expand("<slnum>"))
"    call Decho('  exe sil! keepalt file '.escdirname,'~'.expand("<slnum>"))
"    let v:errmsg= "" " Decho
    exe 'sil! keepj keepalt file '.escdirname
"    call Decho("  errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">",'~'.expand("<slnum>"))
    " enter the new buffer into the s:netrwbuf dictionary
    let s:netrwbuf[s:NetrwFullPath(dirname)]= bufnr("%")
"    call Decho("update netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnr("%"),'~'.expand("<slnum>"))
"    call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
   endif
"   call Decho("  named enew buffer#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))

  else " Re-use the buffer
"   call Decho("--re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)",'~'.expand("<slnum>"))
   let eikeep= &ei
   setl ei=all
   if getline(2) =~# '^" Netrw Directory Listing'
"    call Decho("  getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum,'~'.expand("<slnum>"))
    exe "sil! NetrwKeepj noswapfile keepalt b ".bufnum
   else
"    call Decho("  getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum,'~'.expand("<slnum>"))
    exe "sil! NetrwKeepj noswapfile keepalt b ".bufnum
   endif
"   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
   if bufname("%") == '.'
"    call Decho("exe sil! keepalt file ".fnameescape(getcwd()),'~'.expand("<slnum>"))
    exe "sil! NetrwKeepj keepalt file ".fnameescape(getcwd())
   endif
   let &ei= eikeep

   if line("$") <= 1 && getline(1) == ""
    " empty buffer
    NetrwKeepj call s:NetrwListSettings(a:islocal)
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
    return 0

   elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
"    call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse." a:islocal=".a:islocal.": clear buffer",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwListSettings(a:islocal)
    sil NetrwKeepj %d _
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
    return 0

   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"    call Decho("--re-use tree listing--",'~'.expand("<slnum>"))
"    call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
    sil NetrwKeepj %d _
    NetrwKeepj call s:NetrwListSettings(a:islocal)
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
    return 0

   else
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"    call Dret("s:NetrwGetBuffer 1<buffer not cleared>")
    return 1
   endif
  endif

  " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
  "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
  "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
  "  med    1         D      H
  "  fast   2         H      H
"  call Decho("--do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--",'~'.expand("<slnum>"))
  let fname= expand("%")
  NetrwKeepj call s:NetrwListSettings(a:islocal)
"  call Decho("exe sil! keepalt file ".fnameescape(fname),'~'.expand("<slnum>"))
  exe "sil! NetrwKeepj keepalt file ".fnameescape(fname)

  " delete all lines from buffer {{{3
"  call Decho("--delete all lines from buffer--",'~'.expand("<slnum>"))
"  call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
  sil! keepalt NetrwKeepj %d _

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"  call Dret("s:NetrwGetBuffer 0<cleared buffer>")
  return 0
endfun

" ---------------------------------------------------------------------
" s:NetrwGetcwd: get the current directory. {{{2
"   Change backslashes to forward slashes, if any.
"   If doesc is true, escape certain troublesome characters
fun! s:NetrwGetcwd(doesc)
"  call Dfunc("NetrwGetcwd(doesc=".a:doesc.")")
  let curdir= substitute(getcwd(),'\\','/','ge')
  if curdir !~ '[\/]$'
   let curdir= curdir.'/'
  endif
  if a:doesc
   let curdir= fnameescape(curdir)
  endif
"  call Dret("NetrwGetcwd <".curdir.">")
  return curdir
endfun

" ---------------------------------------------------------------------
"  s:NetrwGetWord: it gets the directory/file named under the cursor {{{2
fun! s:NetrwGetWord()
"  call Dfunc("s:NetrwGetWord() liststyle=".s:ShowStyle()." virtcol=".virtcol("."))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
  let keepsol= &l:sol
  setl nosol

  call s:UseBufWinVars()

  " insure that w:netrw_liststyle is set up
  if !exists("w:netrw_liststyle")
   if exists("g:netrw_liststyle")
    let w:netrw_liststyle= g:netrw_liststyle
   else
    let w:netrw_liststyle= s:THINLIST
   endif
"   call Decho("w:netrw_liststyle=".w:netrw_liststyle,'~'.expand("<slnum>"))
  endif

  if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
   " Active Banner support
"   call Decho("active banner handling",'~'.expand("<slnum>"))
   NetrwKeepj norm! 0
   let dirname= "./"
   let curline= getline('.')

   if curline =~# '"\s*Sorted by\s'
    NetrwKeepj norm s
    let s:netrw_skipbrowse= 1
    echo 'Pressing "s" also works'

   elseif curline =~# '"\s*Sort sequence:'
    let s:netrw_skipbrowse= 1
    echo 'Press "S" to edit sorting sequence'

   elseif curline =~# '"\s*Quick Help:'
    NetrwKeepj norm ?
    let s:netrw_skipbrowse= 1

   elseif curline =~# '"\s*\%(Hiding\|Showing\):'
    NetrwKeepj norm a
    let s:netrw_skipbrowse= 1
    echo 'Pressing "a" also works'

   elseif line("$") > w:netrw_bannercnt
    exe 'sil NetrwKeepj '.w:netrw_bannercnt
   endif

  elseif w:netrw_liststyle == s:THINLIST
"   call Decho("thin column handling",'~'.expand("<slnum>"))
   NetrwKeepj norm! 0
   let dirname= substitute(getline('.'),'\t -->.*$','','')

  elseif w:netrw_liststyle == s:LONGLIST
"   call Decho("long column handling",'~'.expand("<slnum>"))
   NetrwKeepj norm! 0
   let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')

  elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"   call Decho("treelist handling",'~'.expand("<slnum>"))
   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
   let dirname= substitute(dirname,'\t -->.*$','','')

  else
"   call Decho("obtain word from wide listing",'~'.expand("<slnum>"))
   let dirname= getline('.')

   if !exists("b:netrw_cpf")
    let b:netrw_cpf= 0
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
    call histdel("/",-1)
"   "call Decho("computed cpf=".b:netrw_cpf,'~'.expand("<slnum>"))
   endif

"   call Decho("buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
   let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
"   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
"   call Decho("1: dirname<".dirname.">",'~'.expand("<slnum>"))
   if filestart == 0
    NetrwKeepj norm! 0ma
   else
    call cursor(line("."),filestart+1)
    NetrwKeepj norm! ma
   endif
   let rega= @a
   let eofname= filestart + b:netrw_cpf + 1
   if eofname <= col("$")
    call cursor(line("."),filestart+b:netrw_cpf+1)
    NetrwKeepj norm! "ay`a
   else
    NetrwKeepj norm! "ay$
   endif
   let dirname = @a
   let @a      = rega
"   call Decho("2: dirname<".dirname.">",'~'.expand("<slnum>"))
   let dirname= substitute(dirname,'\s\+$','','e')
"   call Decho("3: dirname<".dirname.">",'~'.expand("<slnum>"))
  endif

  " symlinks are indicated by a trailing "@".  Remove it before further processing.
  let dirname= substitute(dirname,"@$","","")

  " executables are indicated by a trailing "*".  Remove it before further processing.
  let dirname= substitute(dirname,"\*$","","")

  let &l:sol= keepsol

"  call Dret("s:NetrwGetWord <".dirname.">")
  return dirname
endfun

" ---------------------------------------------------------------------
" s:NetrwListSettings: make standard settings for a netrw listing {{{2
fun! s:NetrwListSettings(islocal)
"  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
  let fname= bufname("%")
"  "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro nornu",'~'.expand("<slnum>"))
  setl bt=nofile nobl ma nonu nowrap noro nornu
"  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname),'~'.expand("<slnum>"))
  exe "sil! keepalt file ".fnameescape(fname)
  if g:netrw_use_noswf
   setl noswf
  endif
"  call Dredir("ls!")
"  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
  exe "setl ts=".(g:netrw_maxfilenamelen+1)
  setl isk+=.,~,-
  if g:netrw_fastbrowse > a:islocal
   setl bh=hide
  else
   setl bh=delete
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dret("s:NetrwListSettings")
endfun

" ---------------------------------------------------------------------
"  s:NetrwListStyle: {{{2
"  islocal=0: remote browsing
"         =1: local browsing
fun! s:NetrwListStyle(islocal)
"  call Dfunc("NetrwListStyle(islocal=".a:islocal.") w:netrw_liststyle=".w:netrw_liststyle)

  let ykeep             = @@
  let fname             = s:NetrwGetWord()
  if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
  let svpos            = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let w:netrw_liststyle = (w:netrw_liststyle + 1) % s:MAXLIST
"  call Decho("fname<".fname.">",'~'.expand("<slnum>"))
"  call Decho("chgd w:netrw_liststyle to ".w:netrw_liststyle,'~'.expand("<slnum>"))
"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">",'~'.expand("<slnum>"))

  if w:netrw_liststyle == s:THINLIST
   " use one column listing
"   call Decho("use one column list",'~'.expand("<slnum>"))
   let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')

  elseif w:netrw_liststyle == s:LONGLIST
   " use long list
"   call Decho("use long list",'~'.expand("<slnum>"))
   let g:netrw_list_cmd = g:netrw_list_cmd." -l"

  elseif w:netrw_liststyle == s:WIDELIST
   " give wide list
"   call Decho("use wide list",'~'.expand("<slnum>"))
   let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')

  elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"   call Decho("use tree list",'~'.expand("<slnum>"))
   let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')

  else
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"bad value for g:netrw_liststyle (=".w:netrw_liststyle.")",46)
   let g:netrw_liststyle = s:THINLIST
   let w:netrw_liststyle = g:netrw_liststyle
   let g:netrw_list_cmd  = substitute(g:netrw_list_cmd,' -l','','ge')
  endif
  setl ma noro
"  call Decho("setl ma noro",'~'.expand("<slnum>"))

  " clear buffer - this will cause NetrwBrowse/LocalBrowseCheck to do a refresh
"  call Decho("clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
  sil! NetrwKeepj %d _
  " following prevents tree listing buffer from being marked "modified"
"  call Decho("setl nomod",'~'.expand("<slnum>"))
  setl nomod
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))

  " refresh the listing
"  call Decho("refresh the listing",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  NetrwKeepj call s:NetrwCursor()

  " restore position; keep cursor on the filename
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetrwListStyle".(exists("w:netrw_liststyle")? ' : w:netrw_liststyle='.w:netrw_liststyle : ""))
endfun

" ---------------------------------------------------------------------
" s:NetrwBannerCtrl: toggles the display of the banner {{{2
fun! s:NetrwBannerCtrl(islocal)
"  call Dfunc("s:NetrwBannerCtrl(islocal=".a:islocal.") g:netrw_banner=".g:netrw_banner)

  let ykeep= @@
  " toggle the banner (enable/suppress)
  let g:netrw_banner= !g:netrw_banner

  " refresh the listing
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))

  " keep cursor on the filename
  let fname= s:NetrwGetWord()
  sil NetrwKeepj $
  let result= search('\%(^\%(|\+\s\)\=\|\s\{2,}\)\zs'.escape(fname,'.\[]*$^').'\%(\s\{2,}\|$\)','bc')
"  call Decho("search result=".result." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'N/A'),'~'.expand("<slnum>"))
  if result <= 0 && exists("w:netrw_bannercnt")
   exe "NetrwKeepj ".w:netrw_bannercnt
  endif
  let @@= ykeep
"  call Dret("s:NetrwBannerCtrl : g:netrw_banner=".g:netrw_banner)
endfun

" ---------------------------------------------------------------------
" s:NetrwBookmark: supports :NetrwMB[!] [file]s                 {{{2
"
"  No bang: enters files/directories into Netrw's bookmark system
"   No argument and in netrw buffer:
"     if there are marked files: bookmark marked files
"     otherwise                : bookmark file/directory under cursor
"   No argument and not in netrw buffer: bookmarks current open file
"   Has arguments: globs them individually and bookmarks them
"
"  With bang: deletes files/directories from Netrw's bookmark system
fun! s:NetrwBookmark(del,...)
"  call Dfunc("s:NetrwBookmark(del=".a:del.",...) a:0=".a:0)
  if a:0 == 0
   if &ft == "netrw"
    let curbufnr = bufnr("%")

    if exists("s:netrwmarkfilelist_{curbufnr}")
     " for every filename in the marked list
"     call Decho("bookmark every filename in marked list",'~'.expand("<slnum>"))
     let svpos  = winsaveview()
"     call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
     let islocal= expand("%") !~ '^\a\{3,}://'
     for fname in s:netrwmarkfilelist_{curbufnr}
      if a:del|call s:DeleteBookmark(fname)|else|call s:MakeBookmark(fname)|endif
     endfor
     let curdir  = exists("b:netrw_curdir")? b:netrw_curdir : getcwd()
     call s:NetrwUnmarkList(curbufnr,curdir)
     NetrwKeepj call s:NetrwRefresh(islocal,s:NetrwBrowseChgDir(islocal,'./'))
"     call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
     NetrwKeepj call winrestview(svpos)
    else
     let fname= s:NetrwGetWord()
     if a:del|call s:DeleteBookmark(fname)|else|call s:MakeBookmark(fname)|endif
    endif

   else
    " bookmark currently open file
"    call Decho("bookmark currently open file",'~'.expand("<slnum>"))
    let fname= expand("%")
    if a:del|call s:DeleteBookmark(fname)|else|call s:MakeBookmark(fname)|endif
   endif

  else
   " bookmark specified files
   "  attempts to infer if working remote or local
   "  by deciding if the current file begins with an url
   "  Globbing cannot be done remotely.
   let islocal= expand("%") !~ '^\a\{3,}://'
"   call Decho("bookmark specified file".((a:0>1)? "s" : ""),'~'.expand("<slnum>"))
   let i = 1
   while i <= a:0
    if islocal
     if v:version > 704 || (v:version == 704 && has("patch656"))
      let mbfiles= glob(fnameescape(a:{i}),0,1,1)
     else
      let mbfiles= glob(fnameescape(a:{i}),0,1)
     endif
    else
     let mbfiles= [a:{i}]
    endif
"    call Decho("mbfiles".string(mbfiles),'~'.expand("<slnum>"))
    for mbfile in mbfiles
"     call Decho("mbfile<".mbfile.">",'~'.expand("<slnum>"))
     if a:del|call s:DeleteBookmark(mbfile)|else|call s:MakeBookmark(mbfile)|endif
    endfor
    let i= i + 1
   endwhile
  endif

  " update the menu
  call s:NetrwBookmarkMenu()

"  call Dret("s:NetrwBookmark")
endfun

" ---------------------------------------------------------------------
" s:NetrwBookmarkMenu: Uses menu priorities {{{2
"                      .2.[cnt] for bookmarks, and
"                      .3.[cnt] for history
"                      (see s:NetrwMenu())
fun! s:NetrwBookmarkMenu()
  if !exists("s:netrw_menucnt")
   return
  endif
"  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhist_cnt." menucnt=".s:netrw_menucnt)

  " the following test assures that gvim is running, has menus available, and has menus enabled.
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   if exists("g:NetrwTopLvlMenu")
"    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
   endif
   if !exists("s:netrw_initbookhist")
    call s:NetrwBookHistRead()
   endif

   " show bookmarked places
   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
    let cnt= 1
    for bmd in g:netrw_bookmarklist
"     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.bmd.'	:e '.bmd,'~'.expand("<slnum>"))
     let bmd= escape(bmd,g:netrw_menu_escape)

     " show bookmarks for goto menu
     exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.bmd.'	:e '.bmd."\<cr>"

     " show bookmarks for deletion menu
     exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.bmd.'	'.cnt."mB"
     let cnt= cnt + 1
    endfor

   endif

   " show directory browsing history
   if g:netrw_dirhistmax > 0
    let cnt     = g:netrw_dirhist_cnt
    let first   = 1
    let histcnt = 0
    while ( first || cnt != g:netrw_dirhist_cnt )
     let histcnt  = histcnt + 1
     let priority = g:netrw_dirhist_cnt + histcnt
     if exists("g:netrw_dirhist_{cnt}")
      let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
"     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir,'~'.expand("<slnum>"))
      exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
     endif
     let first = 0
     let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
     if cnt < 0
      let cnt= cnt + g:netrw_dirhistmax
     endif
    endwhile
   endif

  endif
"  call Dret("NetrwBookmarkMenu")
endfun

" ---------------------------------------------------------------------
"  s:NetrwBrowseChgDir: constructs a new directory based on the current {{{2
"                       directory and a new directory name.  Also, if the
"                       "new directory name" is actually a file,
"                       NetrwBrowseChgDir() edits the file.
fun! s:NetrwBrowseChgDir(islocal,newdir,...)
"  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))

  let ykeep= @@
  if !exists("b:netrw_curdir")
   " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
   " and the current window is the NetrwMessage window.
   let @@= ykeep
"   call Decho("b:netrw_curdir doesn't exist!",'~'.expand("<slnum>"))
"   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
"   call Dredir("ls!")
"   call Dret("s:NetrwBrowseChgDir")
   return
  endif
"  call Decho("b:netrw_curdir<".b:netrw_curdir.">")

  " NetrwBrowseChgDir: save options and initialize {{{3
"  call Decho("saving options",'~'.expand("<slnum>"))
  call s:SavePosn(s:netrw_nbcd)
  NetrwKeepj call s:NetrwOptionSave("s:")
  NetrwKeepj call s:NetrwSafeOptions()
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   let dirname = substitute(b:netrw_curdir,'\\','/','ge')
  else
   let dirname = b:netrw_curdir
  endif
  let newdir    = a:newdir
  let dolockout = 0
  let dorestore = 1
"  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))

  " ignore <cr>s when done in the banner
"  call Decho('ignore [return]s when done in banner (g:netrw_banner='.g:netrw_banner.")",'~'.expand("<slnum>"))
  if g:netrw_banner
"   call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." line(.)#".line('.')." line($)#".line("#"),'~'.expand("<slnum>"))
   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt && line("$") >= w:netrw_bannercnt
    if getline(".") =~# 'Quick Help'
"     call Decho("#1: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
     let g:netrw_quickhelp= (g:netrw_quickhelp + 1)%len(s:QuickHelp)
"     call Decho("#2: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
     setl ma noro nowrap
     NetrwKeepj call setline(line('.'),'"   Quick Help: <F1>:help  '.s:QuickHelp[g:netrw_quickhelp])
     setl noma nomod nowrap
     call s:RestorePosn(s:netrw_nbcd)
     NetrwKeepj call s:NetrwOptionRestore("s:")
"     call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    endif
   endif
"  else " Decho
"   call Decho("(s:NetrwBrowseChgdir) g:netrw_banner=".g:netrw_banner." (no banner)",'~'.expand("<slnum>"))
  endif

  " set up o/s-dependent directory recognition pattern
  if has("amiga")
   let dirpat= '[\/:]$'
  else
   let dirpat= '[\/]$'
  endif
"  call Decho("set up o/s-dependent directory recognition pattern: dirname<".dirname.">  dirpat<".dirpat.">",'~'.expand("<slnum>"))

  if dirname !~ dirpat
   " apparently vim is "recognizing" that it is in a directory and
   " is removing the trailing "/".  Bad idea, so let's put it back.
   let dirname= dirname.'/'
"   call Decho("adjusting dirname<".dirname.'>  (put trailing "/" back)','~'.expand("<slnum>"))
  endif

"  call Decho("[newdir<".newdir."> ".((newdir =~ dirpat)? "=~" : "!~")." dirpat<".dirpat.">] && [islocal=".a:islocal."] && [newdir is ".(isdirectory(s:NetrwFile(newdir))? "" : "not ")."a directory]",'~'.expand("<slnum>"))
  if newdir !~ dirpat && !(a:islocal && isdirectory(s:NetrwFile(s:ComposePath(dirname,newdir))))
   " ------------------------------
   " NetrwBrowseChgDir: edit a file {{{3
   " ------------------------------
"   call Decho('edit-a-file: case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">",'~'.expand("<slnum>"))

   " save position for benefit of Rexplore
   let s:rexposn_{bufnr("%")}= winsaveview()
"   call Decho("edit-a-file: saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
"   call Decho("edit-a-file: win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
"   call Decho("edit-a-file: w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a')." w:netrw_treedict:".(exists("w:netrw_treedict")? "exists" : 'n/a')." newdir<".newdir.">",'~'.expand("<slnum>"))

   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
"    call Decho("edit-a-file: handle tree listing: w:netrw_treedict<".(exists("w:netrw_treedict")? string(w:netrw_treedict) : 'n/a').">",'~'.expand("<slnum>"))
"    call Decho("edit-a-file: newdir<".newdir.">",'~'.expand("<slnum>"))
    let dirname= s:NetrwTreeDir(a:islocal)
    if dirname =~ '/$'
     let dirname= dirname.newdir
    else
     let dirname= dirname."/".newdir
    endif
"    call Decho("edit-a-file: dirname<".dirname.">",'~'.expand("<slnum>"))
"    call Decho("edit-a-file: tree listing",'~'.expand("<slnum>"))
   elseif newdir =~ '^\(/\|\a:\)'
"    call Decho("edit-a-file: handle an url or path starting with /: <".newdir.">",'~'.expand("<slnum>"))
    let dirname= newdir
   else
    let dirname= s:ComposePath(dirname,newdir)
   endif
"   call Decho("edit-a-file: handling a file: dirname<".dirname."> (a:0=".a:0.")",'~'.expand("<slnum>"))
   " this lets netrw#BrowseX avoid the edit
   if a:0 < 1
"    call Decho("edit-a-file: (a:0=".a:0."<1) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"),'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwOptionRestore("s:")
    let curdir= b:netrw_curdir
    if !exists("s:didsplit")
"     call Decho("edit-a-file: s:didsplit does not exist; g:netrw_browse_split=".string(g:netrw_browse_split)." win#".winnr(),'~'.expand("<slnum>"))
     if type(g:netrw_browse_split) == 3
      " open file in server
      " Note that g:netrw_browse_split is a List: [servername,tabnr,winnr]
"      call Decho("edit-a-file: open file in server",'~'.expand("<slnum>"))
      call s:NetrwServerEdit(a:islocal,dirname)
"      call Dret("s:NetrwBrowseChgDir")
      return
     elseif g:netrw_browse_split == 1
      " horizontally splitting the window first
"      call Decho("edit-a-file: horizontally splitting window prior to edit",'~'.expand("<slnum>"))
      keepalt new
      if !&ea
       keepalt wincmd _
      endif
      call s:SetRexDir(a:islocal,curdir)
     elseif g:netrw_browse_split == 2
      " vertically splitting the window first
"      call Decho("edit-a-file: vertically splitting window prior to edit",'~'.expand("<slnum>"))
      keepalt rightb vert new
      if !&ea
       keepalt wincmd |
      endif
      call s:SetRexDir(a:islocal,curdir)
     elseif g:netrw_browse_split == 3
      " open file in new tab
"      call Decho("edit-a-file: opening new tab prior to edit",'~'.expand("<slnum>"))
      keepalt tabnew
      if !exists("b:netrw_curdir")
       let b:netrw_curdir= getcwd()
      endif
      call s:SetRexDir(a:islocal,curdir)
     elseif g:netrw_browse_split == 4
      " act like "P" (ie. open previous window)
"      call Decho("edit-a-file: use previous window for edit",'~'.expand("<slnum>"))
      if s:NetrwPrevWinOpen(2) == 3
       let @@= ykeep
"       call Dret("s:NetrwBrowseChgDir")
       return
      endif
      call s:SetRexDir(a:islocal,curdir)
     else
      " handling a file, didn't split, so remove menu
"      call Decho("edit-a-file: handling a file+didn't split, so remove menu",'~'.expand("<slnum>"))
      call s:NetrwMenu(0)
      " optional change to window
      if g:netrw_chgwin >= 1
"       call Decho("edit-a-file: changing window to #".g:netrw_chgwin,'~'.expand("<slnum>"))
       if winnr("$")+1 == g:netrw_chgwin
	" if g:netrw_chgwin is set to one more than the last window, then
	" vertically split the last window to make that window available.
	let curwin= winnr()
	exe "NetrwKeepj keepalt ".winnr("$")."wincmd w"
	vs
	exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd ".curwin
       endif
       exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd w"
      endif
      call s:SetRexDir(a:islocal,curdir)
     endif
    endif

    " the point where netrw actually edits the (local) file
    " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
    " no keepalt to support  :e #  to return to a directory listing
    if a:islocal
"     call Decho("edit-a-file: edit local file: exe e! ".fnameescape(dirname),'~'.expand("<slnum>"))
     " some like c-^ to return to the last edited file
     " others like c-^ to return to the netrw buffer
     if exists("g:netrw_altfile") && g:netrw_altfile
      exe "NetrwKeepj keepalt e! ".fnameescape(dirname)
     else
      exe "NetrwKeepj e! ".fnameescape(dirname)
     endif
"     call Decho("edit-a-file: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod,'~'.expand("<slnum>"))
     call s:NetrwCursor()
     if &hidden || &bufhidden == "hide"
      " file came from vim's hidden storage.  Don't "restore" options with it.
      let dorestore= 0
     endif
    else
"     call Decho("edit-a-file: remote file: NetrwBrowse will edit it",'~'.expand("<slnum>"))
    endif
    let dolockout= 1

    " handle g:Netrw_funcref -- call external-to-netrw functions
    "   This code will handle g:Netrw_funcref as an individual function reference
    "   or as a list of function references.  It will ignore anything that's not
    "   a function reference.  See  :help Funcref  for information about function references.
    if exists("g:Netrw_funcref")
"     call Decho("edit-a-file: handle optional Funcrefs",'~'.expand("<slnum>"))
     if type(g:Netrw_funcref) == 2
"      call Decho("edit-a-file: handling a g:Netrw_funcref",'~'.expand("<slnum>"))
      NetrwKeepj call g:Netrw_funcref()
     elseif type(g:Netrw_funcref) == 3
"      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs",'~'.expand("<slnum>"))
      for Fncref in g:Netrw_funcref
       if type(FncRef) == 2
        NetrwKeepj call FncRef()
       endif
      endfor
     endif
    endif
   endif

  elseif newdir =~ '^/'
   " ----------------------------------------------------
   " NetrwBrowseChgDir: just go to the new directory spec {{{3
   " ----------------------------------------------------
"   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>','~'.expand("<slnum>"))
   let dirname = newdir
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   NetrwKeepj call s:NetrwOptionRestore("s:")
   norm! m`

  elseif newdir == './'
   " ---------------------------------------------
   " NetrwBrowseChgDir: refresh the directory list {{{3
   " ---------------------------------------------
"   call Decho('refresh-dirlist: case "refresh directory listing": newdir == "./"','~'.expand("<slnum>"))
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   norm! m`

  elseif newdir == '../'
   " --------------------------------------
   " NetrwBrowseChgDir: go up one directory {{{3
   " --------------------------------------
"   call Decho('go-up: case "go up one directory": newdir == "../"','~'.expand("<slnum>"))

   if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
    " force a refresh
"    call Decho("go-up: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
"    call Decho("go-up: setl noro ma",'~'.expand("<slnum>"))
    setl noro ma
    NetrwKeepj %d _
   endif

   if has("amiga")
    " amiga
"    call Decho('go-up: case "go up one directory": newdir == "../" and amiga','~'.expand("<slnum>"))
    if a:islocal
     let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
     let dirname= substitute(dirname,'/$','','')
    else
     let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
    endif
"    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))

   elseif !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    " windows
    if a:islocal
     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
     if dirname == ""
      let dirname= '/'
     endif
    else
     let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
    endif
    if dirname =~ '^\a:$'
     let dirname= dirname.'/'
    endif
"    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))

   else
    " unix or cygwin
"    call Decho('go-up: case "go up one directory": newdir == "../" and unix or cygwin','~'.expand("<slnum>"))
    if a:islocal
     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
     if dirname == ""
      let dirname= '/'
     endif
    else
     let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
    endif
"    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
   endif
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   norm m`

  elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " --------------------------------------
   " NetrwBrowseChgDir: Handle Tree Listing {{{3
   " --------------------------------------
"   call Decho('tree-list: case liststyle is TREELIST and w:netrw_treedict exists','~'.expand("<slnum>"))
   " force a refresh (for TREELIST, NetrwTreeDir() will force the refresh)
"   call Decho("tree-list: setl noro ma",'~'.expand("<slnum>"))
   setl noro ma
   if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
"    call Decho("tree-list: clear buffer<".expand("%")."> with :%d  (force refresh)",'~'.expand("<slnum>"))
    NetrwKeepj %d _
   endif
   let treedir      = s:NetrwTreeDir(a:islocal)
"   call Decho("tree-list: treedir<".treedir.">",'~'.expand("<slnum>"))
   let s:treecurpos = winsaveview()
   let haskey       = 0
"   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))

   " search treedict for tree dir as-is
"   call Decho("tree-list: search treedict for tree dir as-is",'~'.expand("<slnum>"))
   if has_key(w:netrw_treedict,treedir)
"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : found it!','~'.expand("<slnum>"))
    let haskey= 1
   else
"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
   endif

   " search treedict for treedir with a [/@] appended
"   call Decho("tree-list: search treedict for treedir with a [/@] appended",'~'.expand("<slnum>"))
   if !haskey && treedir !~ '[/@]$'
    if has_key(w:netrw_treedict,treedir."/")
     let treedir= treedir."/"
"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
     let haskey = 1
    else
"     call Decho('tree-list: ....searched for treedir<'.treedir.'/> : not found','~'.expand("<slnum>"))
    endif
   endif

   " search treedict for treedir with any trailing / elided
"   call Decho("tree-list: search treedict for treedir with any trailing / elided",'~'.expand("<slnum>"))
   if !haskey && treedir =~ '/$'
    let treedir= substitute(treedir,'/$','','')
    if has_key(w:netrw_treedict,treedir)
"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
     let haskey = 1
    else
"     call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
    endif
   endif

"   call Decho("haskey=".haskey,'~'.expand("<slnum>"))
   if haskey
    " close tree listing for selected subdirectory
"    call Decho("tree-list: closing selected subdirectory<".dirname.">",'~'.expand("<slnum>"))
    call remove(w:netrw_treedict,treedir)
"    call Decho("tree-list: removed     entry<".treedir."> from treedict",'~'.expand("<slnum>"))
"    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
    let dirname= w:netrw_treetop
   else
    " go down one directory
    let dirname= substitute(treedir,'/*$','/','')
"    call Decho("tree-list: go down one dir: treedir<".treedir.">",'~'.expand("<slnum>"))
"    call Decho("tree-list: ...            : dirname<".dirname.">",'~'.expand("<slnum>"))
   endif
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
"   call Decho("setting s:treeforceredraw to true",'~'.expand("<slnum>"))
   let s:treeforceredraw = 1

  else
   " ----------------------------------------
   " NetrwBrowseChgDir: Go down one directory {{{3
   " ----------------------------------------
   let dirname    = s:ComposePath(dirname,newdir)
"   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:SetRexDir(a:islocal,dirname)
   norm m`
  endif

 " --------------------------------------
 " NetrwBrowseChgDir: Restore and Cleanup {{{3
 " --------------------------------------
  if dorestore
   " dorestore is zero'd when a local file was hidden or bufhidden;
   " in such a case, we want to keep whatever settings it may have.
"   call Decho("doing option restore (dorestore=".dorestore.")",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwOptionRestore("s:")
"  else " Decho
"   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod,'~'.expand("<slnum>"))
  endif
  call s:RestorePosn(s:netrw_nbcd)
  if dolockout && dorestore
"   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname),'~'.expand("<slnum>"))
   if filewritable(dirname)
"    call Decho("restore: doing modification lockout settings: ma nomod noro",'~'.expand("<slnum>"))
"    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
    setl ma noro nomod
"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   else
"    call Decho("restore: doing modification lockout settings: ma nomod ro",'~'.expand("<slnum>"))
"    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
    setl ma ro nomod
"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   endif
  endif
  let @@= ykeep

"  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
  return dirname
endfun

" ---------------------------------------------------------------------
" s:NetrwBrowseUpDir: implements the "-" mappings {{{2
"    for thin, long, and wide: cursor placed just after banner
"    for tree, keeps cursor on current filename
fun! s:NetrwBrowseUpDir(islocal)
"  call Dfunc("s:NetrwBrowseUpDir(islocal=".a:islocal.")")
  if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt-1
   " this test needed because occasionally this function seems to be incorrectly called
   " when multiple leftmouse clicks are taken when atop the one line help in the banner.
   " I'm allowing the very bottom line to permit a "-" exit so that one may escape empty
   " directories.
"   call Dret("s:NetrwBrowseUpDir : cursor not in file area")
   return
  endif

  if !exists("w:netrw_liststyle") || w:netrw_liststyle != s:TREELIST
   call s:SavePosn(s:netrw_nbcd)
  endif

  norm! 0
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
"   call Decho("case: treestyle",'~'.expand("<slnum>"))
   let curline= getline(".")
   let swwline= winline() - 1
   if exists("w:netrw_treetop")
    let b:netrw_curdir= w:netrw_treetop
   endif
   let curdir= b:netrw_curdir
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
   else
    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
   endif
   if !search('\c^'.s:treedepthstring.curline,'cw')
    if !search('\c^'.curline,'cw')
     sil! NetrwKeepj 1
    endif
   endif
   exe "sil! NetrwKeepj norm! z\<cr>"
   while winline() < swwline
    let curwinline= winline()
    exe "sil! NetrwKeepj norm! \<c-y>"
    if curwinline == winline()
     break
    endif
   endwhile
  else
"   call Decho("case: not treestyle",'~'.expand("<slnum>"))
   if exists("b:netrw_curdir")
    let curdir= b:netrw_curdir
   else
    let curdir= expand(getcwd())
   endif
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
   else
    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
   endif
   if has_key(s:netrw_nbcd,bufnr("%"))
    call s:RestorePosn(s:netrw_nbcd)
   elseif exists("w:netrw_bannercnt")
"    call Decho("moving to line#".w:netrw_bannercnt,'~'.expand("<slnum>"))
    exe w:netrw_bannercnt
   else
    1
   endif
  endif
  let curdir= substitute(curdir,'^.*[\/]','','')
  call search('\<'.curdir.'\>','wc')
"  call Dret("s:NetrwBrowseUpDir")
endfun

" ---------------------------------------------------------------------
" netrw#BrowseX:  (implements "x") executes a special "viewer" script or program for the {{{2
"              given filename; typically this means given their extension.
"              0=local, 1=remote
fun! netrw#BrowseX(fname,remote)
"  call Dfunc("netrw#BrowseX(fname<".a:fname."> remote=".a:remote.")")

  " if its really just a directory, then do a "gf" instead
  if (a:remote == 0 && isdirectory(a:fname)) || (a:remote == 1 && fname =~ '/$' && fname !~ '^https\=:')
   norm! gf
"   call Dret("netrw#BrowseX : did gf instead")
  endif


  let ykeep      = @@
  let screenposn = winsaveview()
"  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))

  " need to save and restore aw setting as gx can invoke this function from non-netrw buffers
  let awkeep     = &aw
  set noaw

  " special core dump handler
  if a:fname =~ '/core\(\.\d\+\)\=$'
   if exists("g:Netrw_corehandler")
    if type(g:Netrw_corehandler) == 2
     " g:Netrw_corehandler is a function reference (see :help Funcref)
"     call Decho("g:Netrw_corehandler is a funcref",'~'.expand("<slnum>"))
     call g:Netrw_corehandler(s:NetrwFile(a:fname))
    elseif type(g:Netrw_corehandler) == 3
     " g:Netrw_corehandler is a List of function references (see :help Funcref)
"     call Decho("g:Netrw_corehandler is a List",'~'.expand("<slnum>"))
     for Fncref in g:Netrw_corehandler
      if type(FncRef) == 2
       call FncRef(a:fname)
      endif
     endfor
    endif
"    call Decho("restoring posn to screenposn<".string(screenposn).">,'~'.expand("<slnum>"))"
    call winrestview(screenposn)
    let @@= ykeep
    let &aw= awkeep
"    call Dret("netrw#BrowseX : coredump handler invoked")
    return
   endif
  endif

  " set up the filename
  " (lower case the extension, make a local copy of a remote file)
  let exten= substitute(a:fname,'.*\.\(.\{-}\)','\1','e')
  if has("win32") || has("win95") || has("win64") || has("win16")
   let exten= substitute(exten,'^.*$','\L&\E','')
  endif
"  call Decho("exten<".exten.">",'~'.expand("<slnum>"))

  if a:remote == 1
   " create a local copy
"   call Decho("remote: a:remote=".a:remote.": create a local copy of <".a:fname.">",'~'.expand("<slnum>"))
   setl bh=delete
   call netrw#NetRead(3,a:fname)
   " attempt to rename tempfile
   let basename= substitute(a:fname,'^\(.*\)/\(.*\)\.\([^.]*\)$','\2','')
   let newname = substitute(s:netrw_tmpfile,'^\(.*\)/\(.*\)\.\([^.]*\)$','\1/'.basename.'.\3','')
"   call Decho("basename<".basename.">",'~'.expand("<slnum>"))
"   call Decho("newname <".newname.">",'~'.expand("<slnum>"))
   if rename(s:netrw_tmpfile,newname) == 0
    " renaming succeeded
    let fname= newname
   else
    " renaming failed
    let fname= s:netrw_tmpfile
   endif
  else
"   call Decho("local: a:remote=".a:remote.": handling local copy of <".a:fname.">",'~'.expand("<slnum>"))
   let fname= a:fname
   " special ~ handler for local
   if fname =~ '^\~' && expand("$HOME") != ""
"    call Decho('invoking special ~ handler','~'.expand("<slnum>"))
    let fname= s:NetrwFile(substitute(fname,'^\~',expand("$HOME"),''))
   endif
  endif
"  call Decho("fname<".fname.">",'~'.expand("<slnum>"))
"  call Decho("exten<".exten."> "."netrwFileHandlers#NFH_".exten."():exists=".exists("*netrwFileHandlers#NFH_".exten),'~'.expand("<slnum>"))

  " set up redirection (avoids browser messages)
  " by default, g:netrw_suppress_gx_mesg is true
  if g:netrw_suppress_gx_mesg
   if &srr =~ "%s"
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     let redir= substitute(&srr,"%s","nul","")
    else
     let redir= substitute(&srr,"%s","/dev/null","")
    endif
   elseif (has("win32") || has("win95") || has("win64") || has("win16"))
    let redir= &srr . "nul"
   else
    let redir= &srr . "/dev/null"
   endif
  endif
"  call Decho("set up redirection: redir{".redir."} srr{".&srr."}",'~'.expand("<slnum>"))

  " extract any viewing options.  Assumes that they're set apart by quotes.
"  call Decho("extract any viewing options",'~'.expand("<slnum>"))
  if exists("g:netrw_browsex_viewer")
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
   if g:netrw_browsex_viewer =~ '\s'
    let viewer  = substitute(g:netrw_browsex_viewer,'\s.*$','','')
    let viewopt = substitute(g:netrw_browsex_viewer,'^\S\+\s*','','')." "
    let oviewer = ''
    let cnt     = 1
    while !executable(viewer) && viewer != oviewer
     let viewer  = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\1','')
     let viewopt = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\3','')." "
     let cnt     = cnt + 1
     let oviewer = viewer
"     call Decho("!exe: viewer<".viewer.">  viewopt<".viewopt.">",'~'.expand("<slnum>"))
    endwhile
   else
    let viewer  = g:netrw_browsex_viewer
    let viewopt = ""
   endif
"   call Decho("viewer<".viewer.">  viewopt<".viewopt.">",'~'.expand("<slnum>"))
  endif

  " execute the file handler
"  call Decho("execute the file handler (if any)",'~'.expand("<slnum>"))
  if exists("g:netrw_browsex_viewer") && g:netrw_browsex_viewer == '-'
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
   let ret= netrwFileHandlers#Invoke(exten,fname)

  elseif exists("g:netrw_browsex_viewer") && executable(viewer)
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !".viewer." ".viewopt.s:ShellEscape(fname,1).redir)
   let ret= v:shell_error

  elseif has("win32") || has("win64")
"   call Decho("windows",'~'.expand("<slnum>"))
   if executable("start")
    call s:NetrwExe('sil! !start rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(fname,1))
   elseif executable("rundll32")
    call s:NetrwExe('sil! !rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(fname,1))
   else
    call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
   endif
   call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   let ret= v:shell_error

  elseif has("win32unix")
   let winfname= 'c:\cygwin'.substitute(fname,'/','\\','g')
"   call Decho("cygwin: winfname<".s:ShellEscape(winfname,1).">",'~'.expand("<slnum>"))
   if executable("start")
    call s:NetrwExe('sil !start rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(winfname,1))
   elseif executable("rundll32")
    call s:NetrwExe('sil !rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(winfname,1))
   elseif executable("cygstart")
    call s:NetrwExe('sil !cygstart '.s:ShellEscape(fname,1))
   else
    call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
   endif
   call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   let ret= v:shell_error

  elseif has("unix") && executable("kfmclient") && s:CheckIfKde()
"   call Decho("unix and kfmclient",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !kfmclient exec ".s:ShellEscape(fname,1)." ".redir)
   let ret= v:shell_error

  elseif has("unix") && executable("exo-open") && executable("xdg-open") && executable("setsid")
"   call Decho("unix, exo-open, xdg-open",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !setsid xdg-open ".s:ShellEscape(fname,1).redir)
   let ret= v:shell_error

  elseif has("unix") && executable("xdg-open")
"   call Decho("unix and xdg-open",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !xdg-open ".s:ShellEscape(fname,1).redir)
   let ret= v:shell_error

  elseif has("macunix") && executable("open")
"   call Decho("macunix and open",'~'.expand("<slnum>"))
   call s:NetrwExe("sil !open ".s:ShellEscape(fname,1)." ".redir)
   let ret= v:shell_error

  else
   " netrwFileHandlers#Invoke() always returns 0
   let ret= netrwFileHandlers#Invoke(exten,fname)
  endif

  " if unsuccessful, attempt netrwFileHandlers#Invoke()
  if ret
   let ret= netrwFileHandlers#Invoke(exten,fname)
  endif

  " restoring redraw! after external file handlers
  redraw!

  " cleanup: remove temporary file,
  "          delete current buffer if success with handler,
  "          return to prior buffer (directory listing)
  "          Feb 12, 2008: had to de-activiate removal of
  "          temporary file because it wasn't getting seen.
"  if a:remote == 1 && fname != a:fname
""   call Decho("deleting temporary file<".fname.">",'~'.expand("<slnum>"))
"   call s:NetrwDelete(fname)
"  endif

  if a:remote == 1
   setl bh=delete bt=nofile
   if g:netrw_use_noswf
    setl noswf
   endif
   exe "sil! NetrwKeepj norm! \<c-o>"
"   redraw!
  endif
"  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
  call winrestview(screenposn)
  let @@ = ykeep
  let &aw= awkeep

"  call Dret("netrw#BrowseX")
endfun

" ---------------------------------------------------------------------
" netrw#BrowseXVis: used by gx in visual mode to select a file for browsing {{{2
fun! netrw#BrowseXVis()
"  call Dfunc("netrw#BrowseXVis()")
  let atkeep = @@
  norm! gvy
"  call Decho("@@<".@@.">",'~'.expand("<slnum>"))
  call netrw#BrowseX(@@,netrw#CheckIfRemote())
  let @@     = atkeep
"  call Dret("netrw#BrowseXVis")
endfun

" ---------------------------------------------------------------------
" netrw#CheckIfRemote: returns 1 if current file looks like an url, 0 else {{{2
fun! netrw#CheckIfRemote()
"  call Dfunc("netrw#CheckIfRemote()")
  if expand("%") =~ '^\a\{3,}://'
"   call Dret("netrw#CheckIfRemote 1")
   return 1
  else
"   call Dret("netrw#CheckIfRemote 0")
   return 0
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwChgPerm: (implements "gp") change file permission {{{2
fun! s:NetrwChgPerm(islocal,curdir)
"  call Dfunc("s:NetrwChgPerm(islocal=".a:islocal." curdir<".a:curdir.">)")
  let ykeep  = @@
  call inputsave()
  let newperm= input("Enter new permission: ")
  call inputrestore()
  let chgperm= substitute(g:netrw_chgperm,'\<FILENAME\>',s:ShellEscape(expand("<cfile>")),'')
  let chgperm= substitute(chgperm,'\<PERM\>',s:ShellEscape(newperm),'')
"  call Decho("chgperm<".chgperm.">",'~'.expand("<slnum>"))
  call system(chgperm)
  if v:shell_error != 0
   NetrwKeepj call netrw#ErrorMsg(1,"changing permission on file<".expand("<cfile>")."> seems to have failed",75)
  endif
  if a:islocal
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  endif
  let @@= ykeep
"  call Dret("s:NetrwChgPerm")
endfun

" ---------------------------------------------------------------------
" s:CheckIfKde: checks if kdeinit is running {{{2
"    Returns 0: kdeinit not running
"            1: kdeinit is  running
fun! s:CheckIfKde()
"  call Dfunc("s:CheckIfKde()")
  " seems kde systems often have gnome-open due to dependencies, even though
  " gnome-open's subsidiary display tools are largely absent.  Kde systems
  " usually have "kdeinit" running, though...  (tnx Mikolaj Machowski)
  if !exists("s:haskdeinit")
   if has("unix") && executable("ps") && !has("win32unix")
    let s:haskdeinit= system("ps -e") =~ '\<kdeinit'
    if v:shell_error
     let s:haskdeinit = 0
    endif
   else
    let s:haskdeinit= 0
   endif
"   call Decho("setting s:haskdeinit=".s:haskdeinit,'~'.expand("<slnum>"))
  endif

"  call Dret("s:CheckIfKde ".s:haskdeinit)
  return s:haskdeinit
endfun

" ---------------------------------------------------------------------
" s:NetrwClearExplore: clear explore variables (if any) {{{2
fun! s:NetrwClearExplore()
"  call Dfunc("s:NetrwClearExplore()")
  2match none
  if exists("s:explore_match")        |unlet s:explore_match        |endif
  if exists("s:explore_indx")         |unlet s:explore_indx         |endif
  if exists("s:netrw_explore_prvdir") |unlet s:netrw_explore_prvdir |endif
  if exists("s:dirstarstar")          |unlet s:dirstarstar          |endif
  if exists("s:explore_prvdir")       |unlet s:explore_prvdir       |endif
  if exists("w:netrw_explore_indx")   |unlet w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|unlet w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |unlet w:netrw_explore_list   |endif
  if exists("w:netrw_explore_bufnr")  |unlet w:netrw_explore_bufnr  |endif
"   redraw!
  echo " "
  echo " "
"  call Dret("s:NetrwClearExplore")
endfun

" ---------------------------------------------------------------------
" s:NetrwExploreListUniq: {{{2
fun! s:NetrwExploreListUniq(explist)
"  call Dfunc("s:NetrwExploreListUniq(explist<".string(a:explist).">)")

  " this assumes that the list is already sorted
  let newexplist= []
  for member in a:explist
   if !exists("uniqmember") || member != uniqmember
    let uniqmember = member
    let newexplist = newexplist + [ member ]
   endif
  endfor

"  call Dret("s:NetrwExploreListUniq newexplist<".string(newexplist).">")
  return newexplist
endfun

" ---------------------------------------------------------------------
" s:NetrwForceChgDir: (gd support) Force treatment as a directory {{{2
fun! s:NetrwForceChgDir(islocal,newdir)
"  call Dfunc("s:NetrwForceChgDir(islocal=".a:islocal." newdir<".a:newdir.">)")
  let ykeep= @@
  if a:newdir !~ '/$'
   " ok, looks like force is needed to get directory-style treatment
   if a:newdir =~ '@$'
    let newdir= substitute(a:newdir,'@$','/','')
   elseif a:newdir =~ '[*=|\\]$'
    let newdir= substitute(a:newdir,'.$','/','')
   else
    let newdir= a:newdir.'/'
   endif
"   call Decho("adjusting newdir<".newdir."> due to gd",'~'.expand("<slnum>"))
  else
   " should already be getting treatment as a directory
   let newdir= a:newdir
  endif
  let newdir= s:NetrwBrowseChgDir(a:islocal,newdir)
  call s:NetrwBrowse(a:islocal,newdir)
  let @@= ykeep
"  call Dret("s:NetrwForceChgDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwGlob: does glob() if local, remote listing otherwise {{{2
"     direntry: this is the name of the directory.  Will be fnameescape'd to prevent wildcard handling by glob()
"     expr    : this is the expression to follow the directory.  Will use s:ComposePath()
"     pare    =1: remove the current directory from the resulting glob() filelist
"             =0: leave  the current directory   in the resulting glob() filelist
fun! s:NetrwGlob(direntry,expr,pare)
"  call Dfunc("s:NetrwGlob(direntry<".a:direntry."> expr<".a:expr."> pare=".a:pare.")")
  if netrw#CheckIfRemote()
   keepalt 1sp
   keepalt enew
   let keep_liststyle    = w:netrw_liststyle
   let w:netrw_liststyle = s:THINLIST
   if s:NetrwRemoteListing() == 0
    keepj keepalt %s@/@@
    let filelist= getline(1,$)
    q!
   else
    " remote listing error -- leave treedict unchanged
    let filelist= w:netrw_treedict[a:direntry]
   endif
   let w:netrw_liststyle= keep_liststyle
  elseif v:version > 704 || (v:version == 704 && has("patch656"))
   let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1,1)
   if a:pare
    let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
   endif
  else
   let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1)
   if a:pare
    let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
   endif
  endif
"  call Dret("s:NetrwGlob ".string(filelist))
  return filelist
endfun

" ---------------------------------------------------------------------
" s:NetrwForceFile: (gf support) Force treatment as a file {{{2
fun! s:NetrwForceFile(islocal,newfile)
"  call Dfunc("s:NetrwForceFile(islocal=".a:islocal." newdir<".a:newfile.">)")
  if a:newfile =~ '[/@*=|\\]$'
   let newfile= substitute(a:newfile,'.$','','')
  else
   let newfile= a:newfile
  endif
  if a:islocal
   call s:NetrwBrowseChgDir(a:islocal,newfile)
  else
   call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,newfile))
  endif
"  call Dret("s:NetrwForceFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwHide: this function is invoked by the "a" map for browsing {{{2
"          and switches the hiding mode.  The actual hiding is done by
"          s:NetrwListHide().
"             g:netrw_hide= 0: show all
"                           1: show not-hidden files
"                           2: show hidden files only
fun! s:NetrwHide(islocal)
"  call Dfunc("NetrwHide(islocal=".a:islocal.") g:netrw_hide=".g:netrw_hide)
  let ykeep= @@
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">",'~'.expand("<slnum>"))
"   call Decho("g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))

   " hide the files in the markfile list
   for fname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("match(g:netrw_list_hide<".g:netrw_list_hide.'> fname<\<'.fname.'\>>)='.match(g:netrw_list_hide,'\<'.fname.'\>')." l:isk=".&l:isk,'~'.expand("<slnum>"))
    if match(g:netrw_list_hide,'\<'.fname.'\>') != -1
     " remove fname from hiding list
     let g:netrw_list_hide= substitute(g:netrw_list_hide,'..\<'.escape(fname,g:netrw_fname_escape).'\>..','','')
     let g:netrw_list_hide= substitute(g:netrw_list_hide,',,',',','g')
     let g:netrw_list_hide= substitute(g:netrw_list_hide,'^,\|,$','','')
"     call Decho("unhide: g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
    else
     " append fname to hiding list
     if exists("g:netrw_list_hide") && g:netrw_list_hide != ""
      let g:netrw_list_hide= g:netrw_list_hide.',\<'.escape(fname,g:netrw_fname_escape).'\>'
     else
      let g:netrw_list_hide= '\<'.escape(fname,g:netrw_fname_escape).'\>'
     endif
"     call Decho("hide: g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
    endif
   endfor
   NetrwKeepj call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
   let g:netrw_hide= 1

  else

   " switch between show-all/show-not-hidden/show-hidden
   let g:netrw_hide=(g:netrw_hide+1)%3
   exe "NetrwKeepj norm! 0"
   if g:netrw_hide && g:netrw_list_hide == ""
    NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your hiding list is empty!",49)
    let @@= ykeep
"    call Dret("NetrwHide")
    return
   endif
  endif

  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep
"  call Dret("NetrwHide")
endfun

" ---------------------------------------------------------------------
" s:NetrwHideEdit: allows user to edit the file/directory hiding list {{{2
fun! s:NetrwHideEdit(islocal)
"  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")

  let ykeep= @@
  " save current cursor position
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  " get new hiding list from user
  call inputsave()
  let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
  call inputrestore()
  let g:netrw_list_hide= newhide
"  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))

  " refresh the listing
  sil NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))

  " restore cursor position
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetrwHideEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwHidden: invoked by "gh" {{{2
fun! s:NetrwHidden(islocal)
"  call Dfunc("s:NetrwHidden()")
  let ykeep= @@
  "  save current position
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  if g:netrw_list_hide =~ '\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+'
   " remove pattern from hiding list
   let g:netrw_list_hide= substitute(g:netrw_list_hide,'\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+','','')
  elseif s:Strlen(g:netrw_list_hide) >= 1
   let g:netrw_list_hide= g:netrw_list_hide . ',\(^\|\s\s\)\zs\.\S\+'
  else
   let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
  endif

  " refresh screen and return to saved position
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep
"  call Dret("s:NetrwHidden")
endfun

" ---------------------------------------------------------------------
"  s:NetrwHome: this function determines a "home" for saving bookmarks and history {{{2
fun! s:NetrwHome()
  if exists("g:netrw_home")
   let home= g:netrw_home
  else
   " go to vim plugin home
   for home in split(&rtp,',') + ['']
    if isdirectory(s:NetrwFile(home)) && filewritable(s:NetrwFile(home)) | break | endif
     let basehome= substitute(home,'[/\\]\.vim$','','')
     if isdirectory(s:NetrwFile(basehome)) && filewritable(s:NetrwFile(basehome))
     let home= basehome."/.vim"
     break
    endif
   endfor
   if home == ""
    " just pick the first directory
    let home= substitute(&rtp,',.*$','','')
   endif
   if (has("win32") || has("win95") || has("win64") || has("win16"))
    let home= substitute(home,'/','\\','g')
   endif
  endif
  " insure that the home directory exists
  if g:netrw_dirhistmax > 0 && !isdirectory(s:NetrwFile(home))
   if exists("g:netrw_mkdir")
    call system(g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)))
   else
    call mkdir(home)
   endif
  endif
  let g:netrw_home= home
  return home
endfun

" ---------------------------------------------------------------------
" s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
fun! s:NetrwLeftmouse(islocal)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")

  let ykeep= @@
  " check if the status bar was clicked on instead of a file/directory name
  while getchar(0) != 0
   "clear the input stream
  endwhile
  call feedkeys("\<LeftMouse>")
  let c          = getchar()
  let mouse_lnum = v:mouse_lnum
  let wlastline  = line('w$')
  let lastline   = line('$')
"  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr(),'~'.expand("<slnum>"))
"  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0),'~'.expand("<slnum>"))
  if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
   " appears to be a status bar leftmouse click
   let @@= ykeep
"   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
   return
  endif
   " Dec 04, 2013: following test prevents leftmouse selection/deselection of directories and files in treelist mode
   " Windows are separated by vertical separator bars - but the mouse seems to be doing what it should when dragging that bar
   " without this test when its disabled.
   " May 26, 2014: edit file, :Lex, resize window -- causes refresh.  Reinstated a modified test.  See if problems develop.
"   call Decho("v:mouse_col=".v:mouse_col." col#".col('.')." virtcol#".virtcol('.')." col($)#".col("$")." virtcol($)#".virtcol("$"),'~'.expand("<slnum>"))
   if v:mouse_col > virtcol('.')
    let @@= ykeep
"    call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
    return
   endif

  if a:islocal
   if exists("b:netrw_curdir")
    NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   endif
  else
   if exists("b:netrw_curdir")
    NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwCLeftmouse: used to select a file/directory for a target {{{2
fun! s:NetrwCLeftmouse(islocal)
"  call Dfunc("s:NetrwCLeftmouse(islocal=".a:islocal.")")
  call s:NetrwMarkFileTgt(a:islocal)
"  call Dret("s:NetrwCLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwServerEdit: edit file in a server gvim, usually NETRWSERVER  (implements <c-r>){{{2
"   a:islocal=0 : <c-r> not used, remote
"   a:islocal=1 : <c-r> no  used, local
"   a:islocal=2 : <c-r>     used, remote
"   a:islocal=3 : <c-r>     used, local
fun! s:NetrwServerEdit(islocal,fname)
"  call Dfunc("s:NetrwServerEdit(islocal=".a:islocal.",fname<".a:fname.">)")
  let islocal = a:islocal%2      " =0: remote           =1: local
  let ctrlr   = a:islocal >= 2   " =0: <c-r> not used   =1: <c-r> used
"  call Decho("islocal=".islocal." ctrlr=".ctrlr,'~'.expand("<slnum>"))

  if (islocal && isdirectory(s:NetrwFile(a:fname))) || (!islocal && a:fname =~ '/$')
   " handle directories in the local window -- not in the remote vim server
   " user must have closed the NETRWSERVER window.  Treat as normal editing from netrw.
"   call Decho("handling directory in client window",'~'.expand("<slnum>"))
   let g:netrw_browse_split= 0
   if exists("s:netrw_browse_split") && exists("s:netrw_browse_split_".winnr())
    let g:netrw_browse_split= s:netrw_browse_split_{winnr()}
    unlet s:netrw_browse_split_{winnr()}
   endif
   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,a:fname))
"   call Dret("s:NetrwServerEdit")
   return
  endif

"  call Decho("handling file in server window",'~'.expand("<slnum>"))
  if has("clientserver") && executable("gvim")
"   call Decho("has clientserver and gvim",'~'.expand("<slnum>"))

    if exists("g:netrw_browse_split") && type(g:netrw_browse_split) == 3
"     call Decho("g:netrw_browse_split=".string(g:netrw_browse_split),'~'.expand("<slnum>"))
     let srvrname = g:netrw_browse_split[0]
     let tabnum   = g:netrw_browse_split[1]
     let winnum   = g:netrw_browse_split[2]

     if serverlist() !~ '\<'.srvrname.'\>'
"      call Decho("server not available; ctrlr=".ctrlr,'~'.expand("<slnum>"))

      if !ctrlr
       " user must have closed the server window and the user did not use <c-r>, but
       " used something like <cr>.
"       call Decho("user must have closed server AND did not use ctrl-r",'~'.expand("<slnum>"))
       if exists("g:netrw_browse_split")
	unlet g:netrw_browse_split
       endif
       let g:netrw_browse_split= 0
       if exists("s:netrw_browse_split_".winnr())
        let g:netrw_browse_split= s:netrw_browse_split_{winnr()}
       endif
       call s:NetrwBrowseChgDir(islocal,a:fname)
"       call Dret("s:NetrwServerEdit")
       return

      elseif has("win32") && executable("start")
       " start up remote netrw server under windows
"       call Decho("starting up gvim server<".srvrname."> for windows",'~'.expand("<slnum>"))
       call system("start gvim --servername ".srvrname)

      else
       " start up remote netrw server under linux
"       call Decho("starting up gvim server<".srvrname.">",'~'.expand("<slnum>"))
       call system("gvim --servername ".srvrname)
      endif
     endif

"     call Decho("srvrname<".srvrname."> tabnum=".tabnum." winnum=".winnum." server-editing<".a:fname.">",'~'.expand("<slnum>"))
     call remote_send(srvrname,":tabn ".tabnum."\<cr>")
     call remote_send(srvrname,":".winnum."wincmd w\<cr>")
     call remote_send(srvrname,":e ".fnameescape(s:NetrwFile(a:fname))."\<cr>")

    else

     if serverlist() !~ '\<'.g:netrw_servername.'\>'

      if !ctrlr
"       call Decho("server<".g:netrw_servername."> not available and ctrl-r not used",'~'.expand("<slnum>"))
       if exists("g:netrw_browse_split")
	unlet g:netrw_browse_split
       endif
       let g:netrw_browse_split= 0
       call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,a:fname))
"       call Dret("s:NetrwServerEdit")
       return

      else
"       call Decho("server<".g:netrw_servername."> not available but ctrl-r used",'~'.expand("<slnum>"))
       if has("win32") && executable("start")
        " start up remote netrw server under windows
"        call Decho("starting up gvim server<".g:netrw_servername."> for windows",'~'.expand("<slnum>"))
        call system("start gvim --servername ".g:netrw_servername)
       else
        " start up remote netrw server under linux
"        call Decho("starting up gvim server<".g:netrw_servername.">",'~'.expand("<slnum>"))
        call system("gvim --servername ".g:netrw_servername)
       endif
      endif
     endif

     while 1
      try
"       call Decho("remote-send: e ".a:fname,'~'.expand("<slnum>"))
       call remote_send(g:netrw_servername,":e ".fnameescape(s:NetrwFile(a:fname))."\<cr>")
       break
      catch /^Vim\%((\a\+)\)\=:E241/
       sleep 200m
      endtry
     endwhile

     if exists("g:netrw_browse_split")
      if type(g:netrw_browse_split) != 3
        let s:netrw_browse_split_{winnr()}= g:netrw_browse_split
       endif
      unlet g:netrw_browse_split
     endif
     let g:netrw_browse_split= [g:netrw_servername,1,1]
    endif

   else
    call netrw#ErrorMsg(s:ERROR,"you need a gui-capable vim and client-server to use <ctrl-r>",98)
   endif

"  call Dret("s:NetrwServerEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftmouse: marks the file under the cursor.  May be dragged to select additional files {{{2
fun! s:NetrwSLeftmouse(islocal)
"  call Dfunc("s:NetrwSLeftmouse(islocal=".a:islocal.")")

  let s:ngw= s:NetrwGetWord()
  call s:NetrwMarkFile(a:islocal,s:ngw)

"  call Dret("s:NetrwSLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftdrag: invoked via a shift-leftmouse and dragging {{{2
"                   Used to mark multiple files.
fun! s:NetrwSLeftdrag(islocal)
"  call Dfunc("s:NetrwSLeftdrag(islocal=".a:islocal.")")
  if !exists("s:netrwdrag")
   let s:netrwdrag = winnr()
   if a:islocal
    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(1)<cr>
   else
    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(0)<cr>
   endif
  endif
  let ngw = s:NetrwGetWord()
  if !exists("s:ngw") || s:ngw != ngw
   call s:NetrwMarkFile(a:islocal,ngw)
  endif
  let s:ngw= ngw
"  call Dret("s:NetrwSLeftdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftrelease: terminates shift-leftmouse dragging {{{2
fun! s:NetrwSLeftrelease(islocal)
"  call Dfunc("s:NetrwSLeftrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
  if exists("s:netrwdrag")
   nunmap <s-leftrelease>
   let ngw = s:NetrwGetWord()
   if !exists("s:ngw") || s:ngw != ngw
    call s:NetrwMarkFile(a:islocal,ngw)
   endif
   if exists("s:ngw")
    unlet s:ngw
   endif
   unlet s:netrwdrag
  endif
"  call Dret("s:NetrwSLeftrelease")
endfun

" ---------------------------------------------------------------------
" s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
" separated patterns given in g:netrw_list_hide
fun! s:NetrwListHide()
"  call Dfunc("s:NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
  let ykeep= @@

  " find a character not in the "hide" string to use as a separator for :g and :v commands
  " How-it-works: take the hiding command, convert it into a range.  Duplicate
  " characters don't matter.  Remove all such characters from the '/~...90'
  " string.  Use the first character left as a separator character.
  let listhide= g:netrw_list_hide
  let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
"  call Decho("sep=".sep,'~'.expand("<slnum>"))

  while listhide != ""
   if listhide =~ ','
    let hide     = substitute(listhide,',.*$','','e')
    let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
   else
    let hide     = listhide
    let listhide = ""
   endif

   " Prune the list by hiding any files which match
   if g:netrw_hide == 1
"    call Decho("hiding<".hide."> listhide<".listhide.">",'~'.expand("<slnum>"))
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
   elseif g:netrw_hide == 2
"    call Decho("showing<".hide."> listhide<".listhide.">",'~'.expand("<slnum>"))
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
   endif
  endwhile
  if g:netrw_hide == 2
   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
  endif

  " remove any blank lines that have somehow remained.
  " This seems to happen under Windows.
  exe 'sil! NetrwKeepj 1,$g@^\s*$@d'

  let @@= ykeep
"  call Dret("s:NetrwListHide")
endfun

" ---------------------------------------------------------------------
" s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
"                 implements the "d" mapping.
fun! s:NetrwMakeDir(usrhost)
"  call Dfunc("s:NetrwMakeDir(usrhost<".a:usrhost.">)")

  let ykeep= @@
  " get name of new directory from user.  A bare <CR> will skip.
  " if its currently a directory, also request will be skipped, but with
  " a message.
  call inputsave()
  let newdirname= input("Please give directory name: ")
  call inputrestore()
"  call Decho("newdirname<".newdirname.">",'~'.expand("<slnum>"))

  if newdirname == ""
   let @@= ykeep
"   call Dret("s:NetrwMakeDir : user aborted with bare <cr>")
   return
  endif

  if a:usrhost == ""
"   call Decho("local mkdir",'~'.expand("<slnum>"))

   " Local mkdir:
   " sanity checks
   let fullnewdir= b:netrw_curdir.'/'.newdirname
"   call Decho("fullnewdir<".fullnewdir.">",'~'.expand("<slnum>"))
   if isdirectory(s:NetrwFile(fullnewdir))
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
    endif
    let @@= ykeep
"    call Dret("s:NetrwMakeDir : directory<".newdirname."> exists previously")
    return
   endif
   if s:FileReadable(fullnewdir)
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
    endif
    let @@= ykeep
"    call Dret("s:NetrwMakeDir : file<".newdirname."> exists previously")
    return
   endif

   " requested new local directory is neither a pre-existing file or
   " directory, so make it!
   if exists("*mkdir")
    if has("unix")
     call mkdir(fullnewdir,"p",xor(0777, system("umask")))
    else
     call mkdir(fullnewdir,"p")
    endif
   else
    let netrw_origdir= s:NetrwGetcwd(1)
    call s:NetrwLcd(b:netrw_curdir)
"    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">",'~'.expand("<slnum>"))
    call s:NetrwExe("sil! !".g:netrw_localmkdir.' '.s:ShellEscape(newdirname,1))
    if v:shell_error != 0
     let @@= ykeep
     call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.s:ShellEscape(newdirname,1))
     return
    endif
    if !g:netrw_keepdir
"     call Decho("restoring netrw_origdir since g:netrw_keepdir=".g:netrw_keepdir,'~'.expand("<slnum>"))
     call s:NetrwLcd(netrw_origdir)
    endif
   endif

   if v:shell_error == 0
    " refresh listing
"    call Decho("refresh listing",'~'.expand("<slnum>"))
    let svpos= winsaveview()
"    call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    call winrestview(svpos)
   elseif !exists("g:netrw_quiet")
    call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
   endif
"   redraw!

  elseif !exists("b:netrw_method") || b:netrw_method == 4
   " Remote mkdir:  using ssh
"   call Decho("remote mkdir",'~'.expand("<slnum>"))
   let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
   let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
   call s:NetrwExe("sil! !".mkdircmd." ".s:ShellEscape(newdirname,1))
   if v:shell_error == 0
    " refresh listing
    let svpos= winsaveview()
"    call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    NetrwKeepj call winrestview(svpos)
   elseif !exists("g:netrw_quiet")
    NetrwKeepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
   endif
"   redraw!

  elseif b:netrw_method == 2
   " Remote mkdir:  using ftp+.netrc
   let svpos= winsaveview()
"   call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)

  elseif b:netrw_method == 3
   " Remote mkdir: using ftp + machine, id, passwd, and fname (ie. no .netrc)
   let svpos= winsaveview()
"   call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  endif

  let @@= ykeep
"  call Dret("s:NetrwMakeDir")
endfun

" ---------------------------------------------------------------------
" s:TreeSqueezeDir: allows a shift-cr (gvim only) to squeeze the current tree-listing directory {{{2
fun! s:TreeSqueezeDir(islocal)
"  call Dfunc("s:TreeSqueezeDir(islocal=".a:islocal.")")
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " its a tree-listing style
   let curdepth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
   let stopline = (exists("w:netrw_bannercnt")? (w:netrw_bannercnt + 1) : 1)
   let depth    = strchars(substitute(curdepth,' ','','g'))
   let srch     = -1
"   call Decho("curdepth<".curdepth.'>','~'.expand("<slnum>"))
"   call Decho("depth   =".depth,'~'.expand("<slnum>"))
"   call Decho("stopline#".stopline,'~'.expand("<slnum>"))
"   call Decho("curline#".line(".")."<".getline('.').'>','~'.expand("<slnum>"))
   if depth >= 2
    NetrwKeepj norm! 0
    let curdepthm1= substitute(curdepth,'^'.s:treedepthstring,'','')
    let srch      = search('^'.curdepthm1.'\%('.s:treedepthstring.'\)\@!','bW',stopline)
"    call Decho("curdepthm1<".curdepthm1.'>','~'.expand("<slnum>"))
"    call Decho("case depth>=2: srch<".srch.'>','~'.expand("<slnum>"))
   elseif depth == 1
    NetrwKeepj norm! 0
    let treedepthchr= substitute(s:treedepthstring,' ','','')
    let srch        = search('^[^'.treedepthchr.']','bW',stopline)
"    call Decho("case depth==1: srch<".srch.'>','~'.expand("<slnum>"))
   endif
   if srch > 0
"    call Decho("squeezing at line#".line(".").": ".getline('.'),'~'.expand("<slnum>"))
    call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,s:NetrwGetWord()))
    exe srch
   endif
  endif
"  call Dret("s:TreeSqueezeDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwMaps: {{{2
fun! s:NetrwMaps(islocal)
"  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")

  if g:netrw_mousemaps && g:netrw_retmap
"   call Decho("set up Rexplore 2-leftmouse",'~'.expand("<slnum>"))
   if !hasmapto("<Plug>NetrwReturn")
    if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
"     call Decho("making map for 2-leftmouse",'~'.expand("<slnum>"))
     nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
    elseif maparg("<c-leftmouse>","n") == ""
"     call Decho("making map for c-leftmouse",'~'.expand("<slnum>"))
     nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
    endif
   endif
   nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
"   call Decho("made <Plug>NetrwReturn map",'~'.expand("<slnum>"))
  endif

  if a:islocal
"   call Decho("make local maps",'~'.expand("<slnum>"))
   " local normal-mode maps
   nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(1)<cr>
   nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(1)<cr>
   nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(1)<cr>
   nnoremap <buffer> <silent> <nowait> c	:<c-u>call <SID>NetrwLcd(b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(3,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> d	:<c-u>call <SID>NetrwMakeDir("")<cr>
   nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
   nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(1)<cr>
   nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(1,0)<cr>
   nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(1,1)<cr>
   nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
   nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
   nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(1)<cr>
   nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(3)<cr>
   nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(1)<cr>
   nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
   nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(1)<cr>
   nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(1)<cr>
   nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
   nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(4)<cr>
   nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
   nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(5)<cr>
   nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   nnoremap <buffer> <silent> <nowait> X	:<c-u>call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
"   " local insert-mode maps
"   inoremap <buffer> <silent> <nowait> a	<c-o>:call <SID>NetrwHide(1)<cr>
"   inoremap <buffer> <silent> <nowait> c	<c-o>:exe "NetrwKeepj lcd ".fnameescape(b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> c	<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> C	<c-o>:call <SID>NetrwSetChgwin()<cr>
"   inoremap <buffer> <silent> <nowait> %	<c-o>:call <SID>NetrwOpenFile(1)<cr>
"   inoremap <buffer> <silent> <nowait> -	<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
"   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
"   inoremap <buffer> <silent> <nowait> d	<c-o>:call <SID>NetrwMakeDir("")<cr>
"   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
"   nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> I	<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
"   inoremap <buffer> <silent> <nowait> i	<c-o>:call <SID>NetrwListStyle(1)<cr>
"   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
"   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
"   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
"   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
"   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
"   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
"   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
"   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
"   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
"   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
"   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
"   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
"   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
"   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
"   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
"   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
"   inoremap <buffer> <silent> <nowait> O	<c-o>:call <SID>NetrwObtain(1)<cr>
"   inoremap <buffer> <silent> <nowait> o	<c-o>:call <SID>NetrwSplit(3)<cr>
"   inoremap <buffer> <silent> <nowait> p	<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
"   inoremap <buffer> <silent> <nowait> P	<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
"   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
"   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
"   inoremap <buffer> <silent> <nowait> r	<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
"   inoremap <buffer> <silent> <nowait> s	<c-o>:call <SID>NetrwSortStyle(1)<cr>
"   inoremap <buffer> <silent> <nowait> S	<c-o>:call <SID>NetSortSequence(1)<cr>
"   inoremap <buffer> <silent> <nowait> t	<c-o>:call <SID>NetrwSplit(4)<cr>
"   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
"   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
"   inoremap <buffer> <silent> <nowait> u	<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
"   inoremap <buffer> <silent> <nowait> U	<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
"   inoremap <buffer> <silent> <nowait> v	<c-o>:call <SID>NetrwSplit(5)<cr>
"   inoremap <buffer> <silent> <nowait> x	<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
"    imap <buffer> <unique> <c-h> <c-o><Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit		:call <SID>NetrwHideEdit(1)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
"    imap <buffer> <unique> <c-l> <c-o><Plug>NetrwRefresh
   endif
   nnoremap <buffer> <silent> <Plug>NetrwRefresh		<c-l>:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,(w:netrw_liststyle == 3)? w:netrw_treetop : './'))<cr>
   if s:didstarstar || !mapcheck("<s-down>","n")
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
"    inoremap <buffer> <silent> <s-down>	<c-o>:Nexplore<cr>
   endif
   if s:didstarstar || !mapcheck("<s-up>","n")
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
"    inoremap <buffer> <silent> <s-up>	<c-o>:Pexplore<cr>
   endif
   if !hasmapto('<Plug>NetrwTreeSqueeze')
    nmap <buffer> <silent> <nowait> <s-cr>			<Plug>NetrwTreeSqueeze
"    imap <buffer> <silent> <nowait> <s-cr>			<c-o><Plug>NetrwTreeSqueeze
   endif
   nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze		:call <SID>TreeSqueezeDir(1)<cr>
   let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
   if g:netrw_mousemaps == 1
    nmap <buffer> <leftmouse>   				<Plug>NetrwLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
    nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(1)<cr>
    nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>		<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
    imap <buffer> <leftmouse>		<Plug>ILeftmouse
"    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
"    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
"    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
"    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
"    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>

   " support user-specified maps
   call netrw#UserMaps(1)

  else " remote
"   call Decho("make remote maps",'~'.expand("<slnum>"))
   call s:RemotePathAnalysis(b:netrw_curdir)
   " remote normal-mode maps
   nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(0)<cr>
   nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(0)<cr>
   nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(0)<cr>
   nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> <nowait> <c-l>	:<c-u>call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(2,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
   nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(0)<cr>
   nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(0,0)<cr>
   nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(0,1)<cr>
   nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
   nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
   nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
   nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
   nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
   nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
   nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
   nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
   nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
   nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
   nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
   nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
   nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
   nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
   nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
   nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(0)<cr>
   nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(0)<cr>
   nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(0)<cr>
   nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
   nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
   nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(0)<cr>
   nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(0)<cr>
   nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(0,'b',v:count1)<cr>
   nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(1)<cr>
   nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(0,'h',v:count)<cr>
   nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(2)<cr>
   nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
"   " remote insert-mode maps
"   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
"   inoremap <buffer> <silent> <nowait> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
"   inoremap <buffer> <silent> <nowait> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
"   inoremap <buffer> <silent> <nowait> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
"   inoremap <buffer> <silent> <nowait> a		<c-o>:call <SID>NetrwHide(0)<cr>
"   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
"   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
"   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
"   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
"   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
"   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
"   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
"   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
"   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
"   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
"   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
"   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
"   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
"   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
"   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
"   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
"   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
"   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
"   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
"   inoremap <buffer> <silent> <nowait> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
"   inoremap <buffer> <silent> <nowait> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
"   inoremap <buffer> <silent> <nowait> o		<c-o>:call <SID>NetrwSplit(0)<cr>
"   inoremap <buffer> <silent> <nowait> O		<c-o>:call <SID>NetrwObtain(0)<cr>
"   inoremap <buffer> <silent> <nowait> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
"   inoremap <buffer> <silent> <nowait> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
"   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
"   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
"   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
"   inoremap <buffer> <silent> <nowait> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
"   inoremap <buffer> <silent> <nowait> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
"   inoremap <buffer> <silent> <nowait> S		<c-o>:call <SID>NetSortSequence(0)<cr>
"   inoremap <buffer> <silent> <nowait> t		<c-o>:call <SID>NetrwSplit(1)<cr>
"   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
"   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
"   inoremap <buffer> <silent> <nowait> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
"   inoremap <buffer> <silent> <nowait> v		<c-o>:call <SID>NetrwSplit(2)<cr>
"   inoremap <buffer> <silent> <nowait> x		<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
"   inoremap <buffer> <silent> <nowait> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <c-h> <Plug>NetrwHideEdit
"    imap <buffer> <c-h> <Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <c-l> <Plug>NetrwRefresh
"    imap <buffer> <c-l> <Plug>NetrwRefresh
   endif
   if !hasmapto('<Plug>NetrwTreeSqueeze')
    nmap <buffer> <silent> <nowait> <s-cr>	<Plug>NetrwTreeSqueeze
"    imap <buffer> <silent> <nowait> <s-cr>	<c-o><Plug>NetrwTreeSqueeze
   endif
   nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze	:call <SID>TreeSqueezeDir(0)<cr>

   let mapsafepath     = escape(s:path, s:netrw_map_escape)
   let mapsafeusermach = escape(((s:user == "")? "" : s:user."@").s:machine, s:netrw_map_escape)

   nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   if g:netrw_mousemaps == 1
    nmap <buffer> <leftmouse>		<Plug>NetrwLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
    nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(0)<cr>
    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
    nmap <middlemouse>			<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>		<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
    imap <buffer> <leftmouse>		<Plug>ILeftmouse
"    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
"    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
"    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
"   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
"   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>

   " support user-specified maps
   call netrw#UserMaps(0)
  endif

"  call Dret("s:NetrwMaps")
endfun

" ---------------------------------------------------------------------
" s:NetrwCommands: set up commands 				{{{2
"  If -buffer, the command is only available from within netrw buffers
"  Otherwise, the command is available from any window, so long as netrw
"  has been used at least once in the session.
fun! s:NetrwCommands(islocal)
"  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")

  com! -nargs=* -complete=file -bang	NetrwMB	call s:NetrwBookmark(<bang>0,<f-args>)
  com! -nargs=*			    	NetrwC	call s:NetrwSetChgwin(<q-args>)
  com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"win#".winnr()." not a former netrw window",79)|endif
  if a:islocal
   com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(1,<f-args>)
  else
   com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(0,<f-args>)
  endif
  com! -buffer -nargs=? -complete=file	MT	call s:NetrwMarkTarget(<q-args>)

"  call Dret("s:NetrwCommands")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFiles: apply s:NetrwMarkFile() to named file(s) {{{2
"                   glob()ing only works with local files
fun! s:NetrwMarkFiles(islocal,...)
"  call Dfunc("s:NetrwMarkFiles(islocal=".a:islocal."...) a:0=".a:0)
  let curdir = s:NetrwGetCurdir(a:islocal)
  let i      = 1
  while i <= a:0
   if a:islocal
    if v:version > 704 || (v:version == 704 && has("patch656"))
     let mffiles= glob(fnameescape(a:{i}),0,1,1)
    else
     let mffiles= glob(fnameescape(a:{i}),0,1)
    endif
   else
    let mffiles= [a:{i}]
   endif
"   call Decho("mffiles".string(mffiles),'~'.expand("<slnum>"))
   for mffile in mffiles
"    call Decho("mffile<".mffile.">",'~'.expand("<slnum>"))
    call s:NetrwMarkFile(a:islocal,mffile)
   endfor
   let i= i + 1
  endwhile
"  call Dret("s:NetrwMarkFiles")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkTarget: implements :MT (mark target) {{{2
fun! s:NetrwMarkTarget(...)
"  call Dfunc("s:NetrwMarkTarget() a:0=".a:0)
  if a:0 == 0 || (a:0 == 1 && a:1 == "")
   let curdir = s:NetrwGetCurdir(1)
   let tgt    = b:netrw_curdir
  else
   let curdir = s:NetrwGetCurdir((a:1 =~ '^\a\{3,}://')? 0 : 1)
   let tgt    = a:1
  endif
"  call Decho("tgt<".tgt.">",'~'.expand("<slnum>"))
  let s:netrwmftgt         = tgt
  let s:netrwmftgt_islocal = tgt !~ '^\a\{3,}://'
  let curislocal           = b:netrw_curdir !~ '^\a\{3,}://'
  let svpos                = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call s:NetrwRefresh(curislocal,s:NetrwBrowseChgDir(curislocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)
"  call Dret("s:NetrwMarkTarget")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFile: (invoked by mf) This function is used to both {{{2
"                  mark and unmark files.  If a markfile list exists,
"                  then the rename and delete functions will use it instead
"                  of whatever may happen to be under the cursor at that
"                  moment.  When the mouse and gui are available,
"                  shift-leftmouse may also be used to mark files.
"
"  Creates two lists
"    s:netrwmarkfilelist    -- holds complete paths to all marked files
"    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
"
"  Creates a marked file match string
"    s:netrwmarfilemtch_#   -- used with 2match to display marked files
"
"  Creates a buffer version of islocal
"    b:netrw_islocal
fun! s:NetrwMarkFile(islocal,fname)
"  call Dfunc("s:NetrwMarkFile(islocal=".a:islocal." fname<".a:fname.">)")
"  call Decho("bufnr(%)=".bufnr("%").": ".bufname("%"),'~'.expand("<slnum>"))

  " sanity check
  if empty(a:fname)
"   call Dret("s:NetrwMarkFile : emtpy fname")
   return
  endif
  let curdir = s:NetrwGetCurdir(a:islocal)

  let ykeep   = @@
  let curbufnr= bufnr("%")
  if a:fname =~ '^\a'
   let leader= '\<'
  else
   let leader= ''
  endif
  if a:fname =~ '\a$'
   let trailer = '\>[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  else
   let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  endif

  if exists("s:netrwmarkfilelist_".curbufnr)
   " markfile list pre-exists
"   call Decho("case s:netrwmarkfilelist_".curbufnr." already exists",'~'.expand("<slnum>"))
"   call Decho("starting s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
"   call Decho("starting s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">",'~'.expand("<slnum>"))
   let b:netrw_islocal= a:islocal

   if index(s:netrwmarkfilelist_{curbufnr},a:fname) == -1
    " append filename to buffer's markfilelist
"    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
    call add(s:netrwmarkfilelist_{curbufnr},a:fname)
    let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(a:fname,g:netrw_markfileesc).trailer

   else
    " remove filename from buffer's markfilelist
"    call Decho("remove filename<".a:fname."> from local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
    call filter(s:netrwmarkfilelist_{curbufnr},'v:val != a:fname')
    if s:netrwmarkfilelist_{curbufnr} == []
     " local markfilelist is empty; remove it entirely
"     call Decho("markfile list now empty",'~'.expand("<slnum>"))
     call s:NetrwUnmarkList(curbufnr,curdir)
    else
     " rebuild match list to display markings correctly
"     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr,'~'.expand("<slnum>"))
     let s:netrwmarkfilemtch_{curbufnr}= ""
     let first                         = 1
     for fname in s:netrwmarkfilelist_{curbufnr}
      if first
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.leader.escape(fname,g:netrw_markfileesc).trailer
      else
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(fname,g:netrw_markfileesc).trailer
      endif
      let first= 0
     endfor
"     call Decho("ending s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
    endif
   endif

  else
   " initialize new markfilelist
"   call Decho("case: initialize new markfilelist",'~'.expand("<slnum>"))

"   call Decho("add fname<".a:fname."> to new markfilelist_".curbufnr,'~'.expand("<slnum>"))
   let s:netrwmarkfilelist_{curbufnr}= []
   call add(s:netrwmarkfilelist_{curbufnr},substitute(a:fname,'[|@]$','',''))
"   call Decho("ending s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))

   " build initial markfile matching pattern
   if a:fname =~ '/$'
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc)
   else
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc).trailer
   endif
"   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">",'~'.expand("<slnum>"))
  endif

  " handle global markfilelist
  if exists("s:netrwmarkfilelist")
   let dname= s:ComposePath(b:netrw_curdir,a:fname)
   if index(s:netrwmarkfilelist,dname) == -1
    " append new filename to global markfilelist
    call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"    call Decho("append filename<".a:fname."> to global markfilelist<".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
   else
    " remove new filename from global markfilelist
"    call Decho("filter(".string(s:netrwmarkfilelist).",'v:val != '.".dname.")",'~'.expand("<slnum>"))
    call filter(s:netrwmarkfilelist,'v:val != "'.dname.'"')
"    call Decho("ending s:netrwmarkfilelist  <".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
    if s:netrwmarkfilelist == []
     unlet s:netrwmarkfilelist
    endif
   endif
  else
   " initialize new global-directory markfilelist
   let s:netrwmarkfilelist= []
   call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"   call Decho("init s:netrwmarkfilelist<".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
  endif

  " set up 2match'ing to netrwmarkfilemtch_# list
  if exists("s:netrwmarkfilemtch_{curbufnr}") && s:netrwmarkfilemtch_{curbufnr} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/",'~'.expand("<slnum>"))
   if exists("g:did_drchip_netrwlist_syntax")
    exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/"
   endif
  else
"   call Decho("2match none",'~'.expand("<slnum>"))
   2match none
  endif
  let @@= ykeep
"  call Dret("s:NetrwMarkFile : s:netrwmarkfilelist_".curbufnr."<".(exists("s:netrwmarkfilelist_{curbufnr}")? string(s:netrwmarkfilelist_{curbufnr}) : " doesn't exist").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileArgList: ma: move the marked file list to the argument list (tomflist=0) {{{2
"                         mA: move the argument list to marked file list     (tomflist=1)
"                            Uses the global marked file list
fun! s:NetrwMarkFileArgList(islocal,tomflist)
"  call Dfunc("s:NetrwMarkFileArgList(islocal=".a:islocal.",tomflist=".a:tomflist.")")

  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  if a:tomflist
   " mA: move argument list to marked file list
   while argc()
    let fname= argv(0)
"    call Decho("exe argdel ".fname,'~'.expand("<slnum>"))
    exe "argdel ".fnameescape(fname)
    call s:NetrwMarkFile(a:islocal,fname)
   endwhile

  else
   " ma: move marked file list to argument list
   if exists("s:netrwmarkfilelist")

    " for every filename in the marked list
    for fname in s:netrwmarkfilelist
"     call Decho("exe argadd ".fname,'~'.expand("<slnum>"))
     exe "argadd ".fnameescape(fname)
    endfor	" for every file in the marked list

    " unmark list and refresh
    call s:NetrwUnmarkList(curbufnr,curdir)
    NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    NetrwKeepj call winrestview(svpos)
   endif
  endif

"  call Dret("s:NetrwMarkFileArgList")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCompress: (invoked by mz) This function is used to {{{2
"                          compress/decompress files using the programs
"                          in g:netrw_compress and g:netrw_uncompress,
"                          using g:netrw_compress_suffix to know which to
"                          do.  By default:
"                            g:netrw_compress        = "gzip"
"                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
fun! s:NetrwMarkFileCompress(islocal)
"  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCompress")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{curbufnr}") && exists("g:netrw_compress") && exists("g:netrw_decompress")

   " for every filename in the marked list
   for fname in s:netrwmarkfilelist_{curbufnr}
    let sfx= substitute(fname,'^.\{-}\(\.\a\+\)$','\1','')
"    call Decho("extracted sfx<".sfx.">",'~'.expand("<slnum>"))
    if exists("g:netrw_decompress['".sfx."']")
     " fname has a suffix indicating that its compressed; apply associated decompression routine
     let exe= g:netrw_decompress[sfx]
"     call Decho("fname<".fname."> is compressed so decompress with <".exe.">",'~'.expand("<slnum>"))
     let exe= netrw#WinPath(exe)
     if a:islocal
      if g:netrw_keepdir
       let fname= s:ShellEscape(s:ComposePath(curdir,fname))
      endif
     else
      let fname= s:ShellEscape(b:netrw_curdir.fname,1)
     endif
     if executable(exe)
      if a:islocal
       call system(exe." ".fname)
      else
       NetrwKeepj call s:RemoteSystem(exe." ".fname)
      endif
     else
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"unable to apply<".exe."> to file<".fname.">",50)
     endif
    endif
    unlet sfx

    if exists("exe")
     unlet exe
    elseif a:islocal
     " fname not a compressed file, so compress it
     call system(netrw#WinPath(g:netrw_compress)." ".s:ShellEscape(s:ComposePath(b:netrw_curdir,fname)))
    else
     " fname not a compressed file, so compress it
     NetrwKeepj call s:RemoteSystem(netrw#WinPath(g:netrw_compress)." ".s:ShellEscape(fname))
    endif
   endfor	" for every file in the marked list

   call s:NetrwUnmarkList(curbufnr,curdir)
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  endif
"  call Dret("s:NetrwMarkFileCompress")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCopy: (invoked by mc) copy marked files to target {{{2
"                      If no marked files, then set up directory as the
"                      target.  Currently does not support copying entire
"                      directories.  Uses the local-buffer marked file list.
"                      Returns 1=success  (used by NetrwMarkFileMove())
"                              0=failure
fun! s:NetrwMarkFileCopy(islocal,...)
"  call Dfunc("s:NetrwMarkFileCopy(islocal=".a:islocal.") target<".(exists("s:netrwmftgt")? s:netrwmftgt : '---')."> a:0=".a:0)

  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")
  if b:netrw_curdir !~ '/$'
   if !exists("b:netrw_curdir")
    let b:netrw_curdir= curdir
   endif
   let b:netrw_curdir= b:netrw_curdir."/"
  endif

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCopy")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if !exists("s:netrwmftgt")
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))

  if a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, local directory to local directory
"   call Decho("copy from local to local",'~'.expand("<slnum>"))
   if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
    return
   endif

   " copy marked files while within the same directory (ie. allow renaming)
   if simplify(s:netrwmftgt) == simplify(b:netrw_curdir)
    if len(s:netrwmarkfilelist_{bufnr('%')}) == 1
     " only one marked file
"     call Decho("case: only one marked file",'~'.expand("<slnum>"))
     let args    = s:ShellEscape(b:netrw_curdir.s:netrwmarkfilelist_{bufnr('%')}[0])
     let oldname = s:netrwmarkfilelist_{bufnr('%')}[0]
    elseif a:0 == 1
"     call Decho("case: handling one input argument",'~'.expand("<slnum>"))
     " this happens when the next case was used to recursively call s:NetrwMarkFileCopy()
     let args    = s:ShellEscape(b:netrw_curdir.a:1)
     let oldname = a:1
    else
     " copy multiple marked files inside the same directory
"     call Decho("case: handling a multiple marked files",'~'.expand("<slnum>"))
     let s:recursive= 1
     for oldname in s:netrwmarkfilelist_{bufnr("%")}
      let ret= s:NetrwMarkFileCopy(a:islocal,oldname)
      if ret == 0
       break
      endif
     endfor
     unlet s:recursive
     call s:NetrwUnmarkList(curbufnr,curdir)
"     call Dret("s:NetrwMarkFileCopy ".ret)
     return ret
    endif

    call inputsave()
    let newname= input("Copy ".oldname." to : ",oldname,"file")
    call inputrestore()
    if newname == ""
"     call Dret("s:NetrwMarkFileCopy 0")
     return 0
    endif
    let args= s:ShellEscape(oldname)
    let tgt = s:ShellEscape(s:netrwmftgt.'/'.newname)
   else
    let args= join(map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),"s:ShellEscape(b:netrw_curdir.\"/\".v:val)"))
    let tgt = s:ShellEscape(s:netrwmftgt)
   endif
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let args= substitute(args,'/','\\','g')
    let tgt = substitute(tgt, '/','\\','g')
   endif
   if args =~ "'" |let args= substitute(args,"'\\(.*\\)'",'\1','')|endif
   if tgt  =~ "'" |let tgt = substitute(tgt ,"'\\(.*\\)'",'\1','')|endif
   if args =~ '//'|let args= substitute(args,'//','/','g')|endif
   if tgt  =~ '//'|let tgt = substitute(tgt ,'//','/','g')|endif
"   call Decho("args   <".args.">",'~'.expand("<slnum>"))
"   call Decho("tgt    <".tgt.">",'~'.expand("<slnum>"))
   if isdirectory(s:NetrwFile(args))
"    call Decho("args<".args."> is a directory",'~'.expand("<slnum>"))
    let copycmd= g:netrw_localcopydircmd
"    call Decho("using copydircmd<".copycmd.">",'~'.expand("<slnum>"))
    if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
     " window's xcopy doesn't copy a directory to a target properly.  Instead, it copies a directory's
     " contents to a target.  One must append the source directory name to the target to get xcopy to
     " do the right thing.
     let tgt= tgt.'\'.substitute(a:1,'^.*[\\/]','','')
"     call Decho("modified tgt for xcopy",'~'.expand("<slnum>"))
    endif
   else
    let copycmd= g:netrw_localcopycmd
   endif
   if g:netrw_localcopycmd =~ '\s'
    let copycmd     = substitute(copycmd,'\s.*$','','')
    let copycmdargs = substitute(copycmd,'^.\{-}\(\s.*\)$','\1','')
    let copycmd     = netrw#WinPath(copycmd).copycmdargs
   else
    let copycmd = netrw#WinPath(copycmd)
   endif
"   call Decho("args   <".args.">",'~'.expand("<slnum>"))
"   call Decho("tgt    <".tgt.">",'~'.expand("<slnum>"))
"   call Decho("copycmd<".copycmd.">",'~'.expand("<slnum>"))
"   call Decho("system(".copycmd." '".args."' '".tgt."')",'~'.expand("<slnum>"))
   call system(copycmd." '".args."' '".tgt."'")
   if v:shell_error != 0
    if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
     call netrw#ErrorMsg(s:ERROR,"copy failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",101)
    else
     call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localcopycmd<".g:netrw_localcopycmd.">; it doesn't work!",80)
    endif
"    call Dret("s:NetrwMarkFileCopy 0 : failed: system(".g:netrw_localcopycmd." ".args." ".s:ShellEscape(s:netrwmftgt))
    return 0
   endif

  elseif  a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, local directory to remote directory
"   call Decho("copy from local to remote",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwUpload(s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, remote directory to local directory
"   call Decho("copy from remote to local",'~'.expand("<slnum>"))
   NetrwKeepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, remote directory to remote directory
"   call Decho("copy from remote to remote",'~'.expand("<slnum>"))
   let curdir = getcwd()
   let tmpdir = s:GetTempfile("")
   if tmpdir !~ '/'
    let tmpdir= curdir."/".tmpdir
   endif
   if exists("*mkdir")
    call mkdir(tmpdir)
   else
    call s:NetrwExe("sil! !".g:netrw_localmkdir.' '.s:ShellEscape(tmpdir,1))
    if v:shell_error != 0
     call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMarkFileCopy : failed: sil! !".g:netrw_localmkdir.' '.s:ShellEscape(tmpdir,1) )
     return
    endif
   endif
   if isdirectory(s:NetrwFile(tmpdir))
    call s:NetrwLcd(tmpdir)
    NetrwKeepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
    let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
    NetrwKeepj call s:NetrwUpload(localfiles,s:netrwmftgt)
    if getcwd() == tmpdir
     for fname in s:netrwmarkfilelist_{bufnr('%')}
      NetrwKeepj call s:NetrwDelete(fname)
     endfor
     call s:NetrwLcd(curdir)
     if v:version < 704 || !has("patch1109")
      call s:NetrwExe("sil !".g:netrw_localrmdir." ".s:ShellEscape(tmpdir,1))
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
" "      call Dret("s:NetrwMarkFileCopy : failed: sil !".g:netrw_localrmdir." ".s:ShellEscape(tmpdir,1) )
       return
      endif
     else
      if delete(tmpdir,"d")
       call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".tmpdir.">!",103)
      endif
     endif
    else
     call s:NetrwLcd(curdir)
    endif
   endif
  endif

  " -------
  " cleanup
  " -------
"  call Decho("cleanup",'~'.expand("<slnum>"))
  " remove markings from local buffer
  call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer
"  call Decho(" g:netrw_fastbrowse  =".g:netrw_fastbrowse,'~'.expand("<slnum>"))
"  call Decho(" s:netrwmftgt        =".s:netrwmftgt,'~'.expand("<slnum>"))
"  call Decho(" s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
"  call Decho(" curdir              =".curdir,'~'.expand("<slnum>"))
"  call Decho(" a:islocal           =".a:islocal,'~'.expand("<slnum>"))
"  call Decho(" curbufnr            =".curbufnr,'~'.expand("<slnum>"))
  if exists("s:recursive")
"   call Decho(" s:recursive         =".s:recursive,'~'.expand("<slnum>"))
  else
"   call Decho(" s:recursive         =n/a",'~'.expand("<slnum>"))
  endif
  " see s:LocalFastBrowser() for g:netrw_fastbrowse interpretation (refreshing done for both slow and medium)
  if g:netrw_fastbrowse <= 1
   NetrwKeepj call s:LocalBrowseRefresh()
  else
   " refresh local and targets for fast browsing
   if !exists("s:recursive")
    " remove markings from local buffer
"    call Decho(" remove markings from local buffer",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwUnmarkList(curbufnr,curdir)
   endif

   " refresh buffers
   if s:netrwmftgt_islocal
"    call Decho(" refresh s:netrwmftgt=".s:netrwmftgt,'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
   endif
   if a:islocal && s:netrwmftgt != curdir
"    call Decho(" refresh curdir=".curdir,'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshDir(a:islocal,curdir)
   endif
  endif

"  call Dret("s:NetrwMarkFileCopy 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileDiff: (invoked by md) This function is used to {{{2
"                      invoke vim's diff mode on the marked files.
"                      Either two or three files can be so handled.
"                      Uses the global marked file list.
fun! s:NetrwMarkFileDiff(islocal)
"  call Dfunc("s:NetrwMarkFileDiff(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileDiff")
   return
  endif
  let curdir= s:NetrwGetCurdir(a:islocal)
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{".curbufnr."}")
   let cnt    = 0
   for fname in s:netrwmarkfilelist
    let cnt= cnt + 1
    if cnt == 1
"     call Decho("diffthis: fname<".fname.">",'~'.expand("<slnum>"))
     exe "NetrwKeepj e ".fnameescape(fname)
     diffthis
    elseif cnt == 2 || cnt == 3
     vsplit
     wincmd l
"     call Decho("diffthis: ".fname,'~'.expand("<slnum>"))
     exe "NetrwKeepj e ".fnameescape(fname)
     diffthis
    else
     break
    endif
   endfor
   call s:NetrwUnmarkList(curbufnr,curdir)
  endif

"  call Dret("s:NetrwMarkFileDiff")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileEdit: (invoked by me) put marked files on arg list and start editing them {{{2
"                       Uses global markfilelist
fun! s:NetrwMarkFileEdit(islocal)
"  call Dfunc("s:NetrwMarkFileEdit(islocal=".a:islocal.")")

  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileEdit")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   call s:SetRexDir(a:islocal,curdir)
   let flist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   " unmark markedfile list
"   call s:NetrwUnmarkList(curbufnr,curdir)
   call s:NetrwUnmarkAll()
"   call Decho("exe sil args ".flist,'~'.expand("<slnum>"))
   exe "sil args ".flist
  endif
  echo "(use :bn, :bp to navigate files; :Rex to return)"

"  call Dret("s:NetrwMarkFileEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileQFEL: convert a quickfix-error or location list into a marked file list {{{2
fun! s:NetrwMarkFileQFEL(islocal,qfel)
"  call Dfunc("s:NetrwMarkFileQFEL(islocal=".a:islocal.",qfel)")
  call s:NetrwUnmarkAll()
  let curbufnr= bufnr("%")

  if !empty(a:qfel)
   for entry in a:qfel
    let bufnmbr= entry["bufnr"]
"    call Decho("bufname(".bufnmbr.")<".bufname(bufnmbr)."> line#".entry["lnum"]." text=".entry["text"],'~'.expand("<slnum>"))
    if !exists("s:netrwmarkfilelist_{curbufnr}")
"     call Decho("case: no marked file list",'~'.expand("<slnum>"))
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    elseif index(s:netrwmarkfilelist_{curbufnr},bufname(bufnmbr)) == -1
     " s:NetrwMarkFile will remove duplicate entries from the marked file list.
     " So, this test lets two or more hits on the same pattern to be ignored.
"     call Decho("case: ".bufname(bufnmbr)." not currently in marked file list",'~'.expand("<slnum>"))
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    else
"     call Decho("case: ".bufname(bufnmbr)." already in marked file list",'~'.expand("<slnum>"))
    endif
   endfor
   echo "(use me to edit marked files)"
  else
   call netrw#ErrorMsg(s:WARNING,"can't convert quickfix error list; its empty!",92)
  endif

"  call Dret("s:NetrwMarkFileQFEL")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileExe: (invoked by mx and mX) execute arbitrary system command on marked files {{{2
"                     mx enbloc=0: Uses the local marked-file list, applies command to each file individually
"                     mX enbloc=1: Uses the global marked-file list, applies command to entire list
fun! s:NetrwMarkFileExe(islocal,enbloc)
"  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.",enbloc=".a:enbloc.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  if a:enbloc == 0
   " individually apply command to files, one at a time
    " sanity check
    if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
     NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"     call Dret("s:NetrwMarkFileExe")
     return
    endif
"    call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

    if exists("s:netrwmarkfilelist_{curbufnr}")
     " get the command
     call inputsave()
     let cmd= input("Enter command: ","","file")
     call inputrestore()
"     call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
     if cmd == ""
"      call Dret("s:NetrwMarkFileExe : early exit, empty command")
      return
     endif

     " apply command to marked files, individually.  Substitute: filename -> %
     " If no %, then append a space and the filename to the command
     for fname in s:netrwmarkfilelist_{curbufnr}
      if a:islocal
       if g:netrw_keepdir
	let fname= s:ShellEscape(netrw#WinPath(s:ComposePath(curdir,fname)))
       endif
      else
       let fname= s:ShellEscape(netrw#WinPath(b:netrw_curdir.fname))
      endif
      if cmd =~ '%'
       let xcmd= substitute(cmd,'%',fname,'g')
      else
       let xcmd= cmd.' '.fname
      endif
      if a:islocal
"       call Decho("local: xcmd<".xcmd.">",'~'.expand("<slnum>"))
       let ret= system(xcmd)
      else
"       call Decho("remote: xcmd<".xcmd.">",'~'.expand("<slnum>"))
       let ret= s:RemoteSystem(xcmd)
      endif
      if v:shell_error < 0
       NetrwKeepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
       break
      else
       echo ret
      endif
     endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

 else " apply command to global list of files, en bloc

  call inputsave()
  let cmd= input("Enter command: ","","file")
  call inputrestore()
"  call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
  if cmd == ""
"   call Dret("s:NetrwMarkFileExe : early exit, empty command")
   return
  endif
  if cmd =~ '%'
   let cmd= substitute(cmd,'%',join(map(s:netrwmarkfilelist,'s:ShellEscape(v:val)'),' '),'g')
  else
   let cmd= cmd.' '.join(map(s:netrwmarkfilelist,'s:ShellEscape(v:val)'),' ')
  endif
  if a:islocal
   call system(cmd)
   if v:shell_error < 0
    NetrwKeepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
   endif
  else
   let ret= s:RemoteSystem(cmd)
  endif
  call s:NetrwUnmarkAll()

  " refresh the listing
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

 endif

"  call Dret("s:NetrwMarkFileExe")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">",'~'.expand("<slnum>"))
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">",'~'.expand("<slnum>"))
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileVimCmd: (invoked by mv) execute arbitrary vim command on marked files, one at a time {{{2
"                     Uses the local marked-file list.
fun! s:NetrwMarkFileVimCmd(islocal)
"  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileVimCmd")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " get the command
   call inputsave()
   let cmd= input("Enter vim command: ","","file")
   call inputrestore()
"   call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
   if cmd == ""
"    "   call Dret("s:NetrwMarkFileVimCmd : early exit, empty command")
    return
   endif

   " apply command to marked files.  Substitute: filename -> %
   " If no %, then append a space and the filename to the command
   for fname in s:netrwmarkfilelist_{curbufnr}
"    call Decho("fname<".fname.">",'~'.expand("<slnum>"))
    if a:islocal
     1split
     exe "sil! NetrwKeepj keepalt e ".fnameescape(fname)
"     call Decho("local<".fname.">: exe ".cmd,'~'.expand("<slnum>"))
     exe cmd
     exe "sil! keepalt wq!"
    else
"     call Decho("remote<".fname.">: exe ".cmd." : NOT SUPPORTED YET",'~'.expand("<slnum>"))
     echo "sorry, \"mv\" not supported yet for remote files"
    endif
   endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkFileVimCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">",'~'.expand("<slnum>"))
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">",'~'.expand("<slnum>"))
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileGrep: (invoked by mg) This function applies vimgrep to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileGrep(islocal)
"  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")
  let curdir   = s:NetrwGetCurdir(a:islocal)

  if exists("s:netrwmarkfilelist")
"  call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   call s:NetrwUnmarkAll()
  else
"   call Decho('no marked files, using "*"','~'.expand("<slnum>"))
   let netrwmarkfilelist= "*"
  endif

  " ask user for pattern
  call inputsave()
  let pat= input("Enter pattern: ","")
  call inputrestore()
  let patbang = ""
  if pat =~ '^!'
   let patbang = "!"
   let pat     = strpart(pat,2)
  endif
  if pat =~ '^\i'
   let pat    = escape(pat,'/')
   let pat    = '/'.pat.'/'
  else
   let nonisi = pat[0]
  endif

  " use vimgrep for both local and remote
"  call Decho("exe vimgrep".patbang." ".pat." ".netrwmarkfilelist,'~'.expand("<slnum>"))
  try
   exe "NetrwKeepj noautocmd vimgrep".patbang." ".pat." ".netrwmarkfilelist
  catch /^Vim\%((\a\+)\)\=:E480/
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pat.">",76)
"   call Dret("s:NetrwMarkFileGrep : unable to find pattern<".pat.">")
   return
  endtry
  echo "(use :cn, :cp to navigate, :Rex to return)"

  2match none
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

  if exists("nonisi")
   " original, user-supplied pattern did not begin with a character from isident
"   call Decho("looking for trailing nonisi<".nonisi."> followed by a j, gj, or jg",'~'.expand("<slnum>"))
   if pat =~# nonisi.'j$\|'.nonisi.'gj$\|'.nonisi.'jg$'
    call s:NetrwMarkFileQFEL(a:islocal,getqflist())
   endif
  endif

"  call Dret("s:NetrwMarkFileGrep")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileMove: (invoked by mm) execute arbitrary command on marked files, one at a time {{{2
"                      uses the global marked file list
"                      s:netrwmfloc= 0: target directory is remote
"                                  = 1: target directory is local
fun! s:NetrwMarkFileMove(islocal)
"  call Dfunc("s:NetrwMarkFileMove(islocal=".a:islocal.")")
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileMove")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if !exists("s:netrwmftgt")
   NetrwKeepj call netrw#ErrorMsg(2,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))

  if      a:islocal &&  s:netrwmftgt_islocal
   " move: local -> local
"   call Decho("move from local to local",'~'.expand("<slnum>"))
"   call Decho("local to local move",'~'.expand("<slnum>"))
   if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
    return
   endif
   let tgt         = s:ShellEscape(s:netrwmftgt)
"   call Decho("tgt<".tgt.">",'~'.expand("<slnum>"))
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let tgt         = substitute(tgt, '/','\\','g')
"    call Decho("windows exception: tgt<".tgt.">",'~'.expand("<slnum>"))
    if g:netrw_localmovecmd =~ '\s'
     let movecmd     = substitute(g:netrw_localmovecmd,'\s.*$','','')
     let movecmdargs = substitute(g:netrw_localmovecmd,'^.\{-}\(\s.*\)$','\1','')
     let movecmd     = netrw#WinPath(movecmd).movecmdargs
"     call Decho("windows exception: movecmd<".movecmd."> (#1: had a space)",'~'.expand("<slnum>"))
    else
     let movecmd = netrw#WinPath(movecmd)
"     call Decho("windows exception: movecmd<".movecmd."> (#2: no space)",'~'.expand("<slnum>"))
    endif
   else
    let movecmd = netrw#WinPath(g:netrw_localmovecmd)
"    call Decho("movecmd<".movecmd."> (#3 linux or cygwin)",'~'.expand("<slnum>"))
   endif
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
     let fname= substitute(fname,'/','\\','g')
    endif
"    call Decho("system(".movecmd." ".s:ShellEscape(fname)." ".tgt.")",'~'.expand("<slnum>"))
    let ret= system(movecmd." ".s:ShellEscape(fname)." ".tgt)
    if v:shell_error != 0
     if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
      call netrw#ErrorMsg(s:ERROR,"move failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",100)
     else
      call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localmovecmd<".g:netrw_localmovecmd.">; it doesn't work!",54)
     endif
     break
    endif
   endfor

  elseif  a:islocal && !s:netrwmftgt_islocal
   " move: local -> remote
"   call Decho("move from local to remote",'~'.expand("<slnum>"))
"   call Decho("copy",'~'.expand("<slnum>"))
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove",'~'.expand("<slnum>"))
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwLocalRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " move: remote -> local
"   call Decho("move from remote to local",'~'.expand("<slnum>"))
"   call Decho("copy",'~'.expand("<slnum>"))
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove",'~'.expand("<slnum>"))
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal && !s:netrwmftgt_islocal
   " move: remote -> remote
"   call Decho("move from remote to remote",'~'.expand("<slnum>"))
"   call Decho("copy",'~'.expand("<slnum>"))
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove",'~'.expand("<slnum>"))
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist
  endif

  " -------
  " cleanup
  " -------
"  call Decho("cleanup",'~'.expand("<slnum>"))

  " remove markings from local buffer
  call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer

  " refresh buffers
  if !s:netrwmftgt_islocal
"   call Decho("refresh netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
  endif
  if a:islocal
"   call Decho("refresh b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwRefreshDir(a:islocal,b:netrw_curdir)
  endif
  if g:netrw_fastbrowse <= 1
"   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh",'~'.expand("<slnum>"))
   NetrwKeepj call s:LocalBrowseRefresh()
  endif

"  call Dret("s:NetrwMarkFileMove")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFilePrint: (invoked by mp) This function prints marked files {{{2
"                       using the hardcopy command.  Local marked-file list only.
fun! s:NetrwMarkFilePrint(islocal)
"  call Dfunc("s:NetrwMarkFilePrint(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFilePrint")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
  let curdir= s:NetrwGetCurdir(a:islocal)

  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{curbufnr}
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    1split
    " the autocmds will handle both local and remote files
"    call Decho("exe sil e ".escape(fname,' '),'~'.expand("<slnum>"))
    exe "sil NetrwKeepj e ".fnameescape(fname)
"    call Decho("hardcopy",'~'.expand("<slnum>"))
    hardcopy
    q
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFilePrint")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileRegexp: (invoked by mr) This function is used to mark {{{2
"                        files when given a regexp (for which a prompt is
"                        issued) (matches to name of files).
fun! s:NetrwMarkFileRegexp(islocal)
"  call Dfunc("s:NetrwMarkFileRegexp(islocal=".a:islocal.")")

  " get the regular expression
  call inputsave()
  let regexp= input("Enter regexp: ","","file")
  call inputrestore()

  if a:islocal
   let curdir= s:NetrwGetCurdir(a:islocal)
   " get the matching list of files using local glob()
"   call Decho("handle local regexp",'~'.expand("<slnum>"))
   let dirname = escape(b:netrw_curdir,g:netrw_glob_escape)
   if v:version > 704 || (v:version == 704 && has("patch656"))
    let files   = glob(s:ComposePath(dirname,regexp),0,0,1)
   else
    let files   = glob(s:ComposePath(dirname,regexp),0,0)
   endif
"   call Decho("files<".files.">",'~'.expand("<slnum>"))
   let filelist= split(files,"\n")

  " mark the list of files
  for fname in filelist
"   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwMarkFile(a:islocal,substitute(fname,'^.*/','',''))
  endfor

  else
"   call Decho("handle remote regexp",'~'.expand("<slnum>"))

   " convert displayed listing into a filelist
   let eikeep = &ei
   let areg   = @a
   sil NetrwKeepj %y a
   setl ei=all ma
"   call Decho("setl ei=all ma",'~'.expand("<slnum>"))
   1split
   NetrwKeepj call s:NetrwEnew()
   NetrwKeepj call s:NetrwSafeOptions()
   sil NetrwKeepj norm! "ap
   NetrwKeepj 2
   let bannercnt= search('^" =====','W')
   exe "sil NetrwKeepj 1,".bannercnt."d"
   setl bt=nofile
   if     g:netrw_liststyle == s:LONGLIST
    sil NetrwKeepj %s/\s\{2,}\S.*$//e
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:WIDELIST
    sil NetrwKeepj %s/\s\{2,}/\r/ge
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:TREELIST
    exe 'sil NetrwKeepj %s/^'.s:treedepthstring.' //e'
    sil! NetrwKeepj g/^ .*$/d
    call histdel("/",-1)
    call histdel("/",-1)
   endif
   " convert regexp into the more usual glob-style format
   let regexp= substitute(regexp,'\*','.*','g')
"   call Decho("regexp<".regexp.">",'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj v/".escape(regexp,'/')."/d"
   call histdel("/",-1)
   let filelist= getline(1,line("$"))
   q!
   for filename in filelist
    NetrwKeepj call s:NetrwMarkFile(a:islocal,substitute(filename,'^.*/','',''))
   endfor
   unlet filelist
   let @a  = areg
   let &ei = eikeep
  endif
  echo "  (use me to edit marked files)"

"  call Dret("s:NetrwMarkFileRegexp")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileSource: (invoked by ms) This function sources marked files {{{2
"                        Uses the local marked file list.
fun! s:NetrwMarkFileSource(islocal)
"  call Dfunc("s:NetrwMarkFileSource(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileSource")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
  let curdir= s:NetrwGetCurdir(a:islocal)

  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{bufnr("%")}
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    " the autocmds will handle sourcing both local and remote files
"    call Decho("exe so ".fnameescape(fname),'~'.expand("<slnum>"))
    exe "so ".fnameescape(fname)
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFileSource")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTag: (invoked by mT) This function applies g:netrw_ctags to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileTag(islocal)
"  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir   = s:NetrwGetCurdir(a:islocal)
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileTag")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist")
"   call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "s:ShellEscape(v:val,".!a:islocal.")"))
   call s:NetrwUnmarkAll()

   if a:islocal
    if executable(g:netrw_ctags)
"     call Decho("call system(".g:netrw_ctags." ".netrwmarkfilelist.")",'~'.expand("<slnum>"))
     call system(g:netrw_ctags." ".netrwmarkfilelist)
    else
     call netrw#ErrorMsg(s:ERROR,"g:netrw_ctags<".g:netrw_ctags."> is not executable!",51)
    endif
   else
    let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
    call netrw#Obtain(a:islocal,"tags")
    let curdir= b:netrw_curdir
    1split
    NetrwKeepj e tags
    let path= substitute(curdir,'^\(.*\)/[^/]*$','\1/','')
"    call Decho("curdir<".curdir."> path<".path.">",'~'.expand("<slnum>"))
    exe 'NetrwKeepj %s/\t\(\S\+\)\t/\t'.escape(path,"/\n\r\\").'\1\t/e'
    call histdel("/",-1)
    wq!
   endif
   2match none
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   call winrestview(svpos)
  endif

"  call Dret("s:NetrwMarkFileTag")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTgt:  (invoked by mt) This function sets up a marked file target {{{2
"   Sets up two variables,
"     s:netrwmftgt         : holds the target directory
"     s:netrwmftgt_islocal : 0=target directory is remote
"                            1=target directory is local
fun! s:NetrwMarkFileTgt(islocal)
" call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
  let svpos  = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curdir = s:NetrwGetCurdir(a:islocal)
  let hadtgt = exists("s:netrwmftgt")
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= b:netrw_bannercnt
  endif

  " set up target
  if line(".") < w:netrw_bannercnt
"   call Decho("set up target: line(.) < w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
   " if cursor in banner region, use b:netrw_curdir for the target unless its already the target
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal") && s:netrwmftgt == b:netrw_curdir
"    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target",'~'.expand("<slnum>"))
    unlet s:netrwmftgt s:netrwmftgt_islocal
    if g:netrw_fastbrowse <= 1
     call s:LocalBrowseRefresh()
    endif
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    call winrestview(svpos)
"    call Dret("s:NetrwMarkFileTgt : removed target")
    return
   else
    let s:netrwmftgt= b:netrw_curdir
"    call Decho("inbanner: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   endif

  else
   " get word under cursor.
   "  * If directory, use it for the target.
   "  * If file, use b:netrw_curdir for the target
"   call Decho("get word under cursor",'~'.expand("<slnum>"))
   let curword= s:NetrwGetWord()
   let tgtdir = s:ComposePath(curdir,curword)
   if a:islocal && isdirectory(s:NetrwFile(tgtdir))
    let s:netrwmftgt = tgtdir
"    call Decho("local isdir: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   elseif !a:islocal && tgtdir =~ '/$'
    let s:netrwmftgt = tgtdir
"    call Decho("remote isdir: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   else
    let s:netrwmftgt = curdir
"    call Decho("isfile: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
   endif
  endif
  if a:islocal
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
   let s:netrwmftgt= simplify(s:netrwmftgt)
"   call Decho("simplify: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
  endif
  if g:netrw_cygwin
   let s:netrwmftgt= substitute(system("cygpath ".s:ShellEscape(s:netrwmftgt)),'\n$','','')
   let s:netrwmftgt= substitute(s:netrwmftgt,'\n$','','')
  endif
  let s:netrwmftgt_islocal= a:islocal

  " need to do refresh so that the banner will be updated
  "  s:LocalBrowseRefresh handles all local-browsing buffers when not fast browsing
  if g:netrw_fastbrowse <= 1
"   call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse.", so refreshing all local netrw buffers",'~'.expand("<slnum>"))
   call s:LocalBrowseRefresh()
  endif
"  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,w:netrw_treetop))
  else
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  endif
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)
  if !hadtgt
   sil! NetrwKeepj norm! j
  endif

"  call Decho("getmatches=".string(getmatches()),'~'.expand("<slnum>"))
"  call Decho("s:netrwmarkfilelist=".(exists("s:netrwmarkfilelist")? string(s:netrwmarkfilelist) : 'n/a'),'~'.expand("<slnum>"))
"  call Dret("s:NetrwMarkFileTgt : netrwmftgt<".(exists("s:netrwmftgt")? s:netrwmftgt : "").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwGetCurdir: gets current directory and sets up b:netrw_curdir if necessary {{{2
fun! s:NetrwGetCurdir(islocal)
"  call Dfunc("s:NetrwGetCurdir(islocal=".a:islocal.")")

  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
   let b:netrw_curdir = s:NetrwTreePath(w:netrw_treetop)
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used s:NetrwTreeDir)",'~'.expand("<slnum>"))
  elseif !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)",'~'.expand("<slnum>"))
  endif

"  call Decho("b:netrw_curdir<".b:netrw_curdir."> ".((b:netrw_curdir !~ '\<\a\{3,}://')? "does not match" : "matches")." url pattern",'~'.expand("<slnum>"))
  if b:netrw_curdir !~ '\<\a\{3,}://'
   let curdir= b:netrw_curdir
"   call Decho("g:netrw_keepdir=".g:netrw_keepdir,'~'.expand("<slnum>"))
   if g:netrw_keepdir == 0
    call s:NetrwLcd(curdir)
   endif
  endif

"  call Dret("s:NetrwGetCurdir <".curdir.">")
  return b:netrw_curdir
endfun

" ---------------------------------------------------------------------
" s:NetrwOpenFile: query user for a filename and open it {{{2
fun! s:NetrwOpenFile(islocal)
"  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
  let ykeep= @@
  call inputsave()
  let fname= input("Enter filename: ")
  call inputrestore()
  if fname !~ '[/\\]'
   if exists("b:netrw_curdir")
    if exists("g:netrw_quiet")
     let netrw_quiet_keep = g:netrw_quiet
    endif
    let g:netrw_quiet = 1
    " save position for benefit of Rexplore
    let s:rexposn_{bufnr("%")}= winsaveview()
"    call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
    if b:netrw_curdir =~ '/$'
     exe "NetrwKeepj e ".fnameescape(b:netrw_curdir.fname)
    else
     exe "e ".fnameescape(b:netrw_curdir."/".fname)
    endif
    if exists("netrw_quiet_keep")
     let g:netrw_quiet= netrw_quiet_keep
    else
     unlet g:netrw_quiet
    endif
   endif
  else
   exe "NetrwKeepj e ".fnameescape(fname)
  endif
  let @@= ykeep
"  call Dret("s:NetrwOpenFile")
endfun

" ---------------------------------------------------------------------
" netrw#Shrink: shrinks/expands a netrw or Lexplorer window {{{2
"               For the mapping to this function be made via
"               netrwPlugin, you'll need to have had
"               g:netrw_usetab set to non-zero.
fun! netrw#Shrink()
"  call Dfunc("netrw#Shrink() ft<".&ft."> winwidth=".winwidth(0)." lexbuf#".((exists("t:netrw_lexbufnr"))? t:netrw_lexbufnr : 'n/a'))
  let curwin  = winnr()
  let wiwkeep = &wiw
  set wiw=1

  if &ft == "netrw"
   if winwidth(0) > g:netrw_wiw
    let t:netrw_winwidth= winwidth(0)
    exe "vert resize ".g:netrw_wiw
    wincmd l
    if winnr() == curwin
     wincmd h
    endif
"    call Decho("vert resize 0",'~'.expand("<slnum>"))
   else
    exe "vert resize ".t:netrw_winwidth
"    call Decho("vert resize ".t:netrw_winwidth,'~'.expand("<slnum>"))
   endif

  elseif exists("t:netrw_lexbufnr")
   exe bufwinnr(t:netrw_lexbufnr)."wincmd w"
   if     winwidth(bufwinnr(t:netrw_lexbufnr)) >  g:netrw_wiw
    let t:netrw_winwidth= winwidth(0)
    exe "vert resize ".g:netrw_wiw
    wincmd l
    if winnr() == curwin
     wincmd h
    endif
"    call Decho("vert resize 0",'~'.expand("<slnum>"))
   elseif winwidth(bufwinnr(t:netrw_lexbufnr)) >= 0
    exe "vert resize ".t:netrw_winwidth
"    call Decho("vert resize ".t:netrw_winwidth,'~'.expand("<slnum>"))
   else 
    call netrw#Lexplore(0,0)
   endif

  else
   call netrw#Lexplore(0,0)
  endif
  let wiw= wiwkeep

"  call Dret("netrw#Shrink")
endfun

" ---------------------------------------------------------------------
" s:NetSortSequence: allows user to edit the sorting sequence {{{2
fun! s:NetSortSequence(islocal)
"  call Dfunc("NetSortSequence(islocal=".a:islocal.")")

  let ykeep= @@
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call inputsave()
  let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
  call inputrestore()

  " refresh the listing
  let g:netrw_sort_sequence= newsortseq
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetSortSequence")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkList: delete local marked file list and remove their contents from the global marked-file list {{{2
"   User access provided by the <mF> mapping. (see :help netrw-mF)
"   Used by many MarkFile functions.
fun! s:NetrwUnmarkList(curbufnr,curdir)
"  call Dfunc("s:NetrwUnmarkList(curbufnr=".a:curbufnr." curdir<".a:curdir.">)")

  "  remove all files in local marked-file list from global list
  if exists("s:netrwmarkfilelist")
   for mfile in s:netrwmarkfilelist_{a:curbufnr}
    let dfile = s:ComposePath(a:curdir,mfile)       " prepend directory to mfile
    let idx   = index(s:netrwmarkfilelist,dfile)    " get index in list of dfile
    call remove(s:netrwmarkfilelist,idx)            " remove from global list
   endfor
   if s:netrwmarkfilelist == []
    unlet s:netrwmarkfilelist
   endif

   " getting rid of the local marked-file lists is easy
   unlet s:netrwmarkfilelist_{a:curbufnr}
  endif
  if exists("s:netrwmarkfilemtch_{a:curbufnr}")
   unlet s:netrwmarkfilemtch_{a:curbufnr}
  endif
  2match none
"  call Dret("s:NetrwUnmarkList")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll: remove the global marked file list and all local ones {{{2
fun! s:NetrwUnmarkAll()
"  call Dfunc("s:NetrwUnmarkAll()")
  if exists("s:netrwmarkfilelist")
   unlet s:netrwmarkfilelist
  endif
  sil call s:NetrwUnmarkAll2()
  2match none
"  call Dret("s:NetrwUnmarkAll")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll2: unmark all files from all buffers {{{2
fun! s:NetrwUnmarkAll2()
"  call Dfunc("s:NetrwUnmarkAll2()")
  redir => netrwmarkfilelist_let
  let
  redir END
  let netrwmarkfilelist_list= split(netrwmarkfilelist_let,'\n')          " convert let string into a let list
  call filter(netrwmarkfilelist_list,"v:val =~ '^s:netrwmarkfilelist_'") " retain only those vars that start as s:netrwmarkfilelist_
  call map(netrwmarkfilelist_list,"substitute(v:val,'\\s.*$','','')")    " remove what the entries are equal to
  for flist in netrwmarkfilelist_list
   let curbufnr= substitute(flist,'s:netrwmarkfilelist_','','')
   unlet s:netrwmarkfilelist_{curbufnr}
   unlet s:netrwmarkfilemtch_{curbufnr}
  endfor
"  call Dret("s:NetrwUnmarkAll2")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnMarkFile: called via mu map; unmarks *all* marked files, both global and buffer-local {{{2
"
" Marked files are in two types of lists:
"    s:netrwmarkfilelist    -- holds complete paths to all marked files
"    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
"
" Marked files suitable for use with 2match are in:
"    s:netrwmarkfilemtch_#   -- used with 2match to display marked files
fun! s:NetrwUnMarkFile(islocal)
"  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let curbufnr = bufnr("%")

  " unmark marked file list
  " (although I expect s:NetrwUpload() to do it, I'm just making sure)
  if exists("s:netrwmarkfilelist")
"   "   call Decho("unlet'ing: s:netrwmarkfilelist",'~'.expand("<slnum>"))
   unlet s:netrwmarkfilelist
  endif

  let ibuf= 1
  while ibuf < bufnr("$")
   if exists("s:netrwmarkfilelist_".ibuf)
    unlet s:netrwmarkfilelist_{ibuf}
    unlet s:netrwmarkfilemtch_{ibuf}
   endif
   let ibuf = ibuf + 1
  endwhile
  2match none

"  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
call winrestview(svpos)
"  call Dret("s:NetrwUnMarkFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwMenu: generates the menu for gvim and netrw {{{2
fun! s:NetrwMenu(domenu)

  if !exists("g:NetrwMenuPriority")
   let g:NetrwMenuPriority= 80
  endif

  if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
"   call Dfunc("NetrwMenu(domenu=".a:domenu.")")

   if !exists("s:netrw_menu_enabled") && a:domenu
"    call Decho("initialize menu",'~'.expand("<slnum>"))
    let s:netrw_menu_enabled= 1
    exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
    exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
    exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
    if g:netrw_dirhistmax > 0
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
    else
     exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
    endif
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Tab<tab>t	t'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
    exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Exten<tab>s      :let g:netrw_sort_by="exten"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
    let s:netrw_menucnt= 28
    call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
    call s:NetrwTgtMenu()      " let bookmarks and history be easy targets

   elseif !a:domenu
    let s:netrwcnt = 0
    let curwin     = winnr()
    windo if getline(2) =~# "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
    exe curwin."wincmd w"

    if s:netrwcnt <= 1
"     call Decho("clear menus",'~'.expand("<slnum>"))
     exe 'sil! unmenu '.g:NetrwTopLvlMenu
"     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*','~'.expand("<slnum>"))
     sil! unlet s:netrw_menu_enabled
    endif
   endif
"   call Dret("NetrwMenu")
   return
  endif

endfun

" ---------------------------------------------------------------------
" s:NetrwObtain: obtain file under cursor or from markfile list {{{2
"                Used by the O maps (as <SID>NetrwObtain())
fun! s:NetrwObtain(islocal)
"  call Dfunc("NetrwObtain(islocal=".a:islocal.")")

  let ykeep= @@
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\{3,}://'
   call netrw#Obtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
   call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
  else
   call netrw#Obtain(a:islocal,expand("<cWORD>"))
  endif
  let @@= ykeep

"  call Dret("NetrwObtain")
endfun

" ---------------------------------------------------------------------
" s:NetrwPrevWinOpen: open file/directory in previous window.  {{{2
"   If there's only one window, then the window will first be split.
"   Returns:
"     choice = 0 : didn't have to choose
"     choice = 1 : saved modified file in window first
"     choice = 2 : didn't save modified file, opened window
"     choice = 3 : cancel open
fun! s:NetrwPrevWinOpen(islocal)
"  call Dfunc("s:NetrwPrevWinOpen(islocal=".a:islocal.")")

  let ykeep= @@
  " grab a copy of the b:netrw_curdir to pass it along to newly split windows
  let curdir = b:netrw_curdir

  " get last window number and the word currently under the cursor
  let origwin   = winnr()
  let lastwinnr = winnr("$")
  let curword   = s:NetrwGetWord()
  let choice    = 0
  let s:treedir = s:NetrwTreeDir(a:islocal)
  let curdir    = s:treedir
"  call Decho("winnr($)#".lastwinnr." curword<".curword.">",'~'.expand("<slnum>"))

  let didsplit = 0
  if lastwinnr == 1
   " if only one window, open a new one first
"   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")",'~'.expand("<slnum>"))
   if g:netrw_preview
    " vertically split preview window
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s",'~'.expand("<slnum>"))
    exe (g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
   else
    " horizontally split preview window
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
    exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   endif
   let didsplit = 1
"   call Decho("did split",'~'.expand("<slnum>"))

  else
   NetrwKeepj call s:SaveBufVars()
   let eikeep= &ei
   setl ei=all
   wincmd p
"   call Decho("wincmd p  (now in win#".winnr().") curdir<".curdir.">",'~'.expand("<slnum>"))

   " prevwinnr: the window number of the "prev" window
   " prevbufnr: the buffer number of the buffer in the "prev" window
   " bnrcnt   : the qty of windows open on the "prev" buffer
   let prevwinnr   = winnr()
   let prevbufnr   = bufnr("%")
   let prevbufname = bufname("%")
   let prevmod     = &mod
   let bnrcnt      = 0
   NetrwKeepj call s:RestoreBufVars()
"   call Decho("after wincmd p: win#".winnr()." win($)#".winnr("$")." origwin#".origwin." &mod=".&mod." bufname(%)<".bufname("%")."> prevbufnr=".prevbufnr,'~'.expand("<slnum>"))

   " if the previous window's buffer has been changed (ie. its modified flag is set),
   " and it doesn't appear in any other extant window, then ask the
   " user if s/he wants to abandon modifications therein.
   if prevmod
"    call Decho("detected that prev window's buffer has been modified: prevbufnr=".prevbufnr." winnr()#".winnr(),'~'.expand("<slnum>"))
    windo if winbufnr(0) == prevbufnr | let bnrcnt=bnrcnt+1 | endif
"    call Decho("prevbufnr=".prevbufnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr()=".winnr()." prevwinnr#".prevwinnr,'~'.expand("<slnum>"))
    exe prevwinnr."wincmd w"

    if bnrcnt == 1 && &hidden == 0
     " only one copy of the modified buffer in a window, and
     " hidden not set, so overwriting will lose the modified file.  Ask first...
     let choice = confirm("Save modified buffer<".prevbufname."> first?","&Yes\n&No\n&Cancel")
"     call Decho("(NetrwPrevWinOpen) prevbufname<".prevbufname."> choice=".choice." current-winnr#".winnr(),'~'.expand("<slnum>"))
     let &ei= eikeep

     if choice == 1
      " Yes -- write file & then browse
      let v:errmsg= ""
      sil w
      if v:errmsg != ""
       call netrw#ErrorMsg(s:ERROR,"unable to write <".(exists("prevbufname")? prevbufname : 'n/a').">!",30)
       exe origwin."wincmd w"
       let &ei = eikeep
       let @@  = ykeep
"       call Dret("s:NetrwPrevWinOpen ".choice." : unable to write <".prevbufname.">")
       return choice
      endif

     elseif choice == 2
      " No -- don't worry about changed file, just browse anyway
"      call Decho("don't worry about chgd file, just browse anyway (winnr($)#".winnr("$").")",'~'.expand("<slnum>"))
      echomsg "**note** changes to ".prevbufname." abandoned"

     else
      " Cancel -- don't do this
"      call Decho("cancel, don't browse, switch to win#".origwin,'~'.expand("<slnum>"))
      exe origwin."wincmd w"
      let &ei= eikeep
      let @@ = ykeep
"      call Dret("s:NetrwPrevWinOpen ".choice." : cancelled")
      return choice
     endif
    endif
   endif
   let &ei= eikeep
  endif

  " restore b:netrw_curdir (window split/enew may have lost it)
  let b:netrw_curdir= curdir
  if a:islocal < 2
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(a:islocal,curword))
   else
    call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,curword))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwPrevWinOpen ".choice)
  return choice
endfun

" ---------------------------------------------------------------------
" s:NetrwUpload: load fname to tgt (used by NetrwMarkFileCopy()) {{{2
"                Always assumed to be local -> remote
"                call s:NetrwUpload(filename, target)
"                call s:NetrwUpload(filename, target, fromdirectory)
fun! s:NetrwUpload(fname,tgt,...)
"  call Dfunc("s:NetrwUpload(fname<".((type(a:fname) == 1)? a:fname : string(a:fname))."> tgt<".a:tgt.">) a:0=".a:0)

  if a:tgt =~ '^\a\{3,}://'
   let tgtdir= substitute(a:tgt,'^\a\{3,}://[^/]\+/\(.\{-}\)$','\1','')
  else
   let tgtdir= substitute(a:tgt,'^\(.*\)/[^/]*$','\1','')
  endif
"  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))

  if a:0 > 0
   let fromdir= a:1
  else
   let fromdir= getcwd()
  endif
"  call Decho("fromdir<".fromdir.">",'~'.expand("<slnum>"))

  if type(a:fname) == 1
   " handle uploading a single file using NetWrite
"   call Decho("handle uploading a single file via NetWrite",'~'.expand("<slnum>"))
   1split
"   call Decho("exe e ".fnameescape(s:NetrwFile(a:fname)),'~'.expand("<slnum>"))
   exe "NetrwKeepj e ".fnameescape(s:NetrwFile(a:fname))
"   call Decho("now locally editing<".expand("%").">, has ".line("$")." lines",'~'.expand("<slnum>"))
   if a:tgt =~ '/$'
    let wfname= substitute(a:fname,'^.*/','','')
"    call Decho("exe w! ".fnameescape(wfname),'~'.expand("<slnum>"))
    exe "w! ".fnameescape(a:tgt.wfname)
   else
"    call Decho("writing local->remote: exe w ".fnameescape(a:tgt),'~'.expand("<slnum>"))
    exe "w ".fnameescape(a:tgt)
"    call Decho("done writing local->remote",'~'.expand("<slnum>"))
   endif
   q!

  elseif type(a:fname) == 3
   " handle uploading a list of files via scp
"   call Decho("handle uploading a list of files via scp",'~'.expand("<slnum>"))
   let curdir= getcwd()
   if a:tgt =~ '^scp:'
    call s:NetrwLcd(fromdir)
    let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
    let args    = join(map(filelist,"s:ShellEscape(v:val, 1)"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    let machine = substitute(a:tgt,'^scp://\([^/:]\+\).*$','\1','')
    let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".args." ".s:ShellEscape(machine.":".tgt,1))
    call s:NetrwLcd(curdir)

   elseif a:tgt =~ '^ftp:'
    call s:NetrwMethod(a:tgt)

    if b:netrw_method == 2
     " handle uploading a list of files via ftp+.netrc
     let netrw_fname = b:netrw_fname
     sil NetrwKeepj new
"     call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))

     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     NetrwKeepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     if tgtdir == ""
      let tgtdir= '/'
     endif
     NetrwKeepj call setline(line("$")+1,'cd "'.tgtdir.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     for fname in a:fname
      NetrwKeepj call setline(line("$")+1,'put "'.s:NetrwFile(fname).'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor

     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
"      call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil NetrwKeepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      call netrw#ErrorMsg(s:ERROR,getline(1),14)
     else
      bw!|q
     endif

    elseif b:netrw_method == 3
     " upload with ftp + machine, id, passwd, and fname (ie. no .netrc)
     let netrw_fname= b:netrw_fname
     NetrwKeepj call s:SaveBufVars()|sil NetrwKeepj new|NetrwKeepj call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix

     if exists("g:netrw_port") && g:netrw_port != ""
      NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     else
      NetrwKeepj put ='open '.g:netrw_machine
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_uid") && g:netrw_uid != ""
      if exists("g:netrw_ftp") && g:netrw_ftp == 1
       NetrwKeepj put =g:netrw_uid
"       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
       if exists("s:netrw_passwd")
        NetrwKeepj call setline(line("$")+1,'"'.s:netrw_passwd.'"')
       endif
"       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      elseif exists("s:netrw_passwd")
       NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      endif
     endif

     NetrwKeepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

     if exists("b:netrw_fname") && b:netrw_fname != ""
      NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     for fname in a:fname
      NetrwKeepj call setline(line("$")+1,'put "'.fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor

     " perform ftp:
     " -i       : turns off interactive prompting from ftp
     " -n  unix : DON'T use <.netrc>, even though it exists
     " -n  win32: quit being obnoxious about password
     NetrwKeepj norm! 1Gdd
     call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil NetrwKeepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
      let &debug = debugkeep
      let mod    = 1
     else
      bw!|q
     endif
    elseif !exists("b:netrw_method") || b:netrw_method < 0
"     call Dfunc("netrw#NetrwUpload : unsupported method")
     return
    endif
   else
    call netrw#ErrorMsg(s:ERROR,"can't obtain files with protocol from<".a:tgt.">",63)
   endif
  endif

"  call Dret("s:NetrwUpload")
endfun

" ---------------------------------------------------------------------
" s:NetrwPreview: {{{2
fun! s:NetrwPreview(path) range
"  call Dfunc("NetrwPreview(path<".a:path.">)")
  let ykeep= @@
  NetrwKeepj call s:NetrwOptionSave("s:")
  NetrwKeepj call s:NetrwSafeOptions()
  if has("quickfix")
   if !isdirectory(s:NetrwFile(a:path))
    if g:netrw_preview && !g:netrw_alto
     let pvhkeep = &pvh
     let winsz   = (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
     let &pvh    = winwidth(0) - winsz
    endif
    exe (g:netrw_alto? "top " : "bot ").(g:netrw_preview? "vert " : "")."pedit ".fnameescape(a:path)
    if exists("pvhkeep")
     let &pvh= pvhkeep
    endif
   elseif !exists("g:netrw_quiet")
    NetrwKeepj call netrw#ErrorMsg(s:WARNING,"sorry, cannot preview a directory such as <".a:path.">",38)
   endif
  elseif !exists("g:netrw_quiet")
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"sorry, to preview your vim needs the quickfix feature compiled in",39)
  endif
  NetrwKeepj call s:NetrwOptionRestore("s:")
  let @@= ykeep
"  call Dret("NetrwPreview")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefresh: {{{2
fun! s:NetrwRefresh(islocal,dirname)
"  call Dfunc("s:NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
  " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
  setl ma noro
"  call Decho("setl ma noro",'~'.expand("<slnum>"))
"  call Decho("clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
  let ykeep      = @@

  " save the cursor position before refresh.
  let screenposn = winsaveview()
"  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))

"  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">",'~'.expand("<slnum>"))
"  call Decho("clearing buffer prior to refresh",'~'.expand("<slnum>"))
  sil! NetrwKeepj %d _
  if a:islocal
   NetrwKeepj call netrw#LocalBrowseCheck(a:dirname)
  else
   NetrwKeepj call s:NetrwBrowse(a:islocal,a:dirname)
  endif

  " restore position
"  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(screenposn)

  " restore file marks
  if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  else
"   call Decho("2match none  (bufnr(%)=".bufnr("%")."<".bufname("%").">)",'~'.expand("<slnum>"))
   2match none
  endif

"  restore
  let @@= ykeep
"  call Dret("s:NetrwRefresh")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefreshDir: refreshes a directory by name {{{2
"                    Called by NetrwMarkFileCopy()
"                    Interfaces to s:NetrwRefresh() and s:LocalBrowseRefresh()
fun! s:NetrwRefreshDir(islocal,dirname)
"  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
  if g:netrw_fastbrowse == 0
   " slowest mode (keep buffers refreshed, local or remote)
"   call Decho("slowest mode: keep buffers refreshed, local or remote",'~'.expand("<slnum>"))
   let tgtwin= bufwinnr(a:dirname)
"   call Decho("tgtwin= bufwinnr(".a:dirname.")=".tgtwin,'~'.expand("<slnum>"))

   if tgtwin > 0
    " tgtwin is being displayed, so refresh it
    let curwin= winnr()
"    call Decho("refresh tgtwin#".tgtwin." (curwin#".curwin.")",'~'.expand("<slnum>"))
    exe tgtwin."wincmd w"
    NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
    exe curwin."wincmd w"

   elseif bufnr(a:dirname) > 0
    let bn= bufnr(a:dirname)
"    call Decho("bd bufnr(".a:dirname.")=".bn,'~'.expand("<slnum>"))
    exe "sil keepj bd ".bn
   endif

  elseif g:netrw_fastbrowse <= 1
"   call Decho("medium-speed mode: refresh local buffers only",'~'.expand("<slnum>"))
   NetrwKeepj call s:LocalBrowseRefresh()
  endif
"  call Dret("s:NetrwRefreshDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetChgwin: set g:netrw_chgwin; a <cr> will use the specified
" window number to do its editing in.
" Supports   [count]C  where the count, if present, is used to specify
" a window to use for editing via the <cr> mapping.
fun! s:NetrwSetChgwin(...)
"  call Dfunc("s:NetrwSetChgwin() v:count=".v:count)
  if a:0 > 0
"   call Decho("a:1<".a:1.">",'~'.expand("<slnum>"))
   if a:1 == ""    " :NetrwC win#
    let g:netrw_chgwin= winnr()
   else              " :NetrwC
    let g:netrw_chgwin= a:1
   endif
  elseif v:count > 0 " [count]C
   let g:netrw_chgwin= v:count
  else               " C
   let g:netrw_chgwin= winnr()
  endif
  echo "editing window now set to window#".g:netrw_chgwin
"  call Dret("s:NetrwSetChgwin : g:netrw_chgwin=".g:netrw_chgwin)
endfun

" ---------------------------------------------------------------------
" s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
"          What this function does is to compute a priority for the patterns
"          in the g:netrw_sort_sequence.  It applies a substitute to any
"          "files" that satisfy each pattern, putting the priority / in
"          front.  An "*" pattern handles the default priority.
fun! s:NetrwSetSort()
"  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
  let ykeep= @@
  if w:netrw_liststyle == s:LONGLIST
   let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
  else
   let seqlist  = g:netrw_sort_sequence
  endif
  " sanity check -- insure that * appears somewhere
  if seqlist == ""
   let seqlist= '*'
  elseif seqlist !~ '\*'
   let seqlist= seqlist.',*'
  endif
  let priority = 1
  while seqlist != ""
   if seqlist =~ ','
    let seq     = substitute(seqlist,',.*$','','e')
    let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
   else
    let seq     = seqlist
    let seqlist = ""
   endif
   if priority < 10
    let spriority= "00".priority.g:netrw_sepchr
   elseif priority < 100
    let spriority= "0".priority.g:netrw_sepchr
   else
    let spriority= priority.g:netrw_sepchr
   endif
"   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">",'~'.expand("<slnum>"))

   " sanity check
   if w:netrw_bannercnt > line("$")
    " apparently no files were left after a Hiding pattern was used
"    call Dret("SetSort : no files left after hiding")
    return
   endif
   if seq == '*'
    let starpriority= spriority
   else
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
    call histdel("/",-1)
    " sometimes multiple sorting patterns will match the same file or directory.
    " The following substitute is intended to remove the excess matches.
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
    NetrwKeepj call histdel("/",-1)
   endif
   let priority = priority + 1
  endwhile
  if exists("starpriority")
   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
   NetrwKeepj call histdel("/",-1)
  endif

  " Following line associated with priority -- items that satisfy a priority
  " pattern get prefixed by ###/ which permits easy sorting by priority.
  " Sometimes files can satisfy multiple priority patterns -- only the latest
  " priority pattern needs to be retained.  So, at this point, these excess
  " priority prefixes need to be removed, but not directories that happen to
  " be just digits themselves.
  exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
  NetrwKeepj call histdel("/",-1)
  let @@= ykeep

"  call Dret("SetSort")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetTgt: sets the target to the specified choice index {{{2
"    Implements [count]Tb  (bookhist<b>)
"               [count]Th  (bookhist<h>)
"               See :help netrw-qb for how to make the choice.
fun! s:NetrwSetTgt(islocal,bookhist,choice)
"  call Dfunc("s:NetrwSetTgt(islocal=".a:islocal." bookhist<".a:bookhist."> choice#".a:choice.")")

  if     a:bookhist == 'b'
   " supports choosing a bookmark as a target using a qb-generated list
   let choice= a:choice - 1
   if exists("g:netrw_bookmarklist[".choice."]")
    call netrw#MakeTgt(g:netrw_bookmarklist[choice])
   else
    echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
   endif

  elseif a:bookhist == 'h'
   " supports choosing a history stack entry as a target using a qb-generated list
   let choice= (a:choice % g:netrw_dirhistmax) + 1
   if exists("g:netrw_dirhist_".choice)
    let histentry = g:netrw_dirhist_{choice}
    call netrw#MakeTgt(histentry)
   else
    echomsg "Sorry, history#".a:choice." not available!"
   endif
  endif

  " refresh the display
  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
  endif
  call s:NetrwRefresh(a:islocal,b:netrw_curdir)

"  call Dret("s:NetrwSetTgt")
endfun

" =====================================================================
" s:NetrwSortStyle: change sorting style (name - time - size) and refresh display {{{2
fun! s:NetrwSortStyle(islocal)
"  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
  NetrwKeepj call s:NetrwSaveWordPosn()
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  let g:netrw_sort_by= (g:netrw_sort_by =~# '^n')? 'time' : (g:netrw_sort_by =~# '^t')? 'size' : (g:netrw_sort_by =~# '^siz')? 'exten' : 'name'
  NetrwKeepj norm! 0
  NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

"  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwSplit: mode {{{2
"           =0 : net   and o
"           =1 : net   and t
"           =2 : net   and v
"           =3 : local and o
"           =4 : local and t
"           =5 : local and v
fun! s:NetrwSplit(mode)
"  call Dfunc("s:NetrwSplit(mode=".a:mode.") alto=".g:netrw_alto." altv=".g:netrw_altv)

  let ykeep= @@
  call s:SaveWinVars()

  if a:mode == 0
   " remote and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 1
   " remote and t
   let newdir  = s:NetrwBrowseChgDir(0,s:NetrwGetWord())
"   call Decho("tabnew",'~'.expand("<slnum>"))
   tabnew
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call s:NetrwBrowse(0,newdir)
   unlet s:didsplit

  elseif a:mode == 2
   " remote and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v",'~'.expand("<slnum>"))
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 3
   " local and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 4
   " local and t
   let cursorword  = s:NetrwGetWord()
   let eikeep      = &ei
   let netrw_winnr = winnr()
   let netrw_line  = line(".")
   let netrw_col   = virtcol(".")
   NetrwKeepj norm! H0
   let netrw_hline = line(".")
   setl ei=all
   exe "NetrwKeepj norm! ".netrw_hline."G0z\<CR>"
   exe "NetrwKeepj norm! ".netrw_line."G0".netrw_col."\<bar>"
   let &ei          = eikeep
   let netrw_curdir = s:NetrwTreeDir(0)
"   call Decho("tabnew",'~'.expand("<slnum>"))
   tabnew
   let b:netrw_curdir = netrw_curdir
   let s:didsplit     = 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
   if &ft == "netrw"
    setl ei=all
    exe "NetrwKeepj norm! ".netrw_hline."G0z\<CR>"
    exe "NetrwKeepj norm! ".netrw_line."G0".netrw_col."\<bar>"
    let &ei= eikeep
   endif
   unlet s:didsplit

  elseif a:mode == 5
   " local and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v",'~'.expand("<slnum>"))
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   NetrwKeepj call s:RestoreWinVars()
   NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  else
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"(NetrwSplit) unsupported mode=".a:mode,45)
  endif

  let @@= ykeep
"  call Dret("s:NetrwSplit")
endfun

" ---------------------------------------------------------------------
" s:NetrwTgtMenu: {{{2
fun! s:NetrwTgtMenu()
  if !exists("s:netrw_menucnt")
   return
  endif
"  call Dfunc("s:NetrwTgtMenu()")

  " the following test assures that gvim is running, has menus available, and has menus enabled.
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   if exists("g:NetrwTopLvlMenu")
"    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
   endif
   if !exists("s:netrw_initbookhist")
    call s:NetrwBookHistRead()
   endif

   " try to cull duplicate entries
   let tgtdict={}

   " target bookmarked places
   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
"    call Decho("installing bookmarks as easy targets",'~'.expand("<slnum>"))
    let cnt= 1
    for bmd in g:netrw_bookmarklist
     if has_key(tgtdict,bmd)
      let cnt= cnt + 1
      continue
     endif
     let tgtdict[bmd]= cnt
     let ebmd= escape(bmd,g:netrw_menu_escape)
     " show bookmarks for goto menu
"     call Decho("menu: Targets: ".bmd,'~'.expand("<slnum>"))
     exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
     let cnt= cnt + 1
    endfor
   endif

   " target directory browsing history
   if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
"    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")",'~'.expand("<slnum>"))
    let histcnt = 1
    while histcnt <= g:netrw_dirhistmax
     let priority = g:netrw_dirhist_cnt + histcnt
     if exists("g:netrw_dirhist_{histcnt}")
      let histentry  = g:netrw_dirhist_{histcnt}
      if has_key(tgtdict,histentry)
       let histcnt = histcnt + 1
       continue
      endif
      let tgtdict[histentry] = histcnt
      let ehistentry         = escape(histentry,g:netrw_menu_escape)
"      call Decho("menu: Targets: ".histentry,'~'.expand("<slnum>"))
      exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
     endif
     let histcnt = histcnt + 1
    endwhile
   endif
  endif
"  call Dret("s:NetrwTgtMenu")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDir: determine tree directory given current cursor position {{{2
" (full path directory with trailing slash returned)
fun! s:NetrwTreeDir(islocal)
"  call Dfunc("s:NetrwTreeDir(islocal=".a:islocal.") getline(".line(".").")"."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)
"  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("w:netrw_treetop  =".(exists("w:netrw_treetop")?   w:netrw_treetop   : 'n/a'),'~'.expand("<slnum>"))

  if exists("s:treedir")
   " s:NetrwPrevWinOpen opens a "previous" window -- and thus needs to and does call s:NetrwTreeDir early
   let treedir= s:treedir
   unlet s:treedir
"   call Dret("s:NetrwTreeDir ".treedir)
   return treedir
  endif

  if !exists("b:netrw_curdir") || b:netrw_curdir == ""
   let b:netrw_curdir= getcwd()
  endif
  let treedir = b:netrw_curdir
"  call Decho("set initial treedir<".treedir.">",'~'.expand("<slnum>"))

  let s:treecurpos= winsaveview()
"  call Decho("saving posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))

  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"   call Decho("w:netrw_liststyle is TREELIST:",'~'.expand("<slnum>"))
"   call Decho("line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))

   " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
   let curline= substitute(getline('.'),"\t -->.*$",'','')
   if curline =~ '/$'
"    call Decho("extract tree subdirectory from current line",'~'.expand("<slnum>"))
    let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"    call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
   elseif curline =~ '@$'
"    call Decho("handle symbolic link from current line",'~'.expand("<slnum>"))
    let treedir= resolve(substitute(substitute(getline('.'),'@.*$','','e'),'^|*\s*','','e'))
"    call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
   else
"    call Decho("do not extract tree subdirectory from current line and set treedir to empty",'~'.expand("<slnum>"))
    let treedir= ""
   endif

   " detect user attempting to close treeroot
"   call Decho("check if user is attempting to close treeroot",'~'.expand("<slnum>"))
"   call Decho(".win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
"   call Decho(".getline(".line(".").")<".getline('.').'> '.((getline('.') =~# '^'.s:treedepthstring)? '=~#' : '!~').' ^'.s:treedepthstring,'~'.expand("<slnum>"))
   if curline !~ '^'.s:treedepthstring && getline('.') != '..'
"    call Decho(".user may have attempted to close treeroot",'~'.expand("<slnum>"))
    " now force a refresh
"    call Decho(".force refresh: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
    sil! NetrwKeepj %d _
"    call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".(exists("s:treecurpos")? string(s:treecurpos) : 'n/a').">")
    return b:netrw_curdir
"   else " Decho
"    call Decho(".user not attempting to close treeroot",'~'.expand("<slnum>"))
   endif

"   call Decho("islocal=".a:islocal." curline<".curline.">",'~'.expand("<slnum>"))
   let potentialdir= s:NetrwFile(substitute(curline,'^'.s:treedepthstring.'\+ \(.*\)@$','\1',''))
"   call Decho("potentialdir<".potentialdir."> isdir=".isdirectory(potentialdir),'~'.expand("<slnum>"))

   " COMBAK: a symbolic link may point anywhere -- so it will be used to start a new treetop
"   if a:islocal && curline =~ '@$' && isdirectory(s:NetrwFile(potentialdir))
"    let newdir          = w:netrw_treetop.'/'.potentialdir
" "   call Decho("apply NetrwTreePath to newdir<".newdir.">",'~'.expand("<slnum>"))
"    let treedir         = s:NetrwTreePath(newdir)
"    let w:netrw_treetop = newdir
" "   call Decho("newdir <".newdir.">",'~'.expand("<slnum>"))
"   else
"    call Decho("apply NetrwTreePath to treetop<".w:netrw_treetop.">",'~'.expand("<slnum>"))
    let treedir = s:NetrwTreePath(w:netrw_treetop)
"   endif
  endif

  " sanity maintenance: keep those //s away...
  let treedir= substitute(treedir,'//$','/','')
"  call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))

"  call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".(exists("s:treecurpos")? string(s:treecurpos) : 'n/a').">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDisplay: recursive tree display {{{2
fun! s:NetrwTreeDisplay(dir,depth)
"  call Dfunc("NetrwTreeDisplay(dir<".a:dir."> depth<".a:depth.">)")

  " insure that there are no folds
  setl nofen

  " install ../ and shortdir
  if a:depth == ""
   call setline(line("$")+1,'../')
"   call Decho("setline#".line("$")." ../ (depth is zero)",'~'.expand("<slnum>"))
  endif
  if a:dir =~ '^\a\{3,}://'
   if a:dir == w:netrw_treetop
    let shortdir= a:dir
   else
    let shortdir= substitute(a:dir,'^.*/\([^/]\+\)/$','\1/','e')
   endif
   call setline(line("$")+1,a:depth.shortdir)
  else
   let shortdir= substitute(a:dir,'^.*/','','e')
   call setline(line("$")+1,a:depth.shortdir.'/')
  endif
"  call Decho("setline#".line("$")." shortdir<".a:depth.shortdir.">",'~'.expand("<slnum>"))

  " append a / to dir if its missing one
  let dir= a:dir

  " display subtrees (if any)
  let depth= s:treedepthstring.a:depth
"  call Decho("display subtrees with depth<".depth."> and current leaves",'~'.expand("<slnum>"))

"  call Decho("for every entry in w:netrw_treedict[".dir."]=".string(w:netrw_treedict[dir]),'~'.expand("<slnum>"))
  for entry in w:netrw_treedict[dir]
   if dir =~ '/$'
    let direntry= substitute(dir.entry,'[@/]$','','e')
   else
    let direntry= substitute(dir.'/'.entry,'[@/]$','','e')
   endif
"   call Decho("dir<".dir."> entry<".entry."> direntry<".direntry.">",'~'.expand("<slnum>"))
   if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
"    call Decho("<".direntry."> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwTreeDisplay(direntry,depth)
   elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwTreeDisplay(direntry.'/',depth)
   elseif entry =~ '@$' && has_key(w:netrw_treedict,direntry.'@')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwTreeDisplay(direntry.'/',depth)
   else
"    call Decho("<".entry."> is not a key in treedict (no subtree)",'~'.expand("<slnum>"))
    sil! NetrwKeepj call setline(line("$")+1,depth.entry)
   endif
  endfor

"  call Dret("NetrwTreeDisplay")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefreshTreeDict: updates the contents information for a tree (w:netrw_treedict) {{{2
fun! s:NetrwRefreshTreeDict(dir)
"  call Dfunc("s:NetrwRefreshTreeDict(dir<".a:dir.">)")
  for entry in w:netrw_treedict[a:dir]
   let direntry= substitute(a:dir.'/'.entry,'[@/]$','','e')
"   call Decho("a:dir<".a:dir."> entry<".entry."> direntry<".direntry.">",'~'.expand("<slnum>"))

   if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
"    call Decho("<".direntry."> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshTreeDict(direntry)
    let liststar                   = s:NetrwGlob(direntry,'*',1)
    let listdotstar                = s:NetrwGlob(direntry,'.*',1)
    let w:netrw_treedict[direntry] = liststar + listdotstar
"    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))

   elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshTreeDict(direntry.'/')
    let liststar   = s:NetrwGlob(direntry.'/','*',1)
    let listdotstar= s:NetrwGlob(direntry.'/','.*',1)
    let w:netrw_treedict[direntry]= liststar + listdotstar
"    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))

   elseif entry =~ '@$' && has_key(w:netrw_treedict,direntry.'@')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwRefreshTreeDict(direntry.'/')
    let liststar   = s:NetrwGlob(direntry.'/','*',1)
    let listdotstar= s:NetrwGlob(direntry.'/','.*',1)
"    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))

   else
"    call Decho('not updating w:netrw_treedict['.direntry.'] with entry<'.entry.'> (no subtree)',,'~'.expand("<slnum>"))
   endif
  endfor
"  call Dret("s:NetrwRefreshTreeDict")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeListing: displays tree listing from treetop on down, using NetrwTreeDisplay() {{{2
"                     Called by s:PerformListing()
fun! s:NetrwTreeListing(dirname)
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
"   call Decho("curdir<".a:dirname.">",'~'.expand("<slnum>"))
"   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"),'~'.expand("<slnum>"))
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

   " update the treetop
"   call Decho("update the treetop",'~'.expand("<slnum>"))
   if !exists("w:netrw_treetop")
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)",'~'.expand("<slnum>"))
   elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)",'~'.expand("<slnum>"))
   endif

   if !exists("w:netrw_treedict")
    " insure that we have a treedict, albeit empty
"    call Decho("initializing w:netrw_treedict to empty",'~'.expand("<slnum>"))
    let w:netrw_treedict= {}
   endif

   " update the dictionary for the current directory
"   call Decho("updating: w:netrw_treedict[".a:dirname.'] -> [directory listing]','~'.expand("<slnum>"))
"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d _'
   let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
"   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]),'~'.expand("<slnum>"))
   exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"

   " if past banner, record word
   if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
    let fname= expand("<cword>")
   else
    let fname= ""
   endif
"   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

   " display from treetop on down
   NetrwKeepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
"   call Decho("s:NetrwTreeDisplay) setl noma nomod ro",'~'.expand("<slnum>"))

   " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
   while getline(1) =~ '^\s*$' && byte2line(1) > 0
"    call Decho("deleting blank line",'~'.expand("<slnum>"))
    1d
   endwhile

   exe "setl ".g:netrw_bufsettings

"   call Dret("NetrwTreeListing : bufname<".expand("%").">")
   return
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwTreePath: returns path to current file in tree listing {{{2
"                  Normally, treetop is w:netrw_treetop, but a
"                  user of the function ( netrw#SetTreetop() )
"                  wipes that out prior to calling this function
fun! s:NetrwTreePath(treetop)
"  call Dfunc("s:NetrwTreePath() line#".line(".")."<".getline(".").">")
  let svpos = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
"  call Decho("depth<".depth."> 1st subst",'~'.expand("<slnum>"))
  let depth = substitute(depth,'^'.s:treedepthstring,'','')
"  call Decho("depth<".depth."> 2nd subst (first depth removed)",'~'.expand("<slnum>"))
  let curline= getline('.')
"  call Decho("curline<".curline.'>','~'.expand("<slnum>"))
  if curline =~ '/$'
"   call Decho("extract tree directory from current line",'~'.expand("<slnum>"))
   let treedir= substitute(curline,'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  elseif curline =~ '@\s\+-->'
"   call Decho("extract tree directory using symbolic link",'~'.expand("<slnum>"))
   let treedir= substitute(curline,'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
   let treedir= substitute(treedir,'@\s\+-->.*$','','e')
"   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  else
"   call Decho("do not extract tree directory from current line and set treedir to empty",'~'.expand("<slnum>"))
   let treedir= ""
  endif
  " construct treedir by searching backwards at correct depth
"  call Decho("construct treedir by searching backwards for correct depth",'~'.expand("<slnum>"))
"  call Decho("initial      treedir<".treedir."> depth<".depth.">",'~'.expand("<slnum>"))
  while depth != "" && search('^'.depth.'[^'.s:treedepthstring.'].\{-}/$','bW')
   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
   let treedir= dirname.treedir
   let depth  = substitute(depth,'^'.s:treedepthstring,'','')
"   call Decho("constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">",'~'.expand("<slnum>"))
  endwhile
  if a:treetop =~ '/$'
   let treedir= a:treetop.treedir
  else
   let treedir= a:treetop.'/'.treedir
  endif
  let treedir= substitute(treedir,'//$','/','')
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
  call winrestview(svpos)
"  call Dret("s:NetrwTreePath <".treedir.">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwWideListing: {{{2
fun! s:NetrwWideListing()

  if w:netrw_liststyle == s:WIDELIST
"   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
   " look for longest filename (cpf=characters per filename)
   " cpf: characters per filename
   " fpl: filenames per line
   " fpc: filenames per column
   setl ma noro
"   call Decho("setl ma noro",'~'.expand("<slnum>"))
   let b:netrw_cpf= 0
   if line("$") >= w:netrw_bannercnt
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
    NetrwKeepj call histdel("/",-1)
   else
"    call Dret("NetrwWideListing")
    return
   endif
   let b:netrw_cpf= b:netrw_cpf + 2
"   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf,'~'.expand("<slnum>"))

   " determine qty files per line (fpl)
   let w:netrw_fpl= winwidth(0)/b:netrw_cpf
   if w:netrw_fpl <= 0
    let w:netrw_fpl= 1
   endif
"   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl,'~'.expand("<slnum>"))

   " make wide display
   "   fpc: files per column of wide listing
   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'S",submatch(0)),"\\")/'
   NetrwKeepj call histdel("/",-1)
   let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
   let newcolstart = w:netrw_bannercnt + fpc
   let newcolend   = newcolstart + fpc - 1
"   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]",'~'.expand("<slnum>"))
   if has("clipboard")
    sil! let keepregstar = @*
    sil! let keepregplus = @+
   endif
   while line("$") >= newcolstart
    if newcolend > line("$") | let newcolend= line("$") | endif
    let newcolqty= newcolend - newcolstart
    exe newcolstart
    if newcolqty == 0
     exe "sil! NetrwKeepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
    else
     exe "sil! NetrwKeepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
    endif
    exe "sil! NetrwKeepj ".newcolstart.','.newcolend.'d _'
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt
   endwhile
   if has("clipboard")
    sil! let @*= keepregstar
    sil! let @+= keepregplus
   endif
   exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/\s\+$//e'
   NetrwKeepj call histdel("/",-1)
   exe 'nno <buffer> <silent> w	:call search(''^.\\|\s\s\zs\S'',''W'')'."\<cr>"
   exe 'nno <buffer> <silent> b	:call search(''^.\\|\s\s\zs\S'',''bW'')'."\<cr>"
"   call Decho("NetrwWideListing) setl noma nomod ro",'~'.expand("<slnum>"))
   exe "setl ".g:netrw_bufsettings
"   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("NetrwWideListing")
   return
  else
   if hasmapto("w","n")
    sil! nunmap <buffer> w
   endif
   if hasmapto("b","n")
    sil! nunmap <buffer> b
   endif
  endif

endfun

" ---------------------------------------------------------------------
" s:PerformListing: {{{2
fun! s:PerformListing(islocal)
"  call Dfunc("s:PerformListing(islocal=".a:islocal.")")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
"  call Decho("settings: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)",'~'.expand("<slnum>"))

  " set up syntax highlighting {{{3
"  call Decho("--set up syntax highlighting (ie. setl ft=netrw)",'~'.expand("<slnum>"))
  sil! setl ft=netrw

  NetrwKeepj call s:NetrwSafeOptions()
  setl noro ma
"  call Decho("setl noro ma bh=".&bh,'~'.expand("<slnum>"))

"  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
"   call Decho("(netrw) Processing your browsing request...",'~'.expand("<slnum>"))
"  endif								" Decho

"  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " force a refresh for tree listings
"   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
   sil! NetrwKeepj %d _
  endif

  " save current directory on directory history list
  NetrwKeepj call s:NetrwBookHistHandler(3,b:netrw_curdir)

  " Set up the banner {{{3
  if g:netrw_banner
"   call Decho("--set up banner",'~'.expand("<slnum>"))
   NetrwKeepj call setline(1,'" ============================================================================')
   if exists("g:netrw_pchk")
    " this undocumented option allows pchk to run with different versions of netrw without causing spurious
    " failure detections.
    NetrwKeepj call setline(2,'" Netrw Directory Listing')
   else
    NetrwKeepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
   endif
   if exists("g:netrw_pchk")
    let curdir= substitute(b:netrw_curdir,expand("$HOME"),'~','')
   else
    let curdir= b:netrw_curdir
   endif
   if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
    NetrwKeepj call setline(3,'"   '.substitute(curdir,'/','\\','g'))
   else
    NetrwKeepj call setline(3,'"   '.curdir)
   endif
   let w:netrw_bannercnt= 3
   NetrwKeepj exe "sil! NetrwKeepj ".w:netrw_bannercnt
  else
"   call Decho("--no banner",'~'.expand("<slnum>"))
   NetrwKeepj 1
   let w:netrw_bannercnt= 1
  endif
"  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr(),'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))

  let sortby= g:netrw_sort_by
  if g:netrw_sort_direction =~# "^r"
   let sortby= sortby." reversed"
  endif

  " Sorted by... {{{3
  if g:netrw_banner
"   call Decho("--handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
   if g:netrw_sort_by =~# "^n"
"   call Decho("directories will be sorted by name",'~'.expand("<slnum>"))
    " sorted by name
    NetrwKeepj put ='\"   Sorted by      '.sortby
    NetrwKeepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
    let w:netrw_bannercnt= w:netrw_bannercnt + 2
   else
"   call Decho("directories will be sorted by size or time",'~'.expand("<slnum>"))
    " sorted by size or date
    NetrwKeepj put ='\"   Sorted by '.sortby
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "sil! NetrwKeepj ".w:netrw_bannercnt
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
  endif

  " show copy/move target, if any
  if g:netrw_banner
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
"    call Decho("--show copy/move target<".s:netrwmftgt.">",'~'.expand("<slnum>"))
    NetrwKeepj put =''
    if s:netrwmftgt_islocal
     sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
    else
     sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   else
"    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt",'~'.expand("<slnum>"))
   endif
   exe "sil! NetrwKeepj ".w:netrw_bannercnt
  endif

  " Hiding...  -or-  Showing... {{{3
  if g:netrw_banner
"   call Decho("--handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)",'~'.expand("<slnum>"))
   if g:netrw_list_hide != "" && g:netrw_hide
    if g:netrw_hide == 1
     NetrwKeepj put ='\"   Hiding:        '.g:netrw_list_hide
    else
     NetrwKeepj put ='\"   Showing:       '.g:netrw_list_hide
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "NetrwKeepj ".w:netrw_bannercnt

"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
"   call Decho("quickhelp   =".quickhelp,'~'.expand("<slnum>"))
   NetrwKeepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   NetrwKeepj put ='\" =============================================================================='
   let w:netrw_bannercnt= w:netrw_bannercnt + 2
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
  endif

  " bannercnt should index the line just after the banner
  if g:netrw_banner
   let w:netrw_bannercnt= w:netrw_bannercnt + 1
   exe "sil! NetrwKeepj ".w:netrw_bannercnt
"   call Decho("--w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"),'~'.expand("<slnum>"))
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
  endif

  " get list of files
"  call Decho("--Get list of files - islocal=".a:islocal,'~'.expand("<slnum>"))
  if a:islocal
   NetrwKeepj call s:LocalListing()
  else " remote
   NetrwKeepj let badresult= s:NetrwRemoteListing()
   if badresult
"    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
"    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
    return
   endif
  endif

  " manipulate the directory listing (hide, sort) {{{3
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= 0
  endif
"  call Decho("--manipulate directory listing (hide, sort)",'~'.expand("<slnum>"))
"  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)",'~'.expand("<slnum>"))
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"   call Decho("manipulate directory listing (hide)",'~'.expand("<slnum>"))
"   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
   if g:netrw_hide && g:netrw_list_hide != ""
    NetrwKeepj call s:NetrwListHide()
   endif
   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))

    if g:netrw_sort_by =~# "^n"
     " sort by name
     NetrwKeepj call s:NetrwSetSort()

     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
      if g:netrw_sort_direction =~# 'n'
       " normal direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
       " reverse direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     endif
     " remove priority pattern prefix
"     call Decho("remove priority pattern prefix",'~'.expand("<slnum>"))
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
     NetrwKeepj call histdel("/",-1)

    elseif g:netrw_sort_by =~# "^ext"
     " sort by extension
     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g+/+s/^/001'.g:netrw_sepchr.'/'
     NetrwKeepj call histdel("/",-1)
     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+[./]+s/^/002'.g:netrw_sepchr.'/'
     NetrwKeepj call histdel("/",-1)
     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+['.g:netrw_sepchr.'/]+s/^\(.*\.\)\(.\{-\}\)$/\2'.g:netrw_sepchr.'&/e'
     NetrwKeepj call histdel("/",-1)
     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
      if g:netrw_sort_direction =~# 'n'
       " normal direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
       " reverse direction sorting
       exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     endif
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^.\{-}'.g:netrw_sepchr.'//e'
     NetrwKeepj call histdel("/",-1)

    elseif a:islocal
     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction,'~'.expand("<slnum>"))
      if g:netrw_sort_direction =~# 'n'
"       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort','~'.expand("<slnum>"))
       exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
"       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort!','~'.expand("<slnum>"))
       exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
     NetrwKeepj call histdel("/",-1)
     endif
    endif

   elseif g:netrw_sort_direction =~# 'r'
"    call Decho('(s:PerformListing) reverse the sorted listing','~'.expand("<slnum>"))
    if !g:netrw_banner || w:netrw_bannercnt < line('$')
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
     call histdel("/",-1)
    endif
   endif
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  " convert to wide/tree listing {{{3
"  call Decho("--modify display if wide/tree listing style",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwWideListing()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwTreeListing(b:netrw_curdir)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)",'~'.expand("<slnum>"))

  " resolve symbolic links if local and (thin or tree)
  if a:islocal && (w:netrw_liststyle == s:THINLIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST))
"   call Decho("--resolve symbolic links if local and thin|tree",'~'.expand("<slnum>"))
   g/@$/call s:ShowLink()
  endif

  if exists("w:netrw_bannercnt") && (line("$") >= w:netrw_bannercnt || !g:netrw_banner)
   " place cursor on the top-left corner of the file listing
"   call Decho("--place cursor on top-left corner of file listing",'~'.expand("<slnum>"))
   exe 'sil! '.w:netrw_bannercnt
   sil! NetrwKeepj norm! 0
"   call Decho("  tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
  else
"   call Decho("--did NOT place cursor on top-left corner",'~'.expand("<slnum>"))
"   call Decho("  w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'),'~'.expand("<slnum>"))
"   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
"   call Decho("  g:netrw_banner=".(exists("g:netrw_banner")? g:netrw_banner : 'n/a'),'~'.expand("<slnum>"))
  endif

  " record previous current directory
  let w:netrw_prvdir= b:netrw_curdir
"  call Decho("--record netrw_prvdir<".w:netrw_prvdir.">",'~'.expand("<slnum>"))

  " save certain window-oriented variables into buffer-oriented variables {{{3
"  call Decho("--save some window-oriented variables into buffer oriented variables",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)",'~'.expand("<slnum>"))
  NetrwKeepj call s:SetBufWinVars()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwOptionRestore("w:")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)",'~'.expand("<slnum>"))

  " set display to netrw display settings
"  call Decho("--set display to netrw display settings (".g:netrw_bufsettings.")",'~'.expand("<slnum>"))
  exe "setl ".g:netrw_bufsettings
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)",'~'.expand("<slnum>"))
  if g:netrw_liststyle == s:LONGLIST
"   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
   exe "setl ts=".(g:netrw_maxfilenamelen+1)
  endif

  if exists("s:treecurpos")
"   call Decho("s:treecurpos exists; restore posn",'~'.expand("<slnum>"))
"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)",'~'.expand("<slnum>"))
"   call Decho("restoring posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(s:treecurpos)
   unlet s:treecurpos
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)",'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
"  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
endfun

" ---------------------------------------------------------------------
" s:SetupNetrwStatusLine: {{{2
fun! s:SetupNetrwStatusLine(statline)
"  call Dfunc("SetupNetrwStatusLine(statline<".a:statline.">)")

  if !exists("s:netrw_setup_statline")
   let s:netrw_setup_statline= 1
"   call Decho("do first-time status line setup",'~'.expand("<slnum>"))

   if !exists("s:netrw_users_stl")
    let s:netrw_users_stl= &stl
   endif
   if !exists("s:netrw_users_ls")
    let s:netrw_users_ls= &laststatus
   endif

   " set up User9 highlighting as needed
   let keepa= @a
   redir @a
   try
    hi User9
   catch /^Vim\%((\a\{3,})\)\=:E411/
    if &bg == "dark"
     hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
    else
     hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
    endif
   endtry
   redir END
   let @a= keepa
  endif

  " set up status line (may use User9 highlighting)
  " insure that windows have a statusline
  " make sure statusline is displayed
  let &stl=a:statline
  setl laststatus=2
"  call Decho("stl=".&stl,'~'.expand("<slnum>"))
  redraw

"  call Dret("SetupNetrwStatusLine : stl=".&stl)
endfun

" ---------------------------------------------------------------------
"  Remote Directory Browsing Support:    {{{1
" ===========================================

" ---------------------------------------------------------------------
" s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
"  This function assumes that a long listing will be received.  Size, time,
"  and reverse sorts will be requested of the server but not otherwise
"  enforced here.
fun! s:NetrwRemoteFtpCmd(path,listcmd)
"  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
"  call Decho("line($)=".line("$")." win#".winnr()." w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
  " sanity check: {{{3
  if !exists("w:netrw_method")
   if exists("b:netrw_method")
    let w:netrw_method= b:netrw_method
   else
    call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
"    call Dret("NetrwRemoteFtpCmd")
    return
   endif
  endif

  " WinXX ftp uses unix style input, so set ff to unix	" {{{3
  let ffkeep= &ff
  setl ma ff=unix noro
"  call Decho("setl ma ff=unix noro",'~'.expand("<slnum>"))

  " clear off any older non-banner lines	" {{{3
  " note that w:netrw_bannercnt indexes the line after the banner
"  call Decho('exe sil! NetrwKeepj '.w:netrw_bannercnt.",$d _  (clear off old non-banner lines)",'~'.expand("<slnum>"))
  exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"

  ".........................................
  if w:netrw_method == 2 || w:netrw_method == 5	" {{{3
   " ftp + <.netrc>:  Method #2
   if a:path != ""
    NetrwKeepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    NetrwKeepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
   endif
   NetrwKeepj call setline(line("$")+1,a:listcmd)
"   exe "NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."),''~''.expand("<slnum>"))'
   if exists("g:netrw_port") && g:netrw_port != ""
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1),'~'.expand("<slnum>"))
    exe s:netrw_silentxfer." NetrwKeepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1)
   else
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1),'~'.expand("<slnum>"))
    exe s:netrw_silentxfer." NetrwKeepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)
   endif

  ".........................................
  elseif w:netrw_method == 3	" {{{3
   " ftp + machine,id,passwd,filename:  Method #3
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     NetrwKeepj put ='open '.g:netrw_machine
    endif

    " handle userid and password
    let host= substitute(g:netrw_machine,'\..*$','','')
"    call Decho("host<".host.">",'~'.expand("<slnum>"))
    if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
     call NetUserPass("ftp:".host)
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
     endif
    endif

   if a:path != ""
    NetrwKeepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    NetrwKeepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
   endif
   NetrwKeepj call setline(line("$")+1,a:listcmd)

   " perform ftp:
   " -i       : turns off interactive prompting from ftp
   " -n  unix : DON'T use <.netrc>, even though it exists
   " -n  win32: quit being obnoxious about password
   if exists("w:netrw_bannercnt")
"    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."),''~''.expand("<slnum>"))'
    call s:NetrwExe(s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
"   else " Decho
"    call Decho("WARNING: w:netrw_bannercnt doesn't exist!",'~'.expand("<slnum>"))
"    g/^./call Decho("SKIPPING ftp#".line(".").": ".getline("."),'~'.expand("<slnum>"))
   endif

  ".........................................
  elseif w:netrw_method == 9	" {{{3
   " sftp username@machine: Method #9
   " s:netrw_sftp_cmd
   setl ff=unix

   " restore settings
   let &ff= ffkeep
"   call Dret("NetrwRemoteFtpCmd")
   return

  ".........................................
  else	" {{{3
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . bufname("%") . ">",23)
  endif

  " cleanup for Windows " {{{3
  if has("win32") || has("win95") || has("win64") || has("win16")
   sil! NetrwKeepj %s/\r$//e
   NetrwKeepj call histdel("/",-1)
  endif
  if a:listcmd == "dir"
   " infer directory/link based on the file permission string
   sil! NetrwKeepj g/d\%([-r][-w][-x]\)\{3}/NetrwKeepj s@$@/@e
   sil! NetrwKeepj g/l\%([-r][-w][-x]\)\{3}/NetrwKeepj s/$/@/e
   NetrwKeepj call histdel("/",-1)
   NetrwKeepj call histdel("/",-1)
   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST)
    exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
    NetrwKeepj call histdel("/",-1)
   endif
  endif

  " ftp's listing doesn't seem to include ./ or ../ " {{{3
  if !search('^\.\/$\|\s\.\/$','wn')
   exe 'NetrwKeepj '.w:netrw_bannercnt
   NetrwKeepj put ='./'
  endif
  if !search('^\.\.\/$\|\s\.\.\/$','wn')
   exe 'NetrwKeepj '.w:netrw_bannercnt
   NetrwKeepj put ='../'
  endif

  " restore settings " {{{3
  let &ff= ffkeep
"  call Dret("NetrwRemoteFtpCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteListing: {{{2
fun! s:NetrwRemoteListing()
"  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">) win#".winnr())

  if !exists("w:netrw_bannercnt") && exists("s:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif
  if !exists("w:netrw_bannercnt") && exists("b:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif

  call s:RemotePathAnalysis(b:netrw_curdir)

  " sanity check:
  if exists("b:netrw_method") && b:netrw_method =~ '[235]'
"   call Decho("b:netrw_method=".b:netrw_method,'~'.expand("<slnum>"))
   if !executable("ftp")
"    call Decho("ftp is not executable",'~'.expand("<slnum>"))
    if !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
    endif
    call s:NetrwOptionRestore("w:")
"    call Dret("s:NetrwRemoteListing -1")
    return -1
   endif

  elseif !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ''
"   call Decho("g:netrw_list_cmd<",(exists("g:netrw_list_cmd")? 'n/a' : "-empty-").">",'~'.expand("<slnum>"))
   if !exists("g:netrw_quiet")
    if g:netrw_list_cmd == ""
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your g:netrw_list_cmd is empty; perhaps ".g:netrw_ssh_cmd." is not executable on your system",47)
    else
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
    endif
   endif

   NetrwKeepj call s:NetrwOptionRestore("w:")
"   call Dret("s:NetrwRemoteListing -1")
   return -1
  endif  " (remote handling sanity check)
"  call Decho("passed remote listing sanity checks",'~'.expand("<slnum>"))

  if exists("b:netrw_method")
"   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">",'~'.expand("<slnum>"))
   let w:netrw_method= b:netrw_method
  endif

  if s:method == "ftp"
   " use ftp to get remote file listing {{{3
"   call Decho("use ftp to get remote file listing",'~'.expand("<slnum>"))
   let s:method  = "ftp"
   let listcmd = g:netrw_ftp_list_cmd
   if g:netrw_sort_by =~# '^t'
    let listcmd= g:netrw_ftp_timelist_cmd
   elseif g:netrw_sort_by =~# '^s'
    let listcmd= g:netrw_ftp_sizelist_cmd
   endif
"   call Decho("listcmd<".listcmd."> (using g:netrw_ftp_list_cmd)",'~'.expand("<slnum>"))
   call s:NetrwRemoteFtpCmd(s:path,listcmd)
"   exe "sil! keepalt NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."),''~''.expand("<slnum>"))'

   " report on missing file or directory messages
   if search('[Nn]o such file or directory\|Failed to change directory')
    let mesg= getline(".")
    if exists("w:netrw_bannercnt")
     setl ma
     exe w:netrw_bannercnt.",$d _"
     setl noma
    endif
    NetrwKeepj call s:NetrwOptionRestore("w:")
    call netrw#ErrorMsg(s:WARNING,mesg,96)
"    call Dret("s:NetrwRemoteListing : -1")
    return -1
   endif

   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST)
    " shorten the listing
"    call Decho("generate short listing",'~'.expand("<slnum>"))
    exe "sil! keepalt NetrwKeepj ".w:netrw_bannercnt

    " cleanup
    if g:netrw_ftp_browse_reject != ""
     exe "sil! keepalt NetrwKeepj g/".g:netrw_ftp_browse_reject."/NetrwKeepj d"
     NetrwKeepj call histdel("/",-1)
    endif
    sil! NetrwKeepj %s/\r$//e
    NetrwKeepj call histdel("/",-1)

    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    exe "sil! NetrwKeepj ".w:netrw_bannercnt
    let line2= search('\.\.\/\%(\s\|$\)','cnW')
"    call Decho("search(".'\.\.\/\%(\s\|$\)'."','cnW')=".line2."  w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
    if line2 == 0
"     call Decho("netrw is putting ../ into listing",'~'.expand("<slnum>"))
     sil! NetrwKeepj put='../'
    endif
    exe "sil! NetrwKeepj ".line1
    sil! NetrwKeepj norm! 0

"    call Decho("line1=".line1." line2=".line2." line(.)=".line("."),'~'.expand("<slnum>"))
    if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"     call Decho("M$ ftp cleanup",'~'.expand("<slnum>"))
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+//'
     NetrwKeepj call histdel("/",-1)
    else " normal ftp cleanup
"     call Decho("normal ftp cleanup",'~'.expand("<slnum>"))
     exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2/e'
     exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*/$#/#e'
     exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*$#/#e'
     NetrwKeepj call histdel("/",-1)
     NetrwKeepj call histdel("/",-1)
     NetrwKeepj call histdel("/",-1)
    endif
   endif

   else
   " use ssh to get remote file listing {{{3
"   call Decho("use ssh to get remote file listing: s:path<".s:path.">",'~'.expand("<slnum>"))
   let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
"   call Decho("listcmd<".listcmd."> (using g:netrw_list_cmd)",'~'.expand("<slnum>"))
   if g:netrw_scp_cmd =~ '^pscp'
"    call Decho("1: exe r! ".s:ShellEscape(listcmd.s:path, 1),'~'.expand("<slnum>"))
    exe "NetrwKeepj r! ".listcmd.s:ShellEscape(s:path, 1)
    " remove rubbish and adjust listing format of 'pscp' to 'ssh ls -FLa' like
    sil! NetrwKeepj g/^Listing directory/NetrwKeepj d
    sil! NetrwKeepj g/^d[-rwx][-rwx][-rwx]/NetrwKeepj s+$+/+e
    sil! NetrwKeepj g/^l[-rwx][-rwx][-rwx]/NetrwKeepj s+$+@+e
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
    if g:netrw_liststyle != s:LONGLIST
     sil! NetrwKeepj g/^[dlsp-][-rwx][-rwx][-rwx]/NetrwKeepj s/^.*\s\(\S\+\)$/\1/e
     NetrwKeepj call histdel("/",-1)
    endif
   else
    if s:path == ""
"     call Decho("2: exe r! ".listcmd,'~'.expand("<slnum>"))
     exe "NetrwKeepj keepalt r! ".listcmd
    else
"     call Decho("3: exe r! ".listcmd.' '.s:ShellEscape(fnameescape(s:path),1),'~'.expand("<slnum>"))
     exe "NetrwKeepj keepalt r! ".listcmd.' '.s:ShellEscape(fnameescape(s:path),1)
"     call Decho("listcmd<".listcmd."> path<".s:path.">",'~'.expand("<slnum>"))
    endif
   endif

   " cleanup
   if g:netrw_ssh_browse_reject != ""
"    call Decho("cleanup: exe sil! g/".g:netrw_ssh_browse_reject."/NetrwKeepj d",'~'.expand("<slnum>"))
    exe "sil! g/".g:netrw_ssh_browse_reject."/NetrwKeepj d"
    NetrwKeepj call histdel("/",-1)
   endif
  endif

  if w:netrw_liststyle == s:LONGLIST
   " do a long listing; these substitutions need to be done prior to sorting {{{3
"   call Decho("fix long listing:",'~'.expand("<slnum>"))

   if s:method == "ftp"
    " cleanup
    exe "sil! NetrwKeepj ".w:netrw_bannercnt
    while getline('.') =~# g:netrw_ftp_browse_reject
     sil! NetrwKeepj d
    endwhile
    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    sil! NetrwKeepj 1
    sil! NetrwKeepj call search('^\.\.\/\%(\s\|$\)','W')
    let line2= line(".")
    if line2 == 0
     if b:netrw_curdir != '/'
      exe 'sil! NetrwKeepj '.w:netrw_bannercnt."put='../'"
     endif
    endif
    exe "sil! NetrwKeepj ".line1
    sil! NetrwKeepj norm! 0
   endif

   if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"    call Decho("M$ ftp site listing cleanup",'~'.expand("<slnum>"))
    exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+\)\(\w.*\)$/\2\t\1/'
   elseif exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$")
"    call Decho("normal ftp site listing cleanup: bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/ -> .*$//e'
    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2 \t\1/e'
    exe 'sil NetrwKeepj '.w:netrw_bannercnt
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
    NetrwKeepj call histdel("/",-1)
   endif
  endif

"  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
"   exe "NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."),''~''.expand("<slnum>"))'
"  endif " Decho

"  call Dret("s:NetrwRemoteListing 0")
  return 0
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRm: remove/delete a remote file or directory {{{2
fun! s:NetrwRemoteRm(usrhost,path) range
"  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
"  call Decho("firstline=".a:firstline." lastline=".a:lastline,'~'.expand("<slnum>"))
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  let all= 0
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files with bufnr#".bufnr("%"),'~'.expand("<slnum>"))
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwRemoteRmFile(a:path,fname,all)
    if ok =~# 'q\%[uit]'
     break
    elseif ok =~# 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)

  else
   " remove files specified by range
"   call Decho("remove files specified by range",'~'.expand("<slnum>"))

   " preparation for removing multiple files/directories
   let keepsol = &l:sol
   setl nosol
   let ctr    = a:firstline

   " remove multiple files and directories
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr
    let ok= s:NetrwRemoteRmFile(a:path,s:NetrwGetWord(),all)
    if ok =~# 'q\%[uit]'
     break
    elseif ok =~# 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
   let &l:sol = keepsol
  endif

  " refresh the (remote) directory listing
"  call Decho("refresh remote directory listing",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

"  call Dret("s:NetrwRemoteRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRmFile: {{{2
fun! s:NetrwRemoteRmFile(path,rmfile,all)
"  call Dfunc("s:NetrwRemoteRmFile(path<".a:path."> rmfile<".a:rmfile.">) all=".a:all)

  let all= a:all
  let ok = ""

  if a:rmfile !~ '^"' && (a:rmfile =~ '@$' || a:rmfile !~ '[\/]$')
   " attempt to remove file
"    call Decho("attempt to remove file (all=".all.")",'~'.expand("<slnum>"))
   if !all
    echohl Statement
"    call Decho("case all=0:",'~'.expand("<slnum>"))
    call inputsave()
    let ok= input("Confirm deletion of file<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~# 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~# 'y\%[es]' || ok == ""
"    call Decho("case all=".all." or ok<".ok.">".(exists("w:netrw_method")? ': netrw_method='.w:netrw_method : ""),'~'.expand("<slnum>"))
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
"     call Decho("case ftp:",'~'.expand("<slnum>"))
     let path= a:path
     if path =~ '^\a\{3,}://'
      let path= substitute(path,'^\a\{3,}://[^/]\+/','','')
     endif
     sil! NetrwKeepj .,$d _
     call s:NetrwRemoteFtpCmd(path,"delete ".'"'.a:rmfile.'"')
    else
"     call Decho("case ssh: g:netrw_rm_cmd<".g:netrw_rm_cmd.">",'~'.expand("<slnum>"))
     let netrw_rm_cmd= s:MakeSshCmd(g:netrw_rm_cmd)
"     call Decho("netrw_rm_cmd<".netrw_rm_cmd.">",'~'.expand("<slnum>"))
     if !exists("b:netrw_curdir")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
      let ok="q"
     else
      let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
"      call Decho("netrw_rm_cmd<".netrw_rm_cmd.">",'~'.expand("<slnum>"))
"      call Decho("remotedir<".remotedir.">",'~'.expand("<slnum>"))
"      call Decho("rmfile<".a:rmfile.">",'~'.expand("<slnum>"))
      if remotedir != ""
       let netrw_rm_cmd= netrw_rm_cmd." ".s:ShellEscape(fnameescape(remotedir.a:rmfile))
      else
       let netrw_rm_cmd= netrw_rm_cmd." ".s:ShellEscape(fnameescape(a:rmfile))
      endif
"      call Decho("call system(".netrw_rm_cmd.")",'~'.expand("<slnum>"))
      let ret= system(netrw_rm_cmd)
      if v:shell_error != 0
       if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
        call netrw#ErrorMsg(s:ERROR,"remove failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",102)
       else
        call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
       endif
      elseif ret != 0
       call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
      endif
"      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))
     endif
    endif
   elseif ok =~# 'q\%[uit]'
"    call Decho("ok==".ok,'~'.expand("<slnum>"))
   endif

  else
   " attempt to remove directory
"    call Decho("attempt to remove directory",'~'.expand("<slnum>"))
   if !all
    call inputsave()
    let ok= input("Confirm deletion of directory<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~# 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~# 'y\%[es]' || ok == ""
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     NetrwKeepj call s:NetrwRemoteFtpCmd(a:path,"rmdir ".a:rmfile)
    else
     let rmfile          = substitute(a:path.a:rmfile,'/$','','')
     let netrw_rmdir_cmd = s:MakeSshCmd(netrw#WinPath(g:netrw_rmdir_cmd)).' '.s:ShellEscape(netrw#WinPath(rmfile))
"      call Decho("attempt to remove dir: system(".netrw_rmdir_cmd.")",'~'.expand("<slnum>"))
     let ret= system(netrw_rmdir_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))

     if v:shell_error != 0
"      call Decho("v:shell_error not 0",'~'.expand("<slnum>"))
      let netrw_rmf_cmd= s:MakeSshCmd(netrw#WinPath(g:netrw_rmf_cmd)).' '.s:ShellEscape(netrw#WinPath(substitute(rmfile,'[\/]$','','e')))
"      call Decho("2nd attempt to remove dir: system(".netrw_rmf_cmd.")",'~'.expand("<slnum>"))
      let ret= system(netrw_rmf_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))

      if v:shell_error != 0 && !exists("g:netrw_quiet")
      	NetrwKeepj call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",22)
      endif
     endif
    endif

   elseif ok =~# 'q\%[uit]'
"    call Decho("ok==".ok,'~'.expand("<slnum>"))
   endif
  endif

"  call Dret("s:NetrwRemoteRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRename: rename a remote file or directory {{{2
fun! s:NetrwRemoteRename(usrhost,path) range
"  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")

  " preparation for removing multiple files/directories
  let svpos      = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let ctr        = a:firstline
  let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname)
     call inputrestore()
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
      let newname = substitute(oldname,subfrom,subto,'')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
     endif
    endif

    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     NetrwKeepj call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= s:ShellEscape(a:path.oldname)
     let newname= s:ShellEscape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")",'~'.expand("<slnum>"))
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

   endfor
   call s:NetrwUnMarkFile(1)

  else

  " attempt to rename files/directories
   let keepsol= &l:sol
   setl nosol
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr

    let oldname= s:NetrwGetWord()
"   call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))

    call inputsave()
    let newname= input("Moving ".oldname." to : ",oldname)
    call inputrestore()

    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= s:ShellEscape(a:path.oldname)
     let newname= s:ShellEscape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")",'~'.expand("<slnum>"))
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

    let ctr= ctr + 1
   endwhile
   let &l:sol= keepsol
  endif

  " refresh the directory
  NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)

"  call Dret("NetrwRemoteRename")
endfun

" ---------------------------------------------------------------------
"  Local Directory Browsing Support:    {{{1
" ==========================================

" ---------------------------------------------------------------------
" netrw#FileUrlRead: handles reading file://* files {{{2
"   Should accept:   file://localhost/etc/fstab
"                    file:///etc/fstab
"                    file:///c:/WINDOWS/clock.avi
"                    file:///c|/WINDOWS/clock.avi
"                    file://localhost/c:/WINDOWS/clock.avi
"                    file://localhost/c|/WINDOWS/clock.avi
"                    file://c:/foo.txt
"                    file:///c:/foo.txt
" and %XX (where X is [0-9a-fA-F] is converted into a character with the given hexadecimal value
fun! netrw#FileUrlRead(fname)
"  call Dfunc("netrw#FileUrlRead(fname<".a:fname.">)")
  let fname = a:fname
  if fname =~ '^file://localhost/'
"   call Decho('converting file://localhost/   -to-  file:///','~'.expand("<slnum>"))
   let fname= substitute(fname,'^file://localhost/','file:///','')
"   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
  endif
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   if fname  =~ '^file:///\=\a[|:]/'
"    call Decho('converting file:///\a|/   -to-  file://\a:/','~'.expand("<slnum>"))
    let fname = substitute(fname,'^file:///\=\(\a\)[|:]/','file://\1:/','')
"    call Decho("fname<".fname.">",'~'.expand("<slnum>"))
   endif
  endif
  let fname2396 = netrw#RFC2396(fname)
  let fname2396e= fnameescape(fname2396)
  let plainfname= substitute(fname2396,'file://\(.*\)','\1',"")
  if (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows exception for plainfname",'~'.expand("<slnum>"))
   if plainfname =~ '^/\+\a:'
"    call Decho('removing leading "/"s','~'.expand("<slnum>"))
    let plainfname= substitute(plainfname,'^/\+\(\a:\)','\1','')
   endif
  endif
"  call Decho("fname2396<".fname2396.">",'~'.expand("<slnum>"))
"  call Decho("plainfname<".plainfname.">",'~'.expand("<slnum>"))
  exe "sil doau BufReadPre ".fname2396e
  exe 'NetrwKeepj r '.plainfname
  exe 'sil! bdelete '.plainfname
  exe 'keepalt file! '.plainfname
  NetrwKeepj 1d
"  call Decho("setl nomod",'~'.expand("<slnum>"))
  setl nomod
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Dret("netrw#FileUrlRead")
  exe "sil doau BufReadPost ".fname2396e
endfun

" ---------------------------------------------------------------------
" netrw#LocalBrowseCheck: {{{2
fun! netrw#LocalBrowseCheck(dirname)
  " This function is called by netrwPlugin.vim's s:LocalBrowse(), s:NetrwRexplore(), and by <cr> when atop listed file/directory
  " unfortunate interaction -- split window debugging can't be
  " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
  " event triggers another call to LocalBrowseCheck() when attempts
  " to write to the DBG buffer are made.
  " The &ft == "netrw" test was installed because the BufEnter event
  " would hit when re-entering netrw windows, creating unexpected
  " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
"  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
"  call Decho("isdir<".a:dirname."> =".isdirectory(s:NetrwFile(a:dirname)).((exists("s:treeforceredraw")? " treeforceredraw" : "")).'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dredir("ls!","ls!")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"  call Decho("current buffer#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))

  let ykeep= @@
  if isdirectory(s:NetrwFile(a:dirname))
"   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse,'~'.expand("<slnum>"))

   if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
"    call Decho("case 1 : ft=".&ft,'~'.expand("<slnum>"))
"    call Decho("s:rexposn_".bufnr("%")."<".bufname("%")."> ".(exists("s:rexposn_".bufnr("%"))? "exists" : "does not exist"),'~'.expand("<slnum>"))
    sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)

   elseif &ft == "netrw" && line("$") == 1
"    call Decho("case 2 (ftâ‰¡netrw && line($)â‰¡1)",'~'.expand("<slnum>"))
    sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)

   elseif exists("s:treeforceredraw")
"    call Decho("case 3 (treeforceredraw)",'~'.expand("<slnum>"))
    unlet s:treeforceredraw
    sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
   endif
"   call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
"   call Dret("netrw#LocalBrowseCheck")
   return
  endif

  " following code wipes out currently unused netrw buffers
  "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
  "   AND IF the listing style is not a tree listing
  if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
"   call Decho("wiping out currently unused netrw buffers",'~'.expand("<slnum>"))
   let ibuf    = 1
   let buflast = bufnr("$")
   while ibuf <= buflast
    if bufwinnr(ibuf) == -1 && isdirectory(s:NetrwFile(bufname(ibuf)))
     exe "sil! keepj keepalt ".ibuf."bw!"
    endif
    let ibuf= ibuf + 1
   endwhile
  endif
  let @@= ykeep
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
  " not a directory, ignore it
"  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")
endfun

" ---------------------------------------------------------------------
" s:LocalBrowseRefresh: this function is called after a user has {{{2
" performed any shell command.  The idea is to cause all local-browsing
" buffers to be refreshed after a user has executed some shell command,
" on the chance that s/he removed/created a file/directory with it.
fun! s:LocalBrowseRefresh()
"  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
"  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'),'~'.expand("<slnum>"))
"  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'),'~'.expand("<slnum>"))

  " determine which buffers currently reside in a tab
  if !exists("s:netrw_browselist")
"   call Dret("s:LocalBrowseRefresh : browselist is empty")
   return
  endif
  if !exists("w:netrw_bannercnt")
"   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
   return
  endif
  if exists("s:netrw_events") && s:netrw_events == 1
   " s:LocalFastBrowser gets called (indirectly) from a
   let s:netrw_events= 2
"   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
   return
  endif
  let itab       = 1
  let buftablist = []
  let ykeep      = @@
  while itab <= tabpagenr("$")
   let buftablist = buftablist + tabpagebuflist()
   let itab       = itab + 1
   tabn
  endwhile
"  call Decho("buftablist".string(buftablist),'~'.expand("<slnum>"))
"  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">",'~'.expand("<slnum>"))
  "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
  "   | refresh any netrw window
  "   | wipe out any non-displaying netrw buffer
  let curwin = winnr()
  let ibl    = 0
  for ibuf in s:netrw_browselist
"   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf),'~'.expand("<slnum>"))
   if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
    " wipe out any non-displaying netrw buffer
"    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">",'~'.expand("<slnum>"))
    exe "sil! keepj bd ".fnameescape(ibuf)
    call remove(s:netrw_browselist,ibl)
"    call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
    continue
   elseif index(tabpagebuflist(),ibuf) != -1
    " refresh any netrw buffer
"    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf),'~'.expand("<slnum>"))
    exe bufwinnr(ibuf)."wincmd w"
    if getline(".") =~# 'Quick Help'
     " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
     " (counteracts s:NetrwBrowseChgDir()'s incrementing)
     let g:netrw_quickhelp= g:netrw_quickhelp - 1
    endif
"    call Decho("#3: quickhelp=".g:netrw_quickhelp,'~'.expand("<slnum>"))
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     NetrwKeepj call s:NetrwRefreshTreeDict(w:netrw_treetop)
    endif
    NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
   endif
   let ibl= ibl + 1
"   call Decho("bottom of s:netrw_browselist for loop: ibl=".ibl,'~'.expand("<slnum>"))
  endfor
"  call Decho("restore window: exe ".curwin."wincmd w",'~'.expand("<slnum>"))
  exe curwin."wincmd w"
  let @@= ykeep

"  call Dret("s:LocalBrowseRefresh")
endfun

" ---------------------------------------------------------------------
" s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
"
"     g:netrw_    Directory Is
"     fastbrowse  Local  Remote
"  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
"  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
"  fast   2         H      H
"
"  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
"  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
"                       (re-using a buffer may not be as accurate)
"
"  s:netrw_events : doesn't exist, s:LocalFastBrowser() will install autocmds whena med or fast browsing
"                   =1: autocmds installed, but ignore next FocusGained event to avoid initial double-refresh of listing.
"                       BufEnter may be first event, then a FocusGained event.  Ignore the first FocusGained event.
"                       If :Explore used: it sets s:netrw_events to 2, so no FocusGained events are ignored.
"                   =2: autocmds installed (doesn't ignore any FocusGained events)
fun! s:LocalFastBrowser()
"  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
"  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'),'~'.expand("<slnum>"))
"  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"),'~'.expand("<slnum>"))
"  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"),'~'.expand("<slnum>"))

  " initialize browselist, a list of buffer numbers that the local browser has used
  if !exists("s:netrw_browselist")
"   call Decho("initialize s:netrw_browselist",'~'.expand("<slnum>"))
   let s:netrw_browselist= []
  endif

  " append current buffer to fastbrowse list
  if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
"   call Decho("appendng current buffer to browselist",'~'.expand("<slnum>"))
   call add(s:netrw_browselist,bufnr("%"))
"   call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
  endif

  " enable autocmd events to handle refreshing/removing local browser buffers
  "    If local browse buffer is currently showing: refresh it
  "    If local browse buffer is currently hidden : wipe it
  "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
  "                      =1 : medium speed, re-use directory listing for remote only
  "                      =2 : fast   speed, always re-use directory listing when possible
  if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
   let s:netrw_events= 1
   augroup AuNetrwEvent
    au!
    if (has("win32") || has("win95") || has("win64") || has("win16"))
"     call Decho("installing autocmd: ShellCmdPost",'~'.expand("<slnum>"))
     au ShellCmdPost			*	call s:LocalBrowseRefresh()
    else
"     call Decho("installing autocmds: ShellCmdPost FocusGained",'~'.expand("<slnum>"))
     au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
    endif
   augroup END

  " user must have changed fastbrowse to its fast setting, so remove
  " the associated autocmd events
  elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
"   call Decho("remove AuNetrwEvent autcmd group",'~'.expand("<slnum>"))
   unlet s:netrw_events
   augroup AuNetrwEvent
    au!
   augroup END
   augroup! AuNetrwEvent
  endif

"  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
endfun

" ---------------------------------------------------------------------
"  s:LocalListing: does the job of "ls" for local directories {{{2
fun! s:LocalListing()
"  call Dfunc("s:LocalListing()")
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))

"  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist",'~'.expand("<slnum>")) |endif
"  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist",'~'.expand("<slnum>"))|endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  " get the list of files contained in the current directory
  let dirname    = b:netrw_curdir
  let dirnamelen = strlen(b:netrw_curdir)
  let filelist   = s:NetrwGlob(dirname,"*",0)
  let filelist   = filelist + s:NetrwGlob(dirname,".*",0)
"  call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))

  if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
  elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
    " include ../ in the glob() entry if its missing
"   call Decho("forcibly including on \"..\"",'~'.expand("<slnum>"))
   let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
"   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
  endif

"  call Decho("before while: dirname   <".dirname.">",'~'.expand("<slnum>"))
"  call Decho("before while: dirnamelen<".dirnamelen.">",'~'.expand("<slnum>"))
"  call Decho("before while: filelist  =".string(filelist),'~'.expand("<slnum>"))

  if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
   let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
   let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
"   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy),'~'.expand("<slnum>"))
"   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen,'~'.expand("<slnum>"))
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))

  for filename in filelist
"   call Decho(" ",'~'.expand("<slnum>"))
"   call Decho("for filename in filelist: filename<".filename.">",'~'.expand("<slnum>"))

   if getftype(filename) == "link"
    " indicate a symbolic link
"    call Decho("indicate <".filename."> is a symbolic link with trailing @",'~'.expand("<slnum>"))
    let pfile= filename."@"

   elseif getftype(filename) == "socket"
    " indicate a socket
"    call Decho("indicate <".filename."> is a socket with trailing =",'~'.expand("<slnum>"))
    let pfile= filename."="

   elseif getftype(filename) == "fifo"
    " indicate a fifo
"    call Decho("indicate <".filename."> is a fifo with trailing |",'~'.expand("<slnum>"))
    let pfile= filename."|"

   elseif isdirectory(s:NetrwFile(filename))
    " indicate a directory
"    call Decho("indicate <".filename."> is a directory with trailing /",'~'.expand("<slnum>"))
    let pfile= filename."/"

   elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(s:NetrwFile(filename))
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
      " indicate an executable
"      call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
      let pfile= filename."*"
     else
      " normal file
      let pfile= filename
     endif
    elseif executable(filename)
     " indicate an executable
"     call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
     let pfile= filename."*"
    else
     " normal file
     let pfile= filename
    endif

   else
    " normal file
    let pfile= filename
   endif
"   call Decho("pfile<".pfile."> (after *@/ appending)",'~'.expand("<slnum>"))

   if pfile =~ '//$'
    let pfile= substitute(pfile,'//$','/','e')
"    call Decho("change // to /: pfile<".pfile.">",'~'.expand("<slnum>"))
   endif
   let pfile= strpart(pfile,dirnamelen)
   let pfile= substitute(pfile,'^[/\\]','','e')
"   call Decho("filename<".filename.">",'~'.expand("<slnum>"))
"   call Decho("pfile   <".pfile.">",'~'.expand("<slnum>"))

   if w:netrw_liststyle == s:LONGLIST
    let sz   = getfsize(filename)
    if g:netrw_sizestyle =~# "[hH]"
     let sz= s:NetrwHumanReadable(sz)
    endif
    let fsz  = strpart("               ",1,15-strlen(sz)).sz
    let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
"    call Decho("longlist support: sz=".sz." fsz=".fsz,'~'.expand("<slnum>"))
   endif

   if     g:netrw_sort_by =~# "^t"
    " sort by time (handles time up to 1 quintillion seconds, US)
"    call Decho("getftime(".filename.")=".getftime(filename),'~'.expand("<slnum>"))
    let t  = getftime(filename)
    let ft = strpart("000000000000000000",1,18-strlen(t)).t
"    call Decho("exe NetrwKeepj put ='".ft.'/'.filename."'",'~'.expand("<slnum>"))
    let ftpfile= ft.'/'.pfile
    sil! NetrwKeepj put=ftpfile

   elseif g:netrw_sort_by =~ "^s"
    " sort by size (handles file sizes up to 1 quintillion bytes, US)
"    call Decho("getfsize(".filename.")=".getfsize(filename),'~'.expand("<slnum>"))
    let sz   = getfsize(filename)
    if g:netrw_sizestyle =~# "[hH]"
     let sz= s:NetrwHumanReadable(sz)
    endif
    let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
"    call Decho("exe NetrwKeepj put ='".fsz.'/'.filename."'",'~'.expand("<slnum>"))
    let fszpfile= fsz.'/'.pfile
    sil! NetrwKeepj put =fszpfile

   else
    " sort by name
"    call Decho("exe NetrwKeepj put ='".pfile."'",'~'.expand("<slnum>"))
    sil! NetrwKeepj put=pfile
   endif
  endfor

  " cleanup any windows mess at end-of-line
  sil! NetrwKeepj g/^$/d
  sil! NetrwKeepj %s/\r$//e
  call histdel("/",-1)
"  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
  exe "setl ts=".(g:netrw_maxfilenamelen+1)

"  call Dret("s:LocalListing")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
fun! s:NetrwLocalExecute(cmd)
"  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
  let ykeep= @@
  " sanity check
  if !executable(a:cmd)
   call netrw#ErrorMsg(s:ERROR,"the file<".a:cmd."> is not executable!",89)
   let @@= ykeep
"   call Dret("s:NetrwLocalExecute")
   return
  endif

  let optargs= input(":!".a:cmd,"","file")
"  call Decho("optargs<".optargs.">",'~'.expand("<slnum>"))
  let result= system(a:cmd.optargs)
"  call Decho("result,'~'.expand("<slnum>"))

  " strip any ansi escape sequences off
  let result = substitute(result,"\e\\[[0-9;]*m","","g")

  " show user the result(s)
  echomsg result
  let @@= ykeep

"  call Dret("s:NetrwLocalExecute")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRename: rename a local file or directory {{{2
fun! s:NetrwLocalRename(path) range
"  call Dfunc("NetrwLocalRename(path<".a:path.">)")

  " preparation for removing multiple files/directories
  let ykeep    = @@
  let ctr      = a:firstline
  let svpos    = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname,"file")
     call inputrestore()
     if newname =~ ''
      " two ctrl-x's : ignore all of string preceding the ctrl-x's
      let newname = substitute(newname,'^.*','','')
     elseif newname =~ ''
      " one ctrl-x : ignore portion of string preceding ctrl-x but after last /
      let newname = substitute(newname,'[^/]*','','')
     endif
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
      let newname = substitute(oldname,subfrom,subto,'')
     endif
    endif
    call rename(oldname,newname)
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)

  else

   " attempt to rename files/directories
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif

    NetrwKeepj norm! 0
    let oldname= s:ComposePath(a:path,curword)
"   call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))

    call inputsave()
    let newname= input("Moving ".oldname." to : ",substitute(oldname,'/*$','','e'))
    call inputrestore()

    call rename(oldname,newname)
"   call Decho("renaming <".oldname."> to <".newname.">",'~'.expand("<slnum>"))

    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
"  call Decho("refresh the directory listing",'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  NetrwKeepj call winrestview(svpos)
  let @@= ykeep

"  call Dret("NetrwLocalRename")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRm: {{{2
fun! s:NetrwLocalRm(path) range
"  call Dfunc("s:NetrwLocalRm(path<".a:path.">)")
"  call Decho("firstline=".a:firstline." lastline=".a:lastline,'~'.expand("<slnum>"))

  " preparation for removing multiple files/directories
  let ykeep = @@
  let ret   = 0
  let all   = 0
  let svpos = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files",'~'.expand("<slnum>"))
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwLocalRmFile(a:path,fname,all)
    if ok =~# 'q\%[uit]' || ok == "no"
     break
    elseif ok =~# 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnMarkFile(1)

  else
  " remove (multiple) files and directories
"   call Decho("remove files in range [".a:firstline.",".a:lastline."]",'~'.expand("<slnum>"))

   let keepsol= &l:sol
   setl nosol
   let ctr = a:firstline
   while ctr <= a:lastline
    exe "NetrwKeepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif
    let ok= s:NetrwLocalRmFile(a:path,curword,all)
    if ok =~# 'q\%[uit]' || ok == "no"
     break
    elseif ok =~# 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
   let &l:sol= keepsol
  endif

  " refresh the directory
"  call Decho("bufname<".bufname("%").">",'~'.expand("<slnum>"))
  if bufname("%") != "NetrwMessage"
   NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
"   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(svpos)
  endif
  let @@= ykeep

"  call Dret("s:NetrwLocalRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRmFile: remove file fname given the path {{{2
"                     Give confirmation prompt unless all==1
fun! s:NetrwLocalRmFile(path,fname,all)
"  call Dfunc("s:NetrwLocalRmFile(path<".a:path."> fname<".a:fname."> all=".a:all)

  let all= a:all
  let ok = ""
  NetrwKeepj norm! 0
  let rmfile= s:NetrwFile(s:ComposePath(a:path,a:fname))
"  call Decho("rmfile<".rmfile.">",'~'.expand("<slnum>"))

  if rmfile !~ '^"' && (rmfile =~ '@$' || rmfile !~ '[\/]$')
   " attempt to remove file
"   call Decho("attempt to remove file<".rmfile.">",'~'.expand("<slnum>"))
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of file<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
"    call Decho("response: ok<".ok.">",'~'.expand("<slnum>"))
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
"    call Decho("response: ok<".ok."> (after sub)",'~'.expand("<slnum>"))
    if ok =~# 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~# 'y\%[es]' || ok == ""
    let ret= s:NetrwDelete(rmfile)
"    call Decho("errcode=".v:shell_error." ret=".ret,'~'.expand("<slnum>"))
   endif

  else
   " attempt to remove directory
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of directory<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok == ""
     let ok="no"
    endif
    if ok =~# 'a\%[ll]'
     let all= 1
    endif
   endif
   let rmfile= substitute(rmfile,'[\/]$','','e')

   if all || ok =~# 'y\%[es]' || ok == ""
    if v:version < 704 || !has("patch1109")
" "    call Decho("1st attempt: system(netrw#WinPath(".g:netrw_localrmdir.') '.s:ShellEscape(rmfile).')','~'.expand("<slnum>"))
     call system(netrw#WinPath(g:netrw_localrmdir).' '.s:ShellEscape(rmfile))
" "    call Decho("v:shell_error=".v:shell_error,'~'.expand("<slnum>"))

     if v:shell_error != 0
" "     call Decho("2nd attempt to remove directory<".rmfile.">",'~'.expand("<slnum>"))
      let errcode= s:NetrwDelete(rmfile)
" "     call Decho("errcode=".errcode,'~'.expand("<slnum>"))

      if errcode != 0
       if has("unix")
" "       call Decho("3rd attempt to remove directory<".rmfile.">",'~'.expand("<slnum>"))
	call system("rm ".s:ShellEscape(rmfile))
	if v:shell_error != 0 && !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",34)
	 let ok="no"
	endif
       elseif !exists("g:netrw_quiet")
	call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",35)
	let ok="no"
       endif
      endif
     endif
    else
     if delete(rmfile,"d")
      call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".rmfile.">!",103)
     endif
    endif
   endif
  endif

"  call Dret("s:NetrwLocalRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" Support Functions: {{{1

" ---------------------------------------------------------------------
" s:WinNames: COMBAK {{{2
fun! s:WinNames(id)
  let curwin= winnr()
  1wincmd w
"  call Decho("--- Windows By Name --- #".a:id)
"  windo call Decho("win#".winnr()."<".expand("%").">")
"  call Decho("--- --- --- --- --- ---")
  exe curwin."wincmd w"
endfun

" ---------------------------------------------------------------------
" netrw#Access: intended to provide access to variable values for netrw's test suite {{{2
"   0: marked file list of current buffer
"   1: marked file target
fun! netrw#Access(ilist)
  if     a:ilist == 0
   if exists("s:netrwmarkfilelist_".bufnr('%'))
    return s:netrwmarkfilelist_{bufnr('%')}
   else
    return "no-list-buf#".bufnr('%')
   endif
  elseif a:ilist == 1
   return s:netrwmftgt
endfun

" ---------------------------------------------------------------------
" netrw#Call: allows user-specified mappings to call internal netrw functions {{{2
fun! netrw#Call(funcname,...)
"  call Dfunc("netrw#Call(funcname<".a:funcname.">,".string(a:000).")")
  if a:0 > 0
   exe "call s:".a:funcname."(".string(a:000).")"
  else
   exe "call s:".a:funcname."()"
  endif
"  call Dret("netrw#Call")
endfun

" ---------------------------------------------------------------------
" netrw#Expose: allows UserMaps and pchk to look at otherwise script-local variables {{{2
"               I expect this function to be used in
"                 :PChkAssert netrw#Expose("netrwmarkfilelist")
"               for example.
fun! netrw#Expose(varname)
"   call Dfunc("netrw#Expose(varname<".a:varname.">)")
  if exists("s:".a:varname)
   exe "let retval= s:".a:varname
   if exists("g:netrw_pchk")
    if type(retval) == 3
     let retval = copy(retval)
     let i      = 0
     while i < len(retval)
      let retval[i]= substitute(retval[i],expand("$HOME"),'~','')
      let i        = i + 1
     endwhile
    endif
"     call Dret("netrw#Expose ".string(retval))
    return string(retval)
   endif
  else
   let retval= "n/a"
  endif

"  call Dret("netrw#Expose ".string(retval))
  return retval
endfun

" ---------------------------------------------------------------------
" netrw#Modify: allows UserMaps to set (modify) script-local variables {{{2
fun! netrw#Modify(varname,newvalue)
"  call Dfunc("netrw#Modify(varname<".a:varname.">,newvalue<".string(a:newvalue).">)")
  exe "let s:".a:varname."= ".string(a:newvalue)
"  call Dret("netrw#Modify")
endfun

" ---------------------------------------------------------------------
"  netrw#RFC2396: converts %xx into characters {{{2
fun! netrw#RFC2396(fname)
"  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
  let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
"  call Dret("netrw#RFC2396 ".fname)
  return fname
endfun

" ---------------------------------------------------------------------
" netrw#UserMaps: supports user-specified maps {{{2
"                 see :help function()
"
"                 g:Netrw_UserMaps is a List with members such as:
"                       [[keymap sequence, function reference],...]
"
"                 The referenced function may return a string,
"                 	refresh : refresh the display
"                 	-other- : this string will be executed
"                 or it may return a List of strings.
"
"                 Each keymap-sequence will be set up with a nnoremap
"                 to invoke netrw#UserMaps(islocal).
"                 Related functions:
"                   netrw#Expose(varname)          -- see s:varname variables
"                   netrw#Modify(varname,newvalue) -- modify value of s:varname variable
"                   netrw#Call(funcname,...)       -- call internal netrw function with optional arguments
fun! netrw#UserMaps(islocal)
"  call Dfunc("netrw#UserMaps(islocal=".a:islocal.")")
"  call Decho("g:Netrw_UserMaps ".(exists("g:Netrw_UserMaps")? "exists" : "does NOT exist"),'~'.expand("<slnum>"))

   " set up usermaplist
   if exists("g:Netrw_UserMaps") && type(g:Netrw_UserMaps) == 3
"    call Decho("g:Netrw_UserMaps has type 3<List>",'~'.expand("<slnum>"))
    for umap in g:Netrw_UserMaps
"     call Decho("type(umap[0]<".string(umap[0]).">)=".type(umap[0])." (should be 1=string)",'~'.expand("<slnum>"))
"     call Decho("type(umap[1])=".type(umap[1])." (should be 1=string)",'~'.expand("<slnum>"))
     " if umap[0] is a string and umap[1] is a string holding a function name
     if type(umap[0]) == 1 && type(umap[1]) == 1
"      call Decho("nno <buffer> <silent> ".umap[0]." :call s:UserMaps(".a:islocal.",".string(umap[1]).")<cr>",'~'.expand("<slnum>"))
      exe "nno <buffer> <silent> ".umap[0]." :call <SID>UserMaps(".a:islocal.",'".umap[1]."')<cr>"
      else
       call netrw#ErrorMsg(s:WARNING,"ignoring usermap <".string(umap[0])."> -- not a [string,funcref] entry",99)
     endif
    endfor
   endif
"  call Dret("netrw#UserMaps")
endfun

" ---------------------------------------------------------------------
" netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
fun! netrw#WinPath(path)
"  call Dfunc("netrw#WinPath(path<".a:path.">)")
  if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
   " remove cygdrive prefix, if present
   let path = substitute(a:path,g:netrw_cygdrive.'/\(.\)','\1:','')
   " remove trailing slash (Win95)
   let path = substitute(path, '\(\\\|/\)$', '', 'g')
   " remove escaped spaces
   let path = substitute(path, '\ ', ' ', 'g')
   " convert slashes to backslashes
   let path = substitute(path, '/', '\', 'g')
  else
   let path= a:path
  endif
"  call Dret("netrw#WinPath <".path.">")
  return path
endfun

" ---------------------------------------------------------------------
"  s:ComposePath: Appends a new part to a path taking different systems into consideration {{{2
fun! s:ComposePath(base,subdir)
"  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")

  if has("amiga")
"   call Decho("amiga",'~'.expand("<slnum>"))
   let ec = a:base[s:Strlen(a:base)-1]
   if ec != '/' && ec != ':'
    let ret = a:base."/" . a:subdir
   else
    let ret = a:base.a:subdir
   endif

  elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows",'~'.expand("<slnum>"))
   let ret= a:subdir

  elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows",'~'.expand("<slnum>"))
   if a:base =~ '[/\\]$'
    let ret= a:base.a:subdir
   else
    let ret= a:base.'/'.a:subdir
   endif

  elseif a:base =~ '^\a\{3,}://'
"   call Decho("remote linux/macos",'~'.expand("<slnum>"))
   let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
   let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
   if a:subdir == '../'
    if curpath =~ '[^/]/[^/]\+/$'
     let curpath= substitute(curpath,'[^/]\+/$','','')
    else
     let curpath=""
    endif
    let ret= urlbase.curpath
   else
    let ret= urlbase.curpath.a:subdir
   endif
"   call Decho("urlbase<".urlbase.">",'~'.expand("<slnum>"))
"   call Decho("curpath<".curpath.">",'~'.expand("<slnum>"))
"   call Decho("ret<".ret.">",'~'.expand("<slnum>"))

  else
"   call Decho("local linux/macos",'~'.expand("<slnum>"))
   let ret = substitute(a:base."/".a:subdir,"//","/","g")
   if a:base =~ '^//'
    " keeping initial '//' for the benefit of network share listing support
    let ret= '/'.ret
   endif
   let ret= simplify(ret)
  endif

"  call Dret("s:ComposePath ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:DeleteBookmark: deletes a file/directory from Netrw's bookmark system {{{2
"   Related Functions: s:MakeBookmark() s:NetrwBookHistHandler() s:NetrwBookmark()
fun! s:DeleteBookmark(fname)
"  call Dfunc("s:DeleteBookmark(fname<".a:fname.">)")
  call s:MergeBookmarks()

  if exists("g:netrw_bookmarklist")
   let indx= index(g:netrw_bookmarklist,a:fname)
   if indx == -1
    let indx= 0
    while indx < len(g:netrw_bookmarklist)
     if g:netrw_bookmarklist[indx] =~ a:fname
      call remove(g:netrw_bookmarklist,indx)
      let indx= indx - 1
     endif
     let indx= indx + 1
    endwhile
   else
    " remove exact match
    call remove(g:netrw_bookmarklist,indx)
   endif
  endif

"  call Dret("s:DeleteBookmark")
endfun

" ---------------------------------------------------------------------
" s:FileReadable: o/s independent filereadable {{{2
fun! s:FileReadable(fname)
"  call Dfunc("s:FileReadable(fname<".a:fname.">)")

  if g:netrw_cygwin
   let ret= filereadable(s:NetrwFile(substitute(a:fname,g:netrw_cygdrive.'/\(.\)','\1:/','')))
  else
   let ret= filereadable(s:NetrwFile(a:fname))
  endif

"  call Dret("s:FileReadable ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
"  s:GetTempfile: gets a tempname that'll work for various o/s's {{{2
"                 Places correct suffix on end of temporary filename,
"                 using the suffix provided with fname
fun! s:GetTempfile(fname)
"  call Dfunc("s:GetTempfile(fname<".a:fname.">)")

  if !exists("b:netrw_tmpfile")
   " get a brand new temporary filename
   let tmpfile= tempname()
"   call Decho("tmpfile<".tmpfile."> : from tempname()",'~'.expand("<slnum>"))

   let tmpfile= substitute(tmpfile,'\','/','ge')
"   call Decho("tmpfile<".tmpfile."> : chgd any \\ -> /",'~'.expand("<slnum>"))

   " sanity check -- does the temporary file's directory exist?
   if !isdirectory(s:NetrwFile(substitute(tmpfile,'[^/]\+$','','e')))
"    call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
"    call Dret("s:GetTempfile getcwd<".getcwd().">")
    return ""
   endif

   " let netrw#NetSource() know about the tmpfile
   let s:netrw_tmpfile= tmpfile " used by netrw#NetSource() and netrw#BrowseX()
"   call Decho("tmpfile<".tmpfile."> s:netrw_tmpfile<".s:netrw_tmpfile.">",'~'.expand("<slnum>"))

   " o/s dependencies
   if g:netrw_cygwin != 0
    let tmpfile = substitute(tmpfile,'^\(\a\):',g:netrw_cygdrive.'/\1','e')
   elseif has("win32") || has("win95") || has("win64") || has("win16")
    if !exists("+shellslash") || !&ssl
     let tmpfile = substitute(tmpfile,'/','\','g')
    endif
   else
    let tmpfile = tmpfile
   endif
   let b:netrw_tmpfile= tmpfile
"   call Decho("o/s dependent fixed tempname<".tmpfile.">",'~'.expand("<slnum>"))
  else
   " re-use temporary filename
   let tmpfile= b:netrw_tmpfile
"   call Decho("tmpfile<".tmpfile."> re-using",'~'.expand("<slnum>"))
  endif

  " use fname's suffix for the temporary file
  if a:fname != ""
   if a:fname =~ '\.[^./]\+$'
"    call Decho("using fname<".a:fname.">'s suffix",'~'.expand("<slnum>"))
    if a:fname =~ '\.tar\.gz$' || a:fname =~ '\.tar\.bz2$' || a:fname =~ '\.tar\.xz$'
     let suffix = ".tar".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    elseif a:fname =~ '.txz$'
     let suffix = ".txz".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    else
     let suffix = substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    endif
"    call Decho("suffix<".suffix.">",'~'.expand("<slnum>"))
    let tmpfile= substitute(tmpfile,'\.tmp$','','e')
"    call Decho("chgd tmpfile<".tmpfile."> (removed any .tmp suffix)",'~'.expand("<slnum>"))
    let tmpfile .= suffix
"    call Decho("chgd tmpfile<".tmpfile."> (added ".suffix." suffix) netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
    let s:netrw_tmpfile= tmpfile " supports netrw#NetSource()
   endif
  endif

"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Dret("s:GetTempfile <".tmpfile.">")
  return tmpfile
endfun

" ---------------------------------------------------------------------
" s:MakeSshCmd: transforms input command using USEPORT HOSTNAME into {{{2
"               a correct command for use with a system() call
fun! s:MakeSshCmd(sshcmd)
"  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
  if s:user == ""
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
  else
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
  endif
  if exists("g:netrw_port") && g:netrw_port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
  elseif exists("s:port") && s:port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
  else
   let sshcmd= substitute(sshcmd,"USEPORT ",'','')
  endif
"  call Dret("s:MakeSshCmd <".sshcmd.">")
  return sshcmd
endfun

" ---------------------------------------------------------------------
" s:MakeBookmark: enters a bookmark into Netrw's bookmark system   {{{2
fun! s:MakeBookmark(fname)
"  call Dfunc("s:MakeBookmark(fname<".a:fname.">)")

  if !exists("g:netrw_bookmarklist")
   let g:netrw_bookmarklist= []
  endif

  if index(g:netrw_bookmarklist,a:fname) == -1
   " curdir not currently in g:netrw_bookmarklist, so include it
   if isdirectory(s:NetrwFile(a:fname)) && a:fname !~ '/$'
    call add(g:netrw_bookmarklist,a:fname.'/')
   elseif a:fname !~ '/'
    call add(g:netrw_bookmarklist,getcwd()."/".a:fname)
   else
    call add(g:netrw_bookmarklist,a:fname)
   endif
   call sort(g:netrw_bookmarklist)
  endif

"  call Dret("s:MakeBookmark")
endfun

" ---------------------------------------------------------------------
" s:MergeBookmarks: merge current bookmarks with saved bookmarks {{{2
fun! s:MergeBookmarks()
"  call Dfunc("s:MergeBookmarks() : merge current bookmarks into .netrwbook")
  " get bookmarks from .netrwbook file
  let savefile= s:NetrwHome()."/.netrwbook"
  if filereadable(s:NetrwFile(savefile))
"   call Decho("merge bookmarks (active and file)",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwBookHistSave()
"   call Decho("bookmark delete savefile<".savefile.">",'~'.expand("<slnum>"))
   NetrwKeepj call delete(savefile)
  endif
"  call Dret("s:MergeBookmarks")
endfun

" ---------------------------------------------------------------------
" s:NetrwBMShow: {{{2
fun! s:NetrwBMShow()
"  call Dfunc("s:NetrwBMShow()")
  redir => bmshowraw
   menu
  redir END
  let bmshowlist = split(bmshowraw,'\n')
  if bmshowlist != []
   let bmshowfuncs= filter(bmshowlist,'v:val =~# "<SNR>\\d\\+_BMShow()"')
   if bmshowfuncs != []
    let bmshowfunc = substitute(bmshowfuncs[0],'^.*:\(call.*BMShow()\).*$','\1','')
    if bmshowfunc =~# '^call.*BMShow()'
     exe "sil! NetrwKeepj ".bmshowfunc
    endif
   endif
  endif
"  call Dret("s:NetrwBMShow : bmshowfunc<".(exists("bmshowfunc")? bmshowfunc : 'n/a').">")
endfun

" ---------------------------------------------------------------------
" s:NetrwCursor: responsible for setting cursorline/cursorcolumn based upon g:netrw_cursor {{{2
fun! s:NetrwCursor()
  if !exists("w:netrw_liststyle")
   let w:netrw_liststyle= g:netrw_liststyle
  endif
"  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)

  if &ft != "netrw"
   " if the current window isn't a netrw directory listing window, then use user cursorline/column
   " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
"   call Decho("case ft!=netrw: use user cul,cuc",'~'.expand("<slnum>"))
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc

  elseif g:netrw_cursor == 4
   " all styles: cursorline, cursorcolumn
"   call Decho("case g:netrw_cursor==4: setl cul cuc",'~'.expand("<slnum>"))
   setl cursorline
   setl cursorcolumn

  elseif g:netrw_cursor == 3
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, cursorcolumn
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc",'~'.expand("<slnum>"))
    setl cursorline
    setl cursorcolumn
   else
"    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
    setl cursorline
    let &l:cursorcolumn   = s:netrw_usercuc
   endif

  elseif g:netrw_cursor == 2
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, user's cursorcolumn
"   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)",'~'.expand("<slnum>"))
   let &l:cursorcolumn = s:netrw_usercuc
   setl cursorline

  elseif g:netrw_cursor == 1
   " thin-long-tree: user's cursorline, user's cursorcolumn
   " wide          : cursorline,        user's cursorcolumn
   let &l:cursorcolumn = s:netrw_usercuc
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
    setl cursorline
   else
"    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)",'~'.expand("<slnum>"))
    let &l:cursorline   = s:netrw_usercul
   endif

  else
   " all styles: user's cursorline, user's cursorcolumn
"   call Decho("default: (use user's cul,cuc)",'~'.expand("<slnum>"))
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc
  endif

"  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
fun! s:RestoreCursorline()
"  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%"))
  if exists("s:netrw_usercul")
   let &l:cursorline   = s:netrw_usercul
  endif
  if exists("s:netrw_usercuc")
   let &l:cursorcolumn = s:netrw_usercuc
  endif
"  call Dret("s:RestoreCursorline : restored cul=".&l:cursorline." cuc=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:NetrwDelete: Deletes a file. {{{2
"           Uses Steve Hall's idea to insure that Windows paths stay
"           acceptable.  No effect on Unix paths.
"  Examples of use:  let result= s:NetrwDelete(path)
fun! s:NetrwDelete(path)
"  call Dfunc("s:NetrwDelete(path<".a:path.">)")

  let path = netrw#WinPath(a:path)
  if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
   if exists("+shellslash")
    let sskeep= &shellslash
    setl noshellslash
    let result      = delete(path)
    let &shellslash = sskeep
   else
"    call Decho("exe let result= ".a:cmd."('".path."')",'~'.expand("<slnum>"))
    let result= delete(path)
   endif
  else
"   call Decho("let result= delete(".path.")",'~'.expand("<slnum>"))
   let result= delete(path)
  endif
  if result < 0
   NetrwKeepj call netrw#ErrorMsg(s:WARNING,"delete(".path.") failed!",71)
  endif

"  call Dret("s:NetrwDelete ".result)
  return result
endfun

" ---------------------------------------------------------------------
" s:NetrwEnew: opens a new buffer, passes netrw buffer variables through {{{2
fun! s:NetrwEnew(...)
"  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
"  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))

  " grab a function-local-variable copy of buffer variables
"  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
  if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
  if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
  if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
  if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
  if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
  if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
  if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
  if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif

  NetrwKeepj call s:NetrwOptionRestore("w:")
"  call Decho("generate a buffer with NetrwKeepj keepalt enew!",'~'.expand("<slnum>"))
  " when tree listing uses file TreeListing... a new buffer is made.
  " Want the old buffer to be unlisted.
  " COMBAK: this causes a problem, see P43
"  setl nobl
  let netrw_keepdiff= &l:diff
  noswapfile NetrwKeepj keepalt enew!
  let &l:diff= netrw_keepdiff
"  call Decho("bufnr($)=".bufnr("$")."<".bufname(bufnr("$"))."> winnr($)=".winnr("$"),'~'.expand("<slnum>"))
  NetrwKeepj call s:NetrwOptionSave("w:")

  " copy function-local-variables to buffer variable equivalents
"  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
  if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
  if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
  if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
  if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
  if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
  if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
  if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
  if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
  if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
  if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
  if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
  if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
  if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
  if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
  if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
  if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif

  if a:0 > 0
   let b:netrw_curdir= a:1
   if b:netrw_curdir =~ '/$'
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     setl nobl
     file NetrwTreeListing
     setl nobl bt=nowrite bh=hide
     nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
     nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
    else
     exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
    endif
   endif
  endif

"  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))
endfun

" ---------------------------------------------------------------------
" s:NetrwExe: executes a string using "!" {{{2
fun! s:NetrwExe(cmd)
"  call Dfunc("s:NetrwExe(a:cmd)")
  if has("win32") && &shell !~? 'cmd' && !g:netrw_cygwin
    let savedShell=[&shell,&shellcmdflag,&shellxquote,&shellxescape,&shellquote,&shellpipe,&shellredir,&shellslash]
    set shell& shellcmdflag& shellxquote& shellxescape&
    set shellquote& shellpipe& shellredir& shellslash&
    exe a:cmd
    let [&shell,&shellcmdflag,&shellxquote,&shellxescape,&shellquote,&shellpipe,&shellredir,&shellslash] = savedShell
  else
   exe a:cmd
  endif
"  call Dret("s:NetrwExe")
endfun

" ---------------------------------------------------------------------
" s:NetrwInsureWinVars: insure that a netrw buffer has its w: variables in spite of a wincmd v or s {{{2
fun! s:NetrwInsureWinVars()
  if !exists("w:netrw_liststyle")
"   call Dfunc("s:NetrwInsureWinVars() win#".winnr())
   let curbuf = bufnr("%")
   let curwin = winnr()
   let iwin   = 1
   while iwin <= winnr("$")
    exe iwin."wincmd w"
    if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
     " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
     let winvars= w:
     break
    endif
    let iwin= iwin + 1
   endwhile
   exe "keepalt ".curwin."wincmd w"
   if exists("winvars")
"    call Decho("copying w#".iwin." window variables to w#".curwin,'~'.expand("<slnum>"))
    for k in keys(winvars)
     let w:{k}= winvars[k]
    endfor
   endif
"   call Dret("s:NetrwInsureWinVars win#".winnr())
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwLcd: handles changing the (local) directory {{{2
fun! s:NetrwLcd(newdir)
"  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")

  try
   exe 'NetrwKeepj sil lcd '.fnameescape(a:newdir)
  catch /^Vim\%((\a\+)\)\=:E344/
     " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
     " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
     " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or
     " forward slashes ('//Foo'), depending on whether backslashes have been converted to
     " forward slashes by earlier code; so check for both.
     if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
       if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
         let dirname = '\'
	 exe 'NetrwKeepj sil lcd '.fnameescape(dirname)
       endif
     endif
  catch /^Vim\%((\a\+)\)\=:E472/
   call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
   if exists("w:netrw_prvdir")
    let a:newdir= w:netrw_prvdir
   else
    call s:NetrwOptionRestore("w:")
"    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
    exe "setl ".g:netrw_bufsettings
"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    let a:newdir= dirname
"    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
    return
   endif
  endtry

"  call Dret("s:NetrwLcd")
endfun

" ------------------------------------------------------------------------
" s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
" changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
fun! s:NetrwSaveWordPosn()
"  call Dfunc("NetrwSaveWordPosn()")
  let s:netrw_saveword= '^'.fnameescape(getline('.')).'$'
"  call Dret("NetrwSaveWordPosn : saveword<".s:netrw_saveword.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwHumanReadable: takes a number and makes it "human readable" {{{2
"                       1000 -> 1K, 1000000 -> 1M, 1000000000 -> 1G
fun! s:NetrwHumanReadable(sz)
"  call Dfunc("s:NetrwHumanReadable(sz=".a:sz.") type=".type(a:sz)." style=".g:netrw_sizestyle )

  if g:netrw_sizestyle == 'h'
   if a:sz >= 1000000000 
    let sz = printf("%.1f",a:sz/1000000000.0)."g"
   elseif a:sz >= 10000000
    let sz = printf("%d",a:sz/1000000)."m"
   elseif a:sz >= 1000000
    let sz = printf("%.1f",a:sz/1000000.0)."m"
   elseif a:sz >= 10000
    let sz = printf("%d",a:sz/1000)."k"
   elseif a:sz >= 1000
    let sz = printf("%.1f",a:sz/1000.0)."k"
   else
    let sz= a:sz
   endif

  elseif g:netrw_sizestyle == 'H'
   if a:sz >= 1073741824
    let sz = printf("%.1f",a:sz/1073741824.0)."G"
   elseif a:sz >= 10485760
    let sz = printf("%d",a:sz/1048576)."M"
   elseif a:sz >= 1048576
    let sz = printf("%.1f",a:sz/1048576.0)."M"
   elseif a:sz >= 10240
    let sz = printf("%d",a:sz/1024)."K"
   elseif a:sz >= 1024
    let sz = printf("%.1f",a:sz/1024.0)."K"
   else
    let sz= a:sz
   endif

  else
   let sz= a:sz
  endif

"  call Dret("s:NetrwHumanReadable ".sz)
  return sz
endfun

" ---------------------------------------------------------------------
" s:NetrwRestoreWordPosn: used to keep cursor on same word after refresh, {{{2
"  changed sorting, etc.  Also see s:NetrwSaveWordPosn().
fun! s:NetrwRestoreWordPosn()
"  call Dfunc("NetrwRestoreWordPosn()")
  sil! call search(s:netrw_saveword,'w')
"  call Dret("NetrwRestoreWordPosn")
endfun

" ---------------------------------------------------------------------
" s:RestoreBufVars: {{{2
fun! s:RestoreBufVars()
"  call Dfunc("s:RestoreBufVars()")

  if exists("s:netrw_curdir")        |let b:netrw_curdir         = s:netrw_curdir        |endif
  if exists("s:netrw_lastfile")      |let b:netrw_lastfile       = s:netrw_lastfile      |endif
  if exists("s:netrw_method")        |let b:netrw_method         = s:netrw_method        |endif
  if exists("s:netrw_fname")         |let b:netrw_fname          = s:netrw_fname         |endif
  if exists("s:netrw_machine")       |let b:netrw_machine        = s:netrw_machine       |endif
  if exists("s:netrw_browser_active")|let b:netrw_browser_active = s:netrw_browser_active|endif

"  call Dret("s:RestoreBufVars")
endfun

" ---------------------------------------------------------------------
" s:RemotePathAnalysis: {{{2
fun! s:RemotePathAnalysis(dirname)
"  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")

  "                method   ://    user  @      machine      :port            /path
  let dirpat  = '^\(\w\{-}\)://\(\(\w\+\)@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
  let s:method  = substitute(a:dirname,dirpat,'\1','')
  let s:user    = substitute(a:dirname,dirpat,'\3','')
  let s:machine = substitute(a:dirname,dirpat,'\4','')
  let s:port    = substitute(a:dirname,dirpat,'\5','')
  let s:path    = substitute(a:dirname,dirpat,'\6','')
  let s:fname   = substitute(s:path,'^.*/\ze.','','')
  if s:machine =~ '@'
   let dirpat    = '^\(.*\)@\(.\{-}\)$'
   let s:user    = s:user.'@'.substitute(s:machine,dirpat,'\1','')
   let s:machine = substitute(s:machine,dirpat,'\2','')
  endif

"  call Decho("set up s:method <".s:method .">",'~'.expand("<slnum>"))
"  call Decho("set up s:user   <".s:user   .">",'~'.expand("<slnum>"))
"  call Decho("set up s:machine<".s:machine.">",'~'.expand("<slnum>"))
"  call Decho("set up s:port   <".s:port.">",'~'.expand("<slnum>"))
"  call Decho("set up s:path   <".s:path   .">",'~'.expand("<slnum>"))
"  call Decho("set up s:fname  <".s:fname  .">",'~'.expand("<slnum>"))

"  call Dret("s:RemotePathAnalysis")
endfun

" ---------------------------------------------------------------------
" s:RemoteSystem: runs a command on a remote host using ssh {{{2
"                 Returns status
" Runs system() on
"    [cd REMOTEDIRPATH;] a:cmd
" Note that it doesn't do s:ShellEscape(a:cmd)!
fun! s:RemoteSystem(cmd)
"  call Dfunc("s:RemoteSystem(cmd<".a:cmd.">)")
  if !executable(g:netrw_ssh_cmd)
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"g:netrw_ssh_cmd<".g:netrw_ssh_cmd."> is not executable!",52)
  elseif !exists("b:netrw_curdir")
   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
  else
   let cmd      = s:MakeSshCmd(g:netrw_ssh_cmd." USEPORT HOSTNAME")
   let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
   if remotedir != ""
    let cmd= cmd.' cd '.s:ShellEscape(remotedir).";"
   else
    let cmd= cmd.' '
   endif
   let cmd= cmd.a:cmd
"   call Decho("call system(".cmd.")",'~'.expand("<slnum>"))
   let ret= system(cmd)
  endif
"  call Dret("s:RemoteSystem ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:RestoreWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:RestoreWinVars()
"  call Dfunc("s:RestoreWinVars()")
  if exists("s:bannercnt")      |let w:netrw_bannercnt       = s:bannercnt      |unlet s:bannercnt      |endif
  if exists("s:col")            |let w:netrw_col             = s:col            |unlet s:col            |endif
  if exists("s:curdir")         |let w:netrw_curdir          = s:curdir         |unlet s:curdir         |endif
  if exists("s:explore_bufnr")  |let w:netrw_explore_bufnr   = s:explore_bufnr  |unlet s:explore_bufnr  |endif
  if exists("s:explore_indx")   |let w:netrw_explore_indx    = s:explore_indx   |unlet s:explore_indx   |endif
  if exists("s:explore_line")   |let w:netrw_explore_line    = s:explore_line   |unlet s:explore_line   |endif
  if exists("s:explore_listlen")|let w:netrw_explore_listlen = s:explore_listlen|unlet s:explore_listlen|endif
  if exists("s:explore_list")   |let w:netrw_explore_list    = s:explore_list   |unlet s:explore_list   |endif
  if exists("s:explore_mtchcnt")|let w:netrw_explore_mtchcnt = s:explore_mtchcnt|unlet s:explore_mtchcnt|endif
  if exists("s:fpl")            |let w:netrw_fpl             = s:fpl            |unlet s:fpl            |endif
  if exists("s:hline")          |let w:netrw_hline           = s:hline          |unlet s:hline          |endif
  if exists("s:line")           |let w:netrw_line            = s:line           |unlet s:line           |endif
  if exists("s:liststyle")      |let w:netrw_liststyle       = s:liststyle      |unlet s:liststyle      |endif
  if exists("s:method")         |let w:netrw_method          = s:method         |unlet s:method         |endif
  if exists("s:prvdir")         |let w:netrw_prvdir          = s:prvdir         |unlet s:prvdir         |endif
  if exists("s:treedict")       |let w:netrw_treedict        = s:treedict       |unlet s:treedict       |endif
  if exists("s:treetop")        |let w:netrw_treetop         = s:treetop        |unlet s:treetop        |endif
  if exists("s:winnr")          |let w:netrw_winnr           = s:winnr          |unlet s:winnr          |endif
"  call Dret("s:RestoreWinVars")
endfun

" ---------------------------------------------------------------------
" s:Rexplore: implements returning from a buffer to a netrw directory {{{2
"
"             s:SetRexDir() sets up <2-leftmouse> maps (if g:netrw_retmap
"             is true) and a command, :Rexplore, which call this function.
"
"             s:netrw_nbcd is set up by s:NetrwBrowseChgDir()
"
"             s:rexposn_BUFNR used to save/restore cursor position
fun! s:NetrwRexplore(islocal,dirname)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir."> win#".winnr())
"  call Decho("currently in bufname<".bufname("%").">",'~'.expand("<slnum>"))
"  call Decho("ft=".&ft." win#".winnr()." w:netrw_rexfile<".(exists("w:netrw_rexfile")? w:netrw_rexfile : 'n/a').">",'~'.expand("<slnum>"))

  if &ft == "netrw" && exists("w:netrw_rexfile") && w:netrw_rexfile != ""
   " a :Rex while in a netrw buffer means: edit the file in w:netrw_rexfile
"   call Decho("in netrw buffer, will edit file<".w:netrw_rexfile.">",'~'.expand("<slnum>"))
   exe "NetrwKeepj e ".w:netrw_rexfile
   unlet w:netrw_rexfile
"   call Dret("s:NetrwRexplore returning from netrw to buf#".bufnr("%")."<".bufname("%").">  (ft=".&ft.")")
   return
"  else " Decho
"   call Decho("treating as not-netrw-buffer: ft=".&ft.((&ft == "netrw")? " == netrw" : "!= netrw"),'~'.expand("<slnum>"))
"   call Decho("treating as not-netrw-buffer: w:netrw_rexfile<".((exists("w:netrw_rexfile"))? w:netrw_rexfile : 'n/a').">",'~'.expand("<slnum>"))
  endif

  " ---------------------------
  " :Rex issued while in a file
  " ---------------------------

  " record current file so :Rex can return to it from netrw
  let w:netrw_rexfile= expand("%")
"  call Decho("set w:netrw_rexfile<".w:netrw_rexfile.">  (win#".winnr().")",'~'.expand("<slnum>"))

  if !exists("w:netrw_rexlocal")
"   call Dret("s:NetrwRexplore w:netrw_rexlocal doesn't exist (".&ft." win#".winnr().")")
   return
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
  if w:netrw_rexlocal
   NetrwKeepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
  else
   NetrwKeepj call s:NetrwBrowse(0,w:netrw_rexdir)
  endif
  if exists("s:initbeval")
   setl beval
  endif
  if exists("s:rexposn_".bufnr("%"))
"   call Decho("restore posn, then unlet s:rexposn_".bufnr('%')."<".bufname("%").">",'~'.expand("<slnum>"))
   " restore position in directory listing
"   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
   NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
   if exists("s:rexposn_".bufnr('%'))
    unlet s:rexposn_{bufnr('%')}
   endif
  else
"   call Decho("s:rexposn_".bufnr('%')."<".bufname("%")."> doesn't exist",'~'.expand("<slnum>"))
  endif

  if exists("s:explore_match")
   exe "2match netrwMarkFile /".s:explore_match."/"
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dret("s:NetrwRexplore : ft=".&ft)
endfun

" ---------------------------------------------------------------------
" s:SaveBufVars: save selected b: variables to s: variables {{{2
"                use s:RestoreBufVars() to restore b: variables from s: variables
fun! s:SaveBufVars()
"  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))

  if exists("b:netrw_curdir")        |let s:netrw_curdir         = b:netrw_curdir        |endif
  if exists("b:netrw_lastfile")      |let s:netrw_lastfile       = b:netrw_lastfile      |endif
  if exists("b:netrw_method")        |let s:netrw_method         = b:netrw_method        |endif
  if exists("b:netrw_fname")         |let s:netrw_fname          = b:netrw_fname         |endif
  if exists("b:netrw_machine")       |let s:netrw_machine        = b:netrw_machine       |endif
  if exists("b:netrw_browser_active")|let s:netrw_browser_active = b:netrw_browser_active|endif

"  call Dret("s:SaveBufVars")
endfun

" ---------------------------------------------------------------------
" s:SavePosn: saves position associated with current buffer into a dictionary {{{2
fun! s:SavePosn(posndict)
"  call Dfunc("s:SavePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")

  let a:posndict[bufnr("%")]= winsaveview()
"  call Decho("saving posn: posndict[".bufnr("%")."]=".string(winsaveview()),'~'.expand("<slnum>"))

"  call Dret("s:SavePosn posndict")
  return a:posndict
endfun

" ---------------------------------------------------------------------
" s:RestorePosn: restores position associated with current buffer using dictionary {{{2
fun! s:RestorePosn(posndict)
"  call Dfunc("s:RestorePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
  if has_key(a:posndict,bufnr("%"))
   call winrestview(a:posndict[bufnr("%")])
"   call Decho("restoring posn: posndict[".bufnr("%")."]=".string(a:posndict[bufnr("%")]),'~'.expand("<slnum>"))
  endif
"  call Dret("s:RestorePosn")
endfun

" ---------------------------------------------------------------------
" s:SaveWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:SaveWinVars()
"  call Dfunc("s:SaveWinVars() win#".winnr())
  if exists("w:netrw_bannercnt")      |let s:bannercnt       = w:netrw_bannercnt      |endif
  if exists("w:netrw_col")            |let s:col             = w:netrw_col            |endif
  if exists("w:netrw_curdir")         |let s:curdir          = w:netrw_curdir         |endif
  if exists("w:netrw_explore_bufnr")  |let s:explore_bufnr   = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_indx")   |let s:explore_indx    = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_line")   |let s:explore_line    = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_listlen")|let s:explore_listlen = w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |let s:explore_list    = w:netrw_explore_list   |endif
  if exists("w:netrw_explore_mtchcnt")|let s:explore_mtchcnt = w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_fpl")            |let s:fpl             = w:netrw_fpl            |endif
  if exists("w:netrw_hline")          |let s:hline           = w:netrw_hline          |endif
  if exists("w:netrw_line")           |let s:line            = w:netrw_line           |endif
  if exists("w:netrw_liststyle")      |let s:liststyle       = w:netrw_liststyle      |endif
  if exists("w:netrw_method")         |let s:method          = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let s:prvdir          = w:netrw_prvdir         |endif
  if exists("w:netrw_treedict")       |let s:treedict        = w:netrw_treedict       |endif
  if exists("w:netrw_treetop")        |let s:treetop         = w:netrw_treetop        |endif
  if exists("w:netrw_winnr")          |let s:winnr           = w:netrw_winnr          |endif
"  call Dret("s:SaveWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck()) {{{2
"   To allow separate windows to have their own activities, such as
"   Explore **/pattern, several variables have been made window-oriented.
"   However, when the user splits a browser window (ex: ctrl-w s), these
"   variables are not inherited by the new window.  SetBufWinVars() and
"   UseBufWinVars() get around that.
fun! s:SetBufWinVars()
"  call Dfunc("s:SetBufWinVars() win#".winnr())
  if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
  if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
  if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
  if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
"  call Dret("s:SetBufWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetRexDir: set directory for :Rexplore {{{2
fun! s:SetRexDir(islocal,dirname)
"  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">) win#".winnr())
  let w:netrw_rexdir         = a:dirname
  let w:netrw_rexlocal       = a:islocal
  let s:rexposn_{bufnr("%")} = winsaveview()
"  call Decho("setting w:netrw_rexdir  =".w:netrw_rexdir,'~'.expand("<slnum>"))
"  call Decho("setting w:netrw_rexlocal=".w:netrw_rexlocal,'~'.expand("<slnum>"))
"  call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
"  call Decho("setting s:rexposn_".bufnr("%")."<".bufname("%")."> to ".string(winsaveview()),'~'.expand("<slnum>"))
"  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)
endfun

" ---------------------------------------------------------------------
" s:ShowLink: used to modify thin and tree listings to show links {{{2
fun! s:ShowLink()
" "  call Dfunc("s:ShowLink()")
" "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">",'~'.expand("<slnum>"))
" "  call Decho(printf("line#%4d: %s",line("."),getline(".")),'~'.expand("<slnum>"))
  if exists("b:netrw_curdir")
   norm! $?\a
   let fname   = b:netrw_curdir.'/'.s:NetrwGetWord()
   let resname = resolve(fname)
" "   call Decho("fname         <".fname.">",'~'.expand("<slnum>"))
" "   call Decho("resname       <".resname.">",'~'.expand("<slnum>"))
" "   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
   if resname =~ '^\M'.b:netrw_curdir.'/'
    let dirlen  = strlen(b:netrw_curdir)
    let resname = strpart(resname,dirlen+1)
" "    call Decho("resname<".resname.">  (b:netrw_curdir elided)",'~'.expand("<slnum>"))
   endif
   let modline = getline(".")."\t --> ".resname
" "   call Decho("fname  <".fname.">",'~'.expand("<slnum>"))
" "   call Decho("modline<".modline.">",'~'.expand("<slnum>"))
   setl noro ma
   call setline(".",modline)
   setl ro noma nomod
  endif
" "  call Dret("s:ShowLink".((exists("fname")? ' : '.fname : 'n/a')))
endfun

" ---------------------------------------------------------------------
" s:ShowStyle: {{{2
fun! s:ShowStyle()
  if !exists("w:netrw_liststyle")
   let liststyle= g:netrw_liststyle
  else
   let liststyle= w:netrw_liststyle
  endif
  if     liststyle == s:THINLIST
   return s:THINLIST.":thin"
  elseif liststyle == s:LONGLIST
   return s:LONGLIST.":long"
  elseif liststyle == s:WIDELIST
   return s:WIDELIST.":wide"
  elseif liststyle == s:TREELIST
   return s:TREELIST.":tree"
  else
   return 'n/a'
  endif
endfun

" ---------------------------------------------------------------------
" s:Strlen: this function returns the length of a string, even if its using multi-byte characters. {{{2
"           Solution from Nicolai Weibull, vim docs (:help strlen()),
"           Tony Mechelynck, and my own invention.
fun! s:Strlen(x)
"  "" call Dfunc("s:Strlen(x<".a:x."> g:Align_xstrlen=".g:Align_xstrlen.")")

  if v:version >= 703 && exists("*strdisplaywidth")
   let ret= strdisplaywidth(a:x)

  elseif type(g:Align_xstrlen) == 1
   " allow user to specify a function to compute the string length  (ie. let g:Align_xstrlen="mystrlenfunc")
   exe "let ret= ".g:Align_xstrlen."('".substitute(a:x,"'","''","g")."')"

  elseif g:Align_xstrlen == 1
   " number of codepoints (Latin a + combining circumflex is two codepoints)
   " (comment from TM, solution from NW)
   let ret= strlen(substitute(a:x,'.','c','g'))

  elseif g:Align_xstrlen == 2
   " number of spacing codepoints (Latin a + combining circumflex is one spacing
   " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
   " (comment from TM, solution from TM)
   let ret=strlen(substitute(a:x, '.\Z', 'x', 'g'))

  elseif g:Align_xstrlen == 3
   " virtual length (counting, for instance, tabs as anything between 1 and
   " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately
   " preceded by lam, one otherwise, etc.)
   " (comment from TM, solution from me)
   let modkeep= &l:mod
   exe "norm! o\<esc>"
   call setline(line("."),a:x)
   let ret= virtcol("$") - 1
   d
   NetrwKeepj norm! k
   let &l:mod= modkeep

  else
   " at least give a decent default
    let ret= strlen(a:x)
  endif
"  "" call Dret("s:Strlen ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:ShellEscape: shellescape(), or special windows handling {{{2
fun! s:ShellEscape(s, ...)
  if (has('win32') || has('win64')) && $SHELL == '' && &shellslash
    return printf('"%s"', substitute(a:s, '"', '""', 'g'))
  endif 
  let f = a:0 > 0 ? a:1 : 0
  return shellescape(a:s, f)
endfun

" ---------------------------------------------------------------------
" s:TreeListMove: supports [[, ]], [], and ][ in tree mode {{{2
fun! s:TreeListMove(dir)
"  call Dfunc("s:TreeListMove(dir<".a:dir.">)")
  let curline      = getline('.')
  let prvline      = (line(".") > 1)?         getline(line(".")-1) : ''
  let nxtline      = (line(".") < line("$"))? getline(line(".")+1) : ''
  let curindent    = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
  let indentm1     = substitute(curindent,'^'.s:treedepthstring,'','')
  let treedepthchr = substitute(s:treedepthstring,' ','','g')
  let stopline     = exists("w:netrw_bannercnt")? w:netrw_bannercnt : 1
"  call Decho("prvline  <".prvline."> #".(line(".")-1), '~'.expand("<slnum>"))
"  call Decho("curline  <".curline."> #".line(".")    , '~'.expand("<slnum>"))
"  call Decho("nxtline  <".nxtline."> #".(line(".")+1), '~'.expand("<slnum>"))
"  call Decho("curindent<".curindent.">"              , '~'.expand("<slnum>"))
"  call Decho("indentm1 <".indentm1.">"               , '~'.expand("<slnum>"))
  "  COMBAK : need to handle when on a directory
  "  COMBAK : need to handle ]] and ][.  In general, needs work!!!
  if curline !~ '/$'
   if     a:dir == '[[' && prvline != ''
    NetrwKeepj norm! 0
    let nl = search('^'.indentm1.'\%('.s:treedepthstring.'\)\@!','bWe',stopline) " search backwards
"    call Decho("regfile srch back: ".nl,'~'.expand("<slnum>"))
   elseif a:dir == '[]' && nxtline != ''
    NetrwKeepj norm! 0
"    call Decho('srchpat<'.'^\%('.curindent.'\)\@!'.'>','~'.expand("<slnum>"))
    let nl = search('^\%('.curindent.'\)\@!','We') " search forwards
    if nl != 0
     NetrwKeepj norm! k
    else
     NetrwKeepj norm! G
    endif
"    call Decho("regfile srch fwd: ".nl,'~'.expand("<slnum>"))
   endif
  endif

"  call Dret("s:TreeListMove")
endfun

" ---------------------------------------------------------------------
" s:UpdateBuffersMenu: does emenu Buffers.Refresh (but due to locale, the menu item may not be called that) {{{2
"                      The Buffers.Refresh menu calls s:BMShow(); unfortunately, that means that that function
"                      can't be called except via emenu.  But due to locale, that menu line may not be called
"                      Buffers.Refresh; hence, s:NetrwBMShow() utilizes a "cheat" to call that function anyway.
fun! s:UpdateBuffersMenu()
"  call Dfunc("s:UpdateBuffersMenu()")
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   try
    sil emenu Buffers.Refresh\ menu
   catch /^Vim\%((\a\+)\)\=:E/
    let v:errmsg= ""
    sil NetrwKeepj call s:NetrwBMShow()
   endtry
  endif
"  call Dret("s:UpdateBuffersMenu")
endfun

" ---------------------------------------------------------------------
" s:UseBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck() {{{2
"              Matching function to s:SetBufWinVars()
fun! s:UseBufWinVars()
"  call Dfunc("s:UseBufWinVars()")
  if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
  if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
"  call Dret("s:UseBufWinVars")
endfun

" ---------------------------------------------------------------------
" s:UserMaps: supports user-defined UserMaps {{{2
"               * calls a user-supplied funcref(islocal,curdir)
"               * interprets result
"             See netrw#UserMaps()
fun! s:UserMaps(islocal,funcname)
"  call Dfunc("s:UserMaps(islocal=".a:islocal.",funcname<".a:funcname.">)")

  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
  endif
  let Funcref = function(a:funcname)
  let result  = Funcref(a:islocal)

  if     type(result) == 1
   " if result from user's funcref is a string...
"   call Decho("result string from user funcref<".result.">",'~'.expand("<slnum>"))
   if result == "refresh"
"    call Decho("refreshing display",'~'.expand("<slnum>"))
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   elseif result != ""
"    call Decho("executing result<".result.">",'~'.expand("<slnum>"))
    exe result
   endif

  elseif type(result) == 3
   " if result from user's funcref is a List...
"   call Decho("result List from user funcref<".string(result).">",'~'.expand("<slnum>"))
   for action in result
    if action == "refresh"
"     call Decho("refreshing display",'~'.expand("<slnum>"))
     call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
    elseif action != ""
"     call Decho("executing action<".action.">",'~'.expand("<slnum>"))
     exe action
    endif
   endfor
  endif

"  call Dret("s:UserMaps")
endfun

" ---------------------------------------------------------------------
" Settings Restoration: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo

" ------------------------------------------------------------------------
" Modelines: {{{1
" vim:ts=8 fdm=marker
                                                                                                                                                                                                                                                                                         /*
 *	Just a place holder. 
 */

#ifndef _UAPI_SPARC_SETUP_H
#define _UAPI_SPARC_SETUP_H

#if defined(__sparc__) && defined(__arch64__)
# define COMMAND_LINE_SIZE 2048
#else
# define COMMAND_LINE_SIZE 256
#endif


#endif /* _UAPI_SPARC_SETUP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _SPARC64_PSRCOMPAT_H
#define _SPARC64_PSRCOMPAT_H

#include <asm/pstate.h>

/* Old 32-bit PSR fields for the compatibility conversion code. */
#define PSR_CWP     0x0000001f         /* current window pointer     */
#define PSR_ET      0x00000020         /* enable traps field         */
#define PSR_PS      0x00000040         /* previous privilege level   */
#define PSR_S       0x00000080         /* current privilege level    */
#define PSR_PIL     0x00000f00         /* processor interrupt level  */
#define PSR_EF      0x00001000         /* enable floating point      */
#define PSR_EC      0x00002000         /* enable co-processor        */
#define PSR_SYSCALL 0x00004000         /* inside of a syscall        */
#define PSR_LE      0x00008000         /* SuperSparcII little-endian */
#define PSR_ICC     0x00f00000         /* integer condition codes    */
#define PSR_C       0x00100000         /* carry bit                  */
#define PSR_V       0x00200000         /* overflow bit               */
#define PSR_Z       0x00400000         /* zero bit                   */
#define PSR_N       0x00800000         /* negative bit               */
#define PSR_VERS    0x0f000000         /* cpu-version field          */
#define PSR_IMPL    0xf0000000         /* cpu-implementation field   */

#define PSR_V8PLUS  0xff000000         /* fake impl/ver, meaning a 64bit CPU is present */
#define PSR_XCC	    0x000f0000         /* if PSR_V8PLUS, this is %xcc */

static inline unsigned int tstate_to_psr(unsigned long tstate)
{
	return ((tstate & TSTATE_CWP)			|
		PSR_S					|
		((tstate & TSTATE_ICC) >> 12)		|
		((tstate & TSTATE_XCC) >> 20)		|
		((tstate & TSTATE_SYSCALL) ? PSR_SYSCALL : 0) |
		PSR_V8PLUS);
}

static inline unsigned long psr_to_tstate_icc(unsigned int psr)
{
	unsigned long tstate = ((unsigned long)(psr & PSR_ICC)) << 12;
	if ((psr & (PSR_VERS|PSR_IMPL)) == PSR_V8PLUS)
		tstate |= ((unsigned long)(psr & PSR_XCC)) << 20;
	return tstate;
}

#endif /* !(_SPARC64_PSRCOMPAT_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * include/asm/utrap.h
 *
 * Copyright (C) 1997 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
 */

#ifndef __ASM_SPARC64_UTRAP_H
#define __ASM_SPARC64_UTRAP_H

#define UT_INSTRUCTION_EXCEPTION		1
#define UT_INSTRUCTION_ERROR			2
#define UT_INSTRUCTION_PROTECTION		3
#define UT_ILLTRAP_INSTRUCTION			4
#define UT_ILLEGAL_INSTRUCTION			5
#define UT_PRIVILEGED_OPCODE			6
#define UT_FP_DISABLED				7
#define UT_FP_EXCEPTION_IEEE_754		8
#define UT_FP_EXCEPTION_OTHER			9
#define UT_TAG_OVERVIEW				10
#define UT_DIVISION_BY_ZERO			11
#define UT_DATA_EXCEPTION			12
#define UT_DATA_ERROR				13
#define UT_DATA_PROTECTION			14
#define UT_MEM_ADDRESS_NOT_ALIGNED		15
#define UT_PRIVILEGED_ACTION			16
#define UT_ASYNC_DATA_ERROR			17
#define UT_TRAP_INSTRUCTION_16			18
#define UT_TRAP_INSTRUCTION_17			19
#define UT_TRAP_INSTRUCTION_18			20
#define UT_TRAP_INSTRUCTION_19			21
#define UT_TRAP_INSTRUCTION_20			22
#define UT_TRAP_INSTRUCTION_21			23
#define UT_TRAP_INSTRUCTION_22			24
#define UT_TRAP_INSTRUCTION_23			25
#define UT_TRAP_INSTRUCTION_24			26
#define UT_TRAP_INSTRUCTION_25			27
#define UT_TRAP_INSTRUCTION_26			28
#define UT_TRAP_INSTRUCTION_27			29
#define UT_TRAP_INSTRUCTION_28			30
#define UT_TRAP_INSTRUCTION_29			31
#define UT_TRAP_INSTRUCTION_30			32
#define UT_TRAP_INSTRUCTION_31			33

#define	UTH_NOCHANGE				(-1)

#ifndef __ASSEMBLY__
typedef int utrap_entry_t;
typedef void *utrap_handler_t;
#endif /* __ASSEMBLY__ */

#endif /* !(__ASM_SPARC64_PROCESSOR_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _SPARC_FCNTL_H
#define _SPARC_FCNTL_H

#define O_APPEND	0x0008
#define FASYNC		0x0040	/* fcntl, for BSD compatibility */
#define O_CREAT		0x0200	/* not fcntl */
#define O_TRUNC		0x0400	/* not fcntl */
#define O_EXCL		0x0800	/* not fcntl */
#define O_DSYNC		0x2000	/* used to be O_SYNC, see below */
#define O_NONBLOCK	0x4000
#if defined(__sparc__) && defined(__arch64__)
#define O_NDELAY	0x0004
#else
#define O_NDELAY	(0x0004 | O_NONBLOCK)
#endif
#define O_NOCTTY	0x8000	/* not fcntl */
#define O_LARGEFILE	0x40000
#define O_DIRECT        0x100000 /* direct disk access hint */
#define O_NOATIME	0x200000
#define O_CLOEXEC	0x400000
/*
 * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using
 * the O_SYNC flag.  We continue to use the existing numerical value
 * for O_DSYNC semantics now, but using the correct symbolic name for it.
 * This new value is used to request true Posix O_SYNC semantics.  It is
 * defined in this strange way to make sure applications compiled against
 * new headers get at least O_DSYNC semantics on older kernels.
 *
 * This has the nice side-effect that we can simply test for O_DSYNC
 * wherever we do not care if O_DSYNC or O_SYNC is used.
 *
 * Note: __O_SYNC must never be used directly.
 */
#define __O_SYNC	0x800000
#define O_SYNC		(__O_SYNC|O_DSYNC)

#define O_PATH		0x1000000
#define __O_TMPFILE	0x2000000

#define F_GETOWN	5	/*  for sockets. */
#define F_SETOWN	6	/*  for sockets. */
#define F_GETLK		7
#define F_SETLK		8
#define F_SETLKW	9

/* for posix fcntl() and lockf() */
#define F_RDLCK		1
#define F_WRLCK		2
#define F_UNLCK		3

#define __ARCH_FLOCK_PAD	short __unused;
#define __ARCH_FLOCK64_PAD	short __unused;

#include <asm-generic/fcntl.h>

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _SPARC_IOCTL_H
#define _SPARC_IOCTL_H

/*
 * Our DIR and SIZE overlap in order to simulteneously provide
 * a non-zero _IOC_NONE (for binary compatibility) and
 * 14 bits of size as on i386. Here's the layout:
 *
 *   0xE0000000   DIR
 *   0x80000000     DIR = WRITE
 *   0x40000000     DIR = READ
 *   0x20000000     DIR = NONE
 *   0x3FFF0000   SIZE (overlaps NONE bit)
 *   0x0000FF00   TYPE
 *   0x000000FF   NR (CMD)
 */

#define _IOC_NRBITS      8
#define _IOC_TYPEBITS    8
#define _IOC_SIZEBITS   13	/* Actually 14, see below. */
#define _IOC_DIRBITS     3

#define _IOC_NRMASK      ((1 << _IOC_NRBITS)-1)
#define _IOC_TYPEMASK    ((1 << _IOC_TYPEBITS)-1)
#define _IOC_SIZEMASK    ((1 << _IOC_SIZEBITS)-1)
#define _IOC_XSIZEMASK   ((1 << (_IOC_SIZEBITS+1))-1)
#define _IOC_DIRMASK     ((1 << _IOC_DIRBITS)-1)

#define _IOC_NRSHIFT     0
#define _IOC_TYPESHIFT   (_IOC_NRSHIFT + _IOC_NRBITS)
#define _IOC_SIZESHIFT   (_IOC_TYPESHIFT + _IOC_TYPEBITS)
#define _IOC_DIRSHIFT    (_IOC_SIZESHIFT + _IOC_SIZEBITS)

#define _IOC_NONE        1U
#define _IOC_READ        2U
#define _IOC_WRITE       4U

#define _IOC(dir,type,nr,size) \
        (((dir)  << _IOC_DIRSHIFT) | \
         ((type) << _IOC_TYPESHIFT) | \
         ((nr)   << _IOC_NRSHIFT) | \
         ((size) << _IOC_SIZESHIFT))

#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))

/* Used to decode ioctl numbers in drivers despite the leading underscore... */
#define _IOC_DIR(nr)    \
 ( (((((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK) & (_IOC_WRITE|_IOC_READ)) != 0)?   \
                            (((nr) >> _IOC_DIRSHIFT) & (_IOC_WRITE|_IOC_READ)):  \
                            (((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK) )
#define _IOC_TYPE(nr)       (((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
#define _IOC_NR(nr)         (((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
#define _IOC_SIZE(nr)   \
 ((((((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK) & (_IOC_WRITE|_IOC_READ)) == 0)?    \
                         0: (((nr) >> _IOC_SIZESHIFT) & _IOC_XSIZEMASK))

/* ...and for the PCMCIA and sound. */
#define IOC_IN          (_IOC_WRITE << _IOC_DIRSHIFT)
#define IOC_OUT         (_IOC_READ << _IOC_DIRSHIFT)
#define IOC_INOUT       ((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
#define IOCSIZE_MASK    (_IOC_XSIZEMASK << _IOC_SIZESHIFT)
#define IOCSIZE_SHIFT   (_IOC_SIZESHIFT)

#endif /* !(_SPARC_IOCTL_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * System calls under the Sparc.
 *
 * Don't be scared by the ugly clobbers, it is the only way I can
 * think of right now to force the arguments into fixed registers
 * before the trap into the system call with gcc 'asm' statements.
 *
 * Copyright (C) 1995, 2007 David S. Miller (davem@davemloft.net)
 *
 * SunOS compatibility based upon preliminary work which is:
 *
 * Copyright (C) 1995 Adrian M. Rodriguez (adrian@remus.rutgers.edu)
 */
#ifndef _UAPI_SPARC_UNISTD_H
#define _UAPI_SPARC_UNISTD_H

#ifndef __32bit_syscall_numbers__
#ifndef __arch64__
#define __32bit_syscall_numbers__
#endif
#endif

#define __NR_restart_syscall      0 /* Linux Specific				   */
#define __NR_exit                 1 /* Common                                      */
#define __NR_fork                 2 /* Common                                      */
#define __NR_read                 3 /* Common                                      */
#define __NR_write                4 /* Common                                      */
#define __NR_open                 5 /* Common                                      */
#define __NR_close                6 /* Common                                      */
#define __NR_wait4                7 /* Common                                      */
#define __NR_creat                8 /* Common                                      */
#define __NR_link                 9 /* Common                                      */
#define __NR_unlink              10 /* Common                                      */
#define __NR_execv               11 /* SunOS Specific                              */
#define __NR_chdir               12 /* Common                                      */
#define __NR_chown		 13 /* Common					   */
#define __NR_mknod               14 /* Common                                      */
#define __NR_chmod               15 /* Common                                      */
#define __NR_lchown              16 /* Common                                      */
#define __NR_brk                 17 /* Common                                      */
#define __NR_perfctr             18 /* Performance counter operations              */
#define __NR_lseek               19 /* Common                                      */
#define __NR_getpid              20 /* Common                                      */
#define __NR_capget		 21 /* Linux Specific				   */
#define __NR_capset		 22 /* Linux Specific				   */
#define __NR_setuid              23 /* Implemented via setreuid in SunOS           */
#define __NR_getuid              24 /* Common                                      */
#define __NR_vmsplice	         25 /* ENOSYS under SunOS			   */
#define __NR_ptrace              26 /* Common                                      */
#define __NR_alarm               27 /* Implemented via setitimer in SunOS          */
#define __NR_sigaltstack	 28 /* Common					   */
#define __NR_pause               29 /* Is sigblock(0)->sigpause() in SunOS         */
#define __NR_utime               30 /* Implemented via utimes() under SunOS        */
#ifdef __32bit_syscall_numbers__
#define __NR_lchown32            31 /* Linux sparc32 specific                      */
#define __NR_fchown32            32 /* Linux sparc32 specific                      */
#endif
#define __NR_access              33 /* Common                                      */
#define __NR_nice                34 /* Implemented via get/setpriority() in SunOS  */
#ifdef __32bit_syscall_numbers__
#define __NR_chown32             35 /* Linux sparc32 specific                      */
#endif
#define __NR_sync                36 /* Common                                      */
#define __NR_kill                37 /* Common                                      */
#define __NR_stat                38 /* Common                                      */
#define __NR_sendfile		 39 /* Linux Specific				   */
#define __NR_lstat               40 /* Common                                      */
#define __NR_dup                 41 /* Common                                      */
#define __NR_pipe                42 /* Common                                      */
#define __NR_times               43 /* Implemented via getrusage() in SunOS        */
#ifdef __32bit_syscall_numbers__
#define __NR_getuid32            44 /* Linux sparc32 specific                      */
#endif
#define __NR_umount2             45 /* Linux Specific                              */
#define __NR_setgid              46 /* Implemented via setregid() in SunOS         */
#define __NR_getgid              47 /* Common                                      */
#define __NR_signal              48 /* Implemented via sigvec() in SunOS           */
#define __NR_geteuid             49 /* SunOS calls getuid()                        */
#define __NR_getegid             50 /* SunOS calls getgid()                        */
#define __NR_acct                51 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_getgid32            53 /* Linux sparc32 specific                      */
#else
#define __NR_memory_ordering	 52 /* Linux Specific				   */
#endif
#define __NR_ioctl               54 /* Common                                      */
#define __NR_reboot              55 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_mmap2		 56 /* Linux sparc32 Specific			   */
#endif
#define __NR_symlink             57 /* Common                                      */
#define __NR_readlink            58 /* Common                                      */
#define __NR_execve              59 /* Common                                      */
#define __NR_umask               60 /* Common                                      */
#define __NR_chroot              61 /* Common                                      */
#define __NR_fstat               62 /* Common                                      */
#define __NR_fstat64		 63 /* Linux Specific			           */
#define __NR_getpagesize         64 /* Common                                      */
#define __NR_msync               65 /* Common in newer 1.3.x revs...               */
#define __NR_vfork               66 /* Common                                      */
#define __NR_pread64             67 /* Linux Specific                              */
#define __NR_pwrite64            68 /* Linux Specific                              */
#ifdef __32bit_syscall_numbers__
#define __NR_geteuid32           69 /* Linux sparc32, sbrk under SunOS             */
#define __NR_getegid32           70 /* Linux sparc32, sstk under SunOS             */
#endif
#define __NR_mmap                71 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_setreuid32          72 /* Linux sparc32, vadvise under SunOS          */
#endif
#define __NR_munmap              73 /* Common                                      */
#define __NR_mprotect            74 /* Common                                      */
#define __NR_madvise             75 /* Common                                      */
#define __NR_vhangup             76 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_truncate64		 77 /* Linux sparc32 Specific			   */
#endif
#define __NR_mincore             78 /* Common                                      */
#define __NR_getgroups           79 /* Common                                      */
#define __NR_setgroups           80 /* Common                                      */
#define __NR_getpgrp             81 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_setgroups32         82 /* Linux sparc32, setpgrp under SunOS          */
#endif
#define __NR_setitimer           83 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_ftruncate64	 84 /* Linux sparc32 Specific			   */
#endif
#define __NR_swapon              85 /* Common                                      */
#define __NR_getitimer           86 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_setuid32            87 /* Linux sparc32, gethostname under SunOS      */
#endif
#define __NR_sethostname         88 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_setgid32            89 /* Linux sparc32, getdtablesize under SunOS    */
#endif
#define __NR_dup2                90 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_setfsuid32          91 /* Linux sparc32, getdopt under SunOS          */
#endif
#define __NR_fcntl               92 /* Common                                      */
#define __NR_select              93 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_setfsgid32          94 /* Linux sparc32, setdopt under SunOS          */
#endif
#define __NR_fsync               95 /* Common                                      */
#define __NR_setpriority         96 /* Common                                      */
#define __NR_socket              97 /* Common                                      */
#define __NR_connect             98 /* Common                                      */
#define __NR_accept              99 /* Common                                      */
#define __NR_getpriority        100 /* Common                                      */
#define __NR_rt_sigreturn       101 /* Linux Specific                              */
#define __NR_rt_sigaction       102 /* Linux Specific                              */
#define __NR_rt_sigprocmask     103 /* Linux Specific                              */
#define __NR_rt_sigpending      104 /* Linux Specific                              */
#define __NR_rt_sigtimedwait    105 /* Linux Specific                              */
#define __NR_rt_sigqueueinfo    106 /* Linux Specific                              */
#define __NR_rt_sigsuspend      107 /* Linux Specific                              */
#ifdef __32bit_syscall_numbers__
#define __NR_setresuid32        108 /* Linux Specific, sigvec under SunOS	   */
#define __NR_getresuid32        109 /* Linux Specific, sigblock under SunOS	   */
#define __NR_setresgid32        110 /* Linux Specific, sigsetmask under SunOS	   */
#define __NR_getresgid32        111 /* Linux Specific, sigpause under SunOS	   */
#define __NR_setregid32         112 /* Linux sparc32, sigstack under SunOS         */
#else
#define __NR_setresuid          108 /* Linux Specific, sigvec under SunOS	   */
#define __NR_getresuid          109 /* Linux Specific, sigblock under SunOS	   */
#define __NR_setresgid          110 /* Linux Specific, sigsetmask under SunOS	   */
#define __NR_getresgid          111 /* Linux Specific, sigpause under SunOS	   */
#endif
#define __NR_recvmsg            113 /* Common                                      */
#define __NR_sendmsg            114 /* Common                                      */
#ifdef __32bit_syscall_numbers__
#define __NR_getgroups32        115 /* Linux sparc32, vtrace under SunOS           */
#endif
#define __NR_gettimeofday       116 /* Common                                      */
#define __NR_getrusage          117 /* Common                                      */
#define __NR_getsockopt         118 /* Common                                      */
#define __NR_getcwd		119 /* Linux Specific				   */
#define __NR_readv              120 /* Common                                      */
#define __NR_writev             121 /* Common                                      */
#define __NR_settimeofday       122 /* Common                                      */
#define __NR_fchown             123 /* Common                                      */
#define __NR_fchmod             124 /* Common                                      */
#define __NR_recvfrom           125 /* Common                                      */
#define __NR_setreuid           126 /* Common                                      */
#define __NR_setregid           127 /* Common                                      */
#define __NR_rename             128 /* Common                                      */
#define __NR_truncate           129 /* Common                                      */
#define __NR_ftruncate          130 /* Common                                      */
#define __NR_flock              131 /* Common                                      */
#define __NR_lstat64		132 /* Linux Specific			           */
#define __NR_sendto             133 /* Common                                      */
#define __NR_shutdown           134 /* Common                                      */
#define __NR_socketpair         135 /* Common                                      */
#define __NR_mkdir              136 /* Common                                      */
#define __NR_rmdir              137 /* Common                                      */
#define __NR_utimes             138 /* SunOS Specific                              */
#define __NR_stat64		139 /* Linux Specific			           */
#define __NR_sendfile64         140 /* adjtime under SunOS                         */
#define __NR_getpeername        141 /* Common                                      */
#define __NR_futex              142 /* gethostid under SunOS                       */
#define __NR_gettid             143 /* ENOSYS under SunOS                          */
#define __NR_getrlimit		144 /* Common                                      */
#define __NR_setrlimit          145 /* Common                                      */
#define __NR_pivot_root		146 /* Linux Specific, killpg under SunOS          */
#define __NR_prctl		147 /* ENOSYS under SunOS                          */
#define __NR_pciconfig_read	148 /* ENOSYS under SunOS                          */
#define __NR_pciconfig_write	149 /* ENOSYS under SunOS                          */
#define __NR_getsockname        150 /* Common                                      */
#define __NR_inotify_init       151 /* Linux specific                              */
#define __NR_inotify_add_watch  152 /* Linux specific                              */
#define __NR_poll               153 /* Common                                      */
#define __NR_getdents64		154 /* Linux specific				   */
#ifdef __32bit_syscall_numbers__
#define __NR_fcntl64		155 /* Linux sparc32 Specific                      */
#endif
#define __NR_inotify_rm_watch   156 /* Linux specific				   */
#define __NR_statfs             157 /* Common                                      */
#define __NR_fstatfs            158 /* Common                                      */
#define __NR_umount             159 /* Common                                      */
#define __NR_sched_set_affinity 160 /* Linux specific, async_daemon under SunOS    */
#define __NR_sched_get_affinity 161 /* Linux specific, getfh under SunOS           */
#define __NR_getdomainname      162 /* SunOS Specific                              */
#define __NR_setdomainname      163 /* Common                                      */
#ifndef __32bit_syscall_numbers__
#define __NR_utrap_install	164 /* SYSV ABI/v9 required			   */
#endif
#define __NR_quotactl           165 /* Common                                      */
#define __NR_set_tid_address    166 /* Linux specific, exportfs under SunOS        */
#define __NR_mount              167 /* Common                                      */
#define __NR_ustat              168 /* Common                                      */
#define __NR_setxattr           169 /* SunOS: semsys                               */
#define __NR_lsetxattr          170 /* SunOS: msgsys                               */
#define __NR_fsetxattr          171 /* SunOS: shmsys                               */
#define __NR_getxattr           172 /* SunOS: auditsys                             */
#define __NR_lgetxattr          173 /* SunOS: rfssys                               */
#define __NR_getdents           174 /* Common                                      */
#define __NR_setsid             175 /* Common                                      */
#define __NR_fchdir             176 /* Common                                      */
#define __NR_fgetxattr          177 /* SunOS: fchroot                              */
#define __NR_listxattr          178 /* SunOS: vpixsys                              */
#define __NR_llistxattr         179 /* SunOS: aioread                              */
#define __NR_flistxattr         180 /* SunOS: aiowrite                             */
#define __NR_removexattr        181 /* SunOS: aiowait                              */
#define __NR_lremovexattr       182 /* SunOS: aiocancel                            */
#define __NR_sigpending         183 /* Common                                      */
#define __NR_query_module	184 /* Linux Specific				   */
#define __NR_setpgid            185 /* Common                                      */
#define __NR_fremovexattr       186 /* SunOS: pathconf                             */
#define __NR_tkill              187 /* SunOS: fpathconf                            */
#define __NR_exit_group		188 /* Linux specific, sysconf undef SunOS         */
#define __NR_uname              189 /* Linux Specific                              */
#define __NR_init_module        190 /* Linux Specific                              */
#define __NR_personality        191 /* Linux Specific                              */
#define __NR_remap_file_pages   192 /* Linux Specific                              */
#define __NR_epoll_create       193 /* Linux Specific                              */
#define __NR_epoll_ctl          194 /* Linux Specific                              */
#define __NR_epoll_wait         195 /* Linux Specific                              */
#define __NR_ioprio_set         196 /* Linux Specific                              */
#define __NR_getppid            197 /* Linux Specific                              */
#define __NR_sigaction          198 /* Linux Specific                              */
#define __NR_sgetmask           199 /* Linux Specific                              */
#define __NR_ssetmask           200 /* Linux Specific                              */
#define __NR_sigsuspend         201 /* Linux Specific                              */
#define __NR_oldlstat           202 /* Linux Specific                              */
#define __NR_uselib             203 /* Linux Specific                              */
#define __NR_readdir            204 /* Linux Specific                              */
#define __NR_readahead          205 /* Linux Specific                              */
#define __NR_socketcall         206 /* Linux Specific                              */
#define __NR_syslog             207 /* Linux Specific                              */
#define __NR_lookup_dcookie     208 /* Linux Specific                              */
#define __NR_fadvise64          209 /* Linux Specific                              */
#define __NR_fadvise64_64       210 /* Linux Specific                              */
#define __NR_tgkill             211 /* Linux Specific                              */
#define __NR_waitpid            212 /* Linux Specific                              */
#define __NR_swapoff            213 /* Linux Specific                              */
#define __NR_sysinfo            214 /* Linux Specific                              */
#define __NR_ipc                215 /* Linux Specific                              */
#define __NR_sigreturn          216 /* Linux Specific                              */
#define __NR_clone              217 /* Linux Specific                              */
#define __NR_ioprio_get         218 /* Linux Specific                              */
#define __NR_adjtimex           219 /* Linux Specific                              */
#define __NR_sigprocmask        220 /* Linux Specific                              */
#define __NR_create_module      221 /* Linux Specific                              */
#define __NR_delete_module      222 /* Linux Specific                              */
#define __NR_get_kernel_syms    223 /* Linux Specific                              */
#define __NR_getpgid            224 /* Linux Specific                              */
#define __NR_bdflush            225 /* Linux Specific                              */
#define __NR_sysfs              226 /* Linux Specific                              */
#define __NR_afs_syscall        227 /* Linux Specific                              */
#define __NR_setfsuid           228 /* Linux Specific                              */
#define __NR_setfsgid           229 /* Linux Specific                              */
#define __NR__newselect         230 /* Linux Specific                              */
#ifdef __32bit_syscall_numbers__
#define __NR_time               231 /* Linux Specific                              */
#else
#endif
#define __NR_splice             232 /* Linux Specific                              */
#define __NR_stime              233 /* Linux Specific                              */
#define __NR_statfs64           234 /* Linux Specific                              */
#define __NR_fstatfs64          235 /* Linux Specific                              */
#define __NR__llseek            236 /* Linux Specific                              */
#define __NR_mlock              237
#define __NR_munlock            238
#define __NR_mlockall           239
#define __NR_munlockall         240
#define __NR_sched_setparam     241
#define __NR_sched_getparam     242
#define __NR_sched_setscheduler 243
#define __NR_sched_getscheduler 244
#define __NR_sched_yield        245
#define __NR_sched_get_priority_max 246
#define __NR_sched_get_priority_min 247
#define __NR_sched_rr_get_interval  248
#define __NR_nanosleep          249
#define __NR_mremap             250
#define __NR__sysctl            251
#define __NR_getsid             252
#define __NR_fdatasync          253
#define __NR_nfsservctl         254
#define __NR_sync_file_range	255
#define __NR_clock_settime	256
#define __NR_clock_gettime	257
#define __NR_clock_getres	258
#define __NR_clock_nanosleep	259
#define __NR_sched_getaffinity	260
#define __NR_sched_setaffinity	261
#define __NR_timer_settime	262
#define __NR_timer_gettime	263
#define __NR_timer_getoverrun	264
#define __NR_timer_delete	265
#define __NR_timer_create	266
/* #define __NR_vserver		267 Reserved for VSERVER */
#define __NR_io_setup		268
#define __NR_io_destroy		269
#define __NR_io_submit		270
#define __NR_io_cancel		271
#define __NR_io_getevents	272
#define __NR_mq_open		273
#define __NR_mq_unlink		274
#define __NR_mq_timedsend	275
#define __NR_mq_timedreceive	276
#define __NR_mq_notify		277
#define __NR_mq_getsetattr	278
#define __NR_waitid		279
#define __NR_tee		280
#define __NR_add_key		281
#define __NR_request_key	282
#define __NR_keyctl		283
#define __NR_openat		284
#define __NR_mkdirat		285
#define __NR_mknodat		286
#define __NR_fchownat		287
#define __NR_futimesat		288
#define __NR_fstatat64		289
#define __NR_unlinkat		290
#define __NR_renameat		291
#define __NR_linkat		292
#define __NR_symlinkat		293
#define __NR_readlinkat		294
#define __NR_fchmodat		295
#define __NR_faccessat		296
#define __NR_pselect6		297
#define __NR_ppoll		298
#define __NR_unshare		299
#define __NR_set_robust_list	300
#define __NR_get_robust_list	301
#define __NR_migrate_pages	302
#define __NR_mbind		303
#define __NR_get_mempolicy	304
#define __NR_set_mempolicy	305
#define __NR_kexec_load		306
#define __NR_move_pages		307
#define __NR_getcpu		308
#define __NR_epoll_pwait	309
#define __NR_utimensat		310
#define __NR_signalfd		311
#define __NR_timerfd_create	312
#define __NR_eventfd		313
#define __NR_fallocate		314
#define __NR_timerfd_settime	315
#define __NR_timerfd_gettime	316
#define __NR_signalfd4		317
#define __NR_eventfd2		318
#define __NR_epoll_create1	319
#define __NR_dup3		320
#define __NR_pipe2		321
#define __NR_inotify_init1	322
#define __NR_accept4		323
#define __NR_preadv		324
#define __NR_pwritev		325
#define __NR_rt_tgsigqueueinfo	326
#define __NR_perf_event_open	327
#define __NR_recvmmsg		328
#define __NR_fanotify_init	329
#define __NR_fanotify_mark	330
#define __NR_prlimit64		331
#define __NR_name_to_handle_at	332
#define __NR_open_by_handle_at	333
#define __NR_clock_adjtime	334
#define __NR_syncfs		335
#define __NR_sendmmsg		336
#define __NR_setns		337
#define __NR_process_vm_readv	338
#define __NR_process_vm_writev	339
#define __NR_kern_features	340
#define __NR_kcmp		341
#define __NR_finit_module	342
#define __NR_sched_setattr	343
#define __NR_sched_getattr	344
#define __NR_renameat2		345
#define __NR_seccomp		346
#define __NR_getrandom		347
#define __NR_memfd_create	348
#define __NR_bpf		349
#define __NR_execveat		350
#define __NR_membarrier		351
#define __NR_userfaultfd	352
#define __NR_bind		353
#define __NR_listen		354
#define __NR_setsockopt		355
#define __NR_mlock2		356
#define __NR_copy_file_range	357
#define __NR_preadv2		358
#define __NR_pwritev2		359

#define NR_syscalls		360

/* Bitmask values returned from kern_features system call.  */
#define KERN_FEATURE_MIXED_MODE_STACK	0x00000001

#ifdef __32bit_syscall_numbers__
/* Sparc 32-bit only has the "setresuid32", "getresuid32" variants,
 * it never had the plain ones and there is no value to adding those
 * old versions into the syscall table.
 */
#define __IGNORE_setresuid
#define __IGNORE_getresuid
#define __IGNORE_setresgid
#define __IGNORE_getresgid
#endif

#endif /* _UAPI_SPARC_UNISTD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _SPARC_SHMBUF_H
#define _SPARC_SHMBUF_H

/* 
 * The shmid64_ds structure for sparc architecture.
 * Note extra padding because this structure is passed back and forth
 * between kernel and user space.
 *
 * Pad space is left for:
 * - 64-bit time_t to solve y2038 problem
 * - 2 miscellaneous 32-bit values
 */

#if defined(__sparc__) && defined(__arch64__)
# define PADDING(x)
#else
# define PADDING(x) unsigned int x;
#endif

struct shmid64_ds {
	struct ipc64_perm	shm_perm;	/* operation perms */
	PADDING(__pad1)
	__kernel_time_t		shm_atime;	/* last attach time */
	PADDING(__pad2)
	__kernel_time_t		shm_dtime;	/* last detach time */
	PADDING(__pad3)
	__kernel_time_t		shm_ctime;	/* last change time */
	size_t			shm_segsz;	/* size of segment (bytes) */
	__kernel_pid_t		shm_cpid;	/* pid of creator */
	__kernel_pid_t		shm_lpid;	/* pid of last operator */
	unsigned long		shm_nattch;	/* no. of current attaches */
	unsigned long		__unused1;
	unsigned long		__unused2;
};

struct shminfo64 {
	unsigned long	shmmax;
	unsigned long	shmmin;
	unsigned long	shmmni;
	unsigned long	shmseg;
	unsigned long	shmall;
	unsigned long	__unused1;
	unsigned long	__unused2;
	unsigned long	__unused3;
	unsigned long	__unused4;
};

#undef PADDING

#endif /* _SPARC_SHMBUF_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* apc - Driver definitions for power management functions
 * of Aurora Personality Chip (APC) on SPARCstation-4/5 and 
 * derivatives
 *
 * Copyright (c) 2001 Eric Brower (ebrower@usa.net)
 *
 */

#ifndef _SPARC_APC_H
#define _SPARC_APC_H

#include <linux/ioctl.h>

#define APC_IOC	'A'

#define APCIOCGFANCTL _IOR(APC_IOC, 0x00, int)	/* Get fan speed	*/
#define APCIOCSFANCTL _IOW(APC_IOC, 0x01, int)	/* Set fan speed	*/

#define APCIOCGCPWR   _IOR(APC_IOC, 0x02, int)	/* Get CPOWER state	*/
#define APCIOCSCPWR   _IOW(APC_IOC, 0x03, int)	/* Set CPOWER state	*/

#define APCIOCGBPORT   _IOR(APC_IOC, 0x04, int)	/* Get BPORT state 	*/
#define APCIOCSBPORT   _IOW(APC_IOC, 0x05, int)	/* Set BPORT state	*/

/*
 * Register offsets
 */
#define APC_IDLE_REG	0x00
#define APC_FANCTL_REG	0x20
#define APC_CPOWER_REG	0x24
#define APC_BPORT_REG	0x30

#define APC_REGMASK		0x01
#define APC_BPMASK		0x03

/*
 * IDLE - CPU standby values (set to initiate standby)
 */
#define APC_IDLE_ON		0x01

/*
 * FANCTL - Fan speed control state values
 */
#define APC_FANCTL_HI	0x00	/* Fan speed high	*/
#define APC_FANCTL_LO	0x01	/* Fan speed low	*/

/*
 * CPWR - Convenience power outlet state values 
 */
#define APC_CPOWER_ON	0x00	/* Conv power on	*/
#define APC_CPOWER_OFF	0x01	/* Conv power off	*/

/*
 * BPA/BPB - Read-Write "Bit Ports" state values (reset to 0 at power-on)
 *
 * WARNING: Internal usage of bit ports is platform dependent--
 * don't modify BPORT settings unless you know what you are doing.
 * 
 * On SS5 BPA seems to toggle onboard ethernet loopback... -E
 */
#define APC_BPORT_A		0x01	/* Bit Port A		*/
#define APC_BPORT_B		0x02	/* Bit Port B		*/

#endif /* !(_SPARC_APC_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Makefile for the Sun Boot PROM interface library under
# Linux.
#
asflags := -ansi
ccflags := -Werror

lib-y                 := bootstr_$(BITS).o
lib-y                 += init_$(BITS).o
lib-$(CONFIG_SPARC32) += memory.o
lib-y                 += misc_$(BITS).o
lib-$(CONFIG_SPARC32) += mp.o
lib-$(CONFIG_SPARC32) += ranges.o
lib-y                 += console_$(BITS).o
lib-y                 += printf.o
lib-y                 += tree_$(BITS).o
lib-$(CONFIG_SPARC64) += p1275.o
lib-$(CONFIG_SPARC64) += cif.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #
# Makefile for the FPU instruction emulation.
#

# suppress all warnings - as math.c produces a lot!
ccflags-y := -w

obj-y    := math_$(BITS).o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #
# Arch-specific network modules
#
obj-$(CONFIG_BPF_JIT) += bpf_jit_asm.o bpf_jit_comp.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Makefile for the linux Sparc-specific parts of the memory manager.
#

asflags-y := -ansi
ccflags-y := -Werror

obj-$(CONFIG_SPARC64)   += ultra.o tlb.o tsb.o gup.o
obj-y                   += fault_$(BITS).o
obj-y                   += init_$(BITS).o
obj-$(CONFIG_SPARC32)   += extable.o srmmu.o iommu.o io-unit.o
obj-$(CONFIG_SPARC32)   += srmmu_access.o
obj-$(CONFIG_SPARC32)   += hypersparc.o viking.o tsunami.o swift.o
obj-$(CONFIG_SPARC32)   += leon_mm.o

# Only used by sparc64
obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpage.o

# Only used by sparc32
obj-$(CONFIG_HIGHMEM)   += highmem.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   obj-$(CONFIG_OPROFILE) += oprofile.o

DRIVER_OBJS = $(addprefix ../../../drivers/oprofile/, \
		oprof.o cpu_buffer.o buffer_sync.o \
		event_buffer.o oprofile_files.o \
		oprofilefs.o oprofile_stats.o \
		timer_int.o )

oprofile-y				:= $(DRIVER_OBJS) init.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Makefile for the Sparc boot stuff.
#
# Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
# Copyright (C) 1997,1998 Jakub Jelinek (jj@ultra.linux.cz)

ROOT_IMG	:= /usr/src/root.img
ELFTOAOUT	:= elftoaout

hostprogs-y	:= piggyback
targets		:= tftpboot.img image zImage vmlinux.aout
clean-files	:= System.map

quiet_cmd_elftoaout	= ELFTOAOUT $@
      cmd_elftoaout	= $(ELFTOAOUT) $(obj)/image -o $@
quiet_cmd_piggy		= PIGGY   $@
      cmd_piggy		= $(obj)/piggyback $(BITS) $@ System.map $(ROOT_IMG)
quiet_cmd_strip		= STRIP   $@
      cmd_strip		= $(STRIP) -R .comment -R .note -K sun4u_init -K _end -K _start $< -o $@

ifeq ($(CONFIG_SPARC64),y)

# Actual linking

$(obj)/zImage: $(obj)/image
	$(call if_changed,gzip)
	@echo '  kernel: $@ is ready'

$(obj)/vmlinux.aout: vmlinux FORCE
	$(call if_changed,elftoaout)
	@echo '  kernel: $@ is ready'
else

$(obj)/zImage: $(obj)/image
	$(call if_changed,strip)
	@echo '  kernel: $@ is ready'

# The following lines make a readable image for U-Boot.
#  uImage   - Binary file read by U-boot
#  uImage.o - object file of uImage for loading with a
#             flash programmer understanding ELF.

OBJCOPYFLAGS_image.bin := -S -O binary -R .note -R .comment
$(obj)/image.bin: $(obj)/image FORCE
	$(call if_changed,objcopy)

$(obj)/image.gz: $(obj)/image.bin
	$(call if_changed,gzip)

UIMAGE_LOADADDR = $(CONFIG_UBOOT_LOAD_ADDR)
UIMAGE_ENTRYADDR = $(CONFIG_UBOOT_ENTRY_ADDR)
UIMAGE_COMPRESSION = gzip

quiet_cmd_uimage.o = UIMAGE.O $@
      cmd_uimage.o = $(LD) -Tdata $(CONFIG_UBOOT_FLASH_ADDR) \
                     -r -b binary $@ -o $@.o

targets += uImage
$(obj)/uImage: $(obj)/image.gz
	$(call if_changed,uimage)
	$(call if_changed,uimage.o)
	@echo '  Image $@ is ready'

endif

$(obj)/image: vmlinux FORCE
	$(call if_changed,strip)
	@echo '  kernel: $@ is ready'

$(obj)/tftpboot.img: $(obj)/image $(obj)/piggyback System.map $(ROOT_IMG) FORCE
	$(call if_changed,elftoaout)
	$(call if_changed,piggy)

install:
	sh $(srctree)/$(src)/install.sh $(KERNELRELEASE) $(obj)/zImage \
		System.map "$(INSTALL_PATH)"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #
# arch/blackfin/mach-bf561/Makefile
#

obj-y := ints-priority.o dma.o

obj-$(CONFIG_BF561_COREB) += coreb.o
obj-$(CONFIG_SMP)  += smp.o secondary.o atomic.o
obj-$(CONFIG_HOTPLUG_CPU) += hotplug.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if (BF561)

source "arch/blackfin/mach-bf561/boards/Kconfig"

menu "BF561 Specific Configuration"

if (!SMP)

comment "Core B Support"

config BF561_COREB
	bool "Enable Core B loader"
	default y

endif

comment "Interrupt Priority Assignment"

menu "Priority"

config IRQ_PLL_WAKEUP
	int "PLL Wakeup Interrupt"
	default 7
config IRQ_DMA1_ERROR
	int "DMA1 Error (generic)"
	default 7
config IRQ_DMA2_ERROR
	int "DMA2 Error (generic)"
	default 7
config IRQ_IMDMA_ERROR
	int "IMDMA Error (generic)"
	default 7
config IRQ_PPI0_ERROR
	int "PPI0 Error Interrupt"
	default 7
config IRQ_PPI1_ERROR
	int "PPI1 Error Interrupt"
	default 7
config IRQ_SPORT0_ERROR
	int "SPORT0 Error Interrupt"
	default 7
config IRQ_SPORT1_ERROR
	int "SPORT1 Error Interrupt"
	default 7
config IRQ_SPI_ERROR
	int "SPI Error Interrupt"
	default 7
config IRQ_UART_ERROR
	int "UART Error Interrupt"
	default 7
config IRQ_RESERVED_ERROR
	int "Reserved Interrupt"
	default 7
config IRQ_DMA1_0
	int "DMA1 0  Interrupt(PPI1)"
	default 8
config IRQ_DMA1_1
	int "DMA1 1  Interrupt(PPI2)"
	default 8
config IRQ_DMA1_2
	int "DMA1 2  Interrupt"
	default 8
config IRQ_DMA1_3
	int "DMA1 3  Interrupt"
	default 8
config IRQ_DMA1_4
	int "DMA1 4  Interrupt"
	default 8
config IRQ_DMA1_5
	int "DMA1 5  Interrupt"
	default 8
config IRQ_DMA1_6
	int "DMA1 6  Interrupt"
	default 8
config IRQ_DMA1_7
	int "DMA1 7  Interrupt"
	default 8
config IRQ_DMA1_8
	int "DMA1 8  Interrupt"
	default 8
config IRQ_DMA1_9
	int "DMA1 9  Interrupt"
	default 8
config IRQ_DMA1_10
	int "DMA1 10 Interrupt"
	default 8
config IRQ_DMA1_11
	int "DMA1 11 Interrupt"
	default 8
config IRQ_DMA2_0
	int "DMA2 0  (SPORT0 RX)"
	default 9
config IRQ_DMA2_1
	int "DMA2 1  (SPORT0 TX)"
	default 9
config IRQ_DMA2_2
	int "DMA2 2  (SPORT1 RX)"
	default 9
config IRQ_DMA2_3
	int "DMA2 3  (SPORT2 TX)"
	default 9
config IRQ_DMA2_4
	int "DMA2 4  (SPI)"
	default 9
config IRQ_DMA2_5
	int "DMA2 5  (UART RX)"
	default 9
config IRQ_DMA2_6
	int "DMA2 6  (UART TX)"
	default 9
config IRQ_DMA2_7
	int "DMA2 7  Interrupt"
	default 9
config IRQ_DMA2_8
	int "DMA2 8  Interrupt"
	default 9
config IRQ_DMA2_9
	int "DMA2 9  Interrupt"
	default 9
config IRQ_DMA2_10
	int "DMA2 10 Interrupt"
	default 9
config IRQ_DMA2_11
	int "DMA2 11 Interrupt"
	default 9
config IRQ_TIMER0
	int "TIMER 0  Interrupt"
	default 7 if TICKSOURCE_GPTMR0
	default 8
config IRQ_TIMER1
	int "TIMER 1  Interrupt"
	default 10
config IRQ_TIMER2
	int "TIMER 2  Interrupt"
	default 10
config IRQ_TIMER3
	int "TIMER 3  Interrupt"
	default 10
config IRQ_TIMER4
	int "TIMER 4  Interrupt"
	default 10
config IRQ_TIMER5
	int "TIMER 5  Interrupt"
	default 10
config IRQ_TIMER6
	int "TIMER 6  Interrupt"
	default 10
config IRQ_TIMER7
	int "TIMER 7  Interrupt"
	default 10
config IRQ_TIMER8
	int "TIMER 8  Interrupt"
	default 10
config IRQ_TIMER9
	int "TIMER 9  Interrupt"
	default 10
config IRQ_TIMER10
	int "TIMER 10 Interrupt"
	default 10
config IRQ_TIMER11
	int "TIMER 11 Interrupt"
	default 10
config IRQ_PROG0_INTA
	int "Programmable Flags0 A (8)"
	default 11
config IRQ_PROG0_INTB
	int "Programmable Flags0 B (8)"
	default 11
config IRQ_PROG1_INTA
	int "Programmable Flags1 A (8)"
	default 11
config IRQ_PROG1_INTB
	int "Programmable Flags1 B (8)"
	default 11
config IRQ_PROG2_INTA
	int "Programmable Flags2 A (8)"
	default 11
config IRQ_PROG2_INTB
	int "Programmable Flags2 B (8)"
	default 11
config IRQ_DMA1_WRRD0
	int "MDMA1 0 write/read INT"
	default 8
config IRQ_DMA1_WRRD1
	int "MDMA1 1 write/read INT"
	default 8
config IRQ_DMA2_WRRD0
	int "MDMA2 0 write/read INT"
	default 9
config IRQ_DMA2_WRRD1
	int "MDMA2 1 write/read INT"
	default 9
config IRQ_IMDMA_WRRD0
	int "IMDMA 0 write/read INT"
	default 12
config IRQ_IMDMA_WRRD1
	int "IMDMA 1 write/read INT"
	default 12
config IRQ_WDTIMER
	int "Watch Dog Timer"
	default 13

	help
	  Enter the priority numbers between 7-13 ONLY.  Others are Reserved.
	  This applies to all the above.  It is not recommended to assign the
	  highest priority number 7 to UART or any other device.

endmenu

endmenu

endif
                                                               #
# arch/blackfin/mach-bf561/boards/Makefile
#

obj-$(CONFIG_BFIN561_ACVILON)          += acvilon.o
obj-$(CONFIG_BFIN561_BLUETECHNIX_CM)   += cm_bf561.o
obj-$(CONFIG_BFIN561_EZKIT)            += ezkit.o
obj-$(CONFIG_BFIN561_TEPLA)            += tepla.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   choice
	prompt "System type"
	default BFIN561_EZKIT
	help
	  Select your board!

config BFIN561_EZKIT
	bool "BF561-EZKIT"
	help
	  BF561-EZKIT-LITE board support.

config BFIN561_TEPLA
	bool "BF561-TEPLA"
	help
	 BF561-TEPLA board support.

config BFIN561_BLUETECHNIX_CM
	bool "Bluetechnix CM-BF561"
	help
	  CM-BF561 support for EVAL- and DEV-Board.

config BFIN561_ACVILON
	bool "BF561-ACVILON"
	help
	  BF561-ACVILON System On Module support (SO-DIMM 144).
	  For more information about Acvilon BF561 SoM
	  please go to http://www.niistt.ru/

endchoice
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #
# arch/blackfin/lib/Makefile
#

lib-y := \
	ashldi3.o ashrdi3.o lshrdi3.o \
	muldi3.o divsi3.o udivsi3.o modsi3.o umodsi3.o \
	memcpy.o memset.o memcmp.o memchr.o memmove.o \
	strcmp.o strcpy.o strncmp.o strncpy.o \
	umulsi3_highpart.o smulsi3_highpart.o \
	ins.o outs.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #
# arch/blackfin/mach-bf537/Makefile
#

obj-y := ints-priority.o dma.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        config BF542
	def_bool y
	depends on BF542_std || BF542M
config BF544
	def_bool y
	depends on BF544_std || BF544M
config BF547
	def_bool y
	depends on BF547_std || BF547M
config BF548
	def_bool y
	depends on BF548_std || BF548M
config BF549
	def_bool y
	depends on BF549_std || BF549M

config BF54xM
	def_bool y
	depends on (BF542M || BF544M || BF547M || BF548M || BF549M)

config BF54x
	def_bool y
	depends on (BF542 || BF544 || BF547 || BF548 || BF549)

if (BF54x)

source "arch/blackfin/mach-bf548/boards/Kconfig"

menu "BF548 Specific Configuration"

config DEB_DMA_URGENT
	bool "DMA has priority over core for ext. accesses"
	depends on BF54x
	default y
	help
	  Treat any DEB1, DEB2 and DEB3 request as Urgent

config BF548_ATAPI_ALTERNATIVE_PORT
	bool "BF548 ATAPI alternative port via GPIO"
	help
	  BF548 ATAPI data and address PINs can be routed through
	  async address or GPIO port F and G. Select y to route it
	  to GPIO.

choice
	prompt "UART2 DMA channel selection"
	depends on SERIAL_BFIN_UART2
	default UART2_DMA_RX_ON_DMA18
	help
		UART2 DMA channel selection
		RX -> DMA18
		TX -> DMA19
		or
		RX -> DMA13
		TX -> DMA14

config UART2_DMA_RX_ON_DMA18
	bool "UART2 DMA RX -> DMA18 TX -> DMA19"
	help
		UART2 DMA channel assignment
		RX -> DMA18
		TX -> DMA19
		use SPORT2 default DMA channel

config UART2_DMA_RX_ON_DMA13
	bool "UART2 DMA RX -> DMA13 TX -> DMA14"
	help
		UART2 DMA channel assignment
		RX -> DMA13
		TX -> DMA14
		use EPPI1 EPPI2 default DMA channel
endchoice

choice
	prompt "UART3 DMA channel selection"
	depends on SERIAL_BFIN_UART3
	default UART3_DMA_RX_ON_DMA20
	help
		UART3 DMA channel selection
		RX -> DMA20
		TX -> DMA21
		or
		RX -> DMA15
		TX -> DMA16

config UART3_DMA_RX_ON_DMA20
	bool "UART3 DMA RX -> DMA20 TX -> DMA21"
	help
		UART3 DMA channel assignment
		RX -> DMA20
		TX -> DMA21
		use SPORT3 default DMA channel

config UART3_DMA_RX_ON_DMA15
	bool "UART3 DMA RX -> DMA15 TX -> DMA16"
	help
		UART3 DMA channel assignment
		RX -> DMA15
		TX -> DMA16
		use PIXC default DMA channel

endchoice

comment "Interrupt Priority Assignment"
menu "Priority"

config IRQ_PLL_WAKEUP
	int "IRQ_PLL_WAKEUP"
	default 7
config IRQ_DMAC0_ERR
	int "IRQ_DMAC0_ERR"
	default 7
config IRQ_EPPI0_ERR
	int "IRQ_EPPI0_ERR"
	default 7
config IRQ_SPORT0_ERR
	int "IRQ_SPORT0_ERR"
	default 7
config IRQ_SPORT1_ERR
	int "IRQ_SPORT1_ERR"
	default 7
config IRQ_SPI0_ERR
	int "IRQ_SPI0_ERR"
	default 7
config IRQ_UART0_ERR
	int "IRQ_UART0_ERR"
	default 7
config IRQ_RTC
	int "IRQ_RTC"
	default 8
config IRQ_EPPI0
	int "IRQ_EPPI0"
	default 8
config IRQ_SPORT0_RX
	int "IRQ_SPORT0_RX"
	default 9
config IRQ_SPORT0_TX
	int "IRQ_SPORT0_TX"
	default 9
config IRQ_SPORT1_RX
	int "IRQ_SPORT1_RX"
	default 9
config IRQ_SPORT1_TX
	int "IRQ_SPORT1_TX"
	default 9
config IRQ_SPI0
	int "IRQ_SPI0"
	default 10
config IRQ_UART0_RX
	int "IRQ_UART0_RX"
	default 10
config IRQ_UART0_TX
	int "IRQ_UART0_TX"
	default 10
config IRQ_TIMER8
	int "IRQ_TIMER8"
	default 11
config IRQ_TIMER9
	int "IRQ_TIMER9"
	default 11
config IRQ_TIMER10
	int "IRQ_TIMER10"
	default 11
config IRQ_PINT0
	int "IRQ_PINT0"
	default 12
config IRQ_PINT1
	int "IRQ_PINT0"
	default 12
config IRQ_MDMAS0
	int "IRQ_MDMAS0"
	default 13
config IRQ_MDMAS1
	int "IRQ_DMDMAS1"
	default 13
config IRQ_WATCHDOG
	int "IRQ_WATCHDOG"
	default 13
config IRQ_DMAC1_ERR
	int "IRQ_DMAC1_ERR"
	default 7
config IRQ_SPORT2_ERR
	int "IRQ_SPORT2_ERR"
	default 7
config IRQ_SPORT3_ERR
	int "IRQ_SPORT3_ERR"
	default 7
config IRQ_MXVR_DATA
	int "IRQ MXVR Data"
	default 7
config IRQ_SPI1_ERR
	int "IRQ_SPI1_ERR"
	default 7
config IRQ_SPI2_ERR
	int "IRQ_SPI2_ERR"
	default 7
config IRQ_UART1_ERR
	int "IRQ_UART1_ERR"
	default 7
config IRQ_UART2_ERR
	int "IRQ_UART2_ERR"
	default 7
config IRQ_CAN0_ERR
	int "IRQ_CAN0_ERR"
	default 7
config IRQ_SPORT2_RX
	int "IRQ_SPORT2_RX"
	default 9
config IRQ_SPORT2_TX
	int "IRQ_SPORT2_TX"
	default 9
config IRQ_SPORT3_RX
	int "IRQ_SPORT3_RX"
	default 9
config IRQ_SPORT3_TX
	int "IRQ_SPORT3_TX"
	default 9
config IRQ_EPPI1
	int "IRQ_EPPI1"
	default 9
config IRQ_EPPI2
	int "IRQ_EPPI2"
	default 9
config IRQ_SPI1
	int "IRQ_SPI1"
	default 10
config IRQ_SPI2
	int "IRQ_SPI2"
	default 10
config IRQ_UART1_RX
	int "IRQ_UART1_RX"
	default 10
config IRQ_UART1_TX
	int "IRQ_UART1_TX"
	default 10
config IRQ_ATAPI_RX
	int "IRQ_ATAPI_RX"
	default 10
config IRQ_ATAPI_TX
	int "IRQ_ATAPI_TX"
	default 10
config IRQ_TWI0
	int "IRQ_TWI0"
	default 11
config IRQ_TWI1
	int "IRQ_TWI1"
	default 11
config IRQ_CAN0_RX
	int "IRQ_CAN_RX"
	default 11
config IRQ_CAN0_TX
	int "IRQ_CAN_TX"
	default 11
config IRQ_MDMAS2
	int "IRQ_MDMAS2"
	default 13
config IRQ_MDMAS3
	int "IRQ_DMMAS3"
	default 13
config IRQ_MXVR_ERR
	int "IRQ_MXVR_ERR"
	default 11
config IRQ_MXVR_MSG
	int "IRQ_MXVR_MSG"
	default 11
config IRQ_MXVR_PKT
	int "IRQ_MXVR_PKT"
	default 11
config IRQ_EPPI1_ERR
	int "IRQ_EPPI1_ERR"
	default 7
config IRQ_EPPI2_ERR
	int "IRQ_EPPI2_ERR"
	default 7
config IRQ_UART3_ERR
	int "IRQ_UART3_ERR"
	default 7
config IRQ_HOST_ERR
	int "IRQ_HOST_ERR"
	default 7
config IRQ_PIXC_ERR
	int "IRQ_PIXC_ERR"
	default 7
config IRQ_NFC_ERR
	int "IRQ_NFC_ERR"
	default 7
config IRQ_ATAPI_ERR
	int "IRQ_ATAPI_ERR"
	default 7
config IRQ_CAN1_ERR
	int "IRQ_CAN1_ERR"
	default 7
config IRQ_HS_DMA_ERR
	int "IRQ Handshake DMA Status"
	default 7
config IRQ_PIXC_IN0
	int "IRQ PIXC IN0"
	default 8
config IRQ_PIXC_IN1
	int "IRQ PIXC IN1"
	default 8
config IRQ_PIXC_OUT
	int "IRQ PIXC OUT"
	default 8
config IRQ_SDH
	int "IRQ SDH"
	default 8
config IRQ_CNT
	int "IRQ CNT"
	default 8
config IRQ_KEY
	int "IRQ KEY"
	default 8
config IRQ_CAN1_RX
	int "IRQ CAN1 RX"
	default 11
config IRQ_CAN1_TX
	int "IRQ_CAN1_TX"
	default 11
config IRQ_SDH_MASK0
	int "IRQ_SDH_MASK0"
	default 11
config IRQ_SDH_MASK1
	int "IRQ_SDH_MASK1"
	default 11
config IRQ_USB_INT0
	int "IRQ USB INT0"
	default 11
config IRQ_USB_INT1
	int "IRQ USB INT1"
	default 11
config IRQ_USB_INT2
	int "IRQ USB INT2"
	default 11
config IRQ_USB_DMA
	int "IRQ USB DMA"
	default 11
config IRQ_OTPSEC
	int "IRQ OPTSEC"
	default 11
config IRQ_TIMER0
	int "IRQ_TIMER0"
	default 7 if TICKSOURCE_GPTMR0
	default 8
config IRQ_TIMER1
	int "IRQ_TIMER1"
	default 11
config IRQ_TIMER2
	int "IRQ_TIMER2"
	default 11
config IRQ_TIMER3
	int "IRQ_TIMER3"
	default 11
config IRQ_TIMER4
	int "IRQ_TIMER4"
	default 11
config IRQ_TIMER5
	int "IRQ_TIMER5"
	default 11
config IRQ_TIMER6
	int "IRQ_TIMER6"
	default 11
config IRQ_TIMER7
	int "IRQ_TIMER7"
	default 11
config IRQ_PINT2
	int "IRQ_PIN2"
	default 11
config IRQ_PINT3
	int "IRQ_PIN3"
	default 11

	help
	  Enter the priority numbers between 7-13 ONLY.  Others are Reserved.
	  This applies to all the above.  It is not recommended to assign the
	  highest priority number 7 to UART or any other device.

endmenu

endmenu

endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #
# arch/blackfin/mach-bf548/boards/Makefile
#

obj-$(CONFIG_BFIN548_EZKIT)            += ezkit.o
obj-$(CONFIG_BFIN548_BLUETECHNIX_CM)   += cm_bf548.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         choice
	prompt "System type"
	default BFIN548_EZKIT
	help
	  Select your board!

config BFIN548_EZKIT
	bool "BF548-EZKIT"
	help
	  BFIN548-EZKIT board support.
	  
config BFIN548_BLUETECHNIX_CM
	bool "Bluetechnix CM-BF548"
	depends on (BF548)
	help
	  CM-BF548 support for DEV-Board.	  

endchoice
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *editing.txt*   For Vim version 8.0.  Last change: 2016 Nov 24


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Editing files						*edit-files*

1.  Introduction		|edit-intro|
2.  Editing a file		|edit-a-file|
3.  The argument list		|argument-list|
4.  Writing			|writing|
5.  Writing and quitting	|write-quit|
6.  Dialogs			|edit-dialogs|
7.  The current directory	|current-directory|
8.  Editing binary files	|edit-binary|
9.  Encryption			|encryption|
10. Timestamps			|timestamps|
11. File Searching		|file-searching|

==============================================================================
1. Introduction						*edit-intro*

Editing a file with Vim means:

1. reading the file into a buffer
2. changing the buffer with editor commands
3. writing the buffer into a file

							*current-file*
As long as you don't write the buffer, the original file remains unchanged.
If you start editing a file (read a file into the buffer), the file name is
remembered as the "current file name".  This is also known as the name of the
current buffer.  It can be used with "%" on the command line |:_%|.

							*alternate-file*
If there already was a current file name, then that one becomes the alternate
file name.  It can be used with "#" on the command line |:_#| and you can use
the |CTRL-^| command to toggle between the current and the alternate file.
However, the alternate file name is not changed when |:keepalt| is used.
An alternate file name is remembered for each window.

							*:keepalt* *:keepa*
:keepalt {cmd}		Execute {cmd} while keeping the current alternate file
			name.  Note that commands invoked indirectly (e.g.,
			with a function) may still set the alternate file
			name.  {not in Vi}

All file names are remembered in the buffer list.  When you enter a file name,
for editing (e.g., with ":e filename") or writing (e.g., with ":w filename"),
the file name is added to the list.  You can use the buffer list to remember
which files you edited and to quickly switch from one file to another (e.g.,
to copy text) with the |CTRL-^| command.  First type the number of the file
and then hit CTRL-^.  {Vi: only one alternate file name is remembered}


CTRL-G		or				*CTRL-G* *:f* *:fi* *:file*
:f[ile]			Prints the current file name (as typed, unless ":cd"
			was used), the cursor position (unless the 'ruler'
			option is set), and the file status (readonly,
			modified, read errors, new file).  See the 'shortmess'
			option about how to make this message shorter.
			{Vi does not include column number}

:f[ile]!		like |:file|, but don't truncate the name even when
			'shortmess' indicates this.

{count}CTRL-G		Like CTRL-G, but prints the current file name with
			full path.  If the count is higher than 1 the current
			buffer number is also given.  {not in Vi}

					*g_CTRL-G* *word-count* *byte-count*
g CTRL-G		Prints the current position of the cursor in five
			ways: Column, Line, Word, Character and Byte.  If the
			number of Characters and Bytes is the same then the
			Character position is omitted.
			If there are characters in the line that take more
			than one position on the screen (<Tab> or special
			character), both the "real" column and the screen
			column are shown, separated with a dash.
			Also see the 'ruler' option and the |wordcount()|
			function.
			{not in Vi}

							*v_g_CTRL-G*
{Visual}g CTRL-G	Similar to "g CTRL-G", but Word, Character, Line, and
			Byte counts for the visually selected region are
			displayed.
			In Blockwise mode, Column count is also shown.  (For
			{Visual} see |Visual-mode|.)
			{not in VI}

							*:file_f*
:f[ile][!] {name}	Sets the current file name to {name}.  The optional !
			avoids truncating the message, as with |:file|.
			If the buffer did have a name, that name becomes the
			|alternate-file| name.  An unlisted buffer is created
			to hold the old name.
							*:0file*
:0f[ile][!]		Remove the name of the current buffer.  The optional !
			avoids truncating the message, as with |:file|.  {not
			in Vi}

:buffers
:files
:ls			List all the currently known file names.  See
			'windows.txt' |:files| |:buffers| |:ls|.  {not in
			Vi}

Vim will remember the full path name of a file name that you enter.  In most
cases when the file name is displayed only the name you typed is shown, but
the full path name is being used if you used the ":cd" command |:cd|.

							*home-replace*
If the environment variable $HOME is set, and the file name starts with that
string, it is often displayed with HOME replaced with "~".  This was done to
keep file names short.  When reading or writing files the full name is still
used, the "~" is only used when displaying file names.  When replacing the
file name would result in just "~", "~/" is used instead (to avoid confusion
between options set to $HOME with 'backupext' set to "~").

When writing the buffer, the default is to use the current file name.  Thus
when you give the "ZZ" or ":wq" command, the original file will be
overwritten.  If you do not want this, the buffer can be written into another
file by giving a file name argument to the ":write" command.  For example: >

	vim testfile
	[change the buffer with editor commands]
	:w newfile
	:q

This will create a file "newfile", that is a modified copy of "testfile".
The file "testfile" will remain unchanged.  Anyway, if the 'backup' option is
set, Vim renames or copies the original file before it will be overwritten.
You can use this file if you discover that you need the original file.  See
also the 'patchmode' option.  The name of the backup file is normally the same
as the original file with 'backupext' appended.  The default "~" is a bit
strange to avoid accidentally overwriting existing files.  If you prefer ".bak"
change the 'backupext' option.  Extra dots are replaced with '_' on MS-DOS
machines, when Vim has detected that an MS-DOS-like filesystem is being used
(e.g., messydos or crossdos) or when the 'shortname' option is on.  The
backup file can be placed in another directory by setting 'backupdir'.

							*auto-shortname*
Technical: On the Amiga you can use 30 characters for a file name.  But on an
	   MS-DOS-compatible filesystem only 8 plus 3 characters are
	   available.  Vim tries to detect the type of filesystem when it is
	   creating the .swp file.  If an MS-DOS-like filesystem is suspected,
	   a flag is set that has the same effect as setting the 'shortname'
	   option.  This flag will be reset as soon as you start editing a
	   new file.  The flag will be used when making the file name for the
	   ".swp" and ".~" files for the current file.  But when you are
	   editing a file in a normal filesystem and write to an MS-DOS-like
	   filesystem the flag will not have been set.  In that case the
	   creation of the ".~" file may fail and you will get an error
	   message.  Use the 'shortname' option in this case.

When you started editing without giving a file name, "No File" is displayed in
messages.  If the ":write" command is used with a file name argument, the file
name for the current file is set to that file name.  This only happens when
the 'F' flag is included in 'cpoptions' (by default it is included) |cpo-F|.
This is useful when entering text in an empty buffer and then writing it to a
file.  If 'cpoptions' contains the 'f' flag (by default it is NOT included)
|cpo-f| the file name is set for the ":read file" command.  This is useful
when starting Vim without an argument and then doing ":read file" to start
editing a file.
When the file name was set and 'filetype' is empty the filetype detection
autocommands will be triggered.
							*not-edited*
Because the file name was set without really starting to edit that file, you
are protected from overwriting that file.  This is done by setting the
"notedited" flag.  You can see if this flag is set with the CTRL-G or ":file"
command.  It will include "[Not edited]" when the "notedited" flag is set.
When writing the buffer to the current file name (with ":w!"), the "notedited"
flag is reset.

							*abandon*
Vim remembers whether you have changed the buffer.  You are protected from
losing the changes you made.  If you try to quit without writing, or want to
start editing another file, Vim will refuse this.  In order to overrule this
protection, add a '!' to the command.  The changes will then be lost.  For
example: ":q" will not work if the buffer was changed, but ":q!" will.  To see
whether the buffer was changed use the "CTRL-G" command.  The message includes
the string "[Modified]" if the buffer has been changed, or "+" if the 'm' flag
is in 'shortmess'.

If you want to automatically save the changes without asking, switch on the
'autowriteall' option.  'autowrite' is the associated Vi-compatible option
that does not work for all commands.

If you want to keep the changed buffer without saving it, switch on the
'hidden' option.  See |hidden-buffer|.  Some commands work like this even when
'hidden' is not set, check the help for the command.

==============================================================================
2. Editing a file					*edit-a-file*

							*:e* *:edit* *reload*
:e[dit] [++opt] [+cmd]	Edit the current file.  This is useful to re-edit the
			current file, when it has been changed outside of Vim.
			This fails when changes have been made to the current
			buffer and 'autowriteall' isn't set or the file can't
			be written.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

							*:edit!* *discard*
:e[dit]! [++opt] [+cmd]
			Edit the current file always.  Discard any changes to
			the current buffer.  This is useful if you want to
			start all over again.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

							*:edit_f*
:e[dit] [++opt] [+cmd] {file}
			Edit {file}.
			This fails when changes have been made to the current
			buffer, unless 'hidden' is set or 'autowriteall' is
			set and the file can be written.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

							*:edit!_f*
:e[dit]! [++opt] [+cmd] {file}
			Edit {file} always.  Discard any changes to the
			current buffer.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

:e[dit] [++opt] [+cmd] #[count]
			Edit the [count]th buffer (as shown by |:files|).
			This command does the same as [count] CTRL-^.  But ":e
			#" doesn't work if the alternate buffer doesn't have a
			file name, while CTRL-^ still works then.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

							*:ene* *:enew*
:ene[w]			Edit a new, unnamed buffer.  This fails when changes
			have been made to the current buffer, unless 'hidden'
			is set or 'autowriteall' is set and the file can be
			written.
			If 'fileformats' is not empty, the first format given
			will be used for the new buffer.  If 'fileformats' is
			empty, the 'fileformat' of the current buffer is used.
			{not in Vi}

							*:ene!* *:enew!*
:ene[w]!		Edit a new, unnamed buffer.  Discard any changes to
			the current buffer.
			Set 'fileformat' like |:enew|.
			{not in Vi}

							*:fin* *:find*
:fin[d][!] [++opt] [+cmd] {file}
			Find {file} in 'path' and then |:edit| it.
			{not in Vi} {not available when the |+file_in_path|
			feature was disabled at compile time}

:{count}fin[d][!] [++opt] [+cmd] {file}
			Just like ":find", but use the {count} match in
			'path'.  Thus ":2find file" will find the second
			"file" found in 'path'.  When there are fewer matches
			for the file in 'path' than asked for, you get an
			error message.

							*:ex*
:ex [++opt] [+cmd] [file]
			Same as |:edit|.

							*:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [file]
			When used in Ex mode: Leave |Ex-mode|, go back to
			Normal mode.  Otherwise same as |:edit|.

							*:vie* *:view*
:vie[w][!] [++opt] [+cmd] file
			When used in Ex mode: Leave |Ex mode|, go back to
			Normal mode.  Otherwise same as |:edit|, but set
			'readonly' option for this buffer.  {not in Vi}

							*CTRL-^* *CTRL-6*
CTRL-^			Edit the alternate file.  Mostly the alternate file is
			the previously edited file.  This is a quick way to
			toggle between two files.  It is equivalent to ":e #",
			except that it also works when there is no file name.

			If the 'autowrite' or 'autowriteall' option is on and
			the buffer was changed, write it.
			Mostly the ^ character is positioned on the 6 key,
			pressing CTRL and 6 then gets you what we call CTRL-^.
			But on some non-US keyboards CTRL-^ is produced in
			another way.

{count}CTRL-^		Edit [count]th file in the buffer list (equivalent to
			":e #[count]").  This is a quick way to switch between
			files.
			See |CTRL-^| above for further details.
			{not in Vi}

[count]]f						*]f* *[f*
[count][f		Same as "gf".  Deprecated.

							*gf* *E446* *E447*
[count]gf		Edit the file whose name is under or after the cursor.
			Mnemonic: "goto file".
			Uses the 'isfname' option to find out which characters
			are supposed to be in a file name.  Trailing
			punctuation characters ".,:;!" are ignored. Escaped
			spaces "\ " are reduced to a single space.
			Uses the 'path' option as a list of directory names to
			look for the file.  See the 'path' option for details
			about relative directories and wildcards.
			Uses the 'suffixesadd' option to check for file names
			with a suffix added.
			If the file can't be found, 'includeexpr' is used to
			modify the name and another attempt is done.
			If a [count] is given, the count'th file that is found
			in the 'path' is edited.
			This command fails if Vim refuses to |abandon| the
			current file.
			If you want to edit the file in a new window use
			|CTRL-W_CTRL-F|.
			If you do want to edit a new file, use: >
				:e <cfile>
<			To make gf always work like that: >
				:map gf :e <cfile><CR>
<			If the name is a hypertext link, that looks like
			"type://machine/path", you need the |netrw| plugin.
			For Unix the '~' character is expanded, like in
			"~user/file".  Environment variables are expanded too
			|expand-env|.
			{not in Vi}
			{not available when the |+file_in_path| feature was
			disabled at compile time}

							*v_gf*
{Visual}[count]gf	Same as "gf", but the highlighted text is used as the
			name of the file to edit.  'isfname' is ignored.
			Leading blanks are skipped, otherwise all blanks and
			special characters are included in the file name.
			(For {Visual} see |Visual-mode|.)
			{not in VI}

							*gF*
[count]gF		Same as "gf", except if a number follows the file
			name, then the cursor is positioned on that line in
			the file. The file name and the number must be
			separated by a non-filename (see 'isfname') and
			non-numeric character. White space between the
			filename, the separator and the number are ignored.
			Examples:
				eval.c:10 ~
				eval.c @ 20 ~
				eval.c (30) ~
				eval.c 40 ~

							*v_gF*
{Visual}[count]gF	Same as "v_gf".

These commands are used to start editing a single file.  This means that the
file is read into the buffer and the current file name is set.  The file that
is opened depends on the current directory, see |:cd|.

See |read-messages| for an explanation of the message that is given after the
file has been read.

You can use the ":e!" command if you messed up the buffer and want to start
all over again.  The ":e" command is only useful if you have changed the
current file name.

							*:filename* *{file}*
Besides the things mentioned here, more special items for where a filename is
expected are mentioned at |cmdline-special|.

Note for systems other than Unix: When using a command that accepts a single
file name (like ":edit file") spaces in the file name are allowed, but
trailing spaces are ignored.  This is useful on systems that regularly embed
spaces in file names (like MS-Windows and the Amiga).  Example: The command
":e   Long File Name " will edit the file "Long File Name".  When using a
command that accepts more than one file name (like ":next file1 file2")
embedded spaces must be escaped with a backslash.

						*wildcard* *wildcards*
Wildcards in {file} are expanded, but as with file completion, 'wildignore'
and 'suffixes' apply.  Which wildcards are supported depends on the system.
These are the common ones:
	?	matches one character
	*	matches anything, including nothing
	**	matches anything, including nothing, recurses into directories
	[abc]	match 'a', 'b' or 'c'

To avoid the special meaning of the wildcards prepend a backslash.  However,
on MS-Windows the backslash is a path separator and "path\[abc]" is still seen
as a wildcard when "[" is in the 'isfname' option.  A simple way to avoid this
is to use "path\[[]abc]", this matches the file "path\[abc]".

					*starstar-wildcard*
Expanding "**" is possible on Unix, Win32, Mac OS/X and a few other systems.
This allows searching a directory tree.  This goes up to 100 directories deep.
Note there are some commands where this works slightly differently, see
|file-searching|.
Example: >
	:n **/*.txt
Finds files:
	aaa.txt ~
	subdir/bbb.txt ~
	a/b/c/d/ccc.txt ~
When non-wildcard characters are used right before or after "**" these are
only matched in the top directory.  They are not used for directories further
down in the tree. For example: >
	:n /usr/inc**/types.h
Finds files:
	/usr/include/types.h ~
	/usr/include/sys/types.h ~
	/usr/inc/old/types.h ~
Note that the path with "/sys" is included because it does not need to match
"/inc".  Thus it's like matching "/usr/inc*/*/*...", not
"/usr/inc*/inc*/inc*".

					*backtick-expansion* *`-expansion*
On Unix and a few other systems you can also use backticks for the file name
argument, for example: >
	:next `find . -name ver\\*.c -print`
	:view `ls -t *.patch  \| head -n1`
The backslashes before the star are required to prevent the shell from
expanding "ver*.c" prior to execution of the find program.  The backslash
before the shell pipe symbol "|" prevents Vim from parsing it as command
termination.
This also works for most other systems, with the restriction that the
backticks must be around the whole item.  It is not possible to have text
directly before the first or just after the last backtick.

							*`=*
You can have the backticks expanded as a Vim expression, instead of as an
external command, by putting an equal sign right after the first backtick,
e.g.: >
	:e `=tempname()`
The expression can contain just about anything, thus this can also be used to
avoid the special meaning of '"', '|', '%' and '#'.  However, 'wildignore'
does apply like to other wildcards.

Environment variables in the expression are expanded when evaluating the
expression, thus this works: >
	:e `=$HOME . '/.vimrc'`
This does not work, $HOME is inside a string and used literally: >
	:e `='$HOME' . '/.vimrc'`

If the expression returns a string then names are to be separated with line
breaks.  When the result is a |List| then each item is used as a name.  Line
breaks also separate names.
Note that such expressions are only supported in places where a filename is
expected as an argument to an Ex-command.

							*++opt* *[++opt]*
The [++opt] argument can be used to force the value of 'fileformat',
'fileencoding' or 'binary' to a value for one command, and to specify the
behavior for bad characters.  The form is: >
	++{optname}
Or: >
	++{optname}={value}

Where {optname} is one of:	    *++ff* *++enc* *++bin* *++nobin* *++edit*
    ff     or  fileformat   overrides 'fileformat'
    enc    or  encoding	    overrides 'fileencoding'
    bin    or  binary	    sets 'binary'
    nobin  or  nobinary	    resets 'binary'
    bad			    specifies behavior for bad characters
    edit		    for |:read| only: keep option values as if editing
			    a file

{value} cannot contain white space.  It can be any valid value for these
options.  Examples: >
	:e ++ff=unix
This edits the same file again with 'fileformat' set to "unix". >

	:w ++enc=latin1 newfile
This writes the current buffer to "newfile" in latin1 format.

There may be several ++opt arguments, separated by white space.  They must all
appear before any |+cmd| argument.

								*++bad*
The argument of "++bad=" specifies what happens with characters that can't be
converted and illegal bytes.  It can be one of three things:
    ++bad=X      A single-byte character that replaces each bad character.
    ++bad=keep   Keep bad characters without conversion.  Note that this may
		 result in illegal bytes in your text!
    ++bad=drop   Remove the bad characters.

The default is like "++bad=?": Replace each bad character with a question
mark.  In some places an inverted question mark is used (0xBF).

Note that not all commands use the ++bad argument, even though they do not
give an error when you add it.  E.g. |:write|.

Note that when reading, the 'fileformat' and 'fileencoding' options will be
set to the used format.  When writing this doesn't happen, thus a next write
will use the old value of the option.  Same for the 'binary' option.


							*+cmd* *[+cmd]*
The [+cmd] argument can be used to position the cursor in the newly opened
file, or execute any other command:
	+		Start at the last line.
	+{num}		Start at line {num}.
	+/{pat}		Start at first line containing {pat}.
	+{command}	Execute {command} after opening the new file.
			{command} is any Ex command.
To include a white space in the {pat} or {command}, precede it with a
backslash.  Double the number of backslashes. >
	:edit  +/The\ book	     file
	:edit  +/dir\ dirname\\      file
	:edit  +set\ dir=c:\\\\temp  file
Note that in the last example the number of backslashes is halved twice: Once
for the "+cmd" argument and once for the ":set" command.

							*file-formats*
The 'fileformat' option sets the <EOL> style for a file:
'fileformat'    characters	   name				~
  "dos"		<CR><NL> or <NL>   DOS format		*DOS-format*
  "unix"	<NL>		   Unix format		*Unix-format*
  "mac"		<CR>		   Mac format		*Mac-format*
Previously 'textmode' was used.  It is obsolete now.

When reading a file, the mentioned characters are interpreted as the <EOL>.
In DOS format (default for MS-DOS, OS/2 and Win32), <CR><NL> and <NL> are both
interpreted as the <EOL>.  Note that when writing the file in DOS format,
<CR> characters will be added for each single <NL>.  Also see |file-read|.

When writing a file, the mentioned characters are used for <EOL>.  For DOS
format <CR><NL> is used.  Also see |DOS-format-write|.

You can read a file in DOS format and write it in Unix format.  This will
replace all <CR><NL> pairs by <NL> (assuming 'fileformats' includes "dos"): >
	:e file
	:set fileformat=unix
	:w
If you read a file in Unix format and write with DOS format, all <NL>
characters will be replaced with <CR><NL> (assuming 'fileformats' includes
"unix"): >
	:e file
	:set fileformat=dos
	:w

If you start editing a new file and the 'fileformats' option is not empty
(which is the default), Vim will try to detect whether the lines in the file
are separated by the specified formats.  When set to "unix,dos", Vim will
check for lines with a single <NL> (as used on Unix and Amiga) or by a <CR>
<NL> pair (MS-DOS).  Only when ALL lines end in <CR><NL>, 'fileformat' is set
to "dos", otherwise it is set to "unix".  When 'fileformats' includes "mac",
and no <NL> characters are found in the file, 'fileformat' is set to "mac".

If the 'fileformat' option is set to "dos" on non-MS-DOS systems the message
"[dos format]" is shown to remind you that something unusual is happening.  On
MS-DOS systems you get the message "[unix format]" if 'fileformat' is set to
"unix".  On all systems but the Macintosh you get the message "[mac format]"
if 'fileformat' is set to "mac".

If the 'fileformats' option is empty and DOS format is used, but while reading
a file some lines did not end in <CR><NL>, "[CR missing]" will be included in
the file message.
If the 'fileformats' option is empty and Mac format is used, but while reading
a file a <NL> was found, "[NL missing]" will be included in the file message.

If the new file does not exist, the 'fileformat' of the current buffer is used
when 'fileformats' is empty.  Otherwise the first format from 'fileformats' is
used for the new file.

Before editing binary, executable or Vim script files you should set the
'binary' option.  A simple way to do this is by starting Vim with the "-b"
option.  This will avoid the use of 'fileformat'.  Without this you risk that
single <NL> characters are unexpectedly replaced with <CR><NL>.

You can encrypt files that are written by setting the 'key' option.  This
provides some security against others reading your files. |encryption|


==============================================================================
3. The argument list				*argument-list* *arglist*

If you give more than one file name when starting Vim, this list is remembered
as the argument list.  You can jump to each file in this list.

Do not confuse this with the buffer list, which you can see with the
|:buffers| command.  The argument list was already present in Vi, the buffer
list is new in Vim.  Every file name in the argument list will also be present
in the buffer list (unless it was deleted with |:bdel| or |:bwipe|).  But it's
common that names in the buffer list are not in the argument list.

This subject is introduced in section |07.2| of the user manual.

There is one global argument list, which is used for all windows by default.
It is possible to create a new argument list local to a window, see
|:arglocal|.

You can use the argument list with the following commands, and with the
expression functions |argc()| and |argv()|.  These all work on the argument
list of the current window.

							*:ar* *:args*
:ar[gs]			Print the argument list, with the current file in
			square brackets.

:ar[gs] [++opt] [+cmd] {arglist}			*:args_f*
			Define {arglist} as the new argument list and edit
			the first one.  This fails when changes have been made
			and Vim does not want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

:ar[gs]! [++opt] [+cmd] {arglist}			*:args_f!*
			Define {arglist} as the new argument list and edit
			the first one.  Discard any changes to the current
			buffer.
			Also see |++opt| and |+cmd|.
			{Vi: no ++opt}

:[count]arge[dit][!] [++opt] [+cmd] {name}		*:arge* *:argedit*
			Add {name} to the argument list and edit it.
			When {name} already exists in the argument list, this
			entry is edited.
			This is like using |:argadd| and then |:edit|.
			Note that only one file name is allowed, and spaces
			inside the file name are allowed, like with |:edit|.
			[count] is used like with |:argadd|.
			[!] is required if the current file cannot be
			|abandon|ed.
			Also see |++opt| and |+cmd|.
			{not in Vi}

:[count]arga[dd] {name} ..			*:arga* *:argadd* *E479*
:[count]arga[dd]
			Add the {name}s to the argument list.  When {name} is
			omitted add the current buffer name to the argument
			list.
			If [count] is omitted, the {name}s are added just
			after the current entry in the argument list.
			Otherwise they are added after the [count]'th file.
			If the argument list is "a b c", and "b" is the
			current argument, then these commands result in:
				command		new argument list ~
				:argadd x	a b x c
				:0argadd x	x a b c
				:1argadd x	a x b c
				:$argadd x	a b c x
			And after the last one:
				:+2argadd y	a b c x y
			There is no check for duplicates, it is possible to
			add a file to the argument list twice.
			The currently edited file is not changed.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}
			Note: you can also use this method: >
				:args ## x
<			This will add the "x" item and sort the new list.

:argd[elete] {pattern} ..			*:argd* *:argdelete* *E480*
			Delete files from the argument list that match the
			{pattern}s.  {pattern} is used like a file pattern,
			see |file-pattern|.  "%" can be used to delete the
			current entry.
			This command keeps the currently edited file, also
			when it's deleted from the argument list.
			Example: >
				:argdel *.obj
<			{not in Vi} {not available when compiled without the
			|+listcmds| feature}

:[range]argd[elete]	Delete the {range} files from the argument list.
			Example: >
				:10,$argdel
<			Deletes arguments 10 and further, keeping 1-9. >
				:$argd
<			Deletes just the last one. >
				:argd
				:.argd
<			Deletes the current argument. >
				:%argd
<			Removes all the files from the arglist.
			When the last number in the range is too high, up to
			the last argument is deleted.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}

							*:argu* *:argument*
:[count]argu[ment] [count] [++opt] [+cmd]
			Edit file [count] in the argument list.  When [count]
			is omitted the current entry is used.  This fails
			when changes have been made and Vim does not want to
			|abandon| the current buffer.
			Also see |++opt| and |+cmd|.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}

:[count]argu[ment]! [count] [++opt] [+cmd]
			Edit file [count] in the argument list, discard any
			changes to the current buffer.  When [count] is
			omitted the current entry is used.
			Also see |++opt| and |+cmd|.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}

:[count]n[ext] [++opt] [+cmd]			*:n* *:ne* *:next* *E165* *E163*
			Edit [count] next file.  This fails when changes have
			been made and Vim does not want to |abandon| the
			current buffer.  Also see |++opt| and |+cmd|.  {Vi: no
			count or ++opt}.

:[count]n[ext]! [++opt] [+cmd]
			Edit [count] next file, discard any changes to the
			buffer.  Also see |++opt| and |+cmd|.  {Vi: no count
			or ++opt}.

:n[ext] [++opt] [+cmd] {arglist}			*:next_f*
			Same as |:args_f|.

:n[ext]! [++opt] [+cmd] {arglist}
			Same as |:args_f!|.

:[count]N[ext] [count] [++opt] [+cmd]			*:Next* *:N* *E164*
			Edit [count] previous file in argument list.  This
			fails when changes have been made and Vim does not
			want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.  {Vi: no count or ++opt}.

:[count]N[ext]! [count] [++opt] [+cmd]
			Edit [count] previous file in argument list.  Discard
			any changes to the buffer.  Also see |++opt| and
			|+cmd|.  {Vi: no count or ++opt}.

:[count]prev[ious] [count] [++opt] [+cmd]		*:prev* *:previous*
			Same as :Next.  Also see |++opt| and |+cmd|.  {Vi:
			only in some versions}

							*:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			Start editing the first file in the argument list.
			This fails when changes have been made and Vim does
			not want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|. {Vi: no ++opt}

:rew[ind]! [++opt] [+cmd]
			Start editing the first file in the argument list.
			Discard any changes to the buffer.  Also see |++opt|
			and |+cmd|. {Vi: no ++opt}

							*:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			Other name for ":rewind". {not in Vi}

							*:la* *:last*
:la[st] [++opt] [+cmd]
			Start editing the last file in the argument list.
			This fails when changes have been made and Vim does
			not want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.  {not in Vi}

:la[st]! [++opt] [+cmd]
			Start editing the last file in the argument list.
			Discard any changes to the buffer.  Also see |++opt|
			and |+cmd|.  {not in Vi}

							*:wn* *:wnext*
:[count]wn[ext] [++opt]
			Write current file and start editing the [count]
			next file.  Also see |++opt| and |+cmd|.  {not in Vi}

:[count]wn[ext] [++opt] {file}
			Write current file to {file} and start editing the
			[count] next file, unless {file} already exists and
			the 'writeany' option is off.  Also see |++opt| and
			|+cmd|.  {not in Vi}

:[count]wn[ext]! [++opt] {file}
			Write current file to {file} and start editing the
			[count] next file.  Also see |++opt| and |+cmd|.  {not
			in Vi}

:[count]wN[ext][!] [++opt] [file]		*:wN* *:wNext*
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			Same as :wnext, but go to previous file instead of
			next.  {not in Vi}

The [count] in the commands above defaults to one.  For some commands it is
possible to use two counts.  The last one (rightmost one) is used.

If no [+cmd] argument is present, the cursor is positioned at the last known
cursor position for the file.  If 'startofline' is set, the cursor will be
positioned at the first non-blank in the line, otherwise the last know column
is used.  If there is no last known cursor position the cursor will be in the
first line (the last line in Ex mode).

							*{arglist}*
The wildcards in the argument list are expanded and the file names are sorted.
Thus you can use the command "vim *.c" to edit all the C files.  From within
Vim the command ":n *.c" does the same.

White space is used to separate file names.  Put a backslash before a space or
tab to include it in a file name.  E.g., to edit the single file "foo bar": >
	:next foo\ bar

On Unix and a few other systems you can also use backticks, for example: >
	:next `find . -name \\*.c -print`
The backslashes before the star are required to prevent "*.c" to be expanded
by the shell before executing the find program.

							*arglist-position*
When there is an argument list you can see which file you are editing in the
title of the window (if there is one and 'title' is on) and with the file
message you get with the "CTRL-G" command.  You will see something like
	(file 4 of 11)
If 'shortmess' contains 'f' it will be
	(4 of 11)
If you are not really editing the file at the current position in the argument
list it will be
	(file (4) of 11)
This means that you are position 4 in the argument list, but not editing the
fourth file in the argument list.  This happens when you do ":e file".


LOCAL ARGUMENT LIST

{not in Vi}
{not available when compiled without the |+windows| or |+listcmds| features}

							*:arglocal*
:argl[ocal]		Make a local copy of the global argument list.
			Doesn't start editing another file.

:argl[ocal][!] [++opt] [+cmd] {arglist}
			Define a new argument list, which is local to the
			current window.  Works like |:args_f| otherwise.

							*:argglobal*
:argg[lobal]		Use the global argument list for the current window.
			Doesn't start editing another file.

:argg[lobal][!] [++opt] [+cmd] {arglist}
			Use the global argument list for the current window.
			Define a new global argument list like |:args_f|.
			All windows using the global argument list will see
			this new list.

There can be several argument lists.  They can be shared between windows.
When they are shared, changing the argument list in one window will also
change it in the other window.

When a window is split the new window inherits the argument list from the
current window.  The two windows then share this list, until one of them uses
|:arglocal| or |:argglobal| to use another argument list.


USING THE ARGUMENT LIST

						*:argdo*
:[range]argdo[!] {cmd}	Execute {cmd} for each file in the argument list or
			if [range] is specified only for arguments in that
			range.  It works like doing this: >
				:rewind
				:{cmd}
				:next
				:{cmd}
				etc.
<			When the current file can't be |abandon|ed and the [!]
			is not present, the command fails.
			When an error is detected on one file, further files
			in the argument list will not be visited.
			The last file in the argument list (or where an error
			occurred) becomes the current file.
			{cmd} can contain '|' to concatenate several commands.
			{cmd} must not change the argument list.
			Note: While this command is executing, the Syntax
			autocommand event is disabled by adding it to
			'eventignore'.  This considerably speeds up editing
			each file.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}
			Also see |:windo|, |:tabdo|, |:bufdo|, |:cdo|, |:ldo|,
			|:cfdo| and |:lfdo|

Example: >
	:args *.c
	:argdo set ff=unix | update
This sets the 'fileformat' option to "unix" and writes the file if it is now
changed.  This is done for all *.c files.

Example: >
	:args *.[ch]
	:argdo %s/\<my_foo\>/My_Foo/ge | update
This changes the word "my_foo" to "My_Foo" in all *.c and *.h files.  The "e"
flag is used for the ":substitute" command to avoid an error for files where
"my_foo" isn't used.  ":update" writes the file only if changes were made.

==============================================================================
4. Writing					*writing* *save-file*

Note: When the 'write' option is off, you are not able to write any file.

							*:w* *:write*
						*E502* *E503* *E504* *E505*
						*E512* *E514* *E667* *E796*
:w[rite] [++opt]	Write the whole buffer to the current file.  This is
			the normal way to save changes to a file.  It fails
			when the 'readonly' option is set or when there is
			another reason why the file can't be written.
			For ++opt see |++opt|, but only ++bin, ++nobin, ++ff
			and ++enc are effective.

:w[rite]! [++opt]	Like ":write", but forcefully write when 'readonly' is
			set or there is another reason why writing was
			refused.
			Note: This may change the permission and ownership of
			the file and break (symbolic) links.  Add the 'W' flag
			to 'cpoptions' to avoid this.

:[range]w[rite][!] [++opt]
			Write the specified lines to the current file.  This
			is unusual, because the file will not contain all
			lines in the buffer.

							*:w_f* *:write_f*
:[range]w[rite] [++opt]	{file}
			Write the specified lines to {file}, unless it
			already exists and the 'writeany' option is off.

							*:w!*
:[range]w[rite]! [++opt] {file}
			Write the specified lines to {file}.  Overwrite an
			existing file.

						*:w_a* *:write_a* *E494*
:[range]w[rite][!] [++opt] >>
			Append the specified lines to the current file.

:[range]w[rite][!] [++opt] >> {file}
			Append the specified lines to {file}.  '!' forces the
			write even if file does not exist.

							*:w_c* *:write_c*
:[range]w[rite] [++opt] !{cmd}
			Execute {cmd} with [range] lines as standard input
			(note the space in front of the '!').  {cmd} is
			executed like with ":!{cmd}", any '!' is replaced with
			the previous command |:!|.

The default [range] for the ":w" command is the whole buffer (1,$).  If you
write the whole buffer, it is no longer considered changed.  When you
write it to a different file with ":w somefile" it depends on the "+" flag in
'cpoptions'.  When included, the write command will reset the 'modified' flag,
even though the buffer itself may still be different from its file.

If a file name is given with ":w" it becomes the alternate file.  This can be
used, for example, when the write fails and you want to try again later with
":w #".  This can be switched off by removing the 'A' flag from the
'cpoptions' option.

							*:sav* *:saveas*
:sav[eas][!] [++opt] {file}
			Save the current buffer under the name {file} and set
			the filename of the current buffer to {file}.  The
			previous name is used for the alternate file name.
			The [!] is needed to overwrite an existing file.
			When 'filetype' is empty filetype detection is done
			with the new name, before the file is written.
			When the write was successful 'readonly' is reset.
			{not in Vi}

							*:up* *:update*
:[range]up[date][!] [++opt] [>>] [file]
			Like ":write", but only write when the buffer has been
			modified.  {not in Vi}


WRITING WITH MULTIPLE BUFFERS				*buffer-write*

							*:wa* *:wall*
:wa[ll]			Write all changed buffers.  Buffers without a file
			name cause an error message.  Buffers which are
			readonly are not written. {not in Vi}

:wa[ll]!		Write all changed buffers, even the ones that are
			readonly.  Buffers without a file name are not
			written and cause an error message. {not in Vi}


Vim will warn you if you try to overwrite a file that has been changed
elsewhere.  See |timestamp|.

			    *backup* *E207* *E506* *E507* *E508* *E509* *E510*
If you write to an existing file (but do not append) while the 'backup',
'writebackup' or 'patchmode' option is on, a backup of the original file is
made.  The file is either copied or renamed (see 'backupcopy').  After the
file has been successfully written and when the 'writebackup' option is on and
the 'backup' option is off, the backup file is deleted.  When the 'patchmode'
option is on the backup file may be renamed.

							*backup-table*
'backup' 'writebackup'	action	~
   off	     off	no backup made
   off	     on		backup current file, deleted afterwards (default)
   on	     off	delete old backup, backup current file
   on	     on		delete old backup, backup current file

When the 'backupskip' pattern matches with the name of the file which is
written, no backup file is made.  The values of 'backup' and 'writebackup' are
ignored then.

When the 'backup' option is on, an old backup file (with the same name as the
new backup file) will be deleted.  If 'backup' is not set, but 'writebackup'
is set, an existing backup file will not be deleted.  The backup file that is
made while the file is being written will have a different name.

On some filesystems it's possible that in a crash you lose both the backup and
the newly written file (it might be there but contain bogus data).  In that
case try recovery, because the swap file is synced to disk and might still be
there. |:recover|

The directories given with the 'backupdir' option are used to put the backup
file in.  (default: same directory as the written file).

Whether the backup is a new file, which is a copy of the original file, or the
original file renamed depends on the 'backupcopy' option.  See there for an
explanation of when the copy is made and when the file is renamed.

If the creation of a backup file fails, the write is not done.  If you want
to write anyway add a '!' to the command.

							*write-permissions*
When writing a new file the permissions are read-write.  For unix the mask is
0666 with additionally umask applied.  When writing a file that was read Vim
will preserve the permissions, but clear the s-bit.

							*write-readonly*
When the 'cpoptions' option contains 'W', Vim will refuse to overwrite a
readonly file.  When 'W' is not present, ":w!" will overwrite a readonly file,
if the system allows it (the directory must be writable).

							*write-fail*
If the writing of the new file fails, you have to be careful not to lose
your changes AND the original file.  If there is no backup file and writing
the new file failed, you have already lost the original file!  DON'T EXIT VIM
UNTIL YOU WRITE OUT THE FILE!  If a backup was made, it is put back in place
of the original file (if possible).  If you exit Vim, and lose the changes
you made, the original file will mostly still be there.  If putting back the
original file fails, there will be an error message telling you that you
lost the original file.

						*DOS-format-write*
If the 'fileformat' is "dos", <CR> <NL> is used for <EOL>.  This is default
for MS-DOS, Win32 and OS/2.  On other systems the message "[dos format]" is
shown to remind you that an unusual <EOL> was used.
						*Unix-format-write*
If the 'fileformat' is "unix", <NL> is used for <EOL>.  On MS-DOS, Win32 and
OS/2 the message "[unix format]" is shown.
						*Mac-format-write*
If the 'fileformat' is "mac", <CR> is used for <EOL>.  On non-Mac systems the
message "[mac format]" is shown.

See also |file-formats| and the 'fileformat' and 'fileformats' options.

						*ACL*
ACL stands for Access Control List.  It is an advanced way to control access
rights for a file.  It is used on new MS-Windows and Unix systems, but only
when the filesystem supports it.
   Vim attempts to preserve the ACL info when writing a file.  The backup file
will get the ACL info of the original file.
   The ACL info is also used to check if a file is read-only (when opening the
file).

						*read-only-share*
When MS-Windows shares a drive on the network it can be marked as read-only.
This means that even if the file read-only attribute is absent, and the ACL
settings on NT network shared drives allow writing to the file, you can still
not write to the file.  Vim on Win32 platforms will detect read-only network
drives and will mark the file as read-only.  You will not be able to override
it with |:write|.

						*write-device*
When the file name is actually a device name, Vim will not make a backup (that
would be impossible).  You need to use "!", since the device already exists.
Example for Unix: >
	:w! /dev/lpt0
and for MS-DOS or MS-Windows: >
	:w! lpt0
For Unix a device is detected when the name doesn't refer to a normal file or
a directory.  A fifo or named pipe also looks like a device to Vim.
For MS-DOS and MS-Windows the device is detected by its name:
	AUX
	CON
	CLOCK$
	NUL
	PRN
	COMn	n=1,2,3... etc
	LPTn	n=1,2,3... etc
The names can be in upper- or lowercase.

==============================================================================
5. Writing and quitting					*write-quit*

							*:q* *:quit*
:q[uit]			Quit the current window.  Quit Vim if this is the last
			window.  This fails when changes have been made and
			Vim refuses to |abandon| the current buffer, and when
			the last file in the argument list has not been
			edited.
			If there are other tab pages and quitting the last
			window in the current tab page the current tab page is
			closed |tab-page|.
			Triggers the |QuitPre| autocommand event.

:conf[irm] q[uit]	Quit, but give prompt when changes have been made, or
			the last file in the argument list has not been
			edited.  See |:confirm| and 'confirm'.  {not in Vi}

:q[uit]!		Quit without writing, also when the current buffer has
			changes.  The buffer is unloaded, also when it has
			'hidden' set.
			If this is the last window and there is a modified
			hidden buffer, the current buffer is abandoned and the
			first changed hidden buffer becomes the current
			buffer.
			Use ":qall!" to exit always.

:cq[uit]		Quit always, without writing, and return an error
			code.  See |:cq|.  Used for Manx's QuickFix mode (see
			|quickfix|).  {not in Vi}

							*:wq*
:wq [++opt]		Write the current file and quit.  Writing fails when
			the file is read-only or the buffer does not have a
			name.  Quitting fails when the last file in the
			argument list has not been edited.

:wq! [++opt]		Write the current file and quit.  Writing fails when
			the current buffer does not have a name.

:wq [++opt] {file}	Write to {file} and quit.  Quitting fails when the
			last file in the argument list has not been edited.

:wq! [++opt] {file}	Write to {file} and quit.

:[range]wq[!] [++opt] [file]
			Same as above, but only write the lines in [range].

							*:x* *:xit*
:[range]x[it][!] [++opt] [file]
			Like ":wq", but write only when changes have been
			made.
			When 'hidden' is set and there are more windows, the
			current buffer becomes hidden, after writing the file.

							*:exi* *:exit*
:[range]exi[t][!] [++opt] [file]
			Same as :xit.

							*ZZ*
ZZ			Write current file, if modified, and quit (same as
			":x").  (Note: If there are several windows for the
			current file, the file is written if it was modified
			and the window is closed).

							*ZQ*
ZQ			Quit without checking for changes (same as ":q!").
			{not in Vi}

MULTIPLE WINDOWS AND BUFFERS				*window-exit*

							*:qa* *:qall*
:qa[ll]		Exit Vim, unless there are some buffers which have been
		changed.  (Use ":bmod" to go to the next modified buffer).
		When 'autowriteall' is set all changed buffers will be
		written, like |:wqall|. {not in Vi}

:conf[irm] qa[ll]
		Exit Vim.  Bring up a prompt when some buffers have been
		changed.  See |:confirm|. {not in Vi}

:qa[ll]!	Exit Vim.  Any changes to buffers are lost. {not in Vi}
		Also see |:cquit|, it does the same but exits with a non-zero
		value.

							*:quita* *:quitall*
:quita[ll][!]	Same as ":qall". {not in Vi}

:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		Write all changed buffers and exit Vim.  If there are buffers
		without a file name, which are readonly or which cannot be
		written for another reason, Vim will not quit. {not in Vi}

:conf[irm] wqa[ll] [++opt]
:conf[irm] xa[ll]
		Write all changed buffers and exit Vim.  Bring up a prompt
		when some buffers are readonly or cannot be written for
		another reason.  See |:confirm|. {not in Vi}

:wqa[ll]! [++opt]
:xa[ll]!	Write all changed buffers, even the ones that are readonly,
		and exit Vim.  If there are buffers without a file name or
		which cannot be written for another reason, Vim will not quit.
		{not in Vi}

==============================================================================
6. Dialogs						*edit-dialogs*

							*:confirm* *:conf*
:conf[irm] {command}	Execute {command}, and use a dialog when an
			operation has to be confirmed.  Can be used on the
			|:q|, |:qa| and |:w| commands (the latter to override
			a read-only setting), and any other command that can
			fail in such a way, such as |:only|, |:buffer|,
			|:bdelete|, etc.

Examples: >
  :confirm w foo
<	Will ask for confirmation when "foo" already exists. >
  :confirm q
<	Will ask for confirmation when there are changes. >
  :confirm qa
<	If any modified, unsaved buffers exist, you will be prompted to save
	or abandon each one.  There are also choices to "save all" or "abandon
	all".

If you want to always use ":confirm", set the 'confirm' option.

			*:browse* *:bro* *E338* *E614* *E615* *E616*
:bro[wse] {command}	Open a file selection dialog for an argument to
			{command}.  At present this works for |:e|, |:w|,
			|:wall|, |:wq|, |:wqall|, |:x|, |:xall|, |:exit|,
			|:view|, |:sview|, |:r|, |:saveas|, |:sp|, |:mkexrc|,
			|:mkvimrc|, |:mksession|, |:mkview|, |:split|,
			|:vsplit|, |:tabe|, |:tabnew|, |:cfile|, |:cgetfile|,
			|:caddfile|, |:lfile|, |:lgetfile|, |:laddfile|,
			|:diffsplit|, |:diffpatch|, |:open|, |:pedit|,
			|:redir|, |:source|, |:update|, |:visual|, |:vsplit|,
			and |:qall| if 'confirm' is set.
			{only in Win32, Athena, Motif, GTK and Mac GUI}
			When ":browse" is not possible you get an error
			message.  If the |+browse| feature is missing or the
			{command} doesn't support browsing, the {command} is
			executed without a dialog.
			":browse set" works like |:options|.
			See also |:oldfiles| for ":browse oldfiles".

The syntax is best shown via some examples: >
	:browse e $vim/foo
<		Open the browser in the $vim/foo directory, and edit the
		file chosen. >
	:browse e
<		Open the browser in the directory specified with 'browsedir',
		and edit the file chosen. >
	:browse w
<		Open the browser in the directory of the current buffer,
		with the current buffer filename as default, and save the
		buffer under the filename chosen. >
	:browse w C:/bar
<		Open the browser in the C:/bar directory, with the current
		buffer filename as default, and save the buffer under the
		filename chosen.
Also see the |'browsedir'| option.
For versions of Vim where browsing is not supported, the command is executed
unmodified.

							*browsefilter*
For MS Windows and GTK, you can modify the filters that are used in the browse
dialog.  By setting the g:browsefilter or b:browsefilter variables, you can
change the filters globally or locally to the buffer.  The variable is set to
a string in the format "{filter label}\t{pattern};{pattern}\n" where {filter
label} is the text that appears in the "Files of Type" comboBox, and {pattern}
is the pattern which filters the filenames.  Several patterns can be given,
separated by ';'.

For Motif the same format is used, but only the very first pattern is actually
used (Motif only offers one pattern, but you can edit it).

For example, to have only Vim files in the dialog, you could use the following
command: >

     let g:browsefilter = "Vim Scripts\t*.vim\nVim Startup Files\t*vimrc\n"

You can override the filter setting on a per-buffer basis by setting the
b:browsefilter variable.  You would most likely set b:browsefilter in a
filetype plugin, so that the browse dialog would contain entries related to
the type of file you are currently editing.  Disadvantage: This makes it
difficult to start editing a file of a different type.  To overcome this, you
may want to add "All Files\t*.*\n" as the final filter, so that the user can
still access any desired file.

To avoid setting browsefilter when Vim does not actually support it, you can
use has("browsefilter"): >

	if has("browsefilter")
	   let g:browsefilter = "whatever"
	endif

==============================================================================
7. The current directory				*current-directory*

You may use the |:cd| and |:lcd| commands to change to another directory, so
you will not have to type that directory name in front of the file names.  It
also makes a difference for executing external commands, e.g. ":!ls".

Changing directory fails when the current buffer is modified, the '.' flag is
present in 'cpoptions' and "!" is not used in the command.

							*:cd* *E747* *E472*
:cd[!]			On non-Unix systems: Print the current directory
			name.  On Unix systems: Change the current directory
			to the home directory.  Use |:pwd| to print the
			current directory on all systems.

:cd[!] {path}		Change the current directory to {path}.
			If {path} is relative, it is searched for in the
			directories listed in |'cdpath'|.
			Does not change the meaning of an already opened file,
			because its full path name is remembered.  Files from
			the |arglist| may change though!
			On MS-DOS this also changes the active drive.
			To change to the directory of the current file: >
				:cd %:h
<
							*:cd-* *E186*
:cd[!] -		Change to the previous current directory (before the
			previous ":cd {path}" command). {not in Vi}

							*:chd* *:chdir*
:chd[ir][!] [path]	Same as |:cd|.

							*:lc* *:lcd*
:lc[d][!] {path}	Like |:cd|, but only set the current directory for the
			current window.  The current directory for other
			windows is not changed. {not in Vi}

							*:lch* *:lchdir*
:lch[dir][!]		Same as |:lcd|. {not in Vi}

							*:pw* *:pwd* *E187*
:pw[d]			Print the current directory name.  {Vi: no pwd}
			Also see |getcwd()|.

So long as no |:lcd| command has been used, all windows share the same current
directory.  Using a command to jump to another window doesn't change anything
for the current directory.
When a |:lcd| command has been used for a window, the specified directory
becomes the current directory for that window.  Windows where the |:lcd|
command has not been used stick to the global current directory.  When jumping
to another window the current directory will become the last specified local
current directory.  If none was specified, the global current directory is
used.
When a |:cd| command is used, the current window will lose his local current
directory and will use the global current directory from now on.

After using |:cd| the full path name will be used for reading and writing
files.  On some networked file systems this may cause problems.  The result of
using the full path name is that the file names currently in use will remain
referring to the same file.  Example: If you have a file a:test and a
directory a:vim the commands ":e test" ":cd vim" ":w" will overwrite the file
a:test and not write a:vim/test.  But if you do ":w test" the file a:vim/test
will be written, because you gave a new file name and did not refer to a
filename before the ":cd".

==============================================================================
8. Editing binary files					*edit-binary*

Although Vim was made to edit text files, it is possible to edit binary
files.  The |-b| Vim argument (b for binary) makes Vim do file I/O in binary
mode, and sets some options for editing binary files ('binary' on, 'textwidth'
to 0, 'modeline' off, 'expandtab' off).  Setting the 'binary' option has the
same effect.  Don't forget to do this before reading the file.

There are a few things to remember when editing binary files:
- When editing executable files the number of characters must not change.
  Use only the "R" or "r" command to change text.  Do not delete characters
  with "x" or by backspacing.
- Set the 'textwidth' option to 0.  Otherwise lines will unexpectedly be
  split in two.
- When there are not many <EOL>s, the lines will become very long.  If you
  want to edit a line that does not fit on the screen reset the 'wrap' option.
  Horizontal scrolling is used then.  If a line becomes too long (more than
  about 32767 characters on the Amiga, much more on 32-bit systems, see
  |limits|) you cannot edit that line.  The line will be split when reading
  the file.  It is also possible that you get an "out of memory" error when
  reading the file.
- Make sure the 'binary' option is set BEFORE loading the
  file.  Otherwise both <CR> <NL> and <NL> are considered to end a line
  and when the file is written the <NL> will be replaced with <CR> <NL>.
- <Nul> characters are shown on the screen as ^@.  You can enter them with
  "CTRL-V CTRL-@" or "CTRL-V 000" {Vi cannot handle <Nul> characters in the
  file}
- To insert a <NL> character in the file split a line.  When writing the
  buffer to a file a <NL> will be written for the <EOL>.
- Vim normally appends an <EOL> at the end of the file if there is none.
  Setting the 'binary' option prevents this.  If you want to add the final
  <EOL>, set the 'endofline' option.  You can also read the value of this
  option to see if there was an <EOL> for the last line (you cannot see this
  in the text).

==============================================================================
9. Encryption						*encryption*

Vim is able to write files encrypted, and read them back.  The encrypted text
cannot be read without the right key.
{only available when compiled with the |+cryptv| feature}  *E833*

The text in the swap file and the undo file is also encrypted.  *E843*
However, this is done block-by-block and may reduce the time needed to crack a
password.  You can disable the swap file, but then a crash will cause you to
lose your work.  The undo file can be disabled without much disadvantage. >
	:set noundofile
	:noswapfile edit secrets

Note: The text in memory is not encrypted.  A system administrator may be able
to see your text while you are editing it.  When filtering text with
":!filter" or using ":w !command" the text is also not encrypted, this may
reveal it to others.  The 'viminfo' file is not encrypted.

You could do this to edit very secret text: >
	:set noundofile viminfo=
	:noswapfile edit secrets.txt
Keep in mind that without a swap file you risk losing your work in the event
of a crash or a power failure.

WARNING: If you make a typo when entering the key and then write the file and
exit, the text will be lost!

The normal way to work with encryption, is to use the ":X" command, which will
ask you to enter a key.  A following write command will use that key to
encrypt the file.  If you later edit the same file, Vim will ask you to enter
a key.  If you type the same key as that was used for writing, the text will
be readable again.  If you use a wrong key, it will be a mess.

							*:X*
:X	Prompt for an encryption key.  The typing is done without showing the
	actual text, so that someone looking at the display won't see it.
	The typed key is stored in the 'key' option, which is used to encrypt
	the file when it is written.  The file will remain unchanged until you
	write it.  See also |-x|.

The value of the 'key' options is used when text is written.  When the option
is not empty, the written file will be encrypted, using the value as the
encryption key.  A magic number is prepended, so that Vim can recognize that
the file is encrypted.

To disable the encryption, reset the 'key' option to an empty value: >
	:set key=

You can use the 'cryptmethod' option to select the type of encryption, use one
of these: >
	:setlocal cm=zip        " weak method, backwards compatible
	:setlocal cm=blowfish   " method with flaws
	:setlocal cm=blowfish2  " medium strong method

Do this before writing the file.  When reading an encrypted file it will be
set automatically to the method used when that file was written.  You can
change 'cryptmethod' before writing that file to change the method.

To set the default method, used for new files, use this in your |vimrc| 
file: >
	set cm=blowfish2
Using "blowfish2" is highly recommended.  Only use another method if you
must use an older Vim version that does not support it.

The message given for reading and writing a file will show "[crypted]" when
using zip, "[blowfish]" when using blowfish, etc.

When writing an undo file, the same key and method will be used for the text
in the undo file. |persistent-undo|.

To test for blowfish support you can use these conditions: >
	has('crypt-blowfish')
	has('crypt-blowfish2')
This works since Vim 7.4.1099 while blowfish support was added earlier.
Thus the condition failing doesn't mean blowfish is not supported. You can
test for blowfish with: >
	v:version >= 703
And for blowfish2 with: >
	v:version > 704 || (v:version == 704 && has('patch401'))
If you are sure Vim includes patch 7.4.237 a simpler check is: >
	has('patch-7.4.401')
<
						*E817* *E818* *E819* *E820*
When encryption does not work properly, you would be able to write your text
to a file and never be able to read it back.  Therefore a test is performed to
check if the encryption works as expected.  If you get one of these errors
don't write the file encrypted!  You need to rebuild the Vim binary to fix
this.

*E831* This is an internal error, "cannot happen".  If you can reproduce it,
please report to the developers.

When reading a file that has been encrypted and the 'key' option is not empty,
it will be used for decryption.  If the value is empty, you will be prompted
to enter the key.  If you don't enter a key, or you enter the wrong key, the
file is edited without being decrypted.  There is no warning about using the
wrong key (this makes brute force methods to find the key more difficult).

If want to start reading a file that uses a different key, set the 'key'
option to an empty string, so that Vim will prompt for a new one.  Don't use
the ":set" command to enter the value, other people can read the command over
your shoulder.

Since the value of the 'key' option is supposed to be a secret, its value can
never be viewed.  You should not set this option in a vimrc file.

An encrypted file can be recognized by the "file" command, if you add these
lines to "/etc/magic", "/usr/share/misc/magic" or wherever your system has the
"magic" file: >
     0	string	VimCrypt~	Vim encrypted file
     >9	string	01	- "zip" cryptmethod
     >9	string	02	- "blowfish" cryptmethod
     >9	string	03	- "blowfish2" cryptmethod

Notes:
- Encryption is not possible when doing conversion with 'charconvert'.
- Text you copy or delete goes to the numbered registers.  The registers can
  be saved in the .viminfo file, where they could be read.  Change your
  'viminfo' option to be safe.
- Someone can type commands in Vim when you walk away for a moment, he should
  not be able to get the key.
- If you make a typing mistake when entering the key, you might not be able to
  get your text back!
- If you type the key with a ":set key=value" command, it can be kept in the
  history, showing the 'key' value in a viminfo file.
- There is never 100% safety.  The encryption in Vim has not been tested for
  robustness.
- The algorithm used for 'cryptmethod' "zip" is breakable.  A 4 character key
  in about one hour, a 6 character key in one day (on a Pentium 133 PC).  This
  requires that you know some text that must appear in the file.  An expert
  can break it for any key.  When the text has been decrypted, this also means
  that the key can be revealed, and other files encrypted with the same key
  can be decrypted.
- Pkzip uses the same encryption as 'cryptmethod' "zip", and US Govt has no
  objection to its export.  Pkzip's public file APPNOTE.TXT describes this
  algorithm in detail.
- The implementation of 'cryptmethod' "blowfish" has a flaw.  It is possible
  to crack the first 64 bytes of a file and in some circumstances more of the
  file. Use of it is not recommended, but it's still the strongest method
  supported by Vim 7.3 and 7.4.  The "zip" method is even weaker.
- Vim originates from the Netherlands.  That is where the sources come from.
  Thus the encryption code is not exported from the USA.

==============================================================================
10. Timestamps					*timestamp* *timestamps*

Vim remembers the modification timestamp, mode and size of a file when you
begin editing it.  This is used to avoid that you have two different versions
of the same file (without you knowing this).

After a shell command is run (|:!cmd| |suspend| |:read!| |K|) timestamps,
file modes and file sizes are compared for all buffers in a window.   Vim will
run any associated |FileChangedShell| autocommands or display a warning for
any files that have changed.  In the GUI this happens when Vim regains input
focus.

							*E321* *E462*
If you want to automatically reload a file when it has been changed outside of
Vim, set the 'autoread' option.  This doesn't work at the moment you write the
file though, only when the file wasn't changed inside of Vim.

Note that if a FileChangedShell autocommand is defined you will not get a
warning message or prompt.  The autocommand is expected to handle this.

There is no warning for a directory (e.g., with |netrw-browse|).  But you do
get warned if you started editing a new file and it was created as a directory
later.

When Vim notices the timestamp of a file has changed, and the file is being
edited in a buffer but has not changed, Vim checks if the contents of the file
is equal.  This is done by reading the file again (into a hidden buffer, which
is immediately deleted again) and comparing the text.  If the text is equal,
you will get no warning.

If you don't get warned often enough you can use the following command.

							*:checkt* *:checktime*
:checkt[ime]		Check if any buffers were changed outside of Vim.
			This checks and warns you if you would end up with two
			versions of a file.
			If this is called from an autocommand, a ":global"
			command or is not typed the actual check is postponed
			until a moment the side effects (reloading the file)
			would be harmless.
			Each loaded buffer is checked for its associated file
			being changed.  If the file was changed Vim will take
			action.  If there are no changes in the buffer and
			'autoread' is set, the buffer is reloaded.  Otherwise,
			you are offered the choice of reloading the file.  If
			the file was deleted you get an error message.
			If the file previously didn't exist you get a warning
			if it exists now.
			Once a file has been checked the timestamp is reset,
			you will not be warned again.

:[N]checkt[ime] {filename}
:[N]checkt[ime] [N]
			Check the timestamp of a specific buffer.  The buffer
			may be specified by name, number or with a pattern.


							*E813* *E814*
Vim will reload the buffer if you chose to.  If a window is visible that
contains this buffer, the reloading will happen in the context of this window.
Otherwise a special window is used, so that most autocommands will work.  You
can't close this window.  A few other restrictions apply.  Best is to make
sure nothing happens outside of the current buffer.  E.g., setting
window-local options may end up in the wrong window.  Splitting the window,
doing something there and closing it should be OK (if there are no side
effects from other autocommands).  Closing unrelated windows and buffers will
get you into trouble.

Before writing a file the timestamp is checked.  If it has changed, Vim will
ask if you really want to overwrite the file:

	WARNING: The file has been changed since reading it!!!
	Do you really want to write to it (y/n)?

If you hit 'y' Vim will continue writing the file.  If you hit 'n' the write is
aborted.  If you used ":wq" or "ZZ" Vim will not exit, you will get another
chance to write the file.

The message would normally mean that somebody has written to the file after
the edit session started.  This could be another person, in which case you
probably want to check if your changes to the file and the changes from the
other person should be merged.  Write the file under another name and check for
differences (the "diff" program can be used for this).

It is also possible that you modified the file yourself, from another edit
session or with another command (e.g., a filter command).  Then you will know
which version of the file you want to keep.

There is one situation where you get the message while there is nothing wrong:
On a Win32 system on the day daylight saving time starts.  There is something
in the Win32 libraries that confuses Vim about the hour time difference.  The
problem goes away the next day.

==============================================================================
11. File Searching					*file-searching*

{not available when compiled without the |+path_extra| feature}

The file searching is currently used for the 'path', 'cdpath' and 'tags'
options, for |finddir()| and |findfile()|.  Other commands use |wildcards|
which is slightly different.

There are three different types of searching:

1) Downward search:					*starstar*
   Downward search uses the wildcards '*', '**' and possibly others
   supported by your operating system.  '*' and '**' are handled inside Vim,
   so they work on all operating systems.  Note that "**" only acts as a
   special wildcard when it is at the start of a name.

   The usage of '*' is quite simple: It matches 0 or more characters.  In a
   search pattern this would be ".*".  Note that the "." is not used for file
   searching.

   '**' is more sophisticated:
      - It ONLY matches directories.
      - It matches up to 30 directories deep by default, so you can use it to
	search an entire directory tree
      - The maximum number of levels matched can be given by appending a number
	to '**'.
	Thus '/usr/**2' can match: >
		/usr
		/usr/include
		/usr/include/sys
		/usr/include/g++
		/usr/lib
		/usr/lib/X11
		....
<	It does NOT match '/usr/include/g++/std' as this would be three
	levels.
	The allowed number range is 0 ('**0' is removed) to 100
	If the given number is smaller than 0 it defaults to 30, if it's
	bigger than 100 then 100 is used.  The system also has a limit on the
	path length, usually 256 or 1024 bytes.
      - '**' can only be at the end of the path or be followed by a path
	separator or by a number and a path separator.

   You can combine '*' and '**' in any order: >
	/usr/**/sys/*
	/usr/*tory/sys/**
	/usr/**2/sys/*

2) Upward search:
   Here you can give a directory and then search the directory tree upward for
   a file.  You could give stop-directories to limit the upward search.  The
   stop-directories are appended to the path (for the 'path' option) or to
   the filename (for the 'tags' option) with a ';'.  If you want several
   stop-directories separate them with ';'.  If you want no stop-directory
   ("search upward till the root directory) just use ';'. >
	/usr/include/sys;/usr
<   will search in: >
	   /usr/include/sys
	   /usr/include
	   /usr
<
   If you use a relative path the upward search is started in Vim's current
   directory or in the directory of the current file (if the relative path
   starts with './' and 'd' is not included in 'cpoptions').

   If Vim's current path is /u/user_x/work/release and you do >
	:set path=include;/u/user_x
<  and then search for a file with |gf| the file is searched in: >
	/u/user_x/work/release/include
	/u/user_x/work/include
	/u/user_x/include

3) Combined up/downward search:
   If Vim's current path is /u/user_x/work/release and you do >
	set path=**;/u/user_x
<  and then search for a file with |gf| the file is searched in: >
	/u/user_x/work/release/**
	/u/user_x/work/**
	/u/user_x/**
<
   BE CAREFUL!  This might consume a lot of time, as the search of
   '/u/user_x/**' includes '/u/user_x/work/**' and
   '/u/user_x/work/release/**'.  So '/u/user_x/work/release/**' is searched
   three times and '/u/user_x/work/**' is searched twice.

   In the above example you might want to set path to: >
	:set path=**,/u/user_x/**
<  This searches:
	/u/user_x/work/release/** ~
	/u/user_x/** ~
   This searches the same directories, but in a different order.

   Note that completion for ":find", ":sfind", and ":tabfind" commands do not
   currently work with 'path' items that contain a url or use the double star
   with depth limiter (/usr/**2) or upward search (;) notations.

 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #
# arch/blackfin/mach-bf609/Makefile
#

obj-y := dma.o clock.o ints-priority.o
obj-$(CONFIG_PM) += pm.o dpm.o
obj-$(CONFIG_SCB_PRIORITY) += scb.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #
# arch/blackfin/mach-bf609/boards/Makefile
#

obj-$(CONFIG_BFIN609_EZKIT)            += ezkit.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              choice
	prompt "System type"
	default BFIN609_EZKIT
	help
	  Select your board!

config BFIN609_EZKIT
	bool "BF609-EZKIT"
	help
	  BFIN609-EZKIT board support.
	  
endchoice
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #
# arch/blackfin/kernel/Makefile
#

extra-y := vmlinux.lds

obj-y := \
	entry.o process.o bfin_ksyms.o ptrace.o setup.o signal.o \
	sys_bfin.o traps.o irqchip.o dma-mapping.o flat.o \
	fixed_code.o reboot.o bfin_dma.o \
	exception.o dumpstack.o

ifeq ($(CONFIG_GENERIC_CLOCKEVENTS),y)
    obj-y += time-ts.o
else
    obj-y += time.o
endif

obj-$(CONFIG_GPIO_ADI)               += bfin_gpio.o
obj-$(CONFIG_DYNAMIC_FTRACE)         += ftrace.o
obj-$(CONFIG_FUNCTION_TRACER)        += ftrace-entry.o
obj-$(CONFIG_FUNCTION_GRAPH_TRACER)  += ftrace.o
CFLAGS_REMOVE_ftrace.o = -pg

obj-$(CONFIG_IPIPE)                  += ipipe.o
obj-$(CONFIG_BFIN_GPTIMERS)          += gptimers.o
obj-$(CONFIG_CPLB_INFO)              += cplbinfo.o
obj-$(CONFIG_MODULES)                += module.o
obj-$(CONFIG_KGDB)                   += kgdb.o
obj-$(CONFIG_KGDB_TESTS)             += kgdb_test.o
obj-$(CONFIG_NMI_WATCHDOG)           += nmi.o
obj-$(CONFIG_EARLY_PRINTK)           += early_printk.o
obj-$(CONFIG_EARLY_PRINTK)           += shadow_console.o
obj-$(CONFIG_STACKTRACE)             += stacktrace.o
obj-$(CONFIG_DEBUG_VERBOSE)          += trace.o
obj-$(CONFIG_BFIN_PSEUDODBG_INSNS)   += pseudodbg.o
obj-$(CONFIG_PERF_EVENTS)            += perf_event.o

# the kgdb test puts code into L2 and without linker
# relaxation, we need to force long calls to/from it
CFLAGS_kgdb_test.o := -mlong-calls

obj-$(CONFIG_DEBUG_MMRS)             += debug-mmrs.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #
# arch/blackfin/kernel/cplb-nompu/Makefile
#

obj-y := cplbinit.o cplbmgr.o

CFLAGS_cplbmgr.o := -ffixed-I0 -ffixed-I1 -ffixed-I2 -ffixed-I3 \
		    -ffixed-L0 -ffixed-L1 -ffixed-L2 -ffixed-L3 \
		    -ffixed-M0 -ffixed-M1 -ffixed-M2 -ffixed-M3 \
		    -ffixed-B0 -ffixed-B1 -ffixed-B2 -ffixed-B3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #
# arch/blackfin/kernel/cplb-nompu/Makefile
#

obj-y := cplbinit.o cplbmgr.o

CFLAGS_cplbmgr.o := -ffixed-I0 -ffixed-I1 -ffixed-I2 -ffixed-I3 \
		    -ffixed-L0 -ffixed-L1 -ffixed-L2 -ffixed-L3 \
		    -ffixed-M0 -ffixed-M1 -ffixed-M2 -ffixed-M3 \
		    -ffixed-B0 -ffixed-B1 -ffixed-B2 -ffixed-B3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     config BF60x
	def_bool y
	depends on (BF609)
	select IRQ_PREFLOW_FASTEOI

if (BF60x)

source "arch/blackfin/mach-bf609/boards/Kconfig"

menu "BF609 Specific Configuration"

config SEC_IRQ_PRIORITY_LEVELS
	int "SEC interrupt priority levels"
	default 7
	range 0 7
	help
	  Divide the total number of interrupt priority levels into sub-levels.
	  There is 2 ^ (SEC_IRQ_PRIORITY_LEVELS + 1) different levels.

config L1_PARITY_CHECK
	bool "Enable L1 parity check"
	default n
	help
	  Enable the L1 parity check in L1 sram. A fault event is raised
	  when L1 parity error is found.

comment "System Cross Bar Priority Assignment"

config SCB_PRIORITY
	bool "Init System Cross Bar Priority"
	default n

menuconfig	SCB0_MI0
	bool "SCB0 Master Interface 0 (DDR)"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	Core 0	-- 0
	Core 1	-- 2
	SCB1	-- 9
	SCB2	-- 10
	SCB3	-- 11
	SCB4	-- 12
	SCB5	-- 5
	SCB6	-- 6
	SCB7	-- 8
	SCB8	-- 7
	SCB9	-- 4
	USB	-- 13

if SCB0_MI0

config SCB0_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 13

config SCB0_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 2
	range 0 13

config SCB0_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 4
	range 0 13

config SCB0_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 5
	range 0 13

config SCB0_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 6
	range 0 13

config SCB0_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 7
	range 0 13

config SCB0_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 8
	range 0 13

config SCB0_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 9
	range 0 13

config SCB0_MI0_SLOT8
	int "Slot 8 slave interface id"
	default 10
	range 0 13

config SCB0_MI0_SLOT9
	int "Slot 9 slave interface id"
	default 11
	range 0 13

config SCB0_MI0_SLOT10
	int "Slot 10 slave interface id"
	default 13
	range 0 13

config SCB0_MI0_SLOT11
	int "Slot 11 slave interface id"
	default 12
	range 0 13

config SCB0_MI0_SLOT12
	int "Slot 12 slave interface id"
	default 0
	range 0 13

config SCB0_MI0_SLOT13
	int "Slot 13 slave interface id"
	default 2
	range 0 13

config SCB0_MI0_SLOT14
	int "Slot 14 slave interface id"
	default 4
	range 0 13

config SCB0_MI0_SLOT15
	int "Slot 15 slave interface id"
	default 5
	range 0 13

config SCB0_MI0_SLOT16
	int "Slot 16 slave interface id"
	default 6
	range 0 13

config SCB0_MI0_SLOT17
	int "Slot 17 slave interface id"
	default 7
	range 0 13

config SCB0_MI0_SLOT18
	int "Slot 18 slave interface id"
	default 8
	range 0 13

config SCB0_MI0_SLOT19
	int "Slot 19 slave interface id"
	default 9
	range 0 13

config SCB0_MI0_SLOT20
	int "Slot 20 slave interface id"
	default 10
	range 0 13

config SCB0_MI0_SLOT21
	int "Slot 21 slave interface id"
	default 11
	range 0 13

config SCB0_MI0_SLOT22
	int "Slot 22 slave interface id"
	default 13
	range 0 13

config SCB0_MI0_SLOT23
	int "Slot 23 slave interface id"
	default 12
	range 0 13

config SCB0_MI0_SLOT24
	int "Slot 24 slave interface id"
	default 0
	range 0 13

config SCB0_MI0_SLOT25
	int "Slot 25 slave interface id"
	default 2
	range 0 13

config SCB0_MI0_SLOT26
	int "Slot 26 slave interface id"
	default 4
	range 0 13

config SCB0_MI0_SLOT27
	int "Slot 27 slave interface id"
	default 5
	range 0 13

config SCB0_MI0_SLOT28
	int "Slot 28 slave interface id"
	default 6
	range 0 13

config SCB0_MI0_SLOT29
	int "Slot 29 slave interface id"
	default 7
	range 0 13

config SCB0_MI0_SLOT30
	int "Slot 30 slave interface id"
	default 8
	range 0 13

config SCB0_MI0_SLOT31
	int "Slot 31 slave interface id"
	default 13
	range 0 13

endif # SCB0_MI0

menuconfig	SCB0_MI1
	bool "SCB0 Master Interface 1 (SMC)"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	Core 0	-- 0
	Core 1	-- 2
	SCB1	-- 9
	SCB2	-- 10
	SCB3	-- 11
	SCB4	-- 12
	SCB5	-- 5
	SCB6	-- 6
	SCB7	-- 8
	SCB8	-- 7
	SCB9	-- 4
	USB	-- 13

if SCB0_MI1

config SCB0_MI1_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 13

config SCB0_MI1_SLOT1
	int "Slot 1 slave interface id"
	default 2
	range 0 13

config SCB0_MI1_SLOT2
	int "Slot 2 slave interface id"
	default 4
	range 0 13

config SCB0_MI1_SLOT3
	int "Slot 3 slave interface id"
	default 5
	range 0 13

config SCB0_MI1_SLOT4
	int "Slot 4 slave interface id"
	default 6
	range 0 13

config SCB0_MI1_SLOT5
	int "Slot 5 slave interface id"
	default 7
	range 0 13

config SCB0_MI1_SLOT6
	int "Slot 6 slave interface id"
	default 8
	range 0 13

config SCB0_MI1_SLOT7
	int "Slot 7 slave interface id"
	default 9
	range 0 13

config SCB0_MI1_SLOT8
	int "Slot 8 slave interface id"
	default 10
	range 0 13

config SCB0_MI1_SLOT9
	int "Slot 9 slave interface id"
	default 11
	range 0 13

config SCB0_MI1_SLOT10
	int "Slot 10 slave interface id"
	default 13
	range 0 13

config SCB0_MI1_SLOT11
	int "Slot 11 slave interface id"
	default 12
	range 0 13

config SCB0_MI1_SLOT12
	int "Slot 12 slave interface id"
	default 0
	range 0 13

config SCB0_MI1_SLOT13
	int "Slot 13 slave interface id"
	default 2
	range 0 13

config SCB0_MI1_SLOT14
	int "Slot 14 slave interface id"
	default 4
	range 0 13

config SCB0_MI1_SLOT15
	int "Slot 15 slave interface id"
	default 5
	range 0 13

config SCB0_MI1_SLOT16
	int "Slot 16 slave interface id"
	default 6
	range 0 13

config SCB0_MI1_SLOT17
	int "Slot 17 slave interface id"
	default 7
	range 0 13

config SCB0_MI1_SLOT18
	int "Slot 18 slave interface id"
	default 8
	range 0 13

config SCB0_MI1_SLOT19
	int "Slot 19 slave interface id"
	default 9
	range 0 13

config SCB0_MI1_SLOT20
	int "Slot 20 slave interface id"
	default 10
	range 0 13

config SCB0_MI1_SLOT21
	int "Slot 21 slave interface id"
	default 11
	range 0 13

config SCB0_MI1_SLOT22
	int "Slot 22 slave interface id"
	default 13
	range 0 13

config SCB0_MI1_SLOT23
	int "Slot 23 slave interface id"
	default 12
	range 0 13

config SCB0_MI1_SLOT24
	int "Slot 24 slave interface id"
	default 0
	range 0 13

config SCB0_MI1_SLOT25
	int "Slot 25 slave interface id"
	default 2
	range 0 13

config SCB0_MI1_SLOT26
	int "Slot 26 slave interface id"
	default 4
	range 0 13

config SCB0_MI1_SLOT27
	int "Slot 27 slave interface id"
	default 5
	range 0 13

config SCB0_MI1_SLOT28
	int "Slot 28 slave interface id"
	default 6
	range 0 13

config SCB0_MI1_SLOT29
	int "Slot 29 slave interface id"
	default 7
	range 0 13

config SCB0_MI1_SLOT30
	int "Slot 30 slave interface id"
	default 8
	range 0 13

config SCB0_MI1_SLOT31
	int "Slot 31 slave interface id"
	default 13
	range 0 13

endif # SCB0_MI1

menuconfig	SCB0_MI2
	bool "SCB0 Master Interface 2 (Data L2)"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	Core 0	-- 0
	Core 1	-- 2
	SCB1	-- 9
	SCB2	-- 10
	SCB3	-- 11
	SCB4	-- 12
	SCB5	-- 5
	SCB6	-- 6
	SCB7	-- 8
	SCB8	-- 7
	SCB9	-- 4
	USB	-- 13

if SCB0_MI2

config SCB0_MI2_SLOT0
	int "Slot 0 slave interface id"
	default 4
	range 0 13

config SCB0_MI2_SLOT1
	int "Slot 1 slave interface id"
	default 5
	range 0 13

config SCB0_MI2_SLOT2
	int "Slot 2 slave interface id"
	default 6
	range 0 13

config SCB0_MI2_SLOT3
	int "Slot 3 slave interface id"
	default 7
	range 0 13

config SCB0_MI2_SLOT4
	int "Slot 4 slave interface id"
	default 8
	range 0 13

config SCB0_MI2_SLOT5
	int "Slot 5 slave interface id"
	default 9
	range 0 13

config SCB0_MI2_SLOT6
	int "Slot 6 slave interface id"
	default 10
	range 0 13

config SCB0_MI2_SLOT7
	int "Slot 7 slave interface id"
	default 11
	range 0 13

config SCB0_MI2_SLOT8
	int "Slot 8 slave interface id"
	default 13
	range 0 13

config SCB0_MI2_SLOT9
	int "Slot 9 slave interface id"
	default 12
	range 0 13

config SCB0_MI2_SLOT10
	int "Slot 10 slave interface id"
	default 4
	range 0 13

config SCB0_MI2_SLOT11
	int "Slot 11 slave interface id"
	default 5
	range 0 13

config SCB0_MI2_SLOT12
	int "Slot 12 slave interface id"
	default 6
	range 0 13

config SCB0_MI2_SLOT13
	int "Slot 13 slave interface id"
	default 7
	range 0 13

config SCB0_MI2_SLOT14
	int "Slot 14 slave interface id"
	default 8
	range 0 13

config SCB0_MI2_SLOT15
	int "Slot 15 slave interface id"
	default 9
	range 0 13

config SCB0_MI2_SLOT16
	int "Slot 16 slave interface id"
	default 10
	range 0 13

config SCB0_MI2_SLOT17
	int "Slot 17 slave interface id"
	default 11
	range 0 13

config SCB0_MI2_SLOT18
	int "Slot 18 slave interface id"
	default 13
	range 0 13

config SCB0_MI2_SLOT19
	int "Slot 19 slave interface id"
	default 12
	range 0 13

config SCB0_MI2_SLOT20
	int "Slot 20 slave interface id"
	default 4
	range 0 13

config SCB0_MI2_SLOT21
	int "Slot 21 slave interface id"
	default 5
	range 0 13

config SCB0_MI2_SLOT22
	int "Slot 22 slave interface id"
	default 6
	range 0 13

config SCB0_MI2_SLOT23
	int "Slot 23 slave interface id"
	default 7
	range 0 13

config SCB0_MI2_SLOT24
	int "Slot 24 slave interface id"
	default 8
	range 0 13

config SCB0_MI2_SLOT25
	int "Slot 25 slave interface id"
	default 9
	range 0 13

config SCB0_MI2_SLOT26
	int "Slot 26 slave interface id"
	default 10
	range 0 13

config SCB0_MI2_SLOT27
	int "Slot 27 slave interface id"
	default 11
	range 0 13

config SCB0_MI2_SLOT28
	int "Slot 28 slave interface id"
	default 13
	range 0 13

config SCB0_MI2_SLOT29
	int "Slot 29 slave interface id"
	default 12
	range 0 13

config SCB0_MI2_SLOT30
	int "Slot 30 slave interface id"
	default 4
	range 0 13

config SCB0_MI2_SLOT31
	int "Slot 31 slave interface id"
	default 7
	range 0 13

endif # SCB0_MI2

menuconfig	SCB0_MI3
	bool "SCB0 Master Interface 3 (L1A)"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	Core 0	-- 0
	Core 1	-- 2
	SCB1	-- 9
	SCB2	-- 10
	SCB3	-- 11
	SCB4	-- 12
	SCB5	-- 5
	SCB6	-- 6
	SCB7	-- 8
	SCB8	-- 7
	SCB9	-- 4
	USB	-- 13

if SCB0_MI3

config SCB0_MI3_SLOT0
	int "Slot 0 slave interface id"
	default 4
	range 0 13

config SCB0_MI3_SLOT1
	int "Slot 1 slave interface id"
	default 5
	range 0 13

config SCB0_MI3_SLOT2
	int "Slot 2 slave interface id"
	default 6
	range 0 13

config SCB0_MI3_SLOT3
	int "Slot 3 slave interface id"
	default 7
	range 0 13

config SCB0_MI3_SLOT4
	int "Slot 4 slave interface id"
	default 8
	range 0 13

config SCB0_MI3_SLOT5
	int "Slot 5 slave interface id"
	default 9
	range 0 13

config SCB0_MI3_SLOT6
	int "Slot 6 slave interface id"
	default 10
	range 0 13

config SCB0_MI3_SLOT7
	int "Slot 7 slave interface id"
	default 11
	range 0 13

config SCB0_MI3_SLOT8
	int "Slot 8 slave interface id"
	default 13
	range 0 13

config SCB0_MI3_SLOT9
	int "Slot 9 slave interface id"
	default 12
	range 0 13

config SCB0_MI3_SLOT10
	int "Slot 10 slave interface id"
	default 4
	range 0 13

config SCB0_MI3_SLOT11
	int "Slot 11 slave interface id"
	default 5
	range 0 13

config SCB0_MI3_SLOT12
	int "Slot 12 slave interface id"
	default 6
	range 0 13

config SCB0_MI3_SLOT13
	int "Slot 13 slave interface id"
	default 7
	range 0 13

config SCB0_MI3_SLOT14
	int "Slot 14 slave interface id"
	default 8
	range 0 13

config SCB0_MI3_SLOT15
	int "Slot 15 slave interface id"
	default 9
	range 0 13

config SCB0_MI3_SLOT16
	int "Slot 16 slave interface id"
	default 10
	range 0 13

config SCB0_MI3_SLOT17
	int "Slot 17 slave interface id"
	default 11
	range 0 13

config SCB0_MI3_SLOT18
	int "Slot 18 slave interface id"
	default 13
	range 0 13

config SCB0_MI3_SLOT19
	int "Slot 19 slave interface id"
	default 12
	range 0 13

config SCB0_MI3_SLOT20
	int "Slot 20 slave interface id"
	default 4
	range 0 13

config SCB0_MI3_SLOT21
	int "Slot 21 slave interface id"
	default 5
	range 0 13

config SCB0_MI3_SLOT22
	int "Slot 22 slave interface id"
	default 6
	range 0 13

config SCB0_MI3_SLOT23
	int "Slot 23 slave interface id"
	default 7
	range 0 13

config SCB0_MI3_SLOT24
	int "Slot 24 slave interface id"
	default 8
	range 0 13

config SCB0_MI3_SLOT25
	int "Slot 25 slave interface id"
	default 9
	range 0 13

config SCB0_MI3_SLOT26
	int "Slot 26 slave interface id"
	default 10
	range 0 13

config SCB0_MI3_SLOT27
	int "Slot 27 slave interface id"
	default 11
	range 0 13

config SCB0_MI3_SLOT28
	int "Slot 28 slave interface id"
	default 13
	range 0 13

config SCB0_MI3_SLOT29
	int "Slot 29 slave interface id"
	default 12
	range 0 13

config SCB0_MI3_SLOT30
	int "Slot 30 slave interface id"
	default 4
	range 0 13

config SCB0_MI3_SLOT31
	int "Slot 31 slave interface id"
	default 7
	range 0 13

endif # SCB0_MI3

menuconfig	SCB0_MI4
	bool "SCB0 Master Interface 4 (L1B)"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	Core 0	-- 0
	Core 1	-- 2
	SCB1	-- 9
	SCB2	-- 10
	SCB3	-- 11
	SCB4	-- 12
	SCB5	-- 5
	SCB6	-- 6
	SCB7	-- 8
	SCB8	-- 7
	SCB9	-- 4
	USB	-- 13

if SCB0_MI4

config SCB0_MI4_SLOT0
	int "Slot 0 slave interface id"
	default 4
	range 0 13

config SCB0_MI4_SLOT1
	int "Slot 1 slave interface id"
	default 5
	range 0 13

config SCB0_MI4_SLOT2
	int "Slot 2 slave interface id"
	default 6
	range 0 13

config SCB0_MI4_SLOT3
	int "Slot 3 slave interface id"
	default 7
	range 0 13

config SCB0_MI4_SLOT4
	int "Slot 4 slave interface id"
	default 8
	range 0 13

config SCB0_MI4_SLOT5
	int "Slot 5 slave interface id"
	default 9
	range 0 13

config SCB0_MI4_SLOT6
	int "Slot 6 slave interface id"
	default 10
	range 0 13

config SCB0_MI4_SLOT7
	int "Slot 7 slave interface id"
	default 11
	range 0 13

config SCB0_MI4_SLOT8
	int "Slot 8 slave interface id"
	default 13
	range 0 13

config SCB0_MI4_SLOT9
	int "Slot 9 slave interface id"
	default 12
	range 0 13

config SCB0_MI4_SLOT10
	int "Slot 10 slave interface id"
	default 4
	range 0 13

config SCB0_MI4_SLOT11
	int "Slot 11 slave interface id"
	default 5
	range 0 13

config SCB0_MI4_SLOT12
	int "Slot 12 slave interface id"
	default 6
	range 0 13

config SCB0_MI4_SLOT13
	int "Slot 13 slave interface id"
	default 7
	range 0 13

config SCB0_MI4_SLOT14
	int "Slot 14 slave interface id"
	default 8
	range 0 13

config SCB0_MI4_SLOT15
	int "Slot 15 slave interface id"
	default 9
	range 0 13

config SCB0_MI4_SLOT16
	int "Slot 16 slave interface id"
	default 10
	range 0 13

config SCB0_MI4_SLOT17
	int "Slot 17 slave interface id"
	default 11
	range 0 13

config SCB0_MI4_SLOT18
	int "Slot 18 slave interface id"
	default 13
	range 0 13

config SCB0_MI4_SLOT19
	int "Slot 19 slave interface id"
	default 12
	range 0 13

config SCB0_MI4_SLOT20
	int "Slot 20 slave interface id"
	default 4
	range 0 13

config SCB0_MI4_SLOT21
	int "Slot 21 slave interface id"
	default 5
	range 0 13

config SCB0_MI4_SLOT22
	int "Slot 22 slave interface id"
	default 6
	range 0 13

config SCB0_MI4_SLOT23
	int "Slot 23 slave interface id"
	default 7
	range 0 13

config SCB0_MI4_SLOT24
	int "Slot 24 slave interface id"
	default 8
	range 0 13

config SCB0_MI4_SLOT25
	int "Slot 25 slave interface id"
	default 9
	range 0 13

config SCB0_MI4_SLOT26
	int "Slot 26 slave interface id"
	default 10
	range 0 13

config SCB0_MI4_SLOT27
	int "Slot 27 slave interface id"
	default 11
	range 0 13

config SCB0_MI4_SLOT28
	int "Slot 28 slave interface id"
	default 13
	range 0 13

config SCB0_MI4_SLOT29
	int "Slot 29 slave interface id"
	default 12
	range 0 13

config SCB0_MI4_SLOT30
	int "Slot 30 slave interface id"
	default 4
	range 0 13

config SCB0_MI4_SLOT31
	int "Slot 31 slave interface id"
	default 7
	range 0 13

endif # SCB0_MI4

menuconfig	SCB0_MI5
	bool "SCB0 Master Interface 5 (SMMR)"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	MMR0	-- 1
	MMR1	-- 3
	SCB2	-- 10
	SCB4	-- 12

if SCB0_MI5

config SCB0_MI5_SLOT0
	int "Slot 0 slave interface id"
	default 1
	range 0 13

config SCB0_MI5_SLOT1
	int "Slot 1 slave interface id"
	default 3
	range 0 13

config SCB0_MI5_SLOT2
	int "Slot 2 slave interface id"
	default 10
	range 0 13

config SCB0_MI5_SLOT3
	int "Slot 3 slave interface id"
	default 12
	range 0 13

config SCB0_MI5_SLOT4
	int "Slot 4 slave interface id"
	default 1
	range 0 13

config SCB0_MI5_SLOT5
	int "Slot 5 slave interface id"
	default 3
	range 0 13

config SCB0_MI5_SLOT6
	int "Slot 6 slave interface id"
	default 10
	range 0 13

config SCB0_MI5_SLOT7
	int "Slot 7 slave interface id"
	default 12
	range 0 13

config SCB0_MI5_SLOT8
	int "Slot 8 slave interface id"
	default 1
	range 0 13

config SCB0_MI5_SLOT9
	int "Slot 9 slave interface id"
	default 3
	range 0 13

config SCB0_MI5_SLOT10
	int "Slot 10 slave interface id"
	default 10
	range 0 13

config SCB0_MI5_SLOT11
	int "Slot 11 slave interface id"
	default 12
	range 0 13

config SCB0_MI5_SLOT12
	int "Slot 12 slave interface id"
	default 1
	range 0 13

config SCB0_MI5_SLOT13
	int "Slot 13 slave interface id"
	default 3
	range 0 13

config SCB0_MI5_SLOT14
	int "Slot 14 slave interface id"
	default 10
	range 0 13

config SCB0_MI5_SLOT15
	int "Slot 15 slave interface id"
	default 12
	range 0 13

endif # SCB0_MI5

menuconfig	SCB1_MI0
	bool "SCB1 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	SPORT0A	-- 0
	SPORT0B	-- 1
	SPORT1A	-- 2
	SPORT1B	-- 3
	SPORT2A	-- 4
	SPORT2B	-- 5
	SPI0TX	-- 6
	SPI0RX	-- 7
	SPI1TX	-- 8
	SPI1RX	-- 9

if SCB1_MI0

config SCB1_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 9

config SCB1_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 9

config SCB1_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 9

config SCB1_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 9

config SCB1_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 4
	range 0 9

config SCB1_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 5
	range 0 9

config SCB1_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 6
	range 0 9

config SCB1_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 7
	range 0 9

config SCB1_MI0_SLOT8
	int "Slot 8 slave interface id"
	default 8
	range 0 9

config SCB1_MI0_SLOT9
	int "Slot 9 slave interface id"
	default 9
	range 0 9

config SCB1_MI0_SLOT10
	int "Slot 10 slave interface id"
	default 0
	range 0 9

config SCB1_MI0_SLOT11
	int "Slot 11 slave interface id"
	default 1
	range 0 9

config SCB1_MI0_SLOT12
	int "Slot 12 slave interface id"
	default 2
	range 0 9

config SCB1_MI0_SLOT13
	int "Slot 13 slave interface id"
	default 3
	range 0 9

config SCB1_MI0_SLOT14
	int "Slot 14 slave interface id"
	default 4
	range 0 9

config SCB1_MI0_SLOT15
	int "Slot 15 slave interface id"
	default 5
	range 0 9

config SCB1_MI0_SLOT16
	int "Slot 16 slave interface id"
	default 6
	range 0 13

config SCB1_MI0_SLOT17
	int "Slot 17 slave interface id"
	default 7
	range 0 13

config SCB1_MI0_SLOT18
	int "Slot 18 slave interface id"
	default 8
	range 0 13

config SCB1_MI0_SLOT19
	int "Slot 19 slave interface id"
	default 9
	range 0 13

endif # SCB1_MI0

menuconfig	SCB2_MI0
	bool "SCB2 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	RSI	-- 0
	SDU DMA	-- 1
	SDU	-- 2
	EMAC0	-- 3
	EMAC1	-- 4

if SCB2_MI0

config SCB2_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 4

config SCB2_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 4

config SCB2_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 4

config SCB2_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 4

config SCB2_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 4
	range 0 4

config SCB2_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 0
	range 0 4

config SCB2_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 1
	range 0 4

config SCB2_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 2
	range 0 4

config SCB2_MI0_SLOT8
	int "Slot 8 slave interface id"
	default 3
	range 0 4

config SCB2_MI0_SLOT9
	int "Slot 9 slave interface id"
	default 4
	range 0 4

endif # SCB2_MI0

menuconfig	SCB3_MI0
	bool "SCB3 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	LP0	-- 0
	LP1	-- 1
	LP2	-- 2
	LP3	-- 3
	UART0TX	-- 4
	UART0RX	-- 5
	UART1TX	-- 4
	UART1RX	-- 5

if SCB3_MI0

config SCB3_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 7

config SCB3_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 7

config SCB3_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 7

config SCB3_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 7

config SCB3_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 4
	range 0 7

config SCB3_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 5
	range 0 7

config SCB3_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 6
	range 0 7

config SCB3_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 7
	range 0 7

config SCB3_MI0_SLOT8
	int "Slot 8 slave interface id"
	default 0
	range 0 7

config SCB3_MI0_SLOT9
	int "Slot 9 slave interface id"
	default 1
	range 0 7

config SCB3_MI0_SLOT10
	int "Slot 10 slave interface id"
	default 2
	range 0 7

config SCB3_MI0_SLOT11
	int "Slot 11 slave interface id"
	default 3
	range 0 7

config SCB3_MI0_SLOT12
	int "Slot 12 slave interface id"
	default 4
	range 0 7

config SCB3_MI0_SLOT13
	int "Slot 13 slave interface id"
	default 5
	range 0 7

config SCB3_MI0_SLOT14
	int "Slot 14 slave interface id"
	default 6
	range 0 7

config SCB3_MI0_SLOT15
	int "Slot 15 slave interface id"
	default 7
	range 0 7

endif # SCB3_MI0

menuconfig	SCB4_MI0
	bool "SCB4 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	MDA21	-- 0
	MDA22	-- 1
	MDA23	-- 2
	MDA24	-- 3
	MDA25	-- 4
	MDA26	-- 5
	MDA27	-- 6
	MDA28	-- 7

if SCB4_MI0

config SCB4_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 7

config SCB4_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 7

config SCB4_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 7

config SCB4_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 7

config SCB4_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 4
	range 0 7

config SCB4_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 5
	range 0 7

config SCB4_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 6
	range 0 7

config SCB4_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 7
	range 0 7

config SCB4_MI0_SLOT8
	int "Slot 8 slave interface id"
	default 0
	range 0 7

config SCB4_MI0_SLOT9
	int "Slot 9 slave interface id"
	default 1
	range 0 7

config SCB4_MI0_SLOT10
	int "Slot 10 slave interface id"
	default 2
	range 0 7

config SCB4_MI0_SLOT11
	int "Slot 11 slave interface id"
	default 3
	range 0 7

config SCB4_MI0_SLOT12
	int "Slot 12 slave interface id"
	default 4
	range 0 7

config SCB4_MI0_SLOT13
	int "Slot 13 slave interface id"
	default 5
	range 0 7

config SCB4_MI0_SLOT14
	int "Slot 14 slave interface id"
	default 6
	range 0 7

config SCB4_MI0_SLOT15
	int "Slot 15 slave interface id"
	default 7
	range 0 7

endif # SCB4_MI0

menuconfig	SCB5_MI0
	bool "SCB5 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	PPI0 MDA29	-- 0
	PPI0 MDA30	-- 1
	PPI2 MDA31	-- 2
	PPI2 MDA32	-- 3

if SCB5_MI0

config SCB5_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 3

config SCB5_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 3

config SCB5_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 3

config SCB5_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 3

config SCB5_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 0
	range 0 3

config SCB5_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 1
	range 0 3

config SCB5_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 2
	range 0 3

config SCB5_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 3
	range 0 3

endif # SCB5_MI0

menuconfig	SCB6_MI0
	bool "SCB6 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	PPI1 MDA33	-- 0
	PPI1 MDA34	-- 1

if SCB6_MI0

config SCB6_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 1

config SCB6_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 1

config SCB6_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 0
	range 0 1

config SCB6_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 1
	range 0 1

endif # SCB6_MI0

menuconfig	SCB7_MI0
	bool "SCB7 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	PIXC0	-- 0
	PIXC1	-- 1
	PIXC2	-- 2

if SCB7_MI0

config SCB7_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 2

config SCB7_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 2

config SCB7_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 2

config SCB7_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 0
	range 0 2

config SCB7_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 1
	range 0 2

config SCB7_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 2
	range 0 2

endif # SCB7_MI0

menuconfig	SCB8_MI0
	bool "SCB8 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	PVP CPDOB	-- 0
	PVP CPDOC	-- 1
	PVP CPCO	-- 2
	PVP CPCI	-- 3

if SCB8_MI0

config SCB8_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 3

config SCB8_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 3

config SCB8_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 3

config SCB8_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 3

config SCB8_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 0
	range 0 3

config SCB8_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 1
	range 0 3

config SCB8_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 2
	range 0 3

config SCB8_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 3
	range 0 3

endif # SCB8_MI0

menuconfig	SCB9_MI0
	bool "SCB9 Master Interface 0"
	default n
	depends on SCB_PRIORITY
	help
	The slave interface id of each slot should be set according following table.
	PVP MPDO	-- 0
	PVP MPDI	-- 1
	PVP MPCO	-- 2
	PVP MPCI	-- 3
	PVP CPDOA	-- 4

if SCB9_MI0

config SCB9_MI0_SLOT0
	int "Slot 0 slave interface id"
	default 0
	range 0 4

config SCB9_MI0_SLOT1
	int "Slot 1 slave interface id"
	default 1
	range 0 4

config SCB9_MI0_SLOT2
	int "Slot 2 slave interface id"
	default 2
	range 0 4

config SCB9_MI0_SLOT3
	int "Slot 3 slave interface id"
	default 3
	range 0 4

config SCB9_MI0_SLOT4
	int "Slot 4 slave interface id"
	default 4
	range 0 4

config SCB9_MI0_SLOT5
	int "Slot 5 slave interface id"
	default 0
	range 0 4

config SCB9_MI0_SLOT6
	int "Slot 6 slave interface id"
	default 1
	range 0 4

config SCB9_MI0_SLOT7
	int "Slot 7 slave interface id"
	default 2
	range 0 4

config SCB9_MI0_SLOT8
	int "Slot 8 slave interface id"
	default 3
	range 0 4

config SCB9_MI0_SLOT9
	int "Slot 9 slave interface id"
	default 4
	range 0 4

endif # SCB9_MI0

endmenu

endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #
# arch/blackfin/mach-bf537/Makefile
#

obj-y := ints-priority.o dma.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *insert.txt*    For Vim version 8.0.  Last change: 2016 Jan 31


		  VIM REFERENCE MANUAL    by Bram Moolenaar


						*Insert* *Insert-mode*
Inserting and replacing text				*mode-ins-repl*

Most of this file is about Insert and Replace mode.  At the end are a few
commands for inserting text in other ways.

An overview of the most often used commands can be found in chapter 24 of the
user manual |usr_24.txt|.

1. Special keys						|ins-special-keys|
2. Special special keys					|ins-special-special|
3. 'textwidth' and 'wrapmargin' options			|ins-textwidth|
4. 'expandtab', 'smarttab' and 'softtabstop'  options	|ins-expandtab|
5. Replace mode						|Replace-mode|
6. Virtual Replace mode					|Virtual-Replace-mode|
7. Insert mode completion				|ins-completion|
8. Insert mode commands					|inserting|
9. Ex insert commands					|inserting-ex|
10. Inserting a file					|inserting-file|

Also see 'virtualedit', for moving the cursor to positions where there is no
character.  Useful for editing a table.

==============================================================================
1. Special keys						*ins-special-keys*

In Insert and Replace mode, the following characters have a special meaning;
other characters are inserted directly.  To insert one of these special
characters into the buffer, precede it with CTRL-V.  To insert a <Nul>
character use "CTRL-V CTRL-@" or "CTRL-V 000".  On some systems, you have to
use "CTRL-V 003" to insert a CTRL-C.  Note: When CTRL-V is mapped you can
often use CTRL-Q instead |i_CTRL-Q|.

If you are working in a special language mode when inserting text, see the
'langmap' option, |'langmap'|, on how to avoid switching this mode on and off
all the time.

If you have 'insertmode' set, <Esc> and a few other keys get another meaning.
See |'insertmode'|.

char		action	~
-----------------------------------------------------------------------
						*i_CTRL-[* *i_<Esc>*
<Esc> or CTRL-[	End insert or Replace mode, go back to Normal mode.  Finish
		abbreviation.
		Note: If your <Esc> key is hard to hit on your keyboard, train
		yourself to use CTRL-[.
		If Esc doesn't work and you are using a Mac, try CTRL-Esc.
		Or disable Listening under Accessibility preferences.
						*i_CTRL-C*
CTRL-C		Quit insert mode, go back to Normal mode.  Do not check for
		abbreviations.  Does not trigger the |InsertLeave| autocommand
		event.

						*i_CTRL-@*
CTRL-@		Insert previously inserted text and stop insert.  {Vi: only
		when typed as first char, only up to 128 chars}
						*i_CTRL-A*
CTRL-A		Insert previously inserted text.  {not in Vi}

						*i_CTRL-H* *i_<BS>* *i_BS*
<BS> or CTRL-H	Delete the character before the cursor (see |i_backspacing|
		about joining lines).
		See |:fixdel| if your <BS> key does not do what you want.
		{Vi: does not delete autoindents}
						*i_<Del>* *i_DEL*
<Del>		Delete the character under the cursor.  If the cursor is at
		the end of the line, and the 'backspace' option includes
		"eol", delete the <EOL>; the next line is appended after the
		current one.
		See |:fixdel| if your <Del> key does not do what you want.
		{not in Vi}
						*i_CTRL-W*
CTRL-W		Delete the word before the cursor (see |i_backspacing| about
		joining lines).  See the section "word motions",
		|word-motions|, for the definition of a word.
						*i_CTRL-U*
CTRL-U		Delete all entered characters before the cursor in the current
		line.  If there are no newly entered characters and
		'backspace' is not empty, delete all characters before the
		cursor in the current line.
		See |i_backspacing| about joining lines.
						*i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> or CTRL-I Insert a tab.  If the 'expandtab' option is on, the
		equivalent number of spaces is inserted (use CTRL-V <Tab> to
		avoid the expansion; use CTRL-Q <Tab> if CTRL-V is mapped
		|i_CTRL-Q|).  See also the 'smarttab' option and
		|ins-expandtab|.
						*i_CTRL-J* *i_<NL>*
<NL> or CTRL-J	Begin new line.
						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	Begin new line.
						*i_CTRL-K*
CTRL-K {char1} [char2]
		Enter digraph (see |digraphs|).  When {char1} is a special
		key, the code for that key is inserted in <> form.  For
		example, the string "<S-Space>" can be entered by typing
		<C-K><S-Space> (two keys).  Neither char is considered for
		mapping.  {not in Vi}

CTRL-N		Find next keyword (see |i_CTRL-N|).  {not in Vi}
CTRL-P		Find previous keyword (see |i_CTRL-P|).  {not in Vi}

CTRL-R {0-9a-z"%#*+:.-=}					*i_CTRL-R*
		Insert the contents of a register.  Between typing CTRL-R and
		the second character, '"' will be displayed to indicate that
		you are expected to enter the name of a register.
		The text is inserted as if you typed it, but mappings and
		abbreviations are not used.  If you have options like
		'textwidth', 'formatoptions', or 'autoindent' set, this will
		influence what will be inserted.  This is different from what
		happens with the "p" command and pasting with the mouse.
		Special registers:
			'"'	the unnamed register, containing the text of
				the last delete or yank
			'%'	the current file name
			'#'	the alternate file name
			'*'	the clipboard contents (X11: primary selection)
			'+'	the clipboard contents
			'/'	the last search pattern
			':'	the last command-line
			'.'	the last inserted text
			'-'	the last small (less than a line) delete
							*i_CTRL-R_=*
			'='	the expression register: you are prompted to
				enter an expression (see |expression|)
				Note that 0x80 (128 decimal) is used for
				special keys.  E.g., you can use this to move
				the cursor up:
					CTRL-R ="\<Up>"
				Use CTRL-R CTRL-R to insert text literally.
				When the result is a |List| the items are used
				as lines.  They can have line breaks inside
				too.
				When the result is a Float it's automatically
				converted to a String.
				When append() or setline() is invoked the undo
				sequence will be broken.
		See |registers| about registers.  {not in Vi}

CTRL-R CTRL-R {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-R*
		Insert the contents of a register.  Works like using a single
		CTRL-R, but the text is inserted literally, not as if typed.
		This differs when the register contains characters like <BS>.
		Example, where register a contains "ab^Hc": >
	CTRL-R a		results in "ac".
	CTRL-R CTRL-R a		results in "ab^Hc".
<		Options 'textwidth', 'formatoptions', etc. still apply.  If
		you also want to avoid these, use CTRL-R CTRL-O, see below.
		The '.' register (last inserted text) is still inserted as
		typed.  {not in Vi}

CTRL-R CTRL-O {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-O*
		Insert the contents of a register literally and don't
		auto-indent.  Does the same as pasting with the mouse
		|<MiddleMouse>|.
		Does not replace characters!
		The '.' register (last inserted text) is still inserted as
		typed.  {not in Vi}

CTRL-R CTRL-P {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-P*
		Insert the contents of a register literally and fix the
		indent, like |[<MiddleMouse>|.
		Does not replace characters!
		The '.' register (last inserted text) is still inserted as
		typed.  {not in Vi}

						*i_CTRL-T*
CTRL-T		Insert one shiftwidth of indent at the start of the current
		line.  The indent is always rounded to a 'shiftwidth' (this is
		vi compatible).  {Vi: only when in indent}
						*i_CTRL-D*
CTRL-D		Delete one shiftwidth of indent at the start of the current
		line.  The indent is always rounded to a 'shiftwidth' (this is
		vi compatible).  {Vi: CTRL-D works only when used after
		autoindent}
						*i_0_CTRL-D*
0 CTRL-D	Delete all indent in the current line.  {Vi: CTRL-D works
		only when used after autoindent}
						*i_^_CTRL-D*
^ CTRL-D	Delete all indent in the current line.  The indent is
		restored in the next line.  This is useful when inserting a
		label.  {Vi: CTRL-D works only when used after autoindent}

						*i_CTRL-V*
CTRL-V		Insert next non-digit literally.  For special keys, the
		terminal code is inserted.  It's also possible to enter the
		decimal, octal or hexadecimal value of a character
		|i_CTRL-V_digit|.
		The characters typed right after CTRL-V are not considered for
		mapping.  {Vi: no decimal byte entry}
		Note: When CTRL-V is mapped (e.g., to paste text) you can
		often use CTRL-Q instead |i_CTRL-Q|.

						*i_CTRL-Q*
CTRL-Q		Same as CTRL-V.
		Note: Some terminal connections may eat CTRL-Q, it doesn't
		work then.  It does work in the GUI.

CTRL-X		Enter CTRL-X mode.  This is a sub-mode where commands can
		be given to complete words or scroll the window.  See
		|i_CTRL-X| and |ins-completion|. {not in Vi}

						*i_CTRL-E*
CTRL-E		Insert the character which is below the cursor.  {not in Vi}
						*i_CTRL-Y*
CTRL-Y		Insert the character which is above the cursor.  {not in Vi}
		Note that for CTRL-E and CTRL-Y 'textwidth' is not used, to be
		able to copy characters from a long line.

						*i_CTRL-_*
CTRL-_		Switch between languages, as follows:
		-  When in a rightleft window, revins and nohkmap are toggled,
		   since English will likely be inserted in this case.
		-  When in a norightleft window, revins and hkmap are toggled,
		   since Hebrew will likely be inserted in this case.

		CTRL-_ moves the cursor to the end of the typed text.

		This command is only available when the 'allowrevins' option
		is set.
		Please refer to |rileft.txt| for more information about
		right-to-left mode.
		{not in Vi}
		Only if compiled with the |+rightleft| feature.

						*i_CTRL-^*
CTRL-^		Toggle the use of typing language characters.
		When language |:lmap| mappings are defined:
		- If 'iminsert' is 1 (langmap mappings used) it becomes 0 (no
		  langmap mappings used).
		- If 'iminsert' has another value it becomes 1, thus langmap
		  mappings are enabled.
		When no language mappings are defined:
		- If 'iminsert' is 2 (Input Method used) it becomes 0 (no
		  Input Method used).
		- If 'iminsert' has another value it becomes 2, thus the Input
		  Method is enabled.
		When set to 1, the value of the "b:keymap_name" variable, the
		'keymap' option or "<lang>" appears in the status line.
		The language mappings are normally used to type characters
		that are different from what the keyboard produces.  The
		'keymap' option can be used to install a whole number of them.
		{not in Vi}

						*i_CTRL-]*
CTRL-]		Trigger abbreviation, without inserting a character.  {not in
		Vi}

						*i_<Insert>*
<Insert>	Toggle between Insert and Replace mode.  {not in Vi}
-----------------------------------------------------------------------

						*i_backspacing*
The effect of the <BS>, CTRL-W, and CTRL-U depend on the 'backspace' option
(unless 'revins' is set).  This is a comma separated list of items:

item	    action ~
indent	    allow backspacing over autoindent
eol	    allow backspacing over end-of-line (join lines)
start	    allow backspacing over the start position of insert; CTRL-W and
	    CTRL-U stop once at the start position

When 'backspace' is empty, Vi compatible backspacing is used.  You cannot
backspace over autoindent, before column 1 or before where insert started.

For backwards compatibility the values "0", "1" and "2" are also allowed, see
|'backspace'|.

If the 'backspace' option does contain "eol" and the cursor is in column 1
when one of the three keys is used, the current line is joined with the
previous line.  This effectively deletes the <EOL> in front of the cursor.
{Vi: does not cross lines, does not delete past start position of insert}

						*i_CTRL-V_digit*
With CTRL-V the decimal, octal or hexadecimal value of a character can be
entered directly.  This way you can enter any character, except a line break
(<NL>, value 10).  There are five ways to enter the character value:

first char	mode	     max nr of chars   max value ~
(none)		decimal		   3		255
o or O		octal		   3		377	 (255)
x or X		hexadecimal	   2		ff	 (255)
u		hexadecimal	   4		ffff	 (65535)
U		hexadecimal	   8		7fffffff (2147483647)

Normally you would type the maximum number of characters.  Thus to enter a
space (value 32) you would type <C-V>032.  You can omit the leading zero, in
which case the character typed after the number must be a non-digit.  This
happens for the other modes as well: As soon as you type a character that is
invalid for the mode, the value before it will be used and the "invalid"
character is dealt with in the normal way.

If you enter a value of 10, it will end up in the file as a 0.  The 10 is a
<NL>, which is used internally to represent the <Nul> character.  When writing
the buffer to a file, the <NL> character is translated into <Nul>.  The <NL>
character is written at the end of each line.  Thus if you want to insert a
<NL> character in a file you will have to make a line break.

						*i_CTRL-X* *insert_expand*
CTRL-X enters a sub-mode where several commands can be used.  Most of these
commands do keyword completion; see |ins-completion|.  These are not available
when Vim was compiled without the |+insert_expand| feature.

Two commands can be used to scroll the window up or down, without exiting
insert mode:

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		scroll window one line up.
			When doing completion look here: |complete_CTRL-E|

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		scroll window one line down.
			When doing completion look here: |complete_CTRL-Y|

After CTRL-X is pressed, each CTRL-E (CTRL-Y) scrolls the window up (down) by
one line unless that would cause the cursor to move from its current position
in the file.  As soon as another key is pressed, CTRL-X mode is exited and
that key is interpreted as in Insert mode.


==============================================================================
2. Special special keys				*ins-special-special*

The following keys are special.  They stop the current insert, do something,
and then restart insertion.  This means you can do something without getting
out of Insert mode.  This is very handy if you prefer to use the Insert mode
all the time, just like editors that don't have a separate Normal mode.  You
may also want to set the 'backspace' option to "indent,eol,start" and set the
'insertmode' option.  You can use CTRL-O if you want to map a function key to
a command.

The changes (inserted or deleted characters) before and after these keys can
be undone separately.  Only the last change can be redone and always behaves
like an "i" command.

char		action	~
-----------------------------------------------------------------------
<Up>		cursor one line up			     *i_<Up>*
<Down>		cursor one line down			     *i_<Down>*
CTRL-G <Up>	cursor one line up, insert start column	     *i_CTRL-G_<Up>*
CTRL-G k	cursor one line up, insert start column	     *i_CTRL-G_k*
CTRL-G CTRL-K	cursor one line up, insert start column	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	cursor one line down, insert start column    *i_CTRL-G_<Down>*
CTRL-G j	cursor one line down, insert start column    *i_CTRL-G_j*
CTRL-G CTRL-J	cursor one line down, insert start column    *i_CTRL-G_CTRL-J*
<Left>		cursor one character left		     *i_<Left>*
<Right>		cursor one character right		     *i_<Right>*
<S-Left>	cursor one word back (like "b" command)	     *i_<S-Left>*
<C-Left>	cursor one word back (like "b" command)	     *i_<C-Left>*
<S-Right>	cursor one word forward (like "w" command)   *i_<S-Right>*
<C-Right>	cursor one word forward (like "w" command)   *i_<C-Right>*
<Home>		cursor to first char in the line	     *i_<Home>*
<End>		cursor to after last char in the line	     *i_<End>*
<C-Home>	cursor to first char in the file	     *i_<C-Home>*
<C-End>		cursor to after last char in the file	     *i_<C-End>*
<LeftMouse>	cursor to position of mouse click	     *i_<LeftMouse>*
<S-Up>		move window one page up			     *i_<S-Up>*
<PageUp>	move window one page up			     *i_<PageUp>*
<S-Down>	move window one page down		     *i_<S-Down>*
<PageDown>	move window one page down		     *i_<PageDown>*
<ScrollWheelDown>    move window three lines down	*i_<ScrollWheelDown>*
<S-ScrollWheelDown>  move window one page down		*i_<S-ScrollWheelDown>*
<ScrollWheelUp>      move window three lines up		*i_<ScrollWheelUp>*
<S-ScrollWheelUp>    move window one page up		*i_<S-ScrollWheelUp>*
<ScrollWheelLeft>    move window six columns left	*i_<ScrollWheelLeft>*
<S-ScrollWheelLeft>  move window one page left		*i_<S-ScrollWheelLeft>*
<ScrollWheelRight>   move window six columns right	*i_<ScrollWheelRight>*
<S-ScrollWheelRight> move window one page right		*i_<S-ScrollWheelRight>*
CTRL-O		execute one command, return to Insert mode   *i_CTRL-O*
CTRL-\ CTRL-O	like CTRL-O but don't move the cursor	     *i_CTRL-\_CTRL-O*
CTRL-L		when 'insertmode' is set: go to Normal mode  *i_CTRL-L*
CTRL-G u	break undo sequence, start new change	     *i_CTRL-G_u*
CTRL-G U	don't break undo with next left/right cursor *i_CTRL-G_U*
		movement (but only if the cursor stays
		within same the line)
-----------------------------------------------------------------------

Note: If the cursor keys take you out of Insert mode, check the 'noesckeys'
option.

The CTRL-O command sometimes has a side effect: If the cursor was beyond the
end of the line, it will be put on the last character in the line.  In
mappings it's often better to use <Esc> (first put an "x" in the text, <Esc>
will then always put the cursor on it).  Or use CTRL-\ CTRL-O, but then
beware of the cursor possibly being beyond the end of the line.  Note that the
command following CTRL-\ CTRL-O can still move the cursor, it is not restored
to its original position.

The CTRL-O command takes you to Normal mode.  If you then use a command enter
Insert mode again it normally doesn't nest.  Thus when typing "a<C-O>a" and
then <Esc> takes you back to Normal mode, you do not need to type <Esc> twice.
An exception is when not typing the command, e.g. when executing a mapping or
sourcing a script.  This makes mappings work that briefly switch to Insert
mode.

The shifted cursor keys are not available on all terminals.

Another side effect is that a count specified before the "i" or "a" command is
ignored.  That is because repeating the effect of the command after CTRL-O is
too complicated.

An example for using CTRL-G u: >

	:inoremap <C-H> <C-G>u<C-H>

This redefines the backspace key to start a new undo sequence.  You can now
undo the effect of the backspace key, without changing what you typed before
that, with CTRL-O u.  Another example: >

	:inoremap <CR> <C-]><C-G>u<CR>

This breaks undo at each line break.  It also expands abbreviations before
this.

An example for using CTRL-G U: >

	inoremap <Left>  <C-G>U<Left>
	inoremap <Right> <C-G>U<Right>
	inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
	 \ repeat('<C-G>U<Left>', col('.') - 1) :
	 \ (col('.') < match(getline('.'), '\S') ?
	 \     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
	 \     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
	inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
	inoremap ( ()<C-G>U<Left>

This makes it possible to use the cursor keys in Insert mode, without breaking
the undo sequence and therefore using |.| (redo) will work as expected. 
Also entering a text like (with the "(" mapping from above): >

   Lorem ipsum (dolor

will be repeatable by the |.|to the expected

   Lorem ipsum (dolor)

Using CTRL-O splits undo: the text typed before and after it is undone
separately.  If you want to avoid this (e.g., in a mapping) you might be able
to use CTRL-R = |i_CTRL-R|.  E.g., to call a function: >
	:imap <F2> <C-R>=MyFunc()<CR>

When the 'whichwrap' option is set appropriately, the <Left> and <Right>
keys on the first/last character in the line make the cursor wrap to the
previous/next line.

The CTRL-G j and CTRL-G k commands can be used to insert text in front of a
column.  Example: >
   int i;
   int j;
Position the cursor on the first "int", type "istatic <C-G>j       ".  The
result is: >
   static int i;
	  int j;
When inserting the same text in front of the column in every line, use the
Visual blockwise command "I" |v_b_I|.

==============================================================================
3. 'textwidth' and 'wrapmargin' options			*ins-textwidth*

The 'textwidth' option can be used to automatically break a line before it
gets too long.  Set the 'textwidth' option to the desired maximum line
length.  If you then type more characters (not spaces or tabs), the
last word will be put on a new line (unless it is the only word on the
line).  If you set 'textwidth' to 0, this feature is disabled.

The 'wrapmargin' option does almost the same.  The difference is that
'textwidth' has a fixed width while 'wrapmargin' depends on the width of the
screen.  When using 'wrapmargin' this is equal to using 'textwidth' with a
value equal to (columns - 'wrapmargin'), where columns is the width of the
screen.

When 'textwidth' and 'wrapmargin' are both set, 'textwidth' is used.

If you don't really want to break the line, but view the line wrapped at a
convenient place, see the 'linebreak' option.

The line is only broken automatically when using Insert mode, or when
appending to a line.  When in replace mode and the line length is not
changed, the line will not be broken.

Long lines are broken if you enter a non-white character after the margin.
The situations where a line will be broken can be restricted by adding
characters to the 'formatoptions' option:
"l"  Only break a line if it was not longer than 'textwidth' when the insert
     started.
"v"  Only break at a white character that has been entered during the
     current insert command.  This is mostly Vi-compatible.
"lv" Only break if the line was not longer than 'textwidth' when the insert
     started and only at a white character that has been entered during the
     current insert command.  Only differs from "l" when entering non-white
     characters while crossing the 'textwidth' boundary.

Normally an internal function will be used to decide where to break the line.
If you want to do it in a different way set the 'formatexpr' option to an
expression that will take care of the line break.

If you want to format a block of text, you can use the "gq" operator.  Type
"gq" and a movement command to move the cursor to the end of the block.  In
many cases, the command "gq}" will do what you want (format until the end of
paragraph).  Alternatively, you can use "gqap", which will format the whole
paragraph, no matter where the cursor currently is.  Or you can use Visual
mode: hit "v", move to the end of the block, and type "gq".  See also |gq|.

==============================================================================
4. 'expandtab', 'smarttab' and 'softtabstop' options	*ins-expandtab*

If the 'expandtab' option is on, spaces will be used to fill the amount of
whitespace of the tab.  If you want to enter a real <Tab>, type CTRL-V first
(use CTRL-Q when CTRL-V is mapped |i_CTRL-Q|).
The 'expandtab' option is off by default.  Note that in Replace mode, a single
character is replaced with several spaces.  The result of this is that the
number of characters in the line increases.  Backspacing will delete one
space at a time.  The original character will be put back for only one space
that you backspace over (the last one).  {Vi does not have the 'expandtab'
option}

							*ins-smarttab*
When the 'smarttab' option is on, a <Tab> inserts 'shiftwidth' positions at
the beginning of a line and 'tabstop' positions in other places.  This means
that often spaces instead of a <Tab> character are inserted.  When 'smarttab'
is off, a <Tab> always inserts 'tabstop' positions, and 'shiftwidth' is only
used for ">>" and the like.  {not in Vi}

							*ins-softtabstop*
When the 'softtabstop' option is non-zero, a <Tab> inserts 'softtabstop'
positions, and a <BS> used to delete white space, will delete 'softtabstop'
positions.  This feels like 'tabstop' was set to 'softtabstop', but a real
<Tab> character still takes 'tabstop' positions, so your file will still look
correct when used by other applications.

If 'softtabstop' is non-zero, a <BS> will try to delete as much white space to
move to the previous 'softtabstop' position, except when the previously
inserted character is a space, then it will only delete the character before
the cursor.  Otherwise you cannot always delete a single character before the
cursor.  You will have to delete 'softtabstop' characters first, and then type
extra spaces to get where you want to be.

==============================================================================
5. Replace mode				*Replace* *Replace-mode* *mode-replace*

Enter Replace mode with the "R" command in normal mode.

In Replace mode, one character in the line is deleted for every character you
type.  If there is no character to delete (at the end of the line), the
typed character is appended (as in Insert mode).  Thus the number of
characters in a line stays the same until you get to the end of the line.
If a <NL> is typed, a line break is inserted and no character is deleted.

Be careful with <Tab> characters.  If you type a normal printing character in
its place, the number of characters is still the same, but the number of
columns will become smaller.

If you delete characters in Replace mode (with <BS>, CTRL-W, or CTRL-U), what
happens is that you delete the changes.  The characters that were replaced
are restored.  If you had typed past the existing text, the characters you
added are deleted.  This is effectively a character-at-a-time undo.

If the 'expandtab' option is on, a <Tab> will replace one character with
several spaces.  The result of this is that the number of characters in the
line increases.  Backspacing will delete one space at a time.  The original
character will be put back for only one space that you backspace over (the
last one).  {Vi does not have the 'expandtab' option}

==============================================================================
6. Virtual Replace mode		*vreplace-mode* *Virtual-Replace-mode*

Enter Virtual Replace mode with the "gR" command in normal mode.
{not available when compiled without the |+vreplace| feature}
{Vi does not have Virtual Replace mode}

Virtual Replace mode is similar to Replace mode, but instead of replacing
actual characters in the file, you are replacing screen real estate, so that
characters further on in the file never appear to move.

So if you type a <Tab> it may replace several normal characters, and if you
type a letter on top of a <Tab> it may not replace anything at all, since the
<Tab> will still line up to the same place as before.

Typing a <NL> still doesn't cause characters later in the file to appear to
move.  The rest of the current line will be replaced by the <NL> (that is,
they are deleted), and replacing continues on the next line.  A new line is
NOT inserted unless you go past the end of the file.

Interesting effects are seen when using CTRL-T and CTRL-D.  The characters
before the cursor are shifted sideways as normal, but characters later in the
line still remain still.  CTRL-T will hide some of the old line under the
shifted characters, but CTRL-D will reveal them again.

As with Replace mode, using <BS> etc will bring back the characters that were
replaced.  This still works in conjunction with 'smartindent', CTRL-T and
CTRL-D, 'expandtab', 'smarttab', 'softtabstop', etc.

In 'list' mode, Virtual Replace mode acts as if it was not in 'list' mode,
unless "L" is in 'cpoptions'.

Note that the only situations for which characters beyond the cursor should
appear to move are in List mode |'list'|, and occasionally when 'wrap' is set
(and the line changes length to become shorter or wider than the width of the
screen).  In other cases spaces may be inserted to avoid following characters
to move.

This mode is very useful for editing <Tab> separated columns in tables, for
entering new data while keeping all the columns aligned.

==============================================================================
7. Insert mode completion				*ins-completion*

In Insert and Replace mode, there are several commands to complete part of a
keyword or line that has been typed.  This is useful if you are using
complicated keywords (e.g., function names with capitals and underscores).

These commands are not available when the |+insert_expand| feature was
disabled at compile time.

Completion can be done for:

1. Whole lines						|i_CTRL-X_CTRL-L|
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							|i_CTRL-X_CTRL-]|
7. file names						|i_CTRL-X_CTRL-F|
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N|

All these (except 2) are done in CTRL-X mode.  This is a sub-mode of Insert
and Replace modes.  You enter CTRL-X mode by typing CTRL-X and one of the
CTRL-X commands.  You exit CTRL-X mode by typing a key that is not a valid
CTRL-X mode command.  Valid keys are the CTRL-X command itself, CTRL-N (next),
and CTRL-P (previous).

Also see the 'infercase' option if you want to adjust the case of the match.

							*complete_CTRL-E*
When completion is active you can use CTRL-E to stop it and go back to the
originally typed text.  The CTRL-E will not be inserted.

							*complete_CTRL-Y*
When the popup menu is displayed you can use CTRL-Y to stop completion and
accept the currently selected entry.  The CTRL-Y is not inserted.  Typing a
space, Enter, or some other unprintable character will leave completion mode
and insert that typed character.

When the popup menu is displayed there are a few more special keys, see
|popupmenu-keys|.

Note: The keys that are valid in CTRL-X mode are not mapped.  This allows for
":map ^F ^X^F" to work (where ^F is CTRL-F and ^X is CTRL-X).  The key that
ends CTRL-X mode (any key that is not a valid CTRL-X mode command) is mapped.
Also, when doing completion with 'complete' mappings apply as usual.

Note: While completion is active Insert mode can't be used recursively.
Mappings that somehow invoke ":normal i.." will generate an E523 error.

The following mappings are suggested to make typing the completion commands
a bit easier (although they will hide other commands): >
    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^D ^X^D
    :inoremap ^L ^X^L

As a special case, typing CTRL-R to perform register insertion (see
|i_CTRL-R|) will not exit CTRL-X mode.  This is primarily to allow the use of
the '=' register to call some function to determine the next operation.  If
the contents of the register (or result of the '=' register evaluation) are
not valid CTRL-X mode keys, then CTRL-X mode will be exited as if those keys
had been typed.

For example, the following will map <Tab> to either actually insert a <Tab> if
the current line is currently only whitespace, or start/continue a CTRL-N
completion operation: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	   endif
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>



Completing whole lines					*compl-whole-line*

							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the
			same characters as those in the current line before
			the cursor.  Indent is ignored.  The matching line is
			inserted in front of the cursor.
			The 'complete' option is used to decide which buffers
			are searched for a match.  Both loaded and unloaded
			buffers are used.
	CTRL-L	or
	CTRL-P		Search backwards for next matching line.  This line
			replaces the previous matching line.

	CTRL-N		Search forward for next matching line.  This line
			replaces the previous matching line.

	CTRL-X CTRL-L	After expanding a line you can additionally get the
			line next to it by typing CTRL-X CTRL-L again, unless
			a double CTRL-X is used.  Only works for loaded
			buffers.

Completing keywords in current file			*compl-current*

							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		Search forwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.

CTRL-X CTRL-P		Search backwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.

If there is a keyword in front of the cursor (a name made out of alphabetic
characters and characters in 'iskeyword'), it is used as the search pattern,
with "\<" prepended (meaning: start of a word).  Otherwise "\<\k\k" is used
as search pattern (start of any keyword of at least two characters).

In Replace mode, the number of characters that are replaced depends on the
length of the matched string.  This works like typing the characters of the
matched string in Replace mode.

If there is not a valid keyword character before the cursor, any keyword of
at least two characters is matched.
	e.g., to get:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	just type:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

The search wraps around the end of the file, the value of 'wrapscan' is not
used here.

Multiple repeats of the same completion are skipped; thus a different match
will be inserted at each CTRL-N and CTRL-P (unless there is only one
matching keyword).

Single character matches are never included, as they usually just get in
the way of what you were really after.
	e.g., to get:
		printf("name = %s\n", name);
	just type:
		printf("name = %s\n", n^P);
	or even:
		printf("name = %s\n", ^P);
The 'n' in '\n' is skipped.

After expanding a word, you can use CTRL-X CTRL-P or CTRL-X CTRL-N to get the
word following the expansion in other contexts.  These sequences search for
the text just expanded and further expand by getting an extra word.  This is
useful if you need to repeat a sequence of complicated words.  Although CTRL-P
and CTRL-N look just for strings of at least two characters, CTRL-X CTRL-P and
CTRL-X CTRL-N can be used to expand words of just one character.
	e.g., to get:
		M&eacute;xico
	you can type:
		M^N^P^X^P^X^P
CTRL-N starts the expansion and then CTRL-P takes back the single character
"M", the next two CTRL-X CTRL-P's get the words "&eacute" and ";xico".

If the previous expansion was split, because it got longer than 'textwidth',
then just the text in the current line will be used.

If the match found is at the end of a line, then the first word in the next
line will be inserted and the message "word from next line" displayed, if
this word is accepted the next CTRL-X CTRL-P or CTRL-X CTRL-N will search
for those lines starting with this word.


Completing keywords in 'dictionary'			*compl-dictionary*

							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		Search the files given with the 'dictionary' option
			for words that start with the keyword in front of the
			cursor.  This is like CTRL-N, but only the dictionary
			files are searched, not the current file.  The found
			keyword is inserted in front of the cursor.  This
			could potentially be pretty slow, since all matches
			are found before the first match is used.  By default,
			the 'dictionary' option is empty.
			For suggestions where to find a list of words, see the
			'dictionary' option.

	CTRL-K	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		Works as CTRL-X CTRL-K, but in a special way.  It uses
			the 'thesaurus' option instead of 'dictionary'.  If a
			match is found in the thesaurus file, all the
			remaining words on the same line are included as
			matches, even though they don't complete the word.
			Thus a word can be completely replaced.

			For an example, imagine the 'thesaurus' file has a
			line like this: >
				angry furious mad enraged
<			Placing the cursor after the letters "ang" and typing
			CTRL-X CTRL-T would complete the word "angry";
			subsequent presses would change the word to "furious",
			"mad" etc.
			Other uses include translation between two languages,
			or grouping API functions by keyword.

	CTRL-T	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.


Completing keywords in the current and included files	*compl-keyword*

The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Search for the first keyword in the current and
			included files that starts with the same characters
			as those before the cursor.  The matched keyword is
			inserted in front of the cursor.

	CTRL-N		Search forwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
			Note: CTRL-I is the same as <Tab>, which is likely to
			be typed after a successful completion, therefore
			CTRL-I is not used for searching for the next match.

	CTRL-P		Search backward for previous matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-I	Further use of CTRL-X CTRL-I will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.

Completing tags						*compl-tag*
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same
			characters as before the cursor.  The matching tag is
			inserted in front of the cursor.  Alphabetic
			characters and characters in 'iskeyword' are used
			to decide which characters are included in the tag
			name (same as for a keyword).  See also |CTRL-]|.
			The 'showfulltag' option can be used to add context
			from around the tag definition.
	CTRL-]	or
	CTRL-N		Search forwards for next matching tag.  This tag
			replaces the previous matching tag.

	CTRL-P		Search backward for previous matching tag.  This tag
			replaces the previous matching tag.


Completing file names					*compl-filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the
			same characters as before the cursor.  The matching
			file name is inserted in front of the cursor.
			Alphabetic characters and characters in 'isfname'
			are used to decide which characters are included in
			the file name.  Note: the 'path' option is not used
			here (yet).
	CTRL-F	or
	CTRL-N		Search forwards for next matching file name.  This
			file name replaces the previous matching file name.

	CTRL-P		Search backward for previous matching file name.
			This file name replaces the previous matching file
			name.


Completing definitions or macros			*compl-define*

The 'define' option is used to specify a line that contains a definition.
The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Search in the current and included files for the
			first definition (or macro) name that starts with
			the same characters as before the cursor.  The found
			definition name is inserted in front of the cursor.
	CTRL-D	or
	CTRL-N		Search forwards for next matching macro name.  This
			macro name replaces the previous matching macro
			name.

	CTRL-P		Search backward for previous matching macro name.
			This macro name replaces the previous matching macro
			name.

	CTRL-X CTRL-D	Further use of CTRL-X CTRL-D will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.


Completing Vim commands					*compl-vim*

Completion is context-sensitive.  It works like on the Command-line.  It
completes an Ex command as well as its arguments.  This is useful when writing
a Vim script.

							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		Guess what kind of item is in front of the cursor and
			find the first match for it.
			Note: When CTRL-V is mapped you can often use CTRL-Q
			instead of |i_CTRL-Q|.
	CTRL-V	or
	CTRL-N		Search forwards for next match.  This match replaces
			the previous one.

	CTRL-P		Search backwards for previous match.  This match
			replaces the previous one.

	CTRL-X CTRL-V	Further use of CTRL-X CTRL-V will do the same as
			CTRL-V.  This allows mapping a key to do Vim command
			completion, for example: >
				:imap <Tab> <C-X><C-V>

User defined completion					*compl-function*

Completion is done by a function that can be defined by the user with the
'completefunc' option.  See below for how the function is called and an
example |complete-functions|.

							*i_CTRL-X_CTRL-U*
CTRL-X CTRL-U		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-U	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

							*i_CTRL-X_CTRL-O*
CTRL-X CTRL-O		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-O	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Spelling suggestions					*compl-spelling*

A word before or at the cursor is located and correctly spelled words are
suggested to replace it.  If there is a badly spelled word in the line, before
or under the cursor, the cursor is moved to after it.  Otherwise the word just
before the cursor is used for suggestions, even though it isn't badly spelled.

NOTE: CTRL-S suspends display in many Unix terminals.  Use 's' instead.  Type
CTRL-Q to resume displaying.

						*i_CTRL-X_CTRL-S* *i_CTRL-X_s*
CTRL-X CTRL-S   or
CTRL-X s		Locate the word in front of the cursor and find the
			first spell suggestion for it.
	CTRL-S	or
	CTRL-N		Use the next suggestion.  This replaces the previous
			one.  Note that you can't use 's' here.

	CTRL-P		Use the previous suggestion.  This replaces the
			previous one.


Completing keywords from different sources		*compl-generic*

							*i_CTRL-N*
CTRL-N			Find next match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

							*i_CTRL-P*
CTRL-P			Find previous match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.


FUNCTIONS FOR FINDING COMPLETIONS			*complete-functions*

This applies to 'completefunc' and 'omnifunc'.

The function is called in two different ways:
- First the function is called to find the start of the text to be completed.
- Later the function is called to actually find the matches.

On the first invocation the arguments are:
   a:findstart  1
   a:base	empty

The function must return the column where the completion starts.  It must be a
number between zero and the cursor column "col('.')".  This involves looking
at the characters just before the cursor and including those characters that
could be part of the completed item.  The text between this column and the
cursor column will be replaced with the matches.

Special return values:
   -1 If no completion can be done, the completion will be cancelled with an
      error message.
   -2 To cancel silently and stay in completion mode.
   -3 To cancel silently and leave completion mode.

On the second invocation the arguments are:
   a:findstart  0
   a:base	the text with which matches should match; the text that was
		located in the first call (can be empty)

The function must return a List with the matching words.  These matches
usually include the "a:base" text.  When there are no matches return an empty
List.

In order to return more information than the matching words, return a Dict
that contains the List.  The Dict can have these items:
	words		The List of matching words (mandatory).
	refresh		A string to control re-invocation of the function
			(optional).
			The only value currently recognized is "always", the
			effect is that the function is called whenever the
			leading text is changed.
Other items are ignored.

For acting upon end of completion, see the |CompleteDone| autocommand event.

For example, the function can contain this: >
	let matches = ... list of words ...
	return {'words': matches, 'refresh': 'always'}
<
						*complete-items*
Each list item can either be a string or a Dictionary.  When it is a string it
is used as the completion.  When it is a Dictionary it can contain these
items:
	word		the text that will be inserted, mandatory
	abbr		abbreviation of "word"; when not empty it is used in
			the menu instead of "word"
	menu		extra text for the popup menu, displayed after "word"
			or "abbr"
	info		more information about the item, can be displayed in a
			preview window
	kind		single letter indicating the type of completion
	icase		when non-zero case is to be ignored when comparing
			items to be equal; when omitted zero is used, thus
			items that only differ in case are added
	dup		when non-zero this match will be added even when an
			item with the same word is already present.
	empty		when non-zero this match will be added even when it is
			an empty string

All of these except 'icase', 'dup' and 'empty' must be a string.  If an item
does not meet these requirements then an error message is given and further
items in the list are not used.  You can mix string and Dictionary items in
the returned list.

The "menu" item is used in the popup menu and may be truncated, thus it should
be relatively short.  The "info" item can be longer, it will  be displayed in
the preview window when "preview" appears in 'completeopt'.  The "info" item
will also remain displayed after the popup menu has been removed.  This is
useful for function arguments.  Use a single space for "info" to remove
existing text in the preview window.  The size of the preview window is three
lines, but 'previewheight' is used when it has a value of 1 or 2.

The "kind" item uses a single letter to indicate the kind of completion.  This
may be used to show the completion differently (different color or icon).
Currently these types can be used:
	v	variable
	f	function or method
	m	member of a struct or class
	t	typedef
	d	#define or macro

When searching for matches takes some time call |complete_add()| to add each
match to the total list.  These matches should then not appear in the returned
list!  Call |complete_check()| now and then to allow the user to press a key
while still searching for matches.  Stop searching when it returns non-zero.

							*E839* *E840*
The function is allowed to move the cursor, it is restored afterwards.
The function is not allowed to move to another window or delete text.

An example that completes the names of the months: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    let res = []
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call add(res, m)
	      endif
	    endfor
	    return res
	  endif
	endfun
	set completefunc=CompleteMonths
<
The same, but now pretending searching for matches is slow: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call complete_add(m)
	      endif
	      sleep 300m	" simulate searching for next match
	      if complete_check()
		break
	      endif
	    endfor
	    return []
	  endif
	endfun
	set completefunc=CompleteMonths
<

INSERT COMPLETION POPUP MENU				*ins-completion-menu*
							*popupmenu-completion*
Vim can display the matches in a simplistic popup menu.

The menu is used when:
- The 'completeopt' option contains "menu" or "menuone".
- The terminal supports at least 8 colors.
- There are at least two matches.  One if "menuone" is used.

The 'pumheight' option can be used to set a maximum height.  The default is to
use all space available.

There are three states:
1. A complete match has been inserted, e.g., after using CTRL-N or CTRL-P.
2. A cursor key has been used to select another match.  The match was not
   inserted then, only the entry in the popup menu is highlighted.
3. Only part of a match has been inserted and characters were typed or the
   backspace key was used.  The list of matches was then adjusted for what is
   in front of the cursor.

You normally start in the first state, with the first match being inserted.
When "longest" is in 'completeopt' and there is more than one match you start
in the third state.

If you select another match, e.g., with CTRL-N or CTRL-P, you go to the first
state.  This doesn't change the list of matches.

When you are back at the original text then you are in the third state.  To
get there right away you can use a mapping that uses CTRL-P right after
starting the completion: >
	:imap <F7> <C-N><C-P>
<
						*popupmenu-keys*
In the first state these keys have a special meaning:
<BS> and CTRL-H   Delete one character, find the matches for the word before
		  the cursor.  This reduces the list of matches, often to one
		  entry, and switches to the second state.
Any non-special character:
		  Stop completion without changing the match and insert the
		  typed character.

In the second and third state these keys have a special meaning:
<BS> and CTRL-H   Delete one character, find the matches for the shorter word
		  before the cursor.  This may find more matches.
CTRL-L		  Add one character from the current match, may reduce the
		  number of matches.
any printable, non-white character:
		  Add this character and reduce the number of matches.

In all three states these can be used:
CTRL-Y		  Yes: Accept the currently selected match and stop completion.
CTRL-E		  End completion, go back to what was there before selecting a
		  match (what was typed or longest common string).
<PageUp>	  Select a match several entries back, but don't insert it.
<PageDown>	  Select a match several entries further, but don't insert it.
<Up>		  Select the previous match, as if CTRL-P was used, but don't
		  insert it.
<Down>		  Select the next match, as if CTRL-N was used, but don't
		  insert it.
<Space> or <Tab>  Stop completion without changing the match and insert the
		  typed character.

The behavior of the <Enter> key depends on the state you are in:
first state:	  Use the text as it is and insert a line break.
second state:	  Insert the currently selected match.
third state:	  Use the text as it is and insert a line break.

In other words: If you used the cursor keys to select another entry in the
list of matches then the <Enter> key inserts that match.  If you typed
something else then <Enter> inserts a line break.


The colors of the menu can be changed with these highlight groups:
Pmenu		normal item  |hl-Pmenu|
PmenuSel	selected item  |hl-PmenuSel|
PmenuSbar	scrollbar  |hl-PmenuSbar|
PmenuThumb	thumb of the scrollbar  |hl-PmenuThumb|

There are no special mappings for when the popup menu is visible.  However,
you can use an Insert mode mapping that checks the |pumvisible()| function to
do something different.  Example: >
	:inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>

You can use of <expr> in mapping to have the popup menu used when typing a
character and some condition is met.  For example, for typing a dot: >
	inoremap <expr> . MayComplete()
	func MayComplete()
	    if (can complete)
	      return ".\<C-X>\<C-O>"
	    endif
	    return '.'
	endfunc

See |:map-<expr>| for more info.


FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*

The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.


C							*ft-c-omni*

Completion of C code requires a tags file.  You should use Exuberant ctags,
because it adds extra information that is needed for completion.  You can find
it here: http://ctags.sourceforge.net/  Version 5.6 or later is recommended.

For version 5.5.4 you should add a patch that adds the "typename:" field:
	ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch
A compiled .exe for MS-Windows can be found at:
	http://georgevreilly.com/vim/ctags.html

If you want to complete system functions you can do something like this.  Use
ctags to generate a tags file for all the system header files: >
	% ctags -R -f ~/.vim/systags /usr/include /usr/local/include
In your vimrc file add this tags file to the 'tags' option: >
	set tags+=~/.vim/systags

When using CTRL-X CTRL-O after a name without any "." or "->" it is completed
from the tags file directly.  This works for any identifier, also function
names.  If you want to complete a local variable name, which does not appear
in the tags file, use CTRL-P instead.

When using CTRL-X CTRL-O after something that has "." or "->" Vim will attempt
to recognize the type of the variable and figure out what members it has.
This means only members valid for the variable will be listed.

When a member name already was complete, CTRL-X CTRL-O will add a "." or
"->" for composite types.

Vim doesn't include a C compiler, only the most obviously formatted
declarations are recognized.  Preprocessor stuff may cause confusion.
When the same structure name appears in multiple places all possible members
are included.


CSS							*ft-css-omni*

Complete properties and their appropriate values according to CSS 2.1
specification.


HTML							*ft-html-omni*
XHTML							*ft-xhtml-omni*

CTRL-X CTRL-O provides completion of various elements of (X)HTML files.  It is
designed to support writing of XHTML 1.0 Strict files but will also work for
other versions of HTML. Features:

- after "<" complete tag name depending on context (no div suggestion inside
  of an a tag); '/>' indicates empty tags
- inside of tag complete proper attributes (no width attribute for an a tag);
  show also type of attribute; '*' indicates required attributes
- when attribute has limited number of possible values help to complete them
- complete names of entities
- complete values of "class" and "id" attributes with data obtained from
  <style> tag and included CSS files
- when completing value of "style" attribute or working inside of "style" tag
  switch to |ft-css-omni| completion
- when completing values of events attributes or working inside of "script"
  tag switch to |ft-javascript-omni| completion
- when used after "</" CTRL-X CTRL-O will close the last opened tag

Note: When used first time completion menu will be shown with little delay
- this is time needed for loading of data file.
Note: Completion may fail in badly formatted documents. In such case try to
run |:make| command to detect formatting problems.


HTML flavor						*html-flavor*

The default HTML completion depends on the filetype.  For HTML files it is
HTML 4.01 Transitional ('filetype' is "html"), for XHTML it is XHTML 1.0
Strict ('filetype' is "xhtml").

When doing completion outside of any other tag you will have possibility to
choose DOCTYPE and the appropriate data file will be loaded and used for all
next completions.

More about format of data file in |xml-omni-datafile|. Some of the data files
may be found on the Vim website (|www|).

Note that b:html_omni_flavor may point to a file with any XML data.  This
makes possible to mix PHP (|ft-php-omni|) completion with any XML dialect
(assuming you have data file for it).  Without setting that variable XHTML 1.0
Strict will be used.


JAVASCRIPT					       *ft-javascript-omni*

Completion of most elements of JavaScript language and DOM elements.

Complete:

- variables
- function name; show function arguments
- function arguments
- properties of variables trying to detect type of variable
- complete DOM objects and properties depending on context
- keywords of language

Completion works in separate JavaScript files (&ft==javascript), inside of
<script> tag of (X)HTML and in values of event attributes (including scanning
of external files).

DOM compatibility

At the moment (beginning of 2006) there are two main browsers - MS Internet
Explorer and Mozilla Firefox. These two applications are covering over 90% of
market. Theoretically standards are created by W3C organisation
(http://www.w3c.org) but they are not always followed/implemented.

		IE	FF	W3C  Omni completion ~
		+/-	+/-	+    +		     ~
		+	+	-    +		     ~
		+	-	-    -		     ~
		-	+	-    -		     ~

Regardless from state of implementation in browsers but if element is defined
in standards, completion plugin will place element in suggestion list. When
both major engines implemented element, even if this is not in standards it
will be suggested. All other elements are not placed in suggestion list.


PHP							*ft-php-omni*

Completion of PHP code requires a tags file for completion of data from
external files and for class aware completion. You should use Exuberant ctags
version 5.5.4 or newer. You can find it here: http://ctags.sourceforge.net/

Script completes:

- after $ variables name
  - if variable was declared as object add "->", if tags file is available show
    name of class
  - after "->" complete only function and variable names specific for given
    class. To find class location and contents tags file is required. Because
    PHP isn't strongly typed language user can use @var tag to declare class: >

	/* @var $myVar myClass */
	$myVar->
<
    Still, to find myClass contents tags file is required.

- function names with additional info:
  - in case of built-in functions list of possible arguments and after | type
    data returned by function
  - in case of user function arguments and name of file where function was
    defined (if it is not current file)

- constants names
- class names after "new" declaration


Note: when doing completion first time Vim will load all necessary data into
memory. It may take several seconds. After next use of completion delay
should not be noticeable.

Script detects if cursor is inside <?php ?> tags. If it is outside it will
automatically switch to HTML/CSS/JavaScript completion. Note: contrary to
original HTML files completion of tags (and only tags) isn't context aware.


RUBY							*ft-ruby-omni*

Completion of Ruby code requires that vim be built with |+ruby|.

Ruby completion will parse your buffer on demand in order to provide a list of
completions.  These completions will be drawn from modules loaded by 'require'
and modules defined in the current buffer.

The completions provided by CTRL-X CTRL-O are sensitive to the context:

	  CONTEXT			   COMPLETIONS PROVIDED ~

 1. Not inside a class definition    Classes, constants and globals

 2. Inside a class definition	     Methods or constants defined in the class

 3. After '.', '::' or ':'	     Methods applicable to the object being
				       dereferenced

 4. After ':' or ':foo'		     Symbol name (beginning with 'foo')

Notes:
 - Vim will load/evaluate code in order to provide completions.  This may
   cause some code execution, which may be a concern. This is no longer 
   enabled by default, to enable this feature add >
     let g:rubycomplete_buffer_loading = 1
<- In context 1 above, Vim can parse the entire buffer to add a list of
   classes to the completion results. This feature is turned off by default,
   to enable it add >
     let g:rubycomplete_classes_in_global = 1
<  to your vimrc
 - In context 2 above, anonymous classes are not supported.
 - In context 3 above, Vim will attempt to determine the methods supported by
   the object.
 - Vim can detect and load the Rails environment for files within a rails
   project. The feature is disabled by default, to enable it add >
     let g:rubycomplete_rails = 1
<  to your vimrc


SYNTAX							*ft-syntax-omni*

Vim has the ability to color syntax highlight nearly 500 languages.  Part of
this highlighting includes knowing what keywords are part of a language.  Many
filetypes already have custom completion scripts written for them, the
syntaxcomplete plugin provides basic completion for all other filetypes.  It
does this by populating the omni completion list with the text Vim already
knows how to color highlight.  It can be used for any filetype and provides a
minimal language-sensitive completion.

To enable syntax code completion you can run: >
    setlocal omnifunc=syntaxcomplete#Complete

You can automate this by placing the following in your |.vimrc| (after any
":filetype" command): >
    if has("autocmd") && exists("+omnifunc")
	autocmd Filetype *
		    \	if &omnifunc == "" |
		    \		setlocal omnifunc=syntaxcomplete#Complete |
		    \	endif
    endif

The above will set completion to this script only if a specific plugin does
not already exist for that filetype.

Each filetype can have a wide range of syntax items.  The plugin allows you to
customize which syntax groups to include or exclude from the list.  Let's have
a look at the PHP filetype to see how this works.

If you edit a file called, index.php, run the following command: >
    syntax list

The first thing you will notice is that there are many different syntax groups.
The PHP language can include elements from different languages like HTML,
JavaScript and many more.  The syntax plugin will only include syntax groups
that begin with the filetype, "php", in this case.  For example these syntax
groups are included by default with the PHP: phpEnvVar, phpIntVar,
phpFunctions.

If you wish non-filetype syntax items to also be included, you can use a 
regular expression syntax (added in version 13.0 of autoload\syntaxcomplete.vim)
to add items.  Looking at the output from ":syntax list" while editing a PHP file 
I can see some of these entries: >
    htmlArg,htmlTag,htmlTagName,javaScriptStatement,javaScriptGlobalObjects

To pick up any JavaScript and HTML keyword syntax groups while editing a PHP
file, you can use 3 different regexs, one for each language.  Or you can 
simply restrict the include groups to a particular value, without using 
a regex string: >
    let g:omni_syntax_group_include_php = 'php\w\+,javaScript\w\+,html\w\+'
    let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'
<
The basic form of this variable is: >
    let g:omni_syntax_group_include_{filetype} = 'regex,comma,separated'

The PHP language has an enormous number of items which it knows how to syntax
highlight.  These items will be available within the omni completion list.

Some people may find this list unwieldy or are only interested in certain
items.  There are two ways to prune this list (if necessary).  If you find
certain syntax groups you do not wish displayed you can use two different 
methods to identify these groups.  The first specifically lists the syntax 
groups by name.  The second uses a regular expression to identify both 
syntax groups.  Simply add one the following to your vimrc: >
    let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'
    let g:omni_syntax_group_exclude_php = 'php\w*Constant'

Add as many syntax groups to this list by comma separating them.  The basic
form of this variable is: >
    let g:omni_syntax_group_exclude_{filetype} = 'regex,comma,separated'

You can create as many of these variables as you need, varying only the
filetype at the end of the variable name.

The plugin uses the isKeyword option to determine where word boundaries are
for the syntax items.  For example, in the Scheme language completion should
include the "-", call-with-output-file.  Depending on your filetype, this may
not provide the words you are expecting.  Setting the
g:omni_syntax_use_iskeyword option to 0 will force the syntax plugin to break
on word characters.   This can be controlled adding the following to your
vimrc: >
    let g:omni_syntax_use_iskeyword = 0

For plugin developers, the plugin exposes a public function OmniSyntaxList.
This function can be used to request a List of syntax items.  When editing a
SQL file (:e syntax.sql) you can use the ":syntax list" command to see the 
various groups and syntax items.  For example: >
    syntax list 

Yields data similar to this: >
    sqlOperator    xxx some prior all like and any escape exists in is not 
                       or intersect minus between distinct
                       links to Operator
    sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier 
                       date money long tinyint unsigned xml text smalldate 
                       double datetime nchar smallint numeric time bit char 
                       varbinary binary smallmoney
                       image float integer timestamp real decimal

There are two syntax groups listed here: sqlOperator and sqlType.  To retrieve
a List of syntax items you can call OmniSyntaxList a number of different 
ways.  To retrieve all syntax items regardless of syntax group:  >
    echo OmniSyntaxList( [] )

To retrieve only the syntax items for the sqlOperator syntax group: >
    echo OmniSyntaxList( ['sqlOperator'] )

To retrieve all syntax items for both the sqlOperator and sqlType groups: >
    echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )

A regular expression can also be used: >
    echo OmniSyntaxList( ['sql\w\+'] )

From within a plugin, you would typically assign the output to a List: >
    let myKeywords = []
    let myKeywords = OmniSyntaxList( ['sqlKeyword'] )

    

SQL							*ft-sql-omni*

Completion for the SQL language includes statements, functions, keywords.
It will also dynamically complete tables, procedures, views and column lists
with data pulled directly from within a database.  For detailed instructions
and a tutorial see |omni-sql-completion|.

The SQL completion plugin can be used in conjunction with other completion
plugins.  For example, the PHP filetype has its own completion plugin.
Since PHP is often used to generate dynamic website by accessing a database,
the SQL completion plugin can also be enabled.  This allows you to complete
PHP code and SQL code at the same time.


XML							*ft-xml-omni*

Vim 7 provides a mechanism for context aware completion of XML files.  It
depends on a special |xml-omni-datafile| and two commands: |:XMLns| and
|:XMLent|.  Features are:

- after "<" complete the tag name, depending on context
- inside of a tag complete proper attributes
- when an attribute has a limited number of possible values help to complete
  them
- complete names of entities (defined in |xml-omni-datafile| and in the
  current file with "<!ENTITY" declarations)
- when used after "</" CTRL-X CTRL-O will close the last opened tag

Format of XML data file					*xml-omni-datafile*

XML data files are stored in the "autoload/xml" directory in 'runtimepath'.
Vim distribution provides examples of data files in the
"$VIMRUNTIME/autoload/xml" directory.  They have a meaningful name which will
be used in commands.  It should be a unique name which will not create
conflicts.  For example, the name xhtml10s.vim means it is the data file for
XHTML 1.0 Strict.

Each file contains a variable with a name like g:xmldata_xhtml10s . It is
a compound from two parts:

1. "g:xmldata_"  general prefix, constant for all data files
2. "xhtml10s"    the name of the file and the name of the described XML
		 dialect; it will be used as an argument for the |:XMLns|
		 command

Part two must be exactly the same as name of file.

The variable is a |Dictionary|.  Keys are tag names and each value is a two
element |List|.  The first element of the List is also a List with the names
of possible children.  The second element is a |Dictionary| with the names of
attributes as keys and the possible values of attributes as values.  Example: >

    let g:xmldata_crippled = {
    \ "vimxmlentities": ["amp", "lt", "gt", "apos", "quot"],
    \ 'vimxmlroot': ['tag1'],
    \ 'tag1':
    \ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],
    \ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],
    \ 'childoftag1a':
    \ [ [], {'attrofchild': ['attrofchild']}],
    \ 'childoftag1b':
    \ [ ['childoftag1a'], {'attrofchild': []}],
    \ "vimxmltaginfo": {
    \ 'tag1': ['Menu info', 'Long information visible in preview window']},
    \ 'vimxmlattrinfo': {
    \ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}

This example would be put in the "autoload/xml/crippled.vim" file and could
help to write this file: >

    <tag1 attroftag1b="valueofattr1">
        <childoftag1a attrofchild>
                &amp; &lt;
        </childoftag1a>
        <childoftag1b attrofchild="5">
            <childoftag1a>
                &gt; &apos; &quot;
            </childoftag1a>
        </childoftag1b>
    </tag1>

In the example four special elements are visible:

1. "vimxmlentities" - a special key with List containing entities of this XML
   dialect.
2. If the list containing possible values of attributes has one element and
   this element is equal to the name of the attribute this attribute will be
   treated as boolean and inserted as 'attrname' and not as 'attrname="'
3. "vimxmltaginfo" - a special key with a Dictionary containing tag
   names as keys and two element List as values, for additional menu info and
   the long description.
4. "vimxmlattrinfo" - special key with Dictionary containing attribute names
   as keys and two element List as values, for additional menu info and long
   description.

Note: Tag names in the data file MUST not contain a namespace description.
Check xsl.vim for an example.
Note: All data and functions are publicly available as global
variables/functions and can be used for personal editing functions.


DTD -> Vim							*dtd2vim*

On |www| is the script |dtd2vim| which parses DTD and creates an XML data file
for Vim XML omni completion.

    dtd2vim: http://www.vim.org/scripts/script.php?script_id=1462

Check the beginning of that file for usage details.
The script requires perl and:

    perlSGML: http://savannah.nongnu.org/projects/perlsgml


Commands

:XMLns {name} [{namespace}]					*:XMLns*

Vim has to know which data file should be used and with which namespace.  For
loading of the data file and connecting data with the proper namespace use
|:XMLns| command.  The first (obligatory) argument is the name of the data
(xhtml10s, xsl).  The second argument is the code of namespace (h, xsl).  When
used without a second argument the dialect will be used as default - without
namespace declaration.  For example to use XML completion in .xsl files: >

	:XMLns xhtml10s
	:XMLns xsl xsl


:XMLent {name}							*:XMLent*

By default entities will be completed from the data file of the default
namespace.  The XMLent command should be used in case when there is no default
namespace: >

	:XMLent xhtml10s

Usage

While used in this situation (after declarations from previous part, | is
cursor position): >

	<|

Will complete to an appropriate XHTML tag, and in this situation: >

	<xsl:|

Will complete to an appropriate XSL tag.


The script xmlcomplete.vim, provided through the |autoload| mechanism,
has the xmlcomplete#GetLastOpenTag() function which can be used in XML files
to get the name of the last open tag (b:unaryTagsStack has to be defined): >

	:echo xmlcomplete#GetLastOpenTag("b:unaryTagsStack")



==============================================================================
8. Insert mode commands					*inserting*

The following commands can be used to insert new text into the buffer.  They
can all be undone and repeated with the "." command.

							*a*
a			Append text after the cursor [count] times.  If the
			cursor is in the first column of an empty line Insert
			starts there.  But not when 'virtualedit' is set!

							*A*
A			Append text at the end of the line [count] times.

<insert>	or				*i* *insert* *<Insert>*
i			Insert text before the cursor [count] times.
			When using CTRL-O in Insert mode |i_CTRL-O| the count
			is not supported.

							*I*
I			Insert text before the first non-blank in the line
			[count] times.
			When the 'H' flag is present in 'cpoptions' and the
			line only contains blanks, insert start just before
			the last blank.

							*gI*
gI			Insert text in column 1 [count] times.  {not in Vi}

							*gi*
gi			Insert text in the same position as where Insert mode
			was stopped last time in the current buffer.
			This uses the |'^| mark.  It's different from "`^i"
			when the mark is past the end of the line.
			The position is corrected for inserted/deleted lines,
			but NOT for inserted/deleted characters.
			When the |:keepjumps| command modifier is used the |'^|
			mark won't be changed.
			{not in Vi}

							*o*
o			Begin a new line below the cursor and insert text,
			repeat [count] times.  {Vi: blank [count] screen
			lines}
			When the '#' flag is in 'cpoptions' the count is
			ignored.

							*O*
O			Begin a new line above the cursor and insert text,
			repeat [count] times.  {Vi: blank [count] screen
			lines}
			When the '#' flag is in 'cpoptions' the count is
			ignored.

These commands are used to start inserting text.  You can end insert mode with
<Esc>.  See |mode-ins-repl| for the other special characters in Insert mode.
The effect of [count] takes place after Insert mode is exited.

When 'autoindent' is on, the indent for a new line is obtained from the
previous line.  When 'smartindent' or 'cindent' is on, the indent for a line
is automatically adjusted for C programs.

'textwidth' can be set to the maximum width for a line.  When a line becomes
too long when appending characters a line break is automatically inserted.


==============================================================================
9. Ex insert commands					*inserting-ex*

							*:a* *:append*
:{range}a[ppend][!]	Insert several lines of text below the specified
			line.  If the {range} is missing, the text will be
			inserted after the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.

							*:i* *:in* *:insert*
:{range}i[nsert][!]	Insert several lines of text above the specified
			line.  If the {range} is missing, the text will be
			inserted before the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.

These two commands will keep on asking for lines, until you type a line
containing only a ".".  Watch out for lines starting with a backslash, see
|line-continuation|.

When in Ex mode (see |-e|) a backslash at the end of the line can be used to
insert a NUL character.  To be able to have a line ending in a backslash use
two backslashes.  This means that the number of backslashes is halved, but
only at the end of the line.

NOTE: These commands cannot be used with |:global| or |:vglobal|.
":append" and ":insert" don't work properly in between ":if" and
":endif", ":for" and ":endfor", ":while" and ":endwhile".

							*:start* *:startinsert*
:star[tinsert][!]	Start Insert mode just after executing this command.
			Works like typing "i" in Normal mode.  When the ! is
			included it works like "A", append to the line.
			Otherwise insertion starts at the cursor position.
			Note that when using this command in a function or
			script, the insertion only starts after the function
			or script is finished.
			This command does not work from |:normal|.
			{not in Vi}

							*:stopi* *:stopinsert*
:stopi[nsert]		Stop Insert mode as soon as possible.  Works like
			typing <Esc> in Insert mode.
			Can be used in an autocommand, example: >
				:au BufEnter scratch stopinsert
<
					*replacing-ex* *:startreplace*
:startr[eplace][!]	Start Replace mode just after executing this command.
			Works just like typing "R" in Normal mode.  When the
			! is included it acts just like "$R" had been typed
			(ie. begin replace mode at the end-of-line).  Other-
			wise replacement begins at the cursor position.
			Note that when using this command in a function or
			script that the replacement will only start after
			the function or script is finished.
			{not in Vi}

							*:startgreplace*
:startg[replace][!]	Just like |:startreplace|, but use Virtual Replace
			mode, like with |gR|.
			{not in Vi}

==============================================================================
10. Inserting a file					*inserting-file*

							*:r* *:re* *:read*
:r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the cursor.
			See |++opt| for the possible values of [++opt].

:{range}r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the specified line.
			See |++opt| for the possible values of [++opt].

							*:r!* *:read!*
:[range]r[ead] [++opt] !{cmd}
			Execute {cmd} and insert its standard output below
			the cursor or the specified line.  A temporary file is
			used to store the output of the command which is then
			read into the buffer.  'shellredir' is used to save
			the output of the command, which can be set to include
			stderr or not.  {cmd} is executed like with ":!{cmd}",
			any '!' is replaced with the previous command |:!|.
			See |++opt| for the possible values of [++opt].

These commands insert the contents of a file, or the output of a command,
into the buffer.  They can be undone.  They cannot be repeated with the "."
command.  They work on a line basis, insertion starts below the line in which
the cursor is, or below the specified line.  To insert text above the first
line use the command ":0r {name}".

After the ":read" command, the cursor is left on the first non-blank in the
first new line.  Unless in Ex mode, then the cursor is left on the last new
line (sorry, this is Vi compatible).

If a file name is given with ":r", it becomes the alternate file.  This can be
used, for example, when you want to edit that file instead: ":e! #".  This can
be switched off by removing the 'a' flag from the 'cpoptions' option.

Of the [++opt] arguments one is specifically for ":read", the ++edit argument.
This is useful when the ":read" command is actually used to read a file into
the buffer as if editing that file.  Use this command in an empty buffer: >
	:read ++edit filename
The effect is that the 'fileformat', 'fileencoding', 'bomb', etc. options are
set to what has been detected for "filename".  Note that a single empty line
remains, you may want to delete it.

							*file-read*
The 'fileformat' option sets the <EOL> style for a file:
'fileformat'    characters	   name				~
  "dos"		<CR><NL> or <NL>   DOS format
  "unix"	<NL>		   Unix format
  "mac"		<CR>		   Mac format
Previously 'textmode' was used.  It is obsolete now.

If 'fileformat' is "dos", a <CR> in front of an <NL> is ignored and a CTRL-Z
at the end of the file is ignored.

If 'fileformat' is "mac", a <NL> in the file is internally represented by a
<CR>.  This is to avoid confusion with a <NL> which is used to represent a
<NUL>.  See |CR-used-for-NL|.

If the 'fileformats' option is not empty Vim tries to recognize the type of
<EOL> (see |file-formats|).  However, the 'fileformat' option will not be
changed, the detected format is only used while reading the file.
A similar thing happens with 'fileencodings'.

On non-MS-DOS, Win32, and OS/2 systems the message "[dos format]" is shown if
a file is read in DOS format, to remind you that something unusual is done.
On Macintosh, MS-DOS, Win32, and OS/2 the message "[unix format]" is shown if
a file is read in Unix format.
On non-Macintosh systems, the message "[Mac format]" is shown if a file is
read in Mac format.

An example on how to use ":r !": >
	:r !uuencode binfile binfile
This command reads "binfile", uuencodes it and reads it into the current
buffer.  Useful when you are editing e-mail and want to include a binary
file.

							*read-messages*
When reading a file Vim will display a message with information about the read
file.  In the table is an explanation for some of the items.  The others are
self explanatory.  Using the long or the short version depends on the
'shortmess' option.

	long		short		meaning ~
	[readonly]	{RO}		the file is write protected
	[fifo/socket]			using a stream
	[fifo]				using a fifo stream
	[socket]			using a socket stream
	[CR missing]			reading with "dos" 'fileformat' and a
					NL without a preceding CR was found.
	[NL found]			reading with "mac" 'fileformat' and a
					NL was found (could be "unix" format)
	[long lines split]		at least one line was split in two
	[NOT converted]			conversion from 'fileencoding' to
					'encoding' was desired but not
					possible
	[converted]			conversion from 'fileencoding' to
					'encoding' done
	[crypted]			file was decrypted
	[READ ERRORS]			not all of the file could be read


 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 if (BF537 || BF534 || BF536)

source "arch/blackfin/mach-bf537/boards/Kconfig"

menu "BF537 Specific Configuration"

comment "Interrupt Priority Assignment"
menu "Priority"

config IRQ_PLL_WAKEUP
	int "IRQ_PLL_WAKEUP"
	default 7
config IRQ_DMA_ERROR
	int "IRQ_DMA_ERROR Generic"
	default 7
config IRQ_ERROR
	int "IRQ_ERROR: PPI CAN MAC SPORT0 SPORT1 SPI UART0 UART1"
	default 11
config IRQ_RTC
	int "IRQ_RTC"
	default 8
config IRQ_PPI
	int "IRQ_PPI"
	default 8
config IRQ_SPORT0_RX
	int "IRQ_SPORT0_RX"
	default 9
config IRQ_SPORT0_TX
	int "IRQ_SPORT0_TX"
	default 9
config IRQ_SPORT1_RX
	int "IRQ_SPORT1_RX"
	default 9
config IRQ_SPORT1_TX
	int "IRQ_SPORT1_TX"
	default 9
config IRQ_TWI
	int "IRQ_TWI"
	default 10
config IRQ_SPI
	int "IRQ_SPI"
	default 10
config IRQ_UART0_RX
	int "IRQ_UART0_RX"
	default 10
config IRQ_UART0_TX
	int "IRQ_UART0_TX"
	default 10
config IRQ_UART1_RX
	int "IRQ_UART1_RX"
	default 10
config IRQ_UART1_TX
	int "IRQ_UART1_TX"
	default 10
config IRQ_CAN_RX
	int "IRQ_CAN_RX"
	default 11
config IRQ_CAN_TX
	int "IRQ_CAN_TX"
	default 11
config IRQ_MAC_RX
	int "IRQ_MAC_RX"
	default 11
config IRQ_MAC_TX
	int "IRQ_MAC_TX"
	default 11
config IRQ_TIMER0
	int "IRQ_TIMER0"
	default 7 if TICKSOURCE_GPTMR0
	default 8
config IRQ_TIMER1
	int "IRQ_TIMER1"
	default 12
config IRQ_TIMER2
	int "IRQ_TIMER2"
	default 12
config IRQ_TIMER3
	int "IRQ_TIMER3"
	default 12
config IRQ_TIMER4
	int "IRQ_TIMER4"
	default 12
config IRQ_TIMER5
	int "IRQ_TIMER5"
	default 12
config IRQ_TIMER6
	int "IRQ_TIMER6"
	default 12
config IRQ_TIMER7
	int "IRQ_TIMER7"
	default 12
config IRQ_PROG_INTA
	int "IRQ_PROG_INTA"
	default 12
config IRQ_PORTG_INTB
	int "IRQ_PORTG_INTB"
	default 12
config IRQ_MEM_DMA0
	int "IRQ_MEM_DMA0"
	default 13
config IRQ_MEM_DMA1
	int "IRQ_MEM_DMA1"
	default 13
config IRQ_WATCH
	int "IRQ_WATCH"
	default 13

	help
	  Enter the priority numbers between 7-13 ONLY.  Others are Reserved.
	  This applies to all the above.  It is not recommended to assign the
	  highest priority number 7 to UART or any other device.

endmenu

endmenu

endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #
# arch/blackfin/mach-bf537/boards/Makefile
#

obj-$(CONFIG_BFIN537_STAMP)            += stamp.o
obj-$(CONFIG_BFIN537_BLUETECHNIX_CM_E) += cm_bf537e.o
obj-$(CONFIG_BFIN537_BLUETECHNIX_CM_U) += cm_bf537u.o
obj-$(CONFIG_BFIN537_BLUETECHNIX_TCM)  += tcm_bf537.o
obj-$(CONFIG_PNAV10)                   += pnav10.o
obj-$(CONFIG_CAMSIG_MINOTAUR)          += minotaur.o
obj-$(CONFIG_DNP5370)                  += dnp5370.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                choice
	prompt "System type"
	default BFIN537_STAMP
	help
	  Select your board!

config BFIN537_STAMP
	bool "BF537-STAMP"
	help
	  BF537-STAMP board support.

config BFIN537_BLUETECHNIX_CM_E
	bool "Bluetechnix CM-BF537E"
	depends on (BF537)
	help
	  CM-BF537E support for EVAL- and DEV-Board.

config BFIN537_BLUETECHNIX_CM_U
	bool "Bluetechnix CM-BF537U"
	depends on (BF537)
	help
	  CM-BF537U support for EVAL- and DEV-Board.

config BFIN537_BLUETECHNIX_TCM
	bool "Bluetechnix TCM-BF537"
	depends on (BF537)
	help
	  TCM-BF537 support for EVAL- and DEV-Board.

config PNAV10
	bool "PNAV board"
	depends on (BF537)
	help
	  PNAV board support.

config CAMSIG_MINOTAUR
	bool "Cambridge Signal Processing LTD Minotaur"
	depends on (BF537)
	help
	  Board supply package for CSP Minotaur

config DNP5370
	bool "SSV Dil/NetPC DNP/5370"
	depends on (BF537)
	help
	  Board supply package for DNP/5370 DIL64 module

endchoice
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         menu "Kernel hacking"

source "lib/Kconfig.debug"

config DEBUG_VERBOSE
	bool "Verbose fault messages"
	default y
	select PRINTK
	help
	  When a program crashes due to an exception, or the kernel detects
	  an internal error, the kernel can print a not so brief message
	  explaining what the problem was. This debugging information is
	  useful to developers and kernel hackers when tracking down problems,
	  but mostly meaningless to other people. This is always helpful for
	  debugging but serves no purpose on a production system.
	  Most people should say N here.

config DEBUG_MMRS
	tristate "Generate Blackfin MMR tree"
	depends on !PINCTRL
	select DEBUG_FS
	help
	  Create a tree of Blackfin MMRs via the debugfs tree.  If
	  you enable this, you will find all MMRs laid out in the
	  /sys/kernel/debug/blackfin/ directory where you can read/write
	  MMRs directly from userspace.  This is obviously just a debug
	  feature.

config DEBUG_HWERR
	bool "Hardware error interrupt debugging"
	depends on DEBUG_KERNEL
	help
	  When enabled, the hardware error interrupt is never disabled, and
	  will happen immediately when an error condition occurs.  This comes
	  at a slight cost in code size, but is necessary if you are getting
	  hardware error interrupts and need to know where they are coming
	  from.

config EXACT_HWERR
	bool "Try to make Hardware errors exact"
	depends on DEBUG_HWERR
	help
	  By default, the Blackfin hardware errors are not exact - the error
          be reported multiple cycles after the error happens. This delay
	  can cause the wrong application, or even the kernel to receive a
	  signal to be killed. If you are getting HW errors in your system,
	  try turning this on to ensure they are at least coming from the
	  proper thread.

	  On production systems, it is safe (and a small optimization) to say N.

config DEBUG_DOUBLEFAULT
	bool "Debug Double Faults"
	default n
	help
	  If an exception is caused while executing code within the exception
	  handler, the NMI handler, the reset vector, or in emulator mode,
	  a double fault occurs. On the Blackfin, this is a unrecoverable
	  event. You have two options:
	  - RESET exactly when double fault occurs. The excepting
	    instruction address is stored in RETX, where the next kernel
	    boot will print it out.
	  - Print debug message. This is much more error prone, although
	    easier to handle. It is error prone since:
	    - The excepting instruction is not committed.
	    - All writebacks from the instruction are prevented.
	    - The generated exception is not taken.
	    - The EXCAUSE field is updated with an unrecoverable event
	    The only way to check this is to see if EXCAUSE contains the
	    unrecoverable event value at every exception return. By selecting
	    this option, you are skipping over the faulting instruction, and 
	    hoping things stay together enough to print out a debug message.

	  This does add a little kernel code, but is the only method to debug
	  double faults - if unsure say "Y"

choice
	prompt "Double Fault Failure Method"
	default DEBUG_DOUBLEFAULT_PRINT
	depends on DEBUG_DOUBLEFAULT

config DEBUG_DOUBLEFAULT_PRINT
	bool "Print"

config DEBUG_DOUBLEFAULT_RESET
	bool "Reset"

endchoice

config DEBUG_HUNT_FOR_ZERO
	bool "Catch NULL pointer reads/writes"
	default y
	help
	  Say Y here to catch reads/writes to anywhere in the memory range
	  from 0x0000 - 0x0FFF (the first 4k) of memory.  This is useful in
	  catching common programming errors such as NULL pointer dereferences.

	  Misbehaving applications will be killed (generate a SEGV) while the
	  kernel will trigger a panic.

	  Enabling this option will take up an extra entry in CPLB table.
	  Otherwise, there is no extra overhead.

config DEBUG_BFIN_HWTRACE_ON
	bool "Turn on Blackfin's Hardware Trace"
	default y
	help
	  All Blackfins include a Trace Unit which stores a history of the last
	  16 changes in program flow taken by the program sequencer. The history
	  allows the user to recreate the program sequencerâ€™s recent path. This
	  can be handy when an application dies - we print out the execution
	  path of how it got to the offending instruction.

	  By turning this off, you may save a tiny amount of power.

choice
	prompt "Omit loop Tracing"
	default DEBUG_BFIN_HWTRACE_COMPRESSION_OFF
	depends on DEBUG_BFIN_HWTRACE_ON
	help
	  The trace buffer can be configured to omit recording of changes in
	  program flow that match either the last entry or one of the last
	  two entries. Omitting one of these entries from the record prevents
	  the trace buffer from overflowing because of any sort of loop (for, do
	  while, etc) in the program.

	  Because zero-overhead Hardware loops are not recorded in the trace buffer,
	  this feature can be used to prevent trace overflow from loops that
	  are nested four deep.

config DEBUG_BFIN_HWTRACE_COMPRESSION_OFF
	bool "Trace all Loops"
	help
	  The trace buffer records all changes of flow 

config DEBUG_BFIN_HWTRACE_COMPRESSION_ONE
	bool "Compress single-level loops"
	help
	  The trace buffer does not record single loops - helpful if trace 
	  is spinning on a while or do loop.

config DEBUG_BFIN_HWTRACE_COMPRESSION_TWO
	bool "Compress two-level loops"
	help
	  The trace buffer does not record loops two levels deep. Helpful if
	  the trace is spinning in a nested loop

endchoice

config DEBUG_BFIN_HWTRACE_COMPRESSION
	int
	depends on DEBUG_BFIN_HWTRACE_ON
	default 0 if DEBUG_BFIN_HWTRACE_COMPRESSION_OFF
	default 1 if DEBUG_BFIN_HWTRACE_COMPRESSION_ONE
	default 2 if DEBUG_BFIN_HWTRACE_COMPRESSION_TWO


config DEBUG_BFIN_HWTRACE_EXPAND
	bool "Expand Trace Buffer greater than 16 entries"
	depends on DEBUG_BFIN_HWTRACE_ON
	default n
	help
	  By selecting this option, every time the 16 hardware entries in
	  the Blackfin's HW Trace buffer are full, the kernel will move them
	  into a software buffer, for dumping when there is an issue. This 
	  has a great impact on performance, (an interrupt every 16 change of 
	  flows) and should normally be turned off, except in those nasty
	  debugging sessions

config DEBUG_BFIN_HWTRACE_EXPAND_LEN
	int "Size of Trace buffer (in power of 2k)"
	range 0 4
	depends on DEBUG_BFIN_HWTRACE_EXPAND
	default 1
	help
	  This sets the size of the software buffer that the trace information
	  is kept in.
	  0 for (2^0)  1k, or 256 entries,
	  1 for (2^1)  2k, or 512 entries,
	  2 for (2^2)  4k, or 1024 entries,
	  3 for (2^3)  8k, or 2048 entries,
	  4 for (2^4) 16k, or 4096 entries

config DEBUG_BFIN_NO_KERN_HWTRACE
	bool "Turn off hwtrace in CPLB handlers"
	depends on DEBUG_BFIN_HWTRACE_ON
	default y
	help
	  The CPLB error handler contains a lot of flow changes which can
	  quickly fill up the hardware trace buffer.  When debugging crashes,
	  the hardware trace may indicate that the problem lies in kernel
	  space when in reality an application is buggy.

	  Say Y here to disable hardware tracing in some known "jumpy" pieces
	  of code so that the trace buffer will extend further back.

config EARLY_PRINTK
	bool "Early printk" 
	default n
	select SERIAL_CORE_CONSOLE
	help
	  This option enables special console drivers which allow the kernel
	  to print messages very early in the bootup process.

	  This is useful for kernel debugging when your machine crashes very
	  early before the console code is initialized. After enabling this
	  feature, you must add "earlyprintk=serial,uart0,57600" to the
	  command line (bootargs). It is safe to say Y here in all cases, as
	  all of this lives in the init section and is thrown away after the
	  kernel boots completely.

config NMI_WATCHDOG
	bool "Enable NMI watchdog to help debugging lockup on SMP"
	default n
	depends on SMP
	help
	  If any CPU in the system does not execute the period local timer
	  interrupt for more than 5 seconds, then the NMI handler dumps debug
	  information. This information can be used to debug the lockup.

config CPLB_INFO
	bool "Display the CPLB information"
	help
	  Display the CPLB information via /proc/cplbinfo.

config ACCESS_CHECK
	bool "Check the user pointer address"
	default y
	help
	  Usually the pointer transfer from user space is checked to see if its
	  address is in the kernel space.

	  Say N here to disable that check to improve the performance.

config BFIN_ISRAM_SELF_TEST
	bool "isram boot self tests"
	default n
	help
	  Run some self tests of the isram driver code at boot.

config BFIN_PSEUDODBG_INSNS
	bool "Support pseudo debug instructions"
	default n
	help
	  This option allows the kernel to emulate some pseudo instructions which
	  allow simulator test cases to be run under Linux with no changes.

	  Most people should say N here.

config BFIN_PM_WAKEUP_TIME_BENCH
	bool "Display the total time for kernel to resume from power saving mode"
	default n
	help
	  Display the total time when kernel resumes normal from standby or
	  suspend to mem mode.

endmenu
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #
# arch/blackfin/Makefile
#
# This file is subject to the terms and conditions of the GNU General Public
# License.  See the file "COPYING" in the main directory of this archive
# for more details.
#

ifeq ($(CROSS_COMPILE),)
CROSS_COMPILE    := bfin-uclinux-
endif
LDFLAGS_vmlinux  := -X
OBJCOPYFLAGS     := -O binary -R .note -R .comment -S
GZFLAGS          := -9

KBUILD_CFLAGS           += $(call cc-option,-mno-fdpic)
ifeq ($(CONFIG_ROMKERNEL),y)
KBUILD_CFLAGS           += -mlong-calls
endif
KBUILD_AFLAGS           += $(call cc-option,-mno-fdpic)
KBUILD_CFLAGS_MODULE    += -mlong-calls
LDFLAGS                 += -m elf32bfin

KBUILD_DEFCONFIG := BF537-STAMP_defconfig

# setup the machine name and the machine dependent settings
machine-$(CONFIG_BF512)  := bf518
machine-$(CONFIG_BF514)  := bf518
machine-$(CONFIG_BF516)  := bf518
machine-$(CONFIG_BF518)  := bf518
machine-$(CONFIG_BF522)  := bf527
machine-$(CONFIG_BF523)  := bf527
machine-$(CONFIG_BF524)  := bf527
machine-$(CONFIG_BF525)  := bf527
machine-$(CONFIG_BF526)  := bf527
machine-$(CONFIG_BF527)  := bf527
machine-$(CONFIG_BF531)  := bf533
machine-$(CONFIG_BF532)  := bf533
machine-$(CONFIG_BF533)  := bf533
machine-$(CONFIG_BF534)  := bf537
machine-$(CONFIG_BF536)  := bf537
machine-$(CONFIG_BF537)  := bf537
machine-$(CONFIG_BF538)  := bf538
machine-$(CONFIG_BF539)  := bf538
machine-$(CONFIG_BF542)  := bf548
machine-$(CONFIG_BF542M) := bf548
machine-$(CONFIG_BF544)  := bf548
machine-$(CONFIG_BF544M) := bf548
machine-$(CONFIG_BF547)  := bf548
machine-$(CONFIG_BF547M) := bf548
machine-$(CONFIG_BF548)  := bf548
machine-$(CONFIG_BF548M) := bf548
machine-$(CONFIG_BF549)  := bf548
machine-$(CONFIG_BF549M) := bf548
machine-$(CONFIG_BF561)  := bf561
machine-$(CONFIG_BF609)  := bf609
MACHINE := $(machine-y)
export MACHINE

cpu-$(CONFIG_BF512)  := bf512
cpu-$(CONFIG_BF514)  := bf514
cpu-$(CONFIG_BF516)  := bf516
cpu-$(CONFIG_BF518)  := bf518
cpu-$(CONFIG_BF522)  := bf522
cpu-$(CONFIG_BF523)  := bf523
cpu-$(CONFIG_BF524)  := bf524
cpu-$(CONFIG_BF525)  := bf525
cpu-$(CONFIG_BF526)  := bf526
cpu-$(CONFIG_BF527)  := bf527
cpu-$(CONFIG_BF531)  := bf531
cpu-$(CONFIG_BF532)  := bf532
cpu-$(CONFIG_BF533)  := bf533
cpu-$(CONFIG_BF534)  := bf534
cpu-$(CONFIG_BF536)  := bf536
cpu-$(CONFIG_BF537)  := bf537
cpu-$(CONFIG_BF538)  := bf538
cpu-$(CONFIG_BF539)  := bf539
cpu-$(CONFIG_BF542)  := bf542
cpu-$(CONFIG_BF542M) := bf542m
cpu-$(CONFIG_BF544)  := bf544
cpu-$(CONFIG_BF544M) := bf544m
cpu-$(CONFIG_BF547)  := bf547
cpu-$(CONFIG_BF547M) := bf547m
cpu-$(CONFIG_BF548)  := bf548
cpu-$(CONFIG_BF548M) := bf548m
cpu-$(CONFIG_BF549)  := bf549
cpu-$(CONFIG_BF549M) := bf549m
cpu-$(CONFIG_BF561)  := bf561
cpu-$(CONFIG_BF609)  := bf609

rev-$(CONFIG_BF_REV_0_0)  := 0.0
rev-$(CONFIG_BF_REV_0_1)  := 0.1
rev-$(CONFIG_BF_REV_0_2)  := 0.2
rev-$(CONFIG_BF_REV_0_3)  := 0.3
rev-$(CONFIG_BF_REV_0_4)  := 0.4
rev-$(CONFIG_BF_REV_0_5)  := 0.5
rev-$(CONFIG_BF_REV_0_6)  := 0.6
rev-$(CONFIG_BF_REV_NONE) := none
rev-$(CONFIG_BF_REV_ANY)  := any

CPU_REV := $(cpu-y)-$(rev-y)
export CPU_REV

KBUILD_CFLAGS += -mcpu=$(CPU_REV)
KBUILD_AFLAGS += -mcpu=$(CPU_REV)

# - we utilize the silicon rev from the toolchain, so move it over to the checkflags
CHECKFLAGS_SILICON = $(shell echo "" | $(CPP) $(KBUILD_CFLAGS) -dD - 2>/dev/null | awk '$$2 == "__SILICON_REVISION__" { print $$3 }')
CHECKFLAGS += -D__SILICON_REVISION__=$(CHECKFLAGS_SILICON) -D__bfin__

core-y   += arch/$(ARCH)/kernel/ arch/$(ARCH)/mm/ arch/$(ARCH)/mach-common/

# If we have a machine-specific directory, then include it in the build.
ifneq ($(machine-y),)
core-y   += arch/$(ARCH)/mach-$(MACHINE)/
core-y   += arch/$(ARCH)/mach-$(MACHINE)/boards/
endif

ifeq ($(CONFIG_MPU),y)
core-y	+= arch/$(ARCH)/kernel/cplb-mpu/
else
core-y	+= arch/$(ARCH)/kernel/cplb-nompu/
endif

drivers-$(CONFIG_OPROFILE) += arch/$(ARCH)/oprofile/

libs-y   += arch/$(ARCH)/lib/

machdirs	:= $(patsubst %,arch/blackfin/mach-%/, $(machine-y))

KBUILD_CFLAGS += -Iarch/$(ARCH)/include/
KBUILD_CFLAGS += -Iarch/$(ARCH)/mach-$(MACHINE)/include

KBUILD_CPPFLAGS	+= $(patsubst %,-I$(srctree)/%include,$(machdirs))

CLEAN_FILES += \
	arch/$(ARCH)/kernel/asm-offsets.s \

archclean:
	$(Q)$(MAKE) $(clean)=$(boot)

INSTALL_PATH ?= /tftpboot
boot := arch/$(ARCH)/boot
BOOT_TARGETS = uImage uImage.bin uImage.bz2 uImage.gz uImage.lzma uImage.lzo uImage.xip
PHONY += $(BOOT_TARGETS) install
KBUILD_IMAGE := $(boot)/uImage

all: uImage

$(BOOT_TARGETS): vmlinux
	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@

install:
	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(KBUILD_IMAGE) install

define archhelp
  echo  '* vmImage         - Alias to selected kernel format (vmImage.gz by default)'
  echo  '  vmImage.bin     - Uncompressed Kernel-only image for U-Boot (arch/$(ARCH)/boot/vmImage.bin)'
  echo  '  vmImage.bz2     - Kernel-only image for U-Boot (arch/$(ARCH)/boot/vmImage.bz2)'
  echo  '* vmImage.gz      - Kernel-only image for U-Boot (arch/$(ARCH)/boot/vmImage.gz)'
  echo  '  vmImage.lzma    - Kernel-only image for U-Boot (arch/$(ARCH)/boot/vmImage.lzma)'
  echo  '  vmImage.lzo     - Kernel-only image for U-Boot (arch/$(ARCH)/boot/vmImage.lzo)'
  echo  '  vmImage.xip     - XIP Kernel-only image for U-Boot (arch/$(ARCH)/boot/vmImage.xip)'
  echo  '  install         - Install kernel using'
  echo  '                     (your) ~/bin/$(INSTALLKERNEL) or'
  echo  '                     (distribution) PATH: $(INSTALLKERNEL) or'
  echo  '                     install to $$(INSTALL_PATH)'
endef
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      config MMU
	def_bool n

config FPU
	def_bool n

config RWSEM_GENERIC_SPINLOCK
	def_bool y

config RWSEM_XCHGADD_ALGORITHM
	def_bool n

config BLACKFIN
	def_bool y
	select HAVE_ARCH_KGDB
	select HAVE_ARCH_TRACEHOOK
	select HAVE_DYNAMIC_FTRACE
	select HAVE_FTRACE_MCOUNT_RECORD
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_FUNCTION_TRACER
	select HAVE_IDE
	select HAVE_KERNEL_GZIP if RAMKERNEL
	select HAVE_KERNEL_BZIP2 if RAMKERNEL
	select HAVE_KERNEL_LZMA if RAMKERNEL
	select HAVE_KERNEL_LZO if RAMKERNEL
	select HAVE_OPROFILE
	select HAVE_PERF_EVENTS
	select ARCH_HAVE_CUSTOM_GPIO_H
	select GPIOLIB
	select HAVE_UID16
	select HAVE_UNDERSCORE_SYMBOL_PREFIX
	select VIRT_TO_BUS
	select ARCH_WANT_IPC_PARSE_VERSION
	select GENERIC_ATOMIC64
	select GENERIC_IRQ_PROBE
	select GENERIC_IRQ_SHOW
	select HAVE_NMI_WATCHDOG if NMI_WATCHDOG
	select GENERIC_SMP_IDLE_THREAD
	select ARCH_USES_GETTIMEOFFSET if !GENERIC_CLOCKEVENTS
	select HAVE_MOD_ARCH_SPECIFIC
	select MODULES_USE_ELF_RELA
	select HAVE_DEBUG_STACKOVERFLOW
	select HAVE_NMI

config GENERIC_CSUM
	def_bool y

config GENERIC_BUG
	def_bool y
	depends on BUG

config ZONE_DMA
	def_bool y

config FORCE_MAX_ZONEORDER
	int
	default "14"

config GENERIC_CALIBRATE_DELAY
	def_bool y

config LOCKDEP_SUPPORT
	def_bool y

config STACKTRACE_SUPPORT
	def_bool y

config TRACE_IRQFLAGS_SUPPORT
	def_bool y

source "init/Kconfig"

source "kernel/Kconfig.preempt"

source "kernel/Kconfig.freezer"

menu "Blackfin Processor Options"

comment "Processor and Board Settings"

choice
	prompt "CPU"
	default BF533

config BF512
	bool "BF512"
	help
	  BF512 Processor Support.

config BF514
	bool "BF514"
	help
	  BF514 Processor Support.

config BF516
	bool "BF516"
	help
	  BF516 Processor Support.

config BF518
	bool "BF518"
	help
	  BF518 Processor Support.

config BF522
	bool "BF522"
	help
	  BF522 Processor Support.

config BF523
	bool "BF523"
	help
	  BF523 Processor Support.

config BF524
	bool "BF524"
	help
	  BF524 Processor Support.

config BF525
	bool "BF525"
	help
	  BF525 Processor Support.

config BF526
	bool "BF526"
	help
	  BF526 Processor Support.

config BF527
	bool "BF527"
	help
	  BF527 Processor Support.

config BF531
	bool "BF531"
	help
	  BF531 Processor Support.

config BF532
	bool "BF532"
	help
	  BF532 Processor Support.

config BF533
	bool "BF533"
	help
	  BF533 Processor Support.

config BF534
	bool "BF534"
	help
	  BF534 Processor Support.

config BF536
	bool "BF536"
	help
	  BF536 Processor Support.

config BF537
	bool "BF537"
	help
	  BF537 Processor Support.

config BF538
	bool "BF538"
	help
	  BF538 Processor Support.

config BF539
	bool "BF539"
	help
	  BF539 Processor Support.

config BF542_std
	bool "BF542"
	help
	  BF542 Processor Support.

config BF542M
	bool "BF542m"
	help
	  BF542 Processor Support.

config BF544_std
	bool "BF544"
	help
	  BF544 Processor Support.

config BF544M
	bool "BF544m"
	help
	  BF544 Processor Support.

config BF547_std
	bool "BF547"
	help
	  BF547 Processor Support.

config BF547M
	bool "BF547m"
	help
	  BF547 Processor Support.

config BF548_std
	bool "BF548"
	help
	  BF548 Processor Support.

config BF548M
	bool "BF548m"
	help
	  BF548 Processor Support.

config BF549_std
	bool "BF549"
	help
	  BF549 Processor Support.

config BF549M
	bool "BF549m"
	help
	  BF549 Processor Support.

config BF561
	bool "BF561"
	help
	  BF561 Processor Support.

config BF609
	bool "BF609"
	select CLKDEV_LOOKUP
	help
	  BF609 Processor Support.

endchoice

config SMP
	depends on BF561
	select TICKSOURCE_CORETMR
	bool "Symmetric multi-processing support"
	---help---
	  This enables support for systems with more than one CPU,
	  like the dual core BF561. If you have a system with only one
	  CPU, say N. If you have a system with more than one CPU, say Y.

	  If you don't know what to do here, say N.

config NR_CPUS
	int
	depends on SMP
	default 2 if BF561

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs"
	depends on SMP
	default y

config BF_REV_MIN
	int
	default 0 if (BF51x || BF52x || (BF54x && !BF54xM)) || BF60x
	default 2 if (BF537 || BF536 || BF534)
	default 3 if (BF561 || BF533 || BF532 || BF531 || BF54xM)
	default 4 if (BF538 || BF539)

config BF_REV_MAX
	int
	default 2 if (BF51x || BF52x || (BF54x && !BF54xM)) || BF60x
	default 3 if (BF537 || BF536 || BF534 || BF54xM)
	default 5 if (BF561 || BF538 || BF539)
	default 6 if (BF533 || BF532 || BF531)

choice
	prompt "Silicon Rev"
	default BF_REV_0_0 if (BF51x || BF52x || BF60x)
	default BF_REV_0_2 if (BF534 || BF536 || BF537 || (BF54x && !BF54xM))
	default BF_REV_0_3 if (BF531 || BF532 || BF533 || BF54xM || BF561)

config BF_REV_0_0
	bool "0.0"
	depends on (BF51x || BF52x || (BF54x && !BF54xM) || BF60x)

config BF_REV_0_1
	bool "0.1"
	depends on (BF51x || BF52x || (BF54x && !BF54xM) || BF60x)

config BF_REV_0_2
	bool "0.2"
	depends on (BF51x || BF52x || BF537 || BF536 || BF534 || (BF54x && !BF54xM))

config BF_REV_0_3
	bool "0.3"
	depends on (BF54xM || BF561 || BF537 || BF536 || BF534 || BF533 || BF532 || BF531)

config BF_REV_0_4
	bool "0.4"
	depends on (BF561 || BF533 || BF532 || BF531 || BF538 || BF539 || BF54x)

config BF_REV_0_5
	bool "0.5"
	depends on (BF561 || BF533 || BF532 || BF531 || BF538 || BF539)

config BF_REV_0_6
	bool "0.6"
	depends on (BF533 || BF532 || BF531)

config BF_REV_ANY
	bool "any"

config BF_REV_NONE
	bool "none"

endchoice

config BF53x
	bool
	depends on (BF531 || BF532 || BF533 || BF534 || BF536 || BF537)
	default y

config GPIO_ADI
	def_bool y
	depends on !PINCTRL
	depends on (BF51x || BF52x || BF53x || BF538 || BF539 || BF561)

config PINCTRL_BLACKFIN_ADI2
	def_bool y
	depends on (BF54x || BF60x)
	select PINCTRL
	select PINCTRL_ADI2

config MEM_MT48LC64M4A2FB_7E
	bool
	depends on (BFIN533_STAMP)
	default y

config MEM_MT48LC16M16A2TG_75
	bool
	depends on (BFIN533_EZKIT || BFIN561_EZKIT \
		|| BFIN533_BLUETECHNIX_CM || BFIN537_BLUETECHNIX_CM_E \
		|| BFIN537_BLUETECHNIX_CM_U || H8606_HVSISTEMAS \
		|| BFIN527_BLUETECHNIX_CM)
	default y

config MEM_MT48LC32M8A2_75
	bool
	depends on (BFIN518F_EZBRD || BFIN537_STAMP || PNAV10 || BFIN538_EZKIT)
	default y

config MEM_MT48LC8M32B2B5_7
	bool
	depends on (BFIN561_BLUETECHNIX_CM)
	default y

config MEM_MT48LC32M16A2TG_75
	bool
	depends on (BFIN527_EZKIT || BFIN527_EZKIT_V2 || BFIN532_IP0X || BLACKSTAMP || BFIN527_AD7160EVAL)
	default y

config MEM_MT48H32M16LFCJ_75
	bool
	depends on (BFIN526_EZBRD)
	default y

config MEM_MT47H64M16
	bool
	depends on (BFIN609_EZKIT)
	default y

source "arch/blackfin/mach-bf518/Kconfig"
source "arch/blackfin/mach-bf527/Kconfig"
source "arch/blackfin/mach-bf533/Kconfig"
source "arch/blackfin/mach-bf561/Kconfig"
source "arch/blackfin/mach-bf537/Kconfig"
source "arch/blackfin/mach-bf538/Kconfig"
source "arch/blackfin/mach-bf548/Kconfig"
source "arch/blackfin/mach-bf609/Kconfig"

menu "Board customizations"

config CMDLINE_BOOL
	bool "Default bootloader kernel arguments"

config CMDLINE
	string "Initial kernel command string"
	depends on CMDLINE_BOOL
	default "console=ttyBF0,57600"
	help
	  If you don't have a boot loader capable of passing a command line string
	  to the kernel, you may specify one here. As a minimum, you should specify
	  the memory size and the root device (e.g., mem=8M, root=/dev/nfs).

config BOOT_LOAD
	hex "Kernel load address for booting"
	default "0x1000"
	range 0x1000 0x20000000
	help
	  This option allows you to set the load address of the kernel.
	  This can be useful if you are on a board which has a small amount
	  of memory or you wish to reserve some memory at the beginning of
	  the address space.

	  Note that you need to keep this value above 4k (0x1000) as this
	  memory region is used to capture NULL pointer references as well
	  as some core kernel functions.

config PHY_RAM_BASE_ADDRESS
	hex "Physical RAM Base"
	default 0x0
	help
	  set BF609 FPGA physical SRAM base address

config ROM_BASE
	hex "Kernel ROM Base"
	depends on ROMKERNEL
	default "0x20040040"
	range 0x20000000 0x20400000 if !(BF54x || BF561 || BF60x)
	range 0x20000000 0x30000000 if (BF54x || BF561)
	range 0xB0000000 0xC0000000 if (BF60x)
	help
	  Make sure your ROM base does not include any file-header
	  information that is prepended to the kernel.

	  For example, the bootable U-Boot format (created with
	  mkimage) has a 64 byte header (0x40).  So while the image
	  you write to flash might start at say 0x20080000, you have
	  to add 0x40 to get the kernel's ROM base as it will come
	  after the header.

comment "Clock/PLL Setup"

config CLKIN_HZ
	int "Frequency of the crystal on the board in Hz"
	default "10000000" if BFIN532_IP0X
	default "11059200" if BFIN533_STAMP
	default "24576000" if PNAV10
	default "25000000" # most people use this
	default "27000000" if BFIN533_EZKIT
	default "30000000" if BFIN561_EZKIT
	default "24000000" if BFIN527_AD7160EVAL
	help
	  The frequency of CLKIN crystal oscillator on the board in Hz.
	  Warning: This value should match the crystal on the board. Otherwise,
	  peripherals won't work properly.

config BFIN_KERNEL_CLOCK
	bool "Re-program Clocks while Kernel boots?"
	default n
	help
	  This option decides if kernel clocks are re-programed from the
	  bootloader settings. If the clocks are not set, the SDRAM settings
	  are also not changed, and the Bootloader does 100% of the hardware
	  configuration.

config PLL_BYPASS
	bool "Bypass PLL"
	depends on BFIN_KERNEL_CLOCK && (!BF60x)
	default n

config CLKIN_HALF
	bool "Half Clock In"
	depends on BFIN_KERNEL_CLOCK && (! PLL_BYPASS)
	default n
	help
	  If this is set the clock will be divided by 2, before it goes to the PLL.

config VCO_MULT
	int "VCO Multiplier"
	depends on BFIN_KERNEL_CLOCK && (! PLL_BYPASS)
	range 1 64
	default "22" if BFIN533_EZKIT
	default "45" if BFIN533_STAMP
	default "20" if (BFIN537_STAMP || BFIN527_EZKIT || BFIN527_EZKIT_V2 || BFIN548_EZKIT || BFIN548_BLUETECHNIX_CM || BFIN538_EZKIT)
	default "22" if BFIN533_BLUETECHNIX_CM
	default "20" if (BFIN537_BLUETECHNIX_CM_E || BFIN537_BLUETECHNIX_CM_U || BFIN527_BLUETECHNIX_CM || BFIN561_BLUETECHNIX_CM)
	default "20" if (BFIN561_EZKIT || BF609)
	default "16" if (H8606_HVSISTEMAS || BLACKSTAMP || BFIN526_EZBRD || BFIN518F_EZBRD)
	default "25" if BFIN527_AD7160EVAL
	help
	  This controls the frequency of the on-chip PLL. This can be between 1 and 64.
	  PLL Frequency = (Crystal Frequency) * (this setting)

choice
	prompt "Core Clock Divider"
	depends on BFIN_KERNEL_CLOCK
	default CCLK_DIV_1
	help
	  This sets the frequency of the core. It can be 1, 2, 4 or 8
	  Core Frequency = (PLL frequency) / (this setting)

config CCLK_DIV_1
	bool "1"

config CCLK_DIV_2
	bool "2"

config CCLK_DIV_4
	bool "4"

config CCLK_DIV_8
	bool "8"
endchoice

config SCLK_DIV
	int "System Clock Divider"
	depends on BFIN_KERNEL_CLOCK
	range 1 15
	default 4
	help
	  This sets the frequency of the system clock (including SDRAM or DDR) on
	  !BF60x else it set the clock for system buses and provides the
	  source from which SCLK0 and SCLK1 are derived.
	  This can be between 1 and 15
	  System Clock = (PLL frequency) / (this setting)

config SCLK0_DIV
	int "System Clock0 Divider"
	depends on BFIN_KERNEL_CLOCK && BF60x
	range 1 15
	default 1
	help
	  This sets the frequency of the system clock0 for PVP and all other
	  peripherals not clocked by SCLK1.
	  This can be between 1 and 15
	  System Clock0 = (System Clock) / (this setting)

config SCLK1_DIV
	int "System Clock1 Divider"
	depends on BFIN_KERNEL_CLOCK && BF60x
	range 1 15
	default 1
	help
	  This sets the frequency of the system clock1 (including SPORT, SPI and ACM).
	  This can be between 1 and 15
	  System Clock1 = (System Clock) / (this setting)

config DCLK_DIV
	int "DDR Clock Divider"
	depends on BFIN_KERNEL_CLOCK && BF60x
	range 1 15
	default 2
	help
	  This sets the frequency of the DDR memory.
	  This can be between 1 and 15
	  DDR Clock = (PLL frequency) / (this setting)

choice
	prompt "DDR SDRAM Chip Type"
	depends on BFIN_KERNEL_CLOCK
	depends on BF54x
	default MEM_MT46V32M16_5B

config MEM_MT46V32M16_6T
	bool "MT46V32M16_6T"

config MEM_MT46V32M16_5B
	bool "MT46V32M16_5B"
endchoice

choice
	prompt "DDR/SDRAM Timing"
	depends on BFIN_KERNEL_CLOCK && !BF60x
	default BFIN_KERNEL_CLOCK_MEMINIT_CALC
	help
	  This option allows you to specify Blackfi*quickref.txt*  For Vim version 8.0.  Last change: 2016 Dec 16


		  VIM REFERENCE MANUAL    by Bram Moolenaar

			    Quick reference guide

							 *quickref* *Contents*
 tag	  subject			 tag	  subject	~
|Q_ct|	list of help files		|Q_re|	Repeating commands
|Q_lr|	motion: Left-right		|Q_km|	Key mapping
|Q_ud|	motion: Up-down			|Q_ab|	Abbreviations
|Q_tm|	motion: Text object		|Q_op|	Options
|Q_pa|	motion: Pattern searches	|Q_ur|	Undo/Redo commands
|Q_ma|	motion: Marks			|Q_et|	External commands
|Q_vm|	motion: Various			|Q_qf|	Quickfix commands
|Q_ta|	motion: Using tags		|Q_vc|	Various commands
|Q_sc|	Scrolling			|Q_ce|	Ex: Command-line editing
|Q_in|	insert: Inserting text		|Q_ra|	Ex: Ranges
|Q_ai|	insert: Keys			|Q_ex|	Ex: Special characters
|Q_ss|	insert: Special keys		|Q_st|	Starting Vim
|Q_di|	insert: Digraphs		|Q_ed|	Editing a file
|Q_si|	insert: Special inserts		|Q_fl|	Using the argument list
|Q_de|	change: Deleting text		|Q_wq|	Writing and quitting
|Q_cm|	change: Copying and moving	|Q_ac|	Automatic commands
|Q_ch|	change: Changing text		|Q_wi|	Multi-window commands
|Q_co|	change: Complex			|Q_bu|	Buffer list commands
|Q_vi|	Visual mode			|Q_sy|	Syntax highlighting
|Q_to|	Text objects			|Q_gu|	GUI commands
					|Q_fo|	Folding

------------------------------------------------------------------------------
N is used to indicate an optional count that can be given before the command.
------------------------------------------------------------------------------
*Q_lr*		Left-right motions

|h|	N  h		left (also: CTRL-H, <BS>, or <Left> key)
|l|	N  l		right (also: <Space> or <Right> key)
|0|	   0		to first character in the line (also: <Home> key)
|^|	   ^		to first non-blank character in the line
|$|	N  $		to the last character in the line (N-1 lines lower)
			   (also: <End> key)
|g0|	   g0		to first character in screen line (differs from "0"
			   when lines wrap)
|g^|	   g^		to first non-blank character in screen line (differs
			   from "^" when lines wrap)
|g$|	N  g$		to last character in screen line (differs from "$"
			   when lines wrap)
|gm|	   gm		to middle of the screen line
|bar|	N  |		to column N (default: 1)
|f|	N  f{char}	to the Nth occurrence of {char} to the right
|F|	N  F{char}	to the Nth occurrence of {char} to the left
|t|	N  t{char}	till before the Nth occurrence of {char} to the right
|T|	N  T{char}	till before the Nth occurrence of {char} to the left
|;|	N  ;		repeat the last "f", "F", "t", or "T" N times
|,|	N  ,		repeat the last "f", "F", "t", or "T" N times in
			   opposite direction
------------------------------------------------------------------------------
*Q_ud*		Up-down motions

|k|	N  k		up N lines (also: CTRL-P and <Up>)
|j|	N  j		down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
|-|	N  -		up N lines, on the first non-blank character
|+|	N  +		down N lines, on the first non-blank character (also:
			   CTRL-M and <CR>)
|_|	N  _		down N-1 lines, on the first non-blank character
|G|	N  G		goto line N (default: last line), on the first
			   non-blank character
|gg|	N  gg		goto line N (default: first line), on the first
			   non-blank character
|N%|	N  %		goto line N percentage down in the file; N must be
			   given, otherwise it is the |%| command
|gk|	N  gk		up N screen lines (differs from "k" when line wraps)
|gj|	N  gj		down N screen lines (differs from "j" when line wraps)
------------------------------------------------------------------------------
*Q_tm*		Text object motions

|w|	N  w		N words forward
|W|	N  W		N blank-separated |WORD|s forward
|e|	N  e		forward to the end of the Nth word
|E|	N  E		forward to the end of the Nth blank-separated |WORD|
|b|	N  b		N words backward
|B|	N  B		N blank-separated |WORD|s backward
|ge|	N  ge		backward to the end of the Nth word
|gE|	N  gE		backward to the end of the Nth blank-separated |WORD|

|)|	N  )		N sentences forward
|(|	N  (		N sentences backward
|}|	N  }		N paragraphs forward
|{|	N  {		N paragraphs backward
|]]|	N  ]]		N sections forward, at start of section
|[[|	N  [[		N sections backward, at start of section
|][|	N  ][		N sections forward, at end of section
|[]|	N  []		N sections backward, at end of section
|[(|	N  [(		N times back to unclosed '('
|[{|	N  [{		N times back to unclosed '{'
|[m|	N  [m		N times back to start of method (for Java)
|[M|	N  [M		N times back to end of method (for Java)
|])|	N  ])		N times forward to unclosed ')'
|]}|	N  ]}		N times forward to unclosed '}'
|]m|	N  ]m		N times forward to start of method (for Java)
|]M|	N  ]M		N times forward to end of method (for Java)
|[#|	N  [#		N times back to unclosed "#if" or "#else"
|]#|	N  ]#		N times forward to unclosed "#else" or "#endif"
|[star|	N  [*		N times back to start of comment "/*"
|]star|	N  ]*		N times forward to end of comment "*/"
------------------------------------------------------------------------------
*Q_pa*		Pattern searches

|/|	N  /{pattern}[/[offset]]<CR>
			search forward for the Nth occurrence of {pattern}
|?|	N  ?{pattern}[?[offset]]<CR>
			search backward for the Nth occurrence of {pattern}
|/<CR>|	N  /<CR>	repeat last search, in the forward direction
|?<CR>|	N  ?<CR>	repeat last search, in the backward direction
|n|	N  n		repeat last search
|N|	N  N		repeat last search, in opposite direction
|star|	N  *		search forward for the identifier under the cursor
|#|	N  #		search backward for the identifier under the cursor
|gstar|	N  g*		like "*", but also find partial matches
|g#|	N  g#		like "#", but also find partial matches
|gd|	   gd		goto local declaration of identifier under the cursor
|gD|	   gD		goto global declaration of identifier under the cursor

|pattern|		Special characters in search patterns

			meaning		      magic   nomagic	~
		matches any single character	.	\.
		       matches start of line	^	^
			       matches <EOL>	$	$
		       matches start of word	\<	\<
			 matches end of word	\>	\>
	matches a single char from the range	[a-z]	\[a-z]
      matches a single char not in the range	[^a-z]	\[^a-z]
		  matches an identifier char	\i	\i
		   idem but excluding digits	\I	\I
		 matches a keyword character	\k	\k
		   idem but excluding digits	\K	\K
	       matches a file name character	\f	\f
		   idem but excluding digits	\F	\F
	       matches a printable character	\p	\p
		   idem but excluding digits	\P	\P
	     matches a white space character	\s	\s
	 matches a non-white space character	\S	\S

			       matches <Esc>	\e	\e
			       matches <Tab>	\t	\t
				matches <CR>	\r	\r
				matches <BS>	\b	\b

     matches 0 or more of the preceding atom	*	\*
     matches 1 or more of the preceding atom	\+	\+
	matches 0 or 1 of the preceding atom	\=	\=
	matches 2 to 5 of the preceding atom	\{2,5}  \{2,5}
		  separates two alternatives	\|	\|
		group a pattern into an atom	\(\)	\(\)

|search-offset|		Offsets allowed after search command

    [num]	[num] lines downwards, in column 1
    +[num]	[num] lines downwards, in column 1
    -[num]	[num] lines upwards, in column 1
    e[+num]	[num] characters to the right of the end of the match
    e[-num]	[num] characters to the left of the end of the match
    s[+num]	[num] characters to the right of the start of the match
    s[-num]	[num] characters to the left of the start of the match
    b[+num]	[num] identical to s[+num] above (mnemonic: begin)
    b[-num]	[num] identical to s[-num] above (mnemonic: begin)
    ;{search-command}	execute {search-command} next
------------------------------------------------------------------------------
*Q_ma*		Marks and motions

|m|        m{a-zA-Z}	mark current position with mark {a-zA-Z}
|`a|       `{a-z}	go to mark {a-z} within current file
|`A|       `{A-Z}	go to mark {A-Z} in any file
|`0|       `{0-9}	go to the position where Vim was previously exited
|``|       ``		go to the position before the last jump
|`quote|   `"		go to the position when last editing this file
|`[|       `[		go to the start of the previously operated or put text
|`]|       `]		go to the end of the previously operated or put text
|`<|       `<		go to the start of the (previous) Visual area
|`>|       `>		go to the end of the (previous) Visual area
|`.|       `.		go to the position of the last change in this file
|'|        '{a-zA-Z0-9[]'"<>.}
			same as `, but on the first non-blank in the line
|:marks|  :marks	print the active marks
|CTRL-O|  N  CTRL-O	go to Nth older position in jump list
|CTRL-I|  N  CTRL-I	go to Nth newer position in jump list
|:ju|     :ju[mps]	print the jump list
------------------------------------------------------------------------------
*Q_vm*		Various motions

|%|	   %		find the next brace, bracket, comment, or "#if"/
			   "#else"/"#endif" in this line and go to its match
|H|	N  H		go to the Nth line in the window, on the first
			   non-blank
|M|	   M		go to the middle line in the window, on the first
			   non-blank
|L|	N  L		go to the Nth line from the bottom, on the first
			   non-blank

|go|	N  go			go to Nth byte in the buffer
|:go|	:[range]go[to] [off]	go to [off] byte in the buffer
------------------------------------------------------------------------------
*Q_ta*		Using tags

|:ta|      :ta[g][!] {tag}	jump to tag {tag}
|:ta|      :[count]ta[g][!]	jump to [count]'th newer tag in tag list
|CTRL-]|      CTRL-]		jump to the tag under cursor, unless changes
				   have been made
|:ts|      :ts[elect][!] [tag]	list matching tags and select one to jump to
|:tjump|   :tj[ump][!] [tag]	jump to tag [tag] or select from list when
				   there are multiple matches
|:ltag|    :lt[ag][!] [tag]	jump to tag [tag] and add matching tags to the
				   location list

|:tags|    :tags		print tag list
|CTRL-T|   N  CTRL-T		jump back from Nth older tag in tag list
|:po|      :[count]po[p][!]	jump back from [count]'th older tag in tag list
|:tnext|   :[count]tn[ext][!]	jump to [count]'th next matching tag
|:tp|      :[count]tp[revious][!] jump to [count]'th previous matching tag
|:tr|      :[count]tr[ewind][!]	jump to [count]'th matching tag
|:tl|      :tl[ast][!]		jump to last matching tag

|:ptag|    :pt[ag] {tag}	open a preview window to show tag {tag}
|CTRL-W_}|    CTRL-W }		like CTRL-] but show tag in preview window
|:pts|     :pts[elect]		like ":tselect" but show tag in preview window
|:ptjump|  :ptj[ump]		like ":tjump" but show tag in preview window
|:pclose|  :pc[lose]		close tag preview window
|CTRL-W_z|    CTRL-W z		close tag preview window
------------------------------------------------------------------------------
*Q_sc*		Scrolling

|CTRL-E|	N  CTRL-E	window N lines downwards (default: 1)
|CTRL-D|	N  CTRL-D	window N lines Downwards (default: 1/2 window)
|CTRL-F|	N  CTRL-F	window N pages Forwards (downwards)
|CTRL-Y|	N  CTRL-Y	window N lines upwards (default: 1)
|CTRL-U|	N  CTRL-U	window N lines Upwards (default: 1/2 window)
|CTRL-B|	N  CTRL-B	window N pages Backwards (upwards)
|z<CR>|		   z<CR> or zt	redraw, current line at top of window
|z.|		   z.	 or zz	redraw, current line at center of window
|z-|		   z-	 or zb	redraw, current line at bottom of window

These only work when 'wrap' is off:
|zh|		N  zh		scroll screen N characters to the right
|zl|		N  zl		scroll screen N characters to the left
|zH|		N  zH		scroll screen half a screenwidth to the right
|zL|		N  zL		scroll screen half a screenwidth to the left
------------------------------------------------------------------------------
*Q_in*		Inserting text

|a|	N  a	append text after the cursor (N times)
|A|	N  A	append text at the end of the line (N times)
|i|	N  i	insert text before the cursor (N times) (also: <Insert>)
|I|	N  I	insert text before the first non-blank in the line (N times)
|gI|	N  gI	insert text in column 1 (N times)
|o|	N  o	open a new line below the current line, append text (N times)
|O|	N  O	open a new line above the current line, append text (N times)
|:startinsert|  :star[tinsert][!]  start Insert mode, append when [!] used
|:startreplace| :startr[eplace][!]  start Replace mode, at EOL when [!] used

in Visual block mode:
|v_b_I|	   I	insert the same text in front of all the selected lines
|v_b_A|	   A	append the same text after all the selected lines
------------------------------------------------------------------------------
*Q_ai*		Insert mode keys

|insert-index|	alphabetical index of Insert mode commands

leaving Insert mode:
|i_<Esc>|	<Esc>		  end Insert mode, back to Normal mode
|i_CTRL-C|	CTRL-C		  like <Esc>, but do not use an abbreviation
|i_CTRL-O|	CTRL-O {command}  execute {command} and return to Insert mode

moving around:
|i_<Up>|	cursor keys	  move cursor left/right/up/down
|i_<S-Left>|	shift-left/right  one word left/right
|i_<S-Up>|	shift-up/down	  one screenful backward/forward
|i_<End>|	<End>		  cursor after last character in the line
|i_<Home>|	<Home>		  cursor to first character in the line
------------------------------------------------------------------------------
*Q_ss*		Special keys in Insert mode

|i_CTRL-V|	CTRL-V {char}..	  insert character literally, or enter decimal
				     byte value
|i_<NL>|	<NL> or <CR> or CTRL-M or CTRL-J
				  begin new line
|i_CTRL-E|	CTRL-E		  insert the character from below the cursor
|i_CTRL-Y|	CTRL-Y		  insert the character from above the cursor

|i_CTRL-A|	CTRL-A		  insert previously inserted text
|i_CTRL-@|	CTRL-@		  insert previously inserted text and stop
				     Insert mode
|i_CTRL-R|	CTRL-R {0-9a-z%#:.-="}  insert the contents of a register

|i_CTRL-N|	CTRL-N		  insert next match of identifier before the
				     cursor
|i_CTRL-P|	CTRL-P		  insert previous match of identifier before
				     the cursor
|i_CTRL-X|	CTRL-X ...	  complete the word before the cursor in
				     various ways

|i_<BS>|	<BS> or CTRL-H	  delete the character before the cursor
|i_<Del>|	<Del>		  delete the character under the cursor
|i_CTRL-W|	CTRL-W		  delete word before the cursor
|i_CTRL-U|	CTRL-U		  delete all entered characters in the current
				     line
|i_CTRL-T|	CTRL-T		  insert one shiftwidth of indent in front of
				       the current line
|i_CTRL-D|	CTRL-D		  delete one shiftwidth of indent in front of
				     the current line
|i_0_CTRL-D|	0 CTRL-D	  delete all indent in the current line
|i_^_CTRL-D|	^ CTRL-D	  delete all indent in the current line,
				     restore indent in next line
------------------------------------------------------------------------------
*Q_di*		Digraphs

|:dig|	   :dig[raphs]		show current list of digraphs
|:dig|	   :dig[raphs] {char1}{char2} {number} ...
				add digraph(s) to the list

In Insert or Command-line mode:
|i_CTRL-K|	CTRL-K {char1} {char2}
				  enter digraph
|i_digraph|	{char1} <BS> {char2}
				  enter digraph if 'digraph' option set
------------------------------------------------------------------------------
*Q_si*		Special inserts

|:r|	   :r [file]	   insert the contents of [file] below the cursor
|:r!|	   :r! {command}   insert the standard output of {command} below the
			      cursor
------------------------------------------------------------------------------
*Q_de*		Deleting text

|x|	N  x		delete N characters under and after the cursor
|<Del>|	N  <Del>	delete N characters under and after the cursor
|X|	N  X		delete N characters before the cursor
|d|	N  d{motion}	delete the text that is moved over with {motion}
|v_d|	   {visual}d	delete the highlighted text
|dd|	N  dd		delete N lines
|D|	N  D		delete to the end of the line (and N-1 more lines)
|J|	N  J		join N-1 lines (delete <EOL>s)
|v_J|	   {visual}J	join the highlighted lines
|gJ|	N  gJ		like "J", but without inserting spaces
|v_gJ|	   {visual}gJ	like "{visual}J", but without inserting spaces
|:d|	:[range]d [x]	delete [range] lines [into register x]
------------------------------------------------------------------------------
*Q_cm*		Copying and moving text

|quote|	  "{char}	use register {char} for the next delete, yank, or put
|:reg|	  :reg		show the contents of all registers
|:reg|	  :reg {arg}	show the contents of registers mentioned in {arg}
|y|	  N  y{motion}	yank the text moved over with {motion} into a register
|v_y|	     {visual}y	yank the highlighted text into a register
|yy|	  N  yy		yank N lines into a register
|Y|	  N  Y		yank N lines into a register
|p|	  N  p		put a register after the cursor position (N times)
|P|	  N  P		put a register before the cursor position (N times)
|]p|	  N  ]p		like p, but adjust indent to current line
|[p|	  N  [p		like P, but adjust indent to current line
|gp|	  N  gp		like p, but leave cursor after the new text
|gP|	  N  gP		like P, but leave cursor after the new text
------------------------------------------------------------------------------
*Q_ch*		Changing text

|r|	  N  r{char}	replace N characters with {char}
|gr|	  N  gr{char}	replace N characters without affecting layout
|R|	  N  R		enter Replace mode (repeat the entered text N times)
|gR|	  N  gR		enter virtual Replace mode: Like Replace mode but
			   without affecting layout
|v_b_r|	     {visual}r{char}
			in Visual block mode: Replace each char of the
			   selected text with {char}

	(change = delete text and enter Insert mode)
|c|	  N  c{motion}	change the text that is moved over with {motion}
|v_c|	     {visual}c	change the highlighted text
|cc|	  N  cc		change N lines
|S|	  N  S		change N lines
|C|	  N  C		change to the end of the line (and N-1 more lines)
|s|	  N  s		change N characters
|v_b_c|	     {visual}c	in Visual block mode: Change each of the selected
			   lines with the entered text
|v_b_C|	     {visual}C	in Visual block mode: Change each of the selected
			   lines until end-of-line with the entered text

|~|	  N  ~		switch case for N characters and advance cursor
|v_~|	     {visual}~	switch case for highlighted text
|v_u|	     {visual}u	make highlighted text lowercase
|v_U|	     {visual}U	make highlighted text uppercase
|g~|	     g~{motion} switch case for the text that is moved over with
			   {motion}
|gu|	     gu{motion} make the text that is moved over with {motion}
			   lowercase
|gU|	     gU{motion} make the text that is moved over with {motion}
			   uppercase
|v_g?|	     {visual}g? perform rot13 encoding on highlighted text
|g?|	     g?{motion} perform rot13 encoding on the text that is moved over
			   with {motion}

|CTRL-A|  N  CTRL-A	add N to the number at or after the cursor
|CTRL-X|  N  CTRL-X	subtract N from the number at or after the cursor

|<|	  N  <{motion}	move the lines that are moved over with {motion} one
			   shiftwidth left
|<<|	  N  <<		move N lines one shiftwidth left
|>|	  N  >{motion}	move the lines that are moved over with {motion} one
			   shiftwidth right
|>>|	  N  >>		move N lines one shiftwidth right
|gq|	  N  gq{motion}	format the lines that are moved over with {motion} to
			   'textwidth' length
|:ce|	  :[range]ce[nter] [width]
			center the lines in [range]
|:le|	  :[range]le[ft] [indent]
			left-align the lines in [range] (with [indent])
|:ri|	  :[range]ri[ght] [width]
			right-align the lines in [range]
------------------------------------------------------------------------------
*Q_co*		Complex changes

|!|	   N  !{motion}{command}<CR>
			filter the lines that are moved over through {command}
|!!|	   N  !!{command}<CR>
			filter N lines through {command}
|v_!|	      {visual}!{command}<CR>
			filter the highlighted lines through {command}
|:range!|  :[range]! {command}<CR>
			filter [range] lines through {command}
|=|	   N  ={motion}
			filter the lines that are moved over through 'equalprg'
|==|	   N  ==	filter N lines through 'equalprg'
|v_=|	      {visual}=
			filter the highlighted lines through 'equalprg'
|:s|	   :[range]s[ubstitute]/{pattern}/{string}/[g][c]
			substitute {pattern} by {string} in [range] lines;
			   with [g], replace all occurrences of {pattern};
			   with [c], confirm each replacement
|:s|	   :[range]s[ubstitute] [g][c]
			repeat previous ":s" with new range and options
|&|	      &		Repeat previous ":s" on current line without options
|:ret|	   :[range]ret[ab][!] [tabstop]
			set 'tabstop' to new value and adjust white space
			   accordingly
------------------------------------------------------------------------------
*Q_vi*		Visual mode

|visual-index|	list of Visual mode commands.

|v|        v		start highlighting characters  }  move cursor and use
|V|        V		start highlighting linewise    }  operator to affect
|CTRL-V|   CTRL-V	start highlighting blockwise   }  highlighted text
|v_o|      o		exchange cursor position with start of highlighting
|gv|       gv		start highlighting on previous visual area
|v_v|      v		highlight characters or stop highlighting
|v_V|      V		highlight linewise or stop highlighting
|v_CTRL-V| CTRL-V	highlight blockwise or stop highlighting
------------------------------------------------------------------------------
*Q_to*		Text objects (only in Visual mode or after an operator)

|v_aw|	   N  aw	Select "a word"
|v_iw|	   N  iw	Select "inner word"
|v_aW|	   N  aW	Select "a |WORD|"
|v_iW|	   N  iW	Select "inner |WORD|"
|v_as|	   N  as	Select "a sentence"
|v_is|	   N  is	Select "inner sentence"
|v_ap|	   N  ap	Select "a paragraph"
|v_ip|	   N  ip	Select "inner paragraph"
|v_ab|	   N  ab	Select "a block" (from "[(" to "])")
|v_ib|	   N  ib	Select "inner block" (from "[(" to "])")
|v_aB|	   N  aB	Select "a Block" (from "[{" to "]}")
|v_iB|	   N  iB	Select "inner Block" (from "[{" to "]}")
|v_a>|	   N  a>	Select "a <> block"
|v_i>|	   N  i>	Select "inner <> block"
|v_at|	   N  at	Select "a tag block" (from <aaa> to </aaa>)
|v_it|	   N  it	Select "inner tag block" (from <aaa> to </aaa>)
|v_a'|	   N  a'	Select "a single quoted string"
|v_i'|	   N  i'	Select "inner single quoted string"
|v_aquote| N  a"	Select "a double quoted string"
|v_iquote| N  i"	Select "inner double quoted string"
|v_a`|	   N  a`	Select "a backward quoted string"
|v_i`|	   N  i`	Select "inner backward quoted string"

------------------------------------------------------------------------------
*Q_re*		Repeating commands

|.|	   N  .		repeat last change (with count replaced with N)
|q|	      q{a-z}	record typed characters into register {a-z}
|q|	      q{A-Z}	record typed characters, appended to register {a-z}
|q|	      q		stop recording
|@|	   N  @{a-z}	execute the contents of register {a-z} (N times)
|@@|	   N  @@	   repeat previous @{a-z} (N times)
|:@|	   :@{a-z}	execute the contents of register {a-z} as an Ex
			   command
|:@@|	   :@@		repeat previous :@{a-z}
|:g|	   :[range]g[lobal]/{pattern}/[cmd]
			execute Ex command [cmd] (default: ":p") on the lines
			   within [range] where {pattern} matches
|:g|	   :[range]g[lobal]!/{pattern}/[cmd]
			execute Ex command [cmd] (default: ":p") on the lines
			   within [range] where {pattern} does NOT match
|:so|	   :so[urce] {file}
			read Ex commands from {file}
|:so|	   :so[urce]! {file}
			read Vim commands from {file}
|:sl|	   :sl[eep] [sec]
			don't do anything for [sec] seconds
|gs|	   N  gs	goto Sleep for N seconds
------------------------------------------------------------------------------
*Q_km*		Key mapping

|:map|       :ma[p] {lhs} {rhs}	  map {lhs} to {rhs} in Normal and Visual mode
|:map!|      :ma[p]! {lhs} {rhs}  map {lhs} to {rhs} in Insert and Command-line
				     mode
|:noremap|   :no[remap][!] {lhs} {rhs}
				  same as ":map", no remapping for this {rhs}
|:unmap|     :unm[ap] {lhs}	  remove the mapping of {lhs} for Normal and
				     Visual mode
|:unmap!|    :unm[ap]! {lhs}	  remove the mapping of {lhs} for Insert and
				     Command-line mode
|:map_l|     :ma[p] [lhs]	  list mappings (starting with [lhs]) for
				     Normal and Visual mode
|:map_l!|    :ma[p]! [lhs]	  list mappings (starting with [lhs]) for
				     Insert and Command-line mode
|:cmap|      :cmap/:cunmap/:cnoremap
				  like ":map!"/":unmap!"/":noremap!" but for
				     Command-line mode only
|:imap|      :imap/:iunmap/:inoremap
				  like ":map!"/":unmap!"/":noremap!" but for
				     Insert mode only
|:nmap|      :nmap/:nunmap/:nnoremap
				  like ":map"/":unmap"/":noremap" but for
				     Normal mode only
|:vmap|      :vmap/:vunmap/:vnoremap
				  like ":map"/":unmap"/":noremap" but for
				     Visual mode only
|:omap|      :omap/:ounmap/:onoremap
				  like ":map"/":unmap"/":noremap" but only for
				     when an operator is pending
|:mapc|      :mapc[lear]	  remove mappings for Normal and Visual mode
|:mapc|      :mapc[lear]!	  remove mappings for Insert and Cmdline mode
|:imapc|     :imapc[lear]	  remove mappings for Insert mode
|:vmapc|     :vmapc[lear]	  remove mappings for Visual mode
|:omapc|     :omapc[lear]	  remove mappings for Operator-pending mode
|:nmapc|     :nmapc[lear]	  remove mappings for Normal mode
|:cmapc|     :cmapc[lear]	  remove mappings for Cmdline mode
|:mkexrc|    :mk[exrc][!] [file]  write current mappings, abbreviations, and
				     settings to [file] (default: ".exrc";
				     use ! to overwrite)
|:mkvimrc|   :mkv[imrc][!] [file]
				  same as ":mkexrc", but with default ".vimrc"
|:mksession| :mks[ession][!] [file]
				  like ":mkvimrc", but store current files,
				     windows, etc. too, to be able to continue
				     this session later
------------------------------------------------------------------------------
*Q_ab*		Abbreviations

|:abbreviate|	:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
|:abbreviate|	:ab[breviate] {lhs}	   show abbr's that start with {lhs}
|:abbreviate|	:ab[breviate]		   show all abbreviations
|:unabbreviate|	:una[bbreviate] {lhs}	   remove abbreviation for {lhs}
|:noreabbrev|	:norea[bbrev] [lhs] [rhs]  like ":ab", but don't remap [rhs]
|:iabbrev|	:iab/:iunab/:inoreab	   like ":ab", but only for Insert mode
|:cabbrev|	:cab/:cunab/:cnoreab	   like ":ab", but only for
						Command-line mode
|:abclear|	:abc[lear]		   remove all abbreviations
|:cabclear|	:cabc[lear]		   remove all abbr's for Cmdline mode
|:iabclear|	:iabc[lear]		   remove all abbr's for Insert mode
------------------------------------------------------------------------------
*Q_op*		Options

|:set|		:se[t]			  show all modified options
|:set|		:se[t] all		  show all non-termcap options
|:set|		:se[t] termcap		  show all termcap options
|:set|		:se[t] {option}		  set boolean option (switch it on),
					  show string or number option
|:set|		:se[t] no{option}	  reset boolean option (switch it off)
|:set|		:se[t] inv{option}	  invert boolean option
|:set|		:se[t] {option}={value}	  set string/number option to {value}
|:set|		:se[t] {option}+={value}  append {value} to string option, add
					  {value} to number option
|:set|		:se[t] {option}-={value}  remove {value} to string option,
					  subtract {value} from number option
|:set|		:se[t] {option}?	  show value of {option}
|:set|		:se[t] {option}&	  reset {option} to its default value

|:setlocal|	:setl[ocal]		  like ":set" but set the local value
					  for options that have one
|:setglobal|	:setg[lobal]		  like ":set" but set the global value
					  of a local option

|:fix|		:fix[del]		  set value of 't_kD' according to
					  value of 't_kb'
|:options|	:opt[ions]		  open a new window to view and set
					  options, grouped by functionality,
					  a one line explanation and links to
					  the help

Short explanation of each option:		*option-list*
'aleph'		  'al'	    ASCII code of the letter Aleph (Hebrew)
'allowrevins'	  'ari'     allow CTRL-_ in Insert and Command-line mode
'altkeymap'	  'akm'     for default second language (Farsi/Hebrew)
'ambiwidth'	  'ambw'    what to do with Unicode chars of ambiguous width
'antialias'	  'anti'    Mac OS X: use smooth, antialiased fonts
'autochdir'	  'acd'     change directory to the file in the current window
'arabic'	  'arab'    for Arabic as a default second language
'arabicshape'	  'arshape' do shaping for Arabic characters
'autoindent'	  'ai'	    take indent for new line from previous line
'autoread'	  'ar'	    autom. read file when changed outside of Vim
'autowrite'	  'aw'	    automatically write file if changed
'autowriteall'	  'awa'     as 'autowrite', but works with more commands
'background'	  'bg'	    "dark" or "light", used for highlight colors
'backspace'	  'bs'	    how backspace works at start of line
'backup'	  'bk'	    keep backup file after overwriting a file
'backupcopy'	  'bkc'     make backup as a copy, don't rename the file
'backupdir'	  'bdir'    list of directories for the backup file
'backupext'	  'bex'     extension used for the backup file
'backupskip'	  'bsk'     no backup for files that match these patterns
'balloondelay'	  'bdlay'   delay in mS before a balloon may pop up
'ballooneval'	  'beval'   switch on balloon evaluation
'balloonexpr'	  'bexpr'   expression to show in balloon
'belloff'	  'bo'	    do not ring the bell for these reasons
'binary'	  'bin'     read/write/edit file in binary mode
'bioskey'	  'biosk'   MS-DOS: use bios calls for input characters
'bomb'			    prepend a Byte Order Mark to the file
'breakat'	  'brk'     characters that may cause a line break
'breakindent'	  'bri'     wrapped line repeats indent 
'breakindentopt'  'briopt'  settings for 'breakindent'
'browsedir'	  'bsdir'   which directory to start browsing in
'bufhidden'	  'bh'	    what to do when buffer is no longer in window
'buflisted'	  'bl'	    whether the buffer shows up in the buffer list
'buftype'	  'bt'	    special type of buffer
'casemap'	  'cmp'     specifies how case of letters is changed
'cdpath'	  'cd'	    list of directories searched with ":cd"
'cedit'			    key used to open the command-line window
'charconvert'	  'ccv'     expression for character encoding conversion
'cindent'	  'cin'     do C program indenting
'cinkeys'	  'cink'    keys that trigger indent when 'cindent' is set
'cinoptions'	  'cino'    how to do indenting when 'cindent' is set
'cinwords'	  'cinw'    words where 'si' and 'cin' add an indent
'clipboard'	  'cb'	    use the clipboard as the unnamed register
'cmdheight'	  'ch'	    number of lines to use for the command-line
'cmdwinheight'	  'cwh'     height of the command-line window
'colorcolumn'	  'cc'	    columns to highlight
'columns'	  'co'	    number of columns in the display
'comments'	  'com'     patterns that can start a comment line
'commentstring'   'cms'     template for comments; used for fold marker
'compatible'	  'cp'	    behave Vi-compatible as much as possible
'complete'	  'cpt'     specify how Insert mode completion works
'completefunc'	  'cfu'     function to be used for Insert mode completion
'completeopt'	  'cot'     options for Insert mode completion
'concealcursor'	  'cocu'    whether concealable text is hidden in cursor line
'conceallevel'	  'cole'    whether concealable text is shown or hidden
'confirm'	  'cf'	    ask what to do about unsaved/read-only files
'conskey'	  'consk'   get keys directly from console (MS-DOS only)
'copyindent'	  'ci'	    make 'autoindent' use existing indent structure
'cpoptions'	  'cpo'     flags for Vi-compatible behavior
'cryptmethod'	  'cm'	    type of encryption to use for file writing
'cscopepathcomp'  'cspc'    how many components of the path to show
'cscopeprg'       'csprg'   command to execute cscope
'cscopequickfix'  'csqf'    use quickfix window for cscope results
'cscoperelative'  'csre'    Use cscope.out path basename as prefix
'cscopetag'       'cst'     use cscope for tag commands
'cscopetagorder'  'csto'    determines ":cstag" search order
'cscopeverbose'   'csverb'  give messages when adding a cscope database
'cursorbind'	  'crb'     move cursor in window as it moves in other windows
'cursorcolumn'	  'cuc'	    highlight the screen column of the cursor
'cursorline'	  'cul'	    highlight the screen line of the cursor
'debug'			    set to "msg" to see all error messages
'define'	  'def'     pattern to be used to find a macro definition
'delcombine'	  'deco'    delete combining characters on their own
'dictionary'	  'dict'    list of file names used for keyword completion
'diff'			    use diff mode for the current window
'diffexpr'	  'dex'     expression used to obtain a diff file
'diffopt'	  'dip'     options for using diff mode
'digraph'	  'dg'	    enable the entering of digraphs in Insert mode
'directory'	  'dir'     list of directory names for the swap file
'display'	  'dy'	    list of flags for how to display text
'eadirection'	  'ead'     in which direction 'equalalways' works
'edcompatible'	  'ed'	    toggle flags of ":substitute" command
'emoji'		  'emo'	    emoji characters are considered full width
'encoding'	  'enc'     encoding used internally
'endofline'	  'eol'     write <EOL> for last line in file
'equalalways'	  'ea'	    windows are automatically made the same size
'equalprg'	  'ep'	    external program to use for "=" command
'errorbells'	  'eb'	    ring the bell for error messages
'errorfile'	  'ef'	    name of the errorfile for the QuickFix mode
'errorformat'	  'efm'     description of the lines in the error file
'esckeys'	  'ek'	    recognize function keys in Insert mode
'eventignore'	  'ei'	    autocommand events that are ignored
'expandtab'	  'et'	    use spaces when <Tab> is inserted
'exrc'		  'ex'	    read .vimrc and .exrc in the current directory
'fileencoding'	  'fenc'    file encoding for multi-byte text
'fileencodings'   'fencs'   automatically detected character encodings
'fileformat'	  'ff'	    file format used for file I/O
'fileformats'	  'ffs'     automatically detected values for 'fileformat'
'fileignorecase'  'fic'     ignore case when using file names
'filetype'	  'ft'	    type of file, used for autocommands
'fillchars'	  'fcs'     characters to use for displaying special items
'fixendofline'	  'fixeol'  make sure last line in file has <EOL>
'fkmap'		  'fk'	    Farsi keyboard mapping
'foldclose'	  'fcl'     close a fold when the cursor leaves it
'foldcolumn'	  'fdc'     width of the column used to indicate folds
'foldenable'	  'fen'     set to display all folds open
'foldexpr'	  'fde'     expression used when 'foldmethod' is "expr"
'foldignore'	  'fdi'     ignore lines when 'foldmethod' is "indent"
'foldlevel'	  'fdl'     close folds with a level higher than this
'foldlevelstart'  'fdls'    'foldlevel' when starting to edit a file
'foldmarker'	  'fmr'     markers used when 'foldmethod' is "marker"
'foldmethod'	  'fdm'     folding type
'foldminlines'	  'fml'     minimum number of lines for a fold to be closed
'foldnestmax'	  'fdn'     maximum fold depth
'foldopen'	  'fdo'     for which commands a fold will be opened
'foldtext'	  'fdt'     expression used to display for a closed fold
'formatexpr'	  'fex'     expression used with "gq" command
'formatlistpat'   'flp'     pattern used to recognize a list header
'formatoptions'   'fo'	    how automatic formatting is to be done
'formatprg'	  'fp'	    name of external program used with "gq" command
'fsync'		  'fs'	    whether to invoke fsync() after file write
'gdefault'	  'gd'	    the ":substitute" flag 'g' is default on
'grepformat'	  'gfm'     format of 'grepprg' output
'grepprg'	  'gp'	    program to use for ":grep"
'guicursor'	  'gcr'     GUI: settings for cursor shape and blinking
'guifont'	  'gfn'     GUI: Name(s) of font(s) to be used
'guifontset'	  'gfs'     GUI: Names of multi-byte fonts to be used
'guifontwide'	  'gfw'     list of font names for double-wide characters
'guiheadroom'	  'ghr'     GUI: pixels room for window decorations
'guioptions'	  'go'	    GUI: Which components and options are used
'guipty'		    GUI: try to use a pseudo-tty for ":!" commands
'guitablabel'	  'gtl'     GUI: custom label for a tab page
'guitabtooltip'   'gtt'     GUI: custom tooltip for a tab page
'helpfile'	  'hf'	    full path name of the main help file
'helpheight'	  'hh'	    minimum height of a new help window
'helplang'	  'hlg'     preferred help languages
'hidden'	  'hid'     don't unload buffer when it is |abandon|ed
'highlight'	  'hl'	    sets highlighting mode for various occasions
'history'	  'hi'	    number of command-lines that are remembered
'hkmap'		  'hk'	    Hebrew keyboard mapping
'hkmapp'	  'hkp'     phonetic Hebrew keyboard mapping
'hlsearch'	  'hls'     highlight matches with last search pattern
'icon'			    let Vim set the text of the window icon
'iconstring'		    string to use for the Vim icon text
'ignorecase'	  'ic'	    ignore case in search patterns
'imactivatefunc'  'imaf'    function to enable/disable the X input method
'imactivatekey'   'imak'    key that activates the X input method
'imcmdline'	  'imc'     use IM when starting to edit a command line
'imdisable'	  'imd'     do not use the IM in any mode
'iminsert'	  'imi'     use :lmap or IM in Insert mode
'imsearch'	  'ims'     use :lmap or IM when typing a search pattern
'imstatusfunc'    'imsf'    function to obtain X input method status
'include'	  'inc'     pattern to be used to find an include file
'includeexpr'	  'inex'    expression used to process an include line
'incsearch'	  'is'	    highlight match while typing search pattern
'indentexpr'	  'inde'    expression used to obtain the indent of a line
'indentkeys'	  'indk'    keys that trigger indenting with 'indentexpr'
'infercase'	  'inf'     adjust case of match for keyword completion
'insertmode'	  'im'	    start the edit of a file in Insert mode
'isfname'	  'isf'     characters included in file names and pathnames
'isident'	  'isi'     characters included in identifiers
'iskeyword'	  'isk'     characters included in keywords
'isprint'	  'isp'     printable characters
'joinspaces'	  'js'	    two spaces after a period with a join command
'key'			    encryption key
'keymap'	  'kmp'     name of a keyboard mapping
'keymodel'	  'km'	    enable starting/stopping selection with keys
'keywordprg'	  'kp'	    program to use for the "K" command
'langmap'	  'lmap'    alphabetic characters for other language mode
'langmenu'	  'lm'	    language to be used for the menus
'langremap'	  'lrm'	    do apply 'langmap' to mapped characters
'laststatus'	  'ls'	    tells when last window has status lines
'lazyredraw'	  'lz'	    don't redraw while executing macros
'linebreak'	  'lbr'     wrap long lines at a blank
'lines'			    number of lines in the display
'linespace'	  'lsp'     number of pixel lines to use between characters
'lisp'			    automatic indenting for Lisp
'lispwords'	  'lw'	    words that change how lisp indenting works
'list'			    show <Tab> and <EOL>
'listchars'	  'lcs'     characters for displaying in list mode
'loadplugins'	  'lpl'     load plugin scripts when starting up
'luadll'		    name of the Lua dynamic library
'macatsui'		    Mac GUI: use ATSUI text drawing
'magic'			    changes special characters in search patterns
'makeef'	  'mef'     name of the errorfile for ":make"
'makeprg'	  'mp'	    program to use for the ":make" command
'matchpairs'	  'mps'     pairs of characters that "%" can match
'matchtime'	  'mat'     tenths of a second to show matching paren
'maxcombine'	  'mco'     maximum nr of combining characters displayed
'maxfuncdepth'	  'mfd'     maximum recursive depth for user functions
'maxmapdepth'	  'mmd'     maximum recursive depth for mapping
'maxmem'	  'mm'	    maximum memory (in Kbyte) used for one buffer
'maxmempattern'   'mmp'     maximum memory (in Kbyte) used for pattern search
'maxmemtot'	  'mmt'     maximum memory (in Kbyte) used for all buffers
'menuitems'	  'mis'     maximum number of items in a menu
'mkspellmem'	  'msm'     memory used before |:mkspell| compresses the tree
'modeline'	  'ml'	    recognize modelines at start or end of file
'modelines'	  'mls'     number of lines checked for modelines
'modifiable'	  'ma'	    changes to the text are not possible
'modified'	  'mod'     buffer has been modified
'more'			    pause listings when the whole screen is filled
'mouse'			    enable the use of mouse clicks
'mousefocus'	  'mousef'  keyboard focus follows the mouse
'mousehide'	  'mh'	    hide mouse pointer while typing
'mousemodel'	  'mousem'  changes meaning of mouse buttons
'mouseshape'	  'mouses'  shape of the mouse pointer in different modes
'mousetime'	  'mouset'  max time between mouse double-click
'mzquantum'	  'mzq'     the interval between polls for MzScheme threads
'nrformats'	  'nf'	    number formats recognized for CTRL-A command
'number'	  'nu'	    print the line number in front of each line
'numberwidth'	  'nuw'     number of columns used for the line number
'omnifunc'	  'ofu'     function for filetype-specific completion
'opendevice'	  'odev'    allow reading/writing devices on MS-Windows
'operatorfunc'	  'opfunc'  function to be called for |g@| operator
'osfiletype'	  'oft'     no longer supported
'packpath'	  'pp'      list of directories used for packages
'paragraphs'	  'para'    nroff macros that separate paragraphs
'paste'			    allow pasting text
'pastetoggle'	  'pt'	    key code that causes 'paste' to toggle
'patchexpr'	  'pex'     expression used to patch a file
'patchmode'	  'pm'	    keep the oldest version of a file
'path'		  'pa'	    list of directories searched with "gf" et.al.
'perldll'		    name of the Perl dynamic library
'preserveindent'  'pi'	    preserve the indent structure when reindenting
'previewheight'   'pvh'     height of the preview window
'previewwindow'   'pvw'     identifies the preview window
'printdevice'	  'pdev'    name of the printer to be used for :hardcopy
'printencoding'   'penc'    encoding to be used for printing
'printexpr'	  'pexpr'   expression used to print PostScript for :hardcopy
'printfont'	  'pfn'     name of the font to be used for :hardcopy
'printheader'	  'pheader' format of the header used for :hardcopy
'printmbcharset'  'pmbcs'   CJK character set to be used for :hardcopy
'printmbfont'	  'pmbfn'   font names to be used for CJK output of :hardcopy
'printoptions'	  'popt'    controls the format of :hardcopy output
'prompt'	  'prompt'  enable prompt in Ex mode
'pumheight'	  'ph'	    maximum height of the popup menu
'pythondll'		    name of the Python 2 dynamic library
'pythonthreedll'	    name of the Python 3 dynamic library
'quoteescape'	  'qe'	    escape characters used in a string
'readonly'	  'ro'	    disallow writing the buffer
'redrawtime'	  'rdt'     timeout for 'hlsearch' and |:match| highlighting
'regexpengine'	  're'	    default regexp engine to use
'relativenumber'  'rnu'	    show relative line number in front of each line
'remap'			    allow mappings to work recursively
'renderoptions'	  'rop'	    options for text rendering on Windows
'report'		    threshold for reporting nr. of lines changed
'restorescreen'   'rs'	    Win32: restore screen when exiting
'revins'	  'ri'	    inserting characters will work backwards
'rightleft'	  'rl'	    window is right-to-left oriented
'rightleftcmd'	  'rlc'     commands for which editing works right-to-left
'rubydll'		    name of the Ruby dynamic library
'ruler'		  'ru'	    show cursor line and column in the status line
'rulerformat'	  'ruf'     custom format for the ruler
'runtimepath'	  'rtp'     list of directories used for runtime files
'scroll'	  'scr'     lines to scroll with CTRL-U and CTRL-D
'scrollbind'	  'scb'     scroll in window as other windows scroll
'scrolljump'	  'sj'	    minimum number of lines to scroll
'scrolloff'	  'so'	    minimum nr. of lines above and below cursor
'scrollopt'	  'sbo'     how 'scrollbind' should behave
'sections'	  'sect'    nroff macros that separate sections
'secure'		    secure mode for reading .vimrc in current dir
'selection'	  'sel'     what type of selection to use
'selectmode'	  'slm'     when to use Select mode instead of Visual mode
'sessionoptions'  'ssop'    options for |:mksession|
'shell'		  'sh'	    name of shell to use for external commands
'shellcmdflag'	  'shcf'    flag to shell to execute one command
'shellpipe'	  'sp'	    string to put output of ":make" in error file
'shellquote'	  'shq'     quote character(s) for around shell command
'shellredir'	  'srr'     string to put output of filter in a temp file
'shellslash'	  'ssl'     use forward slash for shell file names
'shelltemp'	  'stmp'    whether to use a temp file for shell commands
'shelltype'	  'st'	    Amiga: influences how to use a shell
'shellxescape'	  'sxe'     characters to escape when 'shellxquote' is (
'shellxquote'	  'sxq'     like 'shellquote', but include redirection
'shiftround'	  'sr'	    round indent to multiple of shiftwidth
'shiftwidth'	  'sw'	    number of spaces to use for (auto)indent step
'shortmess'	  'shm'     list of flags, reduce length of messages
'shortname'	  'sn'	    non-MS-DOS: Filenames assumed to be 8.3 chars
'showbreak'	  'sbr'     string to use at the start of wrapped lines
'showcmd'	  'sc'	    show (partial) command in status line
'showfulltag'	  'sft'     show full tag pattern when completing tag
'showmatch'	  'sm'	    briefly jump to matching bracket if insert one
'showmode'	  'smd'     message on status line to show current mode
'showtabline'	  'stal'    tells when the tab pages line is displayed
'sidescroll'	  'ss'	    minimum number of columns to scroll horizontal
'sidescrolloff'   'siso'    min. nr. of columns to left and right of cursor
'signcolumn'	  'scl'	    when to display the sign column
'smartcase'	  'scs'     no ignore case when pattern has uppercase
'smartindent'	  'si'	    smart autoindenting for C programs
'smarttab'	  'sta'     use 'shiftwidth' when inserting <Tab>
'softtabstop'	  'sts'     number of spaces that <Tab> uses while editing
'spell'			    enable spell checking
'spellcapcheck'   'spc'     pattern to locate end of a sentence
'spellfile'	  'spf'     files where |zg| and |zw| store words
'spelllang'	  'spl'     language(s) to do spell checking for
'spellsuggest'	  'sps'     method(s) used to suggest spelling corrections
'splitbelow'	  'sb'	    new window from split is below the current one
'splitright'	  'spr'     new window is put right of the current one
'startofline'	  'sol'     commands move cursor to first non-blank in line
'statusline'	  'stl'     custom format for the status line
'suffixes'	  'su'	    suffixes that are ignored with multiple match
'suffixesadd'	  'sua'     suffixes added when searching for a file
'swapfile'	  'swf'     whether to use a swapfile for a buffer
'swapsync'	  'sws'     how to sync the swap file
'switchbuf'	  'swb'     sets behavior when switching to another buffer
'synmaxcol'	  'smc'     maximum column to find syntax items
'syntax'	  'syn'     syntax to be loaded for current buffer
'tabline'	  'tal'     custom format for the console tab pages line
'tabpagemax'	  'tpm'     maximum number of tab pages for |-p| and "tab all"
'tabstop'	  'ts'	    number of spaces that <Tab> in file uses
'tagbsearch'	  'tbs'     use binary searching in tags files
'tagcase'	  'tc'      how to handle case when searching in tags files
'taglength'	  'tl'	    number of significant characters for a tag
'tagrelative'	  'tr'	    file names in tag file are relative
'tags'		  'tag'     list of file names used by the tag command
'tagstack'	  'tgst'    push tags onto the tag stack
'tcldll'		    name of the Tcl dynamic library
'term'			    name of the terminal
'termbidi'	  'tbidi'   terminal takes care of bi-directionality
'termencoding'	  'tenc'    character encoding used by the terminal
'termguicolors'	  'tgc'     use GUI colors for the terminal
'terse'			    shorten some messages
'textauto'	  'ta'	    obsolete, use 'fileformats'
'textmode'	  'tx'	    obsolete, use 'fileformat'
'textwidth'	  'tw'	    maximum width of text that is being inserted
'thesaurus'	  'tsr'     list of thesaurus files for keyword completion
'tildeop'	  'top'     tilde command "~" behaves like an operator
'timeout'	  'to'	    time out on mappings and key codes
'timeoutlen'	  'tm'	    time out time in milliseconds
'title'			    let Vim set the title of the window
'titlelen'		    percentage of 'columns' used for window title
'titleold'		    old title, restored when exiting
'titlestring'		    string to use for the Vim window title
'toolbar'	  'tb'	    GUI: which items to show in the toolbar
'toolbariconsize' 'tbis'    size of the toolbar icons (for GTK 2 only)
'ttimeout'		    time out on mappings
'ttimeoutlen'	  'ttm'     time out time for key codes in milliseconds
'ttybuiltin'	  'tbi'     use built-in termcap before external termcap
'ttyfast'	  'tf'	    indicates a fast terminal connection
'ttymouse'	  'ttym'    type of mouse codes generated
'ttyscroll'	  'tsl'     maximum number of lines for a scroll
'ttytype'	  'tty'     alias for 'term'
'undodir'	  'udir'    where to store undo files
'undofile'	  'udf'	    save undo information in a file
'undolevels'	  'ul'	    maximum number of changes that can be undone
'undoreload'	  'ur'	    max nr of lines to save for undo on a buffer reload
'updatecount'	  'uc'	    after this many characters flush swap file
'updatetime'	  'ut'	    after this many milliseconds flush swap file
'verbose'	  'vbs'     give informative messages
'verbosefile'	  'vfile'   file to write messages in
'viewdir'	  'vdir'    directory where to store files with :mkview
'viewoptions'	  'vop'     specifies what to save for :mkview
'viminfo'	  'vi'	    use .viminfo file upon startup and exiting
'virtualedit'	  've'	    when to use virtual editing
'visualbell'	  'vb'	    use visual bell instead of beeping
'warn'			    warn for shell command when buffer was changed
'weirdinvert'	  'wiv'	    for terminals that have weird inversion method
'whichwrap'	  'ww'	    allow specified keys to cross line boundaries
'wildchar'	  'wc'	    command-line character for wildcard expansion
'wildcharm'	  'wcm'     like 'wildchar' but also works when mapped
'wildignore'	  'wig'     files matching these patterns are not completed
'wildignorecase'  'wic'     ignore case when completing file names
'wildmenu'	  'wmnu'    use menu for command line completion
'wildmode'	  'wim'     mode for 'wildchar' command-line expansion
'wildoptions'	  'wop'     specifies how command line completion is done
'winaltkeys'	  'wak'     when the windows system handles ALT keys
'window'	  'wi'	    nr of lines to scroll for CTRL-F and CTRL-B
'winheight'	  'wh'	    minimum number of lines for the current window
'winfixheight'	  'wfh'     keep window height when opening/closing windows
'winfixwidth'	  'wfw'     keep window width when opening/closing windows
'winminheight'	  'wmh'     minimum number of lines for any window
'winminwidth'	  'wmw'     minimal number of columns for any window
'winwidth'	  'wiw'     minimal number of columns for current window
'wrap'			    long lines wrap and continue on the next line
'wrapmargin'	  'wm'	    chars from the right where wrapping starts
'wrapscan'	  'ws'	    searches wrap around the end of the file
'write'			    writing to a file is allowed
'writeany'	  'wa'	    write to file with no need for "!" override
'writebackup'	  'wb'	    make a backup before overwriting a file
'writedelay'	  'wd'	    delay this many msec for each char (for debug)
------------------------------------------------------------------------------
*Q_ur*		Undo/Redo commands

|u|       N  u		undo last N changes
|CTRL-R|  N  CTRL-R	redo last N undone changes
|U|          U		restore last changed line
------------------------------------------------------------------------------
*Q_et*		External commands

|:shell|	:sh[ell]	start a shell
|:!|		:!{command}	execute {command} with a shell
|K|		   K		lookup keyword under the cursor with
				   'keywordprg' program (default: "man")
------------------------------------------------------------------------------
*Q_qf*		Quickfix commands

|:cc|		:cc [nr]	display error [nr] (default is the same again)
|:cnext|	:cn		display the next error
|:cprevious|	:cp		display the previous error
|:clist|	:cl		list all errors
|:cfile|	:cf		read errors from the file 'errorfile'
|:cgetbuffer|	:cgetb		like :cbuffer but don't jump to the first error
|:cgetfile|	:cg		like :cfile but don't jump to the first error
|:cgetexpr|	:cgete		like :cexpr but don't jump to the first error
|:caddfile|	:caddf		add errors from the error file to the current
				   quickfix list
|:caddexpr|	:cad		add errors from an expression to the current
				   quickfix list
|:cbuffer|	:cb		read errors from text in a buffer
|:cexpr|	:cex		read errors from an expression
|:cquit|	:cq		quit without writing and return error code (to
				   the compiler)
|:make|		:make [args]	start make, read errors, and jump to first
				   error
|:grep|		:gr[ep] [args]	execute 'grepprg' to find matches and jump to
				   the first one
------------------------------------------------------------------------------
*Q_vc*		Various commands

|CTRL-L|	   CTRL-L	clear and redraw the screen
|CTRL-G|	   CTRL-G	show current file name (with path) and cursor
				   position
|ga|		   ga		show ascii value of character under cursor in
				   decimal, hex, and octal
|g8|		   g8		for utf-8 encoding: show byte sequence for
				   character under cursor in hex
|g_CTRL-G|	   g CTRL-G	show cursor column, line, and character
				   position
|CTRL-C|	   CTRL-C	during searches: Interrupt the search
|dos-CTRL-Break|   CTRL-Break	MS-DOS: during searches: Interrupt the search
|<Del>|		   <Del>	while entering a count: delete last character
|:version|	:ve[rsion]	show version information
|:mode|		:mode N		MS-DOS: set screen mode to N (number, C80,
				   C4350, etc.)
|:normal|	:norm[al][!] {commands}
				execute Normal mode commands
|Q|		   Q		switch to "Ex" mode

|:redir|	:redir >{file}		redirect messages to {file}
|:silent|	:silent[!] {command}	execute {command} silently
|:confirm|	:confirm {command}	quit, write, etc., asking about
					unsaved changes or read-only files
|:browse|	:browse {command}	open/read/write file, using a
					file selection dialog
------------------------------------------------------------------------------
*Q_ce*		Command-line editing

|c_<Esc>|	<Esc>		   abandon command-line (if 'wildchar' is
				      <Esc>, type it twice)

|c_CTRL-V|	CTRL-V {char}	   insert {char} literally
|c_CTRL-V|	CTRL-V {number}    enter decimal value of character (up to
				      three digits)
|c_CTRL-K|	CTRL-K {char1} {char2}
				   enter digraph (See |Q_di|)
|c_CTRL-R|	CTRL-R {0-9a-z"%#:-=}
				   insert the contents of a register

|c_<Left>|	<Left>/<Right>	   cursor left/right
|c_<S-Left>|	<S-Left>/<S-Right> cursor one word left/right
|c_CTRL-B|	CTRL-B/CTRL-E	   cursor to beginning/end of command-line

|c_<BS>|	<BS>		   delete the character in front of the cursor
|c_<Del>|	<Del>		   delete the character under the cursor
|c_CTRL-W|	CTRL-W		   delete the word in front of the cursor
|c_CTRL-U|	CTRL-U		   remove all characters

|c_<Up>|	<Up>/<Down>	   recall older/newer command-line that starts
				      with current command
|c_<S-Up>|	<S-Up>/<S-Down>	   recall older/newer command-line from history
|c_CTRL-G|	CTRL-G		   next match when 'incsearch' is active
|c_CTRL-T|	CTRL-T		   previous match when 'incsearch' is active
|:history|	:his[tory]	   show older command-lines

Context-sensitive completion on the command-line:

|c_wildchar|	'wildchar'  (default: <Tab>)
				do completion on the pattern in front of the
				   cursor; if there are multiple matches,
				   beep and show the first one; further
				   'wildchar' will show the next ones
|c_CTRL-D|	CTRL-D		list all names that match the pattern in
				   front of the cursor
|c_CTRL-A|	CTRL-A		insert all names that match pattern in front
				   of cursor
|c_CTRL-L|	CTRL-L		insert longest common part of names that
				   match pattern
|c_CTRL-N|	CTRL-N		after 'wildchar' with multiple matches: go
				   to next match
|c_CTRL-P|	CTRL-P		after 'wildchar' with multiple matches: go
				   to previous match
------------------------------------------------------------------------------
*Q_ra*		Ex ranges

|:range|	,		separates two line numbers
|:range|	;		idem, set cursor to the first line number
				before interpreting the second one

|:range|	{number}	an absolute line number
|:range|	.		the current line
|:range|	$		the last line in the file
|:range|	%		equal to 1,$ (the entire file)
|:range|	*		equal to '<,'> (visual area)
|:range|	't		position of mark t
|:range|	/{pattern}[/]	the next line where {pattern} matches
|:range|	?{pattern}[?]	the previous line where {pattern} matches

|:range|	+[num]		add [num] to the preceding line number
				   (default: 1)
|:range|	-[num]		subtract [num] from the preceding line
				   number (default: 1)
------------------------------------------------------------------------------
*Q_ex*		Special Ex characters

|:bar|      |		separates two commands (not for ":global" and ":!")
|:quote|    "		begins comment

|:_%|       %		current file name (only where a file name is expected)
|:_#|       #[num]	alternate file name [num] (only where a file name is
			   expected)
	Note: The next seven are typed literally; these are not special keys!
|:<abuf>|   <abuf>	buffer number, for use in an autocommand (only where a
			   file name is expected)
|:<afile>|  <afile>	file name, for use in an autocommand (only where a
			   file name is expected)
|:<amatch>| <amatch>	what matched with the pattern, for use in an
			   autocommand (only where a file name is expected)
|:<cword>|  <cword>	word under the cursor (only where a file name is
			   expected)
|:<cWORD>|  <cWORD>	WORD under the cursor (only where a file name is
			   expected) (see |WORD|)
|:<cfile>|  <cfile>	file name under the cursor (only where a file name is
			   expected)
|:<sfile>|  <sfile>	file name of a ":source"d file, within that file (only
			   where a file name is expected)

		After "%", "#", "<cfile>", "<sfile>" or "<afile>"
		|::p|	    :p		full path
		|::h|	    :h		head (file name removed)
		|::t|	    :t		tail (file name only)
		|::r|	    :r		root (extension removed)
		|::e|	    :e		extension
		|::s|	    :s/{pat}/{repl}/	substitute {pat} with {repl}
------------------------------------------------------------------------------
*Q_st*		Starting Vim

|-vim|	   vim [options]		start editing with an empty buffer
|-file|	   vim [options] {file} ..	start editing one or more files
|--|	   vim [options] -		read file from stdin
|-tag|	   vim [options] -t {tag}	edit the file associated with {tag}
|-qf|	   vim [options] -q [fname]	start editing in QuickFix mode,
					   display the first error

	Most useful Vim arguments (for full list see |startup-options|)

|-gui|	-g		    start GUI (also allows other options)

|-+|	+[num]		    put the cursor at line [num] (default: last line)
|-+c|	+{command}	    execute {command} after loading the file
|-+/|	+/{pat} {file} ..   put the cursor at the first occurrence of {pat}
|-v|	-v		    Vi mode, start ex in Normal mode
|-e|	-e		    Ex mode, start vim in Ex mode
|-R|	-R		    Read-only mode, implies -n
|-m|	-m		    modifications not allowed (resets 'write' option)
|-d|	-d		    diff mode |diff|
|-b|	-b		    binary mode
|-l|	-l		    lisp mode
|-A|	-A		    Arabic mode ('arabic' is set)
|-F|	-F		    Farsi mode ('fkmap' and 'rightleft' are set)
|-H|	-H		    Hebrew mode ('hkmap' and 'rightleft' are set)
|-V|	-V		    Verbose, give informative messages
|-C|	-C		    Compatible, set the 'compatible' option
|-N|	-N		    Nocompatible, reset the 'compatible' option
|-r|	-r		    give list of swap files
|-r|	-r {file} ..	    recover aborted edit session
|-n|	-n		    do not create a swap file
|-o|	-o [num]	    open [num] windows (default: one for each file)
|-f|	-f		    GUI: foreground process, don't fork
			    Amiga: do not restart Vim to open a window (for
				e.g., mail)
|-s|	-s {scriptin}	    first read commands from the file {scriptin}
|-w|	-w {scriptout}	    write typed chars to file {scriptout} (append)
|-W|	-W {scriptout}	    write typed chars to file {scriptout} (overwrite)
|-T|	-T {terminal}	    set terminal name
|-d|	-d {device}	    Amiga: open {device} to be used as a console
|-u|	-u {vimrc}	    read inits from {vimrc} instead of other inits
|-U|	-U {gvimrc}	    idem, for when starting the GUI
|-i|	-i {viminfo}	    read info from {viminfo} instead of other files
|---|	--		    end of options, other arguments are file names
|--help|    --help	    show list of arguments and exit
|--version| --version	    show version info and exit
|--|	-		    read file from stdin
------------------------------------------------------------------------------
*Q_ed*		Editing a file

	   Without !: Fail if changes have been made to the current buffer.
	      With !: Discard any changes to the current buffer.
|:edit_f|  :e[dit][!] {file}	edit {file}
|:edit|    :e[dit][!]		reload the current file
|:enew|    :ene[w][!]		edit a new, unnamed buffer
|:find|    :fin[d][!] {file}	find {file} in 'path' and edit it

|CTRL-^|   N  CTRL-^		edit alternate file N (equivalent to ":e #N")
|gf|          gf  or ]f		edit the file whose name is under the cursor
|:pwd|     :pwd			print the current directory name
|:cd|      :cd [path]		change the current directory to [path]
|:cd-|     :cd -		back to previous current directory
|:file|    :f[ile]		print the current file name and the cursor
				   position
|:file|    :f[ile] {name}	set the current file name to {name}
|:files|   :files		show alternate file names
------------------------------------------------------------------------------
*Q_fl*		Using the argument list			|argument-list|

|:args|	   :ar[gs]		print the argument list, with the current file
				   in "[]"
|:all|	   :all  or :sall	open a window for every file in the arg list
|:wn|	   :wn[ext][!]		write file and edit next file
|:wn|	   :wn[ext][!] {file}	write to {file} and edit next file, unless
				   {file} exists; With !, overwrite existing
				   file
|:wN|	   :wN[ext][!] [file]	write file and edit previous file

	     in current window    in new window	~
|:argument|  :argu[ment] N	  :sar[gument] N	edit file N
|:next|      :n[ext]		  :sn[ext]		edit next file
|:next_f|    :n[ext] {arglist}	  :sn[ext] {arglist}	define new arg list
							   and edit first file
|:Next|      :N[ext]		  :sN[ext]		edit previous file
|:first|     :fir[st]		  :sfir[st]		edit first file
|:last|      :la[st]		  :sla[st]		edit last file
------------------------------------------------------------------------------
*Q_wq*		Writing and quitting

|:w|	  :[range]w[rite][!]		write to the current file
|:w_f|	  :[range]w[rite] {file}	write to {file}, unless it already
					   exists
|:w_f|	  :[range]w[rite]! {file}	write to {file}.  Overwrite an existing
					   file
|:w_a|	  :[range]w[rite][!] >>		append to the current file
|:w_a|	  :[range]w[rite][!] >> {file}	append to {file}
|:w_c|	  :[range]w[rite] !{cmd}	execute {cmd} with [range] lines as
					   standard input
|:up|	  :[range]up[date][!]		write to current file if modified
|:wall|	  :wa[ll][!]			write all changed buffers

|:q|	  :q[uit]		quit current buffer, unless changes have been
				   made; Exit Vim when there are no other
				   non-help buffers
|:q|	  :q[uit]!		quit current buffer always, discard any
				   changes.  Exit Vim when there are no other
				   non-help buffers
|:qa|	  :qa[ll]		exit Vim, unless changes have been made
|:qa|	  :qa[ll]!		exit Vim always, discard any changes
|:cq|	  :cq			quit without writing and return error code

|:wq|	  :wq[!]		write the current file and exit
|:wq|	  :wq[!] {file}		write to {file} and exit
|:xit|	  :x[it][!] [file]	like ":wq" but write only when changes have
				   been made
|ZZ|	     ZZ			same as ":x"
|ZQ|	     ZQ			same as ":q!"
|:xall|	  :xa[ll][!]  or :wqall[!]
				write all changed buffers and exit

|:stop|	  :st[op][!]		suspend Vim or start new shell; if 'aw' option
				   is set and [!] not given write the buffer
|CTRL-Z|     CTRL-Z		same as ":stop"
------------------------------------------------------------------------------
*Q_ac*		Automatic Commands

|viminfo-file|	read registers, marks, history at startup, save when exiting.

|:rviminfo|	:rv[iminfo] [file]	read info from viminfo file [file]
|:rviminfo|	:rv[iminfo]! [file]	idem, overwrite existing info
|:wviminfo|	:wv[iminfo] [file]	add info to viminfo file [file]
|:wviminfo|	:wv[iminfo]! [file]	write info to viminfo file [file]

|modeline|	Automatic option setting when editing a file

|modeline|	vim:{set-arg}: ..	In the first and last lines of the
					file (see 'ml' option), {set-arg} is
					given as an argument to ":set"

|autocommand|	Automatic execution of commands on certain events.

|:autocmd|	:au			  list all autocommands
|:autocmd|	:au {event}		  list all autocommands for {event}
|:autocmd|	:au {event} {pat}	  list all autocommands for {event}
					  with {pat}
|:autocmd|	:au {event} {pat} {cmd}	  enter new autocommands for {event}
					  with {pat}
|:autocmd|	:au!			  remove all autocommands
|:autocmd|	:au! {event}		  remove all autocommands for {event}
|:autocmd|	:au! * {pat}		  remove all autocommands for {pat}
|:autocmd|	:au! {event} {pat}	  remove all autocommands for {event}
					  with {pat}
|:autocmd|	:au! {event} {pat} {cmd}  remove all autocommands for {event}
					  with {pat} and enter new one
------------------------------------------------------------------------------
*Q_wi*		Multi-window commands

|CTRL-W_s|	CTRL-W s  or  :split	split window into two parts
|:split_f|	:split {file}		split window and edit {file} in one of
					   them
|:vsplit|	:vsplit {file}		same, but split vertically
|:vertical|	:vertical {cmd}		make {cmd} split vertically

|:sfind|	:sf[ind] {file}		split window, find {file} in 'path'
					   and edit it
|CTRL-W_]|	CTRL-W ]		split window and jump to tag under
					   cursor
|CTRL-W_f|	CTRL-W f		split window and edit file name under
					   the cursor
|CTRL-W_^|	CTRL-W ^		split window and edit alternate file
|CTRL-W_n|	CTRL-W n  or  :new	create new empty window
|CTRL-W_q|	CTRL-W q  or  :q[uit]	quit editing and close window
|CTRL-W_c|	CTRL-W c  or  :cl[ose]	make buffer hidden and close window
|CTRL-W_o|	CTRL-W o  or  :on[ly]	make current window only one on the
					   screen

|CTRL-W_j|	CTRL-W j		move cursor to window below
|CTRL-W_k|	CTRL-W k		move cursor to window above
|CTRL-W_CTRL-W|	CTRL-W CTRL-W		move cursor to window below (wrap)
|CTRL-W_W|	CTRL-W W		move cursor to window above (wrap)
|CTRL-W_t|	CTRL-W t		move cursor to top window
|CTRL-W_b|	CTRL-W b		move cursor to bottom window
|CTRL-W_p|	CTRL-W p		move cursor to previous active window

|CTRL-W_r|	CTRL-W r		rotate windows downwards
|CTRL-W_R|	CTRL-W R		rotate windows upwards
|CTRL-W_x|	CTRL-W x		exchange current window with next one

|CTRL-W_=|	CTRL-W =		make all windows equal height & width
|CTRL-W_-|	CTRL-W -		decrease current window height
|CTRL-W_+|	CTRL-W +		increase current window height
|CTRL-W__|	CTRL-W _		set current window height (default:
					   very high)

|CTRL-W_<|	CTRL-W <		decrease current window width
|CTRL-W_>|	CTRL-W >		increase current window width
|CTRL-W_bar|	CTRL-W |		set current window width (default:
					   widest possible)
------------------------------------------------------------------------------
*Q_bu*		Buffer list commands

|:buffers|	:buffers  or  :files	list all known buffer and file names

|:ball|		:ball	  or  :sball	edit all args/buffers
|:unhide|	:unhide   or  :sunhide	edit all loaded buffers

|:badd|		:badd {fname}		add file name {fname} to the list
|:bunload|	:bunload[!] [N]		unload buffer [N] from memory
|:bdelete|	:bdelete[!] [N]		unload buffer [N] and delete it from
					   the buffer list

		in current window  in new window       ~
|:buffer|	:[N]buffer [N]     :[N]sbuffer [N]     to arg/buf N
|:bnext|	:[N]bnext [N]      :[N]sbnext [N]      to Nth next arg/buf
|:bNext|	:[N]bNext [N]      :[N]sbNext [N]      to Nth previous arg/buf
|:bprevious|	:[N]bprevious [N]  :[N]sbprevious [N]  to Nth previous arg/buf
|:bfirst|	:bfirst	           :sbfirst            to first arg/buf
|:blast|	:blast	           :sblast             to last arg/buf
|:bmodified|	:[N]bmod [N]       :[N]sbmod [N]       to Nth modified buf
------------------------------------------------------------------------------
*Q_sy*		Syntax Highlighting

|:syn-on|	:syntax on		start using syntax highlighting
|:syn-off|	:syntax off		stop using syntax highlighting

|:syn-keyword|	:syntax keyword {group-name} {keyword} ..
					add a syntax keyword item
|:syn-match|	:syntax match {group-name} {pattern} ...
					add syntax match item
|:syn-region|	:syntax region {group-name} {pattern} ...
					add syntax region item
|:syn-sync|	:syntax sync [ccomment | lines {N} | ...]
					tell syntax how to sync
|:syntax|	:syntax [list]		list current syntax items
|:syn-clear|	:syntax clear		clear all syntax info

|:highlight|	:highlight clear	clear all highlight info
|:highlight|	:highlight {group-name} {key}={arg} ..
					set highlighting for {group-name}

|:filetype|	:filetype on		switch on file type detection, without
					syntax highlighting
|:filetype|	:filetype plugin indent on
					switch on file type detection, with
					automatic indenting and settings
------------------------------------------------------------------------------
*Q_gu*		GUI commands

|:gui|		:gui			UNIX: start the GUI
|:gui|		:gui {fname} ..		idem, and edit {fname} ..

|:menu|		:menu			list all menus
|:menu|		:menu {mpath}		list menus starting with {mpath}
|:menu|		:menu {mpath} {rhs}	add menu {mpath}, giving {rhs}
|:menu|		:menu {pri} {mpath} {rhs}
					idem, with priorities {pri}
|:menu|		:menu ToolBar.{name} {rhs}
					add toolbar item, giving {rhs}
|:tmenu|	:tmenu {mpath} {text}	add tooltip to menu {mpath}
|:unmenu|	:unmenu {mpath}		remove menu {mpath}
------------------------------------------------------------------------------
*Q_fo*		Folding

|'foldmethod'|	set foldmethod=manual	manual folding
		set foldmethod=indent	folding by indent
		set foldmethod=expr	folding by 'foldexpr'
		set foldmethod=syntax	folding by syntax regions
		set foldmethod=marker	folding by 'foldmarker'

|zf|		zf{motion}		operator: Define a fold manually
|:fold|		:{range}fold		define a fold for {range} lines
|zd|		zd			delete one fold under the cursor
|zD|		zD			delete all folds under the cursor

|zo|		zo			open one fold under the cursor
|zO|		zO			open all folds under the cursor
|zc|		zc			close one fold under the cursor
|zC|		zC			close all folds under the cursor

|zm|		zm			fold more: decrease 'foldlevel'
|zM|		zM			close all folds: make 'foldlevel' zero
|zr|		zr			reduce folding: increase 'foldlevel'
|zR|		zR			open all folds: make 'foldlevel' max.

|zn|		zn			fold none: reset 'foldenable'
|zN|		zN			fold normal set 'foldenable'
|zi|		zi			invert 'foldenable'

 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      n SDRAM/DDR Timing parameters
	  The calculated SDRAM timing parameters may not be 100%
	  accurate - This option is therefore marked experimental.

config BFIN_KERNEL_CLOCK_MEMINIT_CALC
	bool "Calculate Timings"

config BFIN_KERNEL_CLOCK_MEMINIT_SPEC
	bool "Provide accurate Timings based on target SCLK"
	help
	  Please consult the Blackfin Hardware Reference Manuals as well
	  as the memory device datasheet.
	  http://docs.blackfin.uclinux.org/doku.php?id=bfin:sdram
endchoice

menu "Memory Init Control"
	depends on BFIN_KERNEL_CLOCK_MEMINIT_SPEC

config MEM_DDRCTL0
	depends on BF54x
	hex "DDRCTL0"
	default 0x0

config MEM_DDRCTL1
	depends on BF54x
	hex "DDRCTL1"
	default 0x0

config MEM_DDRCTL2
	depends on BF54x
	hex "DDRCTL2"
	default 0x0

config MEM_EBIU_DDRQUE
	depends on BF54x
	hex "DDRQUE"
	default 0x0

config MEM_SDRRC
	depends on !BF54x
	hex "SDRRC"
	default 0x0

config MEM_SDGCTL
	depends on !BF54x
	hex "SDGCTL"
	default 0x0
endmenu

#
# Max & Min Speeds for various Chips
#
config MAX_VCO_HZ
	int
	default 400000000 if BF512
	default 400000000 if BF514
	default 400000000 if BF516
	default 400000000 if BF518
	default 400000000 if BF522
	default 600000000 if BF523
	default 400000000 if BF524
	default 600000000 if BF525
	default 400000000 if BF526
	default 600000000 if BF527
	default 400000000 if BF531
	default 400000000 if BF532
	default 750000000 if BF533
	default 500000000 if BF534
	default 400000000 if BF536
	default 600000000 if BF537
	default 533333333 if BF538
	default 533333333 if BF539
	default 600000000 if BF542
	default 533333333 if BF544
	default 600000000 if BF547
	default 600000000 if BF548
	default 533333333 if BF549
	default 600000000 if BF561
	default 800000000 if BF609

config MIN_VCO_HZ
	int
	default 50000000

config MAX_SCLK_HZ
	int
	default 200000000 if BF609
	default 133333333

config MIN_SCLK_HZ
	int
	default 27000000

comment "Kernel Timer/Scheduler"

source kernel/Kconfig.hz

config SET_GENERIC_CLOCKEVENTS
	bool "Generic clock events"
	default y
	select GENERIC_CLOCKEVENTS

menu "Clock event device"
	depends on GENERIC_CLOCKEVENTS
config TICKSOURCE_GPTMR0
	bool "GPTimer0"
	depends on !SMP
	select BFIN_GPTIMERS

config TICKSOURCE_CORETMR
	bool "Core timer"
	default y
endmenu

menu "Clock source"
	depends on GENERIC_CLOCKEVENTS
config CYCLES_CLOCKSOURCE
	bool "CYCLES"
	default y
	depends on !BFIN_SCRATCH_REG_CYCLES
	depends on !SMP
	help
	  If you say Y here, you will enable support for using the 'cycles'
	  registers as a clock source.  Doing so means you will be unable to
	  safely write to the 'cycles' register during runtime.  You will
	  still be able to read it (such as for performance monitoring), but
	  writing the registers will most likely crash the kernel.

config GPTMR0_CLOCKSOURCE
	bool "GPTimer0"
	select BFIN_GPTIMERS
	depends on !TICKSOURCE_GPTMR0
endmenu

comment "Misc"

choice
	prompt "Blackfin Exception Scratch Register"
	default BFIN_SCRATCH_REG_RETN
	help
	  Select the resource to reserve for the Exception handler:
	    - RETN: Non-Maskable Interrupt (NMI)
	    - RETE: Exception Return (JTAG/ICE)
	    - CYCLES: Performance counter

	  If you are unsure, please select "RETN".

config BFIN_SCRATCH_REG_RETN
	bool "RETN"
	help
	  Use the RETN register in the Blackfin exception handler
	  as a stack scratch register.  This means you cannot
	  safely use NMI on the Blackfin while running Linux, but
	  you can debug the system with a JTAG ICE and use the
	  CYCLES performance registers.

	  If you are unsure, please select "RETN".

config BFIN_SCRATCH_REG_RETE
	bool "RETE"
	help
	  Use the RETE register in the Blackfin exception handler
	  as a stack scratch register.  This means you cannot
	  safely use a JTAG ICE while debugging a Blackfin board,
	  but you can safely use the CYCLES performance registers
	  and the NMI.

	  If you are unsure, please select "RETN".

config BFIN_SCRATCH_REG_CYCLES
	bool "CYCLES"
	help
	  Use the CYCLES register in the Blackfin exception handler
	  as a stack scratch register.  This means you cannot
	  safely use the CYCLES performance registers on a Blackfin
	  board at anytime, but you can debug the system with a JTAG
	  ICE and use the NMI.

	  If you are unsure, please select "RETN".

endchoice

endmenu


menu "Blackfin Kernel Optimizations"

comment "Memory Optimizations"

config I_ENTRY_L1
	bool "Locate interrupt entry code in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, interrupt entry code (STORE/RESTORE CONTEXT) is linked
	  into L1 instruction memory. (less latency)

config EXCPT_IRQ_SYSC_L1
	bool "Locate entire ASM lowlevel exception / interrupt - Syscall and CPLB handler code in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the entire ASM lowlevel exception and interrupt entry code
	  (STORE/RESTORE CONTEXT) is linked into L1 instruction memory.
	  (less latency)

config DO_IRQ_L1
	bool "Locate frequently called do_irq dispatcher function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the frequently called do_irq dispatcher function is linked
	  into L1 instruction memory. (less latency)

config CORE_TIMER_IRQ_L1
	bool "Locate frequently called timer_interrupt() function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the frequently called timer_interrupt() function is linked
	  into L1 instruction memory. (less latency)

config IDLE_L1
	bool "Locate frequently idle function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the frequently called idle function is linked
	  into L1 instruction memory. (less latency)

config SCHEDULE_L1
	bool "Locate kernel schedule function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the frequently called kernel schedule is linked
	  into L1 instruction memory. (less latency)

config ARITHMETIC_OPS_L1
	bool "Locate kernel owned arithmetic functions in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, arithmetic functions are linked
	  into L1 instruction memory. (less latency)

config ACCESS_OK_L1
	bool "Locate access_ok function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the access_ok function is linked
	  into L1 instruction memory. (less latency)

config MEMSET_L1
	bool "Locate memset function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the memset function is linked
	  into L1 instruction memory. (less latency)

config MEMCPY_L1
	bool "Locate memcpy function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the memcpy function is linked
	  into L1 instruction memory. (less latency)

config STRCMP_L1
	bool "locate strcmp function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the strcmp function is linked
	  into L1 instruction memory (less latency).

config STRNCMP_L1
	bool "locate strncmp function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the strncmp function is linked
	  into L1 instruction memory (less latency).

config STRCPY_L1
	bool "locate strcpy function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the strcpy function is linked
	  into L1 instruction memory (less latency).

config STRNCPY_L1
	bool "locate strncpy function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, the strncpy function is linked
	  into L1 instruction memory (less latency).

config SYS_BFIN_SPINLOCK_L1
	bool "Locate sys_bfin_spinlock function in L1 Memory"
	default y
	depends on !SMP
	help
	  If enabled, sys_bfin_spinlock function is linked
	  into L1 instruction memory. (less latency)

config CACHELINE_ALIGNED_L1
	bool "Locate cacheline_aligned data to L1 Data Memory"
	default y if !BF54x
	default n if BF54x
	depends on !SMP && !BF531 && !CRC32
	help
	  If enabled, cacheline_aligned data is linked
	  into L1 data memory. (less latency)

config SYSCALL_TAB_L1
	bool "Locate Syscall Table L1 Data Memory"
	default n
	depends on !SMP && !BF531
	help
	  If enabled, the Syscall LUT is linked
	  into L1 data memory. (less latency)

config CPLB_SWITCH_TAB_L1
	bool "Locate CPLB Switch Tables L1 Data Memory"
	default n
	depends on !SMP && !BF531
	help
	  If enabled, the CPLB Switch Tables are linked
	  into L1 data memory. (less latency)

config ICACHE_FLUSH_L1
	bool "Locate icache flush funcs in L1 Inst Memory"
	default y
	help
	  If enabled, the Blackfin icache flushing functions are linked
	  into L1 instruction memory.

	  Note that this might be required to address anomalies, but
	  these functions are pretty small, so it shouldn't be too bad.
	  If you are using a processor affected by an anomaly, the build
	  system will double check for you and prevent it.

config DCACHE_FLUSH_L1
	bool "Locate dcache flush funcs in L1 Inst Memory"
	default y
	depends on !SMP
	help
	  If enabled, the Blackfin dcache flushing functions are linked
	  into L1 instruction memory.

config APP_STACK_L1
	bool "Support locating application stack in L1 Scratch Memory"
	default y
	depends on !SMP
	help
	  If enabled the application stack can be located in L1
	  scratch memory (less latency).

	  Currently only works with FLAT binaries.

config EXCEPTION_L1_SCRATCH
	bool "Locate exception stack in L1 Scratch Memory"
	default n
	depends on !SMP && !APP_STACK_L1
	help
	  Whenever an exception occurs, use the L1 Scratch memory for
	  stack storage.  You cannot place the stacks of FLAT binaries
	  in L1 when using this option.

	  If you don't use L1 Scratch, then you should say Y here.

comment "Speed Optimizations"
config BFIN_INS_LOWOVERHEAD
	bool "ins[bwl] low overhead, higher interrupt latency"
	default y
	depends on !SMP
	help
	  Reads on the Blackfin are speculative. In Blackfin terms, this means
	  they can be interrupted at any time (even after they have been issued
	  on to the external bus), and re-issued after the interrupt occurs.
	  For memory - this is not a big deal, since memory does not change if
	  it sees a read.

	  If a FIFO is sitting on the end of the read, it will see two reads,
	  when the core only sees one since the FIFO receives both the read
	  which is cancelled (and not delivered to the core) and the one which
	  is re-issued (which is delivered to the core).

	  To solve this, interrupts are turned off before reads occur to
	  I/O space. This option controls which the overhead/latency of
	  controlling interrupts during this time
	   "n" turns interrupts off every read
		(higher overhead, but lower interrupt latency)
	   "y" turns interrupts off every loop
		(low overhead, but longer interrupt latency)

	  default behavior is to leave this set to on (type "Y"). If you are experiencing
	  interrupt latency issues, it is safe and OK to turn this off.

endmenu

choice
	prompt "Kernel executes from"
	help
	  Choose the memory type that the kernel will be running in.

config RAMKERNEL
	bool "RAM"
	help
	  The kernel will be resident in RAM when running.

config ROMKERNEL
	bool "ROM"
	help
	  The kernel will be resident in FLASH/ROM when running.

endchoice

# Common code uses "ROMKERNEL" or "XIP_KERNEL", so define both
config XIP_KERNEL
	bool
	default y
	depends on ROMKERNEL

source "mm/Kconfig"

config BFIN_GPTIMERS
	tristate "Enable Blackfin General Purpose Timers API"
	default n
	help
	  Enable support for the General Purpose Timers API.  If you
	  are unsure, say N.

	  To compile this driver as a module, choose M here: the module
	  will be called gptimers.

choice
	prompt "Uncached DMA region"
	default DMA_UNCACHED_1M
config DMA_UNCACHED_32M
	bool "Enable 32M DMA region"
config DMA_UNCACHED_16M
	bool "Enable 16M DMA region"
config DMA_UNCACHED_8M
	bool "Enable 8M DMA region"
config DMA_UNCACHED_4M
	bool "Enable 4M DMA region"
config DMA_UNCACHED_2M
	bool "Enable 2M DMA region"
config DMA_UNCACHED_1M
	bool "Enable 1M DMA region"
config DMA_UNCACHED_512K
	bool "Enable 512K DMA region"
config DMA_UNCACHED_256K
	bool "Enable 256K DMA region"
config DMA_UNCACHED_128K
	bool "Enable 128K DMA region"
config DMA_UNCACHED_NONE
	bool "Disable DMA region"
endchoice


comment "Cache Support"

config BFIN_ICACHE
	bool "Enable ICACHE"
	default y
config BFIN_EXTMEM_ICACHEABLE
	bool "Enable ICACHE for external memory"
	depends on BFIN_ICACHE
	default y
config BFIN_L2_ICACHEABLE
	bool "Enable ICACHE for L2 SRAM"
	depends on BFIN_ICACHE
	depends on (BF54x || BF561 || BF60x) && !SMP
	default n

config BFIN_DCACHE
	bool "Enable DCACHE"
	default y
config BFIN_DCACHE_BANKA
	bool "Enable only 16k BankA DCACHE - BankB is SRAM"
	depends on BFIN_DCACHE && !BF531
	default n
config BFIN_EXTMEM_DCACHEABLE
	bool "Enable DCACHE for external memory"
	depends on BFIN_DCACHE
	default y
choice
	prompt "External memory DCACHE policy"
	depends on BFIN_EXTMEM_DCACHEABLE
	default BFIN_EXTMEM_WRITEBACK if !SMP
	default BFIN_EXTMEM_WRITETHROUGH if SMP
config BFIN_EXTMEM_WRITEBACK
	bool "Write back"
	depends on !SMP
	help
	  Write Back Policy:
	    Cached data will be written back to SDRAM only when needed.
	    This can give a nice increase in performance, but beware of
	    broken drivers that do not properly invalidate/flush their
	    cache.

	  Write Through Policy:
	    Cached data will always be written back to SDRAM when the
	    cache is updated.  This is a completely safe setting, but
	    performance is worse than Write Back.

	  If you are unsure of the options and you want to be safe,
	  then go with Write Through.

config BFIN_EXTMEM_WRITETHROUGH
	bool "Write through"
	help
	  Write Back Policy:
	    Cached data will be written back to SDRAM only when needed.
	    This can give a nice increase in performance, but beware of
	    broken drivers that do not properly invalidate/flush their
	    cache.

	  Write Through Policy:
	    Cached data will always be written back to SDRAM when the
	    cache is updated.  This is a completely safe setting, but
	    performance is worse than Write Back.

	  If you are unsure of the options and you want to be safe,
	  then go with Write Through.

endchoice

config BFIN_L2_DCACHEABLE
	bool "Enable DCACHE for L2 SRAM"
	depends on BFIN_DCACHE
	depends on (BF54x || BF561 || BF60x) && !SMP
	default n
choice
	prompt "L2 SRAM DCACHE policy"
	depends on BFIN_L2_DCACHEABLE
	default BFIN_L2_WRITEBACK
config BFIN_L2_WRITEBACK
	bool "Write back"

config BFIN_L2_WRITETHROUGH
	bool "Write through"
endchoice


comment "Memory Protection Unit"
config MPU
	bool "Enable the memory protection unit"
	default n
	help
	  Use the processor's MPU to protect applications from accessing
	  memory they do not own.  This comes at a performance penalty
	  and is recommended only for debugging.

comment "Asynchronous Memory Configuration"

menu "EBIU_AMGCTL Global Control"
	depends on !BF60x
config C_AMCKEN
	bool "Enable CLKOUT"
	default y

config C_CDPRIO
	bool "DMA has priority over core for ext. accesses"
	default n

config C_B0PEN
	depends on BF561
	bool "Bank 0 16 bit packing enable"
	default y

config C_B1PEN
	depends on BF561
	bool "Bank 1 16 bit packing enable"
	default y

config C_B2PEN
	depends on BF561
	bool "Bank 2 16 bit packing enable"
	default y

config C_B3PEN
	depends on BF561
	bool "Bank 3 16 bit packing enable"
	default n

choice
	prompt "Enable Asynchronous Memory Banks"
	default C_AMBEN_ALL

config C_AMBEN
	bool "Disable All Banks"

config C_AMBEN_B0
	bool "Enable Bank 0"

config C_AMBEN_B0_B1
	bool "Enable Bank 0 & 1"

config C_AMBEN_B0_B1_B2
	bool "Enable Bank 0 & 1 & 2"

config C_AMBEN_ALL
	bool "Enable All Banks"
endchoice
endmenu

menu "EBIU_AMBCTL Control"
	depends on !BF60x
config BANK_0
	hex "Bank 0 (AMBCTL0.L)"
	default 0x7BB0
	help
	  These are the low 16 bits of the EBIU_AMBCTL0 MMR which are
	  used to control the Asynchronous Memory Bank 0 settings.

config BANK_1
	hex "Bank 1 (AMBCTL0.H)"
	default 0x7BB0
	default 0x5558 if BF54x
	help
	  These are the high 16 bits of the EBIU_AMBCTL0 MMR which are
	  used to control the Asynchronous Memory Bank 1 settings.

config BANK_2
	hex "Bank 2 (AMBCTL1.L)"
	default 0x7BB0
	help
	  These are the low 16 bits of the EBIU_AMBCTL1 MMR which are
	  used to control the Asynchronous Memory Bank 2 settings.

config BANK_3
	hex "Bank 3 (AMBCTL1.H)"
	default 0x99B3
	help
	  These are the high 16 bits of the EBIU_AMBCTL1 MMR which are
	  used to control the Asynchronous Memory Bank 3 settings.

endmenu

config EBIU_MBSCTLVAL
	hex "EBIU Bank Select Control Register"
	depends on BF54x
	default 0

config EBIU_MODEVAL
	hex "Flash Memory Mode Control Register"
	depends on BF54x
	default 1

config EBIU_FCTLVAL
	hex "Flash Memory Bank Control Register"
	depends on BF54x
	default 6
endmenu

#############################################################################
menu "Bus options (PCI, PCMCIA, EISA, MCA, ISA)"

config PCI
	bool "PCI support"
	depends on BROKEN
	help
	  Support for PCI bus.

source "drivers/pci/Kconfig"

source "drivers/pcmcia/Kconfig"

endmenu

menu "Executable file formats"

source "fs/Kconfig.binfmt"

endmenu

menu "Power management options"

source "kernel/power/Kconfig"

config ARCH_SUSPEND_POSSIBLE
	def_bool y

choice
	prompt "Standby Power Saving Mode"
	depends on PM && !BF60x
	default PM_BFIN_SLEEP_DEEPER
config  PM_BFIN_SLEEP_DEEPER
	bool "Sleep Deeper"
	help
	  Sleep "Deeper" Mode (High Power Savings) - This mode reduces dynamic
	  power dissipation by disabling the clock to the processor core (CCLK).
	  Furthermore, Standby sets the internal power supply voltage (VDDINT)
	  to 0.85 V to provide the greatest power savings, while preserving the
	  processor state.
	  The PLL and system clock (SCLK) continue to operate at a very low
	  frequency of about 3.3 MHz. To preserve data integrity in the SDRAM,
	  the SDRAM is put into Self Refresh Mode. Typically an external event
	  such as GPIO interrupt or RTC activity wakes up the processor.
	  Various Peripherals such as UART, SPORT, PPI may not function as
	  normal during Sleep Deeper, due to the reduced SCLK frequency.
	  When in the sleep mode, system DMA access to L1 memory is not supported.

	  If unsure, select "Sleep Deeper".

config  PM_BFIN_SLEEP
	bool "Sleep"
	help
	  Sleep Mode (High Power Savings) - The sleep mode reduces power
	  dissipation by disabling the clock to the processor core (CCLK).
	  The PLL and system clock (SCLK), however, continue to operate in
	  this mode. Typically an external event or RTC activity will wake
	  up the processor. When in the sleep mode, system DMA access to L1
	  memory is not supported.

	  If unsure, select "Sleep Deeper".
endchoice

comment "Possible Suspend Mem / Hibernate Wake-Up Sources"
	depends on PM

config PM_BFIN_WAKE_PH6
	bool "Allow Wake-Up from on-chip PHY or PH6 GP"
	depends on PM && (BF51x || BF52x || BF534 || BF536 || BF537)
	default n
	help
	  Enable PHY and PH6 GP Wake-Up (Voltage Regulator Power-Up)

config PM_BFIN_WAKE_GP
	bool "Allow Wake-Up from GPIOs"
	depends on PM && BF54x
	default n
	help
	  Enable General-Purpose Wake-Up (Voltage Regulator Power-Up)
	  (all processors, except ADSP-BF549). This option sets
	  the general-purpose wake-up enable (GPWE) control bit to enable
	  wake-up upon detection of an active low signal on the /GPW (PH7) pin.
	  On ADSP-BF549 this option enables the same functionality on the
	  /MRXON pin also PH7.

config PM_BFIN_WAKE_PA15
	bool "Allow Wake-Up from PA15"
	depends on PM && BF60x
	default n
	help
	  Enable PA15 Wake-Up

config PM_BFIN_WAKE_PA15_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PA15
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_PB15
	bool "Allow Wake-Up from PB15"
	depends on PM && BF60x
	default n
	help
	  Enable PB15 Wake-Up

config PM_BFIN_WAKE_PB15_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PB15
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_PC15
	bool "Allow Wake-Up from PC15"
	depends on PM && BF60x
	default n
	help
	  Enable PC15 Wake-Up

config PM_BFIN_WAKE_PC15_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PC15
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_PD06
	bool "Allow Wake-Up from PD06(ETH0_PHYINT)"
	depends on PM && BF60x
	default n
	help
	  Enable PD06(ETH0_PHYINT) Wake-up

config PM_BFIN_WAKE_PD06_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PD06
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_PE12
	bool "Allow Wake-Up from PE12(ETH1_PHYINT, PUSH BUTTON)"
	depends on PM && BF60x
	default n
	help
	  Enable PE12(ETH1_PHYINT, PUSH BUTTON) Wake-up

config PM_BFIN_WAKE_PE12_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PE12
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_PG04
	bool "Allow Wake-Up from PG04(CAN0_RX)"
	depends on PM && BF60x
	default n
	help
	  Enable PG04(CAN0_RX) Wake-up

config PM_BFIN_WAKE_PG04_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PG04
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_PG13
	bool "Allow Wake-Up from PG13"
	depends on PM && BF60x
	default n
	help
	  Enable PG13 Wake-Up

config PM_BFIN_WAKE_PG13_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_PG13
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

config PM_BFIN_WAKE_USB
	bool "Allow Wake-Up from (USB)"
	depends on PM && BF60x
	default n
	help
	  Enable (USB) Wake-up

config PM_BFIN_WAKE_USB_POL
	int "Wake-up priority"
	depends on PM_BFIN_WAKE_USB
	default 0
	help
	  Wake-Up priority 0(low) 1(high)

endmenu

menu "CPU Frequency scaling"

source "drivers/cpufreq/Kconfig"

config BFIN_CPU_FREQ
	bool
	depends on CPU_FREQ
	default y

config CPU_VOLTAGE
	bool "CPU Voltage scaling"
	depends on CPU_FREQ
	default n
	help
	  Say Y here if you want CPU voltage scaling according to the CPU frequency.
	  This option violates the PLL BYPASS recommendation in the Blackfin Processor
	  manuals. There is a theoretical risk that during VDDINT transitions
	  the PLL may unlock.

endmenu

source "net/Kconfig"

source "drivers/Kconfig"

source "drivers/firmware/Kconfig"

source "fs/Kconfig"

source "arch/blackfin/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #
# arch/blackfin/mach-common/Makefile
#

obj-y := \
	cache.o cache-c.o entry.o head.o \
	interrupt.o arch_checks.o ints-priority.o

obj-$(CONFIG_PM)          += pm.o
ifneq ($(CONFIG_BF60x),y)
obj-$(CONFIG_PM)	  += dpmc_modes.o
endif
obj-$(CONFIG_SCB_PRIORITY)	+= scb-init.o
obj-$(CONFIG_CPU_VOLTAGE) += dpmc.o
obj-$(CONFIG_SMP)         += smp.o
obj-$(CONFIG_BFIN_KERNEL_CLOCK) += clocks-init.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cmd_scripts/kconfig/zconf.tab.o := gcc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89   -DCURSES_LOC="<curses.h>" -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c

source_scripts/kconfig/zconf.tab.o := scripts/kconfig/zconf.tab.c

deps_scripts/kconfig/zconf.tab.o := \
  /usr/include/stdc-predef.h \
  /usr/include/ctype.h \
  /usr/include/features.h \
  /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
  /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h \
  /usr/include/arm-linux-gnueabihf/bits/types.h \
  /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
  /usr/include/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap-16.h \
  /usr/include/xlocale.h \
  /usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h \
  /usr/include/stdio.h \
  /usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h \
  /usr/include/libio.h \
  /usr/include/_G_config.h \
  /usr/include/wchar.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/sys_errlist.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio.h \
  /usr/include/stdlib.h \
  /usr/include/arm-linux-gnueabihf/bits/waitflags.h \
  /usr/include/arm-linux-gnueabihf/bits/waitstatus.h \
  /usr/include/arm-linux-gnueabihf/sys/types.h \
  /usr/include/time.h \
  /usr/include/arm-linux-gnueabihf/sys/select.h \
  /usr/include/arm-linux-gnueabihf/bits/select.h \
  /usr/include/arm-linux-gnueabihf/bits/sigset.h \
  /usr/include/arm-linux-gnueabihf/bits/time.h \
  /usr/include/arm-linux-gnueabihf/sys/sysmacros.h \
  /usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h \
  /usr/include/alloca.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-bsearch.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-float.h \
  /usr/include/string.h \
  /usr/include/arm-linux-gnueabihf/bits/string.h \
  /usr/include/arm-linux-gnueabihf/bits/string2.h \
  /usr/lib/gcc/arm-linux-gnueabihf/6/include/stdbool.h \
  scripts/kconfig/lkc.h \
    $(wildcard include/config/prefix.h) \
    $(wildcard include/config/list.h) \
    $(wildcard include/config/y.h) \
  scripts/kconfig/expr.h \
    $(wildcard include/config/config.h) \
  /usr/include/assert.h \
  scripts/kconfig/list.h \
  /usr/include/libintl.h \
  /usr/include/locale.h \
  /usr/include/arm-linux-gnueabihf/bits/locale.h \
  scripts/kconfig/lkc_proto.h \
  scripts/kconfig/zconf.hash.c \
  scripts/kconfig/zconf.lex.c \
  /usr/include/errno.h \
  /usr/include/arm-linux-gnueabihf/bits/errno.h \
  /usr/include/linux/errno.h \
  /usr/include/arm-linux-gnueabihf/asm/errno.h \
  /usr/include/asm-generic/errno.h \
  /usr/include/asm-generic/errno-base.h \
  /usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h \
  /usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/syslimits.h \
  /usr/include/limits.h \
  /usr/include/arm-linux-gnueabihf/bits/posix1_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/local_lim.h \
  /usr/include/linux/limits.h \
  /usr/include/arm-linux-gnueabihf/bits/posix2_lim.h \
  /usr/include/unistd.h \
  /usr/include/arm-linux-gnueabihf/bits/posix_opt.h \
  /usr/include/arm-linux-gnueabihf/bits/environments.h \
  /usr/include/arm-linux-gnueabihf/bits/confname.h \
  /usr/include/getopt.h \
  scripts/kconfig/util.c \
  scripts/kconfig/confdata.c \
    $(wildcard include/config/autoconfig.h) \
    $(wildcard include/config/overwriteconfig.h) \
    $(wildcard include/config/autoheader.h) \
    $(wildcard include/config/tristate.h) \
    $(wildcard include/config/probability.h) \
  /usr/include/arm-linux-gnueabihf/sys/stat.h \
  /usr/include/arm-linux-gnueabihf/bits/stat.h \
  /usr/include/fcntl.h \
  /usr/include/arm-linux-gnueabihf/bits/fcntl.h \
  /usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h \
  scripts/kconfig/expr.c \
  scripts/kconfig/symbol.c \
  /usr/include/regex.h \
  /usr/include/arm-linux-gnueabihf/sys/utsname.h \
  /usr/include/arm-linux-gnueabihf/bits/utsname.h \
  scripts/kconfig/menu.c \

scripts/kconfig/zconf.tab.o: $(deps_scripts/kconfig/zconf.tab.o)

$(deps_scripts/kconfig/zconf.tab.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ELF          (    Ä	 4   È/    4   	 (     pL  L L                4   4  4                 T  T T                          X  X               p  ˜               è   è            p  p p D   D         Qåtd                          Råtd    ô   ô         /lib/ld-linux-armhf.so.3             GNU                        GNU !D†OÌöEú<k_üJxFçÛš             Ba$â €À"£ €­h !      €                                                      w×›|†ð–|}í?~–|VÛ“±°¨”.N=öp±š|?ùÿ¼žûn$u‚9ò‹½‹¨¯»“–©ºÚfII"“²¤{œ|gUau‚[š;ÿì„¸+k@M|=­9êvþ)Œ                Õ                             Ð              %                            C              ª              ¾              1              ¢              6              O              y   €       ‡              <                            k              €                             +   ˆ       ]              —                            £              J              d                            V   Œ        libc.so.6 exit _IO_putc perror puts abort stdin mmap fgets strlen strstr read memcmp stdout memcpy malloc __ctype_b_loc stderr munmap __fxstat fwrite close open fprintf __ctype_tolower_loc __libc_start_main free __gmon_start__ GLIBC_2.4                                            ii   ä       p    €    ˆ    Œ                             $    (    ,    0    4    8    <    @    D    H    L    P    T    X    \  	  `  
  d    h    l    @-éØ  ë€½èà-åàŸåààð¾åP  ÆâÊŒâPù¼å ÆâÊŒâHù¼å ÆâÊŒâ@ù¼å ÆâÊŒâ8ù¼å ÆâÊŒâ0ù¼å ÆâÊŒâ(ù¼å ÆâÊŒâ ù¼å ÆâÊŒâù¼å ÆâÊŒâù¼å ÆâÊŒâù¼å ÆâÊŒâ ù¼å ÆâÊŒâøø¼å ÆâÊŒâðø¼å ÆâÊŒâèø¼å ÆâÊŒâàø¼å ÆâÊŒâØø¼å ÆâÊŒâÐø¼å ÆâÊŒâÈø¼å ÆâÊŒâÀø¼å ÆâÊŒâ¸ø¼å ÆâÊŒâ°ø¼å ÆâÊŒâ¨ø¼å ÆâÊŒâ ø¼å ÆâÊŒâ˜ø¼å ÆâÊŒâø¼å Pã0@-édÐMâ7  
 Pã<  ”AŸå0‘åÀ‘å ‘åˆáŸåˆQŸå á  á  „å|Ÿå À…å 0Žå¤ÿÿë  ”å  ãÎÿÿë PPâD  º â á  ã¿ÿÿë  PãH  º4å  Qã  
   ã På å0 ã  ãÉÿÿë pã @ á%  
4åÂ  ë  á4åÇÿÿë  áËÿÿë   ãdÐâ0€½èì0Ÿå  ”åèŸå  “åºÿÿë  áÁÿÿëôÿÿê0‘å  Óå- Rã   Óåe Rã  
°@Ÿå0  ã ã 0”å¨ Ÿå†ÿÿë 0”å.  ã ã˜ Ÿåÿÿë  ãšÿÿëŒ Ÿåwÿÿë  á¨ÿÿëÛÿÿê0Óå  Sãêÿÿp0Ÿå  ãâ  ƒå¨ÿÿêH0Ÿå\ Ÿå  ã 0“å ãlÿÿë  ”ådÿÿë  ãƒÿÿë 0Ÿå!  ã ã 0“å, Ÿåôÿÿê”$  $ ˜$ Ð €  $ l   < œ$ à    ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0ŸåTÿÿëtÿÿë” à 4 0Ÿå Ÿå0à “ç  Rãÿ/Rÿÿêð p   0Ÿå Ÿå 0Cà Sãÿ/‘0Ÿå  Sãÿ/ÿ/á  |      $Ÿå$ Ÿå AàA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/á|  |      @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½è  ( Ÿå 0å  Sã   âÿÿê0Ÿå  Sãûÿÿ
@-é3ÿ/á@½èÛÿÿê     p@-éP á ` á&ÿÿë @ á  á#ÿÿë  Tá  º   á  Dà  †à áp@½èôþÿê  ãp€½èðA-é` á @ áL ŸåÞþÿë  Vã  Ú@pŸå`„à/€ ãPÔä_ Uã    
ûþÿë 0å“ç —ååþÿë Táôÿÿ ŸåðA½èæþÿê¤ Œ  Ä ðO-é@€àAÝMâ Pá,ÐMâ¢  * p ã  Tá  á€ á  š  Ñå  Rã\ R0  0 
 Rã0ƒ  SãÀ	  {  ê Üä\ Rã  R0  0 
 Rã0ƒ  Sãr  
 \á áóÿÿP á0Uå: Sã}  
Eàh`â	  á  á©þÿë 0 ã  átŸå	0Æç£ÿÿë  Pã6  
dŸå  ážÿÿë  Pã1  
TŸå  á™ÿÿë  Pã,  
DŸå  á”ÿÿë  Pã'  
4Ÿå  áÿÿë  Pã"  
  Wãm  
  Xão  
  ã  á¨þÿë pPâö  º â á  ã™þÿë  Pãæ  º,å  YãZ  
 ‰âŒþÿë °PâT  
	  á á  ákþÿë, å Pá 0 ág  
¬Ÿåtþÿë  á¥þÿë p ã…â TážÿÿŠ  Xã:  
ˆ3Ÿå 0“å  Sã  
|SŸåP@ ã  ê â‡þÿë PãJ  Ú@âh0â0ƒàX0Så
 SãD   âcÿÿë  •å á âLþÿë  Pãíÿÿ,CŸå,Ÿå  ”å á<þÿë ”åŸå9þÿëAÝâ,Ðâð½èÀâ	  ê Üä  Rã\ R0  0 
 Rã 0 0  Sã„ÿÿ
 TáP áòÿÿŠ0Uå: Sãÿÿ…â Táp ãbÿÿŠÂÿÿê°2Ÿå&  ã ã 0“å¤Ÿå1þÿë  ãJþÿë˜Ÿå'þÿë  áXþÿë±ÿÿê á„Ÿåþÿëÿÿê`‚Ÿå  átŸå ˜å	þÿë ˜åhŸå€ áþÿë…ÿÿêD2Ÿå  ã ã 0“åLŸåþÿë  ã/þÿë   ã  á Ëç=þÿë°å@åPå å Ÿåïýÿë pPâQ  
 ×å‡â  ZãR  
þÿë	` á  å  ê öå  Zã  
Š0 á³0’á£1 á_ Zã0ƒ ãõÿÿ Fâ
  á  ãÀŸåèýÿë  Pã`  `å
` á YáÜÿÿ*	`Fà†â‡à”AŸåp‡â  ê0÷å@$à„1Ÿå“à Qáùÿÿx1ŸåtPïæ¡“ç  Zã  

p á  ê p—å  Wã  
0—å Táùÿÿ0—å Váöÿÿ  á	 á ‡âÁýÿë  Pãðÿÿ¹ÿÿê †âËýÿë pPâ  
	 á  á ‡â³ýÿëü0Ÿå`‡å@‡å  ‡å á	  áqƒç»þÿë¨ÿÿê  á@åPå ýÿë9ÿÿê  ã´Ÿå¥ýÿë  Pãÿÿ	` á  á¹ÿÿê¤ Ÿå ýÿë  ã¿ýÿëd0Ÿå” Ÿå%  ã 0“å ãžýÿë  á–ýÿë  ãµýÿë<0Ÿå#  ã ã 0“åd Ÿåôÿÿêô  4 T l ü œ$ ˆ  ˜$ H \ €  Ì ì ˜ t ˆ , $  Å“ ”   Ä   ðG-é p áH`ŸåHPŸå`àPà`Fà€ á áMýÿëFa°áð‡½ @ ã@„â0•ä	  á á  á3ÿ/á Vá÷ÿÿð‡½èÄ ¼ ÿ/á@-é€½è      $(wildcard include/config/  .h) \   fixdep: parse error; no targets found
  include/generated/autoconf.h    include/generated/autoksyms.h   arch/um/include/uml-config.h    include/linux/kconfig.h .ver    source_%s := %s

   deps_%s := \
     %s \
 fixdep: error opening config file:  fixdep: error fstat'ing config file:    fixdep: malloc  fixdep: read    _MODULE fixdep:malloc   CONFIG_ fixdep: bad data on stdin
  
%s: $(deps_%s)

   $(deps_%s):
    Usage: fixdep [-e] <depfile> <target> <cmdline>
     -e  insert extra dependencies given on stdin
  cmd_%s := %s

  fixdep: error opening depfile:  fixdep: error fstat'ing depfile:    fixdep: %s is empty
    fixdep: mmap    xõÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ´
 Œ
              ”    ˜                     õþÿo´    d    ” 
   î                         È            Ì    ¬              þÿÿoŒ ÿÿÿo   ðÿÿoR                                                                                                                        GCC: (Raspbian 6.3.0-18+rpi1+deb9u1) 6.3.0 20170516 A.   aeabi $   6 	
"                     T           p                      ´           ”           d           R           Œ           ¬      	     Ì      
     ”                       à           ˜                       L           T                                                                    t            €                                                ñÿH   p        K   Ä	        H   L        H   ô	        H            H   t         N            ñÿK    
        •    
       H   
        K   ”        K   ˜        ¢            ñÿK   œ        K   œ        é            ñÿK   ì
        ò   ì
 D     ú   0 l     H           K   œ          œ ˜    H   Ì        K   à        H   ”	        H   ”           ”       H   ¤                   ñÿ)         K   $
        6  $
       H   H
        K   T
        8  T
       H   €
        H   x         K   Œ
        K  Œ
       H   °
        a         H           q         K   ´
        ˜  ´
       H   ä
        H           ¤         H            Ã           ñÿK   4        H   Œ        K   ”                   ñÿH   T        Ï  T       H           Ý                      ñÿé          ú                              K            H   °        K   ´        ,  ”      <               t         #             N  |        \             l             |                          ¹  ¤$       Ÿ  |        ¦             6  ˜       ¸  ¤$       Ä  ”$      Ì             Þ  €       ð                            t        #             3             E             b             v  ˜$      }             œ              «             »  x       È             á             ñ                                    "             5  ˆ       F  4 `     õ  ¤$         Ä	       V  ¤$       ^  Œ       p  |        |  œ$      Ž  à ä    “             ¥  |       ±   $      ¹             P  ”       Ê              /usr/lib/gcc/arm-linux-gnueabihf/6/../../../arm-linux-gnueabihf/crt1.o $d $a /usr/lib/gcc/arm-linux-gnueabihf/6/../../../arm-linux-gnueabihf/crti.o call_weak_fn /usr/lib/gcc/arm-linux-gnueabihf/6/../../../arm-linux-gnueabihf/crtn.o fixdep.c strrcmp print_config parse_dep_file hashtab crtstuff.c __JCR_LIST__ deregister_tm_clones __do_global_dtors_aux completed.10395 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry elf-init.oS __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini strstr@@GLIBC_2.4 __bss_start__ read@@GLIBC_2.4 free@@GLIBC_2.4 fgets@@GLIBC_2.4 memcpy@@GLIBC_2.4 _edata memcmp@@GLIBC_2.4 __bss_end__ depfile perror@@GLIBC_2.4 stderr@@GLIBC_2.4 _IO_putc@@GLIBC_2.4 fwrite@@GLIBC_2.4 __data_start puts@@GLIBC_2.4 malloc@@GLIBC_2.4 __libc_start_main@@GLIBC_2.4 __fxstat@@GLIBC_2.4 target __ctype_tolower_loc@@GLIBC_2.4 __gmon_start__ open@@GLIBC_2.4 __dso_handle __ctype_b_loc@@GLIBC_2.4 exit@@GLIBC_2.4 _IO_stdin_used strlen@@GLIBC_2.4 mmap@@GLIBC_2.4 fprintf@@GLIBC_2.4 stdin@@GLIBC_2.4 __libc_csu_init __end__ stdout@@GLIBC_2.4 __bss_start insert_extra_deps main munmap@@GLIBC_2.4 __TMC_END__ cmdline abort@@GLIBC_2.4 close@@GLIBC_2.4  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                                                     T T                    #         p p                     1            $                  D   öÿÿo   ´ ´  à                N         ” ”  Ð              V         d d  î                  ^   ÿÿÿo   R R  :                k   þÿÿo   Œ Œ                   z   	      ¬ ¬                   ƒ   	   B   Ì Ì  È               Œ         ” ”                    ‡              @                ’         à à  ¸	                 ˜         ˜ ˜                    ž              ¬                 ¦     p‚   L L                   ±         T T                    »                             Ç                             Ó                              Ø            è                á                t                 æ         t  t                     ì         €  |   $                 ñ      0       |   4                 ú     p        °   /                                à    	     ^         	              à)  Û                               ».  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ELF          (            HL     4     (   p@-é PRâ    áp@½è$Ÿåþÿÿê`Ñç@ á 0 ã0Áç  áŸåþÿÿë`Äçp€½è      á Ÿåþÿÿê     áà-å"Ä áÐMâ"8 áràïæ|ÀïæŸå Àås0ïæàå", áþÿÿëÐâðä    0@-é,ÐMâ(ÀâPâ é @ á å 0å å 0å è  áþÿÿë •è „è,Ðâ0€½è0@-é @ áÐMâPâ å  á ”èþÿÿë •è „èÐâ0€½è  Rãp@-é @ áÐMâ` á    áþÿÿë   áPâ å `å  á ”èþÿÿë •è 0 ã 0å „è  á ”èþÿÿë •è „èÐâp€½è0@-é @ áÐMâPâ å  á ”èþÿÿë •è „èÐâ0€½è0@-éÐMâPâÀ ã è @ á Àå  áþÿÿë •è „èÐâ0€½è0@-éÐMâPâÀ ã è @ á Àå  áþÿÿë •è „èÐâ0€½è0@-éÐMâPâÀ ã è @ á Àå  áþÿÿë •è „èÐâ0€½èð@-é @QâÐMâ P á  
„pŸå„`Ÿå  ê@”å  Tã  
 0Ôå  Sãùÿÿ ”å á  áþÿÿë ”å á  áþÿÿë@”å  Tãñÿÿ0 á  ã ã0 Ÿåþÿÿë 0 ã  ã å  á 0å  áŸåþÿÿëÐâð€½èp   |   \       ð@-é 0 áÐMâ P á@ á  ã ã€ Ÿåþÿÿë 0 ã  ã å  á 0å  ádŸåþÿÿë  Tã  
XpŸåX`Ÿå  ê@”å  Tã  
 0Ôå  Sãùÿÿ ”å á  áþÿÿë ”å á  áþÿÿë@”å  TãñÿÿÐâð€½è„       œ   ¬   ð@-é @QâÐMâ P á  
„pŸå„`Ÿå  ê@”å  Tã  
 0Ôå  Sãùÿÿ ”å á  áþÿÿë ”å á  áþÿÿë@”å  Tãñÿÿ0 á  ã ã0 Ÿåþÿÿë 0 ã  ã å  á 0å  áŸåþÿÿëÐâð€½èp   |   ¸       <@Ÿå -é  ãà-åÐMâÀâ 0”å ã  ŸåÀåþÿÿë  ”åå åþÿÿë  ãþÿÿë    Ð     å0å Àaâ0CàƒàAâà0å‚à Qá€å   Šÿ/á@-é  ŸåÜÿÿëà   ðO-éÐMâÀâ ` á Œè€ á@åpå  Tã  
ô ŸåôŸå  ê@”å  Tã  
 0”å SãùÿÿP”å°”å  á
 á  áþÿÿë0 á  á	 á  áþÿÿë@”å  Tãîÿÿ Xã0 ‘ @ “
  šPGâ @ ã0µå@„â3¿æ  á0å¯þÿë0Hà SãöÿÿŠ  Sã  
\Ÿåp‡àPHàPEâ ×ä	 á  áþÿÿë  UãøÿÿÊ@„â0Hà  Sã@„  Xá  Ðâð½è0Ÿå¿  ãŸå Ÿåþÿÿëp            0  H  ðA-é € á `åÐMâ  VãP á  Úpå @ ã  ê@„â Tá  
‡à  áþÿÿë  Pã÷ÿÿ  áÐâð½è @ ã  áþÿÿë`â På ˜è €â å  áþÿÿë –è ˆè  áÐâð½èðO-é,ÐMâp áTPå   á€ á8Õå0åP°å  QãåŽ  
  Uá  
  á0—å  ã3ÿ/á0—å•å  á   ã3ÿ/á0—å ã  á3ÿ/á4@šå  Tã O  @•å  Tã  
`å  ê@”å  Tã  
 0Ôå  Sãùÿÿ@å °å0 á  á á
  áÎÿÿë@”å  Tãòÿÿ80Õå
 Uá P P  Uãc  
0—å,šå  á,ÐâðO½èÿ/á  Yãa á  Vã  á  “ ƒ“å å 0 ã$0å å  åÿÿë”å —å‘å å  á2ÿ/á á  —å  á2ÿ/á0å  á á 0—å3ÿ/á0›å£	à ãC  0â  á “è`—å6ÿ/á  á0—å ã3ÿ/á
  áþÿÿë@”å  Tã0  
0”å UáùÿÿÔå  Yãöÿÿ0å4`“å  Vã0  
0”å  á	  á’å Qá Â ’å €  Rã÷ÿÿ  á0åþÿÿë0å  Pâ&  
 å  ã  ê`–å  Vã¯ÿÿ
 –å Ráùÿÿ  –å  ã Æå0/¿æ!Šçåâñÿÿê@•å  Tãƒÿÿ,Ðâð½è@•å å  Tã}ÿÿŽÿÿê0—å ã  á3ÿ/á¶ÿÿê   ãþÿÿë  Pâ0”   	` •ÿÿ  ŸåµþÿëX  ðO-é$ÐMâ áHå€ á @ á åP áå ™å,å  á0å2ÿ/á0•å  á â    0™å‘‘3ÿ/á0™å ã  á3ÿ/á0å@“å  Tãx 
vŸå P ã` ã  ã 0Ôå  Sã%  °”å á  áþÿÿë á  Pã åP ÷þÿë ™å”å ° á  á2ÿ/á  ™å”å  á2ÿ/á 0™å á  á3ÿ/á0å0“å ã  
0”å Sã0 Ê0„â  á “èÀ™å<ÿ/á0™å á  á3ÿ/á@”å  TãÓÿÿ0å0“å#1 á0#â0âP…áÿâ! 
0å@“å  Tã    ê@”å  Tã  
 0Ôå  Sãùÿÿ0å  á 0å  á0å	 á•ÿÿë@”å  Tãòÿÿ0å00“å  SãI  
0™å  ã  á3ÿ/á0™å   ãÀŸå  á3ÿ/á0™å ã  á3ÿ/á0å0@“å  Tã p   `   0  ê0”åP“å  áþÿÿë á0™å   á  á3ÿ/á0™å á  á3ÿ/á@”å  Tã   
0”å “åþÿÿë 0”å“å P á å‰þÿë ™å á ° á  á2ÿ/á…â  ™å  á2ÿ/á 0™å á  á3ÿ/á0å Uã P Ó0“åP Ã£0àÓÿÿ
0™å
 á  á3ÿ/áÎÿÿê0™å  ã  á3ÿ/á0å4@“å  Tã(  
  ã0”å  Sã    ê8 Ãå0“å  Sã  
8 Óå  Rãøÿÿ
@”å  Tãñÿÿ á0™å  á3ÿ/á  á0™åPŸå  á3ÿ/á0™å ã  á3ÿ/á@å0å	 á 0å  á0å@å  ágþÿë0™å,”å  á3ÿ/á@å<0”å  Sãu  
0™å  ã  á3ÿ/á0™å   ãÜŸå  á3ÿ/á0™å ã  á3ÿ/á<0”å  Sã0å_  
´rŸå´bŸå0åP“å  Uãj  
° á @ ã0›å “å 0Ðå  Sã    
þÿÿë   á0›å@„â
@„à “åþÿÿë°›å  [ã @„à @„âíÿÿ  áþÿÿë  PâŠ  
@Šà
° á0•å À•åDà0“å  á  ÓåÀåÀ•å  Pã0 Àœå  á Àåþÿÿë  áþÿÿëP•å  Uã €â °‹àêÿÿ
°Kà@Kâ Tã P ÓP Ã0å å “åìýÿë ™å  ã å  á2ÿ/á á  ™å  á2ÿ/á0å  á á 0™å3ÿ/á0å0“å£0à    á0™å
 á  á3ÿ/á0™å ã  á3ÿ/á
  áþÿÿë0å0“å  Sã0å¡ÿÿ å0™å  á,’å3ÿ/á å0™å  á,’å$ÐâðO½èÿ/á0™å ã  á3ÿ/áÞÿÿê   ãþÿÿë  Pâ3  
 ° ã @àãÁÿÿê0™å
 á  á3ÿ/áÉþÿê0™å  á3ÿ/áPå 0™å  á•åâ3ÿ/áŒŸå å @™å ýÿë  á  á4ÿ/á0å0“å ã   •åå0™å  á‘å3ÿ/á