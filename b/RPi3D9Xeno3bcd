her[0]),type(other[1]))
        else:
            raise TypeError("cannot multiply 'ParserElement' and '%s' objects", type(other))

        if minElements < 0:
            raise ValueError("cannot multiply ParserElement by negative value")
        if optElements < 0:
            raise ValueError("second tuple value must be greater or equal to first tuple value")
        if minElements == optElements == 0:
            raise ValueError("cannot multiply ParserElement by 0 or (0,0)")

        if (optElements):
            def makeOptionalList(n):
                if n>1:
                    return Optional(self + makeOptionalList(n-1))
                else:
                    return Optional(self)
            if minElements:
                if minElements == 1:
                    ret = self + makeOptionalList(optElements)
                else:
                    ret = And([self]*minElements) + makeOptionalList(optElements)
            else:
                ret = makeOptionalList(optElements)
        else:
            if minElements == 1:
                ret = self
            else:
                ret = And([self]*minElements)
        return ret

    def __rmul__(self, other):
        return self.__mul__(other)

    def __or__(self, other ):
        """
        Implementation of | operator - returns C{L{MatchFirst}}
        """
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return MatchFirst( [ self, other ] )

    def __ror__(self, other ):
        """
        Implementation of | operator when left operand is not a C{L{ParserElement}}
        """
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other | self

    def __xor__(self, other ):
        """
        Implementation of ^ operator - returns C{L{Or}}
        """
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return Or( [ self, other ] )

    def __rxor__(self, other ):
        """
        Implementation of ^ operator when left operand is not a C{L{ParserElement}}
        """
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other ^ self

    def __and__(self, other ):
        """
        Implementation of & operator - returns C{L{Each}}
        """
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return Each( [ self, other ] )

    def __rand__(self, other ):
        """
        Implementation of & operator when left operand is not a C{L{ParserElement}}
        """
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        if not isinstance( other, ParserElement ):
            warnings.warn("Cannot combine element of type %s with ParserElement" % type(other),
                    SyntaxWarning, stacklevel=2)
            return None
        return other & self

    def __invert__( self ):
        """
        Implementation of ~ operator - returns C{L{NotAny}}
        """
        return NotAny( self )

    def __call__(self, name=None):
        """
        Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
        
        If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
        passed as C{True}.
           
        If C{name} is omitted, same as calling C{L{copy}}.

        Example::
            # these are equivalent
            userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
            userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")             
        """
        if name is not None:
            return self.setResultsName(name)
        else:
            return self.copy()

    def suppress( self ):
        """
        Suppresses the output of this C{ParserElement}; useful to keep punctuation from
        cluttering up returned output.
        """
        return Suppress( self )

    def leaveWhitespace( self ):
        """
        Disables the skipping of whitespace before matching the characters in the
        C{ParserElement}'s defined pattern.  This is normally only used internally by
        the pyparsing module, but may be needed in some whitespace-sensitive grammars.
        """
        self.skipWhitespace = False
        return self

    def setWhitespaceChars( self, chars ):
        """
        Overrides the default whitespace chars
        """
        self.skipWhitespace = True
        self.whiteChars = chars
        self.copyDefaultWhiteChars = False
        return self

    def parseWithTabs( self ):
        """
        Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
        Must be called before C{parseString} when the input grammar contains elements that
        match C{<TAB>} characters.
        """
        self.keepTabs = True
        return self

    def ignore( self, other ):
        """
        Define expression to be ignored (e.g., comments) while doing pattern
        matching; may be called repeatedly, to define multiple comment or other
        ignorable patterns.
        
        Example::
            patt = OneOrMore(Word(alphas))
            patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
            
            patt.ignore(cStyleComment)
            patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
        """
        if isinstance(other, basestring):
            other = Suppress(other)

        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                self.ignoreExprs.append(other)
        else:
            self.ignoreExprs.append( Suppress( other.copy() ) )
        return self

    def setDebugActions( self, startAction, successAction, exceptionAction ):
        """
        Enable display of debugging messages while doing pattern matching.
        """
        self.debugActions = (startAction or _defaultStartDebugAction,
                             successAction or _defaultSuccessDebugAction,
                             exceptionAction or _defaultExceptionDebugAction)
        self.debug = True
        return self

    def setDebug( self, flag=True ):
        """
        Enable display of debugging messages while doing pattern matching.
        Set C{flag} to True to enable, False to disable.

        Example::
            wd = Word(alphas).setName("alphaword")
            integer = Word(nums).setName("numword")
            term = wd | integer
            
            # turn on debugging for wd
            wd.setDebug()

            OneOrMore(term).parseString("abc 123 xyz 890")
        
        prints::
            Match alphaword at loc 0(1,1)
            Matched alphaword -> ['abc']
            Match alphaword at loc 3(1,4)
            Exception raised:Expected alphaword (at char 4), (line:1, col:5)
            Match alphaword at loc 7(1,8)
            Matched alphaword -> ['xyz']
            Match alphaword at loc 11(1,12)
            Exception raised:Expected alphaword (at char 12), (line:1, col:13)
            Match alphaword at loc 15(1,16)
            Exception raised:Expected alphaword (at char 15), (line:1, col:16)

        The output shown is that produced by the default debug actions - custom debug actions can be
        specified using L{setDebugActions}. Prior to attempting
        to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
        is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
        message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
        which makes debugging and exception messages easier to understand - for instance, the default
        name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
        """
        if flag:
            self.setDebugActions( _defaultStartDebugAction, _defaultSuccessDebugAction, _defaultExceptionDebugAction )
        else:
            self.debug = False
        return self

    def __str__( self ):
        return self.name

    def __repr__( self ):
        return _ustr(self)

    def streamline( self ):
        self.streamlined = True
        self.strRepr = None
        return self

    def checkRecursion( self, parseElementList ):
        pass

    def validate( self, validateTrace=[] ):
        """
        Check defined expressions for valid structure, check for infinite recursive definitions.
        """
        self.checkRecursion( [] )

    def parseFile( self, file_or_filename, parseAll=False ):
        """
        Execute the parse expression on the given file or filename.
        If a filename is specified (instead of a file object),
        the entire file is opened, read, and closed before parsing.
        """
        try:
            file_contents = file_or_filename.read()
        except AttributeError:
            with open(file_or_filename, "r") as f:
                file_contents = f.read()
        try:
            return self.parseString(file_contents, parseAll)
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise
            else:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
                raise exc

    def __eq__(self,other):
        if isinstance(other, ParserElement):
            return self is other or vars(self) == vars(other)
        elif isinstance(other, basestring):
            return self.matches(other)
        else:
            return super(ParserElement,self)==other

    def __ne__(self,other):
        return not (self == other)

    def __hash__(self):
        return hash(id(self))

    def __req__(self,other):
        return self == other

    def __rne__(self,other):
        return not (self == other)

    def matches(self, testString, parseAll=True):
        """
        Method for quick testing of a parser against a test string. Good for simple 
        inline microtests of sub expressions while building up larger parser.
           
        Parameters:
         - testString - to test against this expression for a match
         - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
            
        Example::
            expr = Word(nums)
            assert expr.matches("100")
        """
        try:
            self.parseString(_ustr(testString), parseAll=parseAll)
            return True
        except ParseBaseException:
            return False
                
    def runTests(self, tests, parseAll=True, comment='#', fullDump=True, printResults=True, failureTests=False):
        """
        Execute the parse expression on a series of test strings, showing each
        test, the parsed results or where the parse failed. Quick and easy way to
        run a parse expression against a list of sample strings.
           
        Parameters:
         - tests - a list of separate test strings, or a multiline string of test strings
         - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
         - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
              string; pass None to disable comment filtering
         - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
              if False, only dump nested list
         - printResults - (default=C{True}) prints test output to stdout
         - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing

        Returns: a (success, results) tuple, where success indicates that all tests succeeded
        (or failed if C{failureTests} is True), and the results contain a list of lines of each 
        test's output
        
        Example::
            number_expr = pyparsing_common.number.copy()

            result = number_expr.runTests('''
                # unsigned integer
                100
                # negative integer
                -100
                # float with scientific notation
                6.02e23
                # integer with scientific notation
                1e-12
                ''')
            print("Success" if result[0] else "Failed!")

            result = number_expr.runTests('''
                # stray character
                100Z
                # missing leading digit before '.'
                -.100
                # too many '.'
                3.14.159
                ''', failureTests=True)
            print("Success" if result[0] else "Failed!")
        prints::
            # unsigned integer
            100
            [100]

            # negative integer
            -100
            [-100]

            # float with scientific notation
            6.02e23
            [6.02e+23]

            # integer with scientific notation
            1e-12
            [1e-12]

            Success
            
            # stray character
            100Z
               ^
            FAIL: Expected end of text (at char 3), (line:1, col:4)

            # missing leading digit before '.'
            -.100
            ^
            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)

            # too many '.'
            3.14.159
                ^
            FAIL: Expected end of text (at char 4), (line:1, col:5)

            Success

        Each test string must be on a single line. If you want to test a string that spans multiple
        lines, create a test like this::

            expr.runTest(r"this is a test\\n of strings that spans \\n 3 lines")
        
        (Note that this is a raw string literal, you must include the leading 'r'.)
        """
        if isinstance(tests, basestring):
            tests = list(map(str.strip, tests.rstrip().splitlines()))
        if isinstance(comment, basestring):
            comment = Literal(comment)
        allResults = []
        comments = []
        success = True
        for t in tests:
            if comment is not None and comment.matches(t, False) or comments and not t:
                comments.append(t)
                continue
            if not t:
                continue
            out = ['\n'.join(comments), t]
            comments = []
            try:
                t = t.replace(r'\n','\n')
                result = self.parseString(t, parseAll=parseAll)
                out.append(result.dump(full=fullDump))
                success = success and not failureTests
            except ParseBaseException as pe:
                fatal = "(FATAL)" if isinstance(pe, ParseFatalException) else ""
                if '\n' in t:
                    out.append(line(pe.loc, t))
                    out.append(' '*(col(pe.loc,t)-1) + '^' + fatal)
                else:
                    out.append(' '*pe.loc + '^' + fatal)
                out.append("FAIL: " + str(pe))
                success = success and failureTests
                result = pe
            except Exception as exc:
                out.append("FAIL-EXCEPTION: " + str(exc))
                success = success and failureTests
                result = exc

            if printResults:
                if fullDump:
                    out.append('')
                print('\n'.join(out))

            allResults.append((t, result))
        
        return success, allResults

        
class Token(ParserElement):
    """
    Abstract C{ParserElement} subclass, for defining atomic matching patterns.
    """
    def __init__( self ):
        super(Token,self).__init__( savelist=False )


class Empty(Token):
    """
    An empty token, will always match.
    """
    def __init__( self ):
        super(Empty,self).__init__()
        self.name = "Empty"
        self.mayReturnEmpty = True
        self.mayIndexError = False


class NoMatch(Token):
    """
    A token that will never match.
    """
    def __init__( self ):
        super(NoMatch,self).__init__()
        self.name = "NoMatch"
        self.mayReturnEmpty = True
        self.mayIndexError = False
        self.errmsg = "Unmatchable token"

    def parseImpl( self, instring, loc, doActions=True ):
        raise ParseException(instring, loc, self.errmsg, self)


class Literal(Token):
    """
    Token to exactly match a specified string.
    
    Example::
        Literal('blah').parseString('blah')  # -> ['blah']
        Literal('blah').parseString('blahfooblah')  # -> ['blah']
        Literal('blah').parseString('bla')  # -> Exception: Expected "blah"
    
    For case-insensitive matching, use L{CaselessLiteral}.
    
    For keyword matching (force word break before and after the matched string),
    use L{Keyword} or L{CaselessKeyword}.
    """
    def __init__( self, matchString ):
        super(Literal,self).__init__()
        self.match = matchString
        self.matchLen = len(matchString)
        try:
            self.firstMatchChar = matchString[0]
        except IndexError:
            warnings.warn("null string passed to Literal; use Empty() instead",
                            SyntaxWarning, stacklevel=2)
            self.__class__ = Empty
        self.name = '"%s"' % _ustr(self.match)
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = False
        self.mayIndexError = False

    # Performance tuning: this routine gets called a *lot*
    # if this is a single character match string  and the first character matches,
    # short-circuit as quickly as possible, and avoid calling startswith
    #~ @profile
    def parseImpl( self, instring, loc, doActions=True ):
        if (instring[loc] == self.firstMatchChar and
            (self.matchLen==1 or instring.startswith(self.match,loc)) ):
            return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)
_L = Literal
ParserElement._literalStringClass = Literal

class Keyword(Token):
    """
    Token to exactly match a specified string as a keyword, that is, it must be
    immediately followed by a non-keyword character.  Compare with C{L{Literal}}:
     - C{Literal("if")} will match the leading C{'if'} in C{'ifAndOnlyIf'}.
     - C{Keyword("if")} will not; it will only match the leading C{'if'} in C{'if x=1'}, or C{'if(y==2)'}
    Accepts two optional constructor arguments in addition to the keyword string:
     - C{identChars} is a string of characters that would be valid identifier characters,
          defaulting to all alphanumerics + "_" and "$"
     - C{caseless} allows case-insensitive matching, default is C{False}.
       
    Example::
        Keyword("start").parseString("start")  # -> ['start']
        Keyword("start").parseString("starting")  # -> Exception

    For case-insensitive matching, use L{CaselessKeyword}.
    """
    DEFAULT_KEYWORD_CHARS = alphanums+"_$"

    def __init__( self, matchString, identChars=None, caseless=False ):
        super(Keyword,self).__init__()
        if identChars is None:
            identChars = Keyword.DEFAULT_KEYWORD_CHARS
        self.match = matchString
        self.matchLen = len(matchString)
        try:
            self.firstMatchChar = matchString[0]
        except IndexError:
            warnings.warn("null string passed to Keyword; use Empty() instead",
                            SyntaxWarning, stacklevel=2)
        self.name = '"%s"' % self.match
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = False
        self.mayIndexError = False
        self.caseless = caseless
        if caseless:
            self.caselessmatch = matchString.upper()
            identChars = identChars.upper()
        self.identChars = set(identChars)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.caseless:
            if ( (instring[ loc:loc+self.matchLen ].upper() == self.caselessmatch) and
                 (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen].upper() not in self.identChars) and
                 (loc == 0 or instring[loc-1].upper() not in self.identChars) ):
                return loc+self.matchLen, self.match
        else:
            if (instring[loc] == self.firstMatchChar and
                (self.matchLen==1 or instring.startswith(self.match,loc)) and
                (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen] not in self.identChars) and
                (loc == 0 or instring[loc-1] not in self.identChars) ):
                return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)

    def copy(self):
        c = super(Keyword,self).copy()
        c.identChars = Keyword.DEFAULT_KEYWORD_CHARS
        return c

    @staticmethod
    def setDefaultKeywordChars( chars ):
        """Overrides the default Keyword chars
        """
        Keyword.DEFAULT_KEYWORD_CHARS = chars

class CaselessLiteral(Literal):
    """
    Token to match a specified string, ignoring case of letters.
    Note: the matched results will always be in the case of the given
    match string, NOT the case of the input text.

    Example::
        OneOrMore(CaselessLiteral("CMD")).parseString("cmd CMD Cmd10") # -> ['CMD', 'CMD', 'CMD']
        
    (Contrast with example for L{CaselessKeyword}.)
    """
    def __init__( self, matchString ):
        super(CaselessLiteral,self).__init__( matchString.upper() )
        # Preserve the defining literal.
        self.returnString = matchString
        self.name = "'%s'" % self.returnString
        self.errmsg = "Expected " + self.name

    def parseImpl( self, instring, loc, doActions=True ):
        if instring[ loc:loc+self.matchLen ].upper() == self.match:
            return loc+self.matchLen, self.returnString
        raise ParseException(instring, loc, self.errmsg, self)

class CaselessKeyword(Keyword):
    """
    Caseless version of L{Keyword}.

    Example::
        OneOrMore(CaselessKeyword("CMD")).parseString("cmd CMD Cmd10") # -> ['CMD', 'CMD']
        
    (Contrast with example for L{CaselessLiteral}.)
    """
    def __init__( self, matchString, identChars=None ):
        super(CaselessKeyword,self).__init__( matchString, identChars, caseless=True )

    def parseImpl( self, instring, loc, doActions=True ):
        if ( (instring[ loc:loc+self.matchLen ].upper() == self.caselessmatch) and
             (loc >= len(instring)-self.matchLen or instring[loc+self.matchLen].upper() not in self.identChars) ):
            return loc+self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)

class CloseMatch(Token):
    """
    A variation on L{Literal} which matches "close" matches, that is, 
    strings with at most 'n' mismatching characters. C{CloseMatch} takes parameters:
     - C{match_string} - string to be matched
     - C{maxMismatches} - (C{default=1}) maximum number of mismatches allowed to count as a match
    
    The results from a successful parse will contain the matched text from the input string and the following named results:
     - C{mismatches} - a list of the positions within the match_string where mismatches were found
     - C{original} - the original match_string used to compare against the input string
    
    If C{mismatches} is an empty list, then the match was an exact match.
    
    Example::
        patt = CloseMatch("ATCATCGAATGGA")
        patt.parseString("ATCATCGAAXGGA") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})
        patt.parseString("ATCAXCGAAXGGA") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)

        # exact match
        patt.parseString("ATCATCGAATGGA") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})

        # close match allowing up to 2 mismatches
        patt = CloseMatch("ATCATCGAATGGA", maxMismatches=2)
        patt.parseString("ATCAXCGAAXGGA") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})
    """
    def __init__(self, match_string, maxMismatches=1):
        super(CloseMatch,self).__init__()
        self.name = match_string
        self.match_string = match_string
        self.maxMismatches = maxMismatches
        self.errmsg = "Expected %r (with up to %d mismatches)" % (self.match_string, self.maxMismatches)
        self.mayIndexError = False
        self.mayReturnEmpty = False

    def parseImpl( self, instring, loc, doActions=True ):
        start = loc
        instrlen = len(instring)
        maxloc = start + len(self.match_string)

        if maxloc <= instrlen:
            match_string = self.match_string
            match_stringloc = 0
            mismatches = []
            maxMismatches = self.maxMismatches

            for match_stringloc,s_m in enumerate(zip(instring[loc:maxloc], self.match_string)):
                src,mat = s_m
                if src != mat:
                    mismatches.append(match_stringloc)
                    if len(mismatches) > maxMismatches:
                        break
            else:
                loc = match_stringloc + 1
                results = ParseResults([instring[start:loc]])
                results['original'] = self.match_string
                results['mismatches'] = mismatches
                return loc, results

        raise ParseException(instring, loc, self.errmsg, self)


class Word(Token):
    """
    Token for matching words composed of allowed character sets.
    Defined with string containing all allowed initial characters,
    an optional string containing allowed body characters (if omitted,
    defaults to the initial character set), and an optional minimum,
    maximum, and/or exact length.  The default value for C{min} is 1 (a
    minimum value < 1 is not valid); the default values for C{max} and C{exact}
    are 0, meaning no maximum or exact length restriction. An optional
    C{excludeChars} parameter can list characters that might be found in 
    the input C{bodyChars} string; useful to define a word of all printables
    except for one or two characters, for instance.
    
    L{srange} is useful for defining custom character set strings for defining 
    C{Word} expressions, using range notation from regular expression character sets.
    
    A common mistake is to use C{Word} to match a specific literal string, as in 
    C{Word("Address")}. Remember that C{Word} uses the string argument to define
    I{sets} of matchable characters. This expression would match "Add", "AAA",
    "dAred", or any other word made up of the characters 'A', 'd', 'r', 'e', and 's'.
    To match an exact literal string, use L{Literal} or L{Keyword}.

    pyparsing includes helper strings for building Words:
     - L{alphas}
     - L{nums}
     - L{alphanums}
     - L{hexnums}
     - L{alphas8bit} (alphabetic characters in ASCII range 128-255 - accented, tilded, umlauted, etc.)
     - L{punc8bit} (non-alphabetic characters in ASCII range 128-255 - currency, symbols, superscripts, diacriticals, etc.)
     - L{printables} (any non-whitespace character)

    Example::
        # a word composed of digits
        integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))
        
        # a word with a leading capital, and zero or more lowercase
        capital_word = Word(alphas.upper(), alphas.lower())

        # hostnames are alphanumeric, with leading alpha, and '-'
        hostname = Word(alphas, alphanums+'-')
        
        # roman numeral (not a strict parser, accepts invalid mix of characters)
        roman = Word("IVXLCDM")
        
        # any string of non-whitespace characters, except for ','
        csv_value = Word(printables, excludeChars=",")
    """
    def __init__( self, initChars, bodyChars=None, min=1, max=0, exact=0, asKeyword=False, excludeChars=None ):
        super(Word,self).__init__()
        if excludeChars:
            initChars = ''.join(c for c in initChars if c not in excludeChars)
            if bodyChars:
                bodyChars = ''.join(c for c in bodyChars if c not in excludeChars)
        self.initCharsOrig = initChars
        self.initChars = set(initChars)
        if bodyChars :
            self.bodyCharsOrig = bodyChars
            self.bodyChars = set(bodyChars)
        else:
            self.bodyCharsOrig = initChars
            self.bodyChars = set(initChars)

        self.maxSpecified = max > 0

        if min < 1:
            raise ValueError("cannot specify a minimum length < 1; use Optional(Word()) if zero-length word is permitted")

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.asKeyword = asKeyword

        if ' ' not in self.initCharsOrig+self.bodyCharsOrig and (min==1 and max==0 and exact==0):
            if self.bodyCharsOrig == self.initCharsOrig:
                self.reString = "[%s]+" % _escapeRegexRangeChars(self.initCharsOrig)
            elif len(self.initCharsOrig) == 1:
                self.reString = "%s[%s]*" % \
                                      (re.escape(self.initCharsOrig),
                                      _escapeRegexRangeChars(self.bodyCharsOrig),)
            else:
                self.reString = "[%s][%s]*" % \
                                      (_escapeRegexRangeChars(self.initCharsOrig),
                                      _escapeRegexRangeChars(self.bodyCharsOrig),)
            if self.asKeyword:
                self.reString = r"\b"+self.reString+r"\b"
            try:
                self.re = re.compile( self.reString )
            except Exception:
                self.re = None

    def parseImpl( self, instring, loc, doActions=True ):
        if self.re:
            result = self.re.match(instring,loc)
            if not result:
                raise ParseException(instring, loc, self.errmsg, self)

            loc = result.end()
            return loc, result.group()

        if not(instring[ loc ] in self.initChars):
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        instrlen = len(instring)
        bodychars = self.bodyChars
        maxloc = start + self.maxLen
        maxloc = min( maxloc, instrlen )
        while loc < maxloc and instring[loc] in bodychars:
            loc += 1

        throwException = False
        if loc - start < self.minLen:
            throwException = True
        if self.maxSpecified and loc < instrlen and instring[loc] in bodychars:
            throwException = True
        if self.asKeyword:
            if (start>0 and instring[start-1] in bodychars) or (loc<instrlen and instring[loc] in bodychars):
                throwException = True

        if throwException:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def __str__( self ):
        try:
            return super(Word,self).__str__()
        except Exception:
            pass


        if self.strRepr is None:

            def charsAsStr(s):
                if len(s)>4:
                    return s[:4]+"..."
                else:
                    return s

            if ( self.initCharsOrig != self.bodyCharsOrig ):
                self.strRepr = "W:(%s,%s)" % ( charsAsStr(self.initCharsOrig), charsAsStr(self.bodyCharsOrig) )
            else:
                self.strRepr = "W:(%s)" % charsAsStr(self.initCharsOrig)

        return self.strRepr


class Regex(Token):
    """
    Token for matching strings that match a given regular expression.
    Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
    If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
    named parse results.

    Example::
        realnum = Regex(r"[+-]?\d+\.\d*")
        date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
        # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
        roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
    """
    compiledREtype = type(re.compile("[A-Z]"))
    def __init__( self, pattern, flags=0):
        """The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags."""
        super(Regex,self).__init__()

        if isinstance(pattern, basestring):
            if not pattern:
                warnings.warn("null string passed to Regex; use Empty() instead",
                        SyntaxWarning, stacklevel=2)

            self.pattern = pattern
            self.flags = flags

            try:
                self.re = re.compile(self.pattern, self.flags)
                self.reString = self.pattern
            except sre_constants.error:
                warnings.warn("invalid pattern (%s) passed to Regex" % pattern,
                    SyntaxWarning, stacklevel=2)
                raise

        elif isinstance(pattern, Regex.compiledREtype):
            self.re = pattern
            self.pattern = \
            self.reString = str(pattern)
            self.flags = flags
            
        else:
            raise ValueError("Regex may only be constructed with a string or a compiled RE object")

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        result = self.re.match(instring,loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        d = result.groupdict()
        ret = ParseResults(result.group())
        if d:
            for k in d:
                ret[k] = d[k]
        return loc,ret

    def __str__( self ):
        try:
            return super(Regex,self).__str__()
        except Exception:
            pass

        if self.strRepr is None:
            self.strRepr = "Re:(%s)" % repr(self.pattern)

        return self.strRepr


class QuotedString(Token):
    r"""
    Token for matching strings that are delimited by quoting characters.
    
    Defined with the following parameters:
        - quoteChar - string of one or more characters defining the quote delimiting string
        - escChar - character to escape quotes, typically backslash (default=C{None})
        - escQuote - special quote sequence to escape an embedded quote string (such as SQL's "" to escape an embedded ") (default=C{None})
        - multiline - boolean indicating whether quotes can span multiple lines (default=C{False})
        - unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})
        - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} => same as quoteChar)
        - convertWhitespaceEscapes - convert escaped whitespace (C{'\t'}, C{'\n'}, etc.) to actual whitespace (default=C{True})

    Example::
        qs = QuotedString('"')
        print(qs.searchString('lsjdf "This is the quote" sldjf'))
        complex_qs = QuotedString('{{', endQuoteChar='}}')
        print(complex_qs.searchString('lsjdf {{This is the "quote"}} sldjf'))
        sql_qs = QuotedString('"', escQuote='""')
        print(sql_qs.searchString('lsjdf "This is the quote with ""embedded"" quotes" sldjf'))
    prints::
        [['This is the quote']]
        [['This is the "quote"']]
        [['This is the quote with "embedded" quotes']]
    """
    def __init__( self, quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None, convertWhitespaceEscapes=True):
        super(QuotedString,self).__init__()

        # remove white space from quote chars - wont work anyway
        quoteChar = quoteChar.strip()
        if not quoteChar:
            warnings.warn("quoteChar cannot be the empty string",SyntaxWarning,stacklevel=2)
            raise SyntaxError()

        if endQuoteChar is None:
            endQuoteChar = quoteChar
        else:
            endQuoteChar = endQuoteChar.strip()
            if not endQuoteChar:
                warnings.warn("endQuoteChar cannot be the empty string",SyntaxWarning,stacklevel=2)
                raise SyntaxError()

        self.quoteChar = quoteChar
        self.quoteCharLen = len(quoteChar)
        self.firstQuoteChar = quoteChar[0]
        self.endQuoteChar = endQuoteChar
        self.endQuoteCharLen = len(endQuoteChar)
        self.escChar = escChar
        self.escQuote = escQuote
        self.unquoteResults = unquoteResults
        self.convertWhitespaceEscapes = convertWhitespaceEscapes

        if multiline:
            self.flags = re.MULTILINE | re.DOTALL
            self.pattern = r'%s(?:[^%s%s]' % \
                ( re.escape(self.quoteChar),
                  _escapeRegexRangeChars(self.endQuoteChar[0]),
                  (escChar is not None and _escapeRegexRangeChars(escChar) or '') )
        else:
            self.flags = 0
            self.pattern = r'%s(?:[^%s\n\r%s]' % \
                ( re.escape(self.quoteChar),
                  _escapeRegexRangeChars(self.endQuoteChar[0]),
                  (escChar is not None and _escapeRegexRangeChars(escChar) or '') )
        if len(self.endQuoteChar) > 1:
            self.pattern += (
                '|(?:' + ')|(?:'.join("%s[^%s]" % (re.escape(self.endQuoteChar[:i]),
                                               _escapeRegexRangeChars(self.endQuoteChar[i]))
                                    for i in range(len(self.endQuoteChar)-1,0,-1)) + ')'
                )
        if escQuote:
            self.pattern += (r'|(?:%s)' % re.escape(escQuote))
        if escChar:
            self.pattern += (r'|(?:%s.)' % re.escape(escChar))
            self.escCharReplacePattern = re.escape(self.escChar)+"(.)"
        self.pattern += (r')*%s' % re.escape(self.endQuoteChar))

        try:
            self.re = re.compile(self.pattern, self.flags)
            self.reString = self.pattern
        except sre_constants.error:
            warnings.warn("invalid pattern (%s) passed to Regex" % self.pattern,
                SyntaxWarning, stacklevel=2)
            raise

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayIndexError = False
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        result = instring[loc] == self.firstQuoteChar and self.re.match(instring,loc) or None
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        ret = result.group()

        if self.unquoteResults:

            # strip off quotes
            ret = ret[self.quoteCharLen:-self.endQuoteCharLen]

            if isinstance(ret,basestring):
                # replace escaped whitespace
                if '\\' in ret and self.convertWhitespaceEscapes:
                    ws_map = {
                        r'\t' : '\t',
                        r'\n' : '\n',
                        r'\f' : '\f',
                        r'\r' : '\r',
                    }
                    for wslit,wschar in ws_map.items():
                        ret = ret.replace(wslit, wschar)

                # replace escaped characters
                if self.escChar:
                    ret = re.sub(self.escCharReplacePattern,"\g<1>",ret)

                # replace escaped quotes
                if self.escQuote:
                    ret = ret.replace(self.escQuote, self.endQuoteChar)

        return loc, ret

    def __str__( self ):
        try:
            return super(QuotedString,self).__str__()
        except Exception:
            pass

        if self.strRepr is None:
            self.strRepr = "quoted string, starting with %s ending with %s" % (self.quoteChar, self.endQuoteChar)

        return self.strRepr


class CharsNotIn(Token):
    """
    Token for matching words composed of characters I{not} in a given set (will
    include whitespace in matched characters if not listed in the provided exclusion set - see example).
    Defined with string containing all disallowed characters, and an optional
    minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a
    minimum value < 1 is not valid); the default values for C{max} and C{exact}
    are 0, meaning no maximum or exact length restriction.

    Example::
        # define a comma-separated-value as anything that is not a ','
        csv_value = CharsNotIn(',')
        print(delimitedList(csv_value).parseString("dkls,lsdkjf,s12 34,@!#,213"))
    prints::
        ['dkls', 'lsdkjf', 's12 34', '@!#', '213']
    """
    def __init__( self, notChars, min=1, max=0, exact=0 ):
        super(CharsNotIn,self).__init__()
        self.skipWhitespace = False
        self.notChars = notChars

        if min < 1:
            raise ValueError("cannot specify a minimum length < 1; use Optional(CharsNotIn()) if zero-length char group is permitted")

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.name = _ustr(self)
        self.errmsg = "Expected " + self.name
        self.mayReturnEmpty = ( self.minLen == 0 )
        self.mayIndexError = False

    def parseImpl( self, instring, loc, doActions=True ):
        if instring[loc] in self.notChars:
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        notchars = self.notChars
        maxlen = min( start+self.maxLen, len(instring) )
        while loc < maxlen and \
              (instring[loc] not in notchars):
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def __str__( self ):
        try:
            return super(CharsNotIn, self).__str__()
        except Exception:
            pass

        if self.strRepr is None:
            if len(self.notChars) > 4:
                self.strRepr = "!W:(%s...)" % self.notChars[:4]
            else:
                self.strRepr = "!W:(%s)" % self.notChars

        return self.strRepr

class White(Token):
    """
    Special matching class for matching whitespace.  Normally, whitespace is ignored
    by pyparsing grammars.  This class is included when some whitespace structures
    are significant.  Define with a string containing the whitespace characters to be
    matched; default is C{" \\t\\r\\n"}.  Also takes optional C{min}, C{max}, and C{exact} arguments,
    as defined for the C{L{Word}} class.
    """
    whiteStrs = {
        " " : "<SPC>",
        "\t": "<TAB>",
        "\n": "<LF>",
        "\r": "<CR>",
        "\f": "<FF>",
        }
    def __init__(self, ws=" \t\r\n", min=1, max=0, exact=0):
        super(White,self).__init__()
        self.matchWhite = ws
        self.setWhitespaceChars( "".join(c for c in self.whiteChars if c not in self.matchWhite) )
        #~ self.leaveWhitespace()
        self.name = ("".join(White.whiteStrs[c] for c in self.matchWhite))
        self.mayReturnEmpty = True
        self.errmsg = "Expected " + self.name

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

    def parseImpl( self, instring, loc, doActions=True ):
        if not(instring[ loc ] in self.matchWhite):
            raise ParseException(instring, loc, self.errmsg, self)
        start = loc
        loc += 1
        maxloc = start + self.maxLen
        maxloc = min( maxloc, len(instring) )
        while loc < maxloc and instring[loc] in self.matchWhite:
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]


class _PositionToken(Token):
    def __init__( self ):
        super(_PositionToken,self).__init__()
        self.name=self.__class__.__name__
        self.mayReturnEmpty = True
        self.mayIndexError = False

class GoToColumn(_PositionToken):
    """
    Token to advance to a specific column of input text; useful for tabular report scraping.
    """
    def __init__( self, colno ):
        super(GoToColumn,self).__init__()
        self.col = colno

    def preParse( self, instring, loc ):
        if col(loc,instring) != self.col:
            instrlen = len(instring)
            if self.ignoreExprs:
                loc = self._skipIgnorables( instring, loc )
            while loc < instrlen and instring[loc].isspace() and col( loc, instring ) != self.col :
                loc += 1
        return loc

    def parseImpl( self, instring, loc, doActions=True ):
        thiscol = col( loc, instring )
        if thiscol > self.col:
            raise ParseException( instring, loc, "Text not in expected column", self )
        newloc = loc + self.col - thiscol
        ret = instring[ loc: newloc ]
        return newloc, ret


class LineStart(_PositionToken):
    """
    Matches if current position is at the beginning of a line within the parse string
    
    Example::
    
        test = '''\
        AAA this line
        AAA and this line
          AAA but not this one
        B AAA and definitely not this one
        '''

        for t in (LineStart() + 'AAA' + restOfLine).searchString(test):
            print(t)
    
    Prints::
        ['AAA', ' this line']
        ['AAA', ' and this line']    

    """
    def __init__( self ):
        super(LineStart,self).__init__()
        self.errmsg = "Expected start of line"

    def parseImpl( self, instring, loc, doActions=True ):
        if col(loc, instring) == 1:
            return loc, []
        raise ParseException(instring, loc, self.errmsg, self)

class LineEnd(_PositionToken):
    """
    Matches if current position is at the end of a line within the parse string
    """
    def __init__( self ):
        super(LineEnd,self).__init__()
        self.setWhitespaceChars( ParserElement.DEFAULT_WHITE_CHARS.replace("\n","") )
        self.errmsg = "Expected end of line"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc<len(instring):
            if instring[loc] == "\n":
                return loc+1, "\n"
            else:
                raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc+1, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)

class StringStart(_PositionToken):
    """
    Matches if current position is at the beginning of the parse string
    """
    def __init__( self ):
        super(StringStart,self).__init__()
        self.errmsg = "Expected start of text"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc != 0:
            # see if entire string up to here is just whitespace and ignoreables
            if loc != self.preParse( instring, 0 ):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class StringEnd(_PositionToken):
    """
    Matches if current position is at the end of the parse string
    """
    def __init__( self ):
        super(StringEnd,self).__init__()
        self.errmsg = "Expected end of text"

    def parseImpl( self, instring, loc, doActions=True ):
        if loc < len(instring):
            raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc+1, []
        elif loc > len(instring):
            return loc, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)

class WordStart(_PositionToken):
    """
    Matches if the current position is at the beginning of a Word, and
    is not preceded by any character in a given set of C{wordChars}
    (default=C{printables}). To emulate the C{\b} behavior of regular expressions,
    use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of
    the string being parsed, or at the beginning of a line.
    """
    def __init__(self, wordChars = printables):
        super(WordStart,self).__init__()
        self.wordChars = set(wordChars)
        self.errmsg = "Not at the start of a word"

    def parseImpl(self, instring, loc, doActions=True ):
        if loc != 0:
            if (instring[loc-1] in self.wordChars or
                instring[loc] not in self.wordChars):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

class WordEnd(_PositionToken):
    """
    Matches if the current position is at the end of a Word, and
    is not followed by any character in a given set of C{wordChars}
    (default=C{printables}). To emulate the C{\b} behavior of regular expressions,
    use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of
    the string being parsed, or at the end of a line.
    """
    def __init__(self, wordChars = printables):
        super(WordEnd,self).__init__()
        self.wordChars = set(wordChars)
        self.skipWhitespace = False
        self.errmsg = "Not at the end of a word"

    def parseImpl(self, instring, loc, doActions=True ):
        instrlen = len(instring)
        if instrlen>0 and loc<instrlen:
            if (instring[loc] in self.wordChars or
                instring[loc-1] not in self.wordChars):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []


class ParseExpression(ParserElement):
    """
    Abstract subclass of ParserElement, for combining and post-processing parsed tokens.
    """
    def __init__( self, exprs, savelist = False ):
        super(ParseExpression,self).__init__(savelist)
        if isinstance( exprs, _generatorType ):
            exprs = list(exprs)

        if isinstance( exprs, basestring ):
            self.exprs = [ ParserElement._literalStringClass( exprs ) ]
        elif isinstance( exprs, collections.Iterable ):
            exprs = list(exprs)
            # if sequence of strings provided, wrap with Literal
            if all(isinstance(expr, basestring) for expr in exprs):
                exprs = map(ParserElement._literalStringClass, exprs)
            self.exprs = list(exprs)
        else:
            try:
                self.exprs = list( exprs )
            except TypeError:
                self.exprs = [ exprs ]
        self.callPreparse = False

    def __getitem__( self, i ):
        return self.exprs[i]

    def append( self, other ):
        self.exprs.append( other )
        self.strRepr = None
        return self

    def leaveWhitespace( self ):
        """Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
           all contained expressions."""
        self.skipWhitespace = False
        self.exprs = [ e.copy() for e in self.exprs ]
        for e in self.exprs:
            e.leaveWhitespace()
        return self

    def ignore( self, other ):
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                super( ParseExpression, self).ignore( other )
                for e in self.exprs:
                    e.ignore( self.ignoreExprs[-1] )
        else:
            super( ParseExpression, self).ignore( other )
            for e in self.exprs:
                e.ignore( self.ignoreExprs[-1] )
        return self

    def __str__( self ):
        try:
            return super(ParseExpression,self).__str__()
        except Exception:
            pass

        if self.strRepr is None:
            self.strRepr = "%s:(%s)" % ( self.__class__.__name__, _ustr(self.exprs) )
        return self.strRepr

    def streamline( self ):
        super(ParseExpression,self).streamline()

        for e in self.exprs:
            e.streamline()

        # collapse nested And's of the form And( And( And( a,b), c), d) to And( a,b,c,d )
        # but only if there are no parse actions or resultsNames on the nested And's
        # (likewise for Or's and MatchFirst's)
        if ( len(self.exprs) == 2 ):
            other = self.exprs[0]
            if ( isinstance( other, self.__class__ ) and
                  not(other.parseAction) and
                  other.resultsName is None and
                  not other.debug ):
                self.exprs = other.exprs[:] + [ self.exprs[1] ]
                self.strRepr = None
                self.mayReturnEmpty |= other.mayReturnEmpty
                self.mayIndexError  |= other.mayIndexError

            other = self.exprs[-1]
            if ( isinstance( other, self.__class__ ) and
                  not(other.parseAction) and
                  other.resultsName is None and
                  not other.debug ):
                self.exprs = self.exprs[:-1] + other.exprs[:]
                self.strRepr = None
                self.mayReturnEmpty |= other.mayReturnEmpty
                self.mayIndexError  |= other.mayIndexError

        self.errmsg = "Expected " + _ustr(self)
        
        return self

    def setResultsName( self, name, listAllMatches=False ):
        ret = super(ParseExpression,self).setResultsName(name,listAllMatches)
        return ret

    def validate( self, validateTrace=[] ):
        tmp = validateTrace[:]+[self]
        for e in self.exprs:
            e.validate(tmp)
        self.checkRecursion( [] )
        
    def copy(self):
        ret = super(ParseExpression,self).copy()
        ret.exprs = [e.copy() for e in self.exprs]
        return ret

class And(ParseExpression):
    """
    Requires all given C{ParseExpression}s to be found in the given order.
    Expressions may be separated by whitespace.
    May be constructed using the C{'+'} operator.
    May also be constructed using the C{'-'} operator, which will suppress backtracking.

    Example::
        integer = Word(nums)
        name_expr = OneOrMore(Word(alphas))

        expr = And([integer("id"),name_expr("name"),integer("age")])
        # more easily written as:
        expr = integer("id") + name_expr("name") + integer("age")
    """

    class _ErrorStop(Empty):
        def __init__(self, *args, **kwargs):
            super(And._ErrorStop,self).__init__(*args, **kwargs)
            self.name = '-'
            self.leaveWhitespace()

    def __init__( self, exprs, savelist = True ):
        super(And,self).__init__(exprs, savelist)
        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
        self.setWhitespaceChars( self.exprs[0].whiteChars )
        self.skipWhitespace = self.exprs[0].skipWhitespace
        self.callPreparse = True

    def parseImpl( self, instring, loc, doActions=True ):
        # pass False as last arg to _parse for first element, since we already
        # pre-parsed the string as part of our And pre-parsing
        loc, resultlist = self.exprs[0]._parse( instring, loc, doActions, callPreParse=False )
        errorStop = False
        for e in self.exprs[1:]:
            if isinstance(e, And._ErrorStop):
                errorStop = True
                continue
            if errorStop:
                try:
                    loc, exprtokens = e._parse( instring, loc, doActions )
                except ParseSyntaxException:
                    raise
                except ParseBaseException as pe:
                    pe.__traceback__ = None
                    raise ParseSyntaxException._from_exception(pe)
                except IndexError:
                    raise ParseSyntaxException(instring, len(instring), self.errmsg, self)
            else:
                loc, exprtokens = e._parse( instring, loc, doActions )
            if exprtokens or exprtokens.haskeys():
                resultlist += exprtokens
        return loc, resultlist

    def __iadd__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        return self.append( other ) #And( [ self, other ] )

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )
            if not e.mayReturnEmpty:
                break

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr


class Or(ParseExpression):
    """
    Requires that at least one C{ParseExpression} is found.
    If two expressions match, the expression that matches the longest string will be used.
    May be constructed using the C{'^'} operator.

    Example::
        # construct Or using '^' operator
        
        number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
        print(number.searchString("123 3.1416 789"))
    prints::
        [['123'], ['3.1416'], ['789']]
    """
    def __init__( self, exprs, savelist = False ):
        super(Or,self).__init__(exprs, savelist)
        if self.exprs:
            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
        else:
            self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        maxExcLoc = -1
        maxException = None
        matches = []
        for e in self.exprs:
            try:
                loc2 = e.tryParse( instring, loc )
            except ParseException as err:
                err.__traceback__ = None
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(instring,len(instring),e.errmsg,self)
                    maxExcLoc = len(instring)
            else:
                # save match among all matches, to retry longest to shortest
                matches.append((loc2, e))

        if matches:
            matches.sort(key=lambda x: -x[0])
            for _,e in matches:
                try:
                    return e._parse( instring, loc, doActions )
                except ParseException as err:
                    err.__traceback__ = None
                    if err.loc > maxExcLoc:
                        maxException = err
                        maxExcLoc = err.loc

        if maxException is not None:
            maxException.msg = self.errmsg
            raise maxException
        else:
            raise ParseException(instring, loc, "no defined alternatives to match", self)


    def __ixor__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        return self.append( other ) #Or( [ self, other ] )

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " ^ ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class MatchFirst(ParseExpression):
    """
    Requires that at least one C{ParseExpression} is found.
    If two expressions match, the first one listed is the one that will match.
    May be constructed using the C{'|'} operator.

    Example::
        # construct MatchFirst using '|' operator
        
        # watch the order of expressions to match
        number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
        print(number.searchString("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]

        # put more selective expression first
        number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
        print(number.searchString("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
    """
    def __init__( self, exprs, savelist = False ):
        super(MatchFirst,self).__init__(exprs, savelist)
        if self.exprs:
            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
        else:
            self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        maxExcLoc = -1
        maxException = None
        for e in self.exprs:
            try:
                ret = e._parse( instring, loc, doActions )
                return ret
            except ParseException as err:
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(instring,len(instring),e.errmsg,self)
                    maxExcLoc = len(instring)

        # only got here if no expression matched, raise exception for match that made it the furthest
        else:
            if maxException is not None:
                maxException.msg = self.errmsg
                raise maxException
            else:
                raise ParseException(instring, loc, "no defined alternatives to match", self)

    def __ior__(self, other ):
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass( other )
        return self.append( other ) #MatchFirst( [ self, other ] )

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " | ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class Each(ParseExpression):
    """
    Requires all given C{ParseExpression}s to be found, but in any order.
    Expressions may be separated by whitespace.
    May be constructed using the C{'&'} operator.

    Example::
        color = oneOf("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")
        shape_type = oneOf("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")
        integer = Word(nums)
        shape_attr = "shape:" + shape_type("shape")
        posn_attr = "posn:" + Group(integer("x") + ',' + integer("y"))("posn")
        color_attr = "color:" + color("color")
        size_attr = "size:" + integer("size")

        # use Each (using operator '&') to accept attributes in any order 
        # (shape and posn are required, color and size are optional)
        shape_spec = shape_attr & posn_attr & Optional(color_attr) & Optional(size_attr)

        shape_spec.runTests('''
            shape: SQUARE color: BLACK posn: 100, 120
            shape: CIRCLE size: 50 color: BLUE posn: 50,80
            color:GREEN size:20 shape:TRIANGLE posn:20,40
            '''
            )
    prints::
        shape: SQUARE color: BLACK posn: 100, 120
        ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]
        - color: BLACK
        - posn: ['100', ',', '120']
          - x: 100
          - y: 120
        - shape: SQUARE


        shape: CIRCLE size: 50 color: BLUE posn: 50,80
        ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]
        - color: BLUE
        - posn: ['50', ',', '80']
          - x: 50
          - y: 80
        - shape: CIRCLE
        - size: 50


        color: GREEN size: 20 shape: TRIANGLE posn: 20,40
        ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]
        - color: GREEN
        - posn: ['20', ',', '40']
          - x: 20
          - y: 40
        - shape: TRIANGLE
        - size: 20
    """
    def __init__( self, exprs, savelist = True ):
        super(Each,self).__init__(exprs, savelist)
        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
        self.skipWhitespace = True
        self.initExprGroups = True

    def parseImpl( self, instring, loc, doActions=True ):
        if self.initExprGroups:
            self.opt1map = dict((id(e.expr),e) for e in self.exprs if isinstance(e,Optional))
            opt1 = [ e.expr for e in self.exprs if isinstance(e,Optional) ]
            opt2 = [ e for e in self.exprs if e.mayReturnEmpty and not isinstance(e,Optional)]
            self.optionals = opt1 + opt2
            self.multioptionals = [ e.expr for e in self.exprs if isinstance(e,ZeroOrMore) ]
            self.multirequired = [ e.expr for e in self.exprs if isinstance(e,OneOrMore) ]
            self.required = [ e for e in self.exprs if not isinstance(e,(Optional,ZeroOrMore,OneOrMore)) ]
            self.required += self.multirequired
            self.initExprGroups = False
        tmpLoc = loc
        tmpReqd = self.required[:]
        tmpOpt  = self.optionals[:]
        matchOrder = []

        keepMatching = True
        while keepMatching:
            tmpExprs = tmpReqd + tmpOpt + self.multioptionals + self.multirequired
            failed = []
            for e in tmpExprs:
                try:
                    tmpLoc = e.tryParse( instring, tmpLoc )
                except ParseException:
                    failed.append(e)
                else:
                    matchOrder.append(self.opt1map.get(id(e),e))
                    if e in tmpReqd:
                        tmpReqd.remove(e)
                    elif e in tmpOpt:
                        tmpOpt.remove(e)
            if len(failed) == len(tmpExprs):
                keepMatching = False

        if tmpReqd:
            missing = ", ".join(_ustr(e) for e in tmpReqd)
            raise ParseException(instring,loc,"Missing one or more required elements (%s)" % missing )

        # add any unmatched Optionals, in case they have default values defined
        matchOrder += [e for e in self.exprs if isinstance(e,Optional) and e.expr in tmpOpt]

        resultlist = []
        for e in matchOrder:
            loc,results = e._parse(instring,loc,doActions)
            resultlist.append(results)

        finalResults = sum(resultlist, ParseResults([]))
        return loc, finalResults

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + " & ".join(_ustr(e) for e in self.exprs) + "}"

        return self.strRepr

    def checkRecursion( self, parseElementList ):
        subRecCheckList = parseElementList[:] + [ self ]
        for e in self.exprs:
            e.checkRecursion( subRecCheckList )


class ParseElementEnhance(ParserElement):
    """
    Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens.
    """
    def __init__( self, expr, savelist=False ):
        super(ParseElementEnhance,self).__init__(savelist)
        if isinstance( expr, basestring ):
            if issubclass(ParserElement._literalStringClass, Token):
                expr = ParserElement._literalStringClass(expr)
            else:
                expr = ParserElement._literalStringClass(Literal(expr))
        self.expr = expr
        self.strRepr = None
        if expr is not None:
            self.mayIndexError = expr.mayIndexError
            self.mayReturnEmpty = expr.mayReturnEmpty
            self.setWhitespaceChars( expr.whiteChars )
            self.skipWhitespace = expr.skipWhitespace
            self.saveAsList = expr.saveAsList
            self.callPreparse = expr.callPreparse
            self.ignoreExprs.extend(expr.ignoreExprs)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.expr is not None:
            return self.expr._parse( instring, loc, doActions, callPreParse=False )
        else:
            raise ParseException("",loc,self.errmsg,self)

    def leaveWhitespace( self ):
        self.skipWhitespace = False
        self.expr = self.expr.copy()
        if self.expr is not None:
            self.expr.leaveWhitespace()
        return self

    def ignore( self, other ):
        if isinstance( other, Suppress ):
            if other not in self.ignoreExprs:
                super( ParseElementEnhance, self).ignore( other )
                if self.expr is not None:
                    self.expr.ignore( self.ignoreExprs[-1] )
        else:
            super( ParseElementEnhance, self).ignore( other )
            if self.expr is not None:
                self.expr.ignore( self.ignoreExprs[-1] )
        return self

    def streamline( self ):
        super(ParseElementEnhance,self).streamline()
        if self.expr is not None:
            self.expr.streamline()
        return self

    def checkRecursion( self, parseElementList ):
        if self in parseElementList:
            raise RecursiveGrammarException( parseElementList+[self] )
        subRecCheckList = parseElementList[:] + [ self ]
        if self.expr is not None:
            self.expr.checkRecursion( subRecCheckList )

    def validate( self, validateTrace=[] ):
        tmp = validateTrace[:]+[self]
        if self.expr is not None:
            self.expr.validate(tmp)
        self.checkRecursion( [] )

    def __str__( self ):
        try:
            return super(ParseElementEnhance,self).__str__()
        except Exception:
            pass

        if self.strRepr is None and self.expr is not None:
            self.strRepr = "%s:(%s)" % ( self.__class__.__name__, _ustr(self.expr) )
        return self.strRepr


class FollowedBy(ParseElementEnhance):
    """
    Lookahead matching of the given parse expression.  C{FollowedBy}
    does I{not} advance the parsing position within the input string, it only
    verifies that the specified parse expression matches at the current
    position.  C{FollowedBy} always returns a null token list.

    Example::
        # use FollowedBy to match a label only if it is followed by a ':'
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        
        OneOrMore(attr_expr).parseString("shape: SQUARE color: BLACK posn: upper left").pprint()
    prints::
        [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]
    """
    def __init__( self, expr ):
        super(FollowedBy,self).__init__(expr)
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        self.expr.tryParse( instring, loc )
        return loc, []


class NotAny(ParseElementEnhance):
    """
    Lookahead to disallow matching with the given parse expression.  C{NotAny}
    does I{not} advance the parsing position within the input string, it only
    verifies that the specified parse expression does I{not} match at the current
    position.  Also, C{NotAny} does I{not} skip over leading whitespace. C{NotAny}
    always returns a null token list.  May be constructed using the '~' operator.

    Example::
        
    """
    def __init__( self, expr ):
        super(NotAny,self).__init__(expr)
        #~ self.leaveWhitespace()
        self.skipWhitespace = False  # do NOT use self.leaveWhitespace(), don't want to propagate to exprs
        self.mayReturnEmpty = True
        self.errmsg = "Found unwanted token, "+_ustr(self.expr)

    def parseImpl( self, instring, loc, doActions=True ):
        if self.expr.canParseNext(instring, loc):
            raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "~{" + _ustr(self.expr) + "}"

        return self.strRepr

class _MultipleMatch(ParseElementEnhance):
    def __init__( self, expr, stopOn=None):
        super(_MultipleMatch, self).__init__(expr)
        self.saveAsList = True
        ender = stopOn
        if isinstance(ender, basestring):
            ender = ParserElement._literalStringClass(ender)
        self.not_ender = ~ender if ender is not None else None

    def parseImpl( self, instring, loc, doActions=True ):
        self_expr_parse = self.expr._parse
        self_skip_ignorables = self._skipIgnorables
        check_ender = self.not_ender is not None
        if check_ender:
            try_not_ender = self.not_ender.tryParse
        
        # must be at least one (but first see if we are the stopOn sentinel;
        # if so, fail)
        if check_ender:
            try_not_ender(instring, loc)
        loc, tokens = self_expr_parse( instring, loc, doActions, callPreParse=False )
        try:
            hasIgnoreExprs = (not not self.ignoreExprs)
            while 1:
                if check_ender:
                    try_not_ender(instring, loc)
                if hasIgnoreExprs:
                    preloc = self_skip_ignorables( instring, loc )
                else:
                    preloc = loc
                loc, tmptokens = self_expr_parse( instring, preloc, doActions )
                if tmptokens or tmptokens.haskeys():
                    tokens += tmptokens
        except (ParseException,IndexError):
            pass

        return loc, tokens
        
class OneOrMore(_MultipleMatch):
    """
    Repetition of one or more of the given expression.
    
    Parameters:
     - expr - expression that must match one or more times
     - stopOn - (default=C{None}) - expression for a terminating sentinel
          (only required if the sentinel would ordinarily match the repetition 
          expression)          

    Example::
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))

        text = "shape: SQUARE posn: upper left color: BLACK"
        OneOrMore(attr_expr).parseString(text).pprint()  # Fail! read 'color' as data instead of next label -> [['shape', 'SQUARE color']]

        # use stopOn attribute for OneOrMore to avoid reading label string as part of the data
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        OneOrMore(attr_expr).parseString(text).pprint() # Better -> [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]
        
        # could also be written as
        (attr_expr * (1,)).parseString(text).pprint()
    """

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "{" + _ustr(self.expr) + "}..."

        return self.strRepr

class ZeroOrMore(_MultipleMatch):
    """
    Optional repetition of zero or more of the given expression.
    
    Parameters:
     - expr - expression that must match zero or more times
     - stopOn - (default=C{None}) - expression for a terminating sentinel
          (only required if the sentinel would ordinarily match the repetition 
          expression)          

    Example: similar to L{OneOrMore}
    """
    def __init__( self, expr, stopOn=None):
        super(ZeroOrMore,self).__init__(expr, stopOn=stopOn)
        self.mayReturnEmpty = True
        
    def parseImpl( self, instring, loc, doActions=True ):
        try:
            return super(ZeroOrMore, self).parseImpl(instring, loc, doActions)
        except (ParseException,IndexError):
            return loc, []

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "[" + _ustr(self.expr) + "]..."

        return self.strRepr

class _NullToken(object):
    def __bool__(self):
        return False
    __nonzero__ = __bool__
    def __str__(self):
        return ""

_optionalNotMatched = _NullToken()
class Optional(ParseElementEnhance):
    """
    Optional matching of the given expression.

    Parameters:
     - expr - expression that must match zero or more times
     - default (optional) - value to be returned if the optional expression is not found.

    Example::
        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier
        zip = Combine(Word(nums, exact=5) + Optional('-' + Word(nums, exact=4)))
        zip.runTests('''
            # traditional ZIP code
            12345
            
            # ZIP+4 form
            12101-0001
            
            # invalid ZIP
            98765-
            ''')
    prints::
        # traditional ZIP code
        12345
        ['12345']

        # ZIP+4 form
        12101-0001
        ['12101-0001']

        # invalid ZIP
        98765-
             ^
        FAIL: Expected end of text (at char 5), (line:1, col:6)
    """
    def __init__( self, expr, default=_optionalNotMatched ):
        super(Optional,self).__init__( expr, savelist=False )
        self.saveAsList = self.expr.saveAsList
        self.defaultValue = default
        self.mayReturnEmpty = True

    def parseImpl( self, instring, loc, doActions=True ):
        try:
            loc, tokens = self.expr._parse( instring, loc, doActions, callPreParse=False )
        except (ParseException,IndexError):
            if self.defaultValue is not _optionalNotMatched:
                if self.expr.resultsName:
                    tokens = ParseResults([ self.defaultValue ])
                    tokens[self.expr.resultsName] = self.defaultValue
                else:
                    tokens = [ self.defaultValue ]
            else:
                tokens = []
        return loc, tokens

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name

        if self.strRepr is None:
            self.strRepr = "[" + _ustr(self.expr) + "]"

        return self.strRepr

class SkipTo(ParseElementEnhance):
    """
    Token for skipping over all undefined text until the matched expression is found.

    Parameters:
     - expr - target expression marking the end of the data to be skipped
     - include - (default=C{False}) if True, the target expression is also parsed 
          (the skipped text and target expression are returned as a 2-element list).
     - ignore - (default=C{None}) used to define grammars (typically quoted strings and 
          comments) that might contain false matches to the target expression
     - failOn - (default=C{None}) define expressions that are not allowed to be 
          included in the skipped test; if found before the target expression is found, 
          the SkipTo is not a match

    Example::
        report = '''
            Outstanding Issues Report - 1 Jan 2000

               # | Severity | Description                               |  Days Open
            -----+----------+-------------------------------------------+-----------
             101 | Critical | Intermittent system crash                 |          6
              94 | Cosmetic | Spelling error on Login ('log|n')         |         14
              79 | Minor    | System slow when running too many reports |         47
            '''
        integer = Word(nums)
        SEP = Suppress('|')
        # use SkipTo to simply match everything up until the next SEP
        # - ignore quoted strings, so that a '|' character inside a quoted string does not match
        # - parse action will call token.strip() for each matched token, i.e., the description body
        string_data = SkipTo(SEP, ignore=quotedString)
        string_data.setParseAction(tokenMap(str.strip))
        ticket_expr = (integer("issue_num") + SEP 
                      + string_data("sev") + SEP 
                      + string_data("desc") + SEP 
                      + integer("days_open"))
        
        for tkt in ticket_expr.searchString(report):
            print tkt.dump()
    prints::
        ['101', 'Critical', 'Intermittent system crash', '6']
        - days_open: 6
        - desc: Intermittent system crash
        - issue_num: 101
        - sev: Critical
        ['94', 'Cosmetic', "Spelling error on Login ('log|n')", '14']
        - days_open: 14
        - desc: Spelling error on Login ('log|n')
        - issue_num: 94
        - sev: Cosmetic
        ['79', 'Minor', 'System slow when running too many reports', '47']
        - days_open: 47
        - desc: System slow when running too many reports
        - issue_num: 79
        - sev: Minor
    """
    def __init__( self, other, include=False, ignore=None, failOn=None ):
        super( SkipTo, self ).__init__( other )
        self.ignoreExpr = ignore
        self.mayReturnEmpty = True
        self.mayIndexError = False
        self.includeMatch = include
        self.asList = False
        if isinstance(failOn, basestring):
            self.failOn = ParserElement._literalStringClass(failOn)
        else:
            self.failOn = failOn
        self.errmsg = "No match found for "+_ustr(self.expr)

    def parseImpl( self, instring, loc, doActions=True ):
        startloc = loc
        instrlen = len(instring)
        expr = self.expr
        expr_parse = self.expr._parse
        self_failOn_canParseNext = self.failOn.canParseNext if self.failOn is not None else None
        self_ignoreExpr_tryParse = self.ignoreExpr.tryParse if self.ignoreExpr is not None else None
        
        tmploc = loc
        while tmploc <= instrlen:
            if self_failOn_canParseNext is not None:
                # break if failOn expression matches
                if self_failOn_canParseNext(instring, tmploc):
                    break
                    
            if self_ignoreExpr_tryParse is not None:
                # advance past ignore expressions
                while 1:
                    try:
                        tmploc = self_ignoreExpr_tryParse(instring, tmploc)
                    except ParseBaseException:
                        break
            
            try:
                expr_parse(instring, tmploc, doActions=False, callPreParse=False)
            except (ParseException, IndexError):
                # no match, advance loc in string
                tmploc += 1
            else:
                # matched skipto expr, done
                break

        else:
            # ran off the end of the input string without matching skipto expr, fail
            raise ParseException(instring, loc, self.errmsg, self)

        # build up return values
        loc = tmploc
        skiptext = instring[startloc:loc]
        skipresult = ParseResults(skiptext)
        
        if self.includeMatch:
            loc, mat = expr_parse(instring,loc,doActions,callPreParse=False)
            skipresult += mat

        return loc, skipresult

class Forward(ParseElementEnhance):
    """
    Forward declaration of an expression to be defined later -
    used for recursive grammars, such as algebraic infix notation.
    When the expression is known, it is assigned to the C{Forward} variable using the '<<' operator.

    Note: take care when assigning to C{Forward} not to overlook precedence of operators.
    Specifically, '|' has a lower precedence than '<<', so that::
        fwdExpr << a | b | c
    will actually be evaluated as::
        (fwdExpr << a) | b | c
    thereby leaving b and c out as parseable alternatives.  It is recommended that you
    explicitly group the values inserted into the C{Forward}::
        fwdExpr << (a | b | c)
    Converting to use the '<<=' operator instead will avoid this problem.

    See L{ParseResults.pprint} for an example of a recursive parser created using
    C{Forward}.
    """
    def __init__( self, other=None ):
        super(Forward,self).__init__( other, savelist=False )

    def __lshift__( self, other ):
        if isinstance( other, basestring ):
            other = ParserElement._literalStringClass(other)
        self.expr = other
        self.strRepr = None
        self.mayIndexError = self.expr.mayIndexError
        self.mayReturnEmpty = self.expr.mayReturnEmpty
        self.setWhitespaceChars( self.expr.whiteChars )
        self.skipWhitespace = self.expr.skipWhitespace
        self.saveAsList = self.expr.saveAsList
        self.ignoreExprs.extend(self.expr.ignoreExprs)
        return self
        
    def __ilshift__(self, other):
        return self << other
    
    def leaveWhitespace( self ):
        self.skipWhitespace = False
        return self

    def streamline( self ):
        if not self.streamlined:
            self.streamlined = True
            if self.expr is not None:
                self.expr.streamline()
        return self

    def validate( self, validateTrace=[] ):
        if self not in validateTrace:
            tmp = validateTrace[:]+[self]
            if self.expr is not None:
                self.expr.validate(tmp)
        self.checkRecursion([])

    def __str__( self ):
        if hasattr(self,"name"):
            return self.name
        return self.__class__.__name__ + ": ..."

        # stubbed out for now - creates awful memory and perf issues
        self._revertClass = self.__class__
        self.__class__ = _ForwardNoRecurse
        try:
            if self.expr is not None:
                retString = _ustr(self.expr)
            else:
                retString = "None"
        finally:
            self.__class__ = self._revertClass
        return self.__class__.__name__ + ": " + retString

    def copy(self):
        if self.expr is not None:
            return super(Forward,self).copy()
        else:
            ret = Forward()
            ret <<= self
            return ret

class _ForwardNoRecurse(Forward):
    def __str__( self ):
        return "..."

class TokenConverter(ParseElementEnhance):
    """
    Abstract subclass of C{ParseExpression}, for converting parsed results.
    """
    def __init__( self, expr, savelist=False ):
        super(TokenConverter,self).__init__( expr )#, savelist )
        self.saveAsList = False

class Combine(TokenConverter):
    """
    Converter to concatenate all matching tokens to a single string.
    By default, the matching patterns must also be contiguous in the input string;
    this can be disabled by specifying C{'adjacent=False'} in the constructor.

    Example::
        real = Word(nums) + '.' + Word(nums)
        print(real.parseString('3.1416')) # -> ['3', '.', '1416']
        # will also erroneously match the following
        print(real.parseString('3. 1416')) # -> ['3', '.', '1416']

        real = Combine(Word(nums) + '.' + Word(nums))
        print(real.parseString('3.1416')) # -> ['3.1416']
        # no match when there are internal spaces
        print(real.parseString('3. 1416')) # -> Exception: Expected W:(0123...)
    """
    def __init__( self, expr, joinString="", adjacent=True ):
        super(Combine,self).__init__( expr )
        # suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself
        if adjacent:
            self.leaveWhitespace()
        self.adjacent = adjacent
        self.skipWhitespace = True
        self.joinString = joinString
        self.callPreparse = True

    def ignore( self, other ):
        if self.adjacent:
            ParserElement.ignore(self, other)
        else:
            super( Combine, self).ignore( other )
        return self

    def postParse( self, instring, loc, tokenlist ):
        retToks = tokenlist.copy()
        del retToks[:]
        retToks += ParseResults([ "".join(tokenlist._asStringList(self.joinString)) ], modal=self.modalResults)

        if self.resultsName and retToks.haskeys():
            return [ retToks ]
        else:
            return retToks

class Group(TokenConverter):
    """
    Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions.

    Example::
        ident = Word(alphas)
        num = Word(nums)
        term = ident | num
        func = ident + Optional(delimitedList(term))
        print(func.parseString("fn a,b,100"))  # -> ['fn', 'a', 'b', '100']

        func = ident + Group(Optional(delimitedList(term)))
        print(func.parseString("fn a,b,100"))  # -> ['fn', ['a', 'b', '100']]
    """
    def __init__( self, expr ):
        super(Group,self).__init__( expr )
        self.saveAsList = True

    def postParse( self, instring, loc, tokenlist ):
        return [ tokenlist ]

class Dict(TokenConverter):
    """
    Converter to return a repetitive expression as a list, but also as a dictionary.
    Each element can also be referenced using the first token in the expression as its key.
    Useful for tabular report scraping when the first column can be used as a item key.

    Example::
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))

        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        
        # print attributes as plain groups
        print(OneOrMore(attr_expr).parseString(text).dump())
        
        # instead of OneOrMore(expr), parse using Dict(OneOrMore(Group(expr))) - Dict will auto-assign names
        result = Dict(OneOrMore(Group(attr_expr))).parseString(text)
        print(result.dump())
        
        # access named fields as dict entries, or output as dict
        print(result['shape'])        
        print(result.asDict())
    prints::
        ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']

        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
        - color: light blue
        - posn: upper left
        - shape: SQUARE
        - texture: burlap
        SQUARE
        {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}
    See more examples at L{ParseResults} of accessing fields by results name.
    """
    def __init__( self, expr ):
        super(Dict,self).__init__( expr )
        self.saveAsList = True

    def postParse( self, instring, loc, tokenlist ):
        for i,tok in enumerate(tokenlist):
            if len(tok) == 0:
                continue
            ikey = tok[0]
            if isinstance(ikey,int):
                ikey = _ustr(tok[0]).strip()
            if len(tok)==1:
                tokenlist[ikey] = _ParseResultsWithOffset("",i)
            elif len(tok)==2 and not isinstance(tok[1],ParseResults):
                tokenlist[ikey] = _ParseResultsWithOffset(tok[1],i)
            else:
                dictvalue = tok.copy() #ParseResults(i)
                del dictvalue[0]
                if len(dictvalue)!= 1 or (isinstance(dictvalue,ParseResults) and dictvalue.haskeys()):
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue,i)
                else:
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[0],i)

        if self.resultsName:
            return [ tokenlist ]
        else:
            return tokenlist


class Suppress(TokenConverter):
    """
    Converter for ignoring the results of a parsed expression.

    Example::
        source = "a, b, c,d"
        wd = Word(alphas)
        wd_list1 = wd + ZeroOrMore(',' + wd)
        print(wd_list1.parseString(source))

        # often, delimiters that are useful during parsing are just in the
        # way afterward - use Suppress to keep them out of the parsed output
        wd_list2 = wd + ZeroOrMore(Suppress(',') + wd)
        print(wd_list2.parseString(source))
    prints::
        ['a', ',', 'b', ',', 'c', ',', 'd']
        ['a', 'b', 'c', 'd']
    (See also L{delimitedList}.)
    """
    def postParse( self, instring, loc, tokenlist ):
        return []

    def suppress( self ):
        return self


class OnlyOnce(object):
    """
    Wrapper for parse actions, to ensure they are only called once.
    """
    def __init__(self, methodCall):
        self.callable = _trim_arity(methodCall)
        self.called = False
    def __call__(self,s,l,t):
        if not self.called:
            results = self.callable(s,l,t)
            self.called = True
            return results
        raise ParseException(s,l,"")
    def reset(self):
        self.called = False

def traceParseAction(f):
    """
    Decorator for debugging parse actions. 
    
    When the parse action is called, this decorator will print C{">> entering I{method-name}(line:I{current_source_line}, I{parse_location}, I{matched_tokens})".}
    When the parse action completes, the decorator will print C{"<<"} followed by the returned value, or any exception that the parse action raised.

    Example::
        wd = Word(alphas)

        @traceParseAction
        def remove_duplicate_chars(tokens):
            return ''.join(sorted(set(''.join(tokens)))

        wds = OneOrMore(wd).setParseAction(remove_duplicate_chars)
        print(wds.parseString("slkdjs sld sldd sdlf sdljf"))
    prints::
        >>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))
        <<leaving remove_duplicate_chars (ret: 'dfjkls')
        ['dfjkls']
    """
    f = _trim_arity(f)
    def z(*paArgs):
        thisFunc = f.__name__
        s,l,t = paArgs[-3:]
        if len(paArgs)>3:
            thisFunc = paArgs[0].__class__.__name__ + '.' + thisFunc
        sys.stderr.write( ">>entering %s(line: '%s', %d, %r)\n" % (thisFunc,line(l,s),l,t) )
        try:
            ret = f(*paArgs)
        except Exception as exc:
            sys.stderr.write( "<<leaving %s (exception: %s)\n" % (thisFunc,exc) )
            raise
        sys.stderr.write( "<<leaving %s (ret: %r)\n" % (thisFunc,ret) )
        return ret
    try:
        z.__name__ = f.__name__
    except AttributeError:
        pass
    return z

#
# global helpers
#
def delimitedList( expr, delim=",", combine=False ):
    """
    Helper to define a delimited list of expressions - the delimiter defaults to ','.
    By default, the list elements and delimiters can have intervening whitespace, and
    comments, but this can be overridden by passing C{combine=True} in the constructor.
    If C{combine} is set to C{True}, the matching tokens are returned as a single token
    string, with the delimiters included; otherwise, the matching tokens are returned
    as a list of tokens, with the delimiters suppressed.

    Example::
        delimitedList(Word(alphas)).parseString("aa,bb,cc") # -> ['aa', 'bb', 'cc']
        delimitedList(Word(hexnums), delim=':', combine=True).parseString("AA:BB:CC:DD:EE") # -> ['AA:BB:CC:DD:EE']
    """
    dlName = _ustr(expr)+" ["+_ustr(delim)+" "+_ustr(expr)+"]..."
    if combine:
        return Combine( expr + ZeroOrMore( delim + expr ) ).setName(dlName)
    else:
        return ( expr + ZeroOrMore( Suppress( delim ) + expr ) ).setName(dlName)

def countedArray( expr, intExpr=None ):
    """
    Helper to define a counted list of expressions.
    This helper defines a pattern of the form::
        integer expr expr expr...
    where the leading integer tells how many expr expressions follow.
    The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.
    
    If C{intExpr} is specified, it should be a pyparsing expression that produces an integer value.

    Example::
        countedArray(Word(alphas)).parseString('2 ab cd ef')  # -> ['ab', 'cd']

        # in this parser, the leading integer value is given in binary,
        # '10' indicating that 2 values are in the array
        binaryConstant = Word('01').setParseAction(lambda t: int(t[0], 2))
        countedArray(Word(alphas), intExpr=binaryConstant).parseString('10 ab cd ef')  # -> ['ab', 'cd']
    """
    arrayExpr = Forward()
    def countFieldParseAction(s,l,t):
        n = t[0]
        arrayExpr << (n and Group(And([expr]*n)) or Group(empty))
        return []
    if intExpr is None:
        intExpr = Word(nums).setParseAction(lambda t:int(t[0]))
    else:
        intExpr = intExpr.copy()
    intExpr.setName("arrayLen")
    intExpr.addParseAction(countFieldParseAction, callDuringTry=True)
    return ( intExpr + arrayExpr ).setName('(len) ' + _ustr(expr) + '...')

def _flatten(L):
    ret = []
    for i in L:
        if isinstance(i,list):
            ret.extend(_flatten(i))
        else:
            ret.append(i)
    return ret

def matchPreviousLiteral(expr):
    """
    Helper to define an expression that is indirectly defined from
    the tokens matched in a previous expression, that is, it looks
    for a 'repeat' of a previous expression.  For example::
        first = Word(nums)
        second = matchPreviousLiteral(first)
        matchExpr = first + ":" + second
    will match C{"1:1"}, but not C{"1:2"}.  Because this matches a
    previous literal, will also match the leading C{"1:1"} in C{"1:10"}.
    If this is not desired, use C{matchPreviousExpr}.
    Do I{not} use with packrat parsing enabled.
    """
    rep = Forward()
    def copyTokenToRepeater(s,l,t):
        if t:
            if len(t) == 1:
                rep << t[0]
            else:
                # flatten t tokens
                tflat = _flatten(t.asList())
                rep << And(Literal(tt) for tt in tflat)
        else:
            rep << Empty()
    expr.addParseAction(copyTokenToRepeater, callDuringTry=True)
    rep.setName('(prev) ' + _ustr(expr))
    return rep

def matchPreviousExpr(expr):
    """
    Helper to define an expression that is indirectly defined from
    the tokens matched in a previous expression, that is, it looks
    for a 'repeat' of a previous expression.  For example::
        first = Word(nums)
        second = matchPreviousExpr(first)
        matchExpr = first + ":" + second
    will match C{"1:1"}, but not C{"1:2"}.  Because this matches by
    expressions, will I{not} match the leading C{"1:1"} in C{"1:10"};
    the expressions are evaluated first, and then compared, so
    C{"1"} is compared with C{"10"}.
    Do I{not} use with packrat parsing enabled.
    """
    rep = Forward()
    e2 = expr.copy()
    rep <<= e2
    def copyTokenToRepeater(s,l,t):
        matchTokens = _flatten(t.asList())
        def mustMatchTheseTokens(s,l,t):
            theseTokens = _flatten(t.asList())
            if  theseTokens != matchTokens:
                raise ParseException("",0,"")
        rep.setParseAction( mustMatchTheseTokens, callDuringTry=True )
    expr.addParseAction(copyTokenToRepeater, callDuringTry=True)
    rep.setName('(prev) ' + _ustr(expr))
    return rep

def _escapeRegexRangeChars(s):
    #~  escape these chars: ^-]
    for c in r"\^-]":
        s = s.replace(c,_bslash+c)
    s = s.replace("\n",r"\n")
    s = s.replace("\t",r"\t")
    return _ustr(s)

def oneOf( strs, caseless=False, useRegex=True ):
    """
    Helper to quickly define a set of alternative Literals, and makes sure to do
    longest-first testing when there is a conflict, regardless of the input order,
    but returns a C{L{MatchFirst}} for best performance.

    Parameters:
     - strs - a string of space-delimited literals, or a collection of string literals
     - caseless - (default=C{False}) - treat all literals as caseless
     - useRegex - (default=C{True}) - as an optimization, will generate a Regex
          object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or
          if creating a C{Regex} raises an exception)

    Example::
        comp_oper = oneOf("< = > <= >= !=")
        var = Word(alphas)
        number = Word(nums)
        term = var | number
        comparison_expr = term + comp_oper + term
        print(comparison_expr.searchString("B = 12  AA=23 B<=AA AA>12"))
    prints::
        [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]
    """
    if caseless:
        isequal = ( lambda a,b: a.upper() == b.upper() )
        masks = ( lambda a,b: b.upper().startswith(a.upper()) )
        parseElementClass = CaselessLiteral
    else:
        isequal = ( lambda a,b: a == b )
        masks = ( lambda a,b: b.startswith(a) )
        parseElementClass = Literal

    symbols = []
    if isinstance(strs,basestring):
        symbols = strs.split()
    elif isinstance(strs, collections.Iterable):
        symbols = list(strs)
    else:
        warnings.warn("Invalid argument to oneOf, expected string or iterable",
                SyntaxWarning, stacklevel=2)
    if not symbols:
        return NoMatch()

    i = 0
    while i < len(symbols)-1:
        cur = symbols[i]
        for j,other in enumerate(symbols[i+1:]):
            if ( isequal(other, cur) ):
                del symbols[i+j+1]
                break
            elif ( masks(cur, other) ):
                del symbols[i+j+1]
                symbols.insert(i,other)
                cur = other
                break
        else:
            i += 1

    if not caseless and useRegex:
        #~ print (strs,"->", "|".join( [ _escapeRegexChars(sym) for sym in symbols] ))
        try:
            if len(symbols)==len("".join(symbols)):
                return Regex( "[%s]" % "".join(_escapeRegexRangeChars(sym) for sym in symbols) ).setName(' | '.join(symbols))
            else:
                return Regex( "|".join(re.escape(sym) for sym in symbols) ).setName(' | '.join(symbols))
        except Exception:
            warnings.warn("Exception creating Regex for oneOf, building MatchFirst",
                    SyntaxWarning, stacklevel=2)


    # last resort, just use MatchFirst
    return MatchFirst(parseElementClass(sym) for sym in symbols).setName(' | '.join(symbols))

def dictOf( key, value ):
    """
    Helper to easily and clearly define a dictionary by specifying the respective patterns
    for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens
    in the proper order.  The key pattern can include delimiting markers or punctuation,
    as long as they are suppressed, thereby leaving the significant key text.  The value
    pattern can include named results, so that the C{Dict} results can include named token
    fields.

    Example::
        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        print(OneOrMore(attr_expr).parseString(text).dump())
        
        attr_label = label
        attr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)

        # similar to Dict, but simpler call format
        result = dictOf(attr_label, attr_value).parseString(text)
        print(result.dump())
        print(result['shape'])
        print(result.shape)  # object attribute access works too
        print(result.asDict())
    prints::
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
        - color: light blue
        - posn: upper left
        - shape: SQUARE
        - texture: burlap
        SQUARE
        SQUARE
        {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}
    """
    return Dict( ZeroOrMore( Group ( key + value ) ) )

def originalTextFor(expr, asString=True):
    """
    Helper to return the original, untokenized text for a given expression.  Useful to
    restore the parsed fields of an HTML start tag into the raw tag text itself, or to
    revert separate tokens with intervening whitespace back to the original matching
    input text. By default, returns astring containing the original parsed text.  
       
    If the optional C{asString} argument is passed as C{False}, then the return value is a 
    C{L{ParseResults}} containing any results names that were originally matched, and a 
    single token containing the original matched text from the input string.  So if 
    the expression passed to C{L{originalTextFor}} contains expressions with defined
    results names, you must set C{asString} to C{False} if you want to preserve those
    results name values.

    Example::
        src = "this is test <b> bold <i>text</i> </b> normal text "
        for tag in ("b","i"):
            opener,closer = makeHTMLTags(tag)
            patt = originalTextFor(opener + SkipTo(closer) + closer)
            print(patt.searchString(src)[0])
    prints::
        ['<b> bold <i>text</i> </b>']
        ['<i>text</i>']
    """
    locMarker = Empty().setParseAction(lambda s,loc,t: loc)
    endlocMarker = locMarker.copy()
    endlocMarker.callPreparse = False
    matchExpr = locMarker("_original_start") + expr + endlocMarker("_original_end")
    if asString:
        extractText = lambda s,l,t: s[t._original_start:t._original_end]
    else:
        def extractText(s,l,t):
            t[:] = [s[t.pop('_original_start'):t.pop('_original_end')]]
    matchExpr.setParseAction(extractText)
    matchExpr.ignoreExprs = expr.ignoreExprs
    return matchExpr

def ungroup(expr): 
    """
    Helper to undo pyparsing's default grouping of And expressions, even
    if all but one are non-empty.
    """
    return TokenConverter(expr).setParseAction(lambda t:t[0])

def locatedExpr(expr):
    """
    Helper to decorate a returned token with its starting and ending locations in the input string.
    This helper adds the following results names:
     - locn_start = location where matched expression begins
     - locn_end = location where matched expression ends
     - value = the actual parsed results

    Be careful if the input text contains C{<TAB>} characters, you may want to call
    C{L{ParserElement.parseWithTabs}}

    Example::
        wd = Word(alphas)
        for match in locatedExpr(wd).searchString("ljsdf123lksdjjf123lkkjj1222"):
            print(match)
    prints::
        [[0, 'ljsdf', 5]]
        [[8, 'lksdjjf', 15]]
        [[18, 'lkkjj', 23]]
    """
    locator = Empty().setParseAction(lambda s,l,t: l)
    return Group(locator("locn_start") + expr("value") + locator.copy().leaveWhitespace()("locn_end"))


# convenience constants for positional expressions
empty       = Empty().setName("empty")
lineStart   = LineStart().setName("lineStart")
lineEnd     = LineEnd().setName("lineEnd")
stringStart = StringStart().setName("stringStart")
stringEnd   = StringEnd().setName("stringEnd")

_escapedPunc = Word( _bslash, r"\[]-*.$+^?()~ ", exact=2 ).setParseAction(lambda s,l,t:t[0][1])
_escapedHexChar = Regex(r"\\0?[xX][0-9a-fA-F]+").setParseAction(lambda s,l,t:unichr(int(t[0].lstrip(r'\0x'),16)))
_escapedOctChar = Regex(r"\\0[0-7]+").setParseAction(lambda s,l,t:unichr(int(t[0][1:],8)))
_singleChar = _escapedPunc | _escapedHexChar | _escapedOctChar | Word(printables, excludeChars=r'\]', exact=1) | Regex(r"\w", re.UNICODE)
_charRange = Group(_singleChar + Suppress("-") + _singleChar)
_reBracketExpr = Literal("[") + Optional("^").setResultsName("negate") + Group( OneOrMore( _charRange | _singleChar ) ).setResultsName("body") + "]"

def srange(s):
    r"""
    Helper to easily define string ranges for use in Word construction.  Borrows
    syntax from regexp '[]' string range definitions::
        srange("[0-9]")   -> "0123456789"
        srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
        srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"
    The input string must be enclosed in []'s, and the returned string is the expanded
    character set joined into a single string.
    The values enclosed in the []'s may be:
     - a single character
     - an escaped character with a leading backslash (such as C{\-} or C{\]})
     - an escaped hex character with a leading C{'\x'} (C{\x21}, which is a C{'!'} character) 
         (C{\0x##} is also supported for backwards compatibility) 
     - an escaped octal character with a leading C{'\0'} (C{\041}, which is a C{'!'} character)
     - a range of any of the above, separated by a dash (C{'a-z'}, etc.)
     - any combination of the above (C{'aeiouy'}, C{'a-zA-Z0-9_$'}, etc.)
    """
    _expanded = lambda p: p if not isinstance(p,ParseResults) else ''.join(unichr(c) for c in range(ord(p[0]),ord(p[1])+1))
    try:
        return "".join(_expanded(part) for part in _reBracketExpr.parseString(s).body)
    except Exception:
        return ""

def matchOnlyAtCol(n):
    """
    Helper method for defining parse actions that require matching at a specific
    column in the input text.
    """
    def verifyCol(strg,locn,toks):
        if col(locn,strg) != n:
            raise ParseException(strg,locn,"matched token not at column %d" % n)
    return verifyCol

def replaceWith(replStr):
    """
    Helper method for common parse actions that simply return a literal value.  Especially
    useful when used with C{L{transformString<ParserElement.transformString>}()}.

    Example::
        num = Word(nums).setParseAction(lambda toks: int(toks[0]))
        na = oneOf("N/A NA").setParseAction(replaceWith(math.nan))
        term = na | num
        
        OneOrMore(term).parseString("324 234 N/A 234") # -> [324, 234, nan, 234]
    """
    return lambda s,l,t: [replStr]

def removeQuotes(s,l,t):
    """
    Helper parse action for removing quotation marks from parsed quoted strings.

    Example::
        # by default, quotation marks are included in parsed results
        quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["'Now is the Winter of our Discontent'"]

        # use removeQuotes to strip quotation marks from parsed results
        quotedString.setParseAction(removeQuotes)
        quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["Now is the Winter of our Discontent"]
    """
    return t[0][1:-1]

def tokenMap(func, *args):
    """
    Helper to define a parse action by mapping a function to all elements of a ParseResults list.If any additional 
    args are passed, they are forwarded to the given function as additional arguments after
    the token, as in C{hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))}, which will convert the
    parsed data to an integer using base 16.

    Example (compare the last to example in L{ParserElement.transformString}::
        hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16))
        hex_ints.runTests('''
            00 11 22 aa FF 0a 0d 1a
            ''')
        
        upperword = Word(alphas).setParseAction(tokenMap(str.upper))
        OneOrMore(upperword).runTests('''
            my kingdom for a horse
            ''')

        wd = Word(alphas).setParseAction(tokenMap(str.title))
        OneOrMore(wd).setParseAction(' '.join).runTests('''
            now is the winter of our discontent made glorious summer by this sun of york
            ''')
    prints::
        00 11 22 aa FF 0a 0d 1a
        [0, 17, 34, 170, 255, 10, 13, 26]

        my kingdom for a horse
        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']

        now is the winter of our discontent made glorious summer by this sun of york
        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']
    """
    def pa(s,l,t):
        return [func(tokn, *args) for tokn in t]

    try:
        func_name = getattr(func, '__name__', 
                            getattr(func, '__class__').__name__)
    except Exception:
        func_name = str(func)
    pa.__name__ = func_name

    return pa

upcaseTokens = tokenMap(lambda t: _ustr(t).upper())
"""(Deprecated) Helper parse action to convert tokens to upper case. Deprecated in favor of L{pyparsing_common.upcaseTokens}"""

downcaseTokens = tokenMap(lambda t: _ustr(t).lower())
"""(Deprecated) Helper parse action to convert tokens to lower case. Deprecated in favor of L{pyparsing_common.downcaseTokens}"""
    
def _makeTags(tagStr, xml):
    """Internal helper to construct opening and closing tag expressions, given a tag name"""
    if isinstance(tagStr,basestring):
        resname = tagStr
        tagStr = Keyword(tagStr, caseless=not xml)
    else:
        resname = tagStr.name

    tagAttrName = Word(alphas,alphanums+"_-:")
    if (xml):
        tagAttrValue = dblQuotedString.copy().setParseAction( removeQuotes )
        openTag = Suppress("<") + tagStr("tag") + \
                Dict(ZeroOrMore(Group( tagAttrName + Suppress("=") + tagAttrValue ))) + \
                Optional("/",default=[False]).setResultsName("empty").setParseAction(lambda s,l,t:t[0]=='/') + Suppress(">")
    else:
        printablesLessRAbrack = "".join(c for c in printables if c not in ">")
        tagAttrValue = quotedString.copy().setParseAction( removeQuotes ) | Word(printablesLessRAbrack)
        openTag = Suppress("<") + tagStr("tag") + \
                Dict(ZeroOrMore(Group( tagAttrName.setParseAction(downcaseTokens) + \
                Optional( Suppress("=") + tagAttrValue ) ))) + \
                Optional("/",default=[False]).setResultsName("empty").setParseAction(lambda s,l,t:t[0]=='/') + Suppress(">")
    closeTag = Combine(_L("</") + tagStr + ">")

    openTag = openTag.setResultsName("start"+"".join(resname.replace(":"," ").title().split())).setName("<%s>" % resname)
    closeTag = closeTag.setResultsName("end"+"".join(resname.replace(":"," ").title().split())).setName("</%s>" % resname)
    openTag.tag = resname
    closeTag.tag = resname
    return openTag, closeTag

def makeHTMLTags(tagStr):
    """
    Helper to construct opening and closing tag expressions for HTML, given a tag name. Matches
    tags in either upper or lower case, attributes with namespaces and with quoted or unquoted values.

    Example::
        text = '<td>More info at the <a href="http://pyparsing.wikispaces.com">pyparsing</a> wiki page</td>'
        # makeHTMLTags returns pyparsing expressions for the opening and closing tags as a 2-tuple
        a,a_end = makeHTMLTags("A")
        link_expr = a + SkipTo(a_end)("link_text") + a_end
        
        for link in link_expr.searchString(text):
            # attributes in the <A> tag (like "href" shown here) are also accessible as named results
            print(link.link_text, '->', link.href)
    prints::
        pyparsing -> http://pyparsing.wikispaces.com
    """
    return _makeTags( tagStr, False )

def makeXMLTags(tagStr):
    """
    Helper to construct opening and closing tag expressions for XML, given a tag name. Matches
    tags only in the given upper/lower case.

    Example: similar to L{makeHTMLTags}
    """
    return _makeTags( tagStr, True )

def withAttribute(*args,**attrDict):
    """
    Helper to create a validating parse action to be used with start tags created
    with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag
    with a required attribute value, to avoid false matches on common tags such as
    C{<TD>} or C{<DIV>}.

    Call C{withAttribute} with a series of attribute names and values. Specify the list
    of filter attributes names and values as:
     - keyword arguments, as in C{(align="right")}, or
     - as an explicit dict with C{**} operator, when an attribute name is also a Python
          reserved word, as in C{**{"class":"Customer", "align":"right"}}
     - a list of name-value tuples, as in ( ("ns1:class", "Customer"), ("ns2:align","right") )
    For attribute names with a namespace prefix, you must use the second form.  Attribute
    names are matched insensitive to upper/lower case.
       
    If just testing for C{class} (with or without a namespace), use C{L{withClass}}.

    To verify that the attribute exists, but without specifying a value, pass
    C{withAttribute.ANY_VALUE} as the value.

    Example::
        html = '''
            <div>
            Some text
            <div type="grid">1 4 0 1 0</div>
            <div type="graph">1,3 2,3 1,1</div>
            <div>this has no type</div>
            </div>
                
        '''
        div,div_end = makeHTMLTags("div")

        # only match div tag having a type attribute with value "grid"
        div_grid = div().setParseAction(withAttribute(type="grid"))
        grid_expr = div_grid + SkipTo(div | div_end)("body")
        for grid_header in grid_expr.searchString(html):
            print(grid_header.body)
        
        # construct a match with any div tag having a type attribute, regardless of the value
        div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))
        div_expr = div_any_type + SkipTo(div | div_end)("body")
        for div_header in div_expr.searchString(html):
            print(div_header.body)
    prints::
        1 4 0 1 0

        1 4 0 1 0
        1,3 2,3 1,1
    """
    if args:
        attrs = args[:]
    else:
        attrs = attrDict.items()
    attrs = [(k,v) for k,v in attrs]
    def pa(s,l,tokens):
        for attrName,attrValue in attrs:
            if attrName not in tokens:
                raise ParseException(s,l,"no matching attribute " + attrName)
            if attrValue != withAttribute.ANY_VALUE and tokens[attrName] != attrValue:
                raise ParseException(s,l,"attribute '%s' has value '%s', must be '%s'" %
                                            (attrName, tokens[attrName], attrValue))
    return pa
withAttribute.ANY_VALUE = object()

def withClass(classname, namespace=''):
    """
    Simplified version of C{L{withAttribute}} when matching on a div class - made
    difficult because C{class} is a reserved word in Python.

    Example::
        html = '''
            <div>
            Some text
            <div class="grid">1 4 0 1 0</div>
            <div class="graph">1,3 2,3 1,1</div>
            <div>this &lt;div&gt; has no class</div>
            </div>
                
        '''
        div,div_end = makeHTMLTags("div")
        div_grid = div().setParseAction(withClass("grid"))
        
        grid_expr = div_grid + SkipTo(div | div_end)("body")
        for grid_header in grid_expr.searchString(html):
            print(grid_header.body)
        
        div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))
        div_expr = div_any_type + SkipTo(div | div_end)("body")
        for div_header in div_expr.searchString(html):
            print(div_header.body)
    prints::
        1 4 0 1 0

        1 4 0 1 0
        1,3 2,3 1,1
    """
    classattr = "%s:class" % namespace if namespace else "class"
    return withAttribute(**{classattr : classname})        

opAssoc = _Constants()
opAssoc.LEFT = object()
opAssoc.RIGHT = object()

def infixNotation( baseExpr, opList, lpar=Suppress('('), rpar=Suppress(')') ):
    """
    Helper method for constructing grammars of expressions made up of
    operators working in a precedence hierarchy.  Operators may be unary or
    binary, left- or right-associative.  Parse actions can also be attached
    to operator expressions. The generated parser will also recognize the use 
    of parentheses to override operator precedences (see example below).
    
    Note: if you define a deep operator list, you may see performance issues
    when using infixNotation. See L{ParserElement.enablePackrat} for a
    mechanism to potentially improve your parser performance.

    Parameters:
     - baseExpr - expression representing the most basic element for the nested
     - opList - list of tuples, one for each operator precedence level in the
      expression grammar; each tuple is of the form
      (opExpr, numTerms, rightLeftAssoc, parseAction), where:
       - opExpr is the pyparsing expression for the operator;
          may also be a string, which will be converted to a Literal;
          if numTerms is 3, opExpr is a tuple of two expressions, for the
          two operators separating the 3 terms
       - numTerms is the number of terms for this operator (must
          be 1, 2, or 3)
       - rightLeftAssoc is the indicator whether the operator is
          right or left associative, using the pyparsing-defined
          constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.
       - parseAction is the parse action to be associated with
          expressions matching this operator expression (the
          parse action tuple member may be omitted)
     - lpar - expression for matching left-parentheses (default=C{Suppress('(')})
     - rpar - expression for matching right-parentheses (default=C{Suppress(')')})

    Example::
        # simple example of four-function arithmetic with ints and variable names
        integer = pyparsing_common.signed_integer
        varname = pyparsing_common.identifier 
        
        arith_expr = infixNotation(integer | varname,
            [
            ('-', 1, opAssoc.RIGHT),
            (oneOf('* /'), 2, opAssoc.LEFT),
            (oneOf('+ -'), 2, opAssoc.LEFT),
            ])
        
        arith_expr.runTests('''
            5+3*6
            (5+3)*6
            -2--11
            ''', fullDump=False)
    prints::
        5+3*6
        [[5, '+', [3, '*', 6]]]

        (5+3)*6
        [[[5, '+', 3], '*', 6]]

        -2--11
        [[['-', 2], '-', ['-', 11]]]
    """
    ret = Forward()
    lastExpr = baseExpr | ( lpar + ret + rpar )
    for i,operDef in enumerate(opList):
        opExpr,arity,rightLeftAssoc,pa = (operDef + (None,))[:4]
        termName = "%s term" % opExpr if arity < 3 else "%s%s term" % opExpr
        if arity == 3:
            if opExpr is None or len(opExpr) != 2:
                raise ValueError("if numterms=3, opExpr must be a tuple or list of two expressions")
            opExpr1, opExpr2 = opExpr
        thisExpr = Forward().setName(termName)
        if rightLeftAssoc == opAssoc.LEFT:
            if arity == 1:
                matchExpr = FollowedBy(lastExpr + opExpr) + Group( lastExpr + OneOrMore( opExpr ) )
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr + lastExpr) + Group( lastExpr + OneOrMore( opExpr + lastExpr ) )
                else:
                    matchExpr = FollowedBy(lastExpr+lastExpr) + Group( lastExpr + OneOrMore(lastExpr) )
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr) + \
                            Group( lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr )
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        elif rightLeftAssoc == opAssoc.RIGHT:
            if arity == 1:
                # try to avoid LR with this extra test
                if not isinstance(opExpr, Optional):
                    opExpr = Optional(opExpr)
                matchExpr = FollowedBy(opExpr.expr + thisExpr) + Group( opExpr + thisExpr )
            elif arity == 2:
                if opExpr is not None:
                    matchExpr = FollowedBy(lastExpr + opExpr + thisExpr) + Group( lastExpr + OneOrMore( opExpr + thisExpr ) )
                else:
                    matchExpr = FollowedBy(lastExpr + thisExpr) + Group( lastExpr + OneOrMore( thisExpr ) )
            elif arity == 3:
                matchExpr = FollowedBy(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr) + \
                            Group( lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr )
            else:
                raise ValueError("operator must be unary (1), binary (2), or ternary (3)")
        else:
            raise ValueError("operator must indicate right or left associativity")
        if pa:
            matchExpr.setParseAction( pa )
        thisExpr <<= ( matchExpr.setName(termName) | lastExpr )
        lastExpr = thisExpr
    ret <<= lastExpr
    return ret

operatorPrecedence = infixNotation
"""(Deprecated) Former name of C{L{infixNotation}}, will be dropped in a future release."""

dblQuotedString = Combine(Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*')+'"').setName("string enclosed in double quotes")
sglQuotedString = Combine(Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*")+"'").setName("string enclosed in single quotes")
quotedString = Combine(Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*')+'"'|
                       Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*")+"'").setName("quotedString using single or double quotes")
unicodeString = Combine(_L('u') + quotedString.copy()).setName("unicode string literal")

def nestedExpr(opener="(", closer=")", content=None, ignoreExpr=quotedString.copy()):
    """
    Helper method for defining nested lists enclosed in opening and closing
    delimiters ("(" and ")" are the default).

    Parameters:
     - opener - opening character for a nested list (default=C{"("}); can also be a pyparsing expression
     - closer - closing character for a nested list (default=C{")"}); can also be a pyparsing expression
     - content - expression for items within the nested lists (default=C{None})
     - ignoreExpr - expression for ignoring opening and closing delimiters (default=C{quotedString})

    If an expression is not provided for the content argument, the nested
    expression will capture all whitespace-delimited content between delimiters
    as a list of separate values.

    Use the C{ignoreExpr} argument to define expressions that may contain
    opening or closing characters that should not be treated as opening
    or closing characters for nesting, such as quotedString or a comment
    expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.
    The default is L{quotedString}, but if no expressions are to be ignored,
    then pass C{None} for this argument.

    Example::
        data_type = oneOf("void int short long char float double")
        decl_data_type = Combine(data_type + Optional(Word('*')))
        ident = Word(alphas+'_', alphanums+'_')
        number = pyparsing_common.number
        arg = Group(decl_data_type + ident)
        LPAR,RPAR = map(Suppress, "()")

        code_body = nestedExpr('{', '}', ignoreExpr=(quotedString | cStyleComment))

        c_function = (decl_data_type("type") 
                      + ident("name")
                      + LPAR + Optional(delimitedList(arg), [])("args") + RPAR 
                      + code_body("body"))
        c_function.ignore(cStyleComment)
        
        source_code = '''
            int is_odd(int x) { 
                return (x%2); 
            }
                
            int dec_to_hex(char hchar) { 
                if (hchar >= '0' && hchar <= '9') { 
                    return (ord(hchar)-ord('0')); 
                } else { 
                    return (10+ord(hchar)-ord('A'));
                } 
            }
        '''
        for func in c_function.searchString(source_code):
            print("%(name)s (%(type)s) args: %(args)s" % func)

    prints::
        is_odd (int) args: [['int', 'x']]
        dec_to_hex (int) args: [['char', 'hchar']]
    """
    if opener == closer:
        raise ValueError("opening and closing strings cannot be the same")
    if content is None:
        if isinstance(opener,basestring) and isinstance(closer,basestring):
            if len(opener) == 1 and len(closer)==1:
                if ignoreExpr is not None:
                    content = (Combine(OneOrMore(~ignoreExpr +
                                    CharsNotIn(opener+closer+ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
                else:
                    content = (empty.copy()+CharsNotIn(opener+closer+ParserElement.DEFAULT_WHITE_CHARS
                                ).setParseAction(lambda t:t[0].strip()))
            else:
                if ignoreExpr is not None:
                    content = (Combine(OneOrMore(~ignoreExpr + 
                                    ~Literal(opener) + ~Literal(closer) +
                                    CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
                else:
                    content = (Combine(OneOrMore(~Literal(opener) + ~Literal(closer) +
                                    CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS,exact=1))
                                ).setParseAction(lambda t:t[0].strip()))
        else:
            raise ValueError("opening and closing arguments must be strings if no content expression is given")
    ret = Forward()
    if ignoreExpr is not None:
        ret <<= Group( Suppress(opener) + ZeroOrMore( ignoreExpr | ret | content ) + Suppress(closer) )
    else:
        ret <<= Group( Suppress(opener) + ZeroOrMore( ret | content )  + Suppress(closer) )
    ret.setName('nested %s%s expression' % (opener,closer))
    return ret

def indentedBlock(blockStatementExpr, indentStack, indent=True):
    """
    Helper method for defining space-delimited indentation blocks, such as
    those used to define block statements in Python source code.

    Parameters:
     - blockStatementExpr - expression defining syntax of statement that
            is repeated within the indented block
     - indentStack - list created by caller to manage indentation stack
            (multiple statementWithIndentedBlock expressions within a single grammar
            should share a common indentStack)
     - indent - boolean indicating whether block must be indented beyond the
            the current level; set to False for block of left-most statements
            (default=C{True})

    A valid block must contain at least one C{blockStatement}.

    Example::
        data = '''
        def A(z):
          A1
          B = 100
          G = A2
          A2
          A3
        B
        def BB(a,b,c):
          BB1
          def BBA():
            bba1
            bba2
            bba3
        C
        D
        def spam(x,y):
             def eggs(z):
                 pass
        '''


        indentStack = [1]
        stmt = Forward()

        identifier = Word(alphas, alphanums)
        funcDecl = ("def" + identifier + Group( "(" + Optional( delimitedList(identifier) ) + ")" ) + ":")
        func_body = indentedBlock(stmt, indentStack)
        funcDef = Group( funcDecl + func_body )

        rvalue = Forward()
        funcCall = Group(identifier + "(" + Optional(delimitedList(rvalue)) + ")")
        rvalue << (funcCall | identifier | Word(nums))
        assignment = Group(identifier + "=" + rvalue)
        stmt << ( funcDef | assignment | identifier )

        module_body = OneOrMore(stmt)

        parseTree = module_body.parseString(data)
        parseTree.pprint()
    prints::
        [['def',
          'A',
          ['(', 'z', ')'],
          ':',
          [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
         'B',
         ['def',
          'BB',
          ['(', 'a', 'b', 'c', ')'],
          ':',
          [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
         'C',
         'D',
         ['def',
          'spam',
          ['(', 'x', 'y', ')'],
          ':',
          [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]] 
    """
    def checkPeerIndent(s,l,t):
        if l >= len(s): return
        curCol = col(l,s)
        if curCol != indentStack[-1]:
            if curCol > indentStack[-1]:
                raise ParseFatalException(s,l,"illegal nesting")
            raise ParseException(s,l,"not a peer entry")

    def checkSubIndent(s,l,t):
        curCol = col(l,s)
        if curCol > indentStack[-1]:
            indentStack.append( curCol )
        else:
            raise ParseException(s,l,"not a subentry")

    def checkUnindent(s,l,t):
        if l >= len(s): return
        curCol = col(l,s)
        if not(indentStack and curCol < indentStack[-1] and curCol <= indentStack[-2]):
            raise ParseException(s,l,"not an unindent")
        indentStack.pop()

    NL = OneOrMore(LineEnd().setWhitespaceChars("\t ").suppress())
    INDENT = (Empty() + Empty().setParseAction(checkSubIndent)).setName('INDENT')
    PEER   = Empty().setParseAction(checkPeerIndent).setName('')
    UNDENT = Empty().setParseAction(checkUnindent).setName('UNINDENT')
    if indent:
        smExpr = Group( Optional(NL) +
            #~ FollowedBy(blockStatementExpr) +
            INDENT + (OneOrMore( PEER + Group(blockStatementExpr) + Optional(NL) )) + UNDENT)
    else:
        smExpr = Group( Optional(NL) +
            (OneOrMore( PEER + Group(blockStatementExpr) + Optional(NL) )) )
    blockStatementExpr.ignore(_bslash + LineEnd())
    return smExpr.setName('indented block')

alphas8bit = srange(r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]")
punc8bit = srange(r"[\0xa1-\0xbf\0xd7\0xf7]")

anyOpenTag,anyCloseTag = makeHTMLTags(Word(alphas,alphanums+"_:").setName('any tag'))
_htmlEntityMap = dict(zip("gt lt amp nbsp quot apos".split(),'><& "\''))
commonHTMLEntity = Regex('&(?P<entity>' + '|'.join(_htmlEntityMap.keys()) +");").setName("common HTML entity")
def replaceHTMLEntity(t):
    """Helper parser action to replace common HTML entities with their special characters"""
    return _htmlEntityMap.get(t.entity)

# it's easy to get these comment structures wrong - they're very common, so may as well make them available
cStyleComment = Combine(Regex(r"/\*(?:[^*]|\*(?!/))*") + '*/').setName("C style comment")
"Comment of the form C{/* ... */}"

htmlComment = Regex(r"<!--[\s\S]*?-->").setName("HTML comment")
"Comment of the form C{<!-- ... -->}"

restOfLine = Regex(r".*").leaveWhitespace().setName("rest of line")
dblSlashComment = Regex(r"//(?:\\\n|[^\n])*").setName("// comment")
"Comment of the form C{// ... (to end of line)}"

cppStyleComment = Combine(Regex(r"/\*(?:[^*]|\*(?!/))*") + '*/'| dblSlashComment).setName("C++ style comment")
"Comment of either form C{L{cStyleComment}} or C{L{dblSlashComment}}"

javaStyleComment = cppStyleComment
"Same as C{L{cppStyleComment}}"

pythonStyleComment = Regex(r"#.*").setName("Python style comment")
"Comment of the form C{# ... (to end of line)}"

_commasepitem = Combine(OneOrMore(Word(printables, excludeChars=',') +
                                  Optional( Word(" \t") +
                                            ~Literal(",") + ~LineEnd() ) ) ).streamline().setName("commaItem")
commaSeparatedList = delimitedList( Optional( quotedString.copy() | _commasepitem, default="") ).setName("commaSeparatedList")
"""(Deprecated) Predefined expression of 1 or more printable words or quoted strings, separated by commas.
   This expression is deprecated in favor of L{pyparsing_common.comma_separated_list}."""

# some other useful expressions - using lower-case class name since we are really using this as a namespace
class pyparsing_common:
    """
    Here are some common low-level expressions that may be useful in jump-starting parser development:
     - numeric forms (L{integers<integer>}, L{reals<real>}, L{scientific notation<sci_real>})
     - common L{programming identifiers<identifier>}
     - network addresses (L{MAC<mac_address>}, L{IPv4<ipv4_address>}, L{IPv6<ipv6_address>})
     - ISO8601 L{dates<iso8601_date>} and L{datetime<iso8601_datetime>}
     - L{UUID<uuid>}
     - L{comma-separated list<comma_separated_list>}
    Parse actions:
     - C{L{convertToInteger}}
     - C{L{convertToFloat}}
     - C{L{convertToDate}}
     - C{L{convertToDatetime}}
     - C{L{stripHTMLTags}}
     - C{L{upcaseTokens}}
     - C{L{downcaseTokens}}

    Example::
        pyparsing_common.number.runTests('''
            # any int or real number, returned as the appropriate type
            100
            -100
            +100
            3.14159
            6.02e23
            1e-12
            ''')

        pyparsing_common.fnumber.runTests('''
            # any int or real number, returned as float
            100
            -100
            +100
            3.14159
            6.02e23
            1e-12
            ''')

        pyparsing_common.hex_integer.runTests('''
            # hex numbers
            100
            FF
            ''')

        pyparsing_common.fraction.runTests('''
            # fractions
            1/2
            -3/4
            ''')

        pyparsing_common.mixed_integer.runTests('''
            # mixed fractions
            1
            1/2
            -3/4
            1-3/4
            ''')

        import uuid
        pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))
        pyparsing_common.uuid.runTests('''
            # uuid
            12345678-1234-5678-1234-567812345678
            ''')
    prints::
        # any int or real number, returned as the appropriate type
        100
        [100]

        -100
        [-100]

        +100
        [100]

        3.14159
        [3.14159]

        6.02e23
        [6.02e+23]

        1e-12
        [1e-12]

        # any int or real number, returned as float
        100
        [100.0]

        -100
        [-100.0]

        +100
        [100.0]

        3.14159
        [3.14159]

        6.02e23
        [6.02e+23]

        1e-12
        [1e-12]

        # hex numbers
        100
        [256]

        FF
        [255]

        # fractions
        1/2
        [0.5]

        -3/4
        [-0.75]

        # mixed fractions
        1
        [1]

        1/2
        [0.5]

        -3/4
        [-0.75]

        1-3/4
        [1.75]

        # uuid
        12345678-1234-5678-1234-567812345678
        [UUID('12345678-1234-5678-1234-567812345678')]
    """

    convertToInteger = tokenMap(int)
    """
    Parse action for converting parsed integers to Python int
    """

    convertToFloat = tokenMap(float)
    """
    Parse action for converting parsed numbers to Python float
    """

    integer = Word(nums).setName("integer").setParseAction(convertToInteger)
    """expression that parses an unsigned integer, returns an int"""

    hex_integer = Word(hexnums).setName("hex integer").setParseAction(tokenMap(int,16))
    """expression that parses a hexadecimal integer, returns an int"""

    signed_integer = Regex(r'[+-]?\d+').setName("signed integer").setParseAction(convertToInteger)
    """expression that parses an integer with optional leading sign, returns an int"""

    fraction = (signed_integer().setParseAction(convertToFloat) + '/' + signed_integer().setParseAction(convertToFloat)).setName("fraction")
    """fractional expression of an integer divided by an integer, returns a float"""
    fraction.addParseAction(lambda t: t[0]/t[-1])

    mixed_integer = (fraction | signed_integer + Optional(Optional('-').suppress() + fraction)).setName("fraction or mixed integer-fraction")
    """mixed integer of the form 'integer - fraction', with optional leading integer, returns float"""
    mixed_integer.addParseAction(sum)

    real = Regex(r'[+-]?\d+\.\d*').setName("real number").setParseAction(convertToFloat)
    """expression that parses a floating point number and returns a float"""

    sci_real = Regex(r'[+-]?\d+([eE][+-]?\d+|\.\d*([eE][+-]?\d+)?)').setName("real number with scientific notation").setParseAction(convertToFloat)
    """expression that parses a floating point number with optional scientific notation and returns a float"""

    # streamlining this expression makes the docs nicer-looking
    number = (sci_real | real | signed_integer).streamline()
    """any numeric expression, returns the corresponding Python type"""

    fnumber = Regex(r'[+-]?\d+\.?\d*([eE][+-]?\d+)?').setName("fnumber").setParseAction(convertToFloat)
    """any int or real number, returned as float"""
    
    identifier = Word(alphas+'_', alphanums+'_').setName("identifier")
    """typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')"""
    
    ipv4_address = Regex(r'(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}').setName("IPv4 address")
    "IPv4 address (C{0.0.0.0 - 255.255.255.255})"

    _ipv6_part = Regex(r'[0-9a-fA-F]{1,4}').setName("hex_integer")
    _full_ipv6_address = (_ipv6_part + (':' + _ipv6_part)*7).setName("full IPv6 address")
    _short_ipv6_address = (Optional(_ipv6_part + (':' + _ipv6_part)*(0,6)) + "::" + Optional(_ipv6_part + (':' + _ipv6_part)*(0,6))).setName("short IPv6 address")
    _short_ipv6_address.addCondition(lambda t: sum(1 for tt in t if pyparsing_common._ipv6_part.matches(tt)) < 8)
    _mixed_ipv6_address = ("::ffff:" + ipv4_address).setName("mixed IPv6 address")
    ipv6_address = Combine((_full_ipv6_address | _mixed_ipv6_address | _short_ipv6_address).setName("IPv6 address")).setName("IPv6 address")
    "IPv6 address (long, short, or mixed form)"
    
    mac_address = Regex(r'[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\1[0-9a-fA-F]{2}){4}').setName("MAC address")
    "MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)"

    @staticmethod
    def convertToDate(fmt="%Y-%m-%d"):
        """
        Helper to create a parse action for converting parsed date string to Python datetime.date

        Params -
         - fmt - format to be passed to datetime.strptime (default=C{"%Y-%m-%d"})

        Example::
            date_expr = pyparsing_common.iso8601_date.copy()
            date_expr.setParseAction(pyparsing_common.convertToDate())
            print(date_expr.parseString("1999-12-31"))
        prints::
            [datetime.date(1999, 12, 31)]
        """
        def cvt_fn(s,l,t):
            try:
                return datetime.strptime(t[0], fmt).date()
            except ValueError as ve:
                raise ParseException(s, l, str(ve))
        return cvt_fn

    @staticmethod
    def convertToDatetime(fmt="%Y-%m-%dT%H:%M:%S.%f"):
        """
        Helper to create a parse action for converting parsed datetime string to Python datetime.datetime

        Params -
         - fmt - format to be passed to datetime.strptime (default=C{"%Y-%m-%dT%H:%M:%S.%f"})

        Example::
            dt_expr = pyparsing_common.iso8601_datetime.copy()
            dt_expr.setParseAction(pyparsing_common.convertToDatetime())
            print(dt_expr.parseString("1999-12-31T23:59:59.999"))
        prints::
            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]
        """
        def cvt_fn(s,l,t):
            try:
                return datetime.strptime(t[0], fmt)
            except ValueError as ve:
                raise ParseException(s, l, str(ve))
        return cvt_fn

    iso8601_date = Regex(r'(?P<year>\d{4})(?:-(?P<month>\d\d)(?:-(?P<day>\d\d))?)?').setName("ISO8601 date")
    "ISO8601 date (C{yyyy-mm-dd})"

    iso8601_datetime = Regex(r'(?P<year>\d{4})-(?P<month>\d\d)-(?P<day>\d\d)[T ](?P<hour>\d\d):(?P<minute>\d\d)(:(?P<second>\d\d(\.\d*)?)?)?(?P<tz>Z|[+-]\d\d:?\d\d)?').setName("ISO8601 datetime")
    "ISO8601 datetime (C{yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)}) - trailing seconds, milliseconds, and timezone optional; accepts separating C{'T'} or C{' '}"

    uuid = Regex(r'[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}').setName("UUID")
    "UUID (C{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx})"

    _html_stripper = anyOpenTag.suppress() | anyCloseTag.suppress()
    @staticmethod
    def stripHTMLTags(s, l, tokens):
        """
        Parse action to remove HTML tags from web page HTML source

        Example::
            # strip HTML links from normal text 
            text = '<td>More info at the <a href="http://pyparsing.wikispaces.com">pyparsing</a> wiki page</td>'
            td,td_end = makeHTMLTags("TD")
            table_text = td + SkipTo(td_end).setParseAction(pyparsing_common.stripHTMLTags)("body") + td_end
            
            print(table_text.parseString(text).body) # -> 'More info at the pyparsing wiki page'
        """
        return pyparsing_common._html_stripper.transformString(tokens[0])

    _commasepitem = Combine(OneOrMore(~Literal(",") + ~LineEnd() + Word(printables, excludeChars=',') 
                                        + Optional( White(" \t") ) ) ).streamline().setName("commaItem")
    comma_separated_list = delimitedList( Optional( quotedString.copy() | _commasepitem, default="") ).setName("comma separated list")
    """Predefined expression of 1 or more printable words or quoted strings, separated by commas."""

    upcaseTokens = staticmethod(tokenMap(lambda t: _ustr(t).upper()))
    """Parse action to convert tokens to upper case."""

    downcaseTokens = staticmethod(tokenMap(lambda t: _ustr(t).lower()))
    """Parse action to convert tokens to lower case."""


if __name__ == "__main__":

    selectToken    = CaselessLiteral("select")
    fromToken      = CaselessLiteral("from")

    ident          = Word(alphas, alphanums + "_$")

    columnName     = delimitedList(ident, ".", combine=True).setParseAction(upcaseTokens)
    columnNameList = Group(delimitedList(columnName)).setName("columns")
    columnSpec     = ('*' | columnNameList)

    tableName      = delimitedList(ident, ".", combine=True).setParseAction(upcaseTokens)
    tableNameList  = Group(delimitedList(tableName)).setName("tables")
    
    simpleSQL      = selectToken("command") + columnSpec("columns") + fromToken + tableNameList("tables")

    # demo runTests method, including embedded comments in test string
    simpleSQL.runTests("""
        # '*' as column list and dotted table name
        select * from SYS.XYZZY

        # caseless match on "SELECT", and casts back to "select"
        SELECT * from XYZZY, ABC

        # list of column names, and mixed case SELECT keyword
        Select AA,BB,CC from Sys.dual

        # multiple tables
        Select A, B, C from Sys.dual, Table2

        # invalid SELECT keyword - should fail
        Xelect A, B, C from Sys.dual

        # incomplete command - should fail
        Select

        # invalid column name - should fail
        Select ^^^ frox Sys.dual

        """)

    pyparsing_common.number.runTests("""
        100
        -100
        +100
        3.14159
        6.02e23
        1e-12
        """)

    # any int or real number, returned as float
    pyparsing_common.fnumber.runTests("""
        100
        -100
        +100
        3.14159
        6.02e23
        1e-12
        """)

    pyparsing_common.hex_integer.runTests("""
        100
        FF
        """)

    import uuid
    pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))
    pyparsing_common.uuid.runTests("""
        12345678-1234-5678-1234-567812345678
        """)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

from .__about__ import (
    __author__, __copyright__, __email__, __license__, __summary__, __title__,
    __uri__, __version__
)

__all__ = [
    "__title__", "__summary__", "__uri__", "__version__", "__author__",
    "__email__", "__license__", "__copyright__",
]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import sys


PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

# flake8: noqa

if PY3:
    string_types = str,
else:
    string_types = basestring,


def with_metaclass(meta, *bases):
    """
    Create a base class with a metaclass.
    """
    # This requires a bit of explanation: the basic idea is to make a dummy
    # metaclass for one level of class instantiation that replaces itself with
    # the actual metaclass.
    class metaclass(meta):
        def __new__(cls, name, this_bases, d):
            return meta(name, bases, d)
    return type.__new__(metaclass, 'temporary_class', (), {})
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2015 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import absolute_import

import functools
import itertools
import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.10.0"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):

            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)  # Invokes __set__.
        try:
            # This is a bit ugly, but it avoids running this again by
            # removing this descriptor.
            delattr(obj.__class__, self.name)
        except AttributeError:
            pass
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)

    def __getattr__(self, attr):
        _module = self._resolve()
        value = getattr(_module, attr)
        setattr(self, attr, value)
        return value


class _LazyModule(types.ModuleType):

    def __init__(self, name):
        super(_LazyModule, self).__init__(name)
        self.__doc__ = self.__class__.__doc__

    def __dir__(self):
        attrs = ["__doc__", "__name__"]
        attrs += [attr.name for attr in self._moved_attributes]
        return attrs

    # Subclasses should override this
    _moved_attributes = []


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)


class _SixMetaPathImporter(object):

    """
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    """

    def __init__(self, six_module_name):
        self.name = six_module_name
        self.known_modules = {}

    def _add_module(self, mod, *fullnames):
        for fullname in fullnames:
            self.known_modules[self.name + "." + fullname] = mod

    def _get_module(self, fullname):
        return self.known_modules[self.name + "." + fullname]

    def find_module(self, fullname, path=None):
        if fullname in self.known_modules:
            return self
        return None

    def __get_module(self, fullname):
        try:
            return self.known_modules[fullname]
        except KeyError:
            raise ImportError("This loader does not know module " + fullname)

    def load_module(self, fullname):
        try:
            # in case of a reload
            return sys.modules[fullname]
        except KeyError:
            pass
        mod = self.__get_module(fullname)
        if isinstance(mod, MovedModule):
            mod = mod._resolve()
        else:
            mod.__loader__ = self
        sys.modules[fullname] = mod
        return mod

    def is_package(self, fullname):
        """
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        """
        return hasattr(self.__get_module(fullname), "__path__")

    def get_code(self, fullname):
        """Return None

        Required, if is_package is implemented"""
        self.__get_module(fullname)  # eventually raises ImportError
        return None
    get_source = get_code  # same as get_code

_importer = _SixMetaPathImporter(__name__)


class _MovedItems(_LazyModule):

    """Lazy loading of moved objects"""
    __path__ = []  # mark as package


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("intern", "__builtin__", "sys"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserDict", "UserDict", "collections"),
    MovedAttribute("UserList", "UserList", "collections"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("_thread", "thread", "_thread"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
]
# Add windows specific modules.
if sys.platform == "win32":
    _moved_attributes += [
        MovedModule("winreg", "_winreg"),
    ]

for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
    if isinstance(attr, MovedModule):
        _importer._add_module(attr, "moves." + attr.name)
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = _MovedItems(__name__ + ".moves")
_importer._add_module(moves, "moves")


class Module_six_moves_urllib_parse(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
    MovedAttribute("splitquery", "urllib", "urllib.parse"),
    MovedAttribute("splittag", "urllib", "urllib.parse"),
    MovedAttribute("splituser", "urllib", "urllib.parse"),
    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
                      "moves.urllib_parse", "moves.urllib.parse")


class Module_six_moves_urllib_error(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
                      "moves.urllib_error", "moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
                      "moves.urllib_request", "moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
                      "moves.urllib_response", "moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
                      "moves.urllib_robotparser", "moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):

    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    __path__ = []  # mark as package
    parse = _importer._get_module("moves.urllib_parse")
    error = _importer._get_module("moves.urllib_error")
    request = _importer._get_module("moves.urllib_request")
    response = _importer._get_module("moves.urllib_response")
    robotparser = _importer._get_module("moves.urllib_robotparser")

    def __dir__(self):
        return ['parse', 'error', 'request', 'response', 'robotparser']

_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
                      "moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    def create_unbound_method(func, cls):
        return func

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    def create_unbound_method(func, cls):
        return types.MethodType(func, None, cls)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


if PY3:
    def iterkeys(d, **kw):
        return iter(d.keys(**kw))

    def itervalues(d, **kw):
        return iter(d.values(**kw))

    def iteritems(d, **kw):
        return iter(d.items(**kw))

    def iterlists(d, **kw):
        return iter(d.lists(**kw))

    viewkeys = operator.methodcaller("keys")

    viewvalues = operator.methodcaller("values")

    viewitems = operator.methodcaller("items")
else:
    def iterkeys(d, **kw):
        return d.iterkeys(**kw)

    def itervalues(d, **kw):
        return d.itervalues(**kw)

    def iteritems(d, **kw):
        return d.iteritems(**kw)

    def iterlists(d, **kw):
        return d.iterlists(**kw)

    viewkeys = operator.methodcaller("viewkeys")

    viewvalues = operator.methodcaller("viewvalues")

    viewitems = operator.methodcaller("viewitems")

_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
_add_doc(iteritems,
         "Return an iterator over the (key, value) pairs of a dictionary.")
_add_doc(iterlists,
         "Return an iterator over the (key, [values]) pairs of a dictionary.")


if PY3:
    def b(s):
        return s.encode("latin-1")

    def u(s):
        return s
    unichr = chr
    import struct
    int2byte = struct.Struct(">B").pack
    del struct
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
    _assertCountEqual = "assertCountEqual"
    if sys.version_info[1] <= 1:
        _assertRaisesRegex = "assertRaisesRegexp"
        _assertRegex = "assertRegexpMatches"
    else:
        _assertRaisesRegex = "assertRaisesRegex"
        _assertRegex = "assertRegex"
else:
    def b(s):
        return s
    # Workaround for standalone backslash

    def u(s):
        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
    unichr = unichr
    int2byte = chr

    def byte2int(bs):
        return ord(bs[0])

    def indexbytes(buf, i):
        return ord(buf[i])
    iterbytes = functools.partial(itertools.imap, ord)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
    _assertCountEqual = "assertItemsEqual"
    _assertRaisesRegex = "assertRaisesRegexp"
    _assertRegex = "assertRegexpMatches"
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


def assertCountEqual(self, *args, **kwargs):
    return getattr(self, _assertCountEqual)(*args, **kwargs)


def assertRaisesRegex(self, *args, **kwargs):
    return getattr(self, _assertRaisesRegex)(*args, **kwargs)


def assertRegex(self, *args, **kwargs):
    return getattr(self, _assertRegex)(*args, **kwargs)


if PY3:
    exec_ = getattr(moves.builtins, "exec")

    def reraise(tp, value, tb=None):
        if value is None:
            value = tp()
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


if sys.version_info[:2] == (3, 2):
    exec_("""def raise_from(value, from_value):
    if from_value is None:
        raise value
    raise value from from_value
""")
elif sys.version_info[:2] > (3, 2):
    exec_("""def raise_from(value, from_value):
    raise value from from_value
""")
else:
    def raise_from(value, from_value):
        raise value


print_ = getattr(moves.builtins, "print", None)
if print_ is None:
    def print_(*args, **kwargs):
        """The new-style print function for Python 2.4 and 2.5."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return

        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            # If the file has an encoding, encode unicode with it.
            if (isinstance(fp, file) and
                    isinstance(data, unicode) and
                    fp.encoding is not None):
                errors = getattr(fp, "errors", None)
                if errors is None:
                    errors = "strict"
                data = data.encode(fp.encoding, errors)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)
if sys.version_info[:2] < (3, 3):
    _print = print_

    def print_(*args, **kwargs):
        fp = kwargs.get("file", sys.stdout)
        flush = kwargs.pop("flush", False)
        _print(*args, **kwargs)
        if flush and fp is not None:
            fp.flush()

_add_doc(reraise, """Reraise an exception.""")

if sys.version_info[0:2] < (3, 4):
    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
              updated=functools.WRAPPER_UPDATES):
        def wrapper(f):
            f = functools.wraps(wrapped, assigned, updated)(f)
            f.__wrapped__ = wrapped
            return f
        return wrapper
else:
    wraps = functools.wraps


def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    # This requires a bit of explanation: the basic idea is to make a dummy
    # metaclass for one level of class instantiation that replaces itself with
    # the actual metaclass.
    class metaclass(meta):

        def __new__(cls, name, this_bases, d):
            return meta(name, bases, d)
    return type.__new__(metaclass, 'temporary_class', (), {})


def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass."""
    def wrapper(cls):
        orig_vars = cls.__dict__.copy()
        slots = orig_vars.get('__slots__')
        if slots is not None:
            if isinstance(slots, str):
                slots = [slots]
            for slots_var in slots:
                orig_vars.pop(slots_var)
        orig_vars.pop('__dict__', None)
        orig_vars.pop('__weakref__', None)
        return metaclass(cls.__name__, cls.__bases__, orig_vars)
    return wrapper


def python_2_unicode_compatible(klass):
    """
    A decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    """
    if PY2:
        if '__str__' not in klass.__dict__:
            raise ValueError("@python_2_unicode_compatible cannot be applied "
                             "to %s because it doesn't define __str__()." %
                             klass.__name__)
        klass.__unicode__ = klass.__str__
        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
    return klass


# Complete the moves implementation.
# This code is at the end of this module to speed up module loading.
# Turn this module into a package.
__path__ = []  # required for PEP 302 and PEP 451
__package__ = __name__  # see PEP 366 @ReservedAssignment
if globals().get("__spec__") is not None:
    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
# Remove other six meta path importers, since they cause problems. This can
# happen if six is removed from sys.modules and then reloaded. (Setuptools does
# this for some reason.)
if sys.meta_path:
    for i, importer in enumerate(sys.meta_path):
        # Here's some real nastiness: Another "instance" of the six module might
        # be floating around. Therefore, we can't use isinstance() to check for
        # the six meta path importer, since the other six instance will have
        # inserted an importer with different class.
        if (type(importer).__name__ == "_SixMetaPathImporter" and
                importer.name == __name__):
            del sys.meta_path[i]
            break
    del i, importer
# Finally, add the importer to the meta path import hook.
sys.meta_path.append(_importer)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
%}XfW                 @   s  d  Z  d1 Z d j e e e   Z d d l Z d d l Z e j d d k Z	 e	 r[ e Z
 e j j d  r d d l Z e j   d d Z e j d  r d	 Z q e j d
  r d Z q d Z n	 e j Z d d d d d d  Z d d d d d d  Z d d d d d d  Z d d d d d d  Z d d d d d d  Z d d d d d d  Z Gd d   d e  Z d d   Z d d    Z d! d"   Z d# d$   Z e d	 k r<y d d l Z e Z Wnr e k
 r;y d d% l  m! Z! e Z WnC e k
 r6y d d l" Z# e Z Wn e k
 r1e Z Yn XYn XYn Xe$ d& k r|d' Z% d( Z& d2 Z' e( d)  e e% e& d* d+ Z) x+ e' D]# Z* e( d, e* e+ e) e*  f  qWe( d-  e e% e&  Z) x+ e' D]# Z* e( d, e* e+ e) e*  f  qWe( d.  e e%  Z) x+ e' D]# Z* e( d, e* e+ e) e*  f  qWe( d/  e e% d0 d Z) x+ e' D]# Z* e( d, e* e+ e) e*  f  qUWd S)3zyUtilities for determining application-specific dirs.

See <http://github.com/ActiveState/appdirs> for details and usage.
          .N   javaZWindowswin32ZMacdarwinZlinux2Fc             C   s'  t  d k r | d k r |  } | r* d p- d } t j j t |   } |  r| d k	 ru t j j | | |   } qt j j | |   } nu t  d k r t j j d  } |  rt j j | |   } n9 t j d t j j d	   } |  rt j j | |   } |  r#| r#t j j | |  } | S)
aJ  Return full path to the user-specific data dir for this application.

        "appname" is the name of application.
            If None, just the system directory is returned.
        "appauthor" (only used on Windows) is the name of the
            appauthor or distributing body for this application. Typically
            it is the owning company name. This falls back to appname. You may
            pass False to disable it.
        "version" is an optional version path element to append to the
            path. You might want to use this if you want multiple versions
            of your app to be able to run independently. If used, this
            would typically be "<major>.<minor>".
            Only applied when appname is present.
        "roaming" (boolean, default False) can be set True to use the Windows
            roaming appdata directory. That means that for users on a Windows
            network setup for roaming profiles, this user data will be
            sync'd on login. See
            <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>
            for a discussion of issues.

    Typical user data directories are:
        Mac OS X:               ~/Library/Application Support/<AppName>
        Unix:                   ~/.local/share/<AppName>    # or in $XDG_DATA_HOME, if defined
        Win XP (not roaming):   C:\Documents and Settings\<username>\Application Data\<AppAuthor>\<AppName>
        Win XP (roaming):       C:\Documents and Settings\<username>\Local Settings\Application Data\<AppAuthor>\<AppName>
        Win 7  (not roaming):   C:\Users\<username>\AppData\Local\<AppAuthor>\<AppName>
        Win 7  (roaming):       C:\Users\<username>\AppData\Roaming\<AppAuthor>\<AppName>

    For Unix, we follow the XDG spec and support $XDG_DATA_HOME.
    That means, by default "~/.local/share/<AppName>".
    r   NCSIDL_APPDATACSIDL_LOCAL_APPDATAFr   z~/Library/Application Support/ZXDG_DATA_HOMEz~/.local/share)systemospathnormpath_get_win_folderjoin
expandusergetenv)appname	appauthorversionroamingZconstr    r   ?/usr/lib/python3/dist-packages/pkg_resources/_vendor/appdirs.pyuser_data_dir-   s&     r   c                s  t  d k r{ | d k r   } t j j t d   }   r]| d k	 rc t j j | |    } q]t j j |    } n t  d k r t j j d  }   r]t j j |    } n t j d t j j d d	 g   } d
 d   | j	 t j  D }   r4| rt j j   |      f d d   | D } | rOt j j |  } n
 | d } | S  r~| r~t j j | |  } | S)ai  Return full path to the user-shared data dir for this application.

        "appname" is the name of application.
            If None, just the system directory is returned.
        "appauthor" (only used on Windows) is the name of the
            appauthor or distributing body for this application. Typically
            it is the owning company name. This falls back to appname. You may
            pass False to disable it.
        "version" is an optional version path element to append to the
            path. You might want to use this if you want multiple versions
            of your app to be able to run independently. If used, this
            would typically be "<major>.<minor>".
            Only applied when appname is present.
        "multipath" is an optional parameter only applicable to *nix
            which indicates that the entire list of data dirs should be
            returned. By default, the first item from XDG_DATA_DIRS is
            returned, or '/usr/local/share/<AppName>',
            if XDG_DATA_DIRS is not set

    Typical user data directories are:
        Mac OS X:   /Library/Application Support/<AppName>
        Unix:       /usr/local/share/<AppName> or /usr/share/<AppName>
        Win XP:     C:\Documents and Settings\All Users\Application Data\<AppAuthor>\<AppName>
        Vista:      (Fail! "C:\ProgramData" is a hidden *system* directory on Vista.)
        Win 7:      C:\ProgramData\<AppAuthor>\<AppName>   # Hidden, but writeable on Win 7.

    For Unix, this is using the $XDG_DATA_DIRS[0] default.

    WARNING: Do not use this on Windows. See the Vista-Fail note above for why.
    r   NCSIDL_COMMON_APPDATAFr   z/Library/Application SupportZXDG_DATA_DIRSz/usr/local/sharez
/usr/sharec             S   s.   g  |  ]$ } t  j j | j t  j    q Sr   )r   r   r   rstripsep).0xr   r   r   
<listcomp>   s   	 z!site_data_dir.<locals>.<listcomp>c                s(   g  |  ] } t  j j |   g   q Sr   )r   r   r   )r   r   )r   r   r   r      s   	 r   )
r   r   r   r   r   r   r   r   pathsepsplit)r   r   r   	multipathr   pathlistr   )r   r   site_data_dird   s4    	
r$   c             C   s   t  d k r$ t |  | d |  } n9 t j d t j j d   } |  r] t j j | |   } |  r~ | r~ t j j | |  } | S)a  Return full path to the user-specific config dir for this application.

        "appname" is the name of application.
            If None, just the system directory is returned.
        "appauthor" (only used on Windows) is the name of the
            appauthor or distributing body for this application. Typically
            it is the owning company name. This falls back to appname. You may
            pass False to disable it.
        "version" is an optional version path element to append to the
            path. You might want to use this if you want multiple versions
            of your app to be able to run independently. If used, this
            would typically be "<major>.<minor>".
            Only applied when appname is present.
        "roaming" (boolean, default False) can be set True to use the Windows
            roaming appdata directory. That means that for users on a Windows
            network setup for roaming profiles, this user data will be
            sync'd on login. See
            <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>
            for a discussion of issues.

    Typical user data directories are:
        Mac OS X:               same as user_data_dir
        Unix:                   ~/.config/<AppName>     # or in $XDG_CONFIG_HOME, if defined
        Win *:                  same as user_data_dir

    For Unix, we follow the XDG spec and support $XDG_CONFIG_HOME.
    That means, by deafult "~/.config/<AppName>".
    r   r   NZXDG_CONFIG_HOMEz	~/.config)r   r   )r   r   r   r   r   r   r   )r   r   r   r   r   r   r   r   user_config_dir   s    r%   c                s   t  d	 k r? t   |  }   r | r t j j | |  } n t j d d  } d d   | j t j  D }   r | r t j j   |      f d d   | D } | r t j j |  } n
 | d } | S)
a  Return full path to the user-shared data dir for this application.

        "appname" is the name of application.
            If None, just the system directory is returned.
        "appauthor" (only used on Windows) is the name of the
            appauthor or distributing body for this application. Typically
            it is the owning company name. This falls back to appname. You may
            pass False to disable it.
        "version" is an optional version path element to append to the
            path. You might want to use this if you want multiple versions
            of your app to be able to run independently. If used, this
            would typically be "<major>.<minor>".
            Only applied when appname is present.
        "multipath" is an optional parameter only applicable to *nix
            which indicates that the entire list of config dirs should be
            returned. By default, the first item from XDG_CONFIG_DIRS is
            returned, or '/etc/xdg/<AppName>', if XDG_CONFIG_DIRS is not set

    Typical user data directories are:
        Mac OS X:   same as site_data_dir
        Unix:       /etc/xdg/<AppName> or $XDG_CONFIG_DIRS[i]/<AppName> for each value in
                    $XDG_CONFIG_DIRS
        Win *:      same as site_data_dir
        Vista:      (Fail! "C:\ProgramData" is a hidden *system* directory on Vista.)

    For Unix, this is using the $XDG_CONFIG_DIRS[0] default, if multipath=False

    WARNING: Do not use this on Windows. See the Vista-Fail note above for why.
    r   r   ZXDG_CONFIG_DIRSz/etc/xdgc             S   s.   g  |  ]$ } t  j j | j t  j    q Sr   )r   r   r   r   r   )r   r   r   r   r   r      s   	 z#site_config_dir.<locals>.<listcomp>c                s(   g  |  ] } t  j j |   g   q Sr   )r   r   r   )r   r   )r   r   r   r      s   	 r   )r   r   )r   r$   r   r   r   r   r!   r    )r   r   r   r"   r   r#   r   )r   r   site_config_dir   s    
r&   Tc             C   s0  t  d k r | d k r |  } t j j t d   } |  r| d k	 rc t j j | | |   } n t j j | |   } | rt j j | d  } nu t  d k r t j j d  } |  rt j j | |   } n9 t j d t j j d	   } |  rt j j | |   } |  r,| r,t j j | |  } | S)
a  Return full path to the user-specific cache dir for this application.

        "appname" is the name of application.
            If None, just the system directory is returned.
        "appauthor" (only used on Windows) is the name of the
            appauthor or distributing body for this application. Typically
            it is the owning company name. This falls back to appname. You may
            pass False to disable it.
        "version" is an optional version path element to append to the
            path. You might want to use this if you want multiple versions
            of your app to be able to run independently. If used, this
            would typically be "<major>.<minor>".
            Only applied when appname is present.
        "opinion" (boolean) can be False to disable the appending of
            "Cache" to the base app data dir for Windows. See
            discussion below.

    Typical user cache directories are:
        Mac OS X:   ~/Library/Caches/<AppName>
        Unix:       ~/.cache/<AppName> (XDG default)
        Win XP:     C:\Documents and Settings\<username>\Local Settings\Application Data\<AppAuthor>\<AppName>\Cache
        Vista:      C:\Users\<username>\AppData\Local\<AppAuthor>\<AppName>\Cache

    On Windows the only suggestion in the MSDN docs is that local settings go in
    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming
    app data dir (the default returned by `user_data_dir` above). Apps typically
    put cache data somewhere *under* the given dir here. Some examples:
        ...\Mozilla\Firefox\Profiles\<ProfileName>\Cache
        ...\Acme\SuperApp\Cache\1.0
    OPINION: This function appends "Cache" to the `CSIDL_LOCAL_APPDATA` value.
    This can be disabled with the `opinion=False` option.
    r   Nr
   FZCacher   z~/Library/CachesZXDG_CACHE_HOMEz~/.cache)r   r   r   r   r   r   r   r   )r   r   r   opinionr   r   r   r   user_cache_dir  s(    !r(   c             C   s   t  d k r0 t j j t j j d  |   } nu t  d k rr t |  | |  } d } | r t j j | d  } n3 t |  | |  } d } | r t j j | d  } |  r | r t j j | |  } | S)a  Return full path to the user-specific log dir for this application.

        "appname" is the name of application.
            If None, just the system directory is returned.
        "appauthor" (only used on Windows) is the name of the
            appauthor or distributing body for this application. Typically
            it is the owning company name. This falls back to appname. You may
            pass False to disable it.
        "version" is an optional version path element to append to the
            path. You might want to use this if you want multiple versions
            of your app to be able to run independently. If used, this
            would typically be "<major>.<minor>".
            Only applied when appname is present.
        "opinion" (boolean) can be False to disable the appending of
            "Logs" to the base app data dir for Windows, and "log" to the
            base cache dir for Unix. See discussion below.

    Typical user cache directories are:
        Mac OS X:   ~/Library/Logs/<AppName>
        Unix:       ~/.cache/<AppName>/log  # or under $XDG_CACHE_HOME if defined
        Win XP:     C:\Documents and Settings\<username>\Local Settings\Application Data\<AppAuthor>\<AppName>\Logs
        Vista:      C:\Users\<username>\AppData\Local\<AppAuthor>\<AppName>\Logs

    On Windows the only suggestion in the MSDN docs is that local settings
    go in the `CSIDL_LOCAL_APPDATA` directory. (Note: I'm interested in
    examples of what some windows apps use for a logs dir.)

    OPINION: This function appends "Logs" to the `CSIDL_LOCAL_APPDATA`
    value for Windows and appends "log" to the user cache dir for Unix.
    This can be disabled with the `opinion=False` option.
    r   z~/Library/Logsr   FZLogslog)r   r   r   r   r   r   r(   )r   r   r   r'   r   r   r   r   user_log_dir:  s      	r*   c               @   s   e  Z d  Z d Z d d d d d d  Z e d d    Z e d d	    Z e d
 d    Z e d d    Z	 e d d    Z
 e d d    Z d S)AppDirsz1Convenience wrapper for getting application dirs.NFc             C   s1   | |  _  | |  _ | |  _ | |  _ | |  _ d  S)N)r   r   r   r   r"   )selfr   r   r   r   r"   r   r   r   __init__o  s
    				zAppDirs.__init__c             C   s%   t  |  j |  j d |  j d |  j S)Nr   r   )r   r   r   r   r   )r,   r   r   r   r   w  s    zAppDirs.user_data_dirc             C   s%   t  |  j |  j d |  j d |  j S)Nr   r"   )r$   r   r   r   r"   )r,   r   r   r   r$   |  s    zAppDirs.site_data_dirc             C   s%   t  |  j |  j d |  j d |  j S)Nr   r   )r%   r   r   r   r   )r,   r   r   r   r%     s    zAppDirs.user_config_dirc             C   s%   t  |  j |  j d |  j d |  j S)Nr   r"   )r&   r   r   r   r"   )r,   r   r   r   r&     s    zAppDirs.site_config_dirc             C   s   t  |  j |  j d |  j S)Nr   )r(   r   r   r   )r,   r   r   r   r(     s    zAppDirs.user_cache_dirc             C   s   t  |  j |  j d |  j S)Nr   )r*   r   r   r   )r,   r   r   r   r*     s    zAppDirs.user_log_dir)__name__
__module____qualname____doc__r-   propertyr   r$   r%   r&   r(   r*   r   r   r   r   r+   m  s   	r+   c             C   sY   d d l  } d d d d d d i |  } | j | j d	  } | j | |  \ } } | S)
zThis is a fallback technique at best. I'm not sure if using the
    registry for this guarantees us the correct answer for all CSIDL_*
    names.
    r   Nr	   ZAppDatar   zCommon AppDatar
   zLocal AppDataz@Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders)_winregOpenKeyHKEY_CURRENT_USERZQueryValueEx)
csidl_namer3   Zshell_folder_namekeydirtyper   r   r   _get_win_folder_from_registry  s    		r:   c             C   s   d d l  m } m } | j d t | |   d d  } yz t |  } d } x' | D] } t |  d k rS d } PqS W| r y d d  l } | j |  } Wn t	 k
 r Yn XWn t
 k
 r Yn X| S)Nr   )shellconshellF   T)win32com.shellr;   r<   SHGetFolderPathgetattrunicodeordwin32apiGetShortPathNameImportErrorUnicodeError)r6   r;   r<   r8   has_high_charcrC   r   r   r   _get_win_folder_with_pywin32  s$    !	rI   c             C   s   d d  l  } d d d d d d i |  } | j d  } | j j j d  | d  d |  d	 } x' | D] } t |  d
 k rc d } Pqc W| r | j d  } | j j j | j | d  r | } | j S)Nr   r	      r   #   r
      i   Fr=   T)	ctypesZcreate_unicode_bufferwindllZshell32ZSHGetFolderPathWrB   Zkernel32ZGetShortPathNameWvalue)r6   rM   Zcsidl_constbufrG   rH   Zbuf2r   r   r   _get_win_folder_with_ctypes  s"    	rQ   c             C   s4  d d  l  } d d l m } d d l m } | j j d } | j d |  } | j j	 } | j
 d  t | j |   d  | j j |  | j j | j    j d  } d } x' | D] }	 t |	  d k r d	 } Pq W| r0| j d |  } | j j	 }
 t j | | |  r0| j j | j    j d  } | S)
Nr   )jna)r      rH    Fr=   T)arrayZcom.sunrR   Zcom.sun.jna.platformr   ZWinDefZMAX_PATHZzerosZShell32ZINSTANCEr?   r@   ZShlObjZSHGFP_TYPE_CURRENTZNativeZtoStringZtostringr   rB   ZKernel32ZkernalrD   )r6   rU   rR   r   Zbuf_sizerP   r<   r8   rG   rH   Zkernelr   r   r   _get_win_folder_with_jna  s&    +!!rV   )rN   __main__ZMyAppZ	MyCompanyz%-- app dirs (with optional 'version')r   z1.0z%s: %sz)
-- app dirs (without optional 'version')z+
-- app dirs (without optional 'appauthor')z(
-- app dirs (with disabled 'appauthor')r   )r   r   r   )r   r$   r%   r&   r(   r*   ),r1   Z__version_info__r   mapstr__version__sysr   version_infoZPY3rA   platform
startswithZjava_verZos_namer   r   r$   r%   r&   r(   r*   objectr+   r:   rI   rQ   rV   r>   Zwin32comr   rE   rM   rN   Zcom.sun.jnaZcomr.   r   r   ZpropsprintdirsZpropr@   r   r   r   r   <module>	   s~   				7B(393+


  
!
!
!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
%}X                @   s  d  Z  d Z d Z d Z d d l Z d d l m Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z y d d l m Z Wn" e k
 r d d l m Z Yn Xy d d	 l m Z WnA e k
 r@y d d	 l m Z Wn e k
 r;d Z Yn XYn Xd
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF dG dH dI dJ dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr gi Z e e	 j  d ds  Z e d ds k Z e re	 j Z e  Z! e" Z# e  Z$ e% e& e' e( e) e e* e+ e, e- e. g Z/ nv e	 j0 Z e1 Z2 dt du   Z$ g  Z/ d d l3 Z3 xF dv j4   D]8 Z5 y e/ j6 e7 e3 e5   Wn e8 k
 rgw0Yn Xq0We9 dw dx   e2 dy  D  Z: dz d{   Z; Gd| d}   d} e<  Z= e j> e j? Z@ d~ ZA eA d ZB e@ eA ZC e" d  ZD d jE d dx   e jF D  ZG Gd d!   d! eH  ZI Gd d#   d# eI  ZJ Gd d%   d% eI  ZK Gd d'   d' eK  ZL Gd d*   d* eH  ZM Gd d   d e<  ZN Gd d&   d& e<  ZO e jP jQ eO  d d=   ZR d dN   ZS d dK   ZT d d   ZU d d   ZV d d   ZW d dU   ZX d d d  ZY Gd d(   d( e<  ZZ Gd d0   d0 eZ  Z[ Gd d   d e[  Z\ Gd d   d e[  Z] Gd d   d e[  Z^ e^ Z_ e^ eZ _` Gd d   d e[  Za Gd d   d e^  Zb Gd d   d ea  Zc Gd dp   dp e[  Zd Gd d3   d3 e[  Ze Gd d+   d+ e[  Zf Gd d)   d) e[  Zg Gd d   d e[  Zh Gd d2   d2 e[  Zi Gd d   d e[  Zj Gd d   d ej  Zk Gd d   d ej  Zl Gd d   d ej  Zm Gd d.   d. ej  Zn Gd d-   d- ej  Zo Gd d5   d5 ej  Zp Gd d4   d4 ej  Zq Gd d$   d$ eZ  Zr Gd d
   d
 er  Zs Gd d    d  er  Zt Gd d   d er  Zu Gd d   d er  Zv Gd d"   d" eZ  Zw Gd d   d ew  Zx Gd d   d ew  Zy Gd d   d ew  Zz Gd d   d ez  Z{ Gd d6   d6 ez  Z| Gd d   d e<  Z} e}   Z~ Gd d   d ew  Z Gd d,   d, ew  Z Gd d   d ew  Z Gd d   d e  Z Gd d1   d1 ew  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d/   d/ e  Z Gd d   d e<  Z d df   Z d d d dD  Z d d d@  Z d d   Z d dS   Z d dR   Z d d   Z d d d dW  Z d dE   Z d d dk  Z d dl   Z d dn   Z e\   j dG  Z el   j dM  Z em   j dL  Z en   j de  Z eo   j dd  Z ee eD d d d j d d    Z ef d  j d d    Z ef d  j d d    Z e e Be Bee eG d d d dy Bef d e j  BZ e e e d  e  Z e^ d  e d  j d  e e{ e e B  j d  d Z d dc   Z d dQ   Z d d`   Z d d^   Z d dq   Z e d d    Z e d d    Z d d   Z d dO   Z d dP   Z d di   Z e<   e _ d d do  Z e=   Z e<   e _ e<   e _ e d  e d  d dm  Z e Z e ef d  d  j d  Z e ef d  d  j d  Z e ef d  d ef d  d B j d  Z e e_ d e j    j d Z d d d e j   ddT  Z d ddj  Z e d Z e d Z e ee e@ eC d j d  \ Z Z e e d	j4   d
  Z ef ddjE e j    d j d Z dd_   Z e ef d d j d Z ef d j d Z ef d j   j d Z ef d j d Z e ef d de B j d Z e Z ef d j d Z e e{ ee eG d d e ee d e^ d  em      j   j d Z e e e j   e Bdd  j d>  Z Gddr   dr  Z e d k reb d! Z eb d" Z ee e@ eC d# Z e e d$d%d j e  Z e e e   j d& Z d'e BZ e e d$d%d j e  Z e e e   j d( Z e d) e d& e e d( Z e j d* e j j d+ e j j d+ e j j d, d d l Z e j j e e j   e j j d- d S(.  aS  
pyparsing module - Classes and methods to define and execute parsing grammars

The pyparsing module is an alternative approach to creating and executing simple grammars,
vs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you
don't need to learn a new syntax for defining grammars or matching expressions - the parsing module
provides a library of classes that you use to construct the grammar directly in Python.

Here is a program to parse "Hello, World!" (or any greeting of the form 
C{"<salutation>, <addressee>!"}), built up using L{Word}, L{Literal}, and L{And} elements 
(L{'+'<ParserElement.__add__>} operator gives L{And} expressions, strings are auto-converted to
L{Literal} expressions)::

    from pyparsing import Word, alphas

    # define grammar of a greeting
    greet = Word(alphas) + "," + Word(alphas) + "!"

    hello = "Hello, World!"
    print (hello, "->", greet.parseString(hello))

The program outputs the following::

    Hello, World! -> ['Hello', ',', 'World', '!']

The Python representation of the grammar is quite readable, owing to the self-explanatory
class names, and the use of '+', '|' and '^' operators.

The L{ParseResults} object returned from L{ParserElement.parseString<ParserElement.parseString>} can be accessed as a nested list, a dictionary, or an
object with named attributes.

The pyparsing module handles some of the problems that are typically vexing when writing text parsers:
 - extra or missing whitespace (the above program will also handle "Hello,World!", "Hello  ,  World  !", etc.)
 - quoted strings
 - embedded comments
z2.1.10z07 Oct 2016 01:31 UTCz*Paul McGuire <ptmcg@users.sourceforge.net>    N)ref)datetime)RLock)OrderedDictAndCaselessKeywordCaselessLiteral
CharsNotInCombineDictEachEmpty
FollowedByForward
GoToColumnGroupKeywordLineEnd	LineStartLiteral
MatchFirstNoMatchNotAny	OneOrMoreOnlyOnceOptionalOrParseBaseExceptionParseElementEnhanceParseExceptionParseExpressionParseFatalExceptionParseResultsParseSyntaxExceptionParserElementQuotedStringRecursiveGrammarExceptionRegexSkipTo	StringEndStringStartSuppressTokenTokenConverterWhiteWordWordEnd	WordStart
ZeroOrMore	alphanumsalphas
alphas8bitanyCloseTag
anyOpenTagcStyleCommentcolcommaSeparatedListcommonHTMLEntitycountedArraycppStyleCommentdblQuotedStringdblSlashCommentdelimitedListdictOfdowncaseTokensemptyhexnumshtmlCommentjavaStyleCommentlinelineEnd	lineStartlinenomakeHTMLTagsmakeXMLTagsmatchOnlyAtColmatchPreviousExprmatchPreviousLiteral
nestedExprnullDebugActionnumsoneOfopAssocoperatorPrecedence
printablespunc8bitpythonStyleCommentquotedStringremoveQuotesreplaceHTMLEntityreplaceWith
restOfLinesglQuotedStringsrange	stringEndstringStarttraceParseActionunicodeStringupcaseTokenswithAttributeindentedBlockoriginalTextForungroupinfixNotationlocatedExpr	withClass
CloseMatchtokenMappyparsing_common   c             C   s   t  |  t  r |  Sy t |   SWn\ t k
 r t |   j t j   d  } t d  } | j d d    | j	 |  SYn Xd S)a  Drop-in replacement for str(obj) that tries to be Unicode friendly. It first tries
           str(obj). If that fails with a UnicodeEncodeError, then it tries unicode(obj). It
           then < returns the unicode object | encodes it with the default encoding | ... >.
        xmlcharrefreplacez&#\d+;c             S   s,   d t  t |  d d d    d d   S)Nz\ur         )hexint)t rw   A/usr/lib/python3/dist-packages/pkg_resources/_vendor/pyparsing.py<lambda>   s    z_ustr.<locals>.<lambda>N)

isinstanceZunicodestrUnicodeEncodeErrorencodesysgetdefaultencodingr'   setParseActiontransformString)objretZ
xmlcharrefrw   rw   rx   _ustr   s    r   z6sum len sorted reversed list tuple set any all min maxc             c   s   |  ] } | Vq d  S)Nrw   ).0yrw   rw   rx   	<genexpr>   s    r   rr   c             C   sU   d } d d   d j    D } x/ t | |  D] \ } } |  j | |  }  q/ W|  S)z/Escape &, <, >, ", ', etc. in a string of data.z&><"'c             s   s   |  ] } d  | d Vq d S)&;Nrw   )r   srw   rw   rx   r      s    z_xml_escape.<locals>.<genexpr>zamp gt lt quot apos)splitzipreplace)dataZfrom_symbolsZ
to_symbolsZfrom_Zto_rw   rw   rx   _xml_escape   s
    r   c               @   s   e  Z d  Z d S)
_ConstantsN)__name__
__module____qualname__rw   rw   rw   rx   r      s   r   
0123456789ZABCDEFabcdef\    c             c   s$   |  ] } | t  j k r | Vq d  S)N)stringZ
whitespace)r   crw   rw   rx   r      s    c               @   s|   e  Z d  Z d Z d d d d d  Z e d d    Z d d	   Z d
 d   Z d d   Z	 d d d  Z
 d d   Z d S)r   z7base exception class for all parsing runtime exceptionsr   Nc             C   s[   | |  _  | d  k r* | |  _ d |  _ n | |  _ | |  _ | |  _ | | | f |  _ d  S)Nr   )locmsgpstrparserElementargs)selfr   r   r   elemrw   rw   rx   __init__   s    					zParseBaseException.__init__c             C   s   |  | j  | j | j | j  S)z
        internal factory method to simplify creating one type of ParseException 
        from another - avoids having __init__ signature conflicts among subclasses
        )r   r   r   r   )clsperw   rw   rx   _from_exception   s    z"ParseBaseException._from_exceptionc             C   sm   | d k r t  |  j |  j  S| d k r> t |  j |  j  S| d k r] t |  j |  j  St |   d S)zsupported attributes by name are:
            - lineno - returns the line number of the exception text
            - col - returns the column number of the exception text
            - line - returns the line containing the exception text
        rJ   r9   columnrG   N)r9   r   )rJ   r   r   r9   rG   AttributeError)r   Zanamerw   rw   rx   __getattr__   s    zParseBaseException.__getattr__c             C   s    d |  j  |  j |  j |  j f S)Nz"%s (at char %d), (line:%d, col:%d))r   r   rJ   r   )r   rw   rw   rx   __str__   s    zParseBaseException.__str__c             C   s
   t  |   S)N)r   )r   rw   rw   rx   __repr__   s    zParseBaseException.__repr__z>!<c             C   sR   |  j  } |  j d } | rH d j | d |  | | | d  f  } | j   S)zExtracts the exception line from the input string, and marks
           the location of the exception with a special symbol.
        rr   r   N)rG   r   joinstrip)r   ZmarkerStringZline_strZline_columnrw   rw   rx   markInputline   s    	z ParseBaseException.markInputlinec             C   s   d j    t t |    S)Nzlineno col line)r   dirtype)r   rw   rw   rx   __dir__   s    zParseBaseException.__dir__)r   r   r   __doc__r   classmethodr   r   r   r   r   r   rw   rw   rw   rx   r      s   
c               @   s   e  Z d  Z d Z d S)r   aN  
    Exception thrown when parse expressions don't match class;
    supported attributes by name are:
     - lineno - returns the line number of the exception text
     - col - returns the column number of the exception text
     - line - returns the line containing the exception text
        
    Example::
        try:
            Word(nums).setName("integer").parseString("ABC")
        except ParseException as pe:
            print(pe)
            print("column: {}".format(pe.col))
            
    prints::
       Expected integer (at char 0), (line:1, col:1)
        column: 1
    N)r   r   r   r   rw   rw   rw   rx   r      s   c               @   s   e  Z d  Z d Z d S)r!   znuser-throwable exception thrown when inconsistent parse content
       is found; stops all parsing immediatelyN)r   r   r   r   rw   rw   rw   rx   r!     s   c               @   s   e  Z d  Z d Z d S)r#   zjust like L{ParseFatalException}, but thrown internally when an
       L{ErrorStop<And._ErrorStop>} ('-' operator) indicates that parsing is to stop 
       immediately because an unbacktrackable syntax error has been foundN)r   r   r   r   rw   rw   rw   rx   r#     s   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)r&   zZexception thrown by L{ParserElement.validate} if the grammar could be improperly recursivec             C   s   | |  _  d  S)N)parseElementTrace)r   parseElementListrw   rw   rx   r     s    z"RecursiveGrammarException.__init__c             C   s   d |  j  S)NzRecursiveGrammarException: %s)r   )r   rw   rw   rx   r      s    z!RecursiveGrammarException.__str__N)r   r   r   r   r   r   rw   rw   rw   rx   r&     s   c               @   s@   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 S)
_ParseResultsWithOffsetc             C   s   | | f |  _  d  S)N)tup)r   Zp1Zp2rw   rw   rx   r   $  s    z _ParseResultsWithOffset.__init__c             C   s   |  j  | S)N)r   )r   irw   rw   rx   __getitem__&  s    z#_ParseResultsWithOffset.__getitem__c             C   s   t  |  j d  S)Nr   )reprr   )r   rw   rw   rx   r   (  s    z _ParseResultsWithOffset.__repr__c             C   s   |  j  d | f |  _  d  S)Nr   )r   )r   r   rw   rw   rx   	setOffset*  s    z!_ParseResultsWithOffset.setOffsetN)r   r   r   r   r   r   r   rw   rw   rw   rx   r   #  s   r   c               @   sz  e  Z d  Z d Z d d d d d d  Z d d d d e d d  Z d d	   Z e d
 d  Z d d   Z	 d d   Z
 d d   Z d d   Z e Z d d   Z d d   Z d d   Z d d   Z d d   Z e r e Z e Z e Z n6 e Z e Z e Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& d'   Z d d( d)  Z d* d+   Z d, d-   Z d. d/   Z d0 d1   Z  d2 d3   Z! d4 d5   Z" d6 d7   Z# d8 d9   Z$ d: d;   Z% d< d=   Z& d> d? d@  Z' dA dB   Z( dC dD   Z) dE dF   Z* d dG d> d dH dI  Z+ dJ dK   Z, dL dM   Z- d> dN d dO dP  Z. dQ dR   Z/ dS dT   Z0 dU dV   Z1 dW dX   Z2 dY dZ   Z3 d S)[r"   aI  
    Structured parse results, to provide multiple means of access to the parsed data:
       - as a list (C{len(results)})
       - by list index (C{results[0], results[1]}, etc.)
       - by attribute (C{results.<resultsName>} - see L{ParserElement.setResultsName})

    Example::
        integer = Word(nums)
        date_str = (integer.setResultsName("year") + '/' 
                        + integer.setResultsName("month") + '/' 
                        + integer.setResultsName("day"))
        # equivalent form:
        # date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

        # parseString returns a ParseResults object
        result = date_str.parseString("1999/12/31")

        def test(s, fn=repr):
            print("%s -> %s" % (s, fn(eval(s))))
        test("list(result)")
        test("result[0]")
        test("result['month']")
        test("result.day")
        test("'month' in result")
        test("'minutes' in result")
        test("result.dump()", str)
    prints::
        list(result) -> ['1999', '/', '12', '/', '31']
        result[0] -> '1999'
        result['month'] -> '12'
        result.day -> '31'
        'month' in result -> True
        'minutes' in result -> False
        result.dump() -> ['1999', '/', '12', '/', '31']
        - day: 31
        - month: 12
        - year: 1999
    NTc             C   s/   t  | |   r | St j |   } d | _ | S)NT)rz   object__new___ParseResults__doinit)r   toklistnameasListmodalZretobjrw   rw   rx   r   T  s
    	zParseResults.__new__c             C   s  |  j  r d |  _  d  |  _ d  |  _ i  |  _ | |  _ | |  _ | d  k rQ g  } | | t  rv | d  d   |  _ n- | | t  r t |  |  _ n | g |  _ t	   |  _
 | d  k	 r| r| s d |  j | <| | t  r t |  } | |  _ | | t d   t t f  o(| d  d g  f k s| | t  rC| g } | r| | t  rtt | j   d  |  | <n t t | d  d  |  | <| |  | _ n: y | d |  | <Wn% t t t f k
 r| |  | <Yn Xd  S)NFr   r   )r   _ParseResults__name_ParseResults__parent_ParseResults__accumNames_ParseResults__asList_ParseResults__modallist_ParseResults__toklist_generatorTypedict_ParseResults__tokdictru   r   r   
basestringr"   r   copyKeyError	TypeError
IndexError)r   r   r   r   r   rz   rw   rw   rx   r   ]  sB    								3	zParseResults.__init__c             C   sd   t  | t t f  r  |  j | S| |  j k rB |  j | d d St d d   |  j | D  Sd  S)Nrr   r   c             S   s   g  |  ] } | d   q S)r   rw   )r   vrw   rw   rx   
<listcomp>  s   	 z,ParseResults.__getitem__.<locals>.<listcomp>rs   )rz   ru   slicer   r   r   r"   )r   r   rw   rw   rx   r     s
    zParseResults.__getitem__c             C   s   | | t   rB |  j j | t    | g |  j | <| d } n` | | t t f  rm | |  j | <| } n5 |  j j | t    t  | d  g |  j | <| } | | t  r t |   | _	 d  S)Nr   )
r   r   getr   ru   r   r   r"   wkrefr   )r   kr   rz   subrw   rw   rx   __setitem__  s    &	/zParseResults.__setitem__c       
      C   s  t  | t t f  r t |  j  } |  j | =t  | t  rf | d k  rS | | 7} t | | d  } t t | j |     } | j   x{ |  j	 j
   D]] \ } } xN | D]F } x= t |  D]/ \ } \ } }	 t | |	 |	 | k  | | <q Wq Wq Wn
 |  j	 | =d  S)Nr   rr   )rz   ru   r   lenr   r   rangeindicesreverser   items	enumerater   )
r   r   ZmylenZremovedr   occurrencesjr   valuepositionrw   rw   rx   __delitem__  s    


,zParseResults.__delitem__c             C   s   | |  j  k S)N)r   )r   r   rw   rw   rx   __contains__  s    zParseResults.__contains__c             C   s   t  |  j  S)N)r   r   )r   rw   rw   rx   __len__  s    zParseResults.__len__c             C   s	   |  j  S)N)r   )r   rw   rw   rx   __bool__  s    zParseResults.__bool__c             C   s   t  |  j  S)N)iterr   )r   rw   rw   rx   __iter__  s    zParseResults.__iter__c             C   s   t  |  j d  d  d   S)Nrr   rs   )r   r   )r   rw   rw   rx   __reversed__  s    zParseResults.__reversed__c             C   s0   t  |  j d  r |  j j   St |  j  Sd  S)Niterkeys)hasattrr   r   r   )r   rw   rw   rx   	_iterkeys  s    zParseResults._iterkeysc                s     f d d     j    D S)Nc             3   s   |  ] }   | Vq d  S)Nrw   )r   r   )r   rw   rx   r     s    z+ParseResults._itervalues.<locals>.<genexpr>)r   )r   rw   )r   rx   _itervalues  s    zParseResults._itervaluesc                s     f d d     j    D S)Nc             3   s   |  ] } |   | f Vq d  S)Nrw   )r   r   )r   rw   rx   r     s    z*ParseResults._iteritems.<locals>.<genexpr>)r   )r   rw   )r   rx   
_iteritems  s    zParseResults._iteritemsc             C   s   t  |  j    S)zVReturns all named result keys (as a list in Python 2.x, as an iterator in Python 3.x).)r   r   )r   rw   rw   rx   keys  s    zParseResults.keysc             C   s   t  |  j    S)zXReturns all named result values (as a list in Python 2.x, as an iterator in Python 3.x).)r   
itervalues)r   rw   rw   rx   values  s    zParseResults.valuesc             C   s   t  |  j    S)zfReturns all named result key-values (as a list of tuples in Python 2.x, as an iterator in Python 3.x).)r   	iteritems)r   rw   rw   rx   r     s    zParseResults.itemsc             C   s   t  |  j  S)zSince keys() returns an iterator, this method is helpful in bypassing
           code that looks for the existence of any defined results names.)boolr   )r   rw   rw   rx   haskeys  s    zParseResults.haskeysc             O   s   | s d g } xI | j    D]; \ } } | d k rG | d | f } q t d |   q Wt | d t  s t |  d k s | d |  k r | d } |  | } |  | =| S| d } | Sd S)a  
        Removes and returns item at specified index (default=C{last}).
        Supports both C{list} and C{dict} semantics for C{pop()}. If passed no
        argument or an integer argument, it will use C{list} semantics
        and pop tokens from the list of parsed tokens. If passed a 
        non-integer argument (most likely a string), it will use C{dict}
        semantics and pop the corresponding value from any defined 
        results names. A second default return value argument is 
        supported, just as in C{dict.pop()}.

        Example::
            def remove_first(tokens):
                tokens.pop(0)
            print(OneOrMore(Word(nums)).parseString("0 123 321")) # -> ['0', '123', '321']
            print(OneOrMore(Word(nums)).addParseAction(remove_first).parseString("0 123 321")) # -> ['123', '321']

            label = Word(alphas)
            patt = label("LABEL") + OneOrMore(Word(nums))
            print(patt.parseString("AAB 123 321").dump())

            # Use pop() in a parse action to remove named result (note that corresponding value is not
            # removed from list form of results)
            def remove_LABEL(tokens):
                tokens.pop("LABEL")
                return tokens
            patt.addParseAction(remove_LABEL)
            print(patt.parseString("AAB 123 321").dump())
        prints::
            ['AAB', '123', '321']
            - LABEL: AAB

            ['AAB', '123', '321']
        rr   defaultr   z-pop() got an unexpected keyword argument '%s'Nrs   )r   r   rz   ru   r   )r   r   kwargsr   r   indexr   Zdefaultvaluerw   rw   rx   pop  s    "	


zParseResults.popc             C   s   | |  k r |  | S| Sd S)ai  
        Returns named result matching the given key, or if there is no
        such name, then returns the given C{defaultValue} or C{None} if no
        C{defaultValue} is specified.

        Similar to C{dict.get()}.
        
        Example::
            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           

            result = date_str.parseString("1999/12/31")
            print(result.get("year")) # -> '1999'
            print(result.get("hour", "not specified")) # -> 'not specified'
            print(result.get("hour")) # -> None
        Nrw   )r   keydefaultValuerw   rw   rx   r     s    zParseResults.getc             C   sw   |  j  j | |  x] |  j j   D]L \ } } x= t |  D]/ \ } \ } } t | | | | k  | | <q< Wq# Wd S)a  
        Inserts new element at location index in the list of parsed tokens.
        
        Similar to C{list.insert()}.

        Example::
            print(OneOrMore(Word(nums)).parseString("0 123 321")) # -> ['0', '123', '321']

            # use a parse action to insert the parse location in the front of the parsed results
            def insert_locn(locn, tokens):
                tokens.insert(0, locn)
            print(OneOrMore(Word(nums)).addParseAction(insert_locn).parseString("0 123 321")) # -> [0, '0', '123', '321']
        N)r   insertr   r   r   r   )r   r   ZinsStrr   r   r   r   r   rw   rw   rx   r   2  s    zParseResults.insertc             C   s   |  j  j |  d S)a  
        Add single element to end of ParseResults list of elements.

        Example::
            print(OneOrMore(Word(nums)).parseString("0 123 321")) # -> ['0', '123', '321']
            
            # use a parse action to compute the sum of the parsed integers, and add it to the end
            def append_sum(tokens):
                tokens.append(sum(map(int, tokens)))
            print(OneOrMore(Word(nums)).addParseAction(append_sum).parseString("0 123 321")) # -> ['0', '123', '321', 444]
        N)r   append)r   itemrw   rw   rx   r   F  s    zParseResults.appendc             C   s0   t  | t  r |  | 7}  n |  j j |  d S)a  
        Add sequence of elements to end of ParseResults list of elements.

        Example::
            patt = OneOrMore(Word(alphas))
            
            # use a parse action to append the reverse of the matched strings, to make a palindrome
            def make_palindrome(tokens):
                tokens.extend(reversed([t[::-1] for t in tokens]))
                return ''.join(tokens)
            print(patt.addParseAction(make_palindrome).parseString("lskdj sdlkjf lksd")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'
        N)rz   r"   r   extend)r   Zitemseqrw   rw   rx   r   T  s    zParseResults.extendc             C   s!   |  j  d d  =|  j j   d S)z7
        Clear all elements and results names.
        N)r   r   clear)r   rw   rw   rx   r   f  s    zParseResults.clearc             C   s   y |  | SWn t  k
 r$ d SYn X| |  j k rw | |  j k rV |  j | d d St d d   |  j | D  Sn d Sd  S)Nr   rr   r   c             S   s   g  |  ] } | d   q S)r   rw   )r   r   rw   rw   rx   r   w  s   	 z,ParseResults.__getattr__.<locals>.<listcomp>rs   )r   r   r   r"   )r   r   rw   rw   rx   r   m  s    	!zParseResults.__getattr__c             C   s   |  j    } | | 7} | S)N)r   )r   otherr   rw   rw   rx   __add__{  s    
zParseResults.__add__c                s   | j  r t |  j    f d d     | j  j   }   f d d   | D } xD | D]< \ } } | |  | <t | d t  rY t |   | d _ qY W|  j | j 7_ |  j j	 | j  |  S)Nc                s   |  d k  r   S|    S)Nr   rw   )a)offsetrw   rx   ry     s    z'ParseResults.__iadd__.<locals>.<lambda>c          	      sF   g  |  ]< \ } } | D]) } | t  | d    | d   f  q q S)r   rr   )r   )r   r   vlistr   )	addoffsetrw   rx   r     s   	z)ParseResults.__iadd__.<locals>.<listcomp>r   )
r   r   r   r   rz   r"   r   r   r   update)r   r   Z
otheritemsZotherdictitemsr   r   rw   )r  r  rx   __iadd__  s    	

zParseResults.__iadd__c             C   s1   t  | t  r% | d k r% |  j   S| |  Sd  S)Nr   )rz   ru   r   )r   r   rw   rw   rx   __radd__  s    
zParseResults.__radd__c             C   s    d t  |  j  t  |  j  f S)Nz(%s, %s))r   r   r   )r   rw   rw   rx   r     s    zParseResults.__repr__c             C   s%   d d j  d d   |  j D  d S)N[z, c             s   s6   |  ], } t  | t  r$ t |  n	 t |  Vq d  S)N)rz   r"   r   r   )r   r   rw   rw   rx   r     s    z'ParseResults.__str__.<locals>.<genexpr>])r   r   )r   rw   rw   rx   r     s    zParseResults.__str__r   c             C   sl   g  } x_ |  j  D]T } | r/ | r/ | j |  t | t  rQ | | j   7} q | j t |   q W| S)N)r   r   rz   r"   _asStringListr   )r   sepoutr   rw   rw   rx   r	    s    zParseResults._asStringListc             C   s   d d   |  j  D S)a  
        Returns the parse results as a nested list of matching tokens, all converted to strings.

        Example::
            patt = OneOrMore(Word(alphas))
            result = patt.parseString("sldkj lsdkj sldkj")
            # even though the result prints in string-like form, it is actually a pyparsing ParseResults
            print(type(result), result) # -> <class 'pyparsing.ParseResults'> ['sldkj', 'lsdkj', 'sldkj']
            
            # Use asList() to create an actual list
            result_list = result.asList()
            print(type(result_list), result_list) # -> <class 'list'> ['sldkj', 'lsdkj', 'sldkj']
        c             S   s1   g  |  ]' } t  | t  r' | j   n |  q Srw   )rz   r"   r   )r   resrw   rw   rx   r     s   	 z'ParseResults.asList.<locals>.<listcomp>)r   )r   rw   rw   rx   r     s    zParseResults.asListc                sM   t  r |  j } n	 |  j }   f d d     t   f d d   |   D  S)a  
        Returns the named parse results as a nested dictionary.

        Example::
            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
            
            result = date_str.parseString('12/31/1999')
            print(type(result), repr(result)) # -> <class 'pyparsing.ParseResults'> (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})
            
            result_dict = result.asDict()
            print(type(result_dict), repr(result_dict)) # -> <class 'dict'> {'day': '1999', 'year': '12', 'month': '31'}

            # even though a ParseResults supports dict-like access, sometime you just need to have a dict
            import json
            print(json.dumps(result)) # -> Exception: TypeError: ... is not JSON serializable
            print(json.dumps(result.asDict())) # -> {"month": "31", "day": "1999", "year": "12"}
        c                sG   t  |  t  r? |  j   r% |  j   S  f d d   |  D Sn |  Sd  S)Nc                s   g  |  ] }   |   q Srw   rw   )r   r   )toItemrw   rx   r     s   	 z7ParseResults.asDict.<locals>.toItem.<locals>.<listcomp>)rz   r"   r   asDict)r   )r  rw   rx   r    s
    
z#ParseResults.asDict.<locals>.toItemc             3   s'   |  ] \ } } |   |  f Vq d  S)Nrw   )r   r   r   )r  rw   rx   r     s    z&ParseResults.asDict.<locals>.<genexpr>)PY_3r   r   r   )r   Zitem_fnrw   )r  rx   r    s
    		zParseResults.asDictc             C   sP   t  |  j  } |  j j   | _ |  j | _ | j j |  j  |  j | _ | S)zA
        Returns a new copy of a C{ParseResults} object.
        )r"   r   r   r   r   r   r  r   )r   r   rw   rw   rx   r     s    zParseResults.copyFc             C   s  d } g  } t  d d   |  j j   D  } | d } | sP d } d } d } d }	 | d k	 rk | }	 n |  j r} |  j }	 |	 s | r d Sd }	 | | | d |	 d	 g 7} xt |  j  D] \ }
 } t | t  rC|
 | k r| | j | |
 | o| d k | |  g 7} q| | j d | o0| d k | |  g 7} q d } |
 | k r_| |
 } | sw| rqq n d } t	 t
 |   } | | | d | d	 | d
 | d	 g	 7} q W| | | d
 |	 d	 g 7} d j |  S)z
        (Deprecated) Returns the parse results as XML. Tags are created for tokens and lists that have defined results names.
        
c             s   s2   |  ]( \ } } | D] } | d  | f Vq q d S)rr   Nrw   )r   r   r  r   rw   rw   rx   r     s    	z%ParseResults.asXML.<locals>.<genexpr>z  r   NZITEM<>z</)r   r   r   r   r   r   rz   r"   asXMLr   r   r   )r   ZdoctagZnamedItemsOnlyindentZ	formattednlr  Z
namedItemsZnextLevelIndentZselfTagr   r  ZresTagZxmlBodyTextrw   rw   rx   r    sT    "
			
zParseResults.asXMLc             C   sK   xD |  j  j   D]3 \ } } x$ | D] \ } } | | k r# | Sq# Wq Wd  S)N)r   r   )r   r   r   r  r   r   rw   rw   rx   Z__lookup$  s
    zParseResults.__lookupc             C   s   |  j  r |  j  S|  j r? |  j   } | r8 | j |   Sd Snm t |   d k r t |  j  d k r t t |  j j     d d d k r t t |  j j     Sd Sd S)a(  
        Returns the results name for this token expression. Useful when several 
        different expressions might match at a particular location.

        Example::
            integer = Word(nums)
            ssn_expr = Regex(r"\d\d\d-\d\d-\d\d\d\d")
            house_number_expr = Suppress('#') + Word(nums, alphanums)
            user_data = (Group(house_number_expr)("house_number") 
                        | Group(ssn_expr)("ssn")
                        | Group(integer)("age"))
            user_info = OneOrMore(user_data)
            
            result = user_info.parseString("22 111-22-3333 #221B")
            for item in result:
                print(item.getName(), ':', item[0])
        prints::
            age : 22
            ssn : 111-22-3333
            house_number : 221B
        Nrr   r   rs   )r   rs   )	r   r   _ParseResults__lookupr   r   nextr   r   r   )r   parrw   rw   rx   getName+  s    		)zParseResults.getNamer   c             C   s  g  } d } | j  | t |  j     | r|  j   rt d d   |  j   D  } xh| D] \ } } | r | j  |  | j  d | d | | f  t | t  r | r | j  | j | | d   q | j  t |   qa | j  t	 |   qa Wn t
 d d   |  D  r|  } x t |  D] \ }	 }
 t |
 t  r| j  d | d | |	 | d | d |
 j | | d  f  q/| j  d | d | |	 | d | d t |
  f  q/Wd	 j |  S)
aH  
        Diagnostic method for listing out the contents of a C{ParseResults}.
        Accepts an optional C{indent} argument so that this string can be embedded
        in a nested display of other data.

        Example::
            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
            
            result = date_str.parseString('12/31/1999')
            print(result.dump())
        prints::
            ['12', '/', '31', '/', '1999']
            - day: 1999
            - month: 31
            - year: 12
        r  c             s   s'   |  ] \ } } t  |  | f Vq d  S)N)r{   )r   r   r   rw   rw   rx   r   g  s    z$ParseResults.dump.<locals>.<genexpr>z
%s%s- %s: z  rr   c             s   s   |  ] } t  | t  Vq d  S)N)rz   r"   )r   vvrw   rw   rx   r   s  s    z
%s%s[%d]:
%s%s%sr   )r   r   r   r   sortedr   rz   r"   dumpr   anyr   r   )r   r  Zdepthfullr  NLr   r   r   r   r  rw   rw   rx   r  P  s,     B9zParseResults.dumpc             O   s   t  j  |  j   | |  d S)a  
        Pretty-printer for parsed results as a list, using the C{pprint} module.
        Accepts additional positional or keyword args as defined for the 
        C{pprint.pprint} method. (U{http://docs.python.org/3/library/pprint.html#pprint.pprint})

        Example::
            ident = Word(alphas, alphanums)
            num = Word(nums)
            func = Forward()
            term = ident | num | Group('(' + func + ')')
            func <<= ident + Group(Optional(delimitedList(term)))
            result = func.parseString("fna a,b,(fnb c,d,200),100")
            result.pprint(width=40)
        prints::
            ['fna',
             ['a',
              'b',
              ['(', 'fnb', ['c', 'd', '200'], ')'],
              '100']]
        N)pprintr   )r   r   r   rw   rw   rx   r   }  s    zParseResults.pprintc             C   sC   |  j  |  j j   |  j d  k	 r- |  j   p0 d  |  j |  j f f S)N)r   r   r   r   r   r   )r   rw   rw   rx   __getstate__  s
    zParseResults.__getstate__c             C   sm   | d |  _  | d \ |  _ } } |  _ i  |  _ |  j j |  | d  k	 r` t |  |  _ n	 d  |  _ d  S)Nr   rr   )r   r   r   r   r  r   r   )r   stater  ZinAccumNamesrw   rw   rx   __setstate__  s    	zParseResults.__setstate__c             C   s   |  j  |  j |  j |  j f S)N)r   r   r   r   )r   rw   rw   rx   __getnewargs__  s    zParseResults.__getnewargs__c             C   s    t  t |    t |  j    S)N)r   r   r   r   )r   rw   rw   rx   r     s    zParseResults.__dir__)4r   r   r   r   r   rz   r   r   r   r   r   r   r   __nonzero__r   r   r   r   r   r  r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r  r  r   r   r	  r   r  r   r  r  r  r  r   r!  r#  r$  r   rw   rw   rw   rx   r"   -  sh   &	'	4#=%-c             C   sW   | } d |  k  o# t  |  k  n r@ | |  d d k r@ d S|  | j d d |   S)a  Returns current column within a string, counting newlines as line separators.
   The first column is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
   on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
   consistent view of the parsed string, the parse location, and line and column
   positions within the parsed string.
   r   rr   r  )r   rfind)r   strgr   rw   rw   rx   r9     s    
c             C   s   | j  d d |   d S)a  Returns current line number within a string, counting newlines as line separators.
   The first line is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See L{I{ParserElement.parseString}<ParserElement.parseString>} for more information
   on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
   consistent view of the parsed string, the parse location, and line and column
   positions within the parsed string.
   r  r   rr   )count)r   r'  rw   rw   rx   rJ     s    
c             C   s[   | j  d d |   } | j d |   } | d k rE | | d |  S| | d d  Sd S)zfReturns the line of text containing loc within a string, counting newlines as line separators.
       r  r   rr   N)r&  find)r   r'  ZlastCRZnextCRrw   rw   rx   rG     s
    c             C   sF   t  d t |  d t |  d t | |   t | |   f  d  S)NzMatch z at loc z(%d,%d))printr   rJ   r9   )instringr   exprrw   rw   rx   _defaultStartDebugAction  s    r-  c             C   s,   t  d t |  d t | j     d  S)NzMatched z -> )r*  r   r{   r   )r+  startlocZendlocr,  toksrw   rw   rx   _defaultSuccessDebugAction  s    r0  c             C   s   t  d t |   d  S)NzException raised:)r*  r   )r+  r   r,  excrw   rw   rx   _defaultExceptionDebugAction  s    r2  c              G   s   d S)zG'Do-nothing' debug action, to suppress debugging output during parsing.Nrw   )r   rw   rw   rx   rQ     s    rq   c                s   t  k r  f d d   Sd g  d g  t d  d  d k re d d d	  } d d
 d    n t j } t j   d } | d d  d } | d | d | f         f d d   } d } y" t  d t  d  j  } Wn t k
 rt   } Yn X| | _ | S)Nc                s
     |  S)Nrw   )r   lrv   )funcrw   rx   ry     s    z_trim_arity.<locals>.<lambda>r   Frq   ro      c             S   sJ   t  d k r d n d	 } t j d | |  d  | } | j | j f g S)
Nro   r5  r   rq   limitrr   )ro   r5  r   )system_version	tracebackextract_stackfilenamerJ   )r6  r  frame_summaryrw   rw   rx   r;     s    z"_trim_arity.<locals>.extract_stackc             S   s2   t  j |  d | } | d } | j | j f g S)Nr6  rr   rs   )r:  
extract_tbr<  rJ   )tbr6  Zframesr=  rw   rw   rx   r>    s    
z_trim_arity.<locals>.extract_tb   r6  rr   c                 s   x y,  |   d d     } d  d <| SWq t  k
 r  d rO   nD z= t j   d }   | d d d d  d   k s   Wd  ~ X d  k r  d d 7<w   Yq Xq Wd  S)Nr   Trr   r6  rq   rs   rs   )r   r~   exc_info)r   r   r?  )r>  
foundArityr4  r6  maxargspa_call_line_synthrw   rx   wrapper  s"    

&z_trim_arity.<locals>.wrapperz<parse action>r   	__class__)ro   r5  rs   )	singleArgBuiltinsr9  r:  r;  r>  getattrr   	Exceptionr{   )r4  rC  r;  Z	LINE_DIFFZ	this_linerE  	func_namerw   )r>  rB  r4  r6  rC  rD  rx   _trim_arity  s*    				!		rK  c                   s  e  Z d  Z d Z d Z d Z e d d    Z e d d    Z d d d	  Z	 d
 d   Z
 d d   Z d d d  Z d d d  Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d d   Z d! d"   Z d d d# d$  Z d% d&   Z d' d(   Z Gd) d*   d* e  Z e d+ k	 rOGd, d-   d- e  Z n Gd. d-   d- e  Z i  Z e   Z d/ d/ g Z  d d d0 d1  Z! e Z" e d2 d3    Z# d Z$ e d4 d5 d6   Z% d d7 d8  Z& e' d d9 d:  Z( d; d<   Z) e' d= d>  Z* e' d d? d@  Z+ dA dB   Z, dC dD   Z- dE dF   Z. dG dH   Z/ dI dJ   Z0 dK dL   Z1 dM dN   Z2 dO dP   Z3 dQ dR   Z4 dS dT   Z5 dU dV   Z6 dW dX   Z7 dY dZ   Z8 d+ d[ d\  Z9 d] d^   Z: d_ d`   Z; da db   Z< dc dd   Z= de df   Z> dg dh   Z? d di dj  Z@ dk dl   ZA dm dn   ZB do dp   ZC dq dr   ZD g  ds dt  ZE d du dv  ZF   f dw dx   ZG dy dz   ZH d{ d|   ZI d} d~   ZJ d d   ZK d d d  ZL d d d d d d d  ZM   S)r$   z)Abstract base level parser element class.z 
	Fc             C   s   |  t  _ d S)a  
        Overrides the default whitespace chars

        Example::
            # default whitespace chars are space, <TAB> and newline
            OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']
            
            # change to just treat newline as significant
            ParserElement.setDefaultWhitespaceChars(" \t")
            OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
        N)r$   DEFAULT_WHITE_CHARS)charsrw   rw   rx   setDefaultWhitespaceChars=  s    z'ParserElement.setDefaultWhitespaceCharsc             C   s   |  t  _ d S)a  
        Set class to be used for inclusion of string literals into a parser.
        
        Example::
            # default literal class used is Literal
            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           

            date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']


            # change to Suppress
            ParserElement.inlineLiteralsUsing(Suppress)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")           

            date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
        N)r$   _literalStringClass)r   rw   rw   rx   inlineLiteralsUsingL  s    z!ParserElement.inlineLiteralsUsingc             C   s   t    |  _ d  |  _ d  |  _ d  |  _ | |  _ d |  _ t j |  _	 d |  _
 d |  _ d |  _ t    |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d |  _ d |  _ d  S)NTFr   )NNN)r   parseAction
failActionstrReprresultsName
saveAsListskipWhitespacer$   rL  
whiteCharscopyDefaultWhiteCharsmayReturnEmptykeepTabsignoreExprsdebugstreamlinedmayIndexErrorerrmsgmodalResultsdebugActionsrecallPreparsecallDuringTry)r   savelistrw   rw   rx   r   a  s(    																zParserElement.__init__c             C   sT   t  j  |   } |  j d d  | _ |  j d d  | _ |  j rP t j | _ | S)a$  
        Make a copy of this C{ParserElement}.  Useful for defining different parse actions
        for the same parsing pattern, using copies of the original parse element.
        
        Example::
            integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
            integerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress("K")
            integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
            
            print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))
        prints::
            [5120, 100, 655360, 268435456]
        Equivalent form of C{expr.copy()} is just C{expr()}::
            integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress("M")
        N)r   rQ  r[  rX  r$   rL  rW  )r   Zcpyrw   rw   rx   r   x  s    	zParserElement.copyc             C   s;   | |  _  d |  j  |  _ t |  d  r7 |  j |  j _ |  S)af  
        Define name for this expression, makes debugging and exception messages clearer.
        
        Example::
            Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
            Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
        z	Expected 	exception)r   r_  r   rf  r   )r   r   rw   rw   rx   setName  s
    	zParserElement.setNamec             C   sH   |  j    } | j d  r1 | d d  } d } | | _ | | _ | S)aP  
        Define name for referencing matching tokens as a nested attribute
        of the returned parse results.
        NOTE: this returns a *copy* of the original C{ParserElement} object;
        this is so that the client can define a basic element, such as an
        integer, and reference it in multiple places with different names.

        You can also set results names using the abbreviated syntax,
        C{expr("name")} in place of C{expr.setResultsName("name")} - 
        see L{I{__call__}<__call__>}.

        Example::
            date_str = (integer.setResultsName("year") + '/' 
                        + integer.setResultsName("month") + '/' 
                        + integer.setResultsName("day"))

            # equivalent form:
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
        *Nrr   Trs   )r   endswithrT  r`  )r   r   listAllMatchesZnewselfrw   rw   rx   setResultsName  s    	
zParserElement.setResultsNameTc                sa   | r< |  j    d d   f d d  }   | _ | |  _  n! t |  j  d  r] |  j  j |  _  |  S)zMethod to invoke the Python pdb debugger when this element is
           about to be parsed. Set C{breakFlag} to True to enable, False to
           disable.
        Tc                s)   d d  l  } | j     |  | | |  S)Nr   )pdbZ	set_trace)r+  r   	doActionscallPreParserl  )_parseMethodrw   rx   breaker  s    
z'ParserElement.setBreak.<locals>.breaker_originalParseMethod)_parserq  r   )r   Z	breakFlagrp  rw   )ro  rx   setBreak  s    		zParserElement.setBreakc             O   s7   t  t t t  |    |  _ | j d d  |  _ |  S)a  
        Define action to perform when successfully matching parse element definition.
        Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},
        C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:
         - s   = the original string being parsed (see note below)
         - loc = the location of the matching substring
         - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object
        If the functions in fns modify the tokens, they can return them as the return
        value from fn, and the modified list of tokens will replace the original.
        Otherwise, fn does not need to return any value.

        Optional keyword arguments:
         - callDuringTry = (default=C{False}) indicate if parse action should be run during lookaheads and alternate testing

        Note: the default parsing behavior is to expand tabs in the input string
        before starting the parsing process.  See L{I{parseString}<parseString>} for more information
        on parsing strings containing C{<TAB>}s, and suggested methods to maintain a
        consistent view of the parsed string, the parse location, and line and column
        positions within the parsed string.
        
        Example::
            integer = Word(nums)
            date_str = integer + '/' + integer + '/' + integer

            date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']

            # use parse action to convert to ints at parse time
            integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
            date_str = integer + '/' + integer + '/' + integer

            # note that integer fields are now ints, not strings
            date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
        rd  F)r   maprK  rQ  r   rd  )r   fnsr   rw   rw   rx   r     s    "zParserElement.setParseActionc             O   sF   |  j  t t t t |    7_  |  j p< | j d d  |  _ |  S)z
        Add parse action to expression's list of parse actions. See L{I{setParseAction}<setParseAction>}.
        
        See examples in L{I{copy}<copy>}.
        rd  F)rQ  r   rt  rK  rd  r   )r   ru  r   rw   rw   rx   addParseAction  s    $zParserElement.addParseActionc                s   | j  d d   | j  d d  r* t n t   x6 | D].      f d d   } |  j j |  q7 W|  j p | j  d d  |  _ |  S)a  Add a boolean predicate function to expression's list of parse actions. See 
        L{I{setParseAction}<setParseAction>} for function call signatures. Unlike C{setParseAction}, 
        functions passed to C{addCondition} need to return boolean success/fail of the condition.

        Optional keyword arguments:
         - message = define a custom message to be used in the raised exception
         - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException
         
        Example::
            integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
            year_int = integer.copy()
            year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
            date_str = year_int + '/' + integer + '/' + integer

            result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
        messagezfailed user-defined conditionfatalFc                s4   t  t   |  | |   s0   |  |    d  S)N)r   rK  )r   r3  rv   )exc_typefnr   rw   rx   pa  s    z&ParserElement.addCondition.<locals>.pard  )r   r!   r   rQ  r   rd  )r   ru  r   r{  rw   )ry  rz  r   rx   addCondition  s    zParserElement.addConditionc             C   s   | |  _  |  S)a  Define action to perform if parsing fails at this expression.
           Fail acton fn is a callable function that takes the arguments
           C{fn(s,loc,expr,err)} where:
            - s = string being parsed
            - loc = location where expression match was attempted and failed
            - expr = the parse expression that failed
            - err = the exception thrown
           The function returns no value.  It may throw C{L{ParseFatalException}}
           if it is desired to stop parsing immediately.)rR  )r   rz  rw   rw   rx   setFailAction  s    
	zParserElement.setFailActionc             C   so   d } xb | rj d } xO |  j  D]D } y) x" | j | |  \ } } d } q+ WWq t k
 rb Yq Xq Wq	 W| S)NTF)r[  rr  r   )r   r+  r   Z
exprsFoundeZdummyrw   rw   rx   _skipIgnorables#  s    	zParserElement._skipIgnorablesc             C   sj   |  j  r |  j | |  } |  j rf |  j } t |  } x* | | k  re | | | k re | d 7} q< W| S)Nrr   )r[  r  rV  rW  r   )r   r+  r   Zwtinstrlenrw   rw   rx   preParse0  s    			zParserElement.preParsec             C   s
   | g  f S)Nrw   )r   r+  r   rm  rw   rw   rx   	parseImpl<  s    zParserElement.parseImplc             C   s   | S)Nrw   )r   r+  r   	tokenlistrw   rw   rx   	postParse?  s    zParserElement.postParsec          "   C   s  |  j  } | s |  j r6|  j d r< |  j d | | |   | r` |  j r` |  j | |  } n | } | } yV y |  j | | |  \ } } Wn0 t k
 r t | t |  |  j	 |    Yn XWqt
 k
 r2}	 zN |  j d r |  j d | | |  |	  |  j r|  j | | |  |	    WYd  d  }	 ~	 XqXn | rZ|  j rZ|  j | |  } n | } | } |  j s| t |  k ry |  j | | |  \ } } Wqt k
 rt | t |  |  j	 |    YqXn |  j | | |  \ } } |  j | | |  } t | |  j d |  j d |  j }
 |  j rw| sB|  j rw| ryo xh |  j D]] } | | | |
  } | d  k	 rUt | |  j d |  j ot | t t f  d |  j }
 qUWWqwt
 k
 r}	 z/ |  j d r|  j d | | |  |	    WYd  d  }	 ~	 XqwXnk xh |  j D]] } | | | |
  } | d  k	 rt | |  j d |  j odt | t t f  d |  j }
 qW| r|  j d r|  j d | | | |  |
  | |
 f S)Nr   rq   r   r   rr   )r\  rR  ra  rc  r  r  r   r   r   r_  r   r^  r  r"   rT  rU  r`  rQ  rd  rz   r   )r   r+  r   rm  rn  Z	debuggingprelocZtokensStarttokenserrZ	retTokensrz  rw   rw   rx   _parseNoCacheC  sp    	'	&$		zParserElement._parseNoCachec             C   sO   y |  j  | | d d d SWn* t k
 rJ t | | |  j |    Yn Xd  S)Nrm  Fr   )rr  r!   r   r_  )r   r+  r   rw   rw   rx   tryParse  s    zParserElement.tryParsec             C   s;   y |  j  | |  Wn t t f k
 r2 d SYn Xd Sd  S)NFT)r  r   r   )r   r+  r   rw   rw   rx   canParseNext  s
    	zParserElement.canParseNextc               @   s   e  Z d  Z d d   Z d S)zParserElement._UnboundedCachec                s   i    t    |  _     f d d   }   f d d   }   f d d   } t j | |   |  _ t j | |   |  _ t j | |   |  _ d  S)Nc                s     j  |   S)N)r   )r   r   )cachenot_in_cacherw   rx   r     s    z3ParserElement._UnboundedCache.__init__.<locals>.getc                s   |   | <d  S)Nrw   )r   r   r   )r  rw   rx   set  s    z3ParserElement._UnboundedCache.__init__.<locals>.setc                s     j    d  S)N)r   )r   )r  rw   rx   r     s    z5ParserElement._UnboundedCache.__init__.<locals>.clear)r   r  types
MethodTyper   r  r   )r   r   r  r   rw   )r  r  rx   r     s    z&ParserElement._UnboundedCache.__init__N)r   r   r   r   rw   rw   rw   rx   _UnboundedCache  s   r  Nc               @   s   e  Z d  Z d d   Z d S)zParserElement._FifoCachec                s   t    |  _  t        f d d   }    f d d   }   f d d   } t j | |   |  _ t j | |   |  _ t j | |   |  _ d  S)Nc                s     j  |   S)N)r   )r   r   )r  r  rw   rx   r     s    z.ParserElement._FifoCache.__init__.<locals>.getc                s-   |   | <t      k r)   j d  d  S)NF)r   popitem)r   r   r   )r  sizerw   rx   r    s    
z.ParserElement._FifoCache.__init__.<locals>.setc                s     j    d  S)N)r   )r   )r  rw   rx   r     s    z0ParserElement._FifoCache.__init__.<locals>.clear)r   r  _OrderedDictr  r  r   r  r   )r   r  r   r  r   rw   )r  r  r  rx   r     s    	z!ParserElement._FifoCache.__init__N)r   r   r   r   rw   rw   rw   rx   
_FifoCache  s   r  c               @   s   e  Z d  Z d d   Z d S)zParserElement._FifoCachec                s   t    |  _  i    t j g        f d d   }     f d d   }    f d d   } t j | |   |  _ t j | |   |  _ t j | |   |  _ d  S)Nc                s     j  |   S)N)r   )r   r   )r  r  rw   rx   r     s    z.ParserElement._FifoCache.__init__.<locals>.getc                sC   |   | <t      k r2   j  j   d    j |  d  S)N)r   r   popleftr   )r   r   r   )r  key_fifor  rw   rx   r    s    
z.ParserElement._FifoCache.__init__.<locals>.setc                s     j     j    d  S)N)r   )r   )r  r  rw   rx   r     s    
z0ParserElement._FifoCache.__init__.<locals>.clear)	r   r  collectionsdequer  r  r   r  r   )r   r  r   r  r   rw   )r  r  r  r  rx   r     s    z!ParserElement._FifoCache.__init__N)r   r   r   r   rw   rw   rw   rx   r    s   r   c             C   s:  d \ } } |  | | | | f } t  j 	t  j } | j |  }	 |	 | j k r t  j | d 7<y |  j | | | |  }	 WnD t k
 r }
 z$ | j | |
 j	 |
 j
      WYd  d  }
 ~
 Xq/X| j | |	 d |	 d j   f  |	 Sn> t  j | d 7<t |	 t  r|	  |	 d |	 d j   f SWd  QRXd  S)Nr   rr   )r   rr   )r$   packrat_cache_lockpackrat_cacher   r  packrat_cache_statsr  r   r  rF  r   r   rz   rI  )r   r+  r   rm  rn  ZHITZMISSlookupr  r   r   rw   rw   rx   _parseCache  s$    
	$zParserElement._parseCachec               C   s4   t  j j   d g t t  j  t  j d  d   <d  S)Nr   )r$   r  r   r   r  rw   rw   rw   rx   
resetCache  s    zParserElement.resetCache   c             C   sR   t  j sN d t  _ |  d k r0 t  j   t  _ n t  j |   t  _ t  j t  _ d S)a  Enables "packrat" parsing, which adds memoizing to the parsing logic.
           Repeated parse attempts at the same string location (which happens
           often in many complex grammars) can immediately return a cached value,
           instead of re-executing parsing/validating code.  Memoizing is done of
           both valid results and parsing exceptions.
           
           Parameters:
            - cache_size_limit - (default=C{128}) - if an integer value is provided
              will limit the size of the packrat cache; if None is passed, then
              the cache size will be unbounded; if 0 is passed, the cache will
              be effectively disabled.
            
           This speedup may break existing programs that use parse actions that
           have side-effects.  For this reason, packrat parsing is disabled when
           you first import pyparsing.  To activate the packrat feature, your
           program must call the class method C{ParserElement.enablePackrat()}.  If
           your program uses C{psyco} to "compile as you go", you must call
           C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,
           Python will crash.  For best results, call C{enablePackrat()} immediately
           after importing pyparsing.
           
           Example::
               import pyparsing
               pyparsing.ParserElement.enablePackrat()
        TN)r$   _packratEnabledr  r  r  r  rr  )Zcache_size_limitrw   rw   rx   enablePackrat   s    		zParserElement.enablePackratc             C   s   t  j   |  j s |  j   x |  j D] } | j   q' W|  j sP | j   } yT |  j | d  \ } } | r |  j | |  } t	   t
   } | j | |  Wn: t k
 r } z t  j r   n |  WYd d } ~ Xn X| Sd S)aB  
        Execute the parse expression with the given string.
        This is the main interface to the client code, once the complete
        expression has been built.

        If you want the grammar to require that the entire input string be
        successfully parsed, then set C{parseAll} to True (equivalent to ending
        the grammar with C{L{StringEnd()}}).

        Note: C{parseString} implicitly calls C{expandtabs()} on the input string,
        in order to report proper column numbers in parse actions.
        If the input string contains tabs and
        the grammar uses parse actions that use the C{loc} argument to index into the
        string being parsed, you can ensure you have a consistent view of the input
        string by:
         - calling C{parseWithTabs} on your grammar before calling C{parseString}
           (see L{I{parseWithTabs}<parseWithTabs>})
         - define your parse action using the full C{(s,loc,toks)} signature, and
           reference the input string using the parse action's C{s} argument
         - explictly expand the tabs in your input string before calling
           C{parseString}
        
        Example::
            Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
            Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
        r   N)r$   r  r]  
streamliner[  rZ  
expandtabsrr  r  r   r)   r   verbose_stacktrace)r   r+  parseAllr~  r   r  Zser1  rw   rw   rx   parseString#  s$    
	
		zParserElement.parseStringc             c   s  |  j  s |  j   x |  j D] } | j   q W|  j sL t |  j   } t |  } d } |  j } |  j } t	 j
   d }	 y x | | k r\|	 | k  r\y. | | |  }
 | | |
 d d \ } } Wn t k
 r |
 d } Yq X| | k rO|	 d 7}	 | |
 | f V| rF| | |  } | | k r9| } qL| d 7} qY| } q |
 d } q WWn: t k
 r} z t	 j r  n |  WYd d } ~ Xn Xd S)a  
        Scan the input string for expression matches.  Each match will return the
        matching tokens, start location, and end location.  May be called with optional
        C{maxMatches} argument, to clip scanning after 'n' matches are found.  If
        C{overlap} is specified, then overlapping matches will be reported.

        Note that the start and end locations are reported relative to the string
        being parsed.  See L{I{parseString}<parseString>} for more information on parsing
        strings with embedded tabs.

        Example::
            source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
            print(source)
            for tokens,start,end in Word(alphas).scanString(source):
                print(' '*start + '^'*(end-start))
                print(' '*start + tokens[0])
        
        prints::
        
            sldjf123lsdjjkf345sldkjf879lkjsfd987
            ^^^^^
            sldjf
                    ^^^^^^^
                    lsdjjkf
                              ^^^^^^
                              sldkjf
                                       ^^^^^^
                                       lkjsfd
        r   rn  Frr   N)r]  r  r[  rZ  r   r  r   r  rr  r$   r  r   r   r  )r   r+  
maxMatchesZoverlapr~  r  r   Z
preparseFnZparseFnmatchesr  ZnextLocr  Znextlocr1  rw   rw   rx   
scanStringU  sB    	
			

			zParserElement.scanStringc             C   s1  g  } d } d |  _  y x |  j |  D]} \ } } } | j | | |   | r t | t  rv | | j   7} n) t | t  r | | 7} n | j |  | } q( W| j | | d   d d   | D } d j t t	 t
 |    SWn: t k
 r,} z t j r  n |  WYd d } ~ Xn Xd S)af  
        Extension to C{L{scanString}}, to modify matching text with modified tokens that may
        be returned from a parse action.  To use C{transformString}, define a grammar and
        attach a parse action to it that modifies the returned token list.
        Invoking C{transformString()} on a target string will then scan for matches,
        and replace the matched text patterns according to the logic in the parse
        action.  C{transformString()} returns the resulting transformed string.
        
        Example::
            wd = Word(alphas)
            wd.setParseAction(lambda toks: toks[0].title())
            
            print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))
        Prints::
            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
        r   TNc             S   s   g  |  ] } | r |  q Srw   rw   )r   orw   rw   rx   r     s   	 z1ParserElement.transformString.<locals>.<listcomp>r   )rZ  r  r   rz   r"   r   r   r   rt  r   _flattenr   r$   r  )r   r+  r  ZlastErv   r   r~  r1  rw   rw   rx   r     s(    	
 	zParserElement.transformStringc             C   sh   y' t  d d   |  j | |  D  SWn: t k
 rc } z t j rK   n |  WYd d } ~ Xn Xd S)a~  
        Another extension to C{L{scanString}}, simplifying the access to the tokens found
        to match the given parse expression.  May be called with optional
        C{maxMatches} argument, to clip searching after 'n' matches are found.
        
        Example::
            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
            cap_word = Word(alphas.upper(), alphas.lower())
            
            print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))
        prints::
            ['More', 'Iron', 'Lead', 'Gold', 'I']
        c             S   s   g  |  ] \ } } } |  q Srw   rw   )r   rv   r   r~  rw   rw   rx   r     s   	 z.ParserElement.searchString.<locals>.<listcomp>N)r"   r  r   r$   r  )r   r+  r  r1  rw   rw   rx   searchString  s    '	zParserElement.searchStringc       	      c   sl   d } d } xJ |  j  | d | D]3 \ } } } | | |  V| rO | d V| } q" W| | d  Vd S)a[  
        Generator method to split a string using the given expression as a separator.
        May be called with optional C{maxsplit} argument, to limit the number of splits;
        and the optional C{includeSeparators} argument (default=C{False}), if the separating
        matching text should be included in the split results.
        
        Example::        
            punc = oneOf(list(".,;:/-!?"))
            print(list(punc.split("This, this?, this sentence, is badly punctuated!")))
        prints::
            ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
        r   r  N)r  )	r   r+  maxsplitZincludeSeparatorsZsplitsZlastrv   r   r~  rw   rw   rx   r     s    %	
zParserElement.splitc             C   sa   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d St |  | g  S)a  
        Implementation of + operator - returns C{L{And}}. Adding strings to a ParserElement
        converts them to L{Literal}s by default.
        
        Example::
            greet = Word(alphas) + "," + Word(alphas) + "!"
            hello = "Hello, World!"
            print (hello, "->", greet.parseString(hello))
        Prints::
            Hello, World! -> ['Hello', ',', 'World', '!']
        z4Cannot combine element of type %s with ParserElement
stacklevelrq   N)	rz   r   r$   rO  warningswarnr   SyntaxWarningr   )r   r   rw   rw   rx   r     s    zParserElement.__add__c             C   sY   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d S| |  S)z]
        Implementation of + operator when left operand is not a C{L{ParserElement}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)rz   r   r$   rO  r  r  r   r  )r   r   rw   rw   rx   r    s    zParserElement.__radd__c             C   sj   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d St |  t j	   | g  S)zQ
        Implementation of - operator, returns C{L{And}} with error stop
        z4Cannot combine element of type %s with ParserElementr  rq   N)
rz   r   r$   rO  r  r  r   r  r   
_ErrorStop)r   r   rw   rw   rx   __sub__  s    zParserElement.__sub__c             C   sY   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d S| |  S)z]
        Implementation of - operator when left operand is not a C{L{ParserElement}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)rz   r   r$   rO  r  r  r   r  )r   r   rw   rw   rx   __rsub__   s    zParserElement.__rsub__c                sB  t  | t  r | d } } n0t  | t  r:| d d d  } | d d k rb d | d f } t  | d t  r | d d k r | d d k r t   S| d d k r t   S | d t   SqOt  | d t  rt  | d t  r| \ } } | | 8} qOt d t | d  t | d    n t d t |    | d k  rgt d   | d k  rt d   | | k od k n rt d	   | r   f d
 d     | r| d k r   |  } qt  g |    |  } q>  |  } n( | d k r+ } n t  g |  } | S)a  
        Implementation of * operator, allows use of C{expr * 3} in place of
        C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer
        tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples
        may also include C{None} as in:
         - C{expr*(n,None)} or C{expr*(n,)} is equivalent
              to C{expr*n + L{ZeroOrMore}(expr)}
              (read as "at least n instances of C{expr}")
         - C{expr*(None,n)} is equivalent to C{expr*(0,n)}
              (read as "0 to n instances of C{expr}")
         - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}
         - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}

        Note that C{expr*(None,n)} does not raise an exception if
        more than n exprs exist in the input stream; that is,
        C{expr*(None,n)} does not enforce a maximum number of expr
        occurrences.  If this behavior is desired, then write
        C{expr*(None,n) + ~expr}
        r   Nrq   rr   z7cannot multiply 'ParserElement' and ('%s','%s') objectsz0cannot multiply 'ParserElement' and '%s' objectsz/cannot multiply ParserElement by negative valuez@second tuple value must be greater or equal to first tuple valuez+cannot multiply ParserElement by 0 or (0,0)c                s2   |  d k r$ t     |  d   St    Sd  S)Nrr   )r   )n)makeOptionalListr   rw   rx   r  ]  s    z/ParserElement.__mul__.<locals>.makeOptionalList)NN)	rz   ru   tupler2   r   r   r   
ValueErrorr   )r   r   ZminElementsZoptElementsr   rw   )r  r   rx   __mul__,  sD    #

&) 	zParserElement.__mul__c             C   s   |  j  |  S)N)r  )r   r   rw   rw   rx   __rmul__p  s    zParserElement.__rmul__c             C   sa   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d St |  | g  S)zI
        Implementation of | operator - returns C{L{MatchFirst}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)	rz   r   r$   rO  r  r  r   r  r   )r   r   rw   rw   rx   __or__s  s    zParserElement.__or__c             C   sY   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d S| |  BS)z]
        Implementation of | operator when left operand is not a C{L{ParserElement}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)rz   r   r$   rO  r  r  r   r  )r   r   rw   rw   rx   __ror__  s    zParserElement.__ror__c             C   sa   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d St |  | g  S)zA
        Implementation of ^ operator - returns C{L{Or}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)	rz   r   r$   rO  r  r  r   r  r   )r   r   rw   rw   rx   __xor__  s    zParserElement.__xor__c             C   sY   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d S| |  AS)z]
        Implementation of ^ operator when left operand is not a C{L{ParserElement}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)rz   r   r$   rO  r  r  r   r  )r   r   rw   rw   rx   __rxor__  s    zParserElement.__rxor__c             C   sa   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d St |  | g  S)zC
        Implementation of & operator - returns C{L{Each}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)	rz   r   r$   rO  r  r  r   r  r   )r   r   rw   rw   rx   __and__  s    zParserElement.__and__c             C   sY   t  | t  r t j |  } t  | t  sQ t j d t |  t d d d S| |  @S)z]
        Implementation of & operator when left operand is not a C{L{ParserElement}}
        z4Cannot combine element of type %s with ParserElementr  rq   N)rz   r   r$   rO  r  r  r   r  )r   r   rw   rw   rx   __rand__  s    zParserElement.__rand__c             C   s
   t  |   S)zE
        Implementation of ~ operator - returns C{L{NotAny}}
        )r   )r   rw   rw   rx   
__invert__  s    zParserElement.__invert__c             C   s'   | d k	 r |  j  |  S|  j   Sd S)a  
        Shortcut for C{L{setResultsName}}, with C{listAllMatches=False}.
        
        If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be
        passed as C{True}.
           
        If C{name} is omitted, same as calling C{L{copy}}.

        Example::
            # these are equivalent
            userdata = Word(alphas).setResultsName("name") + Word(nums+"-").setResultsName("socsecno")
            userdata = Word(alphas)("name") + Word(nums+"-")("socsecno")             
        N)rk  r   )r   r   rw   rw   rx   __call__  s    zParserElement.__call__c             C   s
   t  |   S)z
        Suppresses the output of this C{ParserElement}; useful to keep punctuation from
        cluttering up returned output.
        )r+   )r   rw   rw   rx   suppress  s    zParserElement.suppressc             C   s   d |  _  |  S)a  
        Disables the skipping of whitespace before matching the characters in the
        C{ParserElement}'s defined pattern.  This is normally only used internally by
        the pyparsing module, but may be needed in some whitespace-sensitive grammars.
        F)rV  )r   rw   rw   rx   leaveWhitespace  s    	zParserElement.leaveWhitespacec             C   s   d |  _  | |  _ d |  _ |  S)z8
        Overrides the default whitespace chars
        TF)rV  rW  rX  )r   rM  rw   rw   rx   setWhitespaceChars  s    			z ParserElement.setWhitespaceCharsc             C   s   d |  _  |  S)z
        Overrides default behavior to expand C{<TAB>}s to spaces before parsing the input string.
        Must be called before C{parseString} when the input grammar contains elements that
        match C{<TAB>} characters.
        T)rZ  )r   rw   rw   rx   parseWithTabs  s    	zParserElement.parseWithTabsc             C   sl   t  | t  r t |  } t  | t  rL | |  j k rh |  j j |  n |  j j t | j     |  S)a  
        Define expression to be ignored (e.g., comments) while doing pattern
        matching; may be called repeatedly, to define multiple comment or other
        ignorable patterns.
        
        Example::
            patt = OneOrMore(Word(alphas))
            patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']
            
            patt.ignore(cStyleComment)
            patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
        )rz   r   r+   r[  r   r   )r   r   rw   rw   rx   ignore  s    zParserElement.ignorec             C   s1   | p	 t  | p t | p t f |  _ d |  _ |  S)zT
        Enable display of debugging messages while doing pattern matching.
        T)r-  r0  r2  ra  r\  )r   ZstartActionZsuccessActionZexceptionActionrw   rw   rx   setDebugActions  s
    			zParserElement.setDebugActionsc             C   s)   | r |  j  t t t  n	 d |  _ |  S)a  
        Enable display of debugging messages while doing pattern matching.
        Set C{flag} to True to enable, False to disable.

        Example::
            wd = Word(alphas).setName("alphaword")
            integer = Word(nums).setName("numword")
            term = wd | integer
            
            # turn on debugging for wd
            wd.setDebug()

            OneOrMore(term).parseString("abc 123 xyz 890")
        
        prints::
            Match alphaword at loc 0(1,1)
            Matched alphaword -> ['abc']
            Match alphaword at loc 3(1,4)
            Exception raised:Expected alphaword (at char 4), (line:1, col:5)
            Match alphaword at loc 7(1,8)
            Matched alphaword -> ['xyz']
            Match alphaword at loc 11(1,12)
            Exception raised:Expected alphaword (at char 12), (line:1, col:13)
            Match alphaword at loc 15(1,16)
            Exception raised:Expected alphaword (at char 15), (line:1, col:16)

        The output shown is that produced by the default debug actions - custom debug actions can be
        specified using L{setDebugActions}. Prior to attempting
        to match the C{wd} expression, the debugging message C{"Match <exprname> at loc <n>(<line>,<col>)"}
        is shown. Then if the parse succeeds, a C{"Matched"} message is shown, or an C{"Exception raised"}
        message is shown. Also note the use of L{setName} to assign a human-readable name to the expression,
        which makes debugging and exception messages easier to understand - for instance, the default
        name created for the C{Word} expression without calling C{setName} is C{"W:(ABCD...)"}.
        F)r  r-  r0  r2  r\  )r   Zflagrw   rw   rx   setDebug  s    #	zParserElement.setDebugc             C   s   |  j  S)N)r   )r   rw   rw   rx   r   @  s    zParserElement.__str__c             C   s
   t  |   S)N)r   )r   rw   rw   rx   r   C  s    zParserElement.__repr__c             C   s   d |  _  d  |  _ |  S)NT)r]  rS  )r   rw   rw   rx   r  F  s    		zParserElement.streamlinec             C   s   d  S)Nrw   )r   r   rw   rw   rx   checkRecursionK  s    zParserElement.checkRecursionc             C   s   |  j  g   d S)zj
        Check defined expressions for valid structure, check for infinite recursive definitions.
        N)r  )r   validateTracerw   rw   rx   validateN  s    zParserElement.validatec             C   s   y | j    } Wn7 t k
 rI t | d   } | j    } Wd QRXYn Xy |  j | |  SWn: t k
 r } z t j r   n |  WYd d } ~ Xn Xd S)z
        Execute the parse expression on the given file or filename.
        If a filename is specified (instead of a file object),
        the entire file is opened, read, and closed before parsing.
        rN)readr   openr  r   r$   r  )r   Zfile_or_filenamer  Zfile_contentsfr1  rw   rw   rx   	parseFileT  s    	zParserElement.parseFilec                sd   t  | t  r1 |  | k p0 t |   t |  k St  | t  rM |  j |  St t |   | k Sd  S)N)rz   r$   varsr   r  super)r   r   )rF  rw   rx   __eq__h  s
    "zParserElement.__eq__c             C   s   |  | k S)Nrw   )r   r   rw   rw   rx   __ne__p  s    zParserElement.__ne__c             C   s   t  t |    S)N)hashid)r   rw   rw   rx   __hash__s  s    zParserElement.__hash__c             C   s
   |  | k S)Nrw   )r   r   rw   rw   rx   __req__v  s    zParserElement.__req__c             C   s   |  | k S)Nrw   )r   r   rw   rw   rx   __rne__y  s    zParserElement.__rne__c             C   s>   y! |  j  t |  d | d SWn t k
 r9 d SYn Xd S)a  
        Method for quick testing of a parser against a test string. Good for simple 
        inline microtests of sub expressions while building up larger parser.
           
        Parameters:
         - testString - to test against this expression for a match
         - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests
            
        Example::
            expr = Word(nums)
            assert expr.matches("100")
        r  TFN)r  r   r   )r   Z
testStringr  rw   rw   rx   r  |  s
    zParserElement.matches#c             C   s  t  | t  r3 t t t j | j   j     } t  | t  rN t |  } g  } g  } d }	 x#| D]}
 | d k	 r | j	 |
 d  s | r |
 r | j
 |
  qg |
 s qg d j |  |
 g } g  } yQ |
 j d d  }
 |  j |
 d | } | j
 | j d |   |	 o| }	 Wn#t k
 r} z t  | t  rGd n d	 } d |
 k r| j
 t | j |
   | j
 d
 t | j |
  d d |  n | j
 d
 | j d |  | j
 d t |   |	 o| }	 | } WYd d } ~ XnN t k
 rB} z. | j
 d t |   |	 o'| }	 | } WYd d } ~ Xn X| ro| r\| j
 d	  t d j |   | j
 |
 | f  qg W|	 | f S)a3  
        Execute the parse expression on a series of test strings, showing each
        test, the parsed results or where the parse failed. Quick and easy way to
        run a parse expression against a list of sample strings.
           
        Parameters:
         - tests - a list of separate test strings, or a multiline string of test strings
         - parseAll - (default=C{True}) - flag to pass to C{L{parseString}} when running tests           
         - comment - (default=C{'#'}) - expression for indicating embedded comments in the test 
              string; pass None to disable comment filtering
         - fullDump - (default=C{True}) - dump results as list followed by results names in nested outline;
              if False, only dump nested list
         - printResults - (default=C{True}) prints test output to stdout
         - failureTests - (default=C{False}) indicates if these tests are expected to fail parsing

        Returns: a (success, results) tuple, where success indicates that all tests succeeded
        (or failed if C{failureTests} is True), and the results contain a list of lines of each 
        test's output
        
        Example::
            number_expr = pyparsing_common.number.copy()

            result = number_expr.runTests('''
                # unsigned integer
                100
                # negative integer
                -100
                # float with scientific notation
                6.02e23
                # integer with scientific notation
                1e-12
                ''')
            print("Success" if result[0] else "Failed!")

            result = number_expr.runTests('''
                # stray character
                100Z
                # missing leading digit before '.'
                -.100
                # too many '.'
                3.14.159
                ''', failureTests=True)
            print("Success" if result[0] else "Failed!")
        prints::
            # unsigned integer
            100
            [100]

            # negative integer
            -100
            [-100]

            # float with scientific notation
            6.02e23
            [6.02e+23]

            # integer with scientific notation
            1e-12
            [1e-12]

            Success
            
            # stray character
            100Z
               ^
            FAIL: Expected end of text (at char 3), (line:1, col:4)

            # missing leading digit before '.'
            -.100
            ^
            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)

            # too many '.'
            3.14.159
                ^
            FAIL: Expected end of text (at char 4), (line:1, col:5)

            Success

        Each test string must be on a single line. If you want to test a string that spans multiple
        lines, create a test like this::

            expr.runTest(r"this is a test\n of strings that spans \n 3 lines")
        
        (Note that this is a raw string literal, you must include the leading 'r'.)
        TNFr  z\nr  r  z(FATAL)r    rr   ^zFAIL: zFAIL-EXCEPTION: )rz   r   r   rt  r{   r   rstrip
splitlinesr   r  r   r   r   r  r  r   r!   rG   r   r9   rI  r*  )r   Ztestsr  ZcommentZfullDumpZprintResultsZfailureTestsZ
allResultsZcommentsZsuccessrv   r  resultr   rx  r1  rw   rw   rx   runTests  sN    W$+,zParserElement.runTests)Nr   r   r   r   rL  r  staticmethodrN  rP  r   r   rg  rk  rs  r   rv  r|  r}  r  r  r  r  r  r  r  r   r  r  r  r  r   r  r  r  rr  r  r  r  r  _MAX_INTr  r   r  r   r   r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r   r   r  r  r  r  r  r  r  r  r  r  r  rw   rw   )rF  rx   r$   8  s   &
H	"2G+D			
)c                   s(   e  Z d  Z d Z   f d d   Z   S)r,   zT
    Abstract C{ParserElement} subclass, for defining atomic matching patterns.
    c                s   t  t |   j d d  d  S)Nre  F)r  r,   r   )r   )rF  rw   rx   r   	  s    zToken.__init__)r   r   r   r   r   rw   rw   )rF  rx   r,   	  s   c                   s(   e  Z d  Z d Z   f d d   Z   S)r   z,
    An empty token, will always match.
    c                s2   t  t |   j   d |  _ d |  _ d |  _ d  S)Nr   TF)r  r   r   r   rY  r^  )r   )rF  rw   rx   r   	  s    		zEmpty.__init__)r   r   r   r   r   rw   rw   )rF  rx   r   	  s   c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r   z(
    A token that will never match.
    c                s;   t  t |   j   d |  _ d |  _ d |  _ d |  _ d  S)Nr   TFzUnmatchable token)r  r   r   r   rY  r^  r_  )r   )rF  rw   rx   r   *	  s
    			zNoMatch.__init__Tc             C   s   t  | | |  j |    d  S)N)r   r_  )r   r+  r   rm  rw   rw   rx   r  1	  s    zNoMatch.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r   &	  s   c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r   a  
    Token to exactly match a specified string.
    
    Example::
        Literal('blah').parseString('blah')  # -> ['blah']
        Literal('blah').parseString('blahfooblah')  # -> ['blah']
        Literal('blah').parseString('bla')  # -> Exception: Expected "blah"
    
    For case-insensitive matching, use L{CaselessLiteral}.
    
    For keyword matching (force word break before and after the matched string),
    use L{Keyword} or L{CaselessKeyword}.
    c                s   t  t |   j   | |  _ t |  |  _ y | d |  _ Wn1 t k
 ro t j	 d t
 d d t |  _ Yn Xd t |  j  |  _ d |  j |  _ d |  _ d |  _ d  S)Nr   z2null string passed to Literal; use Empty() insteadr  rq   z"%s"z	Expected F)r  r   r   matchr   matchLenfirstMatchCharr   r  r  r  r   rF  r   r   r_  rY  r^  )r   matchString)rF  rw   rx   r   C	  s    			zLiteral.__init__Tc             C   sg   | | |  j  k rK |  j d k s7 | j |  j |  rK | |  j |  j f St | | |  j |    d  S)Nrr   )r  r  
startswithr  r   r_  )r   r+  r   rm  rw   rw   rx   r  V	  s    $zLiteral.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r   5	  s   c                   sk   e  Z d  Z d Z e d Z d d   f d d  Z d d d	  Z   f d
 d   Z e	 d d    Z
   S)r   a\  
    Token to exactly match a specified string as a keyword, that is, it must be
    immediately followed by a non-keyword character.  Compare with C{L{Literal}}:
     - C{Literal("if")} will match the leading C{'if'} in C{'ifAndOnlyIf'}.
     - C{Keyword("if")} will not; it will only match the leading C{'if'} in C{'if x=1'}, or C{'if(y==2)'}
    Accepts two optional constructor arguments in addition to the keyword string:
     - C{identChars} is a string of characters that would be valid identifier characters,
          defaulting to all alphanumerics + "_" and "$"
     - C{caseless} allows case-insensitive matching, default is C{False}.
       
    Example::
        Keyword("start").parseString("start")  # -> ['start']
        Keyword("start").parseString("starting")  # -> Exception

    For case-insensitive matching, use L{CaselessKeyword}.
    z_$NFc                s   t  t |   j   | d  k r( t j } | |  _ t |  |  _ y | d |  _ Wn( t k
 r{ t	 j
 d t d d Yn Xd |  j |  _ d |  j |  _ d |  _ d |  _ | |  _ | r | j   |  _ | j   } t |  |  _ d  S)Nr   z2null string passed to Keyword; use Empty() insteadr  rq   z"%s"z	Expected F)r  r   r   DEFAULT_KEYWORD_CHARSr  r   r  r  r   r  r  r  r   r_  rY  r^  caselessuppercaselessmatchr  
identChars)r   r  r  r  )rF  rw   rx   r   q	  s&    						zKeyword.__init__Tc             C   se  |  j  r | | | |  j  j   |  j k rI| t |  |  j k sh | | |  j j   |  j k rI| d k s | | d j   |  j k rI| |  j |  j f Sn | | |  j k rI|  j d k s | j |  j |  rI| t |  |  j k s| | |  j |  j k rI| d k s5| | d |  j k rI| |  j |  j f St	 | | |  j
 |    d  S)Nr   rr   )r  r  r  r  r   r  r  r  r  r   r_  )r   r+  r   rm  rw   rw   rx   r  	  s    	&9)$3#zKeyword.parseImplc                s%   t  t |   j   } t j | _ | S)N)r  r   r   r  r  )r   r   )rF  rw   rx   r   	  s    zKeyword.copyc             C   s   |  t  _ d S)z,Overrides the default Keyword chars
        N)r   r  )rM  rw   rw   rx   setDefaultKeywordChars	  s    zKeyword.setDefaultKeywordChars)r   r   r   r   r3   r  r   r  r   r  r  rw   rw   )rF  rx   r   ^	  s   
c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r   al  
    Token to match a specified string, ignoring case of letters.
    Note: the matched results will always be in the case of the given
    match string, NOT the case of the input text.

    Example::
        OneOrMore(CaselessLiteral("CMD")).parseString("cmd CMD Cmd10") # -> ['CMD', 'CMD', 'CMD']
        
    (Contrast with example for L{CaselessKeyword}.)
    c                sI   t  t |   j | j    | |  _ d |  j |  _ d |  j |  _ d  S)Nz'%s'z	Expected )r  r   r   r  returnStringr   r_  )r   r  )rF  rw   rx   r   	  s    	zCaselessLiteral.__init__Tc             C   sV   | | | |  j   j   |  j k r: | |  j  |  j f St | | |  j |    d  S)N)r  r  r  r  r   r_  )r   r+  r   rm  rw   rw   rx   r  	  s    &zCaselessLiteral.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r   	  s   
c                   s:   e  Z d  Z d Z d   f d d  Z d d d  Z   S)r   z
    Caseless version of L{Keyword}.

    Example::
        OneOrMore(CaselessKeyword("CMD")).parseString("cmd CMD Cmd10") # -> ['CMD', 'CMD']
        
    (Contrast with example for L{CaselessLiteral}.)
    Nc                s#   t  t |   j | | d d d  S)Nr  T)r  r   r   )r   r  r  )rF  rw   rx   r   	  s    zCaselessKeyword.__init__Tc             C   s   | | | |  j   j   |  j k rs | t |  |  j  k s_ | | |  j  j   |  j k rs | |  j  |  j f St | | |  j |    d  S)N)r  r  r  r   r  r  r   r_  )r   r+  r   rm  rw   rw   rx   r  	  s    &9zCaselessKeyword.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r   	  s   c                   s:   e  Z d  Z d Z d   f d d  Z d d d  Z   S)rl   ax  
    A variation on L{Literal} which matches "close" matches, that is, 
    strings with at most 'n' mismatching characters. C{CloseMatch} takes parameters:
     - C{match_string} - string to be matched
     - C{maxMismatches} - (C{default=1}) maximum number of mismatches allowed to count as a match
    
    The results from a successful parse will contain the matched text from the input string and the following named results:
     - C{mismatches} - a list of the positions within the match_string where mismatches were found
     - C{original} - the original match_string used to compare against the input string
    
    If C{mismatches} is an empty list, then the match was an exact match.
    
    Example::
        patt = CloseMatch("ATCATCGAATGGA")
        patt.parseString("ATCATCGAAXGGA") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})
        patt.parseString("ATCAXCGAAXGGA") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)

        # exact match
        patt.parseString("ATCATCGAATGGA") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})

        # close match allowing up to 2 mismatches
        patt = CloseMatch("ATCATCGAATGGA", maxMismatches=2)
        patt.parseString("ATCAXCGAAXGGA") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})
    rr   c                s]   t  t |   j   | |  _ | |  _ | |  _ d |  j |  j f |  _ d |  _ d |  _ d  S)Nz&Expected %r (with up to %d mismatches)F)	r  rl   r   r   match_stringmaxMismatchesr_  r^  rY  )r   r  r  )rF  rw   rx   r   	  s    				zCloseMatch.__init__Tc             C   s  | } t  |  } | t  |  j  } | | k r |  j } d } g  }	 |  j }
 x t t | | |  |  j   D]D \ } } | \ } } | | k rr |	 j |  t  |	  |
 k rr Pqr W| d } t | | |  g  } |  j | d <|	 | d <| | f St | | |  j |    d  S)Nr   rr   Zoriginal
mismatches)	r   r  r  r   r   r   r"   r   r_  )r   r+  r   rm  startr  maxlocr  Zmatch_stringlocr  r  Zs_msrcmatresultsrw   rw   rx   r  	  s(    		/


zCloseMatch.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   rl   	  s   	c            	       s[   e  Z d  Z d Z d d d d d d   f d d  Z d d	 d
  Z   f d d   Z   S)r/   a	  
    Token for matching words composed of allowed character sets.
    Defined with string containing all allowed initial characters,
    an optional string containing allowed body characters (if omitted,
    defaults to the initial character set), and an optional minimum,
    maximum, and/or exact length.  The default value for C{min} is 1 (a
    minimum value < 1 is not valid); the default values for C{max} and C{exact}
    are 0, meaning no maximum or exact length restriction. An optional
    C{excludeChars} parameter can list characters that might be found in 
    the input C{bodyChars} string; useful to define a word of all printables
    except for one or two characters, for instance.
    
    L{srange} is useful for defining custom character set strings for defining 
    C{Word} expressions, using range notation from regular expression character sets.
    
    A common mistake is to use C{Word} to match a specific literal string, as in 
    C{Word("Address")}. Remember that C{Word} uses the string argument to define
    I{sets} of matchable characters. This expression would match "Add", "AAA",
    "dAred", or any other word made up of the characters 'A', 'd', 'r', 'e', and 's'.
    To match an exact literal string, use L{Literal} or L{Keyword}.

    pyparsing includes helper strings for building Words:
     - L{alphas}
     - L{nums}
     - L{alphanums}
     - L{hexnums}
     - L{alphas8bit} (alphabetic characters in ASCII range 128-255 - accented, tilded, umlauted, etc.)
     - L{punc8bit} (non-alphabetic characters in ASCII range 128-255 - currency, symbols, superscripts, diacriticals, etc.)
     - L{printables} (any non-whitespace character)

    Example::
        # a word composed of digits
        integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))
        
        # a word with a leading capital, and zero or more lowercase
        capital_word = Word(alphas.upper(), alphas.lower())

        # hostnames are alphanumeric, with leading alpha, and '-'
        hostname = Word(alphas, alphanums+'-')
        
        # roman numeral (not a strict parser, accepts invalid mix of characters)
        roman = Word("IVXLCDM")
        
        # any string of non-whitespace characters, except for ','
        csv_value = Word(printables, excludeChars=",")
    Nrr   r   Fc                sv  t  t |   j     rc d j   f d d   | D  } | rc d j   f d d   | D  } | |  _ t |  |  _ | r | |  _ t |  |  _ n | |  _ t |  |  _ | d k |  _	 | d k  r t
 d   | |  _ | d k r | |  _ n	 t |  _ | d k r#| |  _ | |  _ t |   |  _ d |  j |  _ d	 |  _ | |  _ d
 |  j |  j k rr| d k rr| d k rr| d k rr|  j |  j k rd t |  j  |  _ ne t |  j  d k rd t j |  j  t |  j  f |  _ n% d t |  j  t |  j  f |  _ |  j r;d |  j d |  _ y t j |  j  |  _ Wn t k
 rqd  |  _ Yn Xd  S)Nr   c             3   s!   |  ] } |   k r | Vq d  S)Nrw   )r   r   )excludeCharsrw   rx   r   7
  s    z Word.__init__.<locals>.<genexpr>c             3   s!   |  ] } |   k r | Vq d  S)Nrw   )r   r   )r  rw   rx   r   9
  s    r   rr   zZcannot specify a minimum length < 1; use Optional(Word()) if zero-length word is permittedz	Expected Fr  z[%s]+z%s[%s]*z	[%s][%s]*z\b)r  r/   r   r   initCharsOrigr  	initCharsbodyCharsOrig	bodyCharsmaxSpecifiedr  minLenmaxLenr  r   r   r_  r^  	asKeyword_escapeRegexRangeCharsreStringr   rb  escapecompilerI  )r   r  r  minmaxexactr   r  )rF  )r  rx   r   4
  sT    ""									:	zWord.__init__Tc       
      C   s  |  j  rX |  j  j | |  } | s< t | | |  j |    | j   } | | j   f S| | |  j k r t | | |  j |    | } | d 7} t |  } |  j } | |  j	 } t
 | |  } x* | | k  r | | | k r | d 7} q Wd }	 | | |  j k  rd }	 |  j r;| | k  r;| | | k r;d }	 |  j r| d k rd| | d | k s| | k  r| | | k rd }	 |	 rt | | |  j |    | | | |  f S)Nrr   FTr   )rb  r  r   r_  endgroupr  r   r  r  r  r  r  r   )
r   r+  r   rm  r  r  r  Z	bodycharsr  ZthrowExceptionrw   rw   rx   r  j
  s6    	
	%	<zWord.parseImplc                s   y t  t |   j   SWn t k
 r+ Yn X|  j d  k r d d   } |  j |  j k r d | |  j  | |  j  f |  _ n d | |  j  |  _ |  j S)Nc             S   s,   t  |   d k r$ |  d  d  d S|  Sd  S)N   z...)r   )r   rw   rw   rx   
charsAsStr
  s    z Word.__str__.<locals>.charsAsStrz	W:(%s,%s)zW:(%s))r  r/   r   rI  rS  r  r  )r   r  )rF  rw   rx   r   
  s    (zWord.__str__)r   r   r   r   r   r  r   rw   rw   )rF  rx   r/   
  s   .$6#c                   sa   e  Z d  Z d Z e e j d   Z d   f d d  Z d d d  Z	   f d	 d
   Z
   S)r'   a  
    Token for matching strings that match a given regular expression.
    Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.
    If the given regex contains named groups (defined using C{(?P<name>...)}), these will be preserved as 
    named parse results.

    Example::
        realnum = Regex(r"[+-]?\d+\.\d*")
        date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')
        # ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
        roman = Regex(r"M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")
    z[A-Z]r   c                s1  t  t |   j   t | t  r | s> t j d t d d | |  _ | |  _	 y+ t
 j |  j |  j	  |  _
 |  j |  _ Wq t j k
 r t j d | t d d   Yq XnI t | t j  r | |  _
 t |  |  _ |  _ | |  _	 n t d   t |   |  _ d |  j |  _ d |  _ d |  _ d	 S)
zThe parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags.z0null string passed to Regex; use Empty() insteadr  rq   z$invalid pattern (%s) passed to RegexzCRegex may only be constructed with a string or a compiled RE objectz	Expected FTN)r  r'   r   rz   r   r  r  r  patternflagsrb  r  r  sre_constantserrorcompiledREtyper{   r  r   r   r_  r^  rY  )r   r  r  )rF  rw   rx   r   
  s.    					zRegex.__init__Tc             C   s   |  j  j | |  } | s3 t | | |  j |    | j   } | j   } t | j    } | r x | D] } | | | | <qj W| | f S)N)rb  r  r   r_  r  	groupdictr"   r	  )r   r+  r   rm  r  dr   r   rw   rw   rx   r  
  s    zRegex.parseImplc                sX   y t  t |   j   SWn t k
 r+ Yn X|  j d  k rQ d t |  j  |  _ |  j S)NzRe:(%s))r  r'   r   rI  rS  r   r  )r   )rF  rw   rx   r   
  s    zRegex.__str__)r   r   r   r   r   rb  r  r  r   r  r   rw   rw   )rF  rx   r'   
  s
   "c            	       s[   e  Z d  Z d Z d d d d d d   f d d  Z d d d  Z   f d	 d
   Z   S)r%   a  
    Token for matching strings that are delimited by quoting characters.
    
    Defined with the following parameters:
        - quoteChar - string of one or more characters defining the quote delimiting string
        - escChar - character to escape quotes, typically backslash (default=C{None})
        - escQuote - special quote sequence to escape an embedded quote string (such as SQL's "" to escape an embedded ") (default=C{None})
        - multiline - boolean indicating whether quotes can span multiple lines (default=C{False})
        - unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})
        - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} => same as quoteChar)
        - convertWhitespaceEscapes - convert escaped whitespace (C{'\t'}, C{'\n'}, etc.) to actual whitespace (default=C{True})

    Example::
        qs = QuotedString('"')
        print(qs.searchString('lsjdf "This is the quote" sldjf'))
        complex_qs = QuotedString('{{', endQuoteChar='}}')
        print(complex_qs.searchString('lsjdf {{This is the "quote"}} sldjf'))
        sql_qs = QuotedString('"', escQuote='""')
        print(sql_qs.searchString('lsjdf "This is the quote with ""embedded"" quotes" sldjf'))
    prints::
        [['This is the quote']]
        [['This is the "quote"']]
        [['This is the quote with "embedded" quotes']]
    NFTc                s  t  t    j   | j   } | sD t j d t d d t    | d  k rY | } n1 | j   } | s t j d t d d t    |   _ t	 |    _
 | d   _ |   _ t	 |    _ |   _ |   _ |   _ |   _ | rNt j t j B  _ d t j   j  t   j d  | d  k	 r>t |  pAd f   _ nP d   _ d t j   j  t   j d  | d  k	 rt |  pd f   _ t	   j  d	 k r  j d
 d j   f d d   t t	   j  d	 d d  D  d 7_ | r!  j d t j |  7_ | r\  j d t j |  7_ t j   j  d   _   j d t j   j  7_ y+ t j   j   j    _   j   _ Wn5 t j k
 rt j d   j t d d   Yn Xt       _! d   j!   _" d   _# d   _$ d  S)Nz$quoteChar cannot be the empty stringr  rq   z'endQuoteChar cannot be the empty stringr   z%s(?:[^%s%s]r   z%s(?:[^%s\n\r%s]rr   z|(?:z)|(?:c             3   sB   |  ]8 } d  t  j   j d |   t   j |  f Vq d S)z%s[^%s]N)rb  r  endQuoteCharr  )r   r   )r   rw   rx   r   /  s   z(QuotedString.__init__.<locals>.<genexpr>)z|(?:%s)z|(?:%s.)z(.)z)*%sz$invalid pattern (%s) passed to Regexz	Expected FTrs   )%r  r%   r   r   r  r  r  SyntaxError	quoteCharr   quoteCharLenfirstQuoteCharr  endQuoteCharLenescCharescQuoteunquoteResultsconvertWhitespaceEscapesrb  	MULTILINEDOTALLr  r  r  r  r   r   escCharReplacePatternr  r  r  r  r   r   r_  r^  rY  )r   r  r  r  Z	multiliner  r  r  )rF  )r   rx   r     sf    									(	%E	zQuotedString.__init__c       	      C   sA  | | |  j  k r( |  j j | |  p+ d  } | sL t | | |  j |    | j   } | j   } |  j r7| |  j |  j	  } t
 | t  r7d | k r |  j r d d d d d d d d	 i } x, | j   D] \ } } | j | |  } q W|  j rt j |  j d
 |  } |  j r7| j |  j |  j  } | | f S)N\z\t	z\nr  z\fz\rz\g<1>)r  rb  r  r   r_  r  r	  r  r  r  rz   r   r  r   r   r  r   r   r  r  )	r   r+  r   rm  r  r   Zws_mapZwslitZwscharrw   rw   rx   r  G  s(    .			zQuotedString.parseImplc                s[   y t  t |   j   SWn t k
 r+ Yn X|  j d  k rT d |  j |  j f |  _ |  j S)Nz.quoted string, starting with %s ending with %s)r  r%   r   rI  rS  r  r  )r   )rF  rw   rx   r   j  s    zQuotedString.__str__)r   r   r   r   r   r  r   rw   rw   )rF  rx   r%   
  s   $A#c                   sR   e  Z d  Z d Z d d d   f d d  Z d d d  Z   f d	 d
   Z   S)r	   a  
    Token for matching words composed of characters I{not} in a given set (will
    include whitespace in matched characters if not listed in the provided exclusion set - see example).
    Defined with string containing all disallowed characters, and an optional
    minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a
    minimum value < 1 is not valid); the default values for C{max} and C{exact}
    are 0, meaning no maximum or exact length restriction.

    Example::
        # define a comma-separated-value as anything that is not a ','
        csv_value = CharsNotIn(',')
        print(delimitedList(csv_value).parseString("dkls,lsdkjf,s12 34,@!#,213"))
    prints::
        ['dkls', 'lsdkjf', 's12 34', '@!#', '213']
    rr   r   c                s   t  t |   j   d |  _ | |  _ | d k  r= t d   | |  _ | d k r^ | |  _ n	 t |  _ | d k r | |  _ | |  _ t	 |   |  _
 d |  j
 |  _ |  j d k |  _ d |  _ d  S)NFrr   zfcannot specify a minimum length < 1; use Optional(CharsNotIn()) if zero-length char group is permittedr   z	Expected )r  r	   r   rV  notCharsr  r  r  r  r   r   r_  rY  r^  )r   r%  r  r  r  )rF  rw   rx   r     s     						zCharsNotIn.__init__Tc             C   s   | | |  j  k r+ t | | |  j |    | } | d 7} |  j  } t | |  j t |   } x* | | k  r | | | k r | d 7} qc W| | |  j k  r t | | |  j |    | | | |  f S)Nrr   )r%  r   r_  r  r  r   r  )r   r+  r   rm  r  Znotcharsmaxlenrw   rw   rx   r    s    
	zCharsNotIn.parseImplc                s   y t  t |   j   SWn t k
 r+ Yn X|  j d  k r} t |  j  d k rm d |  j d  d  |  _ n d |  j |  _ |  j S)Nr
  z
!W:(%s...)z!W:(%s))r  r	   r   rI  rS  r   r%  )r   )rF  rw   rx   r     s    zCharsNotIn.__str__)r   r   r   r   r   r  r   rw   rw   )rF  rx   r	   v  s   c            
       sg   e  Z d  Z d Z d d d d d d d d	 d
 d i Z d d d d   f d d  Z d d d  Z   S)r.   a  
    Special matching class for matching whitespace.  Normally, whitespace is ignored
    by pyparsing grammars.  This class is included when some whitespace structures
    are significant.  Define with a string containing the whitespace characters to be
    matched; default is C{" \t\r\n"}.  Also takes optional C{min}, C{max}, and C{exact} arguments,
    as defined for the C{L{Word}} class.
    r  z<SPC>r"  z<TAB>r  z<LF>r$  z<CR>r#  z<FF>z 	
rr   r   c                s   t  t    j   |   _   j d j   f d d     j D   d j d d     j D    _ d   _ d   j   _	 |   _
 | d k r |   _ n	 t   _ | d k r |   _ |   _
 d  S)Nr   c             3   s$   |  ] } |   j  k r | Vq d  S)N)
matchWhite)r   r   )r   rw   rx   r     s    z!White.__init__.<locals>.<genexpr>c             s   s   |  ] } t  j | Vq d  S)N)r.   	whiteStrs)r   r   rw   rw   rx   r     s    Tz	Expected r   )r  r.   r   r'  r  r   rW  r   rY  r_  r  r  r  )r   Zwsr  r  r  )rF  )r   rx   r     s    	,"				zWhite.__init__Tc             C   s   | | |  j  k r+ t | | |  j |    | } | d 7} | |  j } t | t |   } x- | | k  r | | |  j  k r | d 7} q` W| | |  j k  r t | | |  j |    | | | |  f S)Nrr   )r'  r   r_  r  r  r   r  )r   r+  r   rm  r  r  rw   rw   rx   r    s    
"zWhite.parseImpl)r   r   r   r   r(  r   r  rw   rw   )rF  rx   r.     s   c                   s"   e  Z d  Z   f d d   Z   S)_PositionTokenc                s8   t  t |   j   |  j j |  _ d |  _ d |  _ d  S)NTF)r  r)  r   rF  r   r   rY  r^  )r   )rF  rw   rx   r     s    	z_PositionToken.__init__)r   r   r   r   rw   rw   )rF  rx   r)    s   r)  c                   sC   e  Z d  Z d Z   f d d   Z d d   Z d d d  Z   S)	r   zb
    Token to advance to a specific column of input text; useful for tabular report scraping.
    c                s    t  t |   j   | |  _ d  S)N)r  r   r   r9   )r   colno)rF  rw   rx   r     s    zGoToColumn.__init__c             C   s   t  | |  |  j  k r t |  } |  j r? |  j | |  } xB | | k  r | | j   r t  | |  |  j  k r | d 7} qB W| S)Nrr   )r9   r   r[  r  isspace)r   r+  r   r  rw   rw   rx   r    s    	7zGoToColumn.preParseTc             C   s^   t  | |  } | |  j  k r3 t | | d |    | |  j  | } | | |  } | | f S)NzText not in expected column)r9   r   )r   r+  r   rm  ZthiscolZnewlocr   rw   rw   rx   r    s    zGoToColumn.parseImpl)r   r   r   r   r   r  r  rw   rw   )rF  rx   r     s   	c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r   a  
    Matches if current position is at the beginning of a line within the parse string
    
    Example::
    
        test = '''        AAA this line
        AAA and this line
          AAA but not this one
        B AAA and definitely not this one
        '''

        for t in (LineStart() + 'AAA' + restOfLine).searchString(test):
            print(t)
    
    Prints::
        ['AAA', ' this line']
        ['AAA', ' and this line']    

    c                s    t  t |   j   d |  _ d  S)NzExpected start of line)r  r   r   r_  )r   )rF  rw   rx   r   &  s    zLineStart.__init__Tc             C   s;   t  | |  d k r | g  f St | | |  j |    d  S)Nrr   )r9   r   r_  )r   r+  r   rm  rw   rw   rx   r  *  s    
zLineStart.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r     s   c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r   zU
    Matches if current position is at the end of a line within the parse string
    c                s<   t  t |   j   |  j t j j d d   d |  _ d  S)Nr  r   zExpected end of line)r  r   r   r  r$   rL  r   r_  )r   )rF  rw   rx   r   3  s    zLineEnd.__init__Tc             C   s   | t  |  k  rK | | d k r0 | d d f St | | |  j |    n8 | t  |  k rk | d g  f St | | |  j |    d  S)Nr  rr   )r   r   r_  )r   r+  r   rm  rw   rw   rx   r  8  s    zLineEnd.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r   /  s   c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r*   zM
    Matches if current position is at the beginning of the parse string
    c                s    t  t |   j   d |  _ d  S)NzExpected start of text)r  r*   r   r_  )r   )rF  rw   rx   r   G  s    zStringStart.__init__Tc             C   sF   | d k r< | |  j  | d  k r< t | | |  j |    | g  f S)Nr   )r  r   r_  )r   r+  r   rm  rw   rw   rx   r  K  s    zStringStart.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r*   C  s   c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r)   zG
    Matches if current position is at the end of the parse string
    c                s    t  t |   j   d |  _ d  S)NzExpected end of text)r  r)   r   r_  )r   )rF  rw   rx   r   V  s    zStringEnd.__init__Tc             C   s   | t  |  k  r- t | | |  j |    nT | t  |  k rM | d g  f S| t  |  k ri | g  f St | | |  j |    d  S)Nrr   )r   r   r_  )r   r+  r   rm  rw   rw   rx   r  Z  s    
zStringEnd.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r)   R  s   c                   s:   e  Z d  Z d Z e   f d d  Z d d d  Z   S)r1   ap  
    Matches if the current position is at the beginning of a Word, and
    is not preceded by any character in a given set of C{wordChars}
    (default=C{printables}). To emulate the C{} behavior of regular expressions,
    use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of
    the string being parsed, or at the beginning of a line.
    c                s/   t  t |   j   t |  |  _ d |  _ d  S)NzNot at the start of a word)r  r1   r   r  	wordCharsr_  )r   r,  )rF  rw   rx   r   l  s    zWordStart.__init__Tc             C   sX   | d k rN | | d |  j  k s6 | | |  j  k rN t | | |  j |    | g  f S)Nr   rr   )r,  r   r_  )r   r+  r   rm  rw   rw   rx   r  q  s
    zWordStart.parseImpl)r   r   r   r   rV   r   r  rw   rw   )rF  rx   r1   d  s   c                   s:   e  Z d  Z d Z e   f d d  Z d d d  Z   S)r0   aZ  
    Matches if the current position is at the end of a Word, and
    is not followed by any character in a given set of C{wordChars}
    (default=C{printables}). To emulate the C{} behavior of regular expressions,
    use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of
    the string being parsed, or at the end of a line.
    c                s8   t  t |   j   t |  |  _ d |  _ d |  _ d  S)NFzNot at the end of a word)r  r0   r   r  r,  rV  r_  )r   r,  )rF  rw   rx   r     s    	zWordEnd.__init__Tc             C   sp   t  |  } | d k rf | | k  rf | | |  j k sN | | d |  j k rf t | | |  j |    | g  f S)Nr   rr   )r   r,  r   r_  )r   r+  r   rm  r  rw   rw   rx   r    s    zWordEnd.parseImpl)r   r   r   r   rV   r   r  rw   rw   )rF  rx   r0   x  s   c                   s   e  Z d  Z d Z d   f d d  Z d d   Z d d   Z d	 d
   Z   f d d   Z   f d d   Z	   f d d   Z
 d   f d d  Z g  d d  Z   f d d   Z   S)r    z^
    Abstract subclass of ParserElement, for combining and post-processing parsed tokens.
    Fc                s   t  t |   j |  t | t  r1 t |  } t | t  rX t j |  g |  _	 n t | t
 j  r t |  } t d d   | D  r t t j |  } t |  |  _	 n4 y t |  |  _	 Wn t k
 r | g |  _	 Yn Xd |  _ d  S)Nc             s   s   |  ] } t  | t  Vq d  S)N)rz   r   )r   r,  rw   rw   rx   r     s    z+ParseExpression.__init__.<locals>.<genexpr>F)r  r    r   rz   r   r   r   r$   rO  exprsr  Iterableallrt  r   rc  )r   r-  re  )rF  rw   rx   r     s    zParseExpression.__init__c             C   s   |  j  | S)N)r-  )r   r   rw   rw   rx   r     s    zParseExpression.__getitem__c             C   s   |  j  j |  d  |  _ |  S)N)r-  r   rS  )r   r   rw   rw   rx   r     s    	zParseExpression.appendc             C   sD   d |  _  d d   |  j D |  _ x |  j D] } | j   q, W|  S)z~Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on
           all contained expressions.Fc             S   s   g  |  ] } | j     q Srw   )r   )r   r~  rw   rw   rx   r     s   	 z3ParseExpression.leaveWhitespace.<locals>.<listcomp>)rV  r-  r  )r   r~  rw   rw   rx   r    s
    	zParseExpression.leaveWhitespacec                s   t  | t  r_ | |  j k r t t |   j |  xf |  j D] } | j |  j d  q> Wn> t t |   j |  x% |  j D] } | j |  j d  q W|  S)Nrr   rs   rs   )rz   r+   r[  r  r    r  r-  )r   r   r~  )rF  rw   rx   r    s    zParseExpression.ignorec                sd   y t  t |   j   SWn t k
 r+ Yn X|  j d  k r] d |  j j t |  j  f |  _ |  j S)Nz%s:(%s))	r  r    r   rI  rS  rF  r   r   r-  )r   )rF  rw   rx   r     s    "zParseExpression.__str__c                s  t  t |   j   x |  j D] } | j   q Wt |  j  d k ro|  j d } t | |  j  r | j r | j d  k r | j	 r | j d  d   |  j d g |  _ d  |  _
 |  j | j O_ |  j | j O_ |  j d } t | |  j  ro| j ro| j d  k ro| j	 ro|  j d  d  | j d  d   |  _ d  |  _
 |  j | j O_ |  j | j O_ d t |   |  _ |  S)Nrq   r   rr   z	Expected rs   rs   )r  r    r  r-  r   rz   rF  rQ  rT  r\  rS  rY  r^  r   r_  )r   r~  r   )rF  rw   rx   r    s0    

$	

'	zParseExpression.streamlinec                s   t  t |   j | |  } | S)N)r  r    rk  )r   r   rj  r   )rF  rw   rx   rk    s    zParseExpression.setResultsNamec             C   sI   | d  d   |  g } x |  j  D] } | j |  q! W|  j g   d  S)N)r-  r  r  )r   r  tmpr~  rw   rw   rx   r    s    zParseExpression.validatec                s2   t  t |   j   } d d   |  j D | _ | S)Nc             S   s   g  |  ] } | j     q Srw   )r   )r   r~  rw   rw   rx   r     s   	 z(ParseExpression.copy.<locals>.<listcomp>)r  r    r   r-  )r   r   )rF  rw   rx   r     s    zParseExpression.copy)r   r   r   r   r   r   r   r  r  r   r  rk  r  r   rw   rw   )rF  rx   r      s   	
"c                   st   e  Z d  Z d Z Gd d   d e  Z d   f d d  Z d d d  Z d	 d
   Z d d   Z	 d d   Z
   S)r   a  
    Requires all given C{ParseExpression}s to be found in the given order.
    Expressions may be separated by whitespace.
    May be constructed using the C{'+'} operator.
    May also be constructed using the C{'-'} operator, which will suppress backtracking.

    Example::
        integer = Word(nums)
        name_expr = OneOrMore(Word(alphas))

        expr = And([integer("id"),name_expr("name"),integer("age")])
        # more easily written as:
        expr = integer("id") + name_expr("name") + integer("age")
    c                   s"   e  Z d  Z   f d d   Z   S)zAnd._ErrorStopc                s3   t  t j |   j | |   d |  _ |  j   d  S)N-)r  r   r  r   r   r  )r   r   r   )rF  rw   rx   r     s    	zAnd._ErrorStop.__init__)r   r   r   r   rw   rw   )rF  rx   r    s   r  Tc                so   t  t |   j | |  t d d   |  j D  |  _ |  j |  j d j  |  j d j |  _ d |  _	 d  S)Nc             s   s   |  ] } | j  Vq d  S)N)rY  )r   r~  rw   rw   rx   r     s    zAnd.__init__.<locals>.<genexpr>r   T)
r  r   r   r/  r-  rY  r  rW  rV  rc  )r   r-  re  )rF  rw   rx   r     s
    zAnd.__init__c       	      C   sS  |  j  d j | | | d d \ } } d } x|  j  d d   D]} t | t j  rc d } qB | ry | j | | |  \ } } Wq)t k
 r   Yq)t k
 r } z d  | _ t j |   WYd  d  } ~ Xq)t	 k
 r
t | t
 |  |  j |    Yq)Xn | j | | |  \ } } | s;| j   rB | | 7} qB W| | f S)Nr   rn  Frr   T)r-  rr  rz   r   r  r#   r   __traceback__r   r   r   r_  r   )	r   r+  r   rm  
resultlistZ	errorStopr~  Z
exprtokensr   rw   rw   rx   r    s(    (	!&zAnd.parseImplc             C   s+   t  | t  r t j |  } |  j |  S)N)rz   r   r$   rO  r   )r   r   rw   rw   rx   r  5  s    zAnd.__iadd__c             C   sF   | d  d   |  g } x( |  j  D] } | j |  | j s! Pq! Wd  S)N)r-  r  rY  )r   r   subRecCheckListr~  rw   rw   rx   r  :  s
    	zAnd.checkRecursionc             C   sV   t  |  d  r |  j S|  j d  k rO d d j d d   |  j D  d |  _ |  j S)Nr   {r  c             s   s   |  ] } t  |  Vq d  S)N)r   )r   r~  rw   rw   rx   r   F  s    zAnd.__str__.<locals>.<genexpr>})r   r   rS  r   r-  )r   rw   rw   rx   r   A  s
    *zAnd.__str__)r   r   r   r   r   r  r   r  r  r  r   rw   rw   )rF  rx   r     s   c                   s^   e  Z d  Z d Z d   f d d  Z d d d  Z d d	   Z d
 d   Z d d   Z   S)r   a  
    Requires that at least one C{ParseExpression} is found.
    If two expressions match, the expression that matches the longest string will be used.
    May be constructed using the C{'^'} operator.

    Example::
        # construct Or using '^' operator
        
        number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
        print(number.searchString("123 3.1416 789"))
    prints::
        [['123'], ['3.1416'], ['789']]
    Fc                sQ   t  t |   j | |  |  j rD t d d   |  j D  |  _ n	 d |  _ d  S)Nc             s   s   |  ] } | j  Vq d  S)N)rY  )r   r~  rw   rw   rx   r   \  s    zOr.__init__.<locals>.<genexpr>T)r  r   r   r-  r  rY  )r   r-  re  )rF  rw   rx   r   Y  s    	"zOr.__init__Tc             C   s  d } d  } g  } x |  j  D] } y | j | |  } Wn t k
 r }	 z, d  |	 _ |	 j | k rt |	 } |	 j } WYd  d  }	 ~	 Xq t k
 r t |  | k r t | t |  | j |   } t |  } Yq X| j | | f  q W| r| j	 d d d    xz | D]r \ }
 } y | j
 | | |  SWqt k
 r}	 z, d  |	 _ |	 j | k rm|	 } |	 j } WYd  d  }	 ~	 XqXqW| d  k	 r|  j | _ |  n t | | d |    d  S)Nrr   r   c             S   s	   |  d S)Nr   rw   )xrw   rw   rx   ry   u  s    zOr.parseImpl.<locals>.<lambda>z no defined alternatives to matchrs   )r-  r  r   r2  r   r   r   r_  r   sortrr  r   )r   r+  r   rm  	maxExcLocmaxExceptionr  r~  Zloc2r  _rw   rw   rx   r  `  s<    		 	zOr.parseImplc             C   s+   t  | t  r t j |  } |  j |  S)N)rz   r   r$   rO  r   )r   r   rw   rw   rx   __ixor__  s    zOr.__ixor__c             C   sV   t  |  d  r |  j S|  j d  k rO d d j d d   |  j D  d |  _ |  j S)Nr   r5  z ^ c             s   s   |  ] } t  |  Vq d  S)N)r   )r   r~  rw   rw   rx   r     s    zOr.__str__.<locals>.<genexpr>r6  )r   r   rS  r   r-  )r   rw   rw   rx   r     s
    *z
Or.__str__c             C   s<   | d  d   |  g } x |  j  D] } | j |  q! Wd  S)N)r-  r  )r   r   r4  r~  rw   rw   rx   r    s    zOr.checkRecursion)	r   r   r   r   r   r  r<  r   r  rw   rw   )rF  rx   r   K  s   &	c                   s^   e  Z d  Z d Z d   f d d  Z d d d  Z d d	   Z d
 d   Z d d   Z   S)r   a  
    Requires that at least one C{ParseExpression} is found.
    If two expressions match, the first one listed is the one that will match.
    May be constructed using the C{'|'} operator.

    Example::
        # construct MatchFirst using '|' operator
        
        # watch the order of expressions to match
        number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
        print(number.searchString("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]

        # put more selective expression first
        number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
        print(number.searchString("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
    Fc                sQ   t  t |   j | |  |  j rD t d d   |  j D  |  _ n	 d |  _ d  S)Nc             s   s   |  ] } | j  Vq d  S)N)rY  )r   r~  rw   rw   rx   r     s    z&MatchFirst.__init__.<locals>.<genexpr>T)r  r   r   r-  r  rY  )r   r-  re  )rF  rw   rx   r     s    	"zMatchFirst.__init__Tc       	      C   s
  d } d  } x |  j  D] } y | j | | |  } | SWq t k
 r~ } z# | j | k rl | } | j } WYd  d  } ~ Xq t k
 r t |  | k r t | t |  | j |   } t |  } Yq Xq W| d  k	 r |  j | _ |  n t | | d |    d  S)Nrr   z no defined alternatives to matchrs   )r-  rr  r   r   r   r   r_  r   )	r   r+  r   rm  r9  r:  r~  r   r  rw   rw   rx   r    s$    	zMatchFirst.parseImplc             C   s+   t  | t  r t j |  } |  j |  S)N)rz   r   r$   rO  r   )r   r   rw   rw   rx   __ior__  s    zMatchFirst.__ior__c             C   sV   t  |  d  r |  j S|  j d  k rO d d j d d   |  j D  d |  _ |  j S)Nr   r5  z | c             s   s   |  ] } t  |  Vq d  S)N)r   )r   r~  rw   rw   rx   r     s    z%MatchFirst.__str__.<locals>.<genexpr>r6  )r   r   rS  r   r-  )r   rw   rw   rx   r     s
    *zMatchFirst.__str__c             C   s<   | d  d   |  g } x |  j  D] } | j |  q! Wd  S)N)r-  r  )r   r   r4  r~  rw   rw   rx   r    s    zMatchFirst.checkRecursion)	r   r   r   r   r   r  r=  r   r  rw   rw   )rF  rx   r     s   	c                   sR   e  Z d  Z d Z d   f d d  Z d d d  Z d d   Z d	 d
   Z   S)r   am  
    Requires all given C{ParseExpression}s to be found, but in any order.
    Expressions may be separated by whitespace.
    May be constructed using the C{'&'} operator.

    Example::
        color = oneOf("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")
        shape_type = oneOf("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")
        integer = Word(nums)
        shape_attr = "shape:" + shape_type("shape")
        posn_attr = "posn:" + Group(integer("x") + ',' + integer("y"))("posn")
        color_attr = "color:" + color("color")
        size_attr = "size:" + integer("size")

        # use Each (using operator '&') to accept attributes in any order 
        # (shape and posn are required, color and size are optional)
        shape_spec = shape_attr & posn_attr & Optional(color_attr) & Optional(size_attr)

        shape_spec.runTests('''
            shape: SQUARE color: BLACK posn: 100, 120
            shape: CIRCLE size: 50 color: BLUE posn: 50,80
            color:GREEN size:20 shape:TRIANGLE posn:20,40
            '''
            )
    prints::
        shape: SQUARE color: BLACK posn: 100, 120
        ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]
        - color: BLACK
        - posn: ['100', ',', '120']
          - x: 100
          - y: 120
        - shape: SQUARE


        shape: CIRCLE size: 50 color: BLUE posn: 50,80
        ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]
        - color: BLUE
        - posn: ['50', ',', '80']
          - x: 50
          - y: 80
        - shape: CIRCLE
        - size: 50


        color: GREEN size: 20 shape: TRIANGLE posn: 20,40
        ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]
        - color: GREEN
        - posn: ['20', ',', '40']
          - x: 20
          - y: 40
        - shape: TRIANGLE
        - size: 20
    Tc                sN   t  t |   j | |  t d d   |  j D  |  _ d |  _ d |  _ d  S)Nc             s   s   |  ] } | j  Vq d  S)N)rY  )r   r~  rw   rw   rx   r     s    z Each.__init__.<locals>.<genexpr>T)r  r   r   r/  r-  rY  rV  initExprGroups)r   r-  re  )rF  rw   rx   r     s    	zEach.__init__c                s  |  j  r t d d   |  j D  |  _ d d   |  j D } d d   |  j D } | | |  _ d d   |  j D |  _ d d   |  j D |  _ d d   |  j D |  _ |  j |  j 7_ d	 |  _  | } |  j d  d   } |  j d  d     g  } d
 }	 x |	 r|   |  j |  j }
 g  } x |
 D] } y | j | |  } Wn t	 k
 rj| j
 |  Yq-X| j
 |  j j t |  |   | | k r| j |  q-|   k r-  j |  q-Wt |  t |
  k rd	 }	 qW| r d j d d   | D  } t	 | | d |   |   f d d   |  j D 7} g  } x6 | D]. } | j | | |  \ } } | j
 |  qMWt | t g    } | | f S)Nc             s   s3   |  ]) } t  | t  r t | j  | f Vq d  S)N)rz   r   r  r,  )r   r~  rw   rw   rx   r     s    z!Each.parseImpl.<locals>.<genexpr>c             S   s(   g  |  ] } t  | t  r | j  q Srw   )rz   r   r,  )r   r~  rw   rw   rx   r     s   	 z"Each.parseImpl.<locals>.<listcomp>c             S   s/   g  |  ]% } | j  r t | t  r |  q Srw   )rY  rz   r   )r   r~  rw   rw   rx   r     s   	 c             S   s(   g  |  ] } t  | t  r | j  q Srw   )rz   r2   r,  )r   r~  rw   rw   rx   r      s   	 c             S   s(   g  |  ] } t  | t  r | j  q Srw   )rz   r   r,  )r   r~  rw   rw   rx   r   !  s   	 c             S   s.   g  |  ]$ } t  | t t t f  s |  q Srw   )rz   r   r2   r   )r   r~  rw   rw   rx   r   "  s   	 FTz, c             s   s   |  ] } t  |  Vq d  S)N)r   )r   r~  rw   rw   rx   r   =  s    z*Missing one or more required elements (%s)c                s4   g  |  ]* } t  | t  r | j   k r |  q Srw   )rz   r   r,  )r   r~  )tmpOptrw   rx   r   A  s   	 )r>  r   r-  Zopt1mapZ	optionalsZmultioptionalsZmultirequiredZrequiredr  r   r   r   r  remover   r   rr  sumr"   )r   r+  r   rm  Zopt1Zopt2ZtmpLocZtmpReqdZ
matchOrderZkeepMatchingZtmpExprsZfailedr~  Zmissingr3  r  ZfinalResultsrw   )r?  rx   r    sP    			"
 zEach.parseImplc             C   sV   t  |  d  r |  j S|  j d  k rO d d j d d   |  j D  d |  _ |  j S)Nr   r5  z & c             s   s   |  ] } t  |  Vq d  S)N)r   )r   r~  rw   rw   rx   r   P  s    zEach.__str__.<locals>.<genexpr>r6  )r   r   rS  r   r-  )r   rw   rw   rx   r   K  s
    *zEach.__str__c             C   s<   | d  d   |  g } x |  j  D] } | j |  q! Wd  S)N)r-  r  )r   r   r4  r~  rw   rw   rx   r  T  s    zEach.checkRecursion)r   r   r   r   r   r  r   r  rw   rw   )rF  rx   r     s
   51	c                   s   e  Z d  Z d Z d   f d d  Z d d d  Z d d	   Z   f d
 d   Z   f d d   Z d d   Z	 g  d d  Z
   f d d   Z   S)r   za
    Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens.
    Fc                s   t  t |   j |  t | t  r^ t t j t  rI t j |  } n t j t	 |   } | |  _
 d  |  _ | d  k	 r | j |  _ | j |  _ |  j | j  | j |  _ | j |  _ | j |  _ |  j j | j  d  S)N)r  r   r   rz   r   
issubclassr$   rO  r,   r   r,  rS  r^  rY  r  rW  rV  rU  rc  r[  r   )r   r,  re  )rF  rw   rx   r   ^  s    		zParseElementEnhance.__init__Tc             C   sG   |  j  d  k	 r+ |  j  j | | | d d St d | |  j |    d  S)Nrn  Fr   )r,  rr  r   r_  )r   r+  r   rm  rw   rw   rx   r  p  s    zParseElementEnhance.parseImplc             C   s;   d |  _  |  j j   |  _ |  j d  k	 r7 |  j j   |  S)NF)rV  r,  r   r  )r   rw   rw   rx   r  v  s
    	z#ParseElementEnhance.leaveWhitespacec                s   t  | t  r] | |  j k r t t |   j |  |  j d  k	 r |  j j |  j d  n< t t |   j |  |  j d  k	 r |  j j |  j d  |  S)Nrr   rs   rs   )rz   r+   r[  r  r   r  r,  )r   r   )rF  rw   rx   r  }  s    zParseElementEnhance.ignorec                s3   t  t |   j   |  j d  k	 r/ |  j j   |  S)N)r  r   r  r,  )r   )rF  rw   rx   r    s    zParseElementEnhance.streamlinec             C   sY   |  | k r t  | |  g   | d  d   |  g } |  j d  k	 rU |  j j |  d  S)N)r&   r,  r  )r   r   r4  rw   rw   rx   r    s
    z"ParseElementEnhance.checkRecursionc             C   sG   | d  d   |  g } |  j  d  k	 r6 |  j  j |  |  j g   d  S)N)r,  r  r  )r   r  r0  rw   rw   rx   r    s    zParseElementEnhance.validatec                ss   y t  t |   j   SWn t k
 r+ Yn X|  j d  k rl |  j d  k	 rl d |  j j t |  j  f |  _ |  j S)Nz%s:(%s))	r  r   r   rI  rS  r,  rF  r   r   )r   )rF  rw   rx   r     s    "zParseElementEnhance.__str__)r   r   r   r   r   r  r  r  r  r  r  r   rw   rw   )rF  rx   r   Z  s   c                   s7   e  Z d  Z d Z   f d d   Z d d d  Z   S)r   a  
    Lookahead matching of the given parse expression.  C{FollowedBy}
    does I{not} advance the parsing position within the input string, it only
    verifies that the specified parse expression matches at the current
    position.  C{FollowedBy} always returns a null token list.

    Example::
        # use FollowedBy to match a label only if it is followed by a ':'
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        
        OneOrMore(attr_expr).parseString("shape: SQUARE color: BLACK posn: upper left").pprint()
    prints::
        [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]
    c                s#   t  t |   j |  d |  _ d  S)NT)r  r   r   rY  )r   r,  )rF  rw   rx   r     s    zFollowedBy.__init__Tc             C   s   |  j  j | |  | g  f S)N)r,  r  )r   r+  r   rm  rw   rw   rx   r    s    zFollowedBy.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r     s   c                   sC   e  Z d  Z d Z   f d d   Z d d d  Z d d   Z   S)	r   a  
    Lookahead to disallow matching with the given parse expression.  C{NotAny}
    does I{not} advance the parsing position within the input string, it only
    verifies that the specified parse expression does I{not} match at the current
    position.  Also, C{NotAny} does I{not} skip over leading whitespace. C{NotAny}
    always returns a null token list.  May be constructed using the '~' operator.

    Example::
        
    c                sB   t  t |   j |  d |  _ d |  _ d t |  j  |  _ d  S)NFTzFound unwanted token, )r  r   r   rV  rY  r   r,  r_  )r   r,  )rF  rw   rx   r     s    		zNotAny.__init__Tc             C   s7   |  j  j | |  r- t | | |  j |    | g  f S)N)r,  r  r   r_  )r   r+  r   rm  rw   rw   rx   r    s    zNotAny.parseImplc             C   sF   t  |  d  r |  j S|  j d  k r? d t |  j  d |  _ |  j S)Nr   z~{r6  )r   r   rS  r   r,  )r   rw   rw   rx   r     s
    zNotAny.__str__)r   r   r   r   r   r  r   rw   rw   )rF  rx   r     s   
c                   s4   e  Z d  Z d   f d d  Z d d d  Z   S)_MultipleMatchNc                sc   t  t |   j |  d |  _ | } t | t  rC t j |  } | d  k	 rV | n d  |  _ d  S)NT)	r  rC  r   rU  rz   r   r$   rO  	not_ender)r   r,  stopOnZender)rF  rw   rx   r     s    	z_MultipleMatch.__init__Tc             C   s  |  j  j } |  j } |  j d  k	 } | r6 |  j j } | rI | | |  | | | | d d \ } } y{ |  j }	 xi | r | | |  |	 r | | |  }
 n | }
 | | |
 |  \ } } | s | j   rx | | 7} qx WWn t t f k
 r Yn X| | f S)Nrn  F)	r,  rr  r  rD  r  r[  r   r   r   )r   r+  r   rm  Zself_expr_parseZself_skip_ignorablesZcheck_enderZtry_not_enderr  ZhasIgnoreExprsr  Z	tmptokensrw   rw   rx   r    s,    	z_MultipleMatch.parseImpl)r   r   r   r   r  rw   rw   )rF  rx   rC    s   rC  c               @   s"   e  Z d  Z d Z d d   Z d S)r   a  
    Repetition of one or more of the given expression.
    
    Parameters:
     - expr - expression that must match one or more times
     - stopOn - (default=C{None}) - expression for a terminating sentinel
          (only required if the sentinel would ordinarily match the repetition 
          expression)          

    Example::
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))

        text = "shape: SQUARE posn: upper left color: BLACK"
        OneOrMore(attr_expr).parseString(text).pprint()  # Fail! read 'color' as data instead of next label -> [['shape', 'SQUARE color']]

        # use stopOn attribute for OneOrMore to avoid reading label string as part of the data
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        OneOrMore(attr_expr).parseString(text).pprint() # Better -> [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]
        
        # could also be written as
        (attr_expr * (1,)).parseString(text).pprint()
    c             C   sF   t  |  d  r |  j S|  j d  k r? d t |  j  d |  _ |  j S)Nr   r5  z}...)r   r   rS  r   r,  )r   rw   rw   rx   r   !  s
    zOneOrMore.__str__N)r   r   r   r   r   rw   rw   rw   rx   r     s   c                   sL   e  Z d  Z d Z d   f d d  Z d   f d d  Z d d	   Z   S)
r2   aw  
    Optional repetition of zero or more of the given expression.
    
    Parameters:
     - expr - expression that must match zero or more times
     - stopOn - (default=C{None}) - expression for a terminating sentinel
          (only required if the sentinel would ordinarily match the repetition 
          expression)          

    Example: similar to L{OneOrMore}
    Nc                s)   t  t |   j | d | d |  _ d  S)NrE  T)r  r2   r   rY  )r   r,  rE  )rF  rw   rx   r   6  s    zZeroOrMore.__init__Tc                sI   y  t  t |   j | | |  SWn" t t f k
 rD | g  f SYn Xd  S)N)r  r2   r  r   r   )r   r+  r   rm  )rF  rw   rx   r  :  s     zZeroOrMore.parseImplc             C   sF   t  |  d  r |  j S|  j d  k r? d t |  j  d |  _ |  j S)Nr   r  z]...)r   r   rS  r   r,  )r   rw   rw   rx   r   @  s
    zZeroOrMore.__str__)r   r   r   r   r   r  r   rw   rw   )rF  rx   r2   *  s   c               @   s.   e  Z d  Z d d   Z e Z d d   Z d S)
_NullTokenc             C   s   d S)NFrw   )r   rw   rw   rx   r   J  s    z_NullToken.__bool__c             C   s   d S)Nr   rw   )r   rw   rw   rx   r   M  s    z_NullToken.__str__N)r   r   r   r   r%  r   rw   rw   rw   rx   rF  I  s   rF  c                   sF   e  Z d  Z d Z e   f d d  Z d d d  Z d d   Z   S)	r   aa  
    Optional matching of the given expression.

    Parameters:
     - expr - expression that must match zero or more times
     - default (optional) - value to be returned if the optional expression is not found.

    Example::
        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier
        zip = Combine(Word(nums, exact=5) + Optional('-' + Word(nums, exact=4)))
        zip.runTests('''
            # traditional ZIP code
            12345
            
            # ZIP+4 form
            12101-0001
            
            # invalid ZIP
            98765-
            ''')
    prints::
        # traditional ZIP code
        12345
        ['12345']

        # ZIP+4 form
        12101-0001
        ['12101-0001']

        # invalid ZIP
        98765-
             ^
        FAIL: Expected end of text (at char 5), (line:1, col:6)
    c                sA   t  t |   j | d d |  j j |  _ | |  _ d |  _ d  S)Nre  FT)r  r   r   r,  rU  r   rY  )r   r,  r   )rF  rw   rx   r   t  s    	zOptional.__init__Tc             C   s   y( |  j  j | | | d d \ } } Wnp t t f k
 r |  j t k	 r |  j  j r t |  j g  } |  j | |  j  j <q |  j g } n g  } Yn X| | f S)Nrn  F)r,  rr  r   r   r   _optionalNotMatchedrT  r"   )r   r+  r   rm  r  rw   rw   rx   r  z  s    (zOptional.parseImplc             C   sF   t  |  d  r |  j S|  j d  k r? d t |  j  d |  _ |  j S)Nr   r  r  )r   r   rS  r   r,  )r   rw   rw   rx   r     s
    zOptional.__str__)r   r   r   r   rG  r   r  r   rw   rw   )rF  rx   r   Q  s   "c                   s@   e  Z d  Z d Z d d d   f d d  Z d d d  Z   S)	r(   a	  
    Token for skipping over all undefined text until the matched expression is found.

    Parameters:
     - expr - target expression marking the end of the data to be skipped
     - include - (default=C{False}) if True, the target expression is also parsed 
          (the skipped text and target expression are returned as a 2-element list).
     - ignore - (default=C{None}) used to define grammars (typically quoted strings and 
          comments) that might contain false matches to the target expression
     - failOn - (default=C{None}) define expressions that are not allowed to be 
          included in the skipped test; if found before the target expression is found, 
          the SkipTo is not a match

    Example::
        report = '''
            Outstanding Issues Report - 1 Jan 2000

               # | Severity | Description                               |  Days Open
            -----+----------+-------------------------------------------+-----------
             101 | Critical | Intermittent system crash                 |          6
              94 | Cosmetic | Spelling error on Login ('log|n')         |         14
              79 | Minor    | System slow when running too many reports |         47
            '''
        integer = Word(nums)
        SEP = Suppress('|')
        # use SkipTo to simply match everything up until the next SEP
        # - ignore quoted strings, so that a '|' character inside a quoted string does not match
        # - parse action will call token.strip() for each matched token, i.e., the description body
        string_data = SkipTo(SEP, ignore=quotedString)
        string_data.setParseAction(tokenMap(str.strip))
        ticket_expr = (integer("issue_num") + SEP 
                      + string_data("sev") + SEP 
                      + string_data("desc") + SEP 
                      + integer("days_open"))
        
        for tkt in ticket_expr.searchString(report):
            print tkt.dump()
    prints::
        ['101', 'Critical', 'Intermittent system crash', '6']
        - days_open: 6
        - desc: Intermittent system crash
        - issue_num: 101
        - sev: Critical
        ['94', 'Cosmetic', "Spelling error on Login ('log|n')", '14']
        - days_open: 14
        - desc: Spelling error on Login ('log|n')
        - issue_num: 94
        - sev: Cosmetic
        ['79', 'Minor', 'System slow when running too many reports', '47']
        - days_open: 47
        - desc: System slow when running too many reports
        - issue_num: 79
        - sev: Minor
    FNc                s   t  t |   j |  | |  _ d |  _ d |  _ | |  _ d |  _ t | t	  rg t
 j |  |  _ n	 | |  _ d t |  j  |  _ d  S)NTFzNo match found for )r  r(   r   
ignoreExprrY  r^  includeMatchr   rz   r   r$   rO  failOnr   r,  r_  )r   r   includer  rJ  )rF  rw   rx   r     s    						zSkipTo.__init__Tc             C   s  | } t  |  } |  j } |  j j } |  j d  k	 rB |  j j n d  } |  j d  k	 rc |  j j n d  }	 | }
 x |
 | k r| d  k	 r | | |
  r P|	 d  k	 r x- y |	 | |
  }
 Wq t k
 r PYq Xq Wy | | |
 d d d d Wn" t t	 f k
 r|
 d 7}
 Yqr XPqr Wt | | |  j
 |    |
 } | | |  } t |  } |  j r| | | | d d \ } } | | 7} | | f S)Nrm  Frn  rr   )r   r,  rr  rJ  r  rH  r  r   r   r   r_  r"   rI  )r   r+  r   rm  r.  r  r,  Z
expr_parseZself_failOn_canParseNextZself_ignoreExpr_tryParseZtmplocZskiptextZ
skipresultr  rw   rw   rx   r    s<    	!!
	
zSkipTo.parseImpl)r   r   r   r   r   r  rw   rw   )rF  rx   r(     s   6c                   s   e  Z d  Z d Z d   f d d  Z d d   Z d d   Z d	 d
   Z d d   Z g  d d  Z	 d d   Z
   f d d   Z   S)r   aK  
    Forward declaration of an expression to be defined later -
    used for recursive grammars, such as algebraic infix notation.
    When the expression is known, it is assigned to the C{Forward} variable using the '<<' operator.

    Note: take care when assigning to C{Forward} not to overlook precedence of operators.
    Specifically, '|' has a lower precedence than '<<', so that::
        fwdExpr << a | b | c
    will actually be evaluated as::
        (fwdExpr << a) | b | c
    thereby leaving b and c out as parseable alternatives.  It is recommended that you
    explicitly group the values inserted into the C{Forward}::
        fwdExpr << (a | b | c)
    Converting to use the '<<=' operator instead will avoid this problem.

    See L{ParseResults.pprint} for an example of a recursive parser created using
    C{Forward}.
    Nc                s    t  t |   j | d d d  S)Nre  F)r  r   r   )r   r   )rF  rw   rx   r     s    zForward.__init__c             C   s   t  | t  r t j |  } | |  _ d  |  _ |  j j |  _ |  j j |  _ |  j |  j j	  |  j j
 |  _
 |  j j |  _ |  j j |  j j  |  S)N)rz   r   r$   rO  r,  rS  r^  rY  r  rW  rV  rU  r[  r   )r   r   rw   rw   rx   
__lshift__  s    		zForward.__lshift__c             C   s   |  | >S)Nrw   )r   r   rw   rw   rx   __ilshift__'  s    zForward.__ilshift__c             C   s   d |  _  |  S)NF)rV  )r   rw   rw   rx   r  *  s    	zForward.leaveWhitespacec             C   s2   |  j  s. d |  _  |  j d  k	 r. |  j j   |  S)NT)r]  r,  r  )r   rw   rw   rx   r  .  s
    		zForward.streamlinec             C   sS   |  | k rB | d  d   |  g } |  j  d  k	 rB |  j  j |  |  j g   d  S)N)r,  r  r  )r   r  r0  rw   rw   rx   r  5  s
    zForward.validatec             C   s   t  |  d  r |  j S|  j j d S|  j |  _ t |  _ z+ |  j d  k	 r] t |  j  } n d } Wd  |  j |  _ X|  j j d | S)Nr   z: ...Nonez: )r   r   rF  r   Z_revertClass_ForwardNoRecurser,  r   )r   Z	retStringrw   rw   rx   r   <  s    	
zForward.__str__c                s=   |  j  d  k	 r" t t |   j   St   } | |  K} | Sd  S)N)r,  r  r   r   )r   r   )rF  rw   rx   r   M  s
    	
zForward.copy)r   r   r   r   r   rL  rM  r  r  r  r   r   rw   rw   )rF  rx   r     s   c               @   s   e  Z d  Z d d   Z d S)rO  c             C   s   d S)Nz...rw   )r   rw   rw   rx   r   V  s    z_ForwardNoRecurse.__str__N)r   r   r   r   rw   rw   rw   rx   rO  U  s   rO  c                   s+   e  Z d  Z d Z d   f d d  Z   S)r-   zQ
    Abstract subclass of C{ParseExpression}, for converting parsed results.
    Fc                s#   t  t |   j |  d |  _ d  S)NF)r  r-   r   rU  )r   r,  re  )rF  rw   rx   r   ]  s    zTokenConverter.__init__)r   r   r   r   r   rw   rw   )rF  rx   r-   Y  s   c                   sL   e  Z d  Z d Z d d   f d d  Z   f d d   Z d d	   Z   S)
r
   a  
    Converter to concatenate all matching tokens to a single string.
    By default, the matching patterns must also be contiguous in the input string;
    this can be disabled by specifying C{'adjacent=False'} in the constructor.

    Example::
        real = Word(nums) + '.' + Word(nums)
        print(real.parseString('3.1416')) # -> ['3', '.', '1416']
        # will also erroneously match the following
        print(real.parseString('3. 1416')) # -> ['3', '.', '1416']

        real = Combine(Word(nums) + '.' + Word(nums))
        print(real.parseString('3.1416')) # -> ['3.1416']
        # no match when there are internal spaces
        print(real.parseString('3. 1416')) # -> Exception: Expected W:(0123...)
    r   Tc                sN   t  t |   j |  | r& |  j   | |  _ d |  _ | |  _ d |  _ d  S)NT)r  r
   r   r  adjacentrV  
joinStringrc  )r   r,  rQ  rP  )rF  rw   rx   r   r  s    
			zCombine.__init__c                s6   |  j  r t j |  |  n t t |   j |  |  S)N)rP  r$   r  r  r
   )r   r   )rF  rw   rx   r  |  s    	zCombine.ignorec             C   sn   | j    } | d  d   =| t d j | j |  j   g d |  j 7} |  j rf | j   rf | g S| Sd  S)Nr   r   )r   r"   r   r	  rQ  r`  rT  r   )r   r+  r   r  ZretToksrw   rw   rx   r    s    1zCombine.postParse)r   r   r   r   r   r  r  rw   rw   )rF  rx   r
   a  s   
c                   s4   e  Z d  Z d Z   f d d   Z d d   Z   S)r   a  
    Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions.

    Example::
        ident = Word(alphas)
        num = Word(nums)
        term = ident | num
        func = ident + Optional(delimitedList(term))
        print(func.parseString("fn a,b,100"))  # -> ['fn', 'a', 'b', '100']

        func = ident + Group(Optional(delimitedList(term)))
        print(func.parseString("fn a,b,100"))  # -> ['fn', ['a', 'b', '100']]
    c                s#   t  t |   j |  d |  _ d  S)NT)r  r   r   rU  )r   r,  )rF  rw   rx   r     s    zGroup.__init__c             C   s   | g S)Nrw   )r   r+  r   r  rw   rw   rx   r    s    zGroup.postParse)r   r   r   r   r   r  rw   rw   )rF  rx   r     s   c                   s4   e  Z d  Z d Z   f d d   Z d d   Z   S)r   aW  
    Converter to return a repetitive expression as a list, but also as a dictionary.
    Each element can also be referenced using the first token in the expression as its key.
    Useful for tabular report scraping when the first column can be used as a item key.

    Example::
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))

        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        
        # print attributes as plain groups
        print(OneOrMore(attr_expr).parseString(text).dump())
        
        # instead of OneOrMore(expr), parse using Dict(OneOrMore(Group(expr))) - Dict will auto-assign names
        result = Dict(OneOrMore(Group(attr_expr))).parseString(text)
        print(result.dump())
        
        # access named fields as dict entries, or output as dict
        print(result['shape'])        
        print(result.asDict())
    prints::
        ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']

        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
        - color: light blue
        - posn: upper left
        - shape: SQUARE
        - texture: burlap
        SQUARE
        {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}
    See more examples at L{ParseResults} of accessing fields by results name.
    c                s#   t  t |   j |  d |  _ d  S)NT)r  r   r   rU  )r   r,  )rF  rw   rx   r     s    zDict.__init__c             C   sN  x3t  |  D]%\ } } t |  d k r. q | d } t | t  r] t | d  j   } t |  d k r t d |  | | <q t |  d k r t | d t  r t | d |  | | <q | j   } | d =t |  d k st | t  r| j	   rt | |  | | <q t | d |  | | <q W|  j
 rF| g S| Sd  S)Nr   rr   r   rq   )r   r   rz   ru   r   r   r   r"   r   r   rT  )r   r+  r   r  r   tokZikeyZ	dictvaluerw   rw   rx   r    s$    
&-	zDict.postParse)r   r   r   r   r   r  rw   rw   )rF  rx   r     s   #c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)r+   aV  
    Converter for ignoring the results of a parsed expression.

    Example::
        source = "a, b, c,d"
        wd = Word(alphas)
        wd_list1 = wd + ZeroOrMore(',' + wd)
        print(wd_list1.parseString(source))

        # often, delimiters that are useful during parsing are just in the
        # way afterward - use Suppress to keep them out of the parsed output
        wd_list2 = wd + ZeroOrMore(Suppress(',') + wd)
        print(wd_list2.parseString(source))
    prints::
        ['a', ',', 'b', ',', 'c', ',', 'd']
        ['a', 'b', 'c', 'd']
    (See also L{delimitedList}.)
    c             C   s   g  S)Nrw   )r   r+  r   r  rw   rw   rx   r    s    zSuppress.postParsec             C   s   |  S)Nrw   )r   rw   rw   rx   r    s    zSuppress.suppressN)r   r   r   r   r  r  rw   rw   rw   rx   r+     s   c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	r   zI
    Wrapper for parse actions, to ensure they are only called once.
    c             C   s   t  |  |  _ d |  _ d  S)NF)rK  callablecalled)r   Z
methodCallrw   rw   rx   r     s    zOnlyOnce.__init__c             C   sA   |  j  s+ |  j | | |  } d |  _  | St | | d   d  S)NTr   )rT  rS  r   )r   r   r3  rv   r  rw   rw   rx   r    s
    		zOnlyOnce.__call__c             C   s   d |  _  d  S)NF)rT  )r   rw   rw   rx   reset
  s    zOnlyOnce.resetN)r   r   r   r   r   r  rU  rw   rw   rw   rx   r     s   c                sG   t         f d d   } y   j | _ Wn t k
 rB Yn X| S)as  
    Decorator for debugging parse actions. 
    
    When the parse action is called, this decorator will print C{">> entering I{method-name}(line:I{current_source_line}, I{parse_location}, I{matched_tokens})".}
    When the parse action completes, the decorator will print C{"<<"} followed by the returned value, or any exception that the parse action raised.

    Example::
        wd = Word(alphas)

        @traceParseAction
        def remove_duplicate_chars(tokens):
            return ''.join(sorted(set(''.join(tokens)))

        wds = OneOrMore(wd).setParseAction(remove_duplicate_chars)
        print(wds.parseString("slkdjs sld sldd sdlf sdljf"))
    prints::
        >>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))
        <<leaving remove_duplicate_chars (ret: 'dfjkls')
        ['dfjkls']
    c                 s     j  } |  d d   \ } } } t |   d k rL |  d j j  d | } t j j d | t | |  | | f  y   |    } WnB t k
 r } z" t j j d | | f    WYd  d  } ~ Xn Xt j j d | | f  | S)Nro   r   .z">>entering %s(line: '%s', %d, %r)
z<<leaving %s (exception: %s)
z<<leaving %s (ret: %r)
r7  )r   r   rF  r~   stderrwriterG   rI  )ZpaArgsZthisFuncr   r3  rv   r   r1  )r  rw   rx   z#  s    	)ztraceParseAction.<locals>.z)rK  r   r   )r  rY  rw   )r  rx   rb     s    ,Fc             C   sx   t  |   d t  |  d t  |   d } | rS t |  t | |    j |  S|  t t |  |   j |  Sd S)a  
    Helper to define a delimited list of expressions - the delimiter defaults to ','.
    By default, the list elements and delimiters can have intervening whitespace, and
    comments, but this can be overridden by passing C{combine=True} in the constructor.
    If C{combine} is set to C{True}, the matching tokens are returned as a single token
    string, with the delimiters included; otherwise, the matching tokens are returned
    as a list of tokens, with the delimiters suppressed.

    Example::
        delimitedList(Word(alphas)).parseString("aa,bb,cc") # -> ['aa', 'bb', 'cc']
        delimitedList(Word(hexnums), delim=':', combine=True).parseString("AA:BB:CC:DD:EE") # -> ['AA:BB:CC:DD:EE']
    z [r  z]...N)r   r
   r2   rg  r+   )r,  ZdelimcombineZdlNamerw   rw   rx   r@   9  s    ,!c                s   t         f d d   } | d k rH t t  j d d    } n | j   } | j d  | j | d d |   j d	 t   d
  S)a:  
    Helper to define a counted list of expressions.
    This helper defines a pattern of the form::
        integer expr expr expr...
    where the leading integer tells how many expr expressions follow.
    The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.
    
    If C{intExpr} is specified, it should be a pyparsing expression that produces an integer value.

    Example::
        countedArray(Word(alphas)).parseString('2 ab cd ef')  # -> ['ab', 'cd']

        # in this parser, the leading integer value is given in binary,
        # '10' indicating that 2 values are in the array
        binaryConstant = Word('01').setParseAction(lambda t: int(t[0], 2))
        countedArray(Word(alphas), intExpr=binaryConstant).parseString('10 ab cd ef')  # -> ['ab', 'cd']
    c                s;   | d }   | r, t  t  g |   p5 t  t  >g  S)Nr   )r   r   rC   )r   r3  rv   r  )	arrayExprr,  rw   rx   countFieldParseAction_  s    
-z+countedArray.<locals>.countFieldParseActionNc             S   s   t  |  d  S)Nr   )ru   )rv   rw   rw   rx   ry   d  s    zcountedArray.<locals>.<lambda>ZarrayLenrd  Tz(len) z...)r   r/   rR   r   r   rg  rv  r   )r,  ZintExprr]  rw   )r\  r,  rx   r<   L  s    	c             C   sM   g  } x@ |  D]8 } t  | t  r8 | j t |   q | j |  q W| S)N)rz   r   r   r  r   )Lr   r   rw   rw   rx   r  k  s    r  c                sI   t        f d d   } |  j | d d   j d t |      S)a*  
    Helper to define an expression that is indirectly defined from
    the tokens matched in a previous expression, that is, it looks
    for a 'repeat' of a previous expression.  For example::
        first = Word(nums)
        second = matchPreviousLiteral(first)
        matchExpr = first + ":" + second
    will match C{"1:1"}, but not C{"1:2"}.  Because this matches a
    previous literal, will also match the leading C{"1:1"} in C{"1:10"}.
    If this is not desired, use C{matchPreviousExpr}.
    Do I{not} use with packrat parsing enabled.
    c                sf   | rW t  |  d k r'   | d >qb t | j    }   t d d   | D  >n   t   >d  S)Nrr   r   c             s   s   |  ] } t  |  Vq d  S)N)r   )r   ttrw   rw   rx   r     s    zDmatchPreviousLiteral.<locals>.copyTokenToRepeater.<locals>.<genexpr>)r   r  r   r   r   )r   r3  rv   Ztflat)reprw   rx   copyTokenToRepeater  s    z1matchPreviousLiteral.<locals>.copyTokenToRepeaterrd  Tz(prev) )r   rv  rg  r   )r,  ra  rw   )r`  rx   rO   t  s
    	
c                s_   t      |  j   }   | K    f d d   } |  j | d d   j d t |      S)aS  
    Helper to define an expression that is indirectly defined from
    the tokens matched in a previous expression, that is, it looks
    for a 'repeat' of a previous expression.  For example::
        first = Word(nums)
        second = matchPreviousExpr(first)
        matchExpr = first + ":" + second
    will match C{"1:1"}, but not C{"1:2"}.  Because this matches by
    expressions, will I{not} match the leading C{"1:1"} in C{"1:10"};
    the expressions are evaluated first, and then compared, so
    C{"1"} is compared with C{"10"}.
    Do I{not} use with packrat parsing enabled.
    c                s;   t  | j        f d d   }  j | d d d  S)Nc                s4   t  | j    } |   k r0 t d d d   d  S)Nr   r   )r  r   r   )r   r3  rv   ZtheseTokens)matchTokensrw   rx   mustMatchTheseTokens  s    zLmatchPreviousExpr.<locals>.copyTokenToRepeater.<locals>.mustMatchTheseTokensrd  T)r  r   r   )r   r3  rv   rc  )r`  )rb  rx   ra    s    z.matchPreviousExpr.<locals>.copyTokenToRepeaterrd  Tz(prev) )r   r   rv  rg  r   )r,  Ze2ra  rw   )r`  rx   rN     s    	
c             C   sU   x$ d D] } |  j  | t |  }  q W|  j  d d  }  |  j  d d  }  t |   S)Nz\^-]r  z\nr"  z\t)r   _bslashr   )r   r   rw   rw   rx   r    s
    r  Tc       
         sZ  | r' d d   } d d   } t    n d d   } d d   } t   g  } t |  t  ri |  j   } n7 t |  t j  r t |   } n t j	 d t
 d d | s t   Sd	 } x | t |  d
 k  re| | } x t | | d
 d   D]c \ } }	 | |	 |  r| | | d
 =Pq | | |	  r | | | d
 =| j | |	  |	 } Pq W| d
 7} q W| r+| r+y t |  t d j |   k rt d d j d d   | D   j d j |   St d j d d   | D   j d j |   SWn( t k
 r*t j	 d t
 d d Yn Xt   f d d   | D  j d j |   S)a  
    Helper to quickly define a set of alternative Literals, and makes sure to do
    longest-first testing when there is a conflict, regardless of the input order,
    but returns a C{L{MatchFirst}} for best performance.

    Parameters:
     - strs - a string of space-delimited literals, or a collection of string literals
     - caseless - (default=C{False}) - treat all literals as caseless
     - useRegex - (default=C{True}) - as an optimization, will generate a Regex
          object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or
          if creating a C{Regex} raises an exception)

    Example::
        comp_oper = oneOf("< = > <= >= !=")
        var = Word(alphas)
        number = Word(nums)
        term = var | number
        comparison_expr = term + comp_oper + term
        print(comparison_expr.searchString("B = 12  AA=23 B<=AA AA>12"))
    prints::
        [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]
    c             S   s   |  j    | j    k S)N)r  )r   brw   rw   rx   ry     s    zoneOf.<locals>.<lambda>c             S   s   | j    j |  j     S)N)r  r  )r   re  rw   rw   rx   ry     s    c             S   s
   |  | k S)Nrw   )r   re  rw   rw   rx   ry     s    c             S   s   | j  |   S)N)r  )r   re  rw   rw   rx   ry     s    z6Invalid argument to oneOf, expected string or iterabler  rq   r   rr   Nr   z[%s]c             s   s   |  ] } t  |  Vq d  S)N)r  )r   symrw   rw   rx   r     s    zoneOf.<locals>.<genexpr>z | |c             s   s   |  ] } t  j |  Vq d  S)N)rb  r  )r   rf  rw   rw   rx   r     s    z7Exception creating Regex for oneOf, building MatchFirstc             3   s   |  ] }   |  Vq d  S)Nrw   )r   rf  )parseElementClassrw   rx   r     s    )r   r   rz   r   r   r  r.  r   r  r  r  r   r   r   r   r   r'   rg  rI  r   )
Zstrsr  ZuseRegexZisequalZmasksZsymbolsr   Zcurr   r   rw   )rh  rx   rS     sL    		
'!66	c             C   s   t  t t |  |    S)a  
    Helper to easily and clearly define a dictionary by specifying the respective patterns
    for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens
    in the proper order.  The key pattern can include delimiting markers or punctuation,
    as long as they are suppressed, thereby leaving the significant key text.  The value
    pattern can include named results, so that the C{Dict} results can include named token
    fields.

    Example::
        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
        print(OneOrMore(attr_expr).parseString(text).dump())
        
        attr_label = label
        attr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)

        # similar to Dict, but simpler call format
        result = dictOf(attr_label, attr_value).parseString(text)
        print(result.dump())
        print(result['shape'])
        print(result.shape)  # object attribute access works too
        print(result.asDict())
    prints::
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
        - color: light blue
        - posn: upper left
        - shape: SQUARE
        - texture: burlap
        SQUARE
        SQUARE
        {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}
    )r   r2   r   )r   r   rw   rw   rx   rA     s    !c             C   s   t    j d d    } | j   } d | _ | d  |  | d  } | r\ d d   } n d d   } | j |  |  j | _ | S)	a  
    Helper to return the original, untokenized text for a given expression.  Useful to
    restore the parsed fields of an HTML start tag into the raw tag text itself, or to
    revert separate tokens with intervening whitespace back to the original matching
    input text. By default, returns astring containing the original parsed text.  
       
    If the optional C{asString} argument is passed as C{False}, then the return value is a 
    C{L{ParseResults}} containing any results names that were originally matched, and a 
    single token containing the original matched text from the input string.  So if 
    the expression passed to C{L{originalTextFor}} contains expressions with defined
    results names, you must set C{asString} to C{False} if you want to preserve those
    results name values.

    Example::
        src = "this is test <b> bold <i>text</i> </b> normal text "
        for tag in ("b","i"):
            opener,closer = makeHTMLTags(tag)
            patt = originalTextFor(opener + SkipTo(closer) + closer)
            print(patt.searchString(src)[0])
    prints::
        ['<b> bold <i>text</i> </b>']
        ['<i>text</i>']
    c             S   s   | S)Nrw   )r   r   rv   rw   rw   rx   ry   8  s    z!originalTextFor.<locals>.<lambda>F_original_start_original_endc             S   s   |  | j  | j  S)N)ri  rj  )r   r3  rv   rw   rw   rx   ry   =  s    c             S   s3   |  | j  d  | j  d   g | d  d   <d  S)Nri  rj  )r   )r   r3  rv   rw   rw   rx   extractText?  s    z$originalTextFor.<locals>.extractText)r   r   r   rc  r[  )r,  ZasStringZ	locMarkerZendlocMarker	matchExprrk  rw   rw   rx   rg      s    	c             C   s   t  |   j d d    S)zp
    Helper to undo pyparsing's default grouping of And expressions, even
    if all but one are non-empty.
    c             S   s   |  d S)Nr   rw   )rv   rw   rw   rx   ry   J  s    zungroup.<locals>.<lambda>)r-   r   )r,  rw   rw   rx   rh   E  s    c             C   sH   t    j d d    } t | d  |  d  | j   j   d   S)a  
    Helper to decorate a returned token with its starting and ending locations in the input string.
    This helper adds the following results names:
     - locn_start = location where matched expression begins
     - locn_end = location where matched expression ends
     - value = the actual parsed results

    Be careful if the input text contains C{<TAB>} characters, you may want to call
    C{L{ParserElement.parseWithTabs}}

    Example::
        wd = Word(alphas)
        for match in locatedExpr(wd).searchString("ljsdf123lksdjjf123lkkjj1222"):
            print(match)
    prints::
        [[0, 'ljsdf', 5]]
        [[8, 'lksdjjf', 15]]
        [[18, 'lkkjj', 23]]
    c             S   s   | S)Nrw   )r   r3  rv   rw   rw   rx   ry   `  s    zlocatedExpr.<locals>.<lambda>Z
locn_startr   Zlocn_end)r   r   r   r   r  )r,  Zlocatorrw   rw   rx   rj   L  s    z\[]-*.$+^?()~ r  c             C   s   | d d S)Nr   rr   rw   )r   r3  rv   rw   rw   rx   ry   k  s    ry   z\\0?[xX][0-9a-fA-F]+c             C   s    t  t | d j d  d   S)Nr   z\0x   )unichrru   lstrip)r   r3  rv   rw   rw   rx   ry   l  s    z	\\0[0-7]+c             C   s!   t  t | d d d   d   S)Nr   rr      )rn  ru   )r   r3  rv   rw   rw   rx   ry   m  s    r  z\]z\wr1  r  r  Znegatebodyr  c                sY   d d     y0 d j    f d d   t j |   j D  SWn t k
 rT d SYn Xd S)a  
    Helper to easily define string ranges for use in Word construction.  Borrows
    syntax from regexp '[]' string range definitions::
        srange("[0-9]")   -> "0123456789"
        srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
        srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"
    The input string must be enclosed in []'s, and the returned string is the expanded
    character set joined into a single string.
    The values enclosed in the []'s may be:
     - a single character
     - an escaped character with a leading backslash (such as C{\-} or C{\]})
     - an escaped hex character with a leading C{'\x'} (C{\x21}, which is a C{'!'} character) 
         (C{\0x##} is also supported for backwards compatibility) 
     - an escaped octal character with a leading C{'\0'} (C{\041}, which is a C{'!'} character)
     - a range of any of the above, separated by a dash (C{'a-z'}, etc.)
     - any combination of the above (C{'aeiouy'}, C{'a-zA-Z0-9_$'}, etc.)
    c             S   sN   t  |  t  s |  Sd j d d   t t |  d  t |  d  d  D  S)Nr   c             s   s   |  ] } t  |  Vq d  S)N)rn  )r   r   rw   rw   rx   r     s    z+srange.<locals>.<lambda>.<locals>.<genexpr>r   rr   )rz   r"   r   r   ord)prw   rw   rx   ry     s    zsrange.<locals>.<lambda>r   c             3   s   |  ] }   |  Vq d  S)Nrw   )r   part)	_expandedrw   rx   r     s    zsrange.<locals>.<genexpr>N)r   _reBracketExprr  rq  rI  )r   rw   )ru  rx   r_   r  s
    0c                s     f d d   } | S)zt
    Helper method for defining parse actions that require matching at a specific
    column in the input text.
    c                s/   t  | |     k r+ t |  | d     d  S)Nzmatched token not at column %d)r9   r   )r'  Zlocnr/  )r  rw   rx   	verifyCol  s    z!matchOnlyAtCol.<locals>.verifyColrw   )r  rw  rw   )r  rx   rM     s    c                s     f d d   S)a  
    Helper method for common parse actions that simply return a literal value.  Especially
    useful when used with C{L{transformString<ParserElement.transformString>}()}.

    Example::
        num = Word(nums).setParseAction(lambda toks: int(toks[0]))
        na = oneOf("N/A NA").setParseAction(replaceWith(math.nan))
        term = na | num
        
        OneOrMore(term).parseString("324 234 N/A 234") # -> [324, 234, nan, 234]
    c                s     g S)Nrw   )r   r3  rv   )replStrrw   rx   ry     s    zreplaceWith.<locals>.<lambda>rw   )rx  rw   )rx  rx   r\     s    c             C   s   | d d d  S)a  
    Helper parse action for removing quotation marks from parsed quoted strings.

    Example::
        # by default, quotation marks are included in parsed results
        quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["'Now is the Winter of our Discontent'"]

        # use removeQuotes to strip quotation marks from parsed results
        quotedString.setParseAction(removeQuotes)
        quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["Now is the Winter of our Discontent"]
    r   rr   rs   rw   )r   r3  rv   rw   rw   rx   rZ     s    c                se      f d d   } y" t   d t   d  j  } Wn t k
 rW t   } Yn X| | _ | S)aG  
    Helper to define a parse action by mapping a function to all elements of a ParseResults list.If any additional 
    args are passed, they are forwarded to the given function as additional arguments after
    the token, as in C{hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))}, which will convert the
    parsed data to an integer using base 16.

    Example (compare the last to example in L{ParserElement.transformString}::
        hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16))
        hex_ints.runTests('''
            00 11 22 aa FF 0a 0d 1a
            ''')
        
        upperword = Word(alphas).setParseAction(tokenMap(str.upper))
        OneOrMore(upperword).runTests('''
            my kingdom for a horse
            ''')

        wd = Word(alphas).setParseAction(tokenMap(str.title))
        OneOrMore(wd).setParseAction(' '.join).runTests('''
            now is the winter of our discontent made glorious summer by this sun of york
            ''')
    prints::
        00 11 22 aa FF 0a 0d 1a
        [0, 17, 34, 170, 255, 10, 13, 26]

        my kingdom for a horse
        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']

        now is the winter of our discontent made glorious summer by this sun of york
        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']
    c                s      f d d   | D S)Nc                s   g  |  ] }  |     q Srw   rw   )r   Ztokn)r   r4  rw   rx   r     s   	 z(tokenMap.<locals>.pa.<locals>.<listcomp>rw   )r   r3  rv   )r   r4  rw   rx   r{    s    ztokenMap.<locals>.par   rF  )rH  r   rI  r{   )r4  r   r{  rJ  rw   )r   r4  rx   rm     s     		c             C   s   t  |   j   S)N)r   r  )rv   rw   rw   rx   ry     s    c             C   s   t  |   j   S)N)r   lower)rv   rw   rw   rx   ry     s    c             C   sE  t  |  t  r+ |  } t |  d | }  n	 |  j } t t t d  } | r t j   j	 t
  } t d  |  d  t t t | t d  |    t d d d g j d	  j	 d
 d    t d  } n d j d d   t D  } t j   j	 t
  t |  B} t d  |  d  t t t | j	 t  t t d  |     t d d d g j d	  j	 d d    t d  } t t d  |  d  } | j d d j | j d d  j   j     j d |  } | j d d j | j d d  j   j     j d |  } | | _ | | _ | | f S)zRInternal helper to construct opening and closing tag expressions, given a tag namer  z_-:r  tag=/r   FrC   c             S   s   | d d k S)Nr   r|  rw   )r   r3  rv   rw   rw   rx   ry     s    z_makeTags.<locals>.<lambda>r  r   c             s   s!   |  ] } | d  k r | Vq d S)r  Nrw   )r   r   rw   rw   rx   r     s    z_makeTags.<locals>.<genexpr>c             S   s   | d d k S)Nr   r|  rw   )r   r3  rv   rw   rw   rx   ry     s    z</r  :r  z<%s>r  z</%s>)rz   r   r   r   r/   r4   r3   r>   r   r   rZ   r+   r   r2   r   r   rk  r   rV   rY   rB   r
   _Lr   titler   rg  rz  )tagStrZxmlZresnameZtagAttrNameZtagAttrValueZopenTagZprintablesLessRAbrackZcloseTagrw   rw   rx   	_makeTags  s"    	r~AA		r  c             C   s   t  |  d  S)a   
    Helper to construct opening and closing tag expressions for HTML, given a tag name. Matches
    tags in either upper or lower case, attributes with namespaces and with quoted or unquoted values.

    Example::
        text = '<td>More info at the <a href="http://pyparsing.wikispaces.com">pyparsing</a> wiki page</td>'
        # makeHTMLTags returns pyparsing expressions for the opening and closing tags as a 2-tuple
        a,a_end = makeHTMLTags("A")
        link_expr = a + SkipTo(a_end)("link_text") + a_end
        
        for link in link_expr.searchString(text):
            # attributes in the <A> tag (like "href" shown here) are also accessible as named results
            print(link.link_text, '->', link.href)
    prints::
        pyparsing -> http://pyparsing.wikispaces.com
    F)r  )r  rw   rw   rx   rK     s    c             C   s   t  |  d  S)z
    Helper to construct opening and closing tag expressions for XML, given a tag name. Matches
    tags only in the given upper/lower case.

    Example: similar to L{makeHTMLTags}
    T)r  )r  rw   rw   rx   rL     s    c                 sN   |  r |  d d    n | j      d d     D     f d d   } | S)a<  
    Helper to create a validating parse action to be used with start tags created
    with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag
    with a required attribute value, to avoid false matches on common tags such as
    C{<TD>} or C{<DIV>}.

    Call C{withAttribute} with a series of attribute names and values. Specify the list
    of filter attributes names and values as:
     - keyword arguments, as in C{(align="right")}, or
     - as an explicit dict with C{**} operator, when an attribute name is also a Python
          reserved word, as in C{**{"class":"Customer", "align":"right"}}
     - a list of name-value tuples, as in ( ("ns1:class", "Customer"), ("ns2:align","right") )
    For attribute names with a namespace prefix, you must use the second form.  Attribute
    names are matched insensitive to upper/lower case.
       
    If just testing for C{class} (with or without a namespace), use C{L{withClass}}.

    To verify that the attribute exists, but without specifying a value, pass
    C{withAttribute.ANY_VALUE} as the value.

    Example::
        html = '''
            <div>
            Some text
            <div type="grid">1 4 0 1 0</div>
            <div type="graph">1,3 2,3 1,1</div>
            <div>this has no type</div>
            </div>
                
        '''
        div,div_end = makeHTMLTags("div")

        # only match div tag having a type attribute with value "grid"
        div_grid = div().setParseAction(withAttribute(type="grid"))
        grid_expr = div_grid + SkipTo(div | div_end)("body")
        for grid_header in grid_expr.searchString(html):
            print(grid_header.body)
        
        # construct a match with any div tag having a type attribute, regardless of the value
        div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))
        div_expr = div_any_type + SkipTo(div | div_end)("body")
        for div_header in div_expr.searchString(html):
            print(div_header.body)
    prints::
        1 4 0 1 0

        1 4 0 1 0
        1,3 2,3 1,1
    Nc             S   s"   g  |  ] \ } } | | f  q Srw   rw   )r   r   r   rw   rw   rx   r   Q  s   	 z!withAttribute.<locals>.<listcomp>c                s   xx   D]p \ } } | | k r5 t  |  | d |   | t j k r | | | k r t  |  | d | | | | f   q Wd  S)Nzno matching attribute z+attribute '%s' has value '%s', must be '%s')r   re   	ANY_VALUE)r   r3  r  ZattrNameZ	attrValue)attrsrw   rx   r{  R  s    zwithAttribute.<locals>.pa)r   )r   ZattrDictr{  rw   )r  rx   re     s    2c             C   s&   | r d | n d } t  | |  i   S)a  
    Simplified version of C{L{withAttribute}} when matching on a div class - made
    difficult because C{class} is a reserved word in Python.

    Example::
        html = '''
            <div>
            Some text
            <div class="grid">1 4 0 1 0</div>
            <div class="graph">1,3 2,3 1,1</div>
            <div>this &lt;div&gt; has no class</div>
            </div>
                
        '''
        div,div_end = makeHTMLTags("div")
        div_grid = div().setParseAction(withClass("grid"))
        
        grid_expr = div_grid + SkipTo(div | div_end)("body")
        for grid_header in grid_expr.searchString(html):
            print(grid_header.body)
        
        div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))
        div_expr = div_any_type + SkipTo(div | div_end)("body")
        for div_header in div_expr.searchString(html):
            print(div_header.body)
    prints::
        1 4 0 1 0

        1 4 0 1 0
        1,3 2,3 1,1
    z%s:classclass)re   )Z	classname	namespaceZ	classattrrw   rw   rx   rk   \  s     (r  c             C   s6  t    } |  | | | B} x
t |  D]\ } } | d d d  \ } }	 }
 } |	 d k  rj d | n d | } |	 d k r | d k s t |  d k r t d   | \ } } t    j |  } |
 t j k r|	 d k r
t | |  t | t	 |   } q|	 d k rx| d k	 rQt | | |  t | t	 | |   } qt | |  t | t	 |   } q|	 d k rt | | | | |  t | | | | |  } qt d	   n(|
 t j
 k r|	 d k r&t | t  st |  } t | j |  t | |  } q|	 d k r| d k	 rmt | | |  t | t	 | |   } qt | |  t | t	 |   } q|	 d k rt | | | | |  t | | | | |  } qt d	   n t d
   | r| j |  | | j |  | BK} | } q( W| | K} | S)a	  
    Helper method for constructing grammars of expressions made up of
    operators working in a precedence hierarchy.  Operators may be unary or
    binary, left- or right-associative.  Parse actions can also be attached
    to operator expressions. The generated parser will also recognize the use 
    of parentheses to override operator precedences (see example below).
    
    Note: if you define a deep operator list, you may see performance issues
    when using infixNotation. See L{ParserElement.enablePackrat} for a
    mechanism to potentially improve your parser performance.

    Parameters:
     - baseExpr - expression representing the most basic element for the nested
     - opList - list of tuples, one for each operator precedence level in the
      expression grammar; each tuple is of the form
      (opExpr, numTerms, rightLeftAssoc, parseAction), where:
       - opExpr is the pyparsing expression for the operator;
          may also be a string, which will be converted to a Literal;
          if numTerms is 3, opExpr is a tuple of two expressions, for the
          two operators separating the 3 terms
       - numTerms is the number of terms for this operator (must
          be 1, 2, or 3)
       - rightLeftAssoc is the indicator whether the operator is
          right or left associative, using the pyparsing-defined
          constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.
       - parseAction is the parse action to be associated with
          expressions matching this operator expression (the
          parse action tuple member may be omitted)
     - lpar - expression for matching left-parentheses (default=C{Suppress('(')})
     - rpar - expression for matching right-parentheses (default=C{Suppress(')')})

    Example::
        # simple example of four-function arithmetic with ints and variable names
        integer = pyparsing_common.signed_integer
        varname = pyparsing_common.identifier 
        
        arith_expr = infixNotation(integer | varname,
            [
            ('-', 1, opAssoc.RIGHT),
            (oneOf('* /'), 2, opAssoc.LEFT),
            (oneOf('+ -'), 2, opAssoc.LEFT),
            ])
        
        arith_expr.runTests('''
            5+3*6
            (5+3)*6
            -2--11
            ''', fullDump=False)
    prints::
        5+3*6
        [[5, '+', [3, '*', 6]]]

        (5+3)*6
        [[[5, '+', 3], '*', 6]]

        -2--11
        [[['-', 2], '-', ['-', 11]]]
    Nr
  ro   z%s termz	%s%s termrq   z@if numterms=3, opExpr must be a tuple or list of two expressionsrr   z6operator must be unary (1), binary (2), or ternary (3)z2operator must indicate right or left associativity)N)r   r   r   r  rg  rT   LEFTr   r   r   RIGHTrz   r   r,  r   )ZbaseExprZopListZlparZrparr   ZlastExprr   ZoperDefZopExprZarityZrightLeftAssocr{  ZtermNameZopExpr1ZopExpr2ZthisExprrl  rw   rw   rx   ri     sR    ;	  '/' $/' 

z4"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*"z string enclosed in double quotesz4'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*'z string enclosed in single quotesz*quotedString using single or double quotesuzunicode string literalc             C   s'  |  | k r t  d   | d k rt |  t  rt | t  rt |   d k r t |  d k r | d k	 r t t | t |  | t j d d   j	 d d    } qt
 j   t |  | t j  j	 d d    } q| d k	 r?t t | t |   t |  t t j d d   j	 d d    } qt t t |   t |  t t j d d   j	 d	 d    } n t  d
   t   } | d k	 r| t t |   t | | B| B t |   K} n. | t t |   t | | B t |   K} | j d |  | f  | S)a~	  
    Helper method for defining nested lists enclosed in opening and closing
    delimiters ("(" and ")" are the default).

    Parameters:
     - opener - opening character for a nested list (default=C{"("}); can also be a pyparsing expression
     - closer - closing character for a nested list (default=C{")"}); can also be a pyparsing expression
     - content - expression for items within the nested lists (default=C{None})
     - ignoreExpr - expression for ignoring opening and closing delimiters (default=C{quotedString})

    If an expression is not provided for the content argument, the nested
    expression will capture all whitespace-delimited content between delimiters
    as a list of separate values.

    Use the C{ignoreExpr} argument to define expressions that may contain
    opening or closing characters that should not be treated as opening
    or closing characters for nesting, such as quotedString or a comment
    expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.
    The default is L{quotedString}, but if no expressions are to be ignored,
    then pass C{None} for this argument.

    Example::
        data_type = oneOf("void int short long char float double")
        decl_data_type = Combine(data_type + Optional(Word('*')))
        ident = Word(alphas+'_', alphanums+'_')
        number = pyparsing_common.number
        arg = Group(decl_data_type + ident)
        LPAR,RPAR = map(Suppress, "()")

        code_body = nestedExpr('{', '}', ignoreExpr=(quotedString | cStyleComment))

        c_function = (decl_data_type("type") 
                      + ident("name")
                      + LPAR + Optional(delimitedList(arg), [])("args") + RPAR 
                      + code_body("body"))
        c_function.ignore(cStyleComment)
        
        source_code = '''
            int is_odd(int x) { 
                return (x%2); 
            }
                
            int dec_to_hex(char hchar) { 
                if (hchar >= '0' && hchar <= '9') { 
                    return (ord(hchar)-ord('0')); 
                } else { 
                    return (10+ord(hchar)-ord('A'));
                } 
            }
        '''
        for func in c_function.searchString(source_code):
            print("%(name)s (%(type)s) args: %(args)s" % func)

    prints::
        is_odd (int) args: [['int', 'x']]
        dec_to_hex (int) args: [['char', 'hchar']]
    z.opening and closing strings cannot be the sameNrr   r  c             S   s   |  d j    S)Nr   )r   )rv   rw   rw   rx   ry   9  s    znestedExpr.<locals>.<lambda>c             S   s   |  d j    S)Nr   )r   )rv   rw   rw   rx   ry   <  s    c             S   s   |  d j    S)Nr   )r   )rv   rw   rw   rx   ry   B  s    c             S   s   |  d j    S)Nr   )r   )rv   rw   rw   rx   ry   F  s    zOopening and closing arguments must be strings if no content expression is givenznested %s%s expression)r  rz   r   r   r
   r   r	   r$   rL  r   rC   r   r   r   r   r+   r2   rg  )ZopenerZcloserZcontentrH  r   rw   rw   rx   rP     s4    :$
$ 	5.c                s>    f d d   }   f d d   }   f d d   } t  t   j d  j    } t   t   j |  j d  } t   j |  j d	  } t   j |  j d
  }	 | r t t |  | t  | t |   t |   |	  }
 n0 t t |  t  | t |   t |    }
 |  j	 t
 t    |
 j d  S)a
	  
    Helper method for defining space-delimited indentation blocks, such as
    those used to define block statements in Python source code.

    Parameters:
     - blockStatementExpr - expression defining syntax of statement that
            is repeated within the indented block
     - indentStack - list created by caller to manage indentation stack
            (multiple statementWithIndentedBlock expressions within a single grammar
            should share a common indentStack)
     - indent - boolean indicating whether block must be indented beyond the
            the current level; set to False for block of left-most statements
            (default=C{True})

    A valid block must contain at least one C{blockStatement}.

    Example::
        data = '''
        def A(z):
          A1
          B = 100
          G = A2
          A2
          A3
        B
        def BB(a,b,c):
          BB1
          def BBA():
            bba1
            bba2
            bba3
        C
        D
        def spam(x,y):
             def eggs(z):
                 pass
        '''


        indentStack = [1]
        stmt = Forward()

        identifier = Word(alphas, alphanums)
        funcDecl = ("def" + identifier + Group( "(" + Optional( delimitedList(identifier) ) + ")" ) + ":")
        func_body = indentedBlock(stmt, indentStack)
        funcDef = Group( funcDecl + func_body )

        rvalue = Forward()
        funcCall = Group(identifier + "(" + Optional(delimitedList(rvalue)) + ")")
        rvalue << (funcCall | identifier | Word(nums))
        assignment = Group(identifier + "=" + rvalue)
        stmt << ( funcDef | assignment | identifier )

        module_body = OneOrMore(stmt)

        parseTree = module_body.parseString(data)
        parseTree.pprint()
    prints::
        [['def',
          'A',
          ['(', 'z', ')'],
          ':',
          [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
         'B',
         ['def',
          'BB',
          ['(', 'a', 'b', 'c', ')'],
          ':',
          [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
         'C',
         'D',
         ['def',
          'spam',
          ['(', 'x', 'y', ')'],
          ':',
          [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]] 
    c                sm   | t  |   k r d  St | |   } |   d k ri |   d k rW t |  | d   t |  | d   d  S)Nrr   zillegal nestingznot a peer entryrs   rs   )r   r9   r!   r   )r   r3  rv   curCol)indentStackrw   rx   checkPeerIndent  s     z&indentedBlock.<locals>.checkPeerIndentc                sE   t  | |   } |   d k r/   j |  n t |  | d   d  S)Nrr   znot a subentryrs   )r9   r   r   )r   r3  rv   r  )r  rw   rx   checkSubIndent  s    z%indentedBlock.<locals>.checkSubIndentc                sk   | t  |   k r d  St | |   }   oH |   d k  oH |   d k s] t |  | d     j   d  S)Nrr   rq   znot an unindentrs   r8  )r   r9   r   r   )r   r3  rv   r  )r  rw   rx   checkUnindent  s     &z$indentedBlock.<locals>.checkUnindentz	 INDENTr   ZUNINDENTzindented block)r   r   r  r  r   r   rg  r   r   r  rd  )ZblockStatementExprr  r  r  r  r  r  r  ZPEERZUNDENTZsmExprrw   )r  rx   rf   Q  s    N"8$z#[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]z[\0xa1-\0xbf\0xd7\0xf7]z_:zany tagzgt lt amp nbsp quot aposz><& "'z&(?P<entity>rg  z);zcommon HTML entityc             C   s   t  j |  j  S)zRHelper parser action to replace common HTML entities with their special characters)_htmlEntityMapr   Zentity)rv   rw   rw   rx   r[     s    z/\*(?:[^*]|\*(?!/))*z*/zC style commentz<!--[\s\S]*?-->zHTML commentz.*zrest of linez//(?:\\\n|[^\n])*z
// commentzC++ style commentz#.*zPython style commentz 		commaItemr   c               @   s  e  Z d  Z d Z e e  Z e e  Z e	 e
  j d  j e  Z e	 e  j d  j e e d   Z e d  j d  j e  Z e   j e  d e   j e  j d  Z e j d	 d
    e e e e d  j   e  Bj d  Z e j e  e d  j d  j e  Z e d  j d  j e  Z e e Be Bj   Z e d  j d  j e  Z e	 e d e d  j d  Z e d  j d  Z  e d  j d  Z! e! d e! d j d  Z" e e! d e! d>  d e e! d e! d?  j d  Z# e# j$ d  d
    d! e  j d"  Z% e& e" e% Be# Bj d#   j d#  Z' e d$  j d%  Z( e) d& d' d(   Z* e) d) d* d+   Z+ e d,  j d-  Z, e d.  j d/  Z- e d0  j d1  Z. e/ j   e0 j   BZ1 e) d2 d3    Z2 e& e3 e4 d4  e5   e	 e6 d5 d4 e e7 d6     j   j d7  Z8 e9 e e: j;   e8 Bd8 d9  j d:  Z< e) e d; d
     Z= e) e d< d
     Z> d= S)@rn   a
  
    Here are some common low-level expressions that may be useful in jump-starting parser development:
     - numeric forms (L{integers<integer>}, L{reals<real>}, L{scientific notation<sci_real>})
     - common L{programming identifiers<identifier>}
     - network addresses (L{MAC<mac_address>}, L{IPv4<ipv4_address>}, L{IPv6<ipv6_address>})
     - ISO8601 L{dates<iso8601_date>} and L{datetime<iso8601_datetime>}
     - L{UUID<uuid>}
     - L{comma-separated list<comma_separated_list>}
    Parse actions:
     - C{L{convertToInteger}}
     - C{L{convertToFloat}}
     - C{L{convertToDate}}
     - C{L{convertToDatetime}}
     - C{L{stripHTMLTags}}
     - C{L{upcaseTokens}}
     - C{L{downcaseTokens}}

    Example::
        pyparsing_common.number.runTests('''
            # any int or real number, returned as the appropriate type
            100
            -100
            +100
            3.14159
            6.02e23
            1e-12
            ''')

        pyparsing_common.fnumber.runTests('''
            # any int or real number, returned as float
            100
            -100
            +100
            3.14159
            6.02e23
            1e-12
            ''')

        pyparsing_common.hex_integer.runTests('''
            # hex numbers
            100
            FF
            ''')

        pyparsing_common.fraction.runTests('''
            # fractions
            1/2
            -3/4
            ''')

        pyparsing_common.mixed_integer.runTests('''
            # mixed fractions
            1
            1/2
            -3/4
            1-3/4
            ''')

        import uuid
        pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))
        pyparsing_common.uuid.runTests('''
            # uuid
            12345678-1234-5678-1234-567812345678
            ''')
    prints::
        # any int or real number, returned as the appropriate type
        100
        [100]

        -100
        [-100]

        +100
        [100]

        3.14159
        [3.14159]

        6.02e23
        [6.02e+23]

        1e-12
        [1e-12]

        # any int or real number, returned as float
        100
        [100.0]

        -100
        [-100.0]

        +100
        [100.0]

        3.14159
        [3.14159]

        6.02e23
        [6.02e+23]

        1e-12
        [1e-12]

        # hex numbers
        100
        [256]

        FF
        [255]

        # fractions
        1/2
        [0.5]

        -3/4
        [-0.75]

        # mixed fractions
        1
        [1]

        1/2
        [0.5]

        -3/4
        [-0.75]

        1-3/4
        [1.75]

        # uuid
        12345678-1234-5678-1234-567812345678
        [UUID('12345678-1234-5678-1234-567812345678')]
    integerzhex integerrm  z[+-]?\d+zsigned integerr|  fractionc             C   s   |  d |  d S)Nr   rr   rs   rw   )rv   rw   rw   rx   ry     s    zpyparsing_common.<lambda>r1  z"fraction or mixed integer-fractionz[+-]?\d+\.\d*zreal numberz+[+-]?\d+([eE][+-]?\d+|\.\d*([eE][+-]?\d+)?)z$real number with scientific notationz[+-]?\d+\.?\d*([eE][+-]?\d+)?fnumberr;  
identifierzK(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}zIPv4 addressz[0-9a-fA-F]{1,4}hex_integerr}     zfull IPv6 addressr   r@  z::zshort IPv6 addressc             C   s   t  d d   |  D  d k  S)Nc             s   s'   |  ] } t  j j |  r d  Vq d S)rr   N)rn   
_ipv6_partr  )r   r_  rw   rw   rx   r     s    z,pyparsing_common.<lambda>.<locals>.<genexpr>rp  )rA  )rv   rw   rw   rx   ry     s    z::ffff:zmixed IPv6 addresszIPv6 addressz:[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\1[0-9a-fA-F]{2}){4}zMAC addressz%Y-%m-%dc                s     f d d   } | S)a  
        Helper to create a parse action for converting parsed date string to Python datetime.date

        Params -
         - fmt - format to be passed to datetime.strptime (default=C{"%Y-%m-%d"})

        Example::
            date_expr = pyparsing_common.iso8601_date.copy()
            date_expr.setParseAction(pyparsing_common.convertToDate())
            print(date_expr.parseString("1999-12-31"))
        prints::
            [datetime.date(1999, 12, 31)]
        c                sb   y t  j | d    j   SWn= t k
 r] } z t |  | t |    WYd  d  } ~ Xn Xd  S)Nr   )r   strptimeZdater  r   r{   )r   r3  rv   ve)fmtrw   rx   cvt_fn  s    z.pyparsing_common.convertToDate.<locals>.cvt_fnrw   )r  r  rw   )r  rx   convertToDate  s    zpyparsing_common.convertToDatez%Y-%m-%dT%H:%M:%S.%fc                s     f d d   } | S)a  
        Helper to create a parse action for converting parsed datetime string to Python datetime.datetime

        Params -
         - fmt - format to be passed to datetime.strptime (default=C{"%Y-%m-%dT%H:%M:%S.%f"})

        Example::
            dt_expr = pyparsing_common.iso8601_datetime.copy()
            dt_expr.setParseAction(pyparsing_common.convertToDatetime())
            print(dt_expr.parseString("1999-12-31T23:59:59.999"))
        prints::
            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]
        c                s\   y t  j | d    SWn= t k
 rW } z t |  | t |    WYd  d  } ~ Xn Xd  S)Nr   )r   r  r  r   r{   )r   r3  rv   r  )r  rw   rx   r    s    z2pyparsing_common.convertToDatetime.<locals>.cvt_fnrw   )r  r  rw   )r  rx   convertToDatetime  s    z"pyparsing_common.convertToDatetimez7(?P<year>\d{4})(?:-(?P<month>\d\d)(?:-(?P<day>\d\d))?)?zISO8601 datez(?P<year>\d{4})-(?P<month>\d\d)-(?P<day>\d\d)[T ](?P<hour>\d\d):(?P<minute>\d\d)(:(?P<second>\d\d(\.\d*)?)?)?(?P<tz>Z|[+-]\d\d:?\d\d)?zISO8601 datetimez2[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}UUIDc             C   s   t  j j | d  S)a  
        Parse action to remove HTML tags from web page HTML source

        Example::
            # strip HTML links from normal text 
            text = '<td>More info at the <a href="http://pyparsing.wikispaces.com">pyparsing</a> wiki page</td>'
            td,td_end = makeHTMLTags("TD")
            table_text = td + SkipTo(td_end).setParseAction(pyparsing_common.stripHTMLTags)("body") + td_end
            
            print(table_text.parseString(text).body) # -> 'More info at the pyparsing wiki page'
        r   )rn   _html_stripperr   )r   r3  r  rw   rw   rx   stripHTMLTags  s    zpyparsing_common.stripHTMLTagsrZ  r  z 	r  r   r   zcomma separated listc             C   s   t  |   j   S)N)r   r  )rv   rw   rw   rx   ry     s    c             C   s   t  |   j   S)N)r   ry  )rv   rw   rw   rx   ry     s    N)r   r@  )r   r@  )?r   r   r   r   rm   ru   ZconvertToIntegerfloatZconvertToFloatr/   rR   rg  r   r  rD   r  r'   Zsigned_integerr  rv  r   r  Zmixed_integerrA  realZsci_realr  numberr  r4   r3   r  Zipv4_addressr  Z_full_ipv6_addressZ_short_ipv6_addressr|  Z_mixed_ipv6_addressr
   Zipv6_addressZmac_addressr  r  r  Ziso8601_dateZiso8601_datetimeuuidr7   r6   r  r  r   r   r   rV   r.   _commasepitemr@   rY   r   Zcomma_separated_listrd   rB   rw   rw   rw   rx   rn     sL   '/- ;&J+__main__Zselectfromz_$rV  r[  columnsrh  ZtablesZcommandaK  
        # '*' as column list and dotted table name
        select * from SYS.XYZZY

        # caseless match on "SELECT", and casts back to "select"
        SELECT * from XYZZY, ABC

        # list of column names, and mixed case SELECT keyword
        Select AA,BB,CC from Sys.dual

        # multiple tables
        Select A, B, C from Sys.dual, Table2

        # invalid SELECT keyword - should fail
        Xelect A, B, C from Sys.dual

        # incomplete command - should fail
        Select

        # invalid column name - should fail
        Select ^^^ frox Sys.dual

        z]
        100
        -100
        +100
        3.14159
        6.02e23
        1e-12
        z 
        100
        FF
        z6
        12345678-1234-5678-1234-567812345678
        )r   __version__Z__versionTime__
__author__r   weakrefr   r   r   r~   r  rb  r  r  r   r:  r  r   _threadr   ImportErrorZ	threadingr   r  Zordereddict__all__r  version_infor9  r  maxsizer  r{   r   chrrn  r   rA  r   r  reversedr   r  r  r/  r  r  rG  ZmaxintZxranger   Z__builtin__r   fnamer   rH  r   r   r   r   r   r   Zascii_uppercaseZascii_lowercaser4   rR   rD   r3   rd  r   Z	printablerV   rI  r   r   r!   r#   r&   r   r"   MutableMappingregisterr9   rJ   rG   r-  r0  r2  rQ   rK  r$   r,   r   r   r   r~  rO  r   r   r   rl   r/   r'   r%   r	   r.   r)  r   r   r   r*   r)   r1   r0   r    r   r   r   r   r   r   r   rC  r   r2   rF  rG  r   r(   r   rO  r-   r
   r   r   r+   r   rb   r@   r<   r  rO   rN   r  rS   rA   rg   rh   rj   rg  rC   rI   rH   ra   r`   r   Z_escapedPuncZ_escapedHexCharZ_escapedOctCharUNICODEZ_singleCharZ
_charRangerk  rv  r_   rM   r\   rZ   rm   rd   rB   r  rK   rL   re   r  rk   rT   r  r  ri   rU   r>   r^   rY   rc   rP   rf   r5   rW   r7   r6   r   r   r  r   r;   r[   r8   rE   r  r]   r?   r=   rF   rX   r  r  r:   rn   r   ZselectTokenZ	fromTokenZidentZ
columnNameZcolumnNameListZ
columnSpecZ	tableNameZtableNameListZ	simpleSQLr  r  r  r  r  r  rw   rw   rw   rx   <module>=   s  	*	


8
  
@    &	A=IG3pLOD|M &#	@sQ,A,	I#%$4@
,	?#	k%Zr(,#8+ 
$				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
%}Xu              I   @   s  d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l Z d Z d Z	 e j
 d d k Z e j
 d d k Z e j
 d d  dzk Z e r e f Z e f Z e f Z e Z e Z e j Z n e f Z e e f Z e e j f Z e Z e Z e j j d	  r'e d| Z nW Gd d   d e  Z  y e! e     Wn e" k
 rne d~ Z Yn Xe d Z [  d d   Z# d d   Z$ Gd d   d e  Z% Gd d   d e%  Z& Gd d   d e j'  Z( Gd d   d e%  Z) Gd d   d e  Z* e* e+  Z, Gd d   d e(  Z- e) d d d  d!  e) d" d# d$ d% d"  e) d& d# d# d' d&  e) d( d) d$ d* d(  e) d+ d) d,  e) d- d# d$ d. d-  e) d/ d0 d0 d1 d/  e) d2 d0 d0 d/ d2  e) d3 d) d$ d4 d3  e) d5 d) e rd6 n d7 d8  e) d9 d) d:  e) d; d< d= d>  e) d! d! d   e) d? d? d@  e) dA dA d@  e) dB dB d@  e) d4 d) d$ d4 d3  e) dC d# d$ dD dC  e) dE d# d# dF dE  e& d$ d)  e& dG dH  e& dI dJ  e& dK dL dM  e& dN dO dN  e& dP dQ dR  e& dS dT dU  e& dV dW dX  e& dY dZ d[  e& d\ d] d^  e& d_ d` da  e& db dc dd  e& de df dg  e& dh di dj  e& dk dk dl  e& dm dm dl  e& dn dn dl  e& do do dp  e& dq dr  e& ds dt  e& du dv  e& dw dx dw  e& dy dz  e& d{ d| d}  e& d~ d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d e+ d d  e& d e+ d d  e& d e+ d e+ d  e& d d d  e& d d d  e& d d d  g> Z. e j d k rBe. e& d d  g 7Z. xG e. D]? Z/ e0 e- e/ j1 e/  e2 e/ e&  rIe, j3 e/ d e/ j1  qIW[/ e. e- _. e- e+ d  Z4 e, j3 e4 d  Gd d   d e(  Z5 e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d> d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  g Z6 x! e6 D] Z/ e0 e5 e/ j1 e/  q4W[/ e6 e5 _. e, j3 e5 e+ d  d d  Gd d   d e(  Z7 e) d d d  e) d d d  e) d d d  g Z8 x! e8 D] Z/ e0 e7 e/ j1 e/  qW[/ e8 e7 _. e, j3 e7 e+ d  d d  Gd d   d e(  Z9 e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  g! Z: x! e: D] Z/ e0 e9 e/ j1 e/  q"W[/ e: e9 _. e, j3 e9 e+ d dd Gdd  de(  Z; e) dd d e) dd d e) d	d d e) d
d d g Z< x! e< D] Z/ e0 e; e/ j1 e/  qW[/ e< e; _. e, j3 e; e+ d dd Gdd  de(  Z= e) dd d  g Z> x! e> D] Z/ e0 e= e/ j1 e/  q?W[/ e> e= _. e, j3 e= e+ d dd Gdd  de j'  Z? e, j3 e? e+ d  d dd  Z@ dd  ZA e rdZB dZC dZD dZE dZF d ZG n$ d!ZB d"ZC d#ZD d$ZE d%ZF d&ZG y
 eH ZI Wn eJ k
 rKd'd(  ZI Yn XeI ZH y
 eK ZK Wn eJ k
 r|d)d*  ZK Yn Xe rd+d,  ZL e jM ZN d-d.  ZO e ZP n@ d/d,  ZL d0d1  ZN d2d.  ZO Gd3d4  d4e  ZP eK ZK e# eL d5 e jQ eB  ZR e jQ eC  ZS e jQ eD  ZT e jQ eE  ZU e jQ eF  ZV e jQ eG  ZW e rd6d7  ZX d8d9  ZY d:d;  ZZ d<d=  Z[ e j\ d> Z] e j\ d? Z^ e j\ d@ Z_ n] dAd7  ZX dBd9  ZY dCd;  ZZ dDd=  Z[ e j\ dE Z] e j\ dF Z^ e j\ dG Z_ e# eX dH e# eY dI e# eZ dJ e# e[ dK e rdLdM  Z` dNdO  Za eb Zc d d ld Zd ed je dP jf Zg [d e jh d  Zi e jj Zk el Zm d d ln Zn en jo Zo en jp Zp dQZq e j
 d
 d
 k rdRZr dSZs qdTZr dUZs n| dVdM  Z` dWdO  Za ec Zc eb Zg dXdY  Zi dZd[  Zk e jt e ju ev  Zm d d lo Zo eo jo Zo Zp d\Zq dRZr dSZs e# e` d] e# ea d^ d_dQ  Zw d`dT  Zx dadU  Zy e rez e4 j{ db Z| d dcdd Z} n d d dedf Z| e| dg e j
 d d  dk r)e| dh n2 e j
 d d  dk rOe| di n djdk  Z~ ez e4 j{ dld  Z e d k rdmdn  Z e j
 d d  dk  re Z dodn  Z e# e} dp e j
 d d  dk  re j e j dqdr Z n	 e j Z dsdt  Z dudv  Z dwdx  Z g  Z e+ Z e   j dy d k	 rNg  e _ e j rxL e e j  D]; \ Z Z e e  j+ d k rge j1 e+ k rge j e =PqgW[ [ e j j e,  d S(  z6Utilities for writing code that runs on Python 2 and 3    )absolute_importNz'Benjamin Peterson <benjamin@python.org>z1.10.0         java      c               @   s   e  Z d  Z d d   Z d S)Xc             C   s   d S)Nr   r   l         )selfr
   r
   ;/usr/lib/python3/dist-packages/pkg_resources/_vendor/six.py__len__>   s    z	X.__len__N)__name__
__module____qualname__r   r
   r
   r
   r   r	   <   s   r	   ?   c             C   s   | |  _  d S)z Add documentation to a function.N)__doc__)funcdocr
   r
   r   _add_docK   s    r   c             C   s   t  |   t j |  S)z7Import module, returning the module after the last dot.)
__import__sysmodules)namer
   r
   r   _import_moduleP   s    
r   c               @   s(   e  Z d  Z d d   Z d d   Z d S)
_LazyDescrc             C   s   | |  _  d  S)N)r   )r   r   r
   r
   r   __init__X   s    z_LazyDescr.__init__c             C   sO   |  j    } t | |  j |  y t | j |  j  Wn t k
 rJ Yn X| S)N)_resolvesetattrr   delattr	__class__AttributeError)r   objtpresultr
   r
   r   __get__[   s    z_LazyDescr.__get__N)r   r   r   r   r%   r
   r
   r
   r   r   V   s   r   c                   s=   e  Z d  Z d   f d d  Z d d   Z d d   Z   S)MovedModuleNc                sG   t  t |   j |  t r: | d  k r. | } | |  _ n	 | |  _ d  S)N)superr&   r   PY3mod)r   r   oldnew)r    r
   r   r   i   s    zMovedModule.__init__c             C   s   t  |  j  S)N)r   r)   )r   r
   r
   r   r   r   s    zMovedModule._resolvec             C   s/   |  j    } t | |  } t |  | |  | S)N)r   getattrr   )r   attr_modulevaluer
   r
   r   __getattr__u   s    zMovedModule.__getattr__)r   r   r   r   r   r0   r
   r
   )r    r   r&   g   s   	r&   c                   s4   e  Z d  Z   f d d   Z d d   Z g  Z   S)_LazyModulec                s)   t  t |   j |  |  j j |  _ d  S)N)r'   r1   r   r    r   )r   r   )r    r
   r   r   ~   s    z_LazyModule.__init__c             C   s*   d d g } | d d   |  j  D 7} | S)Nr   r   c             S   s   g  |  ] } | j   q Sr
   )r   ).0r-   r
   r
   r   
<listcomp>   s   	 z'_LazyModule.__dir__.<locals>.<listcomp>)_moved_attributes)r   Zattrsr
   r
   r   __dir__   s    z_LazyModule.__dir__)r   r   r   r   r5   r4   r
   r
   )r    r   r1   |   s   r1   c                   s4   e  Z d  Z d d   f d d  Z d d   Z   S)MovedAttributeNc                s   t  t |   j |  t rj | d  k r. | } | |  _ | d  k r^ | d  k rX | } n | } | |  _ n$ | |  _ | d  k r | } | |  _ d  S)N)r'   r6   r   r(   r)   r-   )r   r   Zold_modZnew_modZold_attrZnew_attr)r    r
   r   r      s    			zMovedAttribute.__init__c             C   s   t  |  j  } t | |  j  S)N)r   r)   r,   r-   )r   moduler
   r
   r   r      s    zMovedAttribute._resolve)r   r   r   r   r   r
   r
   )r    r   r6      s   r6   c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	 d
  Z d d   Z d d   Z	 d d   Z
 d d   Z e Z d S)_SixMetaPathImporterz
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    c             C   s   | |  _  i  |  _ d  S)N)r   known_modules)r   Zsix_module_namer
   r
   r   r      s    	z_SixMetaPathImporter.__init__c             G   s-   x& | D] } | |  j  |  j d | <q Wd  S)N.)r9   r   )r   r)   Z	fullnamesfullnamer
   r
   r   _add_module   s    z _SixMetaPathImporter._add_modulec             C   s   |  j  |  j d | S)Nr:   )r9   r   )r   r;   r
   r
   r   _get_module   s    z _SixMetaPathImporter._get_moduleNc             C   s   | |  j  k r |  Sd  S)N)r9   )r   r;   pathr
   r
   r   find_module   s    z _SixMetaPathImporter.find_modulec             C   s8   y |  j  | SWn" t k
 r3 t d |   Yn Xd  S)Nz!This loader does not know module )r9   KeyErrorImportError)r   r;   r
   r
   r   Z__get_module   s    z!_SixMetaPathImporter.__get_modulec             C   sk   y t  j | SWn t k
 r# Yn X|  j |  } t | t  rQ | j   } n	 |  | _ | t  j | <| S)N)r   r   r@    _SixMetaPathImporter__get_module
isinstancer&   r   
__loader__)r   r;   r)   r
   r
   r   load_module   s    	z _SixMetaPathImporter.load_modulec             C   s   t  |  j |  d  S)z
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        __path__)hasattrrB   )r   r;   r
   r
   r   
is_package   s    z_SixMetaPathImporter.is_packagec             C   s   |  j  |  d S)z;Return None

        Required, if is_package is implementedN)rB   )r   r;   r
   r
   r   get_code   s    z_SixMetaPathImporter.get_code)r   r   r   r   r   r<   r=   r?   rB   rE   rH   rI   
get_sourcer
   r
   r
   r   r8      s   	r8   c               @   s   e  Z d  Z d Z g  Z d S)_MovedItemszLazy loading of moved objectsN)r   r   r   r   rF   r
   r
   r
   r   rK      s   rK   Z	cStringIOioStringIOfilter	itertoolsbuiltinsZifilterfilterfalseZifilterfalseinputZ__builtin__Z	raw_inputinternr   mapimapgetcwdosZgetcwdugetcwdbrangeZxrangeZreload_module	importlibimpreloadreduce	functoolsZshlex_quoteZpipesZshlexZquoteUserDictcollectionsUserList
UserStringzipZizipzip_longestZizip_longestZconfigparserZConfigParsercopyregZcopy_regZdbm_gnuZgdbmzdbm.gnuZ_dummy_threadZdummy_threadZhttp_cookiejarZ	cookielibzhttp.cookiejarZhttp_cookiesZCookiezhttp.cookiesZhtml_entitiesZhtmlentitydefszhtml.entitiesZhtml_parserZ
HTMLParserzhtml.parserZhttp_clientZhttplibzhttp.clientZemail_mime_multipartzemail.MIMEMultipartzemail.mime.multipartZemail_mime_nonmultipartzemail.MIMENonMultipartzemail.mime.nonmultipartZemail_mime_textzemail.MIMETextzemail.mime.textZemail_mime_basezemail.MIMEBasezemail.mime.baseZBaseHTTPServerzhttp.serverZCGIHTTPServerZSimpleHTTPServerZcPicklepickleZqueueZQueuereprlibreprZsocketserverZSocketServer_threadZthreadZtkinterZTkinterZtkinter_dialogZDialogztkinter.dialogZtkinter_filedialogZ
FileDialogztkinter.filedialogZtkinter_scrolledtextZScrolledTextztkinter.scrolledtextZtkinter_simpledialogZSimpleDialogztkinter.simpledialogZtkinter_tixZTixztkinter.tixZtkinter_ttkZttkztkinter.ttkZtkinter_constantsZTkconstantsztkinter.constantsZtkinter_dndZTkdndztkinter.dndZtkinter_colorchooserZtkColorChooserztkinter.colorchooserZtkinter_commondialogZtkCommonDialogztkinter.commondialogZtkinter_tkfiledialogZtkFileDialogZtkinter_fontZtkFontztkinter.fontZtkinter_messageboxZtkMessageBoxztkinter.messageboxZtkinter_tksimpledialogZtkSimpleDialogZurllib_parsez.moves.urllib_parsezurllib.parseZurllib_errorz.moves.urllib_errorzurllib.errorZurllibz.moves.urllibZurllib_robotparserrobotparserzurllib.robotparserZxmlrpc_clientZ	xmlrpclibzxmlrpc.clientZxmlrpc_serverZSimpleXMLRPCServerzxmlrpc.serverwin32winreg_winregzmoves.z.movesmovesc               @   s   e  Z d  Z d Z d S)Module_six_moves_urllib_parsez7Lazy loading of moved objects in six.moves.urllib_parseN)r   r   r   r   r
   r
   r
   r   ro   @  s   ro   ZParseResultZurlparseZSplitResultZparse_qsZ	parse_qslZ	urldefragZurljoinZurlsplitZ
urlunparseZ
urlunsplitZ
quote_plusZunquoteZunquote_plusZ	urlencodeZ
splitqueryZsplittagZ	splituserZuses_fragmentZuses_netlocZuses_paramsZ
uses_queryZuses_relativezmoves.urllib_parsezmoves.urllib.parsec               @   s   e  Z d  Z d Z d S)Module_six_moves_urllib_errorz7Lazy loading of moved objects in six.moves.urllib_errorN)r   r   r   r   r
   r
   r
   r   rp   h  s   rp   ZURLErrorZurllib2Z	HTTPErrorZContentTooShortErrorz.moves.urllib.errorzmoves.urllib_errorzmoves.urllib.errorc               @   s   e  Z d  Z d Z d S)Module_six_moves_urllib_requestz9Lazy loading of moved objects in six.moves.urllib_requestN)r   r   r   r   r
   r
   r
   r   rq   |  s   rq   Zurlopenzurllib.requestZinstall_openerZbuild_openerZpathname2urlZurl2pathnameZ
getproxiesZRequestZOpenerDirectorZHTTPDefaultErrorHandlerZHTTPRedirectHandlerZHTTPCookieProcessorZProxyHandlerZBaseHandlerZHTTPPasswordMgrZHTTPPasswordMgrWithDefaultRealmZAbstractBasicAuthHandlerZHTTPBasicAuthHandlerZProxyBasicAuthHandlerZAbstractDigestAuthHandlerZHTTPDigestAuthHandlerZProxyDigestAuthHandlerZHTTPHandlerZHTTPSHandlerZFileHandlerZ
FTPHandlerZCacheFTPHandlerZUnknownHandlerZHTTPErrorProcessorZurlretrieveZ
urlcleanupZ	URLopenerZFancyURLopenerZproxy_bypassz.moves.urllib.requestzmoves.urllib_requestzmoves.urllib.requestc               @   s   e  Z d  Z d Z d S) Module_six_moves_urllib_responsez:Lazy loading of moved objects in six.moves.urllib_responseN)r   r   r   r   r
   r
   r
   r   rr     s   rr   Zaddbasezurllib.responseZaddclosehookZaddinfoZ
addinfourlz.moves.urllib.responsezmoves.urllib_responsezmoves.urllib.responsec               @   s   e  Z d  Z d Z d S)#Module_six_moves_urllib_robotparserz=Lazy loading of moved objects in six.moves.urllib_robotparserN)r   r   r   r   r
   r
   r
   r   rs     s   rs   ZRobotFileParserz.moves.urllib.robotparserzmoves.urllib_robotparserzmoves.urllib.robotparserc               @   ss   e  Z d  Z d Z g  Z e j d  Z e j d  Z e j d  Z	 e j d  Z
 e j d  Z d d   Z d	 S)
Module_six_moves_urllibzICreate a six.moves.urllib namespace that resembles the Python 3 namespacezmoves.urllib_parsezmoves.urllib_errorzmoves.urllib_requestzmoves.urllib_responsezmoves.urllib_robotparserc             C   s   d d d d d g S)Nparseerrorrequestresponserj   r
   )r   r
   r
   r   r5     s    zModule_six_moves_urllib.__dir__N)r   r   r   r   rF   	_importerr=   ru   rv   rw   rx   rj   r5   r
   r
   r
   r   rt     s   rt   zmoves.urllibc             C   s   t  t |  j |   d S)zAdd an item to six.moves.N)r   rK   r   )Zmover
   r
   r   add_move  s    rz   c             C   s`   y t  t |   WnH t k
 r[ y t j |  =Wn% t k
 rV t d |  f   Yn XYn Xd S)zRemove item from six.moves.zno such move, %rN)r   rK   r!   rn   __dict__r@   )r   r
   r
   r   remove_move  s    r|   __func____self____closure____code____defaults____globals__im_funcZim_selfZfunc_closureZ	func_codeZfunc_defaultsZfunc_globalsc             C   s
   |  j    S)N)next)itr
   r
   r   advance_iterator  s    r   c             C   s    t  d d   t |   j D  S)Nc             s   s   |  ] } d  | j  k Vq d S)__call__N)r{   )r2   klassr
   r
   r   	<genexpr>  s    zcallable.<locals>.<genexpr>)anytype__mro__)r"   r
   r
   r   callable  s    r   c             C   s   |  S)Nr
   )unboundr
   r
   r   get_unbound_function  s    r   c             C   s   |  S)Nr
   )r   clsr
   r
   r   create_unbound_method  s    r   c             C   s   |  j  S)N)r   )r   r
   r
   r   r   "  s    c             C   s   t  j |  | | j  S)N)types
MethodTyper    )r   r"   r
   r
   r   create_bound_method%  s    r   c             C   s   t  j |  d  |  S)N)r   r   )r   r   r
   r
   r   r   (  s    c               @   s   e  Z d  Z d d   Z d S)Iteratorc             C   s   t  |   j |   S)N)r   __next__)r   r
   r
   r   r   -  s    zIterator.nextN)r   r   r   r   r
   r
   r
   r   r   +  s   r   z3Get the function out of a possibly unbound functionc             K   s   t  |  j |    S)N)iterkeys)dkwr
   r
   r   iterkeys>  s    r   c             K   s   t  |  j |    S)N)r   values)r   r   r
   r
   r   
itervaluesA  s    r   c             K   s   t  |  j |    S)N)r   items)r   r   r
   r
   r   	iteritemsD  s    r   c             K   s   t  |  j |    S)N)r   Zlists)r   r   r
   r
   r   	iterlistsG  s    r   r   r   r   c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   P  s    c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   S  s    c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   V  s    c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   Y  s    viewkeys
viewvalues	viewitemsz1Return an iterator over the keys of a dictionary.z3Return an iterator over the values of a dictionary.z?Return an iterator over the (key, value) pairs of a dictionary.zBReturn an iterator over the (key, [values]) pairs of a dictionary.c             C   s   |  j  d  S)Nzlatin-1)encode)sr
   r
   r   bk  s    r   c             C   s   |  S)Nr
   )r   r
   r
   r   un  s    r   z>BassertCountEqualZassertRaisesRegexpZassertRegexpMatchesassertRaisesRegexassertRegexc             C   s   |  S)Nr
   )r   r
   r
   r   r     s    c             C   s   t  |  j d d  d  S)Nz\\z\\\\Zunicode_escape)unicodereplace)r   r
   r
   r   r     s    c             C   s   t  |  d  S)Nr   )ord)Zbsr
   r
   r   byte2int  s    r   c             C   s   t  |  |  S)N)r   )Zbufir
   r
   r   
indexbytes  s    r   ZassertItemsEqualzByte literalzText literalc             O   s   t  |  t  | |   S)N)r,   _assertCountEqual)r   argskwargsr
   r
   r   r     s    c             O   s   t  |  t  | |   S)N)r,   _assertRaisesRegex)r   r   r   r
   r
   r   r     s    c             O   s   t  |  t  | |   S)N)r,   _assertRegex)r   r   r   r
   r
   r   r     s    execc             C   s=   | d  k r |    } | j  | k	 r3 | j |   |  d  S)N)__traceback__with_traceback)r#   r/   tbr
   r
   r   reraise  s
    	r   c             C   s_   | d k r? t  j d  } | j } | d k r9 | j } ~ n | d k rQ | } t d  d S)zExecute code in a namespace.Nr   zexec _code_ in _globs_, _locs_)r   	_getframe	f_globalsf_localsr   )Z_code_Z_globs_Z_locs_framer
   r
   r   exec_  s    		r   z9def reraise(tp, value, tb=None):
    raise tp, value, tb
zrdef raise_from(value, from_value):
    if from_value is None:
        raise value
    raise value from from_value
zCdef raise_from(value, from_value):
    raise value from from_value
c             C   s
   |   d  S)Nr
   )r/   Z
from_valuer
   r
   r   
raise_from  s    r   printc        
         s  | j  d t j      d k r% d S  f d d   } d } | j  d d  } | d k	 r t | t  rs d } n t | t  s t d   | j  d	 d  } | d k	 r t | t  r d } n t | t  s t d
   | r t d   | sx$ |  D] } t | t  r d } Pq W| r?t d  } t d  } n d } d } | d k r]| } | d k ro| } x4 t |   D]& \ }	 } |	 r| |  | |  q|W| |  d S)z4The new-style print function for Python 2.4 and 2.5.fileNc                s   t  |  t  s t |   }  t    t  r t  |  t  r   j d  k	 r t   d d   } | d  k rl d } |  j   j |  }    j |   d  S)Nerrorsstrict)	rC   
basestringstrr   r   encodingr,   r   write)datar   )fpr
   r   r     s    zprint_.<locals>.writeFsepTzsep must be None or a stringendzend must be None or a stringz$invalid keyword arguments to print()
 )popr   stdoutrC   r   r   	TypeError	enumerate)
r   r   r   Zwant_unicoder   r   argnewlineZspacer   r
   )r   r   print_  sL    		
r   c              O   sT   | j  d t j  } | j d d  } t |  |   | rP | d  k	 rP | j   d  S)Nr   flushF)getr   r   r   _printr   )r   r   r   r   r
   r
   r   r     s
    zReraise an exception.c                s       f d d   } | S)Nc                s(   t  j      |   }   |  _ |  S)N)r^   wraps__wrapped__)f)assignedupdatedwrappedr
   r   wrapper  s    	zwraps.<locals>.wrapperr
   )r   r   r   r   r
   )r   r   r   r   r     s    r   c                s5   G   f d d   d   } t  j | d f  i   S)z%Create a base class with a metaclass.c                   s%   e  Z d  Z    f d d   Z d S)z!with_metaclass.<locals>.metaclassc                s    |   |  S)Nr
   )r   r   Z
this_basesr   )basesmetar
   r   __new__'  s    z)with_metaclass.<locals>.metaclass.__new__N)r   r   r   r   r
   )r   r   r
   r   	metaclass%  s   r   Ztemporary_class)r   r   )r   r   r   r
   )r   r   r   with_metaclass   s    r   c                s     f d d   } | S)z6Class decorator for creating a class with a metaclass.c                s   |  j  j   } | j d  } | d  k	 r` t | t  rB | g } x | D] } | j |  qI W| j d d   | j d d     |  j |  j |  S)N	__slots__r{   __weakref__)r{   copyr   rC   r   r   r   	__bases__)r   Z	orig_varsslotsZ	slots_var)r   r
   r   r   .  s    	zadd_metaclass.<locals>.wrapperr
   )r   r   r
   )r   r   add_metaclass,  s    r   c             C   sG   t  rC d |  j k r( t d |  j   |  j |  _ d d   |  _ |  S)a   
    A decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    __str__zY@python_2_unicode_compatible cannot be applied to %s because it doesn't define __str__().c             S   s   |  j    j d  S)Nzutf-8)__unicode__r   )r   r
   r
   r   <lambda>J  s    z-python_2_unicode_compatible.<locals>.<lambda>)PY2r{   
ValueErrorr   r   r   )r   r
   r
   r   python_2_unicode_compatible<  s    r   __spec__)r   r   l        il        il            l    )r   r   )r   r   )r   r   )r   r   )r   Z
__future__r   r^   rO   operatorr   r   
__author____version__version_infor   r(   ZPY34r   Zstring_typesintZinteger_typesr   Zclass_typesZ	text_typebytesZbinary_typemaxsizeZMAXSIZEr   ZlongZ	ClassTyper   platform
startswithobjectr	   lenOverflowErrorr   r   r   r&   
ModuleTyper1   r6   r8   r   ry   rK   r4   r-   r   r   rC   r<   rn   ro   Z_urllib_parse_moved_attributesrp   Z_urllib_error_moved_attributesrq   Z _urllib_request_moved_attributesrr   Z!_urllib_response_moved_attributesrs   Z$_urllib_robotparser_moved_attributesrt   rz   r|   Z
_meth_funcZ
_meth_selfZ_func_closureZ
_func_codeZ_func_defaultsZ_func_globalsr   r   	NameErrorr   r   r   r   r   r   
attrgetterZget_method_functionZget_method_selfZget_function_closureZget_function_codeZget_function_defaultsZget_function_globalsr   r   r   r   methodcallerr   r   r   r   r   chrZunichrZstructZStructZpackZint2byte
itemgetterr   getitemr   r   Z	iterbytesrL   rM   BytesIOr   r   r   partialrU   r   r   r   r   r,   rP   r   r   r   r   r   WRAPPER_ASSIGNMENTSWRAPPER_UPDATESr   r   r   r   rF   __package__globalsr   r   submodule_search_locations	meta_pathr   r   importerappendr
   r
   r
   r   <module>   s  				>					
	
	
	
	
	

							

5			
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function


class Infinity(object):

    def __repr__(self):
        return "Infinity"

    def __hash__(self):
        return hash(repr(self))

    def __lt__(self, other):
        return False

    def __le__(self, other):
        return False

    def __eq__(self, other):
        return isinstance(other, self.__class__)

    def __ne__(self, other):
        return not isinstance(other, self.__class__)

    def __gt__(self, other):
        return True

    def __ge__(self, other):
        return True

    def __neg__(self):
        return NegativeInfinity

Infinity = Infinity()


class NegativeInfinity(object):

    def __repr__(self):
        return "-Infinity"

    def __hash__(self):
        return hash(repr(self))

    def __lt__(self, other):
        return True

    def __le__(self, other):
        return True

    def __eq__(self, other):
        return isinstance(other, self.__class__)

    def __ne__(self, other):
        return not isinstance(other, self.__class__)

    def __gt__(self, other):
        return False

    def __ge__(self, other):
        return False

    def __neg__(self):
        return Infinity

NegativeInfinity = NegativeInfinity()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import operator
import os
import platform
import sys

from pkg_resources.extern.pyparsing import ParseException, ParseResults, stringStart, stringEnd
from pkg_resources.extern.pyparsing import ZeroOrMore, Group, Forward, QuotedString
from pkg_resources.extern.pyparsing import Literal as L  # noqa

from ._compat import string_types
from .specifiers import Specifier, InvalidSpecifier


__all__ = [
    "InvalidMarker", "UndefinedComparison", "UndefinedEnvironmentName",
    "Marker", "default_environment",
]


class InvalidMarker(ValueError):
    """
    An invalid marker was found, users should refer to PEP 508.
    """


class UndefinedComparison(ValueError):
    """
    An invalid operation was attempted on a value that doesn't support it.
    """


class UndefinedEnvironmentName(ValueError):
    """
    A name was attempted to be used that does not exist inside of the
    environment.
    """


class Node(object):

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return str(self.value)

    def __repr__(self):
        return "<{0}({1!r})>".format(self.__class__.__name__, str(self))

    def serialize(self):
        raise NotImplementedError


class Variable(Node):

    def serialize(self):
        return str(self)


class Value(Node):

    def serialize(self):
        return '"{0}"'.format(self)


class Op(Node):

    def serialize(self):
        return str(self)


VARIABLE = (
    L("implementation_version") |
    L("platform_python_implementation") |
    L("implementation_name") |
    L("python_full_version") |
    L("platform_release") |
    L("platform_version") |
    L("platform_machine") |
    L("platform_system") |
    L("python_version") |
    L("sys_platform") |
    L("os_name") |
    L("os.name") |  # PEP-345
    L("sys.platform") |  # PEP-345
    L("platform.version") |  # PEP-345
    L("platform.machine") |  # PEP-345
    L("platform.python_implementation") |  # PEP-345
    L("python_implementation") |  # undocumented setuptools legacy
    L("extra")
)
ALIASES = {
    'os.name': 'os_name',
    'sys.platform': 'sys_platform',
    'platform.version': 'platform_version',
    'platform.machine': 'platform_machine',
    'platform.python_implementation': 'platform_python_implementation',
    'python_implementation': 'platform_python_implementation'
}
VARIABLE.setParseAction(lambda s, l, t: Variable(ALIASES.get(t[0], t[0])))

VERSION_CMP = (
    L("===") |
    L("==") |
    L(">=") |
    L("<=") |
    L("!=") |
    L("~=") |
    L(">") |
    L("<")
)

MARKER_OP = VERSION_CMP | L("not in") | L("in")
MARKER_OP.setParseAction(lambda s, l, t: Op(t[0]))

MARKER_VALUE = QuotedString("'") | QuotedString('"')
MARKER_VALUE.setParseAction(lambda s, l, t: Value(t[0]))

BOOLOP = L("and") | L("or")

MARKER_VAR = VARIABLE | MARKER_VALUE

MARKER_ITEM = Group(MARKER_VAR + MARKER_OP + MARKER_VAR)
MARKER_ITEM.setParseAction(lambda s, l, t: tuple(t[0]))

LPAREN = L("(").suppress()
RPAREN = L(")").suppress()

MARKER_EXPR = Forward()
MARKER_ATOM = MARKER_ITEM | Group(LPAREN + MARKER_EXPR + RPAREN)
MARKER_EXPR << MARKER_ATOM + ZeroOrMore(BOOLOP + MARKER_EXPR)

MARKER = stringStart + MARKER_EXPR + stringEnd


def _coerce_parse_result(results):
    if isinstance(results, ParseResults):
        return [_coerce_parse_result(i) for i in results]
    else:
        return results


def _format_marker(marker, first=True):
    assert isinstance(marker, (list, tuple, string_types))

    # Sometimes we have a structure like [[...]] which is a single item list
    # where the single item is itself it's own list. In that case we want skip
    # the rest of this function so that we don't get extraneous () on the
    # outside.
    if (isinstance(marker, list) and len(marker) == 1 and
            isinstance(marker[0], (list, tuple))):
        return _format_marker(marker[0])

    if isinstance(marker, list):
        inner = (_format_marker(m, first=False) for m in marker)
        if first:
            return " ".join(inner)
        else:
            return "(" + " ".join(inner) + ")"
    elif isinstance(marker, tuple):
        return " ".join([m.serialize() for m in marker])
    else:
        return marker


_operators = {
    "in": lambda lhs, rhs: lhs in rhs,
    "not in": lambda lhs, rhs: lhs not in rhs,
    "<": operator.lt,
    "<=": operator.le,
    "==": operator.eq,
    "!=": operator.ne,
    ">=": operator.ge,
    ">": operator.gt,
}


def _eval_op(lhs, op, rhs):
    try:
        spec = Specifier("".join([op.serialize(), rhs]))
    except InvalidSpecifier:
        pass
    else:
        return spec.contains(lhs)

    oper = _operators.get(op.serialize())
    if oper is None:
        raise UndefinedComparison(
            "Undefined {0!r} on {1!r} and {2!r}.".format(op, lhs, rhs)
        )

    return oper(lhs, rhs)


_undefined = object()


def _get_env(environment, name):
    value = environment.get(name, _undefined)

    if value is _undefined:
        raise UndefinedEnvironmentName(
            "{0!r} does not exist in evaluation environment.".format(name)
        )

    return value


def _evaluate_markers(markers, environment):
    groups = [[]]

    for marker in markers:
        assert isinstance(marker, (list, tuple, string_types))

        if isinstance(marker, list):
            groups[-1].append(_evaluate_markers(marker, environment))
        elif isinstance(marker, tuple):
            lhs, op, rhs = marker

            if isinstance(lhs, Variable):
                lhs_value = _get_env(environment, lhs.value)
                rhs_value = rhs.value
            else:
                lhs_value = lhs.value
                rhs_value = _get_env(environment, rhs.value)

            groups[-1].append(_eval_op(lhs_value, op, rhs_value))
        else:
            assert marker in ["and", "or"]
            if marker == "or":
                groups.append([])

    return any(all(item) for item in groups)


def format_full_version(info):
    version = '{0.major}.{0.minor}.{0.micro}'.format(info)
    kind = info.releaselevel
    if kind != 'final':
        version += kind[0] + str(info.serial)
    return version


def default_environment():
    if hasattr(sys, 'implementation'):
        iver = format_full_version(sys.implementation.version)
        implementation_name = sys.implementation.name
    else:
        iver = '0'
        implementation_name = ''

    return {
        "implementation_name": implementation_name,
        "implementation_version": iver,
        "os_name": os.name,
        "platform_machine": platform.machine(),
        "platform_release": platform.release(),
        "platform_system": platform.system(),
        "platform_version": platform.version(),
        "python_full_version": platform.python_version(),
        "platform_python_implementation": platform.python_implementation(),
        "python_version": platform.python_version()[:3],
        "sys_platform": sys.platform,
    }


class Marker(object):

    def __init__(self, marker):
        try:
            self._markers = _coerce_parse_result(MARKER.parseString(marker))
        except ParseException as e:
            err_str = "Invalid marker: {0!r}, parse error at {1!r}".format(
                marker, marker[e.loc:e.loc + 8])
            raise InvalidMarker(err_str)

    def __str__(self):
        return _format_marker(self._markers)

    def __repr__(self):
        return "<Marker({0!r})>".format(str(self))

    def evaluate(self, environment=None):
        """Evaluate a marker.

        Return the boolean from evaluating the given marker against the
        environment. environment is an optional argument to override all or
        part of the determined environment.

        The environment is determined from the current Python process.
        """
        current_environment = default_environment()
        if environment is not None:
            current_environment.update(environment)

        return _evaluate_markers(self._markers, current_environment)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import string
import re

from pkg_resources.extern.pyparsing import stringStart, stringEnd, originalTextFor, ParseException
from pkg_resources.extern.pyparsing import ZeroOrMore, Word, Optional, Regex, Combine
from pkg_resources.extern.pyparsing import Literal as L  # noqa
from pkg_resources.extern.six.moves.urllib import parse as urlparse

from .markers import MARKER_EXPR, Marker
from .specifiers import LegacySpecifier, Specifier, SpecifierSet


class InvalidRequirement(ValueError):
    """
    An invalid requirement was found, users should refer to PEP 508.
    """


ALPHANUM = Word(string.ascii_letters + string.digits)

LBRACKET = L("[").suppress()
RBRACKET = L("]").suppress()
LPAREN = L("(").suppress()
RPAREN = L(")").suppress()
COMMA = L(",").suppress()
SEMICOLON = L(";").suppress()
AT = L("@").suppress()

PUNCTUATION = Word("-_.")
IDENTIFIER_END = ALPHANUM | (ZeroOrMore(PUNCTUATION) + ALPHANUM)
IDENTIFIER = Combine(ALPHANUM + ZeroOrMore(IDENTIFIER_END))

NAME = IDENTIFIER("name")
EXTRA = IDENTIFIER

URI = Regex(r'[^ ]+')("url")
URL = (AT + URI)

EXTRAS_LIST = EXTRA + ZeroOrMore(COMMA + EXTRA)
EXTRAS = (LBRACKET + Optional(EXTRAS_LIST) + RBRACKET)("extras")

VERSION_PEP440 = Regex(Specifier._regex_str, re.VERBOSE | re.IGNORECASE)
VERSION_LEGACY = Regex(LegacySpecifier._regex_str, re.VERBOSE | re.IGNORECASE)

VERSION_ONE = VERSION_PEP440 ^ VERSION_LEGACY
VERSION_MANY = Combine(VERSION_ONE + ZeroOrMore(COMMA + VERSION_ONE),
                       joinString=",", adjacent=False)("_raw_spec")
_VERSION_SPEC = Optional(((LPAREN + VERSION_MANY + RPAREN) | VERSION_MANY))
_VERSION_SPEC.setParseAction(lambda s, l, t: t._raw_spec or '')

VERSION_SPEC = originalTextFor(_VERSION_SPEC)("specifier")
VERSION_SPEC.setParseAction(lambda s, l, t: t[1])

MARKER_EXPR = originalTextFor(MARKER_EXPR())("marker")
MARKER_EXPR.setParseAction(
    lambda s, l, t: Marker(s[t._original_start:t._original_end])
)
MARKER_SEPERATOR = SEMICOLON
MARKER = MARKER_SEPERATOR + MARKER_EXPR

VERSION_AND_MARKER = VERSION_SPEC + Optional(MARKER)
URL_AND_MARKER = URL + Optional(MARKER)

NAMED_REQUIREMENT = \
    NAME + Optional(EXTRAS) + (URL_AND_MARKER | VERSION_AND_MARKER)

REQUIREMENT = stringStart + NAMED_REQUIREMENT + stringEnd


class Requirement(object):
    """Parse a requirement.

    Parse a given requirement string into its parts, such as name, specifier,
    URL, and extras. Raises InvalidRequirement on a badly-formed requirement
    string.
    """

    # TODO: Can we test whether something is contained within a requirement?
    #       If so how do we do that? Do we need to test against the _name_ of
    #       the thing as well as the version? What about the markers?
    # TODO: Can we normalize the name and extra name?

    def __init__(self, requirement_string):
        try:
            req = REQUIREMENT.parseString(requirement_string)
        except ParseException as e:
            raise InvalidRequirement(
                "Invalid requirement, parse error at \"{0!r}\"".format(
                    requirement_string[e.loc:e.loc + 8]))

        self.name = req.name
        if req.url:
            parsed_url = urlparse.urlparse(req.url)
            if not (parsed_url.scheme and parsed_url.netloc) or (
                    not parsed_url.scheme and not parsed_url.netloc):
                raise InvalidRequirement("Invalid URL given")
            self.url = req.url
        else:
            self.url = None
        self.extras = set(req.extras.asList() if req.extras else [])
        self.specifier = SpecifierSet(req.specifier)
        self.marker = req.marker if req.marker else None

    def __str__(self):
        parts = [self.name]

        if self.extras:
            parts.append("[{0}]".format(",".join(sorted(self.extras))))

        if self.specifier:
            parts.append(str(self.specifier))

        if self.url:
            parts.append("@ {0}".format(self.url))

        if self.marker:
            parts.append("; {0}".format(self.marker))

        return "".join(parts)

    def __repr__(self):
        return "<Requirement({0!r})>".format(str(self))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import abc
import functools
import itertools
import re

from ._compat import string_types, with_metaclass
from .version import Version, LegacyVersion, parse


class InvalidSpecifier(ValueError):
    """
    An invalid specifier was found, users should refer to PEP 440.
    """


class BaseSpecifier(with_metaclass(abc.ABCMeta, object)):

    @abc.abstractmethod
    def __str__(self):
        """
        Returns the str representation of this Specifier like object. This
        should be representative of the Specifier itself.
        """

    @abc.abstractmethod
    def __hash__(self):
        """
        Returns a hash value for this Specifier like object.
        """

    @abc.abstractmethod
    def __eq__(self, other):
        """
        Returns a boolean representing whether or not the two Specifier like
        objects are equal.
        """

    @abc.abstractmethod
    def __ne__(self, other):
        """
        Returns a boolean representing whether or not the two Specifier like
        objects are not equal.
        """

    @abc.abstractproperty
    def prereleases(self):
        """
        Returns whether or not pre-releases as a whole are allowed by this
        specifier.
        """

    @prereleases.setter
    def prereleases(self, value):
        """
        Sets whether or not pre-releases as a whole are allowed by this
        specifier.
        """

    @abc.abstractmethod
    def contains(self, item, prereleases=None):
        """
        Determines if the given item is contained within this specifier.
        """

    @abc.abstractmethod
    def filter(self, iterable, prereleases=None):
        """
        Takes an iterable of items and filters them so that only items which
        are contained within this specifier are allowed in it.
        """


class _IndividualSpecifier(BaseSpecifier):

    _operators = {}

    def __init__(self, spec="", prereleases=None):
        match = self._regex.search(spec)
        if not match:
            raise InvalidSpecifier("Invalid specifier: '{0}'".format(spec))

        self._spec = (
            match.group("operator").strip(),
            match.group("version").strip(),
        )

        # Store whether or not this Specifier should accept prereleases
        self._prereleases = prereleases

    def __repr__(self):
        pre = (
            ", prereleases={0!r}".format(self.prereleases)
            if self._prereleases is not None
            else ""
        )

        return "<{0}({1!r}{2})>".format(
            self.__class__.__name__,
            str(self),
            pre,
        )

    def __str__(self):
        return "{0}{1}".format(*self._spec)

    def __hash__(self):
        return hash(self._spec)

    def __eq__(self, other):
        if isinstance(other, string_types):
            try:
                other = self.__class__(other)
            except InvalidSpecifier:
                return NotImplemented
        elif not isinstance(other, self.__class__):
            return NotImplemented

        return self._spec == other._spec

    def __ne__(self, other):
        if isinstance(other, string_types):
            try:
                other = self.__class__(other)
            except InvalidSpecifier:
                return NotImplemented
        elif not isinstance(other, self.__class__):
            return NotImplemented

        return self._spec != other._spec

    def _get_operator(self, op):
        return getattr(self, "_compare_{0}".format(self._operators[op]))

    def _coerce_version(self, version):
        if not isinstance(version, (LegacyVersion, Version)):
            version = parse(version)
        return version

    @property
    def operator(self):
        return self._spec[0]

    @property
    def version(self):
        return self._spec[1]

    @property
    def prereleases(self):
        return self._prereleases

    @prereleases.setter
    def prereleases(self, value):
        self._prereleases = value

    def __contains__(self, item):
        return self.contains(item)

    def contains(self, item, prereleases=None):
        # Determine if prereleases are to be allowed or not.
        if prereleases is None:
            prereleases = self.prereleases

        # Normalize item to a Version or LegacyVersion, this allows us to have
        # a shortcut for ``"2.0" in Specifier(">=2")
        item = self._coerce_version(item)

        # Determine if we should be supporting prereleases in this specifier
        # or not, if we do not support prereleases than we can short circuit
        # logic if this version is a prereleases.
        if item.is_prerelease and not prereleases:
            return False

        # Actually do the comparison to determine if this item is contained
        # within this Specifier or not.
        return self._get_operator(self.operator)(item, self.version)

    def filter(self, iterable, prereleases=None):
        yielded = False
        found_prereleases = []

        kw = {"prereleases": prereleases if prereleases is not None else True}

        # Attempt to iterate over all the values in the iterable and if any of
        # them match, yield them.
        for version in iterable:
            parsed_version = self._coerce_version(version)

            if self.contains(parsed_version, **kw):
                # If our version is a prerelease, and we were not set to allow
                # prereleases, then we'll store it for later incase nothing
                # else matches this specifier.
                if (parsed_version.is_prerelease and not
                        (prereleases or self.prereleases)):
                    found_prereleases.append(version)
                # Either this is not a prerelease, or we should have been
                # accepting prereleases from the begining.
                else:
                    yielded = True
                    yield version

        # Now that we've iterated over everything, determine if we've yielded
        # any values, and if we have not and we have any prereleases stored up
        # then we will go ahead and yield the prereleases.
        if not yielded and found_prereleases:
            for version in found_prereleases:
                yield version


class LegacySpecifier(_IndividualSpecifier):

    _regex_str = (
        r"""
        (?P<operator>(==|!=|<=|>=|<|>))
        \s*
        (?P<version>
            [^,;\s)]* # Since this is a "legacy" specifier, and the version
                      # string can be just about anything, we match everything
                      # except for whitespace, a semi-colon for marker support,
                      # a closing paren since versions can be enclosed in
                      # them, and a comma since it's a version separator.
        )
        """
    )

    _regex = re.compile(
        r"^\s*" + _regex_str + r"\s*$", re.VERBOSE | re.IGNORECASE)

    _operators = {
        "==": "equal",
        "!=": "not_equal",
        "<=": "less_than_equal",
        ">=": "greater_than_equal",
        "<": "less_than",
        ">": "greater_than",
    }

    def _coerce_version(self, version):
        if not isinstance(version, LegacyVersion):
            version = LegacyVersion(str(version))
        return version

    def _compare_equal(self, prospective, spec):
        return prospective == self._coerce_version(spec)

    def _compare_not_equal(self, prospective, spec):
        return prospective != self._coerce_version(spec)

    def _compare_less_than_equal(self, prospective, spec):
        return prospective <= self._coerce_version(spec)

    def _compare_greater_than_equal(self, prospective, spec):
        return prospective >= self._coerce_version(spec)

    def _compare_less_than(self, prospective, spec):
        return prospective < self._coerce_version(spec)

    def _compare_greater_than(self, prospective, spec):
        return prospective > self._coerce_version(spec)


def _require_version_compare(fn):
    @functools.wraps(fn)
    def wrapped(self, prospective, spec):
        if not isinstance(prospective, Version):
            return False
        return fn(self, prospective, spec)
    return wrapped


class Specifier(_IndividualSpecifier):

    _regex_str = (
        r"""
        (?P<operator>(~=|==|!=|<=|>=|<|>|===))
        (?P<version>
            (?:
                # The identity operators allow for an escape hatch that will
                # do an exact string match of the version you wish to install.
                # This will not be parsed by PEP 440 and we cannot determine
                # any semantic meaning from it. This operator is discouraged
                # but included entirely as an escape hatch.
                (?<====)  # Only match for the identity operator
                \s*
                [^\s]*    # We just match everything, except for whitespace
                          # since we are only testing for strict identity.
            )
            |
            (?:
                # The (non)equality operators allow for wild card and local
                # versions to be specified so we have to define these two
                # operators separately to enable that.
                (?<===|!=)            # Only match for equals and not equals

                \s*
                v?
                (?:[0-9]+!)?          # epoch
                [0-9]+(?:\.[0-9]+)*   # release
                (?:                   # pre release
                    [-_\.]?
                    (a|b|c|rc|alpha|beta|pre|preview)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                   # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?

                # You cannot use a wild card and a dev or local version
                # together so group them with a | and make them optional.
                (?:
                    (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release
                    (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local
                    |
                    \.\*  # Wild card syntax of .*
                )?
            )
            |
            (?:
                # The compatible operator requires at least two digits in the
                # release segment.
                (?<=~=)               # Only match for the compatible operator

                \s*
                v?
                (?:[0-9]+!)?          # epoch
                [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)
                (?:                   # pre release
                    [-_\.]?
                    (a|b|c|rc|alpha|beta|pre|preview)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                                   # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
            )
            |
            (?:
                # All other operators only allow a sub set of what the
                # (non)equality operators do. Specifically they do not allow
                # local versions to be specified nor do they allow the prefix
                # matching wild cards.
                (?<!==|!=|~=)         # We have special cases for these
                                      # operators so we want to make sure they
                                      # don't match here.

                \s*
                v?
                (?:[0-9]+!)?          # epoch
                [0-9]+(?:\.[0-9]+)*   # release
                (?:                   # pre release
                    [-_\.]?
                    (a|b|c|rc|alpha|beta|pre|preview)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                                   # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
            )
        )
        """
    )

    _regex = re.compile(
        r"^\s*" + _regex_str + r"\s*$", re.VERBOSE | re.IGNORECASE)

    _operators = {
        "~=": "compatible",
        "==": "equal",
        "!=": "not_equal",
        "<=": "less_than_equal",
        ">=": "greater_than_equal",
        "<": "less_than",
        ">": "greater_than",
        "===": "arbitrary",
    }

    @_require_version_compare
    def _compare_compatible(self, prospective, spec):
        # Compatible releases have an equivalent combination of >= and ==. That
        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to
        # implement this in terms of the other specifiers instead of
        # implementing it ourselves. The only thing we need to do is construct
        # the other specifiers.

        # We want everything but the last item in the version, but we want to
        # ignore post and dev releases and we want to treat the pre-release as
        # it's own separate segment.
        prefix = ".".join(
            list(
                itertools.takewhile(
                    lambda x: (not x.startswith("post") and not
                               x.startswith("dev")),
                    _version_split(spec),
                )
            )[:-1]
        )

        # Add the prefix notation to the end of our string
        prefix += ".*"

        return (self._get_operator(">=")(prospective, spec) and
                self._get_operator("==")(prospective, prefix))

    @_require_version_compare
    def _compare_equal(self, prospective, spec):
        # We need special logic to handle prefix matching
        if spec.endswith(".*"):
            # In the case of prefix matching we want to ignore local segment.
            prospective = Version(prospective.public)
            # Split the spec out by dots, and pretend that there is an implicit
            # dot in between a release segment and a pre-release segment.
            spec = _version_split(spec[:-2])  # Remove the trailing .*

            # Split the prospective version out by dots, and pretend that there
            # is an implicit dot in between a release segment and a pre-release
            # segment.
            prospective = _version_split(str(prospective))

            # Shorten the prospective version to be the same length as the spec
            # so that we can determine if the specifier is a prefix of the
            # prospective version or not.
            prospective = prospective[:len(spec)]

            # Pad out our two sides with zeros so that they both equal the same
            # length.
            spec, prospective = _pad_version(spec, prospective)
        else:
            # Convert our spec string into a Version
            spec = Version(spec)

            # If the specifier does not have a local segment, then we want to
            # act as if the prospective version also does not have a local
            # segment.
            if not spec.local:
                prospective = Version(prospective.public)

        return prospective == spec

    @_require_version_compare
    def _compare_not_equal(self, prospective, spec):
        return not self._compare_equal(prospective, spec)

    @_require_version_compare
    def _compare_less_than_equal(self, prospective, spec):
        return prospective <= Version(spec)

    @_require_version_compare
    def _compare_greater_than_equal(self, prospective, spec):
        return prospective >= Version(spec)

    @_require_version_compare
    def _compare_less_than(self, prospective, spec):
        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
        spec = Version(spec)

        # Check to see if the prospective version is less than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
        if not prospective < spec:
            return False

        # This special case is here so that, unless the specifier itself
        # includes is a pre-release version, that we do not accept pre-release
        # versions for the version mentioned in the specifier (e.g. <3.1 should
        # not match 3.1.dev0, but should match 3.0.dev0).
        if not spec.is_prerelease and prospective.is_prerelease:
            if Version(prospective.base_version) == Version(spec.base_version):
                return False

        # If we've gotten to here, it means that prospective version is both
        # less than the spec version *and* it's not a pre-release of the same
        # version in the spec.
        return True

    @_require_version_compare
    def _compare_greater_than(self, prospective, spec):
        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
        spec = Version(spec)

        # Check to see if the prospective version is greater than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
        if not prospective > spec:
            return False

        # This special case is here so that, unless the specifier itself
        # includes is a post-release version, that we do not accept
        # post-release versions for the version mentioned in the specifier
        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).
        if not spec.is_postrelease and prospective.is_postrelease:
            if Version(prospective.base_version) == Version(spec.base_version):
                return False

        # Ensure that we do not allow a local version of the version mentioned
        # in the specifier, which is techincally greater than, to match.
        if prospective.local is not None:
            if Version(prospective.base_version) == Version(spec.base_version):
                return False

        # If we've gotten to here, it means that prospective version is both
        # greater than the spec version *and* it's not a pre-release of the
        # same version in the spec.
        return True

    def _compare_arbitrary(self, prospective, spec):
        return str(prospective).lower() == str(spec).lower()

    @property
    def prereleases(self):
        # If there is an explicit prereleases set for this, then we'll just
        # blindly use that.
        if self._prereleases is not None:
            return self._prereleases

        # Look at all of our specifiers and determine if they are inclusive
        # operators, and if they are if they are including an explicit
        # prerelease.
        operator, version = self._spec
        if operator in ["==", ">=", "<=", "~=", "==="]:
            # The == specifier can include a trailing .*, if it does we
            # want to remove before parsing.
            if operator == "==" and version.endswith(".*"):
                version = version[:-2]

            # Parse the version, and if it is a pre-release than this
            # specifier allows pre-releases.
            if parse(version).is_prerelease:
                return True

        return False

    @prereleases.setter
    def prereleases(self, value):
        self._prereleases = value


_prefix_regex = re.compile(r"^([0-9]+)((?:a|b|c|rc)[0-9]+)$")


def _version_split(version):
    result = []
    for item in version.split("."):
        match = _prefix_regex.search(item)
        if match:
            result.extend(match.groups())
        else:
            result.append(item)
    return result


def _pad_version(left, right):
    left_split, right_split = [], []

    # Get the release segment of our versions
    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))
    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))

    # Get the rest of our versions
    left_split.append(left[len(left_split[0]):])
    right_split.append(right[len(right_split[0]):])

    # Insert our padding
    left_split.insert(
        1,
        ["0"] * max(0, len(right_split[0]) - len(left_split[0])),
    )
    right_split.insert(
        1,
        ["0"] * max(0, len(left_split[0]) - len(right_split[0])),
    )

    return (
        list(itertools.chain(*left_split)),
        list(itertools.chain(*right_split)),
    )


class SpecifierSet(BaseSpecifier):

    def __init__(self, specifiers="", prereleases=None):
        # Split on , to break each indidivual specifier into it's own item, and
        # strip each item to remove leading/trailing whitespace.
        specifiers = [s.strip() for s in specifiers.split(",") if s.strip()]

        # Parsed each individual specifier, attempting first to make it a
        # Specifier and falling back to a LegacySpecifier.
        parsed = set()
        for specifier in specifiers:
            try:
                parsed.add(Specifier(specifier))
            except InvalidSpecifier:
                parsed.add(LegacySpecifier(specifier))

        # Turn our parsed specifiers into a frozen set and save them for later.
        self._specs = frozenset(parsed)

        # Store our prereleases value so we can use it later to determine if
        # we accept prereleases or not.
        self._prereleases = prereleases

    def __repr__(self):
        pre = (
            ", prereleases={0!r}".format(self.prereleases)
            if self._prereleases is not None
            else ""
        )

        return "<SpecifierSet({0!r}{1})>".format(str(self), pre)

    def __str__(self):
        return ",".join(sorted(str(s) for s in self._specs))

    def __hash__(self):
        return hash(self._specs)

    def __and__(self, other):
        if isinstance(other, string_types):
            other = SpecifierSet(other)
        elif not isinstance(other, SpecifierSet):
            return NotImplemented

        specifier = SpecifierSet()
        specifier._specs = frozenset(self._specs | other._specs)

        if self._prereleases is None and other._prereleases is not None:
            specifier._prereleases = other._prereleases
        elif self._prereleases is not None and other._prereleases is None:
            specifier._prereleases = self._prereleases
        elif self._prereleases == other._prereleases:
            specifier._prereleases = self._prereleases
        else:
            raise ValueError(
                "Cannot combine SpecifierSets with True and False prerelease "
                "overrides."
            )

        return specifier

    def __eq__(self, other):
        if isinstance(other, string_types):
            other = SpecifierSet(other)
        elif isinstance(other, _IndividualSpecifier):
            other = SpecifierSet(str(other))
        elif not isinstance(other, SpecifierSet):
            return NotImplemented

        return self._specs == other._specs

    def __ne__(self, other):
        if isinstance(other, string_types):
            other = SpecifierSet(other)
        elif isinstance(other, _IndividualSpecifier):
            other = SpecifierSet(str(other))
        elif not isinstance(other, SpecifierSet):
            return NotImplemented

        return self._specs != other._specs

    def __len__(self):
        return len(self._specs)

    def __iter__(self):
        return iter(self._specs)

    @property
    def prereleases(self):
        # If we have been given an explicit prerelease modifier, then we'll
        # pass that through here.
        if self._prereleases is not None:
            return self._prereleases

        # If we don't have any specifiers, and we don't have a forced value,
        # then we'll just return None since we don't know if this should have
        # pre-releases or not.
        if not self._specs:
            return None

        # Otherwise we'll see if any of the given specifiers accept
        # prereleases, if any of them do we'll return True, otherwise False.
        return any(s.prereleases for s in self._specs)

    @prereleases.setter
    def prereleases(self, value):
        self._prereleases = value

    def __contains__(self, item):
        return self.contains(item)

    def contains(self, item, prereleases=None):
        # Ensure that our item is a Version or LegacyVersion instance.
        if not isinstance(item, (LegacyVersion, Version)):
            item = parse(item)

        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
        if prereleases is None:
            prereleases = self.prereleases

        # We can determine if we're going to allow pre-releases by looking to
        # see if any of the underlying items supports them. If none of them do
        # and this item is a pre-release then we do not allow it and we can
        # short circuit that here.
        # Note: This means that 1.0.dev1 would not be contained in something
        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0
        if not prereleases and item.is_prerelease:
            return False

        # We simply dispatch to the underlying specs here to make sure that the
        # given version is contained within all of them.
        # Note: This use of all() here means that an empty set of specifiers
        #       will always return True, this is an explicit design decision.
        return all(
            s.contains(item, prereleases=prereleases)
            for s in self._specs
        )

    def filter(self, iterable, prereleases=None):
        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
        if prereleases is None:
            prereleases = self.prereleases

        # If we have any specifiers, then we want to wrap our iterable in the
        # filter method for each one, this will act as a logical AND amongst
        # each specifier.
        if self._specs:
            for spec in self._specs:
                iterable = spec.filter(iterable, prereleases=bool(prereleases))
            return iterable
        # If we do not have any specifiers, then we need to have a rough filter
        # which will filter out any pre-releases, unless there are no final
        # releases, and which will filter out LegacyVersion in general.
        else:
            filtered = []
            found_prereleases = []

            for item in iterable:
                # Ensure that we some kind of Version class for this item.
                if not isinstance(item, (LegacyVersion, Version)):
                    parsed_version = parse(item)
                else:
                    parsed_version = item

                # Filter out any item which is parsed as a LegacyVersion
                if isinstance(parsed_version, LegacyVersion):
                    continue

                # Store any item which is a pre-release for later unless we've
                # already found a final version or we are accepting prereleases
                if parsed_version.is_prerelease and not prereleases:
                    if not filtered:
                        found_prereleases.append(item)
                else:
                    filtered.append(item)

            # If we've found no items except for pre-releases, then we'll go
            # ahead and use the pre-releases
            if not filtered and found_prereleases and prereleases is None:
                return found_prereleases

            return filtered
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import re


_canonicalize_regex = re.compile(r"[-_.]+")


def canonicalize_name(name):
    # This is taken from PEP 503.
    return _canonicalize_regex.sub("-", name).lower()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import collections
import itertools
import re

from ._structures import Infinity


__all__ = [
    "parse", "Version", "LegacyVersion", "InvalidVersion", "VERSION_PATTERN"
]


_Version = collections.namedtuple(
    "_Version",
    ["epoch", "release", "dev", "pre", "post", "local"],
)


def parse(version):
    """
    Parse the given version string and return either a :class:`Version` object
    or a :class:`LegacyVersion` object depending on if the given version is
    a valid PEP 440 version or a legacy version.
    """
    try:
        return Version(version)
    except InvalidVersion:
        return LegacyVersion(version)


class InvalidVersion(ValueError):
    """
    An invalid version was found, users should refer to PEP 440.
    """


class _BaseVersion(object):

    def __hash__(self):
        return hash(self._key)

    def __lt__(self, other):
        return self._compare(other, lambda s, o: s < o)

    def __le__(self, other):
        return self._compare(other, lambda s, o: s <= o)

    def __eq__(self, other):
        return self._compare(other, lambda s, o: s == o)

    def __ge__(self, other):
        return self._compare(other, lambda s, o: s >= o)

    def __gt__(self, other):
        return self._compare(other, lambda s, o: s > o)

    def __ne__(self, other):
        return self._compare(other, lambda s, o: s != o)

    def _compare(self, other, method):
        if not isinstance(other, _BaseVersion):
            return NotImplemented

        return method(self._key, other._key)


class LegacyVersion(_BaseVersion):

    def __init__(self, version):
        self._version = str(version)
        self._key = _legacy_cmpkey(self._version)

    def __str__(self):
        return self._version

    def __repr__(self):
        return "<LegacyVersion({0})>".format(repr(str(self)))

    @property
    def public(self):
        return self._version

    @property
    def base_version(self):
        return self._version

    @property
    def local(self):
        return None

    @property
    def is_prerelease(self):
        return False

    @property
    def is_postrelease(self):
        return False


_legacy_version_component_re = re.compile(
    r"(\d+ | [a-z]+ | \.| -)", re.VERBOSE,
)

_legacy_version_replacement_map = {
    "pre": "c", "preview": "c", "-": "final-", "rc": "c", "dev": "@",
}


def _parse_version_parts(s):
    for part in _legacy_version_component_re.split(s):
        part = _legacy_version_replacement_map.get(part, part)

        if not part or part == ".":
            continue

        if part[:1] in "0123456789":
            # pad for numeric comparison
            yield part.zfill(8)
        else:
            yield "*" + part

    # ensure that alpha/beta/candidate are before final
    yield "*final"


def _legacy_cmpkey(version):
    # We hardcode an epoch of -1 here. A PEP 440 version can only have a epoch
    # greater than or equal to 0. This will effectively put the LegacyVersion,
    # which uses the defacto standard originally implemented by setuptools,
    # as before all PEP 440 versions.
    epoch = -1

    # This scheme is taken from pkg_resources.parse_version setuptools prior to
    # it's adoption of the packaging library.
    parts = []
    for part in _parse_version_parts(version.lower()):
        if part.startswith("*"):
            # remove "-" before a prerelease tag
            if part < "*final":
                while parts and parts[-1] == "*final-":
                    parts.pop()

            # remove trailing zeros from each series of numeric parts
            while parts and parts[-1] == "00000000":
                parts.pop()

        parts.append(part)
    parts = tuple(parts)

    return epoch, parts

# Deliberately not anchored to the start and end of the string, to make it
# easier for 3rd party code to reuse
VERSION_PATTERN = r"""
    v?
    (?:
        (?:(?P<epoch>[0-9]+)!)?                           # epoch
        (?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment
        (?P<pre>                                          # pre-release
            [-_\.]?
            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))
            [-_\.]?
            (?P<pre_n>[0-9]+)?
        )?
        (?P<post>                                         # post release
            (?:-(?P<post_n1>[0-9]+))
            |
            (?:
                [-_\.]?
                (?P<post_l>post|rev|r)
                [-_\.]?
                (?P<post_n2>[0-9]+)?
            )
        )?
        (?P<dev>                                          # dev release
            [-_\.]?
            (?P<dev_l>dev)
            [-_\.]?
            (?P<dev_n>[0-9]+)?
        )?
    )
    (?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version
"""


class Version(_BaseVersion):

    _regex = re.compile(
        r"^\s*" + VERSION_PATTERN + r"\s*$",
        re.VERBOSE | re.IGNORECASE,
    )

    def __init__(self, version):
        # Validate the version and parse it into pieces
        match = self._regex.search(version)
        if not match:
            raise InvalidVersion("Invalid version: '{0}'".format(version))

        # Store the parsed out pieces of the version
        self._version = _Version(
            epoch=int(match.group("epoch")) if match.group("epoch") else 0,
            release=tuple(int(i) for i in match.group("release").split(".")),
            pre=_parse_letter_version(
                match.group("pre_l"),
                match.group("pre_n"),
            ),
            post=_parse_letter_version(
                match.group("post_l"),
                match.group("post_n1") or match.group("post_n2"),
            ),
            dev=_parse_letter_version(
                match.group("dev_l"),
                match.group("dev_n"),
            ),
            local=_parse_local_version(match.group("local")),
        )

        # Generate a key which will be used for sorting
        self._key = _cmpkey(
            self._version.epoch,
            self._version.release,
            self._version.pre,
            self._version.post,
            self._version.dev,
            self._version.local,
        )

    def __repr__(self):
        return "<Version({0})>".format(repr(str(self)))

    def __str__(self):
        parts = []

        # Epoch
        if self._version.epoch != 0:
            parts.append("{0}!".format(self._version.epoch))

        # Release segment
        parts.append(".".join(str(x) for x in self._version.release))

        # Pre-release
        if self._version.pre is not None:
            parts.append("".join(str(x) for x in self._version.pre))

        # Post-release
        if self._version.post is not None:
            parts.append(".post{0}".format(self._version.post[1]))

        # Development release
        if self._version.dev is not None:
            parts.append(".dev{0}".format(self._version.dev[1]))

        # Local version segment
        if self._version.local is not None:
            parts.append(
                "+{0}".format(".".join(str(x) for x in self._version.local))
            )

        return "".join(parts)

    @property
    def public(self):
        return str(self).split("+", 1)[0]

    @property
    def base_version(self):
        parts = []

        # Epoch
        if self._version.epoch != 0:
            parts.append("{0}!".format(self._version.epoch))

        # Release segment
        parts.append(".".join(str(x) for x in self._version.release))

        return "".join(parts)

    @property
    def local(self):
        version_string = str(self)
        if "+" in version_string:
            return version_string.split("+", 1)[1]

    @property
    def is_prerelease(self):
        return bool(self._version.dev or self._version.pre)

    @property
    def is_postrelease(self):
        return bool(self._version.post)


def _parse_letter_version(letter, number):
    if letter:
        # We consider there to be an implicit 0 in a pre-release if there is
        # not a numeral associated with it.
        if number is None:
            number = 0

        # We normalize any letters to their lower case form
        letter = letter.lower()

        # We consider some words to be alternate spellings of other words and
        # in those cases we want to normalize the spellings to our preferred
        # spelling.
        if letter == "alpha":
            letter = "a"
        elif letter == "beta":
            letter = "b"
        elif letter in ["c", "pre", "preview"]:
            letter = "rc"
        elif letter in ["rev", "r"]:
            letter = "post"

        return letter, int(number)
    if not letter and number:
        # We assume if we are given a number, but we are not given a letter
        # then this is using the implicit post release syntax (e.g. 1.0-1)
        letter = "post"

        return letter, int(number)


_local_version_seperators = re.compile(r"[\._-]")


def _parse_local_version(local):
    """
    Takes a string like abc.1.twelve and turns it into ("abc", 1, "twelve").
    """
    if local is not None:
        return tuple(
            part.lower() if not part.isdigit() else int(part)
            for part in _local_version_seperators.split(local)
        )


def _cmpkey(epoch, release, pre, post, dev, local):
    # When we compare a release version, we want to compare it with all of the
    # trailing zeros removed. So we'll use a reverse the list, drop all the now
    # leading zeros until we come to something non zero, then take the rest
    # re-reverse it back into the correct order and make it a tuple and use
    # that for our sorting key.
    release = tuple(
        reversed(list(
            itertools.dropwhile(
                lambda x: x == 0,
                reversed(release),
            )
        ))
    )

    # We need to "trick" the sorting algorithm to put 1.0.dev0 before 1.0a0.
    # We'll do this by abusing the pre segment, but we _only_ want to do this
    # if there is not a pre or a post segment. If we have one of those then
    # the normal sorting rules will handle this case correctly.
    if pre is None and post is None and dev is not None:
        pre = -Infinity
    # Versions without a pre-release (except as noted above) should sort after
    # those with one.
    elif pre is None:
        pre = Infinity

    # Versions without a post segment should sort before those with one.
    if post is None:
        post = -Infinity

    # Versions without a development segment should sort after those with one.
    if dev is None:
        dev = Infinity

    if local is None:
        # Versions without a local segment should sort before those with one.
        local = -Infinity
    else:
        # Versions with a local segment need that segment parsed to implement
        # the sorting rules in PEP440.
        # - Alpha numeric segments sort before numeric segments
        # - Alpha numeric segments sort lexicographically
        # - Numeric segments sort numerically
        # - Shorter versions sort before longer versions when the prefixes
        #   match exactly
        local = tuple(
            (i, "") if isinstance(i, int) else (-Infinity, i)
            for i in local
        )

    return epoch, release, pre, post, dev, local
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
%}X                 @   sr   d  d l  m Z m Z m Z d d d d d d d d	 g Z d
 Z d Z d Z d Z d Z	 d Z
 d Z d e	 Z d S)    )absolute_importdivisionprint_function	__title____summary____uri____version__
__author__	__email____license____copyright__Z	packagingz"Core utilities for Python packagesz!https://github.com/pypa/packagingz16.8z)Donald Stufft and individual contributorszdonald@stufft.ioz"BSD or Apache License, Version 2.0zCopyright 2014-2016 %sN)Z
__future__r   r   r   __all__r   r   r   r   r	   r
   r   r    r   r   K/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/__about__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
%}X                 @   sx   d  d l  m Z m Z m Z d d l m Z m Z m Z m Z m	 Z	 m
 Z
 m Z m Z d d d d d d	 d
 d g Z d S)    )absolute_importdivisionprint_function   )
__author____copyright__	__email____license____summary__	__title____uri____version__r   r
   r   r   r   r   r	   r   N)Z
__future__r   r   r   	__about__r   r   r   r	   r
   r   r   r   __all__ r   r   J/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/__init__.py<module>   s   :                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
%}X\                 @   sy   d  d l  m Z m Z m Z d  d l Z e j d  d k Z e j d  d k Z e r` e f Z	 n	 e
 f Z	 d d   Z d S)    )absolute_importdivisionprint_functionN      c                s5   G   f d d   d   } t  j | d f  i   S)z/
    Create a base class with a metaclass.
    c                   s%   e  Z d  Z    f d d   Z d S)z!with_metaclass.<locals>.metaclassc                s    |   |  S)N )clsnameZ
this_basesd)basesmetar   I/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/_compat.py__new__   s    z)with_metaclass.<locals>.metaclass.__new__N)__name__
__module____qualname__r   r   )r   r   r   r   	metaclass   s   r   Ztemporary_class)typer   )r   r   r   r   )r   r   r   with_metaclass   s    r   )Z
__future__r   r   r   sysversion_infoZPY2ZPY3strZstring_typesZ
basestringr   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
%}X                 @   s^   d  d l  m Z m Z m Z Gd d   d e  Z e   Z Gd d   d e  Z e   Z d S)    )absolute_importdivisionprint_functionc               @   s|   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d S)Infinityc             C   s   d S)Nr    )selfr   r   M/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/_structures.py__repr__	   s    zInfinity.__repr__c             C   s   t  t |    S)N)hashrepr)r   r   r   r   __hash__   s    zInfinity.__hash__c             C   s   d S)NFr   )r   otherr   r   r   __lt__   s    zInfinity.__lt__c             C   s   d S)NFr   )r   r   r   r   r   __le__   s    zInfinity.__le__c             C   s   t  | |  j  S)N)
isinstance	__class__)r   r   r   r   r   __eq__   s    zInfinity.__eq__c             C   s   t  | |  j  S)N)r   r   )r   r   r   r   r   __ne__   s    zInfinity.__ne__c             C   s   d S)NTr   )r   r   r   r   r   __gt__   s    zInfinity.__gt__c             C   s   d S)NTr   )r   r   r   r   r   __ge__   s    zInfinity.__ge__c             C   s   t  S)N)NegativeInfinity)r   r   r   r   __neg__!   s    zInfinity.__neg__N)__name__
__module____qualname__r	   r   r   r   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s|   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d S)r   c             C   s   d S)Nz	-Infinityr   )r   r   r   r   r	   )   s    zNegativeInfinity.__repr__c             C   s   t  t |    S)N)r
   r   )r   r   r   r   r   ,   s    zNegativeInfinity.__hash__c             C   s   d S)NTr   )r   r   r   r   r   r   /   s    zNegativeInfinity.__lt__c             C   s   d S)NTr   )r   r   r   r   r   r   2   s    zNegativeInfinity.__le__c             C   s   t  | |  j  S)N)r   r   )r   r   r   r   r   r   5   s    zNegativeInfinity.__eq__c             C   s   t  | |  j  S)N)r   r   )r   r   r   r   r   r   8   s    zNegativeInfinity.__ne__c             C   s   d S)NFr   )r   r   r   r   r   r   ;   s    zNegativeInfinity.__gt__c             C   s   d S)NFr   )r   r   r   r   r   r   >   s    zNegativeInfinity.__ge__c             C   s   t  S)N)r   )r   r   r   r   r   A   s    zNegativeInfinity.__neg__N)r   r   r   r	   r   r   r   r   r   r   r   r   r   r   r   r   r   '   s   r   N)Z
__future__r   r   r   objectr   r   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
%}X8                  @   s  d  d l  m Z m Z m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m	 Z	 m
 Z
 m Z m Z d  d l m Z m Z m Z m Z d  d l m Z d d l m Z d d l m Z m Z d	 d
 d d d g Z Gd d	   d	 e  Z Gd d
   d
 e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z  Gd d   d e  Z! e d  e d  Be d  Be d  Be d  Be d  Be d  Be d   Be d!  Be d"  Be d#  Be d$  Be d%  Be d&  Be d'  Be d(  Be d)  Be d*  BZ" d$ d# d% d" d& d d' d d( d d) d i Z# e" j$ d+ d,    e d-  e d.  Be d/  Be d0  Be d1  Be d2  Be d3  Be d4  BZ% e% e d5  Be d6  BZ& e& j$ d7 d,    e d8  e d9  BZ' e' j$ d: d,    e d;  e d<  BZ( e" e' BZ) e e) e& e)  Z* e* j$ d= d,    e d>  j+   Z, e d?  j+   Z- e   Z. e* e e, e. e-  BZ/ e. e/ e e( e.  >e e. e Z0 d@ dA   Z1 dB dC dD  Z2 d6 dE d,   d5 dF d,   d4 e j3 d0 e j4 d. e j5 d1 e j6 d/ e j7 d3 e j8 i Z9 dG dH   Z: e   Z; dI dJ   Z< dK dL   Z= dM dN   Z> dO d   Z? GdP d   d e  Z@ d S)Q    )absolute_importdivisionprint_functionN)ParseExceptionParseResultsstringStart	stringEnd)
ZeroOrMoreGroupForwardQuotedString)Literal   )string_types)	SpecifierInvalidSpecifierInvalidMarkerUndefinedComparisonUndefinedEnvironmentNameMarkerdefault_environmentc               @   s   e  Z d  Z d Z d S)r   zE
    An invalid marker was found, users should refer to PEP 508.
    N)__name__
__module____qualname____doc__ r   r   I/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/markers.pyr      s   c               @   s   e  Z d  Z d Z d S)r   zP
    An invalid operation was attempted on a value that doesn't support it.
    N)r   r   r   r   r   r   r   r   r      s   c               @   s   e  Z d  Z d Z d S)r   z\
    A name was attempted to be used that does not exist inside of the
    environment.
    N)r   r   r   r   r   r   r   r   r   %   s   c               @   s@   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 S)
Nodec             C   s   | |  _  d  S)N)value)selfr   r   r   r   __init__.   s    zNode.__init__c             C   s   t  |  j  S)N)strr   )r   r   r   r   __str__1   s    zNode.__str__c             C   s   d j  |  j j t |    S)Nz<{0}({1!r})>)format	__class__r   r!   )r   r   r   r   __repr__4   s    zNode.__repr__c             C   s
   t   d  S)N)NotImplementedError)r   r   r   r   	serialize7   s    zNode.serializeN)r   r   r   r    r"   r%   r'   r   r   r   r   r   ,   s   r   c               @   s   e  Z d  Z d d   Z d S)Variablec             C   s
   t  |   S)N)r!   )r   r   r   r   r'   =   s    zVariable.serializeN)r   r   r   r'   r   r   r   r   r(   ;   s   r(   c               @   s   e  Z d  Z d d   Z d S)Valuec             C   s   d j  |   S)Nz"{0}")r#   )r   r   r   r   r'   C   s    zValue.serializeN)r   r   r   r'   r   r   r   r   r)   A   s   r)   c               @   s   e  Z d  Z d d   Z d S)Opc             C   s
   t  |   S)N)r!   )r   r   r   r   r'   I   s    zOp.serializeN)r   r   r   r'   r   r   r   r   r*   G   s   r*   implementation_versionplatform_python_implementationimplementation_namepython_full_versionplatform_releaseplatform_versionplatform_machineplatform_systempython_versionsys_platformos_namezos.namezsys.platformzplatform.versionzplatform.machinezplatform.python_implementationpython_implementationZextrac             C   s   t  t j | d | d   S)Nr   )r(   ALIASESget)sltr   r   r   <lambda>i   s    r<   z===z==z>=z<=z!=z~=><znot ininc             C   s   t  | d  S)Nr   )r*   )r9   r:   r;   r   r   r   r<   w   s    '"c             C   s   t  | d  S)Nr   )r)   )r9   r:   r;   r   r   r   r<   z   s    andorc             C   s   t  | d  S)Nr   )tuple)r9   r:   r;   r   r   r   r<      s    ()c             C   s(   t  |  t  r  d d   |  D S|  Sd  S)Nc             S   s   g  |  ] } t  |   q Sr   )_coerce_parse_result).0ir   r   r   
<listcomp>   s   	 z(_coerce_parse_result.<locals>.<listcomp>)
isinstancer   )Zresultsr   r   r   rG      s    rG   Tc             C   s   t  |  t t t f  s t  t  |  t  rf t |   d k rf t  |  d t t f  rf t |  d  St  |  t  r d d   |  D } | r d j |  Sd d j |  d Sn- t  |  t  r d j d d	   |  D  S|  Sd  S)
Nr   r   c             s   s!   |  ] } t  | d  d Vq d S)firstFN)_format_marker)rH   mr   r   r   	<genexpr>   s    z!_format_marker.<locals>.<genexpr> rE   rF   c             S   s   g  |  ] } | j     q Sr   )r'   )rH   rN   r   r   r   rJ      s   	 z"_format_marker.<locals>.<listcomp>)rK   listrD   r   AssertionErrorlenrM   join)markerrL   innerr   r   r   rM      s    !rM   c             C   s
   |  | k S)Nr   )lhsrhsr   r   r   r<      s    c             C   s
   |  | k S)Nr   )rW   rX   r   r   r   r<      s    c             C   s   y% t  d j | j   | g   } Wn t k
 r9 Yn X| j |   St j | j    } | d  k r t d j | |  |    | |  |  S)N z#Undefined {0!r} on {1!r} and {2!r}.)	r   rT   r'   r   contains
_operatorsr8   r   r#   )rW   oprX   specZoperr   r   r   _eval_op   s    %r^   c             C   s7   |  j  | t  } | t k r3 t d j |    | S)Nz/{0!r} does not exist in evaluation environment.)r8   
_undefinedr   r#   )environmentnamer   r   r   r   _get_env   s
    rb   c       	      C   s,  g  g } x	|  D]} t  | t t t f  s4 t  t  | t  r` | d j t | |   q t  | t  r | \ } } } t  | t  r t | | j	  } | j	 } n | j	 } t | | j	  } | d j t
 | | |   q | d k s t  | d k r | j g   q Wt d d   | D  S)	Nr   rB   rC   c             s   s   |  ] } t  |  Vq d  S)N)all)rH   itemr   r   r   rO      s    z$_evaluate_markers.<locals>.<genexpr>re   )rB   rC   )rK   rQ   rD   r   rR   append_evaluate_markersr(   rb   r   r^   any)	Zmarkersr`   groupsrU   rW   r\   rX   Z	lhs_valueZ	rhs_valuer   r   r   rg      s"    		 rg   c             C   sC   d j  |   } |  j } | d k r? | | d t |  j  7} | S)Nz{0.major}.{0.minor}.{0.micro}finalr   )r#   releaselevelr!   serial)infoversionZkindr   r   r   format_full_version   s
    	ro   c              C   s   t  t d  r0 t t j j  }  t j j } n d }  d } d | d |  d t j d t j   d t j	   d	 t j
   d
 t j   d t j   d t j   d t j   d  d  d t j i S)Nimplementation0rY   r-   r+   r5   r1   r/   r2   r0   r.   r,   r3      r4   )hasattrsysro   rp   rn   ra   osplatformmachinereleasesystemr3   r6   )Ziverr-   r   r   r   r      s     	c               @   sC   e  Z d  Z d d   Z d d   Z d d   Z d d d	  Z d S)
r   c             C   sz   y t  t j |   |  _ WnW t k
 ru } z7 d j | | | j | j d   } t |   WYd  d  } ~ Xn Xd  S)Nz+Invalid marker: {0!r}, parse error at {1!r}   )rG   MARKERZparseString_markersr   r#   locr   )r   rU   eZerr_strr   r   r   r      s     zMarker.__init__c             C   s   t  |  j  S)N)rM   r|   )r   r   r   r   r"     s    zMarker.__str__c             C   s   d j  t |    S)Nz<Marker({0!r})>)r#   r!   )r   r   r   r   r%     s    zMarker.__repr__Nc             C   s2   t    } | d k	 r" | j |  t |  j |  S)a$  Evaluate a marker.

        Return the boolean from evaluating the given marker against the
        environment. environment is an optional argument to override all or
        part of the determined environment.

        The environment is determined from the current Python process.
        N)r   updaterg   r|   )r   r`   Zcurrent_environmentr   r   r   evaluate   s    		zMarker.evaluate)r   r   r   r    r"   r%   r   r   r   r   r   r     s   )AZ
__future__r   r   r   operatorru   rv   rt   Zpkg_resources.extern.pyparsingr   r   r   r   r	   r
   r   r   r   LZ_compatr   Z
specifiersr   r   __all__
ValueErrorr   r   r   objectr   r(   r)   r*   ZVARIABLEr7   ZsetParseActionZVERSION_CMPZ	MARKER_OPZMARKER_VALUEZBOOLOPZ
MARKER_VARZMARKER_ITEMsuppressZLPARENZRPARENZMARKER_EXPRZMARKER_ATOMr{   rG   rM   ltleeqnegegtr[   r^   r_   rb   rg   ro   r   r   r   r   r   r   <module>   sx   ""		E
							                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
%}X                 @   sb  d  d l  m Z m Z m Z d  d l Z d  d l Z d  d l m Z m Z m	 Z	 m
 Z
 d  d l m Z m Z m Z m Z m Z d  d l m Z d  d l m Z d d l m Z m Z d d	 l m Z m Z m Z Gd
 d   d e  Z e e j e j  Z  e d  j!   Z" e d  j!   Z# e d  j!   Z$ e d  j!   Z% e d  j!   Z& e d  j!   Z' e d  j!   Z( e d  Z) e  e e)  e  BZ* e e  e e*   Z+ e+ d  Z, e+ Z- e d  d  Z. e( e. Z/ e- e e& e-  Z0 e" e e0  e# d  Z1 e e j2 e j3 e j4 B Z5 e e j2 e j3 e j4 B Z6 e5 e6 AZ7 e e7 e e& e7  d d d d d  Z8 e e$ e8 e% e8 B Z9 e9 j: d d    e	 e9  d  Z; e; j: d d    e	 e    d   Z e j: d! d    e' Z< e< e Z= e; e e=  Z> e/ e e=  Z? e, e e1  e? e> BZ@ e e@ e ZA Gd" d#   d# eB  ZC d S)$    )absolute_importdivisionprint_functionN)stringStart	stringEndoriginalTextForParseException)
ZeroOrMoreWordOptionalRegexCombine)Literal)parse   )MARKER_EXPRMarker)LegacySpecifier	SpecifierSpecifierSetc               @   s   e  Z d  Z d Z d S)InvalidRequirementzJ
    An invalid requirement was found, users should refer to PEP 508.
    N)__name__
__module____qualname____doc__ r   r   N/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/requirements.pyr      s   r   [](),;@z-_.namez[^ ]+urlextrasZ
joinStringZadjacentF	_raw_specc             C   s   | j  p d S)N )r'   )sltr   r   r   <lambda>6   s    r,   	specifierc             C   s   | d S)Nr   r   )r)   r*   r+   r   r   r   r,   9   s    markerc             C   s   t  |  | j | j   S)N)r   Z_original_startZ_original_end)r)   r*   r+   r   r   r   r,   =   s    c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	RequirementzParse a requirement.

    Parse a given requirement string into its parts, such as name, specifier,
    URL, and extras. Raises InvalidRequirement on a badly-formed requirement
    string.
    c             C   s.  y t  j |  } WnN t k
 rc } z. t d j | | j | j d     WYd  d  } ~ Xn X| j |  _ | j r t j | j  } | j	 o | j
 s | j	 r | j
 r t d   | j |  _ n	 d  |  _ t | j r | j j   n g   |  _ t | j  |  _ | j r!| j n d  |  _ d  S)Nz+Invalid requirement, parse error at "{0!r}"   zInvalid URL given)REQUIREMENTZparseStringr   r   formatlocr$   r%   urlparseschemeZnetlocsetr&   ZasListr   r-   r.   )selfZrequirement_stringZreqeZ
parsed_urlr   r   r   __init__X   s"    3		'zRequirement.__init__c             C   s   |  j  g } |  j r= | j d j d j t |  j     |  j r\ | j t |  j   |  j r~ | j d j |  j   |  j	 r | j d j |  j	   d j |  S)Nz[{0}]r!   z@ {0}z; {0}r(   )
r$   r&   appendr2   joinsortedr-   strr%   r.   )r7   partsr   r   r   __str__m   s    	(			zRequirement.__str__c             C   s   d j  t |    S)Nz<Requirement({0!r})>)r2   r=   )r7   r   r   r   __repr__~   s    zRequirement.__repr__N)r   r   r   r   r9   r?   r@   r   r   r   r   r/   K   s   r/   )DZ
__future__r   r   r   stringreZpkg_resources.extern.pyparsingr   r   r   r   r	   r
   r   r   r   r   LZ%pkg_resources.extern.six.moves.urllibr   r4   Zmarkersr   r   Z
specifiersr   r   r   
ValueErrorr   Zascii_lettersZdigitsZALPHANUMsuppressZLBRACKETZRBRACKETZLPARENZRPARENCOMMAZ	SEMICOLONATZPUNCTUATIONZIDENTIFIER_ENDZ
IDENTIFIERNAMEZEXTRAZURIZURLZEXTRAS_LISTZEXTRASZ
_regex_strVERBOSE
IGNORECASEZVERSION_PEP440ZVERSION_LEGACYZVERSION_ONEZVERSION_MANYZ_VERSION_SPECZsetParseActionZVERSION_SPECZMARKER_SEPERATORZMARKERZVERSION_AND_MARKERZURL_AND_MARKERZNAMED_REQUIREMENTr1   objectr/   r   r   r   r   <module>   sZ   "(


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
%}Xym                 @   sE  d  d l  m Z m Z m Z d  d l Z d  d l Z d  d l Z d  d l Z d d l m	 Z	 m
 Z
 d d l m Z m Z m Z Gd d   d e  Z Gd d	   d	 e
 e j e   Z Gd
 d   d e  Z Gd d   d e  Z d d   Z Gd d   d e  Z e j d  Z d d   Z d d   Z Gd d   d e  Z d S)    )absolute_importdivisionprint_functionN   )string_typeswith_metaclass)VersionLegacyVersionparsec               @   s   e  Z d  Z d Z d S)InvalidSpecifierzH
    An invalid specifier was found, users should refer to PEP 440.
    N)__name__
__module____qualname____doc__ r   r   L/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/specifiers.pyr      s   r   c               @   s   e  Z d  Z e j d d    Z e j d d    Z e j d d    Z e j d d    Z e j	 d	 d
    Z
 e
 j d d
    Z
 e j d d d   Z e j d d d   Z d S)BaseSpecifierc             C   s   d S)z
        Returns the str representation of this Specifier like object. This
        should be representative of the Specifier itself.
        Nr   )selfr   r   r   __str__   s    zBaseSpecifier.__str__c             C   s   d S)zF
        Returns a hash value for this Specifier like object.
        Nr   )r   r   r   r   __hash__   s    zBaseSpecifier.__hash__c             C   s   d S)zq
        Returns a boolean representing whether or not the two Specifier like
        objects are equal.
        Nr   )r   otherr   r   r   __eq__$   s    zBaseSpecifier.__eq__c             C   s   d S)zu
        Returns a boolean representing whether or not the two Specifier like
        objects are not equal.
        Nr   )r   r   r   r   r   __ne__+   s    zBaseSpecifier.__ne__c             C   s   d S)zg
        Returns whether or not pre-releases as a whole are allowed by this
        specifier.
        Nr   )r   r   r   r   prereleases2   s    zBaseSpecifier.prereleasesc             C   s   d S)zd
        Sets whether or not pre-releases as a whole are allowed by this
        specifier.
        Nr   )r   valuer   r   r   r   9   s    Nc             C   s   d S)zR
        Determines if the given item is contained within this specifier.
        Nr   )r   itemr   r   r   r   contains@   s    zBaseSpecifier.containsc             C   s   d S)z
        Takes an iterable of items and filters them so that only items which
        are contained within this specifier are allowed in it.
        Nr   )r   iterabler   r   r   r   filterF   s    zBaseSpecifier.filter)r   r   r   abcabstractmethodr   r   r   r   abstractpropertyr   setterr   r   r   r   r   r   r      s   r   c               @   s   e  Z d  Z i  Z d d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z e d d    Z e d d    Z e d d    Z e j d d    Z d d   Z d d d  Z d d d  Z d S) _IndividualSpecifier Nc             C   sg   |  j  j |  } | s- t d j |    | j d  j   | j d  j   f |  _ | |  _ d  S)NzInvalid specifier: '{0}'operatorversion)_regexsearchr   formatgroupstrip_spec_prereleases)r   specr   matchr   r   r   __init__R   s    z_IndividualSpecifier.__init__c             C   sF   |  j  d  k	 r! d j |  j  n d } d j |  j j t |   |  S)Nz, prereleases={0!r}r$   z<{0}({1!r}{2})>)r-   r)   r   	__class__r   str)r   prer   r   r   __repr___   s    !		z_IndividualSpecifier.__repr__c             C   s   d j  |  j   S)Nz{0}{1})r)   r,   )r   r   r   r   r   l   s    z_IndividualSpecifier.__str__c             C   s   t  |  j  S)N)hashr,   )r   r   r   r   r   o   s    z_IndividualSpecifier.__hash__c             C   sd   t  | t  r> y |  j |  } WqT t k
 r: t SYqT Xn t  | |  j  sT t S|  j | j k S)N)
isinstancer   r1   r   NotImplementedr,   )r   r   r   r   r   r   r   s    z_IndividualSpecifier.__eq__c             C   sd   t  | t  r> y |  j |  } WqT t k
 r: t SYqT Xn t  | |  j  sT t S|  j | j k S)N)r6   r   r1   r   r7   r,   )r   r   r   r   r   r   }   s    z_IndividualSpecifier.__ne__c             C   s   t  |  d j |  j |   S)Nz_compare_{0})getattrr)   
_operators)r   opr   r   r   _get_operator   s    z"_IndividualSpecifier._get_operatorc             C   s%   t  | t t f  s! t |  } | S)N)r6   r	   r   r
   )r   r&   r   r   r   _coerce_version   s    z$_IndividualSpecifier._coerce_versionc             C   s   |  j  d S)Nr   )r,   )r   r   r   r   r%      s    z_IndividualSpecifier.operatorc             C   s   |  j  d S)Nr   )r,   )r   r   r   r   r&      s    z_IndividualSpecifier.versionc             C   s   |  j  S)N)r-   )r   r   r   r   r      s    z _IndividualSpecifier.prereleasesc             C   s   | |  _  d  S)N)r-   )r   r   r   r   r   r      s    c             C   s   |  j  |  S)N)r   )r   r   r   r   r   __contains__   s    z!_IndividualSpecifier.__contains__c             C   sT   | d  k r |  j  } |  j |  } | j r8 | r8 d S|  j |  j  | |  j  S)NF)r   r<   is_prereleaser;   r%   r&   )r   r   r   r   r   r   r      s    	z_IndividualSpecifier.containsc             c   s   d } g  } d | d  k	 r! | n d i } xc | D][ } |  j  |  } |  j | |  r1 | j r | pm |  j r | j |  q1 d } | Vq1 W| r | r x | D] } | Vq Wd  S)NFr   T)r<   r   r>   r   append)r   r   r   yieldedfound_prereleaseskwr&   parsed_versionr   r   r   r      s    		z_IndividualSpecifier.filter)r   r   r   r9   r0   r4   r   r   r   r   r;   r<   propertyr%   r&   r   r"   r=   r   r   r   r   r   r   r#   N   s    r#   c               @   s   e  Z d  Z d Z e j d e d e j e j B Z d d d d d d	 d
 d d d d d i Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)LegacySpecifiera  
        (?P<operator>(==|!=|<=|>=|<|>))
        \s*
        (?P<version>
            [^,;\s)]* # Since this is a "legacy" specifier, and the version
                      # string can be just about anything, we match everything
                      # except for whitespace, a semi-colon for marker support,
                      # a closing paren since versions can be enclosed in
                      # them, and a comma since it's a version separator.
        )
        z^\s*z\s*$z==equalz!=	not_equalz<=less_than_equalz>=greater_than_equal<	less_than>greater_thanc             C   s%   t  | t  s! t t |   } | S)N)r6   r	   r2   )r   r&   r   r   r   r<      s    zLegacySpecifier._coerce_versionc             C   s   | |  j  |  k S)N)r<   )r   prospectiver.   r   r   r   _compare_equal   s    zLegacySpecifier._compare_equalc             C   s   | |  j  |  k S)N)r<   )r   rN   r.   r   r   r   _compare_not_equal   s    z"LegacySpecifier._compare_not_equalc             C   s   | |  j  |  k S)N)r<   )r   rN   r.   r   r   r   _compare_less_than_equal   s    z(LegacySpecifier._compare_less_than_equalc             C   s   | |  j  |  k S)N)r<   )r   rN   r.   r   r   r   _compare_greater_than_equal   s    z+LegacySpecifier._compare_greater_than_equalc             C   s   | |  j  |  k  S)N)r<   )r   rN   r.   r   r   r   _compare_less_than  s    z"LegacySpecifier._compare_less_thanc             C   s   | |  j  |  k S)N)r<   )r   rN   r.   r   r   r   _compare_greater_than  s    z%LegacySpecifier._compare_greater_thanN)r   r   r   
_regex_strrecompileVERBOSE
IGNORECASEr'   r9   r<   rO   rP   rQ   rR   rS   rT   r   r   r   r   rE      s    rE   c                s%   t  j      f d d    } | S)Nc                s#   t  | t  s d S  |  | |  S)NF)r6   r   )r   rN   r.   )fnr   r   wrapped  s    z)_require_version_compare.<locals>.wrapped)	functoolswraps)rZ   r[   r   )rZ   r   _require_version_compare
  s    !r^   c               @   s!  e  Z d  Z d Z e j d e d e j e j B Z d d d d d d	 d
 d d d d d d d d d i Z	 e
 d d    Z e
 d d    Z e
 d d    Z e
 d d    Z e
 d d    Z e
 d d    Z e
 d  d!    Z d" d#   Z e d$ d%    Z e j d& d%    Z d' S)(	Specifiera  
        (?P<operator>(~=|==|!=|<=|>=|<|>|===))
        (?P<version>
            (?:
                # The identity operators allow for an escape hatch that will
                # do an exact string match of the version you wish to install.
                # This will not be parsed by PEP 440 and we cannot determine
                # any semantic meaning from it. This operator is discouraged
                # but included entirely as an escape hatch.
                (?<====)  # Only match for the identity operator
                \s*
                [^\s]*    # We just match everything, except for whitespace
                          # since we are only testing for strict identity.
            )
            |
            (?:
                # The (non)equality operators allow for wild card and local
                # versions to be specified so we have to define these two
                # operators separately to enable that.
                (?<===|!=)            # Only match for equals and not equals

                \s*
                v?
                (?:[0-9]+!)?          # epoch
                [0-9]+(?:\.[0-9]+)*   # release
                (?:                   # pre release
                    [-_\.]?
                    (a|b|c|rc|alpha|beta|pre|preview)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                   # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?

                # You cannot use a wild card and a dev or local version
                # together so group them with a | and make them optional.
                (?:
                    (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release
                    (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local
                    |
                    \.\*  # Wild card syntax of .*
                )?
            )
            |
            (?:
                # The compatible operator requires at least two digits in the
                # release segment.
                (?<=~=)               # Only match for the compatible operator

                \s*
                v?
                (?:[0-9]+!)?          # epoch
                [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)
                (?:                   # pre release
                    [-_\.]?
                    (a|b|c|rc|alpha|beta|pre|preview)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                                   # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
            )
            |
            (?:
                # All other operators only allow a sub set of what the
                # (non)equality operators do. Specifically they do not allow
                # local versions to be specified nor do they allow the prefix
                # matching wild cards.
                (?<!==|!=|~=)         # We have special cases for these
                                      # operators so we want to make sure they
                                      # don't match here.

                \s*
                v?
                (?:[0-9]+!)?          # epoch
                [0-9]+(?:\.[0-9]+)*   # release
                (?:                   # pre release
                    [-_\.]?
                    (a|b|c|rc|alpha|beta|pre|preview)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                                   # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
            )
        )
        z^\s*z\s*$z~=Z
compatiblez==rF   z!=rG   z<=rH   z>=rI   rJ   rK   rL   rM   z===Z	arbitraryc             C   so   d j  t t j d d   t |    d  d   } | d 7} |  j d  | |  on |  j d  | |  S)	N.c             S   s   |  j  d  o |  j  d  S)NZpostZdev)
startswith)xr   r   r   <lambda>  s   z/Specifier._compare_compatible.<locals>.<lambda>r   z.*z>=z==)joinlist	itertools	takewhile_version_splitr;   )r   rN   r.   prefixr   r   r   _compare_compatible  s    	
zSpecifier._compare_compatiblec             C   s   | j  d  rt t | j  } t | d  d   } t t |   } | d  t |   } t | |  \ } } n$ t |  } | j s t | j  } | | k S)Nz.*   )endswithr   Zpublicri   r2   len_pad_versionlocal)r   rN   r.   r   r   r   rO     s    	zSpecifier._compare_equalc             C   s   |  j  | |  S)N)rO   )r   rN   r.   r   r   r   rP     s    zSpecifier._compare_not_equalc             C   s   | t  |  k S)N)r   )r   rN   r.   r   r   r   rQ     s    z"Specifier._compare_less_than_equalc             C   s   | t  |  k S)N)r   )r   rN   r.   r   r   r   rR     s    z%Specifier._compare_greater_than_equalc             C   sU   t  |  } | | k  s d S| j rQ | j rQ t  | j  t  | j  k rQ d Sd S)NFT)r   r>   base_version)r   rN   r.   r   r   r   rS     s    zSpecifier._compare_less_thanc             C   s   t  |  } | | k s d S| j rQ | j rQ t  | j  t  | j  k rQ d S| j d  k	 r t  | j  t  | j  k r d Sd S)NFT)r   Zis_postreleaserr   rq   )r   rN   r.   r   r   r   rT     s    zSpecifier._compare_greater_thanc             C   s"   t  |  j   t  |  j   k S)N)r2   lower)r   rN   r.   r   r   r   _compare_arbitrary  s    zSpecifier._compare_arbitraryc             C   ss   |  j  d  k	 r |  j  S|  j \ } } | d
 k ro | d k r\ | j d  r\ | d  d  } t |  j ro d Sd	 S)N==>=<=~====z.*rl   TF)ru   rv   rw   rx   ry   rm   )r-   r,   rn   r
   r>   )r   r%   r&   r   r   r   r     s    zSpecifier.prereleasesc             C   s   | |  _  d  S)N)r-   )r   r   r   r   r   r     s    N)r   r   r   rU   rV   rW   rX   rY   r'   r9   r^   rk   rO   rP   rQ   rR   rS   rT   rt   rD   r   r"   r   r   r   r   r_     s*   ^#r_   z^([0-9]+)((?:a|b|c|rc)[0-9]+)$c             C   s\   g  } xO |  j  d  D]> } t j |  } | rG | j | j    q | j |  q W| S)Nr`   )split_prefix_regexr(   extendgroupsr?   )r&   resultr   r/   r   r   r   ri   '  s    ri   c          	   C   s1  g  g  } } | j  t t j d d   |     | j  t t j d d   |    | j  |  t | d  d    | j  | t | d  d    | j d d g t d t | d  t | d    | j d d g t d t | d  t | d    t t j |    t t j |    f S)Nc             S   s
   |  j    S)N)isdigit)rb   r   r   r   rc   6  s    z_pad_version.<locals>.<lambda>c             S   s
   |  j    S)N)r   )rb   r   r   r   rc   7  s    r   r   0)r?   rf   rg   rh   ro   insertmaxchain)leftrightZ
left_splitZright_splitr   r   r   rp   2  s    %%!!//rp   c               @   s   e  Z d  Z d d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z e d d    Z e j d d    Z d d   Z d d d  Z d d d  Z d S)SpecifierSetr$   Nc             C   s   d d   | j  d  D } t   } xM | D]E } y | j t |   Wq, t k
 rp | j t |   Yq, Xq, Wt |  |  _ | |  _ d  S)Nc             S   s(   g  |  ] } | j    r | j     q Sr   )r+   ).0sr   r   r   
<listcomp>R  s   	 z)SpecifierSet.__init__.<locals>.<listcomp>,)	rz   setaddr_   r   rE   	frozenset_specsr-   )r   Z
specifiersr   Zparsed	specifierr   r   r   r0   O  s    	zSpecifierSet.__init__c             C   s=   |  j  d  k	 r! d j |  j  n d } d j t |   |  S)Nz, prereleases={0!r}r$   z<SpecifierSet({0!r}{1})>)r-   r)   r   r2   )r   r3   r   r   r   r4   d  s    !zSpecifierSet.__repr__c             C   s#   d j  t d d   |  j D   S)Nr   c             s   s   |  ] } t  |  Vq d  S)N)r2   )r   r   r   r   r   	<genexpr>n  s    z'SpecifierSet.__str__.<locals>.<genexpr>)re   sortedr   )r   r   r   r   r   m  s    zSpecifierSet.__str__c             C   s   t  |  j  S)N)r5   r   )r   r   r   r   r   p  s    zSpecifierSet.__hash__c             C   s   t  | t  r t |  } n t  | t  s1 t St   } t |  j | j B | _ |  j d  k r | j d  k	 r | j | _ nZ |  j d  k	 r | j d  k r |  j | _ n- |  j | j k r |  j | _ n t d   | S)NzFCannot combine SpecifierSets with True and False prerelease overrides.)r6   r   r   r7   r   r   r-   
ValueError)r   r   r   r   r   r   __and__s  s    		zSpecifierSet.__and__c             C   se   t  | t  r t |  } n7 t  | t  rB t t |   } n t  | t  sU t S|  j | j k S)N)r6   r   r   r#   r2   r7   r   )r   r   r   r   r   r     s    zSpecifierSet.__eq__c             C   se   t  | t  r t |  } n7 t  | t  rB t t |   } n t  | t  sU t S|  j | j k S)N)r6   r   r   r#   r2   r7   r   )r   r   r   r   r   r     s    zSpecifierSet.__ne__c             C   s   t  |  j  S)N)ro   r   )r   r   r   r   __len__  s    zSpecifierSet.__len__c             C   s   t  |  j  S)N)iterr   )r   r   r   r   __iter__  s    zSpecifierSet.__iter__c             C   s=   |  j  d  k	 r |  j  S|  j s# d  St d d   |  j D  S)Nc             s   s   |  ] } | j  Vq d  S)N)r   )r   r   r   r   r   r     s    z+SpecifierSet.prereleases.<locals>.<genexpr>)r-   r   any)r   r   r   r   r     s
    	zSpecifierSet.prereleasesc             C   s   | |  _  d  S)N)r-   )r   r   r   r   r   r     s    c             C   s   |  j  |  S)N)r   )r   r   r   r   r   r=     s    zSpecifierSet.__contains__c                sm   t    t t f  s! t       d  k r6 |  j   rJ   j rJ d St    f d d   |  j D  S)NFc             3   s$   |  ] } | j    d   Vq d S)r   N)r   )r   r   )r   r   r   r   r     s   z(SpecifierSet.contains.<locals>.<genexpr>)r6   r	   r   r
   r   r>   allr   )r   r   r   r   )r   r   r   r     s    	zSpecifierSet.containsc             C   s  | d  k r |  j  } |  j rQ x, |  j D]! } | j | d t |  } q( W| Sg  } g  } x} | D]u } t | t t f  s t |  } n | } t | t  r qd | j r | r | s | j	 |  qd | j	 |  qd W| r | r | d  k r | S| Sd  S)Nr   )
r   r   r   boolr6   r	   r   r
   r>   r?   )r   r   r   r.   ZfilteredrA   r   rC   r   r   r   r     s*    		zSpecifierSet.filter)r   r   r   r0   r4   r   r   r   r   r   r   r   rD   r   r"   r=   r   r   r   r   r   r   r   M  s   	

r   )Z
__future__r   r   r   r   r\   rg   rV   Z_compatr   r   r&   r   r	   r
   r   r   ABCMetaobjectr   r#   rE   r^   r_   rW   r{   ri   rp   r   r   r   r   r   <module>   s"   "94	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
%}X                 @   sG   d  d l  m Z m Z m Z d  d l Z e j d  Z d d   Z d S)    )absolute_importdivisionprint_functionNz[-_.]+c             C   s   t  j d |   j   S)N-)_canonicalize_regexsublower)name r
   G/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/utils.pycanonicalize_name   s    r   )Z
__future__r   r   r   recompiler   r   r
   r
   r
   r   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
%}X$-              
   @   s{  d  d l  m Z m Z m Z d  d l Z d  d l Z d  d l Z d d l m Z d d d d d	 g Z	 e j
 d
 d d d d d d g  Z d d   Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z e j d e j  Z d d d d d d d d d d i Z d d   Z d d    Z d! Z Gd" d   d e  Z d# d$   Z e j d%  Z d& d'   Z d( d)   Z d S)*    )absolute_importdivisionprint_functionN   )InfinityparseVersionLegacyVersionInvalidVersionVERSION_PATTERN_Versionepochreleasedevprepostlocalc             C   s1   y t  |   SWn t k
 r, t |   SYn Xd S)z
    Parse the given version string and return either a :class:`Version` object
    or a :class:`LegacyVersion` object depending on if the given version is
    a valid PEP 440 version or a legacy version.
    N)r   r
   r	   )version r   I/usr/lib/python3/dist-packages/pkg_resources/_vendor/packaging/version.pyr      s    c               @   s   e  Z d  Z d Z d S)r
   zF
    An invalid version was found, users should refer to PEP 440.
    N)__name__
__module____qualname____doc__r   r   r   r   r
   $   s   c               @   sp   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d S)_BaseVersionc             C   s   t  |  j  S)N)hash_key)selfr   r   r   __hash__,   s    z_BaseVersion.__hash__c             C   s   |  j  | d d    S)Nc             S   s
   |  | k  S)Nr   )sor   r   r   <lambda>0   s    z%_BaseVersion.__lt__.<locals>.<lambda>)_compare)r   otherr   r   r   __lt__/   s    z_BaseVersion.__lt__c             C   s   |  j  | d d    S)Nc             S   s
   |  | k S)Nr   )r   r    r   r   r   r!   3   s    z%_BaseVersion.__le__.<locals>.<lambda>)r"   )r   r#   r   r   r   __le__2   s    z_BaseVersion.__le__c             C   s   |  j  | d d    S)Nc             S   s
   |  | k S)Nr   )r   r    r   r   r   r!   6   s    z%_BaseVersion.__eq__.<locals>.<lambda>)r"   )r   r#   r   r   r   __eq__5   s    z_BaseVersion.__eq__c             C   s   |  j  | d d    S)Nc             S   s
   |  | k S)Nr   )r   r    r   r   r   r!   9   s    z%_BaseVersion.__ge__.<locals>.<lambda>)r"   )r   r#   r   r   r   __ge__8   s    z_BaseVersion.__ge__c             C   s   |  j  | d d    S)Nc             S   s
   |  | k S)Nr   )r   r    r   r   r   r!   <   s    z%_BaseVersion.__gt__.<locals>.<lambda>)r"   )r   r#   r   r   r   __gt__;   s    z_BaseVersion.__gt__c             C   s   |  j  | d d    S)Nc             S   s
   |  | k S)Nr   )r   r    r   r   r   r!   ?   s    z%_BaseVersion.__ne__.<locals>.<lambda>)r"   )r   r#   r   r   r   __ne__>   s    z_BaseVersion.__ne__c             C   s&   t  | t  s t S| |  j | j  S)N)
isinstancer   NotImplementedr   )r   r#   methodr   r   r   r"   A   s    z_BaseVersion._compareN)r   r   r   r   r$   r%   r&   r'   r(   r)   r"   r   r   r   r   r   *   s   r   c               @   s   e  Z d  Z d d   Z d d   Z d d   Z e d d    Z e d	 d
    Z e d d    Z	 e d d    Z
 e d d    Z d S)r	   c             C   s%   t  |  |  _ t |  j  |  _ d  S)N)str_version_legacy_cmpkeyr   )r   r   r   r   r   __init__J   s    zLegacyVersion.__init__c             C   s   |  j  S)N)r.   )r   r   r   r   __str__N   s    zLegacyVersion.__str__c             C   s   d j  t t |     S)Nz<LegacyVersion({0})>)formatreprr-   )r   r   r   r   __repr__Q   s    zLegacyVersion.__repr__c             C   s   |  j  S)N)r.   )r   r   r   r   publicT   s    zLegacyVersion.publicc             C   s   |  j  S)N)r.   )r   r   r   r   base_versionX   s    zLegacyVersion.base_versionc             C   s   d  S)Nr   )r   r   r   r   r   \   s    zLegacyVersion.localc             C   s   d S)NFr   )r   r   r   r   is_prerelease`   s    zLegacyVersion.is_prereleasec             C   s   d S)NFr   )r   r   r   r   is_postreleased   s    zLegacyVersion.is_postreleaseN)r   r   r   r0   r1   r4   propertyr5   r6   r   r7   r8   r   r   r   r   r	   H   s   z(\d+ | [a-z]+ | \.| -)cpreview-zfinal-rc@c             c   s{   xo t  j |   D]^ } t j | |  } | s | d k r> q | d  d  d k re | j d  Vq d | Vq Wd Vd  S)N.r   
0123456789   *z*final)_legacy_version_component_resplit_legacy_version_replacement_mapgetzfill)r   partr   r   r   _parse_version_partsr   s    rI   c             C   s   d } g  } x t  |  j    D]| } | j d  r | d k  rg x$ | rf | d d k rf | j   qC Wx$ | r | d d k r | j   qj W| j |  q Wt |  } | | f S)	Nr   rB   z*finalz*final-Z00000000rJ   rJ   )rI   lower
startswithpopappendtuple)r   r   partsrH   r   r   r   r/      s    r/   a  
    v?
    (?:
        (?:(?P<epoch>[0-9]+)!)?                           # epoch
        (?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment
        (?P<pre>                                          # pre-release
            [-_\.]?
            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))
            [-_\.]?
            (?P<pre_n>[0-9]+)?
        )?
        (?P<post>                                         # post release
            (?:-(?P<post_n1>[0-9]+))
            |
            (?:
                [-_\.]?
                (?P<post_l>post|rev|r)
                [-_\.]?
                (?P<post_n2>[0-9]+)?
            )
        )?
        (?P<dev>                                          # dev release
            [-_\.]?
            (?P<dev_l>dev)
            [-_\.]?
            (?P<dev_n>[0-9]+)?
        )?
    )
    (?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version
c               @   s   e  Z d  Z e j d e d e j e j B Z d d   Z	 d d   Z
 d d   Z e d	 d
    Z e d d    Z e d d    Z e d d    Z e d d    Z d S)r   z^\s*z\s*$c             C   s[  |  j  j |  } | s- t d j |    t d | j d  rW t | j d   n d d t d d   | j d  j d  D  d t	 | j d	  | j d
   d t	 | j d  | j d  p | j d   d t	 | j d  | j d   d t
 | j d    |  _ t |  j j |  j j |  j j |  j j |  j j |  j j  |  _ d  S)NzInvalid version: '{0}'r   r   r   c             s   s   |  ] } t  |  Vq d  S)N)int).0ir   r   r   	<genexpr>   s    z#Version.__init__.<locals>.<genexpr>r?   r   Zpre_lZpre_nr   Zpost_lZpost_n1Zpost_n2r   Zdev_lZdev_nr   )_regexsearchr
   r2   r   grouprQ   rO   rD   _parse_letter_version_parse_local_versionr.   _cmpkeyr   r   r   r   r   r   r   )r   r   matchr   r   r   r0      s.    *+!					zVersion.__init__c             C   s   d j  t t |     S)Nz<Version({0})>)r2   r3   r-   )r   r   r   r   r4      s    zVersion.__repr__c             C   sM  g  } |  j  j d k r4 | j d j |  j  j   | j d j d d   |  j  j D   |  j  j d  k	 r | j d j d d   |  j  j D   |  j  j d  k	 r | j d j |  j  j d	   |  j  j d  k	 r | j d
 j |  j  j d	   |  j  j	 d  k	 r@| j d j d j d d   |  j  j	 D    d j |  S)Nr   z{0}!r?   c             s   s   |  ] } t  |  Vq d  S)N)r-   )rR   xr   r   r   rT      s    z"Version.__str__.<locals>.<genexpr> c             s   s   |  ] } t  |  Vq d  S)N)r-   )rR   r\   r   r   r   rT      s    z.post{0}r   z.dev{0}z+{0}c             s   s   |  ] } t  |  Vq d  S)N)r-   )rR   r\   r   r   r   rT     s    )
r.   r   rN   r2   joinr   r   r   r   r   )r   rP   r   r   r   r1      s    ))  ,zVersion.__str__c             C   s   t  |   j d d  d S)N+r   r   )r-   rD   )r   r   r   r   r5   
  s    zVersion.publicc             C   sj   g  } |  j  j d k r4 | j d j |  j  j   | j d j d d   |  j  j D   d j |  S)Nr   z{0}!r?   c             s   s   |  ] } t  |  Vq d  S)N)r-   )rR   r\   r   r   r   rT     s    z'Version.base_version.<locals>.<genexpr>r]   )r.   r   rN   r2   r^   r   )r   rP   r   r   r   r6     s
    )zVersion.base_versionc             C   s0   t  |   } d | k r, | j d d  d Sd  S)Nr_   r   )r-   rD   )r   Zversion_stringr   r   r   r     s    zVersion.localc             C   s   t  |  j j p |  j j  S)N)boolr.   r   r   )r   r   r   r   r7   !  s    zVersion.is_prereleasec             C   s   t  |  j j  S)N)r`   r.   r   )r   r   r   r   r8   %  s    zVersion.is_postreleaseN)r   r   r   recompiler   VERBOSE
IGNORECASErU   r0   r4   r1   r9   r5   r6   r   r7   r8   r   r   r   r   r      s   #c             C   s   |  r | d  k r d } |  j    }  |  d k r9 d }  n< |  d k rN d }  n' |  d k rc d	 }  n |  d k ru d }  |  t |  f S|  r | r d }  |  t |  f Sd  S)Nr   ZalphaaZbetabr:   r   r;   r=   revrr   )r:   r   r;   )rg   rh   )rK   rQ   )ZletterZnumberr   r   r   rX   *  s     			rX   z[\._-]c             C   s0   |  d k	 r, t  d d   t j |   D  Sd S)zR
    Takes a string like abc.1.twelve and turns it into ("abc", 1, "twelve").
    Nc             s   s3   |  ]) } | j    s! | j   n	 t |  Vq d  S)N)isdigitrK   rQ   )rR   rH   r   r   r   rT   R  s   z'_parse_local_version.<locals>.<genexpr>)rO   _local_version_seperatorsrD   )r   r   r   r   rY   L  s    	rY   c             C   s   t  t t t j d d   t |      } | d  k r^ | d  k r^ | d  k	 r^ t } n | d  k rp t } | d  k r t } | d  k r t } | d  k r t } n t  d d   | D  } |  | | | | | f S)Nc             S   s
   |  d k S)Nr   r   )r\   r   r   r   r!   `  s    z_cmpkey.<locals>.<lambda>c             s   s7   |  ]- } t  | t  r$ | d  f n
 t | f Vq d S)r]   N)r*   rQ   r   )rR   rS   r   r   r   rT     s   z_cmpkey.<locals>.<genexpr>)rO   reversedlist	itertools	dropwhiler   )r   r   r   r   r   r   r   r   r   rZ   W  s&    		$

		rZ   )Z
__future__r   r   r   collectionsrm   ra   Z_structuresr   __all__
namedtupler   r   
ValueErrorr
   objectr   r	   rb   rc   rC   rE   rI   r/   r   r   rX   rj   rY   rZ   r   r   r   r   <module>   s.   !$9k                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       import sys


class VendorImporter:
    """
    A PEP 302 meta path importer for finding optionally-vendored
    or otherwise naturally-installed packages from root_name.
    """

    def __init__(self, root_name, vendored_names=(), vendor_pkg=None):
        self.root_name = root_name
        self.vendored_names = set(vendored_names)
        self.vendor_pkg = vendor_pkg or root_name.replace('extern', '_vendor')

    @property
    def search_path(self):
        """
        Search first the vendor package then as a natural package.
        """
        yield self.vendor_pkg + '.'
        yield ''

    def find_module(self, fullname, path=None):
        """
        Return self when fullname starts with root_name and the
        target module is one vendored through this importer.
        """
        root, base, target = fullname.partition(self.root_name + '.')
        if root:
            return
        if not any(map(target.startswith, self.vendored_names)):
            return
        return self

    def load_module(self, fullname):
        """
        Iterate over the search path to locate and load fullname.
        """
        root, base, target = fullname.partition(self.root_name + '.')
        for prefix in self.search_path:
            try:
                extant = prefix + target
                __import__(extant)
                mod = sys.modules[extant]
                sys.modules[fullname] = mod
                # mysterious hack:
                # Remove the reference to the extant package/module
                # on later Python versions to cause relative imports
                # in the vendor package to resolve the same modules
                # as those going through this importer.
                if sys.version_info > (3, 3):
                    del sys.modules[extant]
                return mod
            except ImportError:
                pass
        else:
            raise ImportError(
                "The '{target}' package is required; "
                "normally this is bundled with this package so if you get "
                "this warning, consult the packager of your "
                "distribution.".format(**locals())
            )

    def install(self):
        """
        Install this importer into sys.meta_path if not already present.
        """
        if self not in sys.meta_path:
            sys.meta_path.append(self)


names = 'packaging', 'pyparsing', 'six', 'appdirs'
VendorImporter(__name__, names).install()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
%}X	                 @   s<   d  d l  Z  Gd d   d  Z d Z e e e  j   d S)	    Nc               @   sa   e  Z d  Z d Z f  d d d  Z e d d    Z d d d  Z d	 d
   Z d d   Z	 d S)VendorImporterz
    A PEP 302 meta path importer for finding optionally-vendored
    or otherwise naturally-installed packages from root_name.
    Nc             C   s7   | |  _  t |  |  _ | p- | j d d  |  _ d  S)NZexternZ_vendor)	root_namesetvendored_namesreplace
vendor_pkg)selfr   r   r    r	   ?/usr/lib/python3/dist-packages/pkg_resources/extern/__init__.py__init__
   s    	zVendorImporter.__init__c             c   s   |  j  d Vd Vd S)zL
        Search first the vendor package then as a natural package.
        . N)r   )r   r	   r	   r
   search_path   s    zVendorImporter.search_pathc             C   sL   | j  |  j d  \ } } } | r) d St t | j |  j   sH d S|  S)z
        Return self when fullname starts with root_name and the
        target module is one vendored through this importer.
        r   N)	partitionr   anymap
startswithr   )r   fullnamepathrootbasetargetr	   r	   r
   find_module   s    zVendorImporter.find_modulec             C   s   | j  |  j d  \ } } } x |  j D]j } yO | | } t |  t j | } | t j | <t j d k ry t j | =| SWq) t k
 r Yq) Xq) Wt d j t	       d S)zK
        Iterate over the search path to locate and load fullname.
        r      zThe '{target}' package is required; normally this is bundled with this package so if you get this warning, consult the packager of your distribution.N)r   r   )
r   r   r   
__import__sysmodulesversion_infoImportErrorformatlocals)r   r   r   r   r   prefixZextantmodr	   r	   r
   load_module#   s    


	zVendorImporter.load_modulec             C   s#   |  t  j k r t  j j |   d S)zR
        Install this importer into sys.meta_path if not already present.
        N)r   	meta_pathappend)r   r	   r	   r
   install@   s    zVendorImporter.install)
__name__
__module____qualname____doc__r   propertyr   r   r#   r&   r	   r	   r	   r
   r      s   r   	packaging	pyparsingsixappdirs)r,   r-   r.   r/   )r   r   namesr'   r&   r	   r	   r	   r
   <module>   s   D                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Metadata-Version: 1.1
Name: requests
Version: 2.12.4
Summary: Python HTTP for Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.com
License: Apache 2.0
Description: Requests: HTTP for Humans
        =========================
        
        .. image:: https://img.shields.io/pypi/v/requests.svg
            :target: https://pypi.python.org/pypi/requests
            
        Requests is the only *Non-GMO* HTTP library for Python, safe for human
        consumption.
        
        **Warning:** Recreational use of other HTTP libraries may result in dangerous side-effects,
        including: security vulnerabilities, verbose code, reinventing the wheel,
        constantly reading documentation, depression, headaches, or even death.
        
        Behold, the power of Requests:
        
        .. code-block:: python
        
            >>> r = requests.get('https://api.github.com/user', auth=('user', 'pass'))
            >>> r.status_code
            200
            >>> r.headers['content-type']
            'application/json; charset=utf8'
            >>> r.encoding
            'utf-8'
            >>> r.text
            u'{"type":"User"...'
            >>> r.json()
            {u'disk_usage': 368627, u'private_gists': 484, ...}
        
        See `the similar code, sans Requests <https://gist.github.com/973705>`_.
        
        .. image:: http://docs.python-requests.org/en/master/_static/requests-sidebar.png
            :target: http://docs.python-requests.org/
        
        
        Requests allows you to send *organic, grass-fed* HTTP/1.1 requests, without the
        need for manual labor. There's no need to manually add query strings to your
        URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling
        are 100% automatic, powered by `urllib3 <https://github.com/shazow/urllib3>`_,
        which is embedded within Requests.
        
        Besides, all the cool kids are doing it. Requests is one of the most
        downloaded Python packages of all time, pulling in over 7,000,000 downloads
        every month. You don't want to be left out!
        
        Feature Support
        ---------------
        
        Requests is ready for today's web.
        
        - International Domains and URLs
        - Keep-Alive & Connection Pooling
        - Sessions with Cookie Persistence
        - Browser-style SSL Verification
        - Basic/Digest Authentication
        - Elegant Key/Value Cookies
        - Automatic Decompression
        - Automatic Content Decoding
        - Unicode Response Bodies
        - Multipart File Uploads
        - HTTP(S) Proxy Support
        - Connection Timeouts
        - Streaming Downloads
        - ``.netrc`` Support
        - Chunked Requests
        - Thread-safety
        
        Requests officially supports Python 2.62.7 & 3.33.5, and runs great on PyPy.
        
        Installation
        ------------
        
        To install Requests, simply:
        
        .. code-block:: bash
        
            $ pip install requests
            
        
        Satisfaction, guaranteed.
        
        Documentation
        -------------
        
        Fantastic documentation is available at http://docs.python-requests.org/, for a limited time only.
        
        
        How to Contribute
        -----------------
        
        #. Check for open issues or open a fresh issue to start a discussion around a feature idea or a bug. There is a `Contributor Friendly`_ tag for issues that should be ideal for people who are not very familiar with the codebase yet.
        #. Fork `the repository`_ on GitHub to start making your changes to the **master** branch (or branch off of it).
        #. Write a test which shows that the bug was fixed or that the feature works as expected.
        #. Send a pull request and bug the maintainer until it gets merged and published. :) Make sure to add yourself to AUTHORS_.
        
        .. _`the repository`: http://github.com/kennethreitz/requests
        .. _AUTHORS: https://github.com/kennethreitz/requests/blob/master/AUTHORS.rst
        .. _Contributor Friendly: https://github.com/kennethreitz/requests/issues?direction=desc&labels=Contributor+Friendly&page=1&sort=updated&state=open
        
        
        .. :changelog:
        
        Release History
        ---------------
        
        2.12.4 (2016-12-14)
        +++++++++++++++++++
        
        **Bugfixes**
        
        - Fixed regression from 2.12.2 where non-string types were rejected in the
          basic auth parameters. While support for this behaviour has been readded,
          the behaviour is deprecated and will be removed in the future.
        
        2.12.3 (2016-12-01)
        +++++++++++++++++++
        
        **Bugfixes**
        
        - Fixed regression from v2.12.1 for URLs with schemes that begin with "http".
          These URLs have historically been processed as though they were HTTP-schemed
          URLs, and so have had parameters added. This was removed in v2.12.2 in an
          overzealous attempt to resolve problems with IDNA-encoding those URLs. This
          change was reverted: the other fixes for IDNA-encoding have been judged to
          be sufficient to return to the behaviour Requests had before v2.12.0.
        
        2.12.2 (2016-11-30)
        +++++++++++++++++++
        
        **Bugfixes**
        
        - Fixed several issues with IDNA-encoding URLs that are technically invalid but
          which are widely accepted. Requests will now attempt to IDNA-encode a URL if
          it can but, if it fails, and the host contains only ASCII characters, it will
          be passed through optimistically. This will allow users to opt-in to using
          IDNA2003 themselves if they want to, and will also allow technically invalid
          but still common hostnames.
        - Fixed an issue where URLs with leading whitespace would raise
          ``InvalidSchema`` errors.
        - Fixed an issue where some URLs without the HTTP or HTTPS schemes would still
          have HTTP URL preparation applied to them.
        - Fixed an issue where Unicode strings could not be used in basic auth.
        - Fixed an issue encountered by some Requests plugins where constructing a
          Response object would cause ``Response.content`` to raise an
          ``AttributeError``.
        
        2.12.1 (2016-11-16)
        +++++++++++++++++++
        
        **Bugfixes**
        
        - Updated setuptools 'security' extra for the new PyOpenSSL backend in urllib3.
        
        **Miscellaneous**
        
        - Updated bundled urllib3 to 1.19.1.
        
        2.12.0 (2016-11-15)
        +++++++++++++++++++
        
        **Improvements**
        
        - Updated support for internationalized domain names from IDNA2003 to IDNA2008.
          This updated support is required for several forms of IDNs and is mandatory
          for .de domains.
        - Much improved heuristics for guessing content lengths: Requests will no
          longer read an entire ``StringIO`` into memory.
        - Much improved logic for recalculating ``Content-Length`` headers for
          ``PreparedRequest`` objects.
        - Improved tolerance for file-like objects that have no ``tell`` method but
          do have a ``seek`` method.
        - Anything that is a subclass of ``Mapping`` is now treated like a dictionary
          by the ``data=`` keyword argument.
        - Requests now tolerates empty passwords in proxy credentials, rather than
          stripping the credentials.
        - If a request is made with a file-like object as the body and that request is
          redirected with a 307 or 308 status code, Requests will now attempt to
          rewind the body object so it can be replayed.
        
        **Bugfixes**
        
        - When calling ``response.close``, the call to ``close`` will be propagated
          through to non-urllib3 backends.
        - Fixed issue where the ``ALL_PROXY`` environment variable would be preferred
          over scheme-specific variables like ``HTTP_PROXY``.
        - Fixed issue where non-UTF8 reason phrases got severely mangled by falling
          back to decoding using ISO 8859-1 instead.
        - Fixed a bug where Requests would not correctly correlate cookies set when
          using custom Host headers if those Host headers did not use the native
          string type for the platform.
        
        **Miscellaneous**
        
        - Updated bundled urllib3 to 1.19.
        - Updated bundled certifi certs to 2016.09.26.
        
        2.11.1 (2016-08-17)
        +++++++++++++++++++
        
        **Bugfixes**
        
        - Fixed a bug when using ``iter_content`` with ``decode_unicode=True`` for
          streamed bodies would raise ``AttributeError``. This bug was introduced in
          2.11.
        - Strip Content-Type and Transfer-Encoding headers from the header block when
          following a redirect that transforms the verb from POST/PUT to GET.
        
        2.11.0 (2016-08-08)
        +++++++++++++++++++
        
        **Improvements**
        
        - Added support for the ``ALL_PROXY`` environment variable.
        - Reject header values that contain leading whitespace or newline characters to
          reduce risk of header smuggling.
        
        **Bugfixes**
        
        - Fixed occasional ``TypeError`` when attempting to decode a JSON response that
          occurred in an error case. Now correctly returns a ``ValueError``.
        - Requests would incorrectly ignore a non-CIDR IP address in the ``NO_PROXY``
          environment variables: Requests now treats it as a specific IP.
        - Fixed a bug when sending JSON data that could cause us to encounter obscure
          OpenSSL errors in certain network conditions (yes, really).
        - Added type checks to ensure that ``iter_content`` only accepts integers and
          ``None`` for chunk sizes.
        - Fixed issue where responses whose body had not been fully consumed would have
          the underlying connection closed but not returned to the connection pool,
          which could cause Requests to hang in situations where the ``HTTPAdapter``
          had been configured to use a blocking connection pool.
        
        **Miscellaneous**
        
        - Updated bundled urllib3 to 1.16.
        - Some previous releases accidentally accepted non-strings as acceptable header values. This release does not.
        
        2.10.0 (2016-04-29)
        +++++++++++++++++++
        
        **New Features**
        
        - SOCKS Proxy Support! (requires PySocks; ``$ pip install requests[socks]``)
        
        **Miscellaneous**
        
        - Updated bundled urllib3 to 1.15.1.
        
        2.9.2 (2016-04-29)
        ++++++++++++++++++
        
        **Improvements**
        
        - Change built-in CaseInsensitiveDict (used for headers) to use OrderedDict
          as its underlying datastore.
        
        **Bugfixes**
        
        - Don't use redirect_cache if allow_redirects=False
        - When passed objects that throw exceptions from ``tell()``, send them via
          chunked transfer encoding instead of failing.
        - Raise a ProxyError for proxy related connection issues.
        
        2.9.1 (2015-12-21)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Resolve regression introduced in 2.9.0 that made it impossible to send binary
          strings as bodies in Python 3.
        - Fixed errors when calculating cookie expiration dates in certain locales.
        
        **Miscellaneous**
        
        - Updated bundled urllib3 to 1.13.1.
        
        2.9.0 (2015-12-15)
        ++++++++++++++++++
        
        **Minor Improvements** (Backwards compatible)
        
        - The ``verify`` keyword argument now supports being passed a path to a
          directory of CA certificates, not just a single-file bundle.
        - Warnings are now emitted when sending files opened in text mode.
        - Added the 511 Network Authentication Required status code to the status code
          registry.
        
        **Bugfixes**
        
        - For file-like objects that are not seeked to the very beginning, we now
          send the content length for the number of bytes we will actually read, rather
          than the total size of the file, allowing partial file uploads.
        - When uploading file-like objects, if they are empty or have no obvious
          content length we set ``Transfer-Encoding: chunked`` rather than
          ``Content-Length: 0``.
        - We correctly receive the response in buffered mode when uploading chunked
          bodies.
        - We now handle being passed a query string as a bytestring on Python 3, by
          decoding it as UTF-8.
        - Sessions are now closed in all cases (exceptional and not) when using the
          functional API rather than leaking and waiting for the garbage collector to
          clean them up.
        - Correctly handle digest auth headers with a malformed ``qop`` directive that
          contains no token, by treating it the same as if no ``qop`` directive was
          provided at all.
        - Minor performance improvements when removing specific cookies by name.
        
        **Miscellaneous**
        
        - Updated urllib3 to 1.13.
        
        2.8.1 (2015-10-13)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Update certificate bundle to match ``certifi`` 2015.9.6.2's weak certificate
          bundle.
        - Fix a bug in 2.8.0 where requests would raise ``ConnectTimeout`` instead of
          ``ConnectionError``
        - When using the PreparedRequest flow, requests will now correctly respect the
          ``json`` parameter. Broken in 2.8.0.
        - When using the PreparedRequest flow, requests will now correctly handle a
          Unicode-string method name on Python 2. Broken in 2.8.0.
        
        2.8.0 (2015-10-05)
        ++++++++++++++++++
        
        **Minor Improvements** (Backwards Compatible)
        
        - Requests now supports per-host proxies. This allows the ``proxies``
          dictionary to have entries of the form
          ``{'<scheme>://<hostname>': '<proxy>'}``. Host-specific proxies will be used
          in preference to the previously-supported scheme-specific ones, but the
          previous syntax will continue to work.
        - ``Response.raise_for_status`` now prints the URL that failed as part of the
          exception message.
        - ``requests.utils.get_netrc_auth`` now takes an ``raise_errors`` kwarg,
          defaulting to ``False``. When ``True``, errors parsing ``.netrc`` files cause
          exceptions to be thrown.
        - Change to bundled projects import logic to make it easier to unbundle
          requests downstream.
        - Changed the default User-Agent string to avoid leaking data on Linux: now
          contains only the requests version.
        
        **Bugfixes**
        
        - The ``json`` parameter to ``post()`` and friends will now only be used if
          neither ``data`` nor ``files`` are present, consistent with the
          documentation.
        - We now ignore empty fields in the ``NO_PROXY`` environment variable.
        - Fixed problem where ``httplib.BadStatusLine`` would get raised if combining
          ``stream=True`` with ``contextlib.closing``.
        - Prevented bugs where we would attempt to return the same connection back to
          the connection pool twice when sending a Chunked body.
        - Miscellaneous minor internal changes.
        - Digest Auth support is now thread safe.
        
        **Updates**
        
        - Updated urllib3 to 1.12.
        
        2.7.0 (2015-05-03)
        ++++++++++++++++++
        
        This is the first release that follows our new release process. For more, see
        `our documentation
        <http://docs.python-requests.org/en/latest/community/release-process/>`_.
        
        **Bugfixes**
        
        - Updated urllib3 to 1.10.4, resolving several bugs involving chunked transfer
          encoding and response framing.
        
        2.6.2 (2015-04-23)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Fix regression where compressed data that was sent as chunked data was not
          properly decompressed. (#2561)
        
        2.6.1 (2015-04-22)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Remove VendorAlias import machinery introduced in v2.5.2.
        
        - Simplify the PreparedRequest.prepare API: We no longer require the user to
          pass an empty list to the hooks keyword argument. (c.f. #2552)
        
        - Resolve redirects now receives and forwards all of the original arguments to
          the adapter. (#2503)
        
        - Handle UnicodeDecodeErrors when trying to deal with a unicode URL that
          cannot be encoded in ASCII. (#2540)
        
        - Populate the parsed path of the URI field when performing Digest
          Authentication. (#2426)
        
        - Copy a PreparedRequest's CookieJar more reliably when it is not an instance
          of RequestsCookieJar. (#2527)
        
        2.6.0 (2015-03-14)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - CVE-2015-2296: Fix handling of cookies on redirect. Previously a cookie
          without a host value set would use the hostname for the redirected URL
          exposing requests users to session fixation attacks and potentially cookie
          stealing. This was disclosed privately by Matthew Daley of
          `BugFuzz <https://bugfuzz.com>`_. This affects all versions of requests from
          v2.1.0 to v2.5.3 (inclusive on both ends).
        
        - Fix error when requests is an ``install_requires`` dependency and ``python
          setup.py test`` is run. (#2462)
        
        - Fix error when urllib3 is unbundled and requests continues to use the
          vendored import location.
        
        - Include fixes to ``urllib3``'s header handling.
        
        - Requests' handling of unvendored dependencies is now more restrictive.
        
        **Features and Improvements**
        
        - Support bytearrays when passed as parameters in the ``files`` argument.
          (#2468)
        
        - Avoid data duplication when creating a request with ``str``, ``bytes``, or
          ``bytearray`` input to the ``files`` argument.
        
        2.5.3 (2015-02-24)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Revert changes to our vendored certificate bundle. For more context see
          (#2455, #2456, and http://bugs.python.org/issue23476)
        
        2.5.2 (2015-02-23)
        ++++++++++++++++++
        
        **Features and Improvements**
        
        - Add sha256 fingerprint support. (`shazow/urllib3#540`_)
        
        - Improve the performance of headers. (`shazow/urllib3#544`_)
        
        **Bugfixes**
        
        - Copy pip's import machinery. When downstream redistributors remove
          requests.packages.urllib3 the import machinery will continue to let those
          same symbols work. Example usage in requests' documentation and 3rd-party
          libraries relying on the vendored copies of urllib3 will work without having
          to fallback to the system urllib3.
        
        - Attempt to quote parts of the URL on redirect if unquoting and then quoting
          fails. (#2356)
        
        - Fix filename type check for multipart form-data uploads. (#2411)
        
        - Properly handle the case where a server issuing digest authentication
          challenges provides both auth and auth-int qop-values. (#2408)
        
        - Fix a socket leak. (`shazow/urllib3#549`_)
        
        - Fix multiple ``Set-Cookie`` headers properly. (`shazow/urllib3#534`_)
        
        - Disable the built-in hostname verification. (`shazow/urllib3#526`_)
        
        - Fix the behaviour of decoding an exhausted stream. (`shazow/urllib3#535`_)
        
        **Security**
        
        - Pulled in an updated ``cacert.pem``.
        
        - Drop RC4 from the default cipher list. (`shazow/urllib3#551`_)
        
        .. _shazow/urllib3#551: https://github.com/shazow/urllib3/pull/551
        .. _shazow/urllib3#549: https://github.com/shazow/urllib3/pull/549
        .. _shazow/urllib3#544: https://github.com/shazow/urllib3/pull/544
        .. _shazow/urllib3#540: https://github.com/shazow/urllib3/pull/540
        .. _shazow/urllib3#535: https://github.com/shazow/urllib3/pull/535
        .. _shazow/urllib3#534: https://github.com/shazow/urllib3/pull/534
        .. _shazow/urllib3#526: https://github.com/shazow/urllib3/pull/526
        
        2.5.1 (2014-12-23)
        ++++++++++++++++++
        
        **Behavioural Changes**
        
        - Only catch HTTPErrors in raise_for_status (#2382)
        
        **Bugfixes**
        
        - Handle LocationParseError from urllib3 (#2344)
        - Handle file-like object filenames that are not strings (#2379)
        - Unbreak HTTPDigestAuth handler. Allow new nonces to be negotiated (#2389)
        
        2.5.0 (2014-12-01)
        ++++++++++++++++++
        
        **Improvements**
        
        - Allow usage of urllib3's Retry object with HTTPAdapters (#2216)
        - The ``iter_lines`` method on a response now accepts a delimiter with which
          to split the content (#2295)
        
        **Behavioural Changes**
        
        - Add deprecation warnings to functions in requests.utils that will be removed
          in 3.0 (#2309)
        - Sessions used by the functional API are always closed (#2326)
        - Restrict requests to HTTP/1.1 and HTTP/1.0 (stop accepting HTTP/0.9) (#2323)
        
        **Bugfixes**
        
        - Only parse the URL once (#2353)
        - Allow Content-Length header to always be overridden (#2332)
        - Properly handle files in HTTPDigestAuth (#2333)
        - Cap redirect_cache size to prevent memory abuse (#2299)
        - Fix HTTPDigestAuth handling of redirects after authenticating successfully
          (#2253)
        - Fix crash with custom method parameter to Session.request (#2317)
        - Fix how Link headers are parsed using the regular expression library (#2271)
        
        **Documentation**
        
        - Add more references for interlinking (#2348)
        - Update CSS for theme (#2290)
        - Update width of buttons and sidebar (#2289)
        - Replace references of Gittip with Gratipay (#2282)
        - Add link to changelog in sidebar (#2273)
        
        2.4.3 (2014-10-06)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Unicode URL improvements for Python 2.
        - Re-order JSON param for backwards compat.
        - Automatically defrag authentication schemes from host/pass URIs. (`#2249 <https://github.com/kennethreitz/requests/issues/2249>`_)
        
        
        2.4.2 (2014-10-05)
        ++++++++++++++++++
        
        **Improvements**
        
        - FINALLY! Add json parameter for uploads! (`#2258 <https://github.com/kennethreitz/requests/pull/2258>`_)
        - Support for bytestring URLs on Python 3.x (`#2238 <https://github.com/kennethreitz/requests/pull/2238>`_)
        
        **Bugfixes**
        
        - Avoid getting stuck in a loop (`#2244 <https://github.com/kennethreitz/requests/pull/2244>`_)
        - Multiple calls to iter* fail with unhelpful error. (`#2240 <https://github.com/kennethreitz/requests/issues/2240>`_, `#2241 <https://github.com/kennethreitz/requests/issues/2241>`_)
        
        **Documentation**
        
        - Correct redirection introduction (`#2245 <https://github.com/kennethreitz/requests/pull/2245/>`_)
        - Added example of how to send multiple files in one request. (`#2227 <https://github.com/kennethreitz/requests/pull/2227/>`_)
        - Clarify how to pass a custom set of CAs (`#2248 <https://github.com/kennethreitz/requests/pull/2248/>`_)
        
        
        
        2.4.1 (2014-09-09)
        ++++++++++++++++++
        
        - Now has a "security" package extras set, ``$ pip install requests[security]``
        - Requests will now use Certifi if it is available.
        - Capture and re-raise urllib3 ProtocolError
        - Bugfix for responses that attempt to redirect to themselves forever (wtf?).
        
        
        2.4.0 (2014-08-29)
        ++++++++++++++++++
        
        **Behavioral Changes**
        
        - ``Connection: keep-alive`` header is now sent automatically.
        
        **Improvements**
        
        - Support for connect timeouts! Timeout now accepts a tuple (connect, read) which is used to set individual connect and read timeouts.
        - Allow copying of PreparedRequests without headers/cookies.
        - Updated bundled urllib3 version.
        - Refactored settings loading from environment -- new `Session.merge_environment_settings`.
        - Handle socket errors in iter_content.
        
        
        2.3.0 (2014-05-16)
        ++++++++++++++++++
        
        **API Changes**
        
        - New ``Response`` property ``is_redirect``, which is true when the
          library could have processed this response as a redirection (whether
          or not it actually did).
        - The ``timeout`` parameter now affects requests with both ``stream=True`` and
          ``stream=False`` equally.
        - The change in v2.0.0 to mandate explicit proxy schemes has been reverted.
          Proxy schemes now default to ``http://``.
        - The ``CaseInsensitiveDict`` used for HTTP headers now behaves like a normal
          dictionary when references as string or viewed in the interpreter.
        
        **Bugfixes**
        
        - No longer expose Authorization or Proxy-Authorization headers on redirect.
          Fix CVE-2014-1829 and CVE-2014-1830 respectively.
        - Authorization is re-evaluated each redirect.
        - On redirect, pass url as native strings.
        - Fall-back to autodetected encoding for JSON when Unicode detection fails.
        - Headers set to ``None`` on the ``Session`` are now correctly not sent.
        - Correctly honor ``decode_unicode`` even if it wasn't used earlier in the same
          response.
        - Stop advertising ``compress`` as a supported Content-Encoding.
        - The ``Response.history`` parameter is now always a list.
        - Many, many ``urllib3`` bugfixes.
        
        2.2.1 (2014-01-23)
        ++++++++++++++++++
        
        **Bugfixes**
        
        - Fixes incorrect parsing of proxy credentials that contain a literal or encoded '#' character.
        - Assorted urllib3 fixes.
        
        2.2.0 (2014-01-09)
        ++++++++++++++++++
        
        **API Changes**
        
        - New exception: ``ContentDecodingError``. Raised instead of ``urllib3``
          ``DecodeError`` exceptions.
        
        **Bugfixes**
        
        - Avoid many many exceptions from the buggy implementation of ``proxy_bypass`` on OS X in Python 2.6.
        - Avoid crashing when attempting to get authentication credentials from ~/.netrc when running as a user without a home directory.
        - Use the correct pool size for pools of connections to proxies.
        - Fix iteration of ``CookieJar`` objects.
        - Ensure that cookies are persisted over redirect.
        - Switch back to using chardet, since it has merged with charade.
        
        2.1.0 (2013-12-05)
        ++++++++++++++++++
        
        - Updated CA Bundle, of course.
        - Cookies set on individual Requests through a ``Session`` (e.g. via ``Session.get()``) are no longer persisted to the ``Session``.
        - Clean up connections when we hit problems during chunked upload, rather than leaking them.
        - Return connections to the pool when a chunked upload is successful, rather than leaking it.
        - Match the HTTPbis recommendation for HTTP 301 redirects.
        - Prevent hanging when using streaming uploads and Digest Auth when a 401 is received.
        - Values of headers set by Requests are now always the native string type.
        - Fix previously broken SNI support.
        - Fix accessing HTTP proxies using proxy authentication.
        - Unencode HTTP Basic usernames and passwords extracted from URLs.
        - Support for IP address ranges for no_proxy environment variable
        - Parse headers correctly when users override the default ``Host:`` header.
        - Avoid munging the URL in case of case-sensitive servers.
        - Looser URL handling for non-HTTP/HTTPS urls.
        - Accept unicode methods in Python 2.6 and 2.7.
        - More resilient cookie handling.
        - Make ``Response`` objects pickleable.
        - Actually added MD5-sess to Digest Auth instead of pretending to like last time.
        - Updated internal urllib3.
        - Fixed @Lukasa's lack of taste.
        
        2.0.1 (2013-10-24)
        ++++++++++++++++++
        
        - Updated included CA Bundle with new mistrusts and automated process for the future
        - Added MD5-sess to Digest Auth
        - Accept per-file headers in multipart file POST messages.
        - Fixed: Don't send the full URL on CONNECT messages.
        - Fixed: Correctly lowercase a redirect scheme.
        - Fixed: Cookies not persisted when set via functional API.
        - Fixed: Translate urllib3 ProxyError into a requests ProxyError derived from ConnectionError.
        - Updated internal urllib3 and chardet.
        
        2.0.0 (2013-09-24)
        ++++++++++++++++++
        
        **API Changes:**
        
        - Keys in the Headers dictionary are now native strings on all Python versions,
          i.e. bytestrings on Python 2, unicode on Python 3.
        - Proxy URLs now *must* have an explicit scheme. A ``MissingSchema`` exception
          will be raised if they don't.
        - Timeouts now apply to read time if ``Stream=False``.
        - ``RequestException`` is now a subclass of ``IOError``, not ``RuntimeError``.
        - Added new method to ``PreparedRequest`` objects: ``PreparedRequest.copy()``.
        - Added new method to ``Session`` objects: ``Session.update_request()``. This
          method updates a ``Request`` object with the data (e.g. cookies) stored on
          the ``Session``.
        - Added new method to ``Session`` objects: ``Session.prepare_request()``. This
          method updates and prepares a ``Request`` object, and returns the
          corresponding ``PreparedRequest`` object.
        - Added new method to ``HTTPAdapter`` objects: ``HTTPAdapter.proxy_headers()``.
          This should not be called directly, but improves the subclass interface.
        - ``httplib.IncompleteRead`` exceptions caused by incorrect chunked encoding
          will now raise a Requests ``ChunkedEncodingError`` instead.
        - Invalid percent-escape sequences now cause a Requests ``InvalidURL``
          exception to be raised.
        - HTTP 208 no longer uses reason phrase ``"im_used"``. Correctly uses
          ``"already_reported"``.
        - HTTP 226 reason added (``"im_used"``).
        
        **Bugfixes:**
        
        - Vastly improved proxy support, including the CONNECT verb. Special thanks to
          the many contributors who worked towards this improvement.
        - Cookies are now properly managed when 401 authentication responses are
          received.
        - Chunked encoding fixes.
        - Support for mixed case schemes.
        - Better handling of streaming downloads.
        - Retrieve environment proxies from more locations.
        - Minor cookies fixes.
        - Improved redirect behaviour.
        - Improved streaming behaviour, particularly for compressed data.
        - Miscellaneous small Python 3 text encoding bugs.
        - ``.netrc`` no longer overrides explicit auth.
        - Cookies set by hooks are now correctly persisted on Sessions.
        - Fix problem with cookies that specify port numbers in their host field.
        - ``BytesIO`` can be used to perform streaming uploads.
        - More generous parsing of the ``no_proxy`` environment variable.
        - Non-string objects can be passed in data values alongside files.
        
        1.2.3 (2013-05-25)
        ++++++++++++++++++
        
        - Simple packaging fix
        
        
        1.2.2 (2013-05-23)
        ++++++++++++++++++
        
        - Simple packaging fix
        
        
        1.2.1 (2013-05-20)
        ++++++++++++++++++
        
        - 301 and 302 redirects now change the verb to GET for all verbs, not just
          POST, improving browser compatibility.
        - Python 3.3.2 compatibility
        - Always percent-encode location headers
        - Fix connection adapter matching to be most-specific first
        - new argument to the default connection adapter for passing a block argument
        - prevent a KeyError when there's no link headers
        
        1.2.0 (2013-03-31)
        ++++++++++++++++++
        
        - Fixed cookies on sessions and on requests
        - Significantly change how hooks are dispatched - hooks now receive all the
          arguments specified by the user when making a request so hooks can make a
          secondary request with the same parameters. This is especially necessary for
          authentication handler authors
        - certifi support was removed
        - Fixed bug where using OAuth 1 with body ``signature_type`` sent no data
        - Major proxy work thanks to @Lukasa including parsing of proxy authentication
          from the proxy url
        - Fix DigestAuth handling too many 401s
        - Update vendored urllib3 to include SSL bug fixes
        - Allow keyword arguments to be passed to ``json.loads()`` via the
          ``Response.json()`` method
        - Don't send ``Content-Length`` header by default on ``GET`` or ``HEAD``
          requests
        - Add ``elapsed`` attribute to ``Response`` objects to time how long a request
          took.
        - Fix ``RequestsCookieJar``
        - Sessions and Adapters are now picklable, i.e., can be used with the
          multiprocessing library
        - Update charade to version 1.0.3
        
        The change in how hooks are dispatched will likely cause a great deal of
        issues.
        
        1.1.0 (2013-01-10)
        ++++++++++++++++++
        
        - CHUNKED REQUESTS
        - Support for iterable response bodies
        - Assume servers persist redirect params
        - Allow explicit content types to be specified for file data
        - Make merge_kwargs case-insensitive when looking up keys
        
        1.0.3 (2012-12-18)
        ++++++++++++++++++
        
        - Fix file upload encoding bug
        - Fix cookie behavior
        
        1.0.2 (2012-12-17)
        ++++++++++++++++++
        
        - Proxy fix for HTTPAdapter.
        
        1.0.1 (2012-12-17)
        ++++++++++++++++++
        
        - Cert verification exception bug.
        - Proxy fix for HTTPAdapter.
        
        1.0.0 (2012-12-17)
        ++++++++++++++++++
        
        - Massive Refactor and Simplification
        - Switch to Apache 2.0 license
        - Swappable Connection Adapters
        - Mountable Connection Adapters
        - Mutable ProcessedRequest chain
        - /s/prefetch/stream
        - Removal of all configuration
        - Standard library logging
        - Make Response.json() callable, not property.
        - Usage of new charade project, which provides python 2 and 3 simultaneous chardet.
        - Removal of all hooks except 'response'
        - Removal of all authentication helpers (OAuth, Kerberos)
        
        This is not a backwards compatible change.
        
        0.14.2 (2012-10-27)
        +++++++++++++++++++
        
        - Improved mime-compatible JSON handling
        - Proxy fixes
        - Path hack fixes
        - Case-Insensitive Content-Encoding headers
        - Support for CJK parameters in form posts
        
        
        0.14.1 (2012-10-01)
        +++++++++++++++++++
        
        - Python 3.3 Compatibility
        - Simply default accept-encoding
        - Bugfixes
        
        
        0.14.0 (2012-09-02)
        ++++++++++++++++++++
        
        - No more iter_content errors if already downloaded.
        
        0.13.9 (2012-08-25)
        +++++++++++++++++++
        
        - Fix for OAuth + POSTs
        - Remove exception eating from dispatch_hook
        - General bugfixes
        
        0.13.8 (2012-08-21)
        +++++++++++++++++++
        
        - Incredible Link header support :)
        
        0.13.7 (2012-08-19)
        +++++++++++++++++++
        
        - Support for (key, value) lists everywhere.
        - Digest Authentication improvements.
        - Ensure proxy exclusions work properly.
        - Clearer UnicodeError exceptions.
        - Automatic casting of URLs to strings (fURL and such)
        - Bugfixes.
        
        0.13.6 (2012-08-06)
        +++++++++++++++++++
        
        - Long awaited fix for hanging connections!
        
        0.13.5 (2012-07-27)
        +++++++++++++++++++
        
        - Packaging fix
        
        0.13.4 (2012-07-27)
        +++++++++++++++++++
        
        - GSSAPI/Kerberos authentication!
        - App Engine 2.7 Fixes!
        - Fix leaking connections (from urllib3 update)
        - OAuthlib path hack fix
        - OAuthlib URL parameters fix.
        
        0.13.3 (2012-07-12)
        +++++++++++++++++++
        
        - Use simplejson if available.
        - Do not hide SSLErrors behind Timeouts.
        - Fixed param handling with urls containing fragments.
        - Significantly improved information in User Agent.
        - client certificates are ignored when verify=False
        
        0.13.2 (2012-06-28)
        +++++++++++++++++++
        
        - Zero dependencies (once again)!
        - New: Response.reason
        - Sign querystring parameters in OAuth 1.0
        - Client certificates no longer ignored when verify=False
        - Add openSUSE certificate support
        
        0.13.1 (2012-06-07)
        +++++++++++++++++++
        
        - Allow passing a file or file-like object as data.
        - Allow hooks to return responses that indicate errors.
        - Fix Response.text and Response.json for body-less responses.
        
        0.13.0 (2012-05-29)
        +++++++++++++++++++
        
        - Removal of Requests.async in favor of `grequests <https://github.com/kennethreitz/grequests>`_
        - Allow disabling of cookie persistence.
        - New implementation of safe_mode
        - cookies.get now supports default argument
        - Session cookies not saved when Session.request is called with return_response=False
        - Env: no_proxy support.
        - RequestsCookieJar improvements.
        - Various bug fixes.
        
        0.12.1 (2012-05-08)
        +++++++++++++++++++
        
        - New ``Response.json`` property.
        - Ability to add string file uploads.
        - Fix out-of-range issue with iter_lines.
        - Fix iter_content default size.
        - Fix POST redirects containing files.
        
        0.12.0 (2012-05-02)
        +++++++++++++++++++
        
        - EXPERIMENTAL OAUTH SUPPORT!
        - Proper CookieJar-backed cookies interface with awesome dict-like interface.
        - Speed fix for non-iterated content chunks.
        - Move ``pre_request`` to a more usable place.
        - New ``pre_send`` hook.
        - Lazily encode data, params, files.
        - Load system Certificate Bundle if ``certify`` isn't available.
        - Cleanups, fixes.
        
        0.11.2 (2012-04-22)
        +++++++++++++++++++
        
        - Attempt to use the OS's certificate bundle if ``certifi`` isn't available.
        - Infinite digest auth redirect fix.
        - Multi-part file upload improvements.
        - Fix decoding of invalid %encodings in URLs.
        - If there is no content in a response don't throw an error the second time that content is attempted to be read.
        - Upload data on redirects.
        
        0.11.1 (2012-03-30)
        +++++++++++++++++++
        
        * POST redirects now break RFC to do what browsers do: Follow up with a GET.
        * New ``strict_mode`` configuration to disable new redirect behavior.
        
        
        0.11.0 (2012-03-14)
        +++++++++++++++++++
        
        * Private SSL Certificate support
        * Remove select.poll from Gevent monkeypatching
        * Remove redundant generator for chunked transfer encoding
        * Fix: Response.ok raises Timeout Exception in safe_mode
        
        0.10.8 (2012-03-09)
        +++++++++++++++++++
        
        * Generate chunked ValueError fix
        * Proxy configuration by environment variables
        * Simplification of iter_lines.
        * New `trust_env` configuration for disabling system/environment hints.
        * Suppress cookie errors.
        
        0.10.7 (2012-03-07)
        +++++++++++++++++++
        
        * `encode_uri` = False
        
        0.10.6 (2012-02-25)
        +++++++++++++++++++
        
        * Allow '=' in cookies.
        
        0.10.5 (2012-02-25)
        +++++++++++++++++++
        
        * Response body with 0 content-length fix.
        * New async.imap.
        * Don't fail on netrc.
        
        
        0.10.4 (2012-02-20)
        +++++++++++++++++++
        
        * Honor netrc.
        
        0.10.3 (2012-02-20)
        +++++++++++++++++++
        
        * HEAD requests don't follow redirects anymore.
        * raise_for_status() doesn't raise for 3xx anymore.
        * Make Session objects picklable.
        * ValueError for invalid schema URLs.
        
        0.10.2 (2012-01-15)
        +++++++++++++++++++
        
        * Vastly improved URL quoting.
        * Additional allowed cookie key values.
        * Attempted fix for "Too many open files" Error
        * Replace unicode errors on first pass, no need for second pass.
        * Append '/' to bare-domain urls before query insertion.
        * Exceptions now inherit from RuntimeError.
        * Binary uploads + auth fix.
        * Bugfixes.
        
        
        0.10.1 (2012-01-23)
        +++++++++++++++++++
        
        * PYTHON 3 SUPPORT!
        * Dropped 2.5 Support. (*Backwards Incompatible*)
        
        0.10.0 (2012-01-21)
        +++++++++++++++++++
        
        * ``Response.content`` is now bytes-only. (*Backwards Incompatible*)
        * New ``Response.text`` is unicode-only.
        * If no ``Response.encoding`` is specified and ``chardet`` is available, ``Response.text`` will guess an encoding.
        * Default to ISO-8859-1 (Western) encoding for "text" subtypes.
        * Removal of `decode_unicode`. (*Backwards Incompatible*)
        * New multiple-hooks system.
        * New ``Response.register_hook`` for registering hooks within the pipeline.
        * ``Response.url`` is now Unicode.
        
        0.9.3 (2012-01-18)
        ++++++++++++++++++
        
        * SSL verify=False bugfix (apparent on windows machines).
        
        0.9.2 (2012-01-18)
        ++++++++++++++++++
        
        * Asynchronous async.send method.
        * Support for proper chunk streams with boundaries.
        * session argument for Session classes.
        * Print entire hook tracebacks, not just exception instance.
        * Fix response.iter_lines from pending next line.
        * Fix but in HTTP-digest auth w/ URI having query strings.
        * Fix in Event Hooks section.
        * Urllib3 update.
        
        
        0.9.1 (2012-01-06)
        ++++++++++++++++++
        
        * danger_mode for automatic Response.raise_for_status()
        * Response.iter_lines refactor
        
        0.9.0 (2011-12-28)
        ++++++++++++++++++
        
        * verify ssl is default.
        
        
        0.8.9 (2011-12-28)
        ++++++++++++++++++
        
        * Packaging fix.
        
        
        0.8.8 (2011-12-28)
        ++++++++++++++++++
        
        * SSL CERT VERIFICATION!
        * Release of Cerifi: Mozilla's cert list.
        * New 'verify' argument for SSL requests.
        * Urllib3 update.
        
        0.8.7 (2011-12-24)
        ++++++++++++++++++
        
        * iter_lines last-line truncation fix
        * Force safe_mode for async requests
        * Handle safe_mode exceptions more consistently
        * Fix iteration on null responses in safe_mode
        
        0.8.6 (2011-12-18)
        ++++++++++++++++++
        
        * Socket timeout fixes.
        * Proxy Authorization support.
        
        0.8.5 (2011-12-14)
        ++++++++++++++++++
        
        * Response.iter_lines!
        
        0.8.4 (2011-12-11)
        ++++++++++++++++++
        
        * Prefetch bugfix.
        * Added license to installed version.
        
        0.8.3 (2011-11-27)
        ++++++++++++++++++
        
        * Converted auth system to use simpler callable objects.
        * New session parameter to API methods.
        * Display full URL while logging.
        
        0.8.2 (2011-11-19)
        ++++++++++++++++++
        
        * New Unicode decoding system, based on over-ridable `Response.encoding`.
        * Proper URL slash-quote handling.
        * Cookies with ``[``, ``]``, and ``_`` allowed.
        
        0.8.1 (2011-11-15)
        ++++++++++++++++++
        
        * URL Request path fix
        * Proxy fix.
        * Timeouts fix.
        
        0.8.0 (2011-11-13)
        ++++++++++++++++++
        
        * Keep-alive support!
        * Complete removal of Urllib2
        * Complete removal of Poster
        * Complete removal of CookieJars
        * New ConnectionError raising
        * Safe_mode for error catching
        * prefetch parameter for request methods
        * OPTION method
        * Async pool size throttling
        * File uploads send real names
        * Vendored in urllib3
        
        0.7.6 (2011-11-07)
        ++++++++++++++++++
        
        * Digest authentication bugfix (attach query data to path)
        
        0.7.5 (2011-11-04)
        ++++++++++++++++++
        
        * Response.content = None if there was an invalid response.
        * Redirection auth handling.
        
        0.7.4 (2011-10-26)
        ++++++++++++++++++
        
        * Session Hooks fix.
        
        0.7.3 (2011-10-23)
        ++++++++++++++++++
        
        * Digest Auth fix.
        
        
        0.7.2 (2011-10-23)
        ++++++++++++++++++
        
        * PATCH Fix.
        
        
        0.7.1 (2011-10-23)
        ++++++++++++++++++
        
        * Move away from urllib2 authentication handling.
        * Fully Remove AuthManager, AuthObject, &c.
        * New tuple-based auth system with handler callbacks.
        
        
        0.7.0 (2011-10-22)
        ++++++++++++++++++
        
        * Sessions are now the primary interface.
        * Deprecated InvalidMethodException.
        * PATCH fix.
        * New config system (no more global settings).
        
        
        0.6.6 (2011-10-19)
        ++++++++++++++++++
        
        * Session parameter bugfix (params merging).
        
        
        0.6.5 (2011-10-18)
        ++++++++++++++++++
        
        * Offline (fast) test suite.
        * Session dictionary argument merging.
        
        
        0.6.4 (2011-10-13)
        ++++++++++++++++++
        
        * Automatic decoding of unicode, based on HTTP Headers.
        * New ``decode_unicode`` setting.
        * Removal of ``r.read/close`` methods.
        * New ``r.faw`` interface for advanced response usage.*
        * Automatic expansion of parameterized headers.
        
        
        0.6.3 (2011-10-13)
        ++++++++++++++++++
        
        * Beautiful ``requests.async`` module, for making async requests w/ gevent.
        
        
        0.6.2 (2011-10-09)
        ++++++++++++++++++
        
        * GET/HEAD obeys allow_redirects=False.
        
        
        0.6.1 (2011-08-20)
        ++++++++++++++++++
        
        * Enhanced status codes experience ``\o/``
        * Set a maximum number of redirects (``settings.max_redirects``)
        * Full Unicode URL support
        * Support for protocol-less redirects.
        * Allow for arbitrary request types.
        * Bugfixes
        
        
        0.6.0 (2011-08-17)
        ++++++++++++++++++
        
        * New callback hook system
        * New persistent sessions object and context manager
        * Transparent Dict-cookie handling
        * Status code reference object
        * Removed Response.cached
        * Added Response.request
        * All args are kwargs
        * Relative redirect support
        * HTTPError handling improvements
        * Improved https testing
        * Bugfixes
        
        
        0.5.1 (2011-07-23)
        ++++++++++++++++++
        
        * International Domain Name Support!
        * Access headers without fetching entire body (``read()``)
        * Use lists as dicts for parameters
        * Add Forced Basic Authentication
        * Forced Basic is default authentication type
        * ``python-requests.org`` default User-Agent header
        * CaseInsensitiveDict lower-case caching
        * Response.history bugfix
        
        
        0.5.0 (2011-06-21)
        ++++++++++++++++++
        
        * PATCH Support
        * Support for Proxies
        * HTTPBin Test Suite
        * Redirect Fixes
        * settings.verbose stream writing
        * Querystrings for all methods
        * URLErrors (Connection Refused, Timeout, Invalid URLs) are treated as explicitly raised
          ``r.requests.get('hwe://blah'); r.raise_for_status()``
        
        
        0.4.1 (2011-05-22)
        ++++++++++++++++++
        
        * Improved Redirection Handling
        * New 'allow_redirects' param for following non-GET/HEAD Redirects
        * Settings module refactoring
        
        
        0.4.0 (2011-05-15)
        ++++++++++++++++++
        
        * Response.history: list of redirected responses
        * Case-Insensitive Header Dictionaries!
        * Unicode URLs
        
        
        0.3.4 (2011-05-14)
        ++++++++++++++++++
        
        * Urllib2 HTTPAuthentication Recursion fix (Basic/Digest)
        * Internal Refactor
        * Bytes data upload Bugfix
        
        
        
        0.3.3 (2011-05-12)
        ++++++++++++++++++
        
        * Request timeouts
        * Unicode url-encoded data
        * Settings context manager and module
        
        
        0.3.2 (2011-04-15)
        ++++++++++++++++++
        
        * Automatic Decompression of GZip Encoded Content
        * AutoAuth Support for Tupled HTTP Auth
        
        
        0.3.1 (2011-04-01)
        ++++++++++++++++++
        
        * Cookie Changes
        * Response.read()
        * Poster fix
        
        
        0.3.0 (2011-02-25)
        ++++++++++++++++++
        
        * Automatic Authentication API Change
        * Smarter Query URL Parameterization
        * Allow file uploads and POST data together
        * New Authentication Manager System
            - Simpler Basic HTTP System
            - Supports all build-in urllib2 Auths
            - Allows for custom Auth Handlers
        
        
        0.2.4 (2011-02-19)
        ++++++++++++++++++
        
        * Python 2.5 Support
        * PyPy-c v1.4 Support
        * Auto-Authentication tests
        * Improved Request object constructor
        
        0.2.3 (2011-02-15)
        ++++++++++++++++++
        
        * New HTTPHandling Methods
            - Response.__nonzero__ (false if bad HTTP Status)
            - Response.ok (True if expected HTTP Status)
            - Response.error (Logged HTTPError if bad HTTP Status)
            - Response.raise_for_status() (Raises stored HTTPError)
        
        
        0.2.2 (2011-02-14)
        ++++++++++++++++++
        
        * Still handles request in the event of an HTTPError. (Issue #2)
        * Eventlet and Gevent Monkeypatch support.
        * Cookie Support (Issue #1)
        
        
        0.2.1 (2011-02-14)
        ++++++++++++++++++
        
        * Added file attribute to POST and PUT requests for multipart-encode file uploads.
        * Added Request.url attribute for context and redirects
        
        
        0.2.0 (2011-02-14)
        ++++++++++++++++++
        
        * Birth!
        
        
        0.0.1 (2011-02-13)
        ++++++++++++++++++
        
        * Frustration
        * Conception
        
        
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[security]
pyOpenSSL>=0.14
cryptography>=1.3.4
idna>=2.0.0

[socks]
PySocks>=1.5.6, !=1.5.7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   requests
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # -*- coding: utf-8 -*-

#   __
#  /__)  _  _     _   _ _/   _
# / (   (- (/ (/ (- _)  /  _)
#          /

"""
Requests HTTP library
~~~~~~~~~~~~~~~~~~~~~

Requests is an HTTP library, written in Python, for human beings. Basic GET
usage:

   >>> import requests
   >>> r = requests.get('https://www.python.org')
   >>> r.status_code
   200
   >>> 'Python is a programming language' in r.content
   True

... or POST:

   >>> payload = dict(key1='value1', key2='value2')
   >>> r = requests.post('http://httpbin.org/post', data=payload)
   >>> print(r.text)
   {
     ...
     "form": {
       "key2": "value2",
       "key1": "value1"
     },
     ...
   }

The other HTTP methods are supported - see `requests.api`. Full documentation
is at <http://python-requests.org>.

:copyright: (c) 2016 by Kenneth Reitz.
:license: Apache 2.0, see LICENSE for more details.
"""

__title__ = 'requests'
__version__ = '2.12.4'
__build__ = 0x021204
__author__ = 'Kenneth Reitz'
__license__ = 'Apache 2.0'
__copyright__ = 'Copyright 2016 Kenneth Reitz'

# Attempt to enable urllib3's SNI support, if possible
try:
    from .packages.urllib3.contrib import pyopenssl
    pyopenssl.inject_into_urllib3()
except ImportError:
    pass

import warnings

# urllib3's DependencyWarnings should be silenced.
from .packages.urllib3.exceptions import DependencyWarning
warnings.simplefilter('ignore', DependencyWarning)

from . import utils
from .models import Request, Response, PreparedRequest
from .api import request, get, head, post, patch, put, delete, options
from .sessions import session, Session
from .status_codes import codes
from .exceptions import (
    RequestException, Timeout, URLRequired,
    TooManyRedirects, HTTPError, ConnectionError,
    FileModeWarning, ConnectTimeout, ReadTimeout
)

# Set default logging handler to avoid "No handler found" warnings.
import logging
try:  # Python 2.7+
    from logging import NullHandler
except ImportError:
    class NullHandler(logging.Handler):
        def emit(self, record):
            pass

logging.getLogger(__name__).addHandler(NullHandler())

# FileModeWarnings go off per the default.
warnings.simplefilter('default', FileModeWarning, append=True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # -*- coding: utf-8 -*-

"""
requests._internal_utils
~~~~~~~~~~~~~~

Provides utility functions that are consumed internally by Requests
which depend on extremely few external helpers (such as compat)
"""

from .compat import is_py2, builtin_str, str


def to_native_string(string, encoding='ascii'):
    """Given a string object, regardless of type, returns a representation of
    that string in the native string type, encoding and decoding where
    necessary. This assumes ASCII unless told otherwise.
    """
    if isinstance(string, builtin_str):
        out = string
    else:
        if is_py2:
            out = string.encode(encoding)
        else:
            out = string.decode(encoding)

    return out


def unicode_is_ascii(u_string):
    """Determine if unicode string only contains ASCII characters.

    :param str u_string: unicode string to check. Must be unicode
        and not Python 2 `str`.
    :rtype: bool
    """
    assert isinstance(u_string, str)
    try:
        u_string.encode('ascii')
        return True
    except UnicodeEncodeError:
        return False
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # -*- coding: utf-8 -*-

"""
requests.adapters
~~~~~~~~~~~~~~~~~

This module contains the transport adapters that Requests uses to define
and maintain connections.
"""

import os.path
import socket

from .models import Response
from .packages.urllib3.poolmanager import PoolManager, proxy_from_url
from .packages.urllib3.response import HTTPResponse
from .packages.urllib3.util import Timeout as TimeoutSauce
from .packages.urllib3.util.retry import Retry
from .compat import urlparse, basestring
from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,
                    prepend_scheme_if_needed, get_auth_from_url, urldefragauth,
                    select_proxy, to_native_string)
from .structures import CaseInsensitiveDict
from .packages.urllib3.exceptions import ClosedPoolError
from .packages.urllib3.exceptions import ConnectTimeoutError
from .packages.urllib3.exceptions import HTTPError as _HTTPError
from .packages.urllib3.exceptions import MaxRetryError
from .packages.urllib3.exceptions import NewConnectionError
from .packages.urllib3.exceptions import ProxyError as _ProxyError
from .packages.urllib3.exceptions import ProtocolError
from .packages.urllib3.exceptions import ReadTimeoutError
from .packages.urllib3.exceptions import SSLError as _SSLError
from .packages.urllib3.exceptions import ResponseError
from .cookies import extract_cookies_to_jar
from .exceptions import (ConnectionError, ConnectTimeout, ReadTimeout, SSLError,
                         ProxyError, RetryError, InvalidSchema)
from .auth import _basic_auth_str

try:
    from .packages.urllib3.contrib.socks import SOCKSProxyManager
except ImportError:
    def SOCKSProxyManager(*args, **kwargs):
        raise InvalidSchema("Missing dependencies for SOCKS support.")

DEFAULT_POOLBLOCK = False
DEFAULT_POOLSIZE = 10
DEFAULT_RETRIES = 0
DEFAULT_POOL_TIMEOUT = None


class BaseAdapter(object):
    """The Base Transport Adapter"""

    def __init__(self):
        super(BaseAdapter, self).__init__()

    def send(self, request, stream=False, timeout=None, verify=True,
             cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param verify: (optional) Whether to verify SSL certificates.
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        """
        raise NotImplementedError

    def close(self):
        """Cleans up adapter specific items."""
        raise NotImplementedError


class HTTPAdapter(BaseAdapter):
    """The built-in HTTP Adapter for urllib3.

    Provides a general-case interface for Requests sessions to contact HTTP and
    HTTPS urls by implementing the Transport Adapter interface. This class will
    usually be created by the :class:`Session <Session>` class under the
    covers.

    :param pool_connections: The number of urllib3 connection pools to cache.
    :param pool_maxsize: The maximum number of connections to save in the pool.
    :param max_retries: The maximum number of retries each connection
        should attempt. Note, this applies only to failed DNS lookups, socket
        connections and connection timeouts, never to requests where data has
        made it to the server. By default, Requests does not retry failed
        connections. If you need granular control over the conditions under
        which we retry a request, import urllib3's ``Retry`` class and pass
        that instead.
    :param pool_block: Whether the connection pool should block for connections.

    Usage::

      >>> import requests
      >>> s = requests.Session()
      >>> a = requests.adapters.HTTPAdapter(max_retries=3)
      >>> s.mount('http://', a)
    """
    __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxsize',
                 '_pool_block']

    def __init__(self, pool_connections=DEFAULT_POOLSIZE,
                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,
                 pool_block=DEFAULT_POOLBLOCK):
        if max_retries == DEFAULT_RETRIES:
            self.max_retries = Retry(0, read=False)
        else:
            self.max_retries = Retry.from_int(max_retries)
        self.config = {}
        self.proxy_manager = {}

        super(HTTPAdapter, self).__init__()

        self._pool_connections = pool_connections
        self._pool_maxsize = pool_maxsize
        self._pool_block = pool_block

        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)

    def __getstate__(self):
        return dict((attr, getattr(self, attr, None)) for attr in
                    self.__attrs__)

    def __setstate__(self, state):
        # Can't handle by adding 'proxy_manager' to self.__attrs__ because
        # self.poolmanager uses a lambda function, which isn't pickleable.
        self.proxy_manager = {}
        self.config = {}

        for attr, value in state.items():
            setattr(self, attr, value)

        self.init_poolmanager(self._pool_connections, self._pool_maxsize,
                              block=self._pool_block)

    def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs):
        """Initializes a urllib3 PoolManager.

        This method should not be called from user code, and is only
        exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param connections: The number of urllib3 connection pools to cache.
        :param maxsize: The maximum number of connections to save in the pool.
        :param block: Block when no free connections are available.
        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
        """
        # save these values for pickling
        self._pool_connections = connections
        self._pool_maxsize = maxsize
        self._pool_block = block

        self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,
                                       block=block, strict=True, **pool_kwargs)

    def proxy_manager_for(self, proxy, **proxy_kwargs):
        """Return urllib3 ProxyManager for the given proxy.

        This method should not be called from user code, and is only
        exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param proxy: The proxy to return a urllib3 ProxyManager for.
        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.
        :returns: ProxyManager
        :rtype: requests.packages.urllib3.ProxyManager
        """
        if proxy in self.proxy_manager:
            manager = self.proxy_manager[proxy]
        elif proxy.lower().startswith('socks'):
            username, password = get_auth_from_url(proxy)
            manager = self.proxy_manager[proxy] = SOCKSProxyManager(
                proxy,
                username=username,
                password=password,
                num_pools=self._pool_connections,
                maxsize=self._pool_maxsize,
                block=self._pool_block,
                **proxy_kwargs
            )
        else:
            proxy_headers = self.proxy_headers(proxy)
            manager = self.proxy_manager[proxy] = proxy_from_url(
                proxy,
                proxy_headers=proxy_headers,
                num_pools=self._pool_connections,
                maxsize=self._pool_maxsize,
                block=self._pool_block,
                **proxy_kwargs)

        return manager

    def cert_verify(self, conn, url, verify, cert):
        """Verify a SSL certificate. This method should not be called from user
        code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param conn: The urllib3 connection object associated with the cert.
        :param url: The requested URL.
        :param verify: Whether we should actually verify the certificate.
        :param cert: The SSL certificate to verify.
        """
        if url.lower().startswith('https') and verify:

            cert_loc = None

            # Allow self-specified cert location.
            if verify is not True:
                cert_loc = verify

            if not cert_loc:
                cert_loc = DEFAULT_CA_BUNDLE_PATH

            if not cert_loc:
                raise Exception("Could not find a suitable SSL CA certificate bundle.")

            conn.cert_reqs = 'CERT_REQUIRED'

            if not os.path.isdir(cert_loc):
                conn.ca_certs = cert_loc
            else:
                conn.ca_cert_dir = cert_loc
        else:
            conn.cert_reqs = 'CERT_NONE'
            conn.ca_certs = None
            conn.ca_cert_dir = None

        if cert:
            if not isinstance(cert, basestring):
                conn.cert_file = cert[0]
                conn.key_file = cert[1]
            else:
                conn.cert_file = cert

    def build_response(self, req, resp):
        """Builds a :class:`Response <requests.Response>` object from a urllib3
        response. This should not be called from user code, and is only exposed
        for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`

        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.
        :param resp: The urllib3 response object.
        :rtype: requests.Response
        """
        response = Response()

        # Fallback to None if there's no status_code, for whatever reason.
        response.status_code = getattr(resp, 'status', None)

        # Make headers case-insensitive.
        response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))

        # Set encoding.
        response.encoding = get_encoding_from_headers(response.headers)
        response.raw = resp
        response.reason = response.raw.reason

        if isinstance(req.url, bytes):
            response.url = req.url.decode('utf-8')
        else:
            response.url = req.url

        # Add new cookies from the server.
        extract_cookies_to_jar(response.cookies, req, resp)

        # Give the Response some context.
        response.request = req
        response.connection = self

        return response

    def get_connection(self, url, proxies=None):
        """Returns a urllib3 connection for the given URL. This should not be
        called from user code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param url: The URL to connect to.
        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
        :rtype: requests.packages.urllib3.ConnectionPool
        """
        proxy = select_proxy(url, proxies)

        if proxy:
            proxy = prepend_scheme_if_needed(proxy, 'http')
            proxy_manager = self.proxy_manager_for(proxy)
            conn = proxy_manager.connection_from_url(url)
        else:
            # Only scheme should be lower case
            parsed = urlparse(url)
            url = parsed.geturl()
            conn = self.poolmanager.connection_from_url(url)

        return conn

    def close(self):
        """Disposes of any internal state.

        Currently, this closes the PoolManager and any active ProxyManager,
        which closes any pooled connections.
        """
        self.poolmanager.clear()
        for proxy in self.proxy_manager.values():
            proxy.clear()

    def request_url(self, request, proxies):
        """Obtain the url to use when making the final request.

        If the message is being sent through a HTTP proxy, the full URL has to
        be used. Otherwise, we should only use the path portion of the URL.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.
        :rtype: str
        """
        proxy = select_proxy(request.url, proxies)
        scheme = urlparse(request.url).scheme

        is_proxied_http_request = (proxy and scheme != 'https')
        using_socks_proxy = False
        if proxy:
            proxy_scheme = urlparse(proxy).scheme.lower()
            using_socks_proxy = proxy_scheme.startswith('socks')

        url = request.path_url
        if is_proxied_http_request and not using_socks_proxy:
            url = urldefragauth(request.url)

        return url

    def add_headers(self, request, **kwargs):
        """Add any headers needed by the connection. As of v2.0 this does
        nothing by default, but is left for overriding by users that subclass
        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.
        :param kwargs: The keyword arguments from the call to send().
        """
        pass

    def proxy_headers(self, proxy):
        """Returns a dictionary of the headers to add to any request sent
        through a proxy. This works with urllib3 magic to ensure that they are
        correctly sent to the proxy, rather than in a tunnelled request if
        CONNECT is being used.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param proxies: The url of the proxy being used for this request.
        :rtype: dict
        """
        headers = {}
        username, password = get_auth_from_url(proxy)

        if username:
            headers['Proxy-Authorization'] = _basic_auth_str(username,
                                                             password)

        return headers

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param verify: (optional) Whether to verify SSL certificates.
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """

        conn = self.get_connection(request.url, proxies)

        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request)

        chunked = not (request.body is None or 'Content-Length' in request.headers)

        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {0}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)

        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool

                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)

                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)

                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)

                    low_conn.endheaders()

                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')

                    # Receive the response from the server
                    try:
                        # For Python 2.7+ versions, use buffering of HTTP
                        # responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 2.6 versions and back
                        r = low_conn.getresponse()

                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise

        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)

        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)

            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)

            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)

            raise ConnectionError(e, request=request)

        except ClosedPoolError as e:
            raise ConnectionError(e, request=request)

        except _ProxyError as e:
            raise ProxyError(e)

        except (_SSLError, _HTTPError) as e:
            if isinstance(e, _SSLError):
                raise SSLError(e, request=request)
            elif isinstance(e, ReadTimeoutError):
                raise ReadTimeout(e, request=request)
            else:
                raise

        return self.build_response(request, resp)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
requests.certs
~~~~~~~~~~~~~~

This module returns the preferred default CA certificate bundle.

If you are packaging Requests, e.g., for a Linux distribution or a managed
environment, you can change the definition of where() to return a separately
packaged CA bundle.
"""
import os.path

try:
    from certifi import where
except ImportError:
    def where():
        """Return the preferred certificate bundle."""
        # On Debian systems use ca-certificates
        return '/etc/ssl/certs/ca-certificates.crt'

if __name__ == '__main__':
    print(where())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # -*- coding: utf-8 -*-

"""
requests.api
~~~~~~~~~~~~

This module implements the Requests API.

:copyright: (c) 2012 by Kenneth Reitz.
:license: Apache2, see LICENSE for more details.
"""

from . import sessions


def request(method, url, **kwargs):
    """Constructs and sends a :class:`Request <Request>`.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.
        ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``
        or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content-type'`` is a string
        defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers
        to add for the file.
    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.
    :param timeout: (optional) How long to wait for the server to send data
        before giving up, as a float, or a :ref:`(connect timeout, read
        timeout) <timeouts>` tuple.
    :type timeout: float or tuple
    :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection.
    :type allow_redirects: bool
    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
    :param verify: (optional) whether the SSL cert will be verified. A CA_BUNDLE path can also be provided. Defaults to ``True``.
    :param stream: (optional) if ``False``, the response content will be immediately downloaded.
    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response

    Usage::

      >>> import requests
      >>> req = requests.request('GET', 'http://httpbin.org/get')
      <Response [200]>
    """

    # By using the 'with' statement we are sure the session is closed, thus we
    # avoid leaving sockets open which can trigger a ResourceWarning in some
    # cases, and look like a memory leak in others.
    with sessions.Session() as session:
        return session.request(method=method, url=url, **kwargs)


def get(url, params=None, **kwargs):
    """Sends a GET request.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    kwargs.setdefault('allow_redirects', True)
    return request('get', url, params=params, **kwargs)


def options(url, **kwargs):
    """Sends a OPTIONS request.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    kwargs.setdefault('allow_redirects', True)
    return request('options', url, **kwargs)


def head(url, **kwargs):
    """Sends a HEAD request.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    kwargs.setdefault('allow_redirects', False)
    return request('head', url, **kwargs)


def post(url, data=None, json=None, **kwargs):
    """Sends a POST request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    return request('post', url, data=data, json=json, **kwargs)


def put(url, data=None, **kwargs):
    """Sends a PUT request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    return request('put', url, data=data, **kwargs)


def patch(url, data=None, **kwargs):
    """Sends a PATCH request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    return request('patch', url,  data=data, **kwargs)


def delete(url, **kwargs):
    """Sends a DELETE request.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """

    return request('delete', url, **kwargs)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # -*- coding: utf-8 -*-

"""
requests.auth
~~~~~~~~~~~~~

This module contains the authentication handlers for Requests.
"""

import os
import re
import time
import hashlib
import threading
import warnings

from base64 import b64encode

from .compat import urlparse, str, basestring
from .cookies import extract_cookies_to_jar
from ._internal_utils import to_native_string
from .utils import parse_dict_header
from .status_codes import codes

CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'
CONTENT_TYPE_MULTI_PART = 'multipart/form-data'


def _basic_auth_str(username, password):
    """Returns a Basic Auth string."""

    # "I want us to put a big-ol' comment on top of it that
    # says that this behaviour is dumb but we need to preserve
    # it because people are relying on it."
    #    - Lukasa
    #
    # These are here solely to maintain backwards compatibility
    # for things like ints. This will be removed in 3.0.0.
    if not isinstance(username, basestring):
        warnings.warn(
            "Non-string usernames will no longer be supported in Requests "
            "3.0.0. Please convert the object you've passed in ({!r}) to "
            "a string or bytes object in the near future to avoid "
            "problems.".format(username),
            category=DeprecationWarning,
        )
        username = str(username)

    if not isinstance(password, basestring):
        warnings.warn(
            "Non-string passwords will no longer be supported in Requests "
            "3.0.0. Please convert the object you've passed in ({!r}) to "
            "a string or bytes object in the near future to avoid "
            "problems.".format(password),
            category=DeprecationWarning,
        )
        password = str(password)
    # -- End Removal --

    if isinstance(username, str):
        username = username.encode('latin1')

    if isinstance(password, str):
        password = password.encode('latin1')

    authstr = 'Basic ' + to_native_string(
        b64encode(b':'.join((username, password))).strip()
    )

    return authstr


class AuthBase(object):
    """Base class that all auth implementations derive from"""

    def __call__(self, r):
        raise NotImplementedError('Auth hooks must be callable.')


class HTTPBasicAuth(AuthBase):
    """Attaches HTTP Basic Authentication to the given Request object."""

    def __init__(self, username, password):
        self.username = username
        self.password = password

    def __eq__(self, other):
        return all([
            self.username == getattr(other, 'username', None),
            self.password == getattr(other, 'password', None)
        ])

    def __ne__(self, other):
        return not self == other

    def __call__(self, r):
        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)
        return r


class HTTPProxyAuth(HTTPBasicAuth):
    """Attaches HTTP Proxy Authentication to a given Request object."""

    def __call__(self, r):
        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)
        return r


class HTTPDigestAuth(AuthBase):
    """Attaches HTTP Digest Authentication to the given Request object."""

    def __init__(self, username, password):
        self.username = username
        self.password = password
        # Keep state in per-thread local storage
        self._thread_local = threading.local()

    def init_per_thread_state(self):
        # Ensure state is initialized just once per-thread
        if not hasattr(self._thread_local, 'init'):
            self._thread_local.init = True
            self._thread_local.last_nonce = ''
            self._thread_local.nonce_count = 0
            self._thread_local.chal = {}
            self._thread_local.pos = None
            self._thread_local.num_401_calls = None

    def build_digest_header(self, method, url):
        """
        :rtype: str
        """

        realm = self._thread_local.chal['realm']
        nonce = self._thread_local.chal['nonce']
        qop = self._thread_local.chal.get('qop')
        algorithm = self._thread_local.chal.get('algorithm')
        opaque = self._thread_local.chal.get('opaque')
        hash_utf8 = None

        if algorithm is None:
            _algorithm = 'MD5'
        else:
            _algorithm = algorithm.upper()
        # lambdas assume digest modules are imported at the top level
        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':
            def md5_utf8(x):
                if isinstance(x, str):
                    x = x.encode('utf-8')
                return hashlib.md5(x).hexdigest()
            hash_utf8 = md5_utf8
        elif _algorithm == 'SHA':
            def sha_utf8(x):
                if isinstance(x, str):
                    x = x.encode('utf-8')
                return hashlib.sha1(x).hexdigest()
            hash_utf8 = sha_utf8

        KD = lambda s, d: hash_utf8("%s:%s" % (s, d))

        if hash_utf8 is None:
            return None

        # XXX not implemented yet
        entdig = None
        p_parsed = urlparse(url)
        #: path is request-uri defined in RFC 2616 which should not be empty
        path = p_parsed.path or "/"
        if p_parsed.query:
            path += '?' + p_parsed.query

        A1 = '%s:%s:%s' % (self.username, realm, self.password)
        A2 = '%s:%s' % (method, path)

        HA1 = hash_utf8(A1)
        HA2 = hash_utf8(A2)

        if nonce == self._thread_local.last_nonce:
            self._thread_local.nonce_count += 1
        else:
            self._thread_local.nonce_count = 1
        ncvalue = '%08x' % self._thread_local.nonce_count
        s = str(self._thread_local.nonce_count).encode('utf-8')
        s += nonce.encode('utf-8')
        s += time.ctime().encode('utf-8')
        s += os.urandom(8)

        cnonce = (hashlib.sha1(s).hexdigest()[:16])
        if _algorithm == 'MD5-SESS':
            HA1 = hash_utf8('%s:%s:%s' % (HA1, nonce, cnonce))

        if not qop:
            respdig = KD(HA1, "%s:%s" % (nonce, HA2))
        elif qop == 'auth' or 'auth' in qop.split(','):
            noncebit = "%s:%s:%s:%s:%s" % (
                nonce, ncvalue, cnonce, 'auth', HA2
                )
            respdig = KD(HA1, noncebit)
        else:
            # XXX handle auth-int.
            return None

        self._thread_local.last_nonce = nonce

        # XXX should the partial digests be encoded too?
        base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
               'response="%s"' % (self.username, realm, nonce, path, respdig)
        if opaque:
            base += ', opaque="%s"' % opaque
        if algorithm:
            base += ', algorithm="%s"' % algorithm
        if entdig:
            base += ', digest="%s"' % entdig
        if qop:
            base += ', qop="auth", nc=%s, cnonce="%s"' % (ncvalue, cnonce)

        return 'Digest %s' % (base)

    def handle_redirect(self, r, **kwargs):
        """Reset num_401_calls counter on redirects."""
        if r.is_redirect:
            self._thread_local.num_401_calls = 1

    def handle_401(self, r, **kwargs):
        """
        Takes the given response and tries digest-auth, if needed.

        :rtype: requests.Response
        """

        if self._thread_local.pos is not None:
            # Rewind the file position indicator of the body to where
            # it was to resend the request.
            r.request.body.seek(self._thread_local.pos)
        s_auth = r.headers.get('www-authenticate', '')

        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:

            self._thread_local.num_401_calls += 1
            pat = re.compile(r'digest ', flags=re.IGNORECASE)
            self._thread_local.chal = parse_dict_header(pat.sub('', s_auth, count=1))

            # Consume content and release the original connection
            # to allow our new request to reuse the same one.
            r.content
            r.close()
            prep = r.request.copy()
            extract_cookies_to_jar(prep._cookies, r.request, r.raw)
            prep.prepare_cookies(prep._cookies)

            prep.headers['Authorization'] = self.build_digest_header(
                prep.method, prep.url)
            _r = r.connection.send(prep, **kwargs)
            _r.history.append(r)
            _r.request = prep

            return _r

        self._thread_local.num_401_calls = 1
        return r

    def __call__(self, r):
        # Initialize per-thread state, if needed
        self.init_per_thread_state()
        # If we have a saved nonce, skip the 401
        if self._thread_local.last_nonce:
            r.headers['Authorization'] = self.build_digest_header(r.method, r.url)
        try:
            self._thread_local.pos = r.body.tell()
        except AttributeError:
            # In the case of HTTPDigestAuth being reused and the body of
            # the previous request was a file-like object, pos has the
            # file position of the previous body. Ensure it's set to
            # None.
            self._thread_local.pos = None
        r.register_hook('response', self.handle_401)
        r.register_hook('response', self.handle_redirect)
        self._thread_local.num_401_calls = 1

        return r

    def __eq__(self, other):
        return all([
            self.username == getattr(other, 'username', None),
            self.password == getattr(other, 'password', None)
        ])

    def __ne__(self, other):
        return not self == other
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # -*- coding: utf-8 -*-

"""
requests.compat
~~~~~~~~~~~~~~~

This module handles import compatibility issues between Python 2 and
Python 3.
"""

from .packages import chardet

import sys

# -------
# Pythons
# -------

# Syntax sugar.
_ver = sys.version_info

#: Python 2.x?
is_py2 = (_ver[0] == 2)

#: Python 3.x?
is_py3 = (_ver[0] == 3)

try:
    import simplejson as json
except (ImportError, SyntaxError):
    # simplejson does not support Python 3.2, it throws a SyntaxError
    # because of u'...' Unicode literals.
    import json

# ---------
# Specifics
# ---------

if is_py2:
    from urllib import quote, unquote, quote_plus, unquote_plus, urlencode, getproxies, proxy_bypass
    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag
    from urllib2 import parse_http_list
    import cookielib
    from Cookie import Morsel
    from StringIO import StringIO
    from .packages.urllib3.packages.ordered_dict import OrderedDict
    from httplib import IncompleteRead

    builtin_str = str
    bytes = str
    str = unicode
    basestring = basestring
    numeric_types = (int, long, float)
    integer_types = (int, long)

elif is_py3:
    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag
    from urllib.request import parse_http_list, getproxies, proxy_bypass
    from http import cookiejar as cookielib
    from http.cookies import Morsel
    from io import StringIO
    from collections import OrderedDict
    from http.client import IncompleteRead

    builtin_str = str
    str = str
    bytes = bytes
    basestring = (str, bytes)
    numeric_types = (int, float)
    integer_types = (int,)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # -*- coding: utf-8 -*-

"""
requests.cookies
~~~~~~~~~~~~~~~~

Compatibility code to be able to use `cookielib.CookieJar` with requests.

requests.utils imports from here, so be careful with imports.
"""

import copy
import time
import calendar
import collections

from ._internal_utils import to_native_string
from .compat import cookielib, urlparse, urlunparse, Morsel

try:
    import threading
    # grr, pyflakes: this fixes "redefinition of unused 'threading'"
    threading
except ImportError:
    import dummy_threading as threading


class MockRequest(object):
    """Wraps a `requests.Request` to mimic a `urllib2.Request`.

    The code in `cookielib.CookieJar` expects this interface in order to correctly
    manage cookie policies, i.e., determine whether a cookie can be set, given the
    domains of the request and the cookie.

    The original request object is read-only. The client is responsible for collecting
    the new headers via `get_new_headers()` and interpreting them appropriately. You
    probably want `get_cookie_header`, defined below.
    """

    def __init__(self, request):
        self._r = request
        self._new_headers = {}
        self.type = urlparse(self._r.url).scheme

    def get_type(self):
        return self.type

    def get_host(self):
        return urlparse(self._r.url).netloc

    def get_origin_req_host(self):
        return self.get_host()

    def get_full_url(self):
        # Only return the response's URL if the user hadn't set the Host
        # header
        if not self._r.headers.get('Host'):
            return self._r.url
        # If they did set it, retrieve it and reconstruct the expected domain
        host = to_native_string(self._r.headers['Host'], encoding='utf-8')
        parsed = urlparse(self._r.url)
        # Reconstruct the URL as we expect it
        return urlunparse([
            parsed.scheme, host, parsed.path, parsed.params, parsed.query,
            parsed.fragment
        ])

    def is_unverifiable(self):
        return True

    def has_header(self, name):
        return name in self._r.headers or name in self._new_headers

    def get_header(self, name, default=None):
        return self._r.headers.get(name, self._new_headers.get(name, default))

    def add_header(self, key, val):
        """cookielib has no legitimate use for this method; add it back if you find one."""
        raise NotImplementedError("Cookie headers should be added with add_unredirected_header()")

    def add_unredirected_header(self, name, value):
        self._new_headers[name] = value

    def get_new_headers(self):
        return self._new_headers

    @property
    def unverifiable(self):
        return self.is_unverifiable()

    @property
    def origin_req_host(self):
        return self.get_origin_req_host()

    @property
    def host(self):
        return self.get_host()


class MockResponse(object):
    """Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.

    ...what? Basically, expose the parsed HTTP headers from the server response
    the way `cookielib` expects to see them.
    """

    def __init__(self, headers):
        """Make a MockResponse for `cookielib` to read.

        :param headers: a httplib.HTTPMessage or analogous carrying the headers
        """
        self._headers = headers

    def info(self):
        return self._headers

    def getheaders(self, name):
        self._headers.getheaders(name)


def extract_cookies_to_jar(jar, request, response):
    """Extract the cookies from the response into a CookieJar.

    :param jar: cookielib.CookieJar (not necessarily a RequestsCookieJar)
    :param request: our own requests.Request object
    :param response: urllib3.HTTPResponse object
    """
    if not (hasattr(response, '_original_response') and
            response._original_response):
        return
    # the _original_response field is the wrapped httplib.HTTPResponse object,
    req = MockRequest(request)
    # pull out the HTTPMessage with the headers and put it in the mock:
    res = MockResponse(response._original_response.msg)
    jar.extract_cookies(res, req)


def get_cookie_header(jar, request):
    """
    Produce an appropriate Cookie header string to be sent with `request`, or None.

    :rtype: str
    """
    r = MockRequest(request)
    jar.add_cookie_header(r)
    return r.get_new_headers().get('Cookie')


def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
    """Unsets a cookie by name, by default over all domains and paths.

    Wraps CookieJar.clear(), is O(n).
    """
    clearables = []
    for cookie in cookiejar:
        if cookie.name != name:
            continue
        if domain is not None and domain != cookie.domain:
            continue
        if path is not None and path != cookie.path:
            continue
        clearables.append((cookie.domain, cookie.path, cookie.name))

    for domain, path, name in clearables:
        cookiejar.clear(domain, path, name)


class CookieConflictError(RuntimeError):
    """There are two cookies that meet the criteria specified in the cookie jar.
    Use .get and .set and include domain and path args in order to be more specific.
    """


class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
    """Compatibility class; is a cookielib.CookieJar, but exposes a dict
    interface.

    This is the CookieJar we create by default for requests and sessions that
    don't specify one, since some clients may expect response.cookies and
    session.cookies to support dict operations.

    Requests does not use the dict interface internally; it's just for
    compatibility with external client code. All requests code should work
    out of the box with externally provided instances of ``CookieJar``, e.g.
    ``LWPCookieJar`` and ``FileCookieJar``.

    Unlike a regular CookieJar, this class is pickleable.

    .. warning:: dictionary operations that are normally O(1) may be O(n).
    """

    def get(self, name, default=None, domain=None, path=None):
        """Dict-like get() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains.

        .. warning:: operation is O(n), not O(1).
        """
        try:
            return self._find_no_duplicates(name, domain, path)
        except KeyError:
            return default

    def set(self, name, value, **kwargs):
        """Dict-like set() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains.
        """
        # support client code that unsets cookies by assignment of a None value:
        if value is None:
            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))
            return

        if isinstance(value, Morsel):
            c = morsel_to_cookie(value)
        else:
            c = create_cookie(name, value, **kwargs)
        self.set_cookie(c)
        return c

    def iterkeys(self):
        """Dict-like iterkeys() that returns an iterator of names of cookies
        from the jar.

        .. seealso:: itervalues() and iteritems().
        """
        for cookie in iter(self):
            yield cookie.name

    def keys(self):
        """Dict-like keys() that returns a list of names of cookies from the
        jar.

        .. seealso:: values() and items().
        """
        return list(self.iterkeys())

    def itervalues(self):
        """Dict-like itervalues() that returns an iterator of values of cookies
        from the jar.

        .. seealso:: iterkeys() and iteritems().
        """
        for cookie in iter(self):
            yield cookie.value

    def values(self):
        """Dict-like values() that returns a list of values of cookies from the
        jar.

        .. seealso:: keys() and items().
        """
        return list(self.itervalues())

    def iteritems(self):
        """Dict-like iteritems() that returns an iterator of name-value tuples
        from the jar.

        .. seealso:: iterkeys() and itervalues().
        """
        for cookie in iter(self):
            yield cookie.name, cookie.value

    def items(self):
        """Dict-like items() that returns a list of name-value tuples from the
        jar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a
        vanilla python dict of key value pairs.

        .. seealso:: keys() and values().
        """
        return list(self.iteritems())

    def list_domains(self):
        """Utility method to list all the domains in the jar."""
        domains = []
        for cookie in iter(self):
            if cookie.domain not in domains:
                domains.append(cookie.domain)
        return domains

    def list_paths(self):
        """Utility method to list all the paths in the jar."""
        paths = []
        for cookie in iter(self):
            if cookie.path not in paths:
                paths.append(cookie.path)
        return paths

    def multiple_domains(self):
        """Returns True if there are multiple domains in the jar.
        Returns False otherwise.

        :rtype: bool
        """
        domains = []
        for cookie in iter(self):
            if cookie.domain is not None and cookie.domain in domains:
                return True
            domains.append(cookie.domain)
        return False  # there is only one domain in jar

    def get_dict(self, domain=None, path=None):
        """Takes as an argument an optional domain and path and returns a plain
        old Python dict of name-value pairs of cookies that meet the
        requirements.

        :rtype: dict
        """
        dictionary = {}
        for cookie in iter(self):
            if (domain is None or cookie.domain == domain) and (path is None
                                                or cookie.path == path):
                dictionary[cookie.name] = cookie.value
        return dictionary

    def __contains__(self, name):
        try:
            return super(RequestsCookieJar, self).__contains__(name)
        except CookieConflictError:
            return True

    def __getitem__(self, name):
        """Dict-like __getitem__() for compatibility with client code. Throws
        exception if there are more than one cookie with name. In that case,
        use the more explicit get() method instead.

        .. warning:: operation is O(n), not O(1).
        """
        return self._find_no_duplicates(name)

    def __setitem__(self, name, value):
        """Dict-like __setitem__ for compatibility with client code. Throws
        exception if there is already a cookie of that name in the jar. In that
        case, use the more explicit set() method instead.
        """
        self.set(name, value)

    def __delitem__(self, name):
        """Deletes a cookie given a name. Wraps ``cookielib.CookieJar``'s
        ``remove_cookie_by_name()``.
        """
        remove_cookie_by_name(self, name)

    def set_cookie(self, cookie, *args, **kwargs):
        if hasattr(cookie.value, 'startswith') and cookie.value.startswith('"') and cookie.value.endswith('"'):
            cookie.value = cookie.value.replace('\\"', '')
        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)

    def update(self, other):
        """Updates this jar with cookies from another CookieJar or dict-like"""
        if isinstance(other, cookielib.CookieJar):
            for cookie in other:
                self.set_cookie(copy.copy(cookie))
        else:
            super(RequestsCookieJar, self).update(other)

    def _find(self, name, domain=None, path=None):
        """Requests uses this method internally to get cookie values.

        If there are conflicting cookies, _find arbitrarily chooses one.
        See _find_no_duplicates if you want an exception thrown if there are
        conflicting cookies.

        :param name: a string containing name of cookie
        :param domain: (optional) string containing domain of cookie
        :param path: (optional) string containing path of cookie
        :return: cookie.value
        """
        for cookie in iter(self):
            if cookie.name == name:
                if domain is None or cookie.domain == domain:
                    if path is None or cookie.path == path:
                        return cookie.value

        raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))

    def _find_no_duplicates(self, name, domain=None, path=None):
        """Both ``__get_item__`` and ``get`` call this function: it's never
        used elsewhere in Requests.

        :param name: a string containing name of cookie
        :param domain: (optional) string containing domain of cookie
        :param path: (optional) string containing path of cookie
        :raises KeyError: if cookie is not found
        :raises CookieConflictError: if there are multiple cookies
            that match name and optionally domain and path
        :return: cookie.value
        """
        toReturn = None
        for cookie in iter(self):
            if cookie.name == name:
                if domain is None or cookie.domain == domain:
                    if path is None or cookie.path == path:
                        if toReturn is not None:  # if there are multiple cookies that meet passed in criteria
                            raise CookieConflictError('There are multiple cookies with name, %r' % (name))
                        toReturn = cookie.value  # we will eventually return this as long as no cookie conflict

        if toReturn:
            return toReturn
        raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))

    def __getstate__(self):
        """Unlike a normal CookieJar, this class is pickleable."""
        state = self.__dict__.copy()
        # remove the unpickleable RLock object
        state.pop('_cookies_lock')
        return state

    def __setstate__(self, state):
        """Unlike a normal CookieJar, this class is pickleable."""
        self.__dict__.update(state)
        if '_cookies_lock' not in self.__dict__:
            self._cookies_lock = threading.RLock()

    def copy(self):
        """Return a copy of this RequestsCookieJar."""
        new_cj = RequestsCookieJar()
        new_cj.update(self)
        return new_cj


def _copy_cookie_jar(jar):
    if jar is None:
        return None

    if hasattr(jar, 'copy'):
        # We're dealing with an instance of RequestsCookieJar
        return jar.copy()
    # We're dealing with a generic CookieJar instance
    new_jar = copy.copy(jar)
    new_jar.clear()
    for cookie in jar:
        new_jar.set_cookie(copy.copy(cookie))
    return new_jar


def create_cookie(name, value, **kwargs):
    """Make a cookie from underspecified parameters.

    By default, the pair of `name` and `value` will be set for the domain ''
    and sent on every request (this is sometimes called a "supercookie").
    """
    result = dict(
        version=0,
        name=name,
        value=value,
        port=None,
        domain='',
        path='/',
        secure=False,
        expires=None,
        discard=True,
        comment=None,
        comment_url=None,
        rest={'HttpOnly': None},
        rfc2109=False,)

    badargs = set(kwargs) - set(result)
    if badargs:
        err = 'create_cookie() got unexpected keyword arguments: %s'
        raise TypeError(err % list(badargs))

    result.update(kwargs)
    result['port_specified'] = bool(result['port'])
    result['domain_specified'] = bool(result['domain'])
    result['domain_initial_dot'] = result['domain'].startswith('.')
    result['path_specified'] = bool(result['path'])

    return cookielib.Cookie(**result)


def morsel_to_cookie(morsel):
    """Convert a Morsel object into a Cookie containing the one k/v pair."""

    expires = None
    if morsel['max-age']:
        try:
            expires = int(time.time() + int(morsel['max-age']))
        except ValueError:
            raise TypeError('max-age: %s must be integer' % morsel['max-age'])
    elif morsel['expires']:
        time_template = '%a, %d-%b-%Y %H:%M:%S GMT'
        expires = calendar.timegm(
            time.strptime(morsel['expires'], time_template)
        )
    return create_cookie(
        comment=morsel['comment'],
        comment_url=bool(morsel['comment']),
        discard=False,
        domain=morsel['domain'],
        expires=expires,
        name=morsel.key,
        path=morsel['path'],
        port=None,
        rest={'HttpOnly': morsel['httponly']},
        rfc2109=False,
        secure=bool(morsel['secure']),
        value=morsel.value,
        version=morsel['version'] or 0,
    )


def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
    """Returns a CookieJar from a key/value dictionary.

    :param cookie_dict: Dict of key/values to insert into CookieJar.
    :param cookiejar: (optional) A cookiejar to add the cookies to.
    :param overwrite: (optional) If False, will not replace cookies
        already in the jar with new ones.
    """
    if cookiejar is None:
        cookiejar = RequestsCookieJar()

    if cookie_dict is not None:
        names_from_jar = [cookie.name for cookie in cookiejar]
        for name in cookie_dict:
            if overwrite or (name not in names_from_jar):
                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))

    return cookiejar


def merge_cookies(cookiejar, cookies):
    """Add cookies to cookiejar and returns a merged CookieJar.

    :param cookiejar: CookieJar object to add the cookies to.
    :param cookies: Dictionary or CookieJar object to be added.
    """
    if not isinstance(cookiejar, cookielib.CookieJar):
        raise ValueError('You can only merge into CookieJar')

    if isinstance(cookies, dict):
        cookiejar = cookiejar_from_dict(
            cookies, cookiejar=cookiejar, overwrite=False)
    elif isinstance(cookies, cookielib.CookieJar):
        try:
            cookiejar.update(cookies)
        except AttributeError:
            for cookie_in_jar in cookies:
                cookiejar.set_cookie(cookie_in_jar)

    return cookiejar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # -*- coding: utf-8 -*-

"""
requests.exceptions
~~~~~~~~~~~~~~~~~~~

This module contains the set of Requests' exceptions.
"""
from .packages.urllib3.exceptions import HTTPError as BaseHTTPError


class RequestException(IOError):
    """There was an ambiguous exception that occurred while handling your
    request.
    """

    def __init__(self, *args, **kwargs):
        """Initialize RequestException with `request` and `response` objects."""
        response = kwargs.pop('response', None)
        self.response = response
        self.request = kwargs.pop('request', None)
        if (response is not None and not self.request and
                hasattr(response, 'request')):
            self.request = self.response.request
        super(RequestException, self).__init__(*args, **kwargs)


class HTTPError(RequestException):
    """An HTTP error occurred."""


class ConnectionError(RequestException):
    """A Connection error occurred."""


class ProxyError(ConnectionError):
    """A proxy error occurred."""


class SSLError(ConnectionError):
    """An SSL error occurred."""


class Timeout(RequestException):
    """The request timed out.

    Catching this error will catch both
    :exc:`~requests.exceptions.ConnectTimeout` and
    :exc:`~requests.exceptions.ReadTimeout` errors.
    """


class ConnectTimeout(ConnectionError, Timeout):
    """The request timed out while trying to connect to the remote server.

    Requests that produced this error are safe to retry.
    """


class ReadTimeout(Timeout):
    """The server did not send any data in the allotted amount of time."""


class URLRequired(RequestException):
    """A valid URL is required to make a request."""


class TooManyRedirects(RequestException):
    """Too many redirects."""


class MissingSchema(RequestException, ValueError):
    """The URL schema (e.g. http or https) is missing."""


class InvalidSchema(RequestException, ValueError):
    """See defaults.py for valid schemas."""


class InvalidURL(RequestException, ValueError):
    """The URL provided was somehow invalid."""


class InvalidHeader(RequestException, ValueError):
    """The header value provided was somehow invalid."""


class ChunkedEncodingError(RequestException):
    """The server declared chunked encoding but sent an invalid chunk."""


class ContentDecodingError(RequestException, BaseHTTPError):
    """Failed to decode response content"""


class StreamConsumedError(RequestException, TypeError):
    """The content for this response was already consumed"""


class RetryError(RequestException):
    """Custom retries logic failed"""

class UnrewindableBodyError(RequestException):
    """Requests encountered an error when trying to rewind a body"""

# Warnings


class RequestsWarning(Warning):
    """Base warning for Requests."""
    pass


class FileModeWarning(RequestsWarning, DeprecationWarning):
    """A file was opened in text mode, but Requests determined its binary length."""
    pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # -*- coding: utf-8 -*-

"""
requests.hooks
~~~~~~~~~~~~~~

This module provides the capabilities for the Requests hooks system.

Available hooks:

``response``:
    The response generated from a Request.
"""
HOOKS = ['response']


def default_hooks():
    return dict((event, []) for event in HOOKS)

# TODO: response is the only one


def dispatch_hook(key, hooks, hook_data, **kwargs):
    """Dispatches a hook dictionary on a given piece of data."""
    hooks = hooks or dict()
    hooks = hooks.get(key)
    if hooks:
        if hasattr(hooks, '__call__'):
            hooks = [hooks]
        for hook in hooks:
            _hook_data = hook(hook_data, **kwargs)
            if _hook_data is not None:
                hook_data = _hook_data
    return hook_data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # -*- coding: utf-8 -*-

from .structures import LookupDict

_codes = {

    # Informational.
    100: ('continue',),
    101: ('switching_protocols',),
    102: ('processing',),
    103: ('checkpoint',),
    122: ('uri_too_long', 'request_uri_too_long'),
    200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\o/', ''),
    201: ('created',),
    202: ('accepted',),
    203: ('non_authoritative_info', 'non_authoritative_information'),
    204: ('no_content',),
    205: ('reset_content', 'reset'),
    206: ('partial_content', 'partial'),
    207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),
    208: ('already_reported',),
    226: ('im_used',),

    # Redirection.
    300: ('multiple_choices',),
    301: ('moved_permanently', 'moved', '\\o-'),
    302: ('found',),
    303: ('see_other', 'other'),
    304: ('not_modified',),
    305: ('use_proxy',),
    306: ('switch_proxy',),
    307: ('temporary_redirect', 'temporary_moved', 'temporary'),
    308: ('permanent_redirect',
          'resume_incomplete', 'resume',),  # These 2 to be removed in 3.0

    # Client Error.
    400: ('bad_request', 'bad'),
    401: ('unauthorized',),
    402: ('payment_required', 'payment'),
    403: ('forbidden',),
    404: ('not_found', '-o-'),
    405: ('method_not_allowed', 'not_allowed'),
    406: ('not_acceptable',),
    407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),
    408: ('request_timeout', 'timeout'),
    409: ('conflict',),
    410: ('gone',),
    411: ('length_required',),
    412: ('precondition_failed', 'precondition'),
    413: ('request_entity_too_large',),
    414: ('request_uri_too_large',),
    415: ('unsupported_media_type', 'unsupported_media', 'media_type'),
    416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),
    417: ('expectation_failed',),
    418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),
    421: ('misdirected_request',),
    422: ('unprocessable_entity', 'unprocessable'),
    423: ('locked',),
    424: ('failed_dependency', 'dependency'),
    425: ('unordered_collection', 'unordered'),
    426: ('upgrade_required', 'upgrade'),
    428: ('precondition_required', 'precondition'),
    429: ('too_many_requests', 'too_many'),
    431: ('header_fields_too_large', 'fields_too_large'),
    444: ('no_response', 'none'),
    449: ('retry_with', 'retry'),
    450: ('blocked_by_windows_parental_controls', 'parental_controls'),
    451: ('unavailable_for_legal_reasons', 'legal_reasons'),
    499: ('client_closed_request',),

    # Server Error.
    500: ('internal_server_error', 'server_error', '/o\\', ''),
    501: ('not_implemented',),
    502: ('bad_gateway',),
    503: ('service_unavailable', 'unavailable'),
    504: ('gateway_timeout',),
    505: ('http_version_not_supported', 'http_version'),
    506: ('variant_also_negotiates',),
    507: ('insufficient_storage',),
    509: ('bandwidth_limit_exceeded', 'bandwidth'),
    510: ('not_extended',),
    511: ('network_authentication_required', 'network_auth', 'network_authentication'),
}

codes = LookupDict(name='status_codes')

for code, titles in _codes.items():
    for title in titles:
        setattr(codes, title, code)
        if not title.startswith('\\'):
            setattr(codes, title.upper(), code)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
$IXH                 @   sA   d  Z  d d l m Z m Z m Z d d d  Z d d   Z d S)	z
requests._internal_utils
~~~~~~~~~~~~~~

Provides utility functions that are consumed internally by Requests
which depend on extremely few external helpers (such as compat)
   )is_py2builtin_strstrasciic             C   sC   t  |  t  r |  } n' t r0 |  j |  } n |  j |  } | S)zGiven a string object, regardless of type, returns a representation of
    that string in the native string type, encoding and decoding where
    necessary. This assumes ASCII unless told otherwise.
    )
isinstancer   r   encodedecode)stringencodingout r   :/usr/lib/python3/dist-packages/requests/_internal_utils.pyto_native_string   s    	r   c             C   sG   t  |  t  s t  y |  j d  d SWn t k
 rB d SYn Xd S)zDetermine if unicode string only contains ASCII characters.

    :param str u_string: unicode string to check. Must be unicode
        and not Python 2 `str`.
    :rtype: bool
    r   TFN)r   r   AssertionErrorr   UnicodeEncodeError)Zu_stringr   r   r   unicode_is_ascii   s    r   N)__doc__compatr   r   r   r   r   r   r   r   r   <module>	   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
l2XXf                 @   sd   d  Z  d d l Z y d d l m Z Wn e k
 rF d d   Z Yn Xe d k r` e e    d S)a  
requests.certs
~~~~~~~~~~~~~~

This module returns the preferred default CA certificate bundle.

If you are packaging Requests, e.g., for a Linux distribution or a managed
environment, you can change the definition of where() to return a separately
packaged CA bundle.
    N)wherec               C   s   d S)z(Return the preferred certificate bundle.z"/etc/ssl/certs/ca-certificates.crt r   r   r   0/usr/lib/python3/dist-packages/requests/certs.pyr      s    r   __main__)__doc__os.pathosZcertifir   ImportError__name__printr   r   r   r   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # -*- coding: utf-8 -*-

"""
requests.models
~~~~~~~~~~~~~~~

This module contains the primary objects that power Requests.
"""

import collections
import datetime

# Import encoding now, to avoid implicit import later.
# Implicit import within threads may cause LookupError when standard library is in a ZIP,
# such as in Embedded Python. See https://github.com/kennethreitz/requests/issues/3578.
import encodings.idna

from io import BytesIO, UnsupportedOperation
from .hooks import default_hooks
from .structures import CaseInsensitiveDict

from .auth import HTTPBasicAuth
from .cookies import cookiejar_from_dict, get_cookie_header, _copy_cookie_jar
from .packages import idna
from .packages.urllib3.fields import RequestField
from .packages.urllib3.filepost import encode_multipart_formdata
from .packages.urllib3.util import parse_url
from .packages.urllib3.exceptions import (
    DecodeError, ReadTimeoutError, ProtocolError, LocationParseError)
from .exceptions import (
    HTTPError, MissingSchema, InvalidURL, ChunkedEncodingError,
    ContentDecodingError, ConnectionError, StreamConsumedError)
from ._internal_utils import to_native_string, unicode_is_ascii
from .utils import (
    guess_filename, get_auth_from_url, requote_uri,
    stream_decode_response_unicode, to_key_val_list, parse_header_links,
    iter_slices, guess_json_utf, super_len, check_header_validity)
from .compat import (
    cookielib, urlunparse, urlsplit, urlencode, str, bytes, StringIO,
    is_py2, chardet, builtin_str, basestring)
from .compat import json as complexjson
from .status_codes import codes

#: The set of HTTP status codes that indicate an automatically
#: processable redirect.
REDIRECT_STATI = (
    codes.moved,               # 301
    codes.found,               # 302
    codes.other,               # 303
    codes.temporary_redirect,  # 307
    codes.permanent_redirect,  # 308
)

DEFAULT_REDIRECT_LIMIT = 30
CONTENT_CHUNK_SIZE = 10 * 1024
ITER_CHUNK_SIZE = 512


class RequestEncodingMixin(object):
    @property
    def path_url(self):
        """Build the path URL to use."""

        url = []

        p = urlsplit(self.url)

        path = p.path
        if not path:
            path = '/'

        url.append(path)

        query = p.query
        if query:
            url.append('?')
            url.append(query)

        return ''.join(url)

    @staticmethod
    def _encode_params(data):
        """Encode parameters in a piece of data.

        Will successfully encode parameters when passed as a dict or a list of
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
        if parameters are supplied as a dict.
        """

        if isinstance(data, (str, bytes)):
            return data
        elif hasattr(data, 'read'):
            return data
        elif hasattr(data, '__iter__'):
            result = []
            for k, vs in to_key_val_list(data):
                if isinstance(vs, basestring) or not hasattr(vs, '__iter__'):
                    vs = [vs]
                for v in vs:
                    if v is not None:
                        result.append(
                            (k.encode('utf-8') if isinstance(k, str) else k,
                             v.encode('utf-8') if isinstance(v, str) else v))
            return urlencode(result, doseq=True)
        else:
            return data

    @staticmethod
    def _encode_files(files, data):
        """Build the body for a multipart/form-data request.

        Will successfully encode files when passed as a dict or a list of
        tuples. Order is retained if data is a list of tuples but arbitrary
        if parameters are supplied as a dict.
        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
        or 4-tuples (filename, fileobj, contentype, custom_headers).
        """
        if (not files):
            raise ValueError("Files must be provided.")
        elif isinstance(data, basestring):
            raise ValueError("Data must not be a string.")

        new_fields = []
        fields = to_key_val_list(data or {})
        files = to_key_val_list(files or {})

        for field, val in fields:
            if isinstance(val, basestring) or not hasattr(val, '__iter__'):
                val = [val]
            for v in val:
                if v is not None:
                    # Don't call str() on bytestrings: in Py3 it all goes wrong.
                    if not isinstance(v, bytes):
                        v = str(v)

                    new_fields.append(
                        (field.decode('utf-8') if isinstance(field, bytes) else field,
                         v.encode('utf-8') if isinstance(v, str) else v))

        for (k, v) in files:
            # support for explicit filename
            ft = None
            fh = None
            if isinstance(v, (tuple, list)):
                if len(v) == 2:
                    fn, fp = v
                elif len(v) == 3:
                    fn, fp, ft = v
                else:
                    fn, fp, ft, fh = v
            else:
                fn = guess_filename(v) or k
                fp = v

            if isinstance(fp, (str, bytes, bytearray)):
                fdata = fp
            else:
                fdata = fp.read()

            rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)
            rf.make_multipart(content_type=ft)
            new_fields.append(rf)

        body, content_type = encode_multipart_formdata(new_fields)

        return body, content_type


class RequestHooksMixin(object):
    def register_hook(self, event, hook):
        """Properly register a hook."""

        if event not in self.hooks:
            raise ValueError('Unsupported event specified, with event name "%s"' % (event))

        if isinstance(hook, collections.Callable):
            self.hooks[event].append(hook)
        elif hasattr(hook, '__iter__'):
            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))

    def deregister_hook(self, event, hook):
        """Deregister a previously registered hook.
        Returns True if the hook existed, False if not.
        """

        try:
            self.hooks[event].remove(hook)
            return True
        except ValueError:
            return False


class Request(RequestHooksMixin):
    """A user-created :class:`Request <Request>` object.

    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.

    :param method: HTTP method to use.
    :param url: URL to send.
    :param headers: dictionary of headers to send.
    :param files: dictionary of {filename: fileobject} files to multipart upload.
    :param data: the body to attach to the request. If a dictionary is provided, form-encoding will take place.
    :param json: json for the body to attach to the request (if files or data is not specified).
    :param params: dictionary of URL parameters to append to the URL.
    :param auth: Auth handler or (user, pass) tuple.
    :param cookies: dictionary or CookieJar of cookies to attach to this request.
    :param hooks: dictionary of callback hooks, for internal usage.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'http://httpbin.org/get')
      >>> req.prepare()
      <PreparedRequest [GET]>
    """

    def __init__(self, method=None, url=None, headers=None, files=None,
        data=None, params=None, auth=None, cookies=None, hooks=None, json=None):

        # Default empty dicts for dict params.
        data = [] if data is None else data
        files = [] if files is None else files
        headers = {} if headers is None else headers
        params = {} if params is None else params
        hooks = {} if hooks is None else hooks

        self.hooks = default_hooks()
        for (k, v) in list(hooks.items()):
            self.register_hook(event=k, hook=v)

        self.method = method
        self.url = url
        self.headers = headers
        self.files = files
        self.data = data
        self.json = json
        self.params = params
        self.auth = auth
        self.cookies = cookies

    def __repr__(self):
        return '<Request [%s]>' % (self.method)

    def prepare(self):
        """Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it."""
        p = PreparedRequest()
        p.prepare(
            method=self.method,
            url=self.url,
            headers=self.headers,
            files=self.files,
            data=self.data,
            json=self.json,
            params=self.params,
            auth=self.auth,
            cookies=self.cookies,
            hooks=self.hooks,
        )
        return p


class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
    """The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
    containing the exact bytes that will be sent to the server.

    Generated from either a :class:`Request <Request>` object or manually.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'http://httpbin.org/get')
      >>> r = req.prepare()
      <PreparedRequest [GET]>

      >>> s = requests.Session()
      >>> s.send(r)
      <Response [200]>
    """

    def __init__(self):
        #: HTTP verb to send to the server.
        self.method = None
        #: HTTP URL to send the request to.
        self.url = None
        #: dictionary of HTTP headers.
        self.headers = None
        # The `CookieJar` used to create the Cookie header will be stored here
        # after prepare_cookies is called
        self._cookies = None
        #: request body to send to the server.
        self.body = None
        #: dictionary of callback hooks, for internal usage.
        self.hooks = default_hooks()
        #: integer denoting starting position of a readable file-like body.
        self._body_position = None

    def prepare(self, method=None, url=None, headers=None, files=None,
        data=None, params=None, auth=None, cookies=None, hooks=None, json=None):
        """Prepares the entire request with the given parameters."""

        self.prepare_method(method)
        self.prepare_url(url, params)
        self.prepare_headers(headers)
        self.prepare_cookies(cookies)
        self.prepare_body(data, files, json)
        self.prepare_auth(auth, url)

        # Note that prepare_auth must be last to enable authentication schemes
        # such as OAuth to work on a fully prepared request.

        # This MUST go after prepare_auth. Authenticators could add a hook
        self.prepare_hooks(hooks)

    def __repr__(self):
        return '<PreparedRequest [%s]>' % (self.method)

    def copy(self):
        p = PreparedRequest()
        p.method = self.method
        p.url = self.url
        p.headers = self.headers.copy() if self.headers is not None else None
        p._cookies = _copy_cookie_jar(self._cookies)
        p.body = self.body
        p.hooks = self.hooks
        p._body_position = self._body_position
        return p

    def prepare_method(self, method):
        """Prepares the given HTTP method."""
        self.method = method
        if self.method is not None:
            self.method = to_native_string(self.method.upper())

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/kennethreitz/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode('utf8')
        else:
            url = unicode(url) if is_py2 else str(url)

        # Remove leading whitespaces from url
        url = url.lstrip()

        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ':' in url and not url.lower().startswith('http'):
            self.url = url
            return

        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)

        if not scheme:
            error = ("Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?")
            error = error.format(to_native_string(url, 'utf8'))

            raise MissingSchema(error)

        if not host:
            raise InvalidURL("Invalid URL %r: No host supplied" % url)

        # In general, we want to try IDNA encoding every hostname, as that
        # allows users to automatically get the correct behaviour. However,
        # were quite strict about IDNA encoding, so certain valid hostnames
        # may fail to encode. On failure, we verify the hostname meets a
        # minimum standard of only containing ASCII characters, and not starting
        # with a wildcard (*), before allowing the unencoded hostname through.
        try:
            host = idna.encode(host, uts46=True).decode('utf-8')
        except (UnicodeError, idna.IDNAError):
            if not unicode_is_ascii(host) or host.startswith(u'*'):
                raise InvalidURL('URL has an invalid label.')

        # Carefully reconstruct the network location
        netloc = auth or ''
        if netloc:
            netloc += '@'
        netloc += host
        if port:
            netloc += ':' + str(port)

        # Bare domains aren't valid URLs.
        if not path:
            path = '/'

        if is_py2:
            if isinstance(scheme, str):
                scheme = scheme.encode('utf-8')
            if isinstance(netloc, str):
                netloc = netloc.encode('utf-8')
            if isinstance(path, str):
                path = path.encode('utf-8')
            if isinstance(query, str):
                query = query.encode('utf-8')
            if isinstance(fragment, str):
                fragment = fragment.encode('utf-8')

        if isinstance(params, (str, bytes)):
            params = to_native_string(params)

        enc_params = self._encode_params(params)
        if enc_params:
            if query:
                query = '%s&%s' % (query, enc_params)
            else:
                query = enc_params

        url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))
        self.url = url

    def prepare_headers(self, headers):
        """Prepares the given HTTP headers."""

        self.headers = CaseInsensitiveDict()
        if headers:
            for header in headers.items():
                # Raise exception on invalid header value.
                check_header_validity(header)
                name, value = header
                self.headers[to_native_string(name)] = value

    def prepare_body(self, data, files, json=None):
        """Prepares the given HTTP body data."""

        # Check if file, fo, generator, iterator.
        # If not, run through normal process.

        # Nottin' on you.
        body = None
        content_type = None

        if not data and json is not None:
            # urllib3 requires a bytes-like body. Python 2's json.dumps
            # provides this natively, but Python 3 gives a Unicode string.
            content_type = 'application/json'
            body = complexjson.dumps(json)
            if not isinstance(body, bytes):
                body = body.encode('utf-8')

        is_stream = all([
            hasattr(data, '__iter__'),
            not isinstance(data, (basestring, list, tuple, collections.Mapping))
        ])

        try:
            length = super_len(data)
        except (TypeError, AttributeError, UnsupportedOperation):
            length = None

        if is_stream:
            body = data

            if getattr(body, 'tell', None) is not None:
                # Record the current file position before reading.
                # This will allow us to rewind a file in the event
                # of a redirect.
                try:
                    self._body_position = body.tell()
                except (IOError, OSError):
                    # This differentiates from None, allowing us to catch
                    # a failed `tell()` later when trying to rewind the body
                    self._body_position = object()

            if files:
                raise NotImplementedError('Streamed bodies and files are mutually exclusive.')

            if length:
                self.headers['Content-Length'] = builtin_str(length)
            else:
                self.headers['Transfer-Encoding'] = 'chunked'
        else:
            # Multi-part file uploads.
            if files:
                (body, content_type) = self._encode_files(files, data)
            else:
                if data:
                    body = self._encode_params(data)
                    if isinstance(data, basestring) or hasattr(data, 'read'):
                        content_type = None
                    else:
                        content_type = 'application/x-www-form-urlencoded'

            self.prepare_content_length(body)

            # Add content-type if it wasn't explicitly provided.
            if content_type and ('content-type' not in self.headers):
                self.headers['Content-Type'] = content_type

        self.body = body

    def prepare_content_length(self, body):
        """Prepare Content-Length header based on request method and body"""
        if body is not None:
            length = super_len(body)
            if length:
                # If length exists, set it. Otherwise, we fallback
                # to Transfer-Encoding: chunked.
                self.headers['Content-Length'] = builtin_str(length)
        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:
            # Set Content-Length to 0 for methods that can have a body
            # but don't provide one. (i.e. not GET or HEAD)
            self.headers['Content-Length'] = '0'

    def prepare_auth(self, auth, url=''):
        """Prepares the given HTTP auth data."""

        # If no Auth is explicitly provided, extract it from the URL first.
        if auth is None:
            url_auth = get_auth_from_url(self.url)
            auth = url_auth if any(url_auth) else None

        if auth:
            if isinstance(auth, tuple) and len(auth) == 2:
                # special-case basic HTTP auth
                auth = HTTPBasicAuth(*auth)

            # Allow auth to make its changes.
            r = auth(self)

            # Update self to reflect the auth changes.
            self.__dict__.update(r.__dict__)

            # Recompute Content-Length
            self.prepare_content_length(self.body)

    def prepare_cookies(self, cookies):
        """Prepares the given HTTP cookie data.

        This function eventually generates a ``Cookie`` header from the
        given cookies using cookielib. Due to cookielib's design, the header
        will not be regenerated if it already exists, meaning this function
        can only be called once for the life of the
        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls
        to ``prepare_cookies`` will have no actual effect, unless the "Cookie"
        header is removed beforehand.
        """
        if isinstance(cookies, cookielib.CookieJar):
            self._cookies = cookies
        else:
            self._cookies = cookiejar_from_dict(cookies)

        cookie_header = get_cookie_header(self._cookies, self)
        if cookie_header is not None:
            self.headers['Cookie'] = cookie_header

    def prepare_hooks(self, hooks):
        """Prepares the given hooks."""
        # hooks can be passed as None to the prepare method and to this
        # method. To prevent iterating over None, simply use an empty list
        # if hooks is False-y
        hooks = hooks or []
        for event in hooks:
            self.register_hook(event, hooks[event])


class Response(object):
    """The :class:`Response <Response>` object, which contains a
    server's response to an HTTP request.
    """

    __attrs__ = [
        '_content', 'status_code', 'headers', 'url', 'history',
        'encoding', 'reason', 'cookies', 'elapsed', 'request'
    ]

    def __init__(self):
        super(Response, self).__init__()

        self._content = False
        self._content_consumed = False

        #: Integer Code of responded HTTP Status, e.g. 404 or 200.
        self.status_code = None

        #: Case-insensitive Dictionary of Response Headers.
        #: For example, ``headers['content-encoding']`` will return the
        #: value of a ``'Content-Encoding'`` response header.
        self.headers = CaseInsensitiveDict()

        #: File-like object representation of response (for advanced usage).
        #: Use of ``raw`` requires that ``stream=True`` be set on the request.
        # This requirement does not apply for use internally to Requests.
        self.raw = None

        #: Final URL location of Response.
        self.url = None

        #: Encoding to decode with when accessing r.text.
        self.encoding = None

        #: A list of :class:`Response <Response>` objects from
        #: the history of the Request. Any redirect responses will end
        #: up here. The list is sorted from the oldest to the most recent request.
        self.history = []

        #: Textual reason of responded HTTP Status, e.g. "Not Found" or "OK".
        self.reason = None

        #: A CookieJar of Cookies the server sent back.
        self.cookies = cookiejar_from_dict({})

        #: The amount of time elapsed between sending the request
        #: and the arrival of the response (as a timedelta).
        #: This property specifically measures the time taken between sending
        #: the first byte of the request and finishing parsing the headers. It
        #: is therefore unaffected by consuming the response content or the
        #: value of the ``stream`` keyword argument.
        self.elapsed = datetime.timedelta(0)

        #: The :class:`PreparedRequest <PreparedRequest>` object to which this
        #: is a response.
        self.request = None

    def __getstate__(self):
        # Consume everything; accessing the content attribute makes
        # sure the content has been fully read.
        if not self._content_consumed:
            self.content

        return dict(
            (attr, getattr(self, attr, None))
            for attr in self.__attrs__
        )

    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

        # pickled objects do not have .raw
        setattr(self, '_content_consumed', True)
        setattr(self, 'raw', None)

    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)

    def __bool__(self):
        """Returns true if :attr:`status_code` is 'OK'."""
        return self.ok

    def __nonzero__(self):
        """Returns true if :attr:`status_code` is 'OK'."""
        return self.ok

    def __iter__(self):
        """Allows you to use a response as an iterator."""
        return self.iter_content(128)

    @property
    def ok(self):
        try:
            self.raise_for_status()
        except HTTPError:
            return False
        return True

    @property
    def is_redirect(self):
        """True if this Response is a well-formed HTTP redirect that could have
        been processed automatically (by :meth:`Session.resolve_redirects`).
        """
        return ('location' in self.headers and self.status_code in REDIRECT_STATI)

    @property
    def is_permanent_redirect(self):
        """True if this Response one of the permanent versions of redirect"""
        return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))

    @property
    def apparent_encoding(self):
        """The apparent encoding, provided by the chardet library"""
        return chardet.detect(self.content)['encoding']

    def iter_content(self, chunk_size=1, decode_unicode=False):
        """Iterates over the response data.  When stream=True is set on the
        request, this avoids reading the content at once into memory for
        large responses.  The chunk size is the number of bytes it should
        read into memory.  This is not necessarily the length of each item
        returned as decoding can take place.

        chunk_size must be of type int or None. A value of None will
        function differently depending on the value of `stream`.
        stream=True will read data as it arrives in whatever size the
        chunks are received. If stream=False, data is returned as
        a single chunk.

        If decode_unicode is True, content will be decoded using the best
        available encoding based on the response.
        """

        def generate():
            # Special case for urllib3.
            if hasattr(self.raw, 'stream'):
                try:
                    for chunk in self.raw.stream(chunk_size, decode_content=True):
                        yield chunk
                except ProtocolError as e:
                    raise ChunkedEncodingError(e)
                except DecodeError as e:
                    raise ContentDecodingError(e)
                except ReadTimeoutError as e:
                    raise ConnectionError(e)
            else:
                # Standard file-like object.
                while True:
                    chunk = self.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk

            self._content_consumed = True

        if self._content_consumed and isinstance(self._content, bool):
            raise StreamConsumedError()
        elif chunk_size is not None and not isinstance(chunk_size, int):
            raise TypeError("chunk_size must be an int, it is instead a %s." % type(chunk_size))
        # simulate reading small chunks of the content
        reused_chunks = iter_slices(self._content, chunk_size)

        stream_chunks = generate()

        chunks = reused_chunks if self._content_consumed else stream_chunks

        if decode_unicode:
            chunks = stream_decode_response_unicode(chunks, self)

        return chunks

    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):
        """Iterates over the response data, one line at a time.  When
        stream=True is set on the request, this avoids reading the
        content at once into memory for large responses.

        .. note:: This method is not reentrant safe.
        """

        pending = None

        for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):

            if pending is not None:
                chunk = pending + chunk

            if delimiter:
                lines = chunk.split(delimiter)
            else:
                lines = chunk.splitlines()

            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
                pending = lines.pop()
            else:
                pending = None

            for line in lines:
                yield line

        if pending is not None:
            yield pending

    @property
    def content(self):
        """Content of the response, in bytes."""

        if self._content is False:
            # Read the contents.
            if self._content_consumed:
                raise RuntimeError(
                    'The content for this response was already consumed')

            if self.status_code == 0 or self.raw is None:
                self._content = None
            else:
                self._content = bytes().join(self.iter_content(CONTENT_CHUNK_SIZE)) or bytes()

        self._content_consumed = True
        # don't need to release the connection; that's been handled by urllib3
        # since we exhausted the data.
        return self._content

    @property
    def text(self):
        """Content of the response, in unicode.

        If Response.encoding is None, encoding will be guessed using
        ``chardet``.

        The encoding of the response content is determined based solely on HTTP
        headers, following RFC 2616 to the letter. If you can take advantage of
        non-HTTP knowledge to make a better guess at the encoding, you should
        set ``r.encoding`` appropriately before accessing this property.
        """

        # Try charset from content-type
        content = None
        encoding = self.encoding

        if not self.content:
            return str('')

        # Fallback to auto-detected encoding.
        if self.encoding is None:
            encoding = self.apparent_encoding

        # Decode unicode from given encoding.
        try:
            content = str(self.content, encoding, errors='replace')
        except (LookupError, TypeError):
            # A LookupError is raised if the encoding was not found which could
            # indicate a misspelling or similar mistake.
            #
            # A TypeError can be raised if encoding is None
            #
            # So we try blindly encoding.
            content = str(self.content, errors='replace')

        return content

    def json(self, **kwargs):
        """Returns the json-encoded content of a response, if any.

        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises ValueError: If the response body does not contain valid json.
        """

        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using chardet to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(
                        self.content.decode(encoding), **kwargs
                    )
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
        return complexjson.loads(self.text, **kwargs)

    @property
    def links(self):
        """Returns the parsed header links of the response, if any."""

        header = self.headers.get('link')

        # l = MultiDict()
        l = {}

        if header:
            links = parse_header_links(header)

            for link in links:
                key = link.get('rel') or link.get('url')
                l[key] = link

        return l

    def raise_for_status(self):
        """Raises stored :class:`HTTPError`, if one occurred."""

        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason

        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)

        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)

        if http_error_msg:
            raise HTTPError(http_error_msg, response=self)

    def close(self):
        """Releases the connection back to the pool. Once this method has been
        called the underlying ``raw`` object must not be accessed again.

        *Note: Should not normally need to be called explicitly.*
        """
        if not self._content_consumed:
            self.raw.close()

        release_conn = getattr(self.raw, 'release_conn', None)
        if release_conn is not None:
            release_conn()
                                                                                                                                                        # -*- coding: utf-8 -*-

"""
requests.session
~~~~~~~~~~~~~~~~

This module provides a Session object to manage and persist settings across
requests (cookies, auth, proxies).
"""
import os
from collections import Mapping
from datetime import datetime

from .auth import _basic_auth_str
from .compat import cookielib, OrderedDict, urljoin, urlparse
from .cookies import (
    cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)
from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT
from .hooks import default_hooks, dispatch_hook
from ._internal_utils import to_native_string
from .utils import to_key_val_list, default_headers
from .exceptions import (
    TooManyRedirects, InvalidSchema, ChunkedEncodingError, ContentDecodingError)
from .packages.urllib3._collections import RecentlyUsedContainer
from .structures import CaseInsensitiveDict

from .adapters import HTTPAdapter

from .utils import (
    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,
    get_auth_from_url, rewind_body
)

from .status_codes import codes

# formerly defined here, reexposed here for backward compatibility
from .models import REDIRECT_STATI

REDIRECT_CACHE_SIZE = 1000


def merge_setting(request_setting, session_setting, dict_class=OrderedDict):
    """Determines appropriate setting for a given request, taking into account
    the explicit setting on that request, and the setting in the session. If a
    setting is a dictionary, they will be merged together using `dict_class`
    """

    if session_setting is None:
        return request_setting

    if request_setting is None:
        return session_setting

    # Bypass if not a dictionary (e.g. verify)
    if not (
            isinstance(session_setting, Mapping) and
            isinstance(request_setting, Mapping)
    ):
        return request_setting

    merged_setting = dict_class(to_key_val_list(session_setting))
    merged_setting.update(to_key_val_list(request_setting))

    # Remove keys that are set to None. Extract keys first to avoid altering
    # the dictionary during iteration.
    none_keys = [k for (k, v) in merged_setting.items() if v is None]
    for key in none_keys:
        del merged_setting[key]

    return merged_setting


def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):
    """Properly merges both requests and session hooks.

    This is necessary because when request_hooks == {'response': []}, the
    merge breaks Session hooks entirely.
    """
    if session_hooks is None or session_hooks.get('response') == []:
        return request_hooks

    if request_hooks is None or request_hooks.get('response') == []:
        return session_hooks

    return merge_setting(request_hooks, session_hooks, dict_class)


class SessionRedirectMixin(object):
    def resolve_redirects(self, resp, req, stream=False, timeout=None,
                          verify=True, cert=None, proxies=None, **adapter_kwargs):
        """Receives a Response. Returns a generator of Responses."""

        i = 0
        hist = [] # keep track of history

        while resp.is_redirect:
            prepared_request = req.copy()

            if i > 0:
                # Update history and keep track of redirects.
                hist.append(resp)
                new_hist = list(hist)
                resp.history = new_hist

            try:
                resp.content  # Consume socket so it can be released
            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):
                resp.raw.read(decode_content=False)

            if i >= self.max_redirects:
                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects, response=resp)

            # Release the connection back into the pool.
            resp.close()

            url = resp.headers['location']

            # Handle redirection without scheme (see: RFC 1808 Section 4)
            if url.startswith('//'):
                parsed_rurl = urlparse(resp.url)
                url = '%s:%s' % (parsed_rurl.scheme, url)

            # The scheme should be lower case...
            parsed = urlparse(url)
            url = parsed.geturl()

            # Facilitate relative 'location' headers, as allowed by RFC 7231.
            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')
            # Compliant with RFC3986, we percent encode the url.
            if not parsed.netloc:
                url = urljoin(resp.url, requote_uri(url))
            else:
                url = requote_uri(url)

            prepared_request.url = to_native_string(url)
            # Cache the url, unless it redirects to itself.
            if resp.is_permanent_redirect and req.url != prepared_request.url:
                self.redirect_cache[req.url] = prepared_request.url

            self.rebuild_method(prepared_request, resp)

            # https://github.com/kennethreitz/requests/issues/1084
            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):
                # https://github.com/kennethreitz/requests/issues/3490
                purged_headers = ('Content-Length', 'Content-Type', 'Transfer-Encoding')
                for header in purged_headers:
                    prepared_request.headers.pop(header, None)
                prepared_request.body = None

            headers = prepared_request.headers
            try:
                del headers['Cookie']
            except KeyError:
                pass

            # Extract any cookies sent on the response to the cookiejar
            # in the new request. Because we've mutated our copied prepared
            # request, use the old one that we haven't yet touched.
            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)
            merge_cookies(prepared_request._cookies, self.cookies)
            prepared_request.prepare_cookies(prepared_request._cookies)

            # Rebuild auth and proxy information.
            proxies = self.rebuild_proxies(prepared_request, proxies)
            self.rebuild_auth(prepared_request, resp)

            # A failed tell() sets `_body_position` to `object()`. This non-None
            # value ensures `rewindable` will be True, allowing us to raise an
            # UnrewindableBodyError, instead of hanging the connection.
            rewindable = (
                prepared_request._body_position is not None and
                ('Content-Length' in headers or 'Transfer-Encoding' in headers)
            )

            # Attempt to rewind consumed file-like object.
            if rewindable:
                rewind_body(prepared_request)

            # Override the original request.
            req = prepared_request

            resp = self.send(
                req,
                stream=stream,
                timeout=timeout,
                verify=verify,
                cert=cert,
                proxies=proxies,
                allow_redirects=False,
                **adapter_kwargs
            )

            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)

            i += 1
            yield resp

    def rebuild_auth(self, prepared_request, response):
        """When being redirected we may want to strip authentication from the
        request to avoid leaking credentials. This method intelligently removes
        and reapplies authentication where possible to avoid credential loss.
        """
        headers = prepared_request.headers
        url = prepared_request.url

        if 'Authorization' in headers:
            # If we get redirected to a new host, we should strip out any
            # authentication headers.
            original_parsed = urlparse(response.request.url)
            redirect_parsed = urlparse(url)

            if (original_parsed.hostname != redirect_parsed.hostname):
                del headers['Authorization']

        # .netrc might have more auth for us on our new host.
        new_auth = get_netrc_auth(url) if self.trust_env else None
        if new_auth is not None:
            prepared_request.prepare_auth(new_auth)

        return

    def rebuild_proxies(self, prepared_request, proxies):
        """This method re-evaluates the proxy configuration by considering the
        environment variables. If we are redirected to a URL covered by
        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing
        proxy keys for this URL (in case they were stripped by a previous
        redirect).

        This method also replaces the Proxy-Authorization header where
        necessary.

        :rtype: dict
        """
        headers = prepared_request.headers
        url = prepared_request.url
        scheme = urlparse(url).scheme
        new_proxies = proxies.copy() if proxies is not None else {}

        if self.trust_env and not should_bypass_proxies(url):
            environ_proxies = get_environ_proxies(url)

            proxy = environ_proxies.get(scheme, environ_proxies.get('all'))

            if proxy:
                new_proxies.setdefault(scheme, proxy)

        if 'Proxy-Authorization' in headers:
            del headers['Proxy-Authorization']

        try:
            username, password = get_auth_from_url(new_proxies[scheme])
        except KeyError:
            username, password = None, None

        if username and password:
            headers['Proxy-Authorization'] = _basic_auth_str(username, password)

        return new_proxies

    def rebuild_method(self, prepared_request, response):
        """When being redirected we may want to change the method of the request
        based on certain specs or browser behavior.
        """
        method = prepared_request.method

        # http://tools.ietf.org/html/rfc7231#section-6.4.4
        if response.status_code == codes.see_other and method != 'HEAD':
            method = 'GET'

        # Do what the browsers do, despite standards...
        # First, turn 302s into GETs.
        if response.status_code == codes.found and method != 'HEAD':
            method = 'GET'

        # Second, if a POST is responded to with a 301, turn it into a GET.
        # This bizarre behaviour is explained in Issue 1704.
        if response.status_code == codes.moved and method == 'POST':
            method = 'GET'

        prepared_request.method = method


class Session(SessionRedirectMixin):
    """A Requests session.

    Provides cookie persistence, connection-pooling, and configuration.

    Basic Usage::

      >>> import requests
      >>> s = requests.Session()
      >>> s.get('http://httpbin.org/get')
      <Response [200]>

    Or as a context manager::

      >>> with requests.Session() as s:
      >>>     s.get('http://httpbin.org/get')
      <Response [200]>
    """

    __attrs__ = [
        'headers', 'cookies', 'auth', 'proxies', 'hooks', 'params', 'verify',
        'cert', 'prefetch', 'adapters', 'stream', 'trust_env',
        'max_redirects',
    ]

    def __init__(self):

        #: A case-insensitive dictionary of headers to be sent on each
        #: :class:`Request <Request>` sent from this
        #: :class:`Session <Session>`.
        self.headers = default_headers()

        #: Default Authentication tuple or object to attach to
        #: :class:`Request <Request>`.
        self.auth = None

        #: Dictionary mapping protocol or protocol and host to the URL of the proxy
        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to
        #: be used on each :class:`Request <Request>`.
        self.proxies = {}

        #: Event-handling hooks.
        self.hooks = default_hooks()

        #: Dictionary of querystring data to attach to each
        #: :class:`Request <Request>`. The dictionary values may be lists for
        #: representing multivalued query parameters.
        self.params = {}

        #: Stream response content default.
        self.stream = False

        #: SSL Verification default.
        self.verify = True

        #: SSL client certificate default.
        self.cert = None

        #: Maximum number of redirects allowed. If the request exceeds this
        #: limit, a :class:`TooManyRedirects` exception is raised.
        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is
        #: 30.
        self.max_redirects = DEFAULT_REDIRECT_LIMIT

        #: Trust environment settings for proxy configuration, default
        #: authentication and similar.
        self.trust_env = True

        #: A CookieJar containing all currently outstanding cookies set on this
        #: session. By default it is a
        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but
        #: may be any other ``cookielib.CookieJar`` compatible object.
        self.cookies = cookiejar_from_dict({})

        # Default connection adapters.
        self.adapters = OrderedDict()
        self.mount('https://', HTTPAdapter())
        self.mount('http://', HTTPAdapter())

        # Only store 1000 redirects to prevent using infinite memory
        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def prepare_request(self, request):
        """Constructs a :class:`PreparedRequest <PreparedRequest>` for
        transmission and returns it. The :class:`PreparedRequest` has settings
        merged from the :class:`Request <Request>` instance and those of the
        :class:`Session`.

        :param request: :class:`Request` instance to prepare with this
            session's settings.
        :rtype: requests.PreparedRequest
        """
        cookies = request.cookies or {}

        # Bootstrap CookieJar.
        if not isinstance(cookies, cookielib.CookieJar):
            cookies = cookiejar_from_dict(cookies)

        # Merge with session cookies
        merged_cookies = merge_cookies(
            merge_cookies(RequestsCookieJar(), self.cookies), cookies)

        # Set environment's basic authentication if not explicitly set.
        auth = request.auth
        if self.trust_env and not auth and not self.auth:
            auth = get_netrc_auth(request.url)

        p = PreparedRequest()
        p.prepare(
            method=request.method.upper(),
            url=request.url,
            files=request.files,
            data=request.data,
            json=request.json,
            headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),
            params=merge_setting(request.params, self.params),
            auth=merge_setting(auth, self.auth),
            cookies=merged_cookies,
            hooks=merge_hooks(request.hooks, self.hooks),
        )
        return p

    def request(self, method, url,
        params=None,
        data=None,
        headers=None,
        cookies=None,
        files=None,
        auth=None,
        timeout=None,
        allow_redirects=True,
        proxies=None,
        hooks=None,
        stream=None,
        verify=None,
        cert=None,
        json=None):
        """Constructs a :class:`Request <Request>`, prepares it and sends it.
        Returns :class:`Response <Response>` object.

        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, bytes, or file-like object to send
            in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``'filename': file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) whether the SSL cert will be verified.
            A CA_BUNDLE path can also be provided. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, ('cert', 'key') pair.
        :rtype: requests.Response
        """
        # Create the Request.
        req = Request(
            method = method.upper(),
            url = url,
            headers = headers,
            files = files,
            data = data or {},
            json = json,
            params = params or {},
            auth = auth,
            cookies = cookies,
            hooks = hooks,
        )
        prep = self.prepare_request(req)

        proxies = proxies or {}

        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )

        # Send the request.
        send_kwargs = {
            'timeout': timeout,
            'allow_redirects': allow_redirects,
        }
        send_kwargs.update(settings)
        resp = self.send(prep, **send_kwargs)

        return resp

    def get(self, url, **kwargs):
        """Sends a GET request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        kwargs.setdefault('allow_redirects', True)
        return self.request('GET', url, **kwargs)

    def options(self, url, **kwargs):
        """Sends a OPTIONS request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        kwargs.setdefault('allow_redirects', True)
        return self.request('OPTIONS', url, **kwargs)

    def head(self, url, **kwargs):
        """Sends a HEAD request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        kwargs.setdefault('allow_redirects', False)
        return self.request('HEAD', url, **kwargs)

    def post(self, url, data=None, json=None, **kwargs):
        """Sends a POST request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        return self.request('POST', url, data=data, json=json, **kwargs)

    def put(self, url, data=None, **kwargs):
        """Sends a PUT request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        return self.request('PUT', url, data=data, **kwargs)

    def patch(self, url, data=None, **kwargs):
        """Sends a PATCH request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        return self.request('PATCH', url,  data=data, **kwargs)

    def delete(self, url, **kwargs):
        """Sends a DELETE request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        """

        return self.request('DELETE', url, **kwargs)

    def send(self, request, **kwargs):
        """
        Send a given PreparedRequest.

        :rtype: requests.Response
        """
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault('stream', self.stream)
        kwargs.setdefault('verify', self.verify)
        kwargs.setdefault('cert', self.cert)
        kwargs.setdefault('proxies', self.proxies)

        # It's possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError('You can only send PreparedRequests.')

        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop('allow_redirects', True)
        stream = kwargs.get('stream')
        hooks = request.hooks

        # Resolve URL in redirect cache, if available.
        if allow_redirects:
            checked_urls = set()
            while request.url in self.redirect_cache:
                checked_urls.add(request.url)
                new_url = self.redirect_cache.get(request.url)
                if new_url in checked_urls:
                    break
                request.url = new_url

        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)

        # Start time (approximately) of the request
        start = datetime.utcnow()

        # Send the request
        r = adapter.send(request, **kwargs)

        # Total elapsed time of the request (approximately)
        r.elapsed = datetime.utcnow() - start

        # Response manipulation hooks
        r = dispatch_hook('response', hooks, r, **kwargs)

        # Persist cookies
        if r.history:

            # If the hooks create history then we want those cookies too
            for resp in r.history:
                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)

        extract_cookies_to_jar(self.cookies, request, r.raw)

        # Redirect resolving generator.
        gen = self.resolve_redirects(r, request, **kwargs)

        # Resolve redirects if allowed.
        history = [resp for resp in gen] if allow_redirects else []

        # Shuffle things around if there's history.
        if history:
            # Insert the first (original) request at the start
            history.insert(0, r)
            # Get the last request made
            r = history.pop()
            r.history = history

        if not stream:
            r.content

        return r

    def merge_environment_settings(self, url, proxies, stream, verify, cert):
        """
        Check the environment and merge it with some settings.

        :rtype: dict
        """
        # Gather clues from the surrounding environment.
        if self.trust_env:
            # Set environment's proxies.
            env_proxies = get_environ_proxies(url) or {}
            for (k, v) in env_proxies.items():
                proxies.setdefault(k, v)

            # Look for requests environment configuration and be compatible
            # with cURL.
            if verify is True or verify is None:
                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or
                          os.environ.get('CURL_CA_BUNDLE'))

        # Merge all the kwargs.
        proxies = merge_setting(proxies, self.proxies)
        stream = merge_setting(stream, self.stream)
        verify = merge_setting(verify, self.verify)
        cert = merge_setting(cert, self.cert)

        return {'verify': verify, 'proxies': proxies, 'stream': stream,
                'cert': cert}

    def get_adapter(self, url):
        """
        Returns the appropriate connection adapter for the given URL.

        :rtype: requests.adapters.BaseAdapter
        """
        for (prefix, adapter) in self.adapters.items():

            if url.lower().startswith(prefix):
                return adapter

        # Nothing matches :-/
        raise InvalidSchema("No connection adapters were found for '%s'" % url)

    def close(self):
        """Closes all adapters and as such the session"""
        for v in self.adapters.values():
            v.close()

    def mount(self, prefix, adapter):
        """Registers a connection adapter to a prefix.

        Adapters are sorted in descending order by key length.
        """
        self.adapters[prefix] = adapter
        keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]

        for key in keys_to_move:
            self.adapters[key] = self.adapters.pop(key)

    def __getstate__(self):
        state = dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)
        state['redirect_cache'] = dict(self.redirect_cache)
        return state

    def __setstate__(self, state):
        redirect_cache = state.pop('redirect_cache', {})
        for attr, value in state.items():
            setattr(self, attr, value)

        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)
        for redirect, to in redirect_cache.items():
            self.redirect_cache[redirect] = to


def session():
    """
    Returns a :class:`Session` for context-management.

    :rtype: Session
    """

    return Session()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # -*- coding: utf-8 -*-

"""
requests.structures
~~~~~~~~~~~~~~~~~~~

Data structures that power Requests.
"""

import collections

from .compat import OrderedDict


class CaseInsensitiveDict(collections.MutableMapping):
    """A case-insensitive ``dict``-like object.

    Implements all methods and operations of
    ``collections.MutableMapping`` as well as dict's ``copy``. Also
    provides ``lower_items``.

    All keys are expected to be strings. The structure remembers the
    case of the last key to be set, and ``iter(instance)``,
    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``
    will contain case-sensitive keys. However, querying and contains
    testing is case insensitive::

        cid = CaseInsensitiveDict()
        cid['Accept'] = 'application/json'
        cid['aCCEPT'] == 'application/json'  # True
        list(cid) == ['Accept']  # True

    For example, ``headers['content-encoding']`` will return the
    value of a ``'Content-Encoding'`` response header, regardless
    of how the header name was originally stored.

    If the constructor, ``.update``, or equality comparison
    operations are given keys that have equal ``.lower()``s, the
    behavior is undefined.
    """

    def __init__(self, data=None, **kwargs):
        self._store = OrderedDict()
        if data is None:
            data = {}
        self.update(data, **kwargs)

    def __setitem__(self, key, value):
        # Use the lowercased key for lookups, but store the actual
        # key alongside the value.
        self._store[key.lower()] = (key, value)

    def __getitem__(self, key):
        return self._store[key.lower()][1]

    def __delitem__(self, key):
        del self._store[key.lower()]

    def __iter__(self):
        return (casedkey for casedkey, mappedvalue in self._store.values())

    def __len__(self):
        return len(self._store)

    def lower_items(self):
        """Like iteritems(), but with all lowercase keys."""
        return (
            (lowerkey, keyval[1])
            for (lowerkey, keyval)
            in self._store.items()
        )

    def __eq__(self, other):
        if isinstance(other, collections.Mapping):
            other = CaseInsensitiveDict(other)
        else:
            return NotImplemented
        # Compare insensitively
        return dict(self.lower_items()) == dict(other.lower_items())

    # Copy is required
    def copy(self):
        return CaseInsensitiveDict(self._store.values())

    def __repr__(self):
        return str(dict(self.items()))


class LookupDict(dict):
    """Dictionary lookup object."""

    def __init__(self, name=None):
        self.name = name
        super(LookupDict, self).__init__()

    def __repr__(self):
        return '<lookup \'%s\'>' % (self.name)

    def __getitem__(self, key):
        # We allow fall-through here, so values default to None

        return self.__dict__.get(key, None)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # -*- coding: utf-8 -*-

"""
requests.utils
~~~~~~~~~~~~~~

This module provides utility functions that are used within Requests
that are also useful for external consumption.
"""

import cgi
import codecs
import collections
import io
import os
import re
import socket
import struct
import warnings

from . import __version__
from . import certs
# to_native_string is unused here, but imported here for backwards compatibility
from ._internal_utils import to_native_string
from .compat import parse_http_list as _parse_list_header
from .compat import (
    quote, urlparse, bytes, str, OrderedDict, unquote, getproxies,
    proxy_bypass, urlunparse, basestring, integer_types)
from .cookies import RequestsCookieJar, cookiejar_from_dict
from .structures import CaseInsensitiveDict
from .exceptions import (
    InvalidURL, InvalidHeader, FileModeWarning, UnrewindableBodyError)

_hush_pyflakes = (RequestsCookieJar,)

NETRC_FILES = ('.netrc', '_netrc')

DEFAULT_CA_BUNDLE_PATH = certs.where()


def dict_to_sequence(d):
    """Returns an internal sequence dictionary update."""

    if hasattr(d, 'items'):
        d = d.items()

    return d


def super_len(o):
    total_length = None
    current_position = 0

    if hasattr(o, '__len__'):
        total_length = len(o)

    elif hasattr(o, 'len'):
        total_length = o.len

    elif hasattr(o, 'fileno'):
        try:
            fileno = o.fileno()
        except io.UnsupportedOperation:
            pass
        else:
            total_length = os.fstat(fileno).st_size

            # Having used fstat to determine the file length, we need to
            # confirm that this file was opened up in binary mode.
            if 'b' not in o.mode:
                warnings.warn((
                    "Requests has determined the content-length for this "
                    "request using the binary size of the file: however, the "
                    "file has been opened in text mode (i.e. without the 'b' "
                    "flag in the mode). This may lead to an incorrect "
                    "content-length. In Requests 3.0, support will be removed "
                    "for files in text mode."),
                    FileModeWarning
                )

    if hasattr(o, 'tell'):
        try:
            current_position = o.tell()
        except (OSError, IOError):
            # This can happen in some weird situations, such as when the file
            # is actually a special file descriptor like stdin. In this
            # instance, we don't know what the length is, so set it to zero and
            # let requests chunk it instead.
            if total_length is not None:
                current_position = total_length
        else:
            if hasattr(o, 'seek') and total_length is None:
                # StringIO and BytesIO have seek but no useable fileno

                # seek to end of file
                o.seek(0, 2)
                total_length = o.tell()

                # seek back to current position to support
                # partially read file-like objects
                o.seek(current_position or 0)

    if total_length is None:
        total_length = 0

    return max(0, total_length - current_position)


def get_netrc_auth(url, raise_errors=False):
    """Returns the Requests tuple auth for a given url from netrc."""

    try:
        from netrc import netrc, NetrcParseError

        netrc_path = None

        for f in NETRC_FILES:
            try:
                loc = os.path.expanduser('~/{0}'.format(f))
            except KeyError:
                # os.path.expanduser can fail when $HOME is undefined and
                # getpwuid fails. See http://bugs.python.org/issue20164 &
                # https://github.com/kennethreitz/requests/issues/1846
                return

            if os.path.exists(loc):
                netrc_path = loc
                break

        # Abort early if there isn't one.
        if netrc_path is None:
            return

        ri = urlparse(url)

        # Strip port numbers from netloc. This weird `if...encode`` dance is
        # used for Python 3.2, which doesn't support unicode literals.
        splitstr = b':'
        if isinstance(url, str):
            splitstr = splitstr.decode('ascii')
        host = ri.netloc.split(splitstr)[0]

        try:
            _netrc = netrc(netrc_path).authenticators(host)
            if _netrc:
                # Return with login / password
                login_i = (0 if _netrc[0] else 1)
                return (_netrc[login_i], _netrc[2])
        except (NetrcParseError, IOError):
            # If there was a parsing error or a permissions issue reading the file,
            # we'll just skip netrc auth unless explicitly asked to raise errors.
            if raise_errors:
                raise

    # AppEngine hackiness.
    except (ImportError, AttributeError):
        pass


def guess_filename(obj):
    """Tries to guess the filename of the given object."""
    name = getattr(obj, 'name', None)
    if (name and isinstance(name, basestring) and name[0] != '<' and
            name[-1] != '>'):
        return os.path.basename(name)


def from_key_val_list(value):
    """Take an object and test to see if it can be represented as a
    dictionary. Unless it can not be represented as such, return an
    OrderedDict, e.g.,

    ::

        >>> from_key_val_list([('key', 'val')])
        OrderedDict([('key', 'val')])
        >>> from_key_val_list('string')
        ValueError: need more than 1 value to unpack
        >>> from_key_val_list({'key': 'val'})
        OrderedDict([('key', 'val')])

    :rtype: OrderedDict
    """
    if value is None:
        return None

    if isinstance(value, (str, bytes, bool, int)):
        raise ValueError('cannot encode objects that are not 2-tuples')

    return OrderedDict(value)


def to_key_val_list(value):
    """Take an object and test to see if it can be represented as a
    dictionary. If it can be, return a list of tuples, e.g.,

    ::

        >>> to_key_val_list([('key', 'val')])
        [('key', 'val')]
        >>> to_key_val_list({'key': 'val'})
        [('key', 'val')]
        >>> to_key_val_list('string')
        ValueError: cannot encode objects that are not 2-tuples.

    :rtype: list
    """
    if value is None:
        return None

    if isinstance(value, (str, bytes, bool, int)):
        raise ValueError('cannot encode objects that are not 2-tuples')

    if isinstance(value, collections.Mapping):
        value = value.items()

    return list(value)


# From mitsuhiko/werkzeug (used with permission).
def parse_list_header(value):
    """Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Quotes are removed automatically after parsing.

    It basically works like :func:`parse_set_header` just that items
    may appear multiple times and case sensitivity is preserved.

    The return value is a standard :class:`list`:

    >>> parse_list_header('token, "quoted value"')
    ['token', 'quoted value']

    To create a header from the :class:`list` again, use the
    :func:`dump_header` function.

    :param value: a string with a list header.
    :return: :class:`list`
    :rtype: list
    """
    result = []
    for item in _parse_list_header(value):
        if item[:1] == item[-1:] == '"':
            item = unquote_header_value(item[1:-1])
        result.append(item)
    return result


# From mitsuhiko/werkzeug (used with permission).
def parse_dict_header(value):
    """Parse lists of key, value pairs as described by RFC 2068 Section 2 and
    convert them into a python dict:

    >>> d = parse_dict_header('foo="is a fish", bar="as well"')
    >>> type(d) is dict
    True
    >>> sorted(d.items())
    [('bar', 'as well'), ('foo', 'is a fish')]

    If there is no value for a key it will be `None`:

    >>> parse_dict_header('key_without_value')
    {'key_without_value': None}

    To create a header from the :class:`dict` again, use the
    :func:`dump_header` function.

    :param value: a string with a dict header.
    :return: :class:`dict`
    :rtype: dict
    """
    result = {}
    for item in _parse_list_header(value):
        if '=' not in item:
            result[item] = None
            continue
        name, value = item.split('=', 1)
        if value[:1] == value[-1:] == '"':
            value = unquote_header_value(value[1:-1])
        result[name] = value
    return result


# From mitsuhiko/werkzeug (used with permission).
def unquote_header_value(value, is_filename=False):
    r"""Unquotes a header value.  (Reversal of :func:`quote_header_value`).
    This does not use the real unquoting but what browsers are actually
    using for quoting.

    :param value: the header value to unquote.
    :rtype: str
    """
    if value and value[0] == value[-1] == '"':
        # this is not the real unquoting, but fixing this so that the
        # RFC is met will result in bugs with internet explorer and
        # probably some other browsers as well.  IE for example is
        # uploading files with "C:\foo\bar.txt" as filename
        value = value[1:-1]

        # if this is a filename and the starting characters look like
        # a UNC path, then just return the value without quotes.  Using the
        # replace sequence below on a UNC path has the effect of turning
        # the leading double slash into a single slash and then
        # _fix_ie_filename() doesn't work correctly.  See #458.
        if not is_filename or value[:2] != '\\\\':
            return value.replace('\\\\', '\\').replace('\\"', '"')
    return value


def dict_from_cookiejar(cj):
    """Returns a key/value dictionary from a CookieJar.

    :param cj: CookieJar object to extract cookies from.
    :rtype: dict
    """

    cookie_dict = {}

    for cookie in cj:
        cookie_dict[cookie.name] = cookie.value

    return cookie_dict


def add_dict_to_cookiejar(cj, cookie_dict):
    """Returns a CookieJar from a key/value dictionary.

    :param cj: CookieJar to insert cookies into.
    :param cookie_dict: Dict of key/values to insert into CookieJar.
    :rtype: CookieJar
    """

    return cookiejar_from_dict(cookie_dict, cj)


def get_encodings_from_content(content):
    """Returns encodings from given content string.

    :param content: bytestring to extract encodings from.
    """
    warnings.warn((
        'In requests 3.0, get_encodings_from_content will be removed. For '
        'more information, please see the discussion on issue #2266. (This'
        ' warning should only appear once.)'),
        DeprecationWarning)

    charset_re = re.compile(r'<meta.*?charset=["\']*(.+?)["\'>]', flags=re.I)
    pragma_re = re.compile(r'<meta.*?content=["\']*;?charset=(.+?)["\'>]', flags=re.I)
    xml_re = re.compile(r'^<\?xml.*?encoding=["\']*(.+?)["\'>]')

    return (charset_re.findall(content) +
            pragma_re.findall(content) +
            xml_re.findall(content))


def get_encoding_from_headers(headers):
    """Returns encodings from given HTTP Header Dict.

    :param headers: dictionary to extract encoding from.
    :rtype: str
    """

    content_type = headers.get('content-type')

    if not content_type:
        return None

    content_type, params = cgi.parse_header(content_type)

    if 'charset' in params:
        return params['charset'].strip("'\"")

    if 'text' in content_type:
        return 'ISO-8859-1'


def stream_decode_response_unicode(iterator, r):
    """Stream decodes a iterator."""

    if r.encoding is None:
        for item in iterator:
            yield item
        return

    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')
    for chunk in iterator:
        rv = decoder.decode(chunk)
        if rv:
            yield rv
    rv = decoder.decode(b'', final=True)
    if rv:
        yield rv


def iter_slices(string, slice_length):
    """Iterate over slices of a string."""
    pos = 0
    if slice_length is None or slice_length <= 0:
        slice_length = len(string)
    while pos < len(string):
        yield string[pos:pos + slice_length]
        pos += slice_length


def get_unicode_from_response(r):
    """Returns the requested content back in unicode.

    :param r: Response object to get unicode content from.

    Tried:

    1. charset from content-type
    2. fall back and replace all unicode characters

    :rtype: str
    """
    warnings.warn((
        'In requests 3.0, get_unicode_from_response will be removed. For '
        'more information, please see the discussion on issue #2266. (This'
        ' warning should only appear once.)'),
        DeprecationWarning)

    tried_encodings = []

    # Try charset from content-type
    encoding = get_encoding_from_headers(r.headers)

    if encoding:
        try:
            return str(r.content, encoding)
        except UnicodeError:
            tried_encodings.append(encoding)

    # Fall back:
    try:
        return str(r.content, encoding, errors='replace')
    except TypeError:
        return r.content


# The unreserved URI characters (RFC 3986)
UNRESERVED_SET = frozenset(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    + "0123456789-._~")


def unquote_unreserved(uri):
    """Un-escape any percent-escape sequences in a URI that are unreserved
    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.

    :rtype: str
    """
    parts = uri.split('%')
    for i in range(1, len(parts)):
        h = parts[i][0:2]
        if len(h) == 2 and h.isalnum():
            try:
                c = chr(int(h, 16))
            except ValueError:
                raise InvalidURL("Invalid percent-escape sequence: '%s'" % h)

            if c in UNRESERVED_SET:
                parts[i] = c + parts[i][2:]
            else:
                parts[i] = '%' + parts[i]
        else:
            parts[i] = '%' + parts[i]
    return ''.join(parts)


def requote_uri(uri):
    """Re-quote the given URI.

    This function passes the given URI through an unquote/quote cycle to
    ensure that it is fully and consistently quoted.

    :rtype: str
    """
    safe_with_percent = "!#$%&'()*+,/:;=?@[]~"
    safe_without_percent = "!#$&'()*+,/:;=?@[]~"
    try:
        # Unquote only the unreserved characters
        # Then quote only illegal characters (do not quote reserved,
        # unreserved, or '%')
        return quote(unquote_unreserved(uri), safe=safe_with_percent)
    except InvalidURL:
        # We couldn't unquote the given URI, so let's try quoting it, but
        # there may be unquoted '%'s in the URI. We need to make sure they're
        # properly quoted so they do not cause issues elsewhere.
        return quote(uri, safe=safe_without_percent)


def address_in_network(ip, net):
    """This function allows you to check if on IP belongs to a network subnet

    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24
             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24

    :rtype: bool
    """
    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]
    netaddr, bits = net.split('/')
    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]
    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask
    return (ipaddr & netmask) == (network & netmask)


def dotted_netmask(mask):
    """Converts mask from /xx format to xxx.xxx.xxx.xxx

    Example: if mask is 24 function returns 255.255.255.0

    :rtype: str
    """
    bits = 0xffffffff ^ (1 << 32 - mask) - 1
    return socket.inet_ntoa(struct.pack('>I', bits))


def is_ipv4_address(string_ip):
    """
    :rtype: bool
    """
    try:
        socket.inet_aton(string_ip)
    except socket.error:
        return False
    return True


def is_valid_cidr(string_network):
    """
    Very simple check of the cidr format in no_proxy variable.

    :rtype: bool
    """
    if string_network.count('/') == 1:
        try:
            mask = int(string_network.split('/')[1])
        except ValueError:
            return False

        if mask < 1 or mask > 32:
            return False

        try:
            socket.inet_aton(string_network.split('/')[0])
        except socket.error:
            return False
    else:
        return False
    return True


def should_bypass_proxies(url):
    """
    Returns whether we should bypass proxies or not.

    :rtype: bool
    """
    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())

    # First check whether no_proxy is defined. If it is, check that the URL
    # we're getting isn't in the no_proxy list.
    no_proxy = get_proxy('no_proxy')
    netloc = urlparse(url).netloc

    if no_proxy:
        # We need to check whether we match here. We need to see if we match
        # the end of the netloc, both with and without the port.
        no_proxy = (
            host for host in no_proxy.replace(' ', '').split(',') if host
        )

        ip = netloc.split(':')[0]
        if is_ipv4_address(ip):
            for proxy_ip in no_proxy:
                if is_valid_cidr(proxy_ip):
                    if address_in_network(ip, proxy_ip):
                        return True
                elif ip == proxy_ip:
                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &
                    # matches the IP of the index
                    return True
        else:
            for host in no_proxy:
                if netloc.endswith(host) or netloc.split(':')[0].endswith(host):
                    # The URL does match something in no_proxy, so we don't want
                    # to apply the proxies on this URL.
                    return True

    # If the system proxy settings indicate that this URL should be bypassed,
    # don't proxy.
    # The proxy_bypass function is incredibly buggy on OS X in early versions
    # of Python 2.6, so allow this call to fail. Only catch the specific
    # exceptions we've seen, though: this call failing in other ways can reveal
    # legitimate problems.
    try:
        bypass = proxy_bypass(netloc)
    except (TypeError, socket.gaierror):
        bypass = False

    if bypass:
        return True

    return False


def get_environ_proxies(url):
    """
    Return a dict of environment proxies.

    :rtype: dict
    """
    if should_bypass_proxies(url):
        return {}
    else:
        return getproxies()


def select_proxy(url, proxies):
    """Select a proxy for the url, if applicable.

    :param url: The url being for the request
    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
    """
    proxies = proxies or {}
    urlparts = urlparse(url)
    if urlparts.hostname is None:
        return proxies.get(urlparts.scheme, proxies.get('all'))

    proxy_keys = [
        urlparts.scheme + '://' + urlparts.hostname,
        urlparts.scheme,
        'all://' + urlparts.hostname,
        'all',
    ]
    proxy = None
    for proxy_key in proxy_keys:
        if proxy_key in proxies:
            proxy = proxies[proxy_key]
            break

    return proxy


def default_user_agent(name="python-requests"):
    """
    Return a string representing the default user agent.

    :rtype: str
    """
    return '%s/%s' % (name, __version__)


def default_headers():
    """
    :rtype: requests.structures.CaseInsensitiveDict
    """
    return CaseInsensitiveDict({
        'User-Agent': default_user_agent(),
        'Accept-Encoding': ', '.join(('gzip', 'deflate')),
        'Accept': '*/*',
        'Connection': 'keep-alive',
    })


def parse_header_links(value):
    """Return a dict of parsed link headers proxies.

    i.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"

    :rtype: list
    """

    links = []

    replace_chars = ' \'"'

    for val in re.split(', *<', value):
        try:
            url, params = val.split(';', 1)
        except ValueError:
            url, params = val, ''

        link = {'url': url.strip('<> \'"')}

        for param in params.split(';'):
            try:
                key, value = param.split('=')
            except ValueError:
                break

            link[key.strip(replace_chars)] = value.strip(replace_chars)

        links.append(link)

    return links


# Null bytes; no need to recreate these on each call to guess_json_utf
_null = '\x00'.encode('ascii')  # encoding to ASCII for Python 3
_null2 = _null * 2
_null3 = _null * 3


def guess_json_utf(data):
    """
    :rtype: str
    """
    # JSON always starts with two ASCII characters, so detection is as
    # easy as counting the nulls and from their location and count
    # determine the encoding. Also detect a BOM, if present.
    sample = data[:4]
    if sample in (codecs.BOM_UTF32_LE, codecs.BOM32_BE):
        return 'utf-32'     # BOM included
    if sample[:3] == codecs.BOM_UTF8:
        return 'utf-8-sig'  # BOM included, MS style (discouraged)
    if sample[:2] in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
        return 'utf-16'     # BOM included
    nullcount = sample.count(_null)
    if nullcount == 0:
        return 'utf-8'
    if nullcount == 2:
        if sample[::2] == _null2:   # 1st and 3rd are null
            return 'utf-16-be'
        if sample[1::2] == _null2:  # 2nd and 4th are null
            return 'utf-16-le'
        # Did not detect 2 valid UTF-16 ascii-range characters
    if nullcount == 3:
        if sample[:3] == _null3:
            return 'utf-32-be'
        if sample[1:] == _null3:
            return 'utf-32-le'
        # Did not detect a valid UTF-32 ascii-range character
    return None


def prepend_scheme_if_needed(url, new_scheme):
    """Given a URL that may or may not have a scheme, prepend the given scheme.
    Does not replace a present scheme with the one provided as an argument.

    :rtype: str
    """
    scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)

    # urlparse is a finicky beast, and sometimes decides that there isn't a
    # netloc present. Assume that it's being over-cautious, and switch netloc
    # and path if urlparse decided there was no netloc.
    if not netloc:
        netloc, path = path, netloc

    return urlunparse((scheme, netloc, path, params, query, fragment))


def get_auth_from_url(url):
    """Given a url with authentication components, extract them into a tuple of
    username,password.

    :rtype: (str,str)
    """
    parsed = urlparse(url)

    try:
        auth = (unquote(parsed.username), unquote(parsed.password))
    except (AttributeError, TypeError):
        auth = ('', '')

    return auth


# Moved outside of function to avoid recompile every call
_CLEAN_HEADER_REGEX_BYTE = re.compile(b'^\\S[^\\r\\n]*$|^$')
_CLEAN_HEADER_REGEX_STR = re.compile(r'^\S[^\r\n]*$|^$')

def check_header_validity(header):
    """Verifies that header value is a string which doesn't contain
    leading whitespace or return characters. This prevents unintended
    header injection.

    :param header: tuple, in the format (name, value).
    """
    name, value = header

    if isinstance(value, bytes):
        pat = _CLEAN_HEADER_REGEX_BYTE
    else:
        pat = _CLEAN_HEADER_REGEX_STR
    try:
        if not pat.match(value):
            raise InvalidHeader("Invalid return character or leading space in header: %s" % name)
    except TypeError:
        raise InvalidHeader("Header value %s must be of type str or bytes, "
                            "not %s" % (value, type(value)))


def urldefragauth(url):
    """
    Given a url remove the fragment and the authentication part.

    :rtype: str
    """
    scheme, netloc, path, params, query, fragment = urlparse(url)

    # see func:`prepend_scheme_if_needed`
    if not netloc:
        netloc, path = path, netloc

    netloc = netloc.rsplit('@', 1)[-1]

    return urlunparse((scheme, netloc, path, params, query, ''))

def rewind_body(prepared_request):
    """Move file pointer back to its recorded starting position
    so it can be read again on redirect.
    """
    body_seek = getattr(prepared_request.body, 'seek', None)
    if body_seek is not None and isinstance(prepared_request._body_position, integer_types):
        try:
            body_seek(prepared_request._body_position)
        except (IOError, OSError):
            raise UnrewindableBodyError("An error occured when rewinding request "
                                        "body for redirect.")
    else:
        raise UnrewindableBodyError("Unable to rewind request body for redirect.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
.QX                 @   s  d  Z  d Z d Z d Z d Z d Z d Z y d d l m Z e j	   Wn e
 k
 r\ Yn Xd	 d
 l Z d d l m Z e j d e  d d l m Z d d l m Z m Z m Z d d l m Z m Z m Z m Z m Z m Z m Z m Z d d l m Z m  Z  d d l! m" Z" d d l# m$ Z$ m% Z% m& Z& m' Z' m( Z( m) Z) m* Z* m+ Z+ m, Z, d	 d
 l- Z- y d	 d l- m. Z. Wn+ e
 k
 rGd d   d e- j/  Z. Yn Xe- j0 e1  j2 e.    e j d e* d d d
 S)a  
Requests HTTP library
~~~~~~~~~~~~~~~~~~~~~

Requests is an HTTP library, written in Python, for human beings. Basic GET
usage:

   >>> import requests
   >>> r = requests.get('https://www.python.org')
   >>> r.status_code
   200
   >>> 'Python is a programming language' in r.content
   True

... or POST:

   >>> payload = dict(key1='value1', key2='value2')
   >>> r = requests.post('http://httpbin.org/post', data=payload)
   >>> print(r.text)
   {
     ...
     "form": {
       "key2": "value2",
       "key1": "value1"
     },
     ...
   }

The other HTTP methods are supported - see `requests.api`. Full documentation
is at <http://python-requests.org>.

:copyright: (c) 2016 by Kenneth Reitz.
:license: Apache 2.0, see LICENSE for more details.
Zrequestsz2.12.4i zKenneth Reitzz
Apache 2.0zCopyright 2016 Kenneth Reitz   )	pyopenssl    N)DependencyWarningignore)utils)RequestResponsePreparedRequest)requestgetheadpostpatchputdeleteoptions)sessionSession)codes)	RequestExceptionTimeoutURLRequiredTooManyRedirects	HTTPErrorConnectionErrorFileModeWarningConnectTimeoutReadTimeout)NullHandlerc               @   s   e  Z d  Z d d   Z d S)r   c             C   s   d  S)N )selfrecordr   r   3/usr/lib/python3/dist-packages/requests/__init__.pyemitP   s    zNullHandler.emitN)__name__
__module____qualname__r#   r   r   r   r"   r   O   s   r   defaultappendT)3__doc__Z	__title____version__Z	__build__
__author__Z__license__Z__copyright__Zpackages.urllib3.contribr   Zinject_into_urllib3ImportErrorwarningsZpackages.urllib3.exceptionsr   simplefilter r   Zmodelsr   r   r	   Zapir
   r   r   r   r   r   r   r   Zsessionsr   r   Zstatus_codesr   
exceptionsr   r   r   r   r   r   r   r   r   Zloggingr   ZHandlerZ	getLoggerr$   Z
addHandlerr   r   r   r"   <module>)   s6   :@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
QXM                 @   s?  d  Z  d d l Z d d l Z d d l m Z d d l m Z m Z d d l	 m
 Z
 d d l m Z d d l m Z d d	 l m Z m Z d d
 l m Z m Z m Z m Z m Z m Z m Z d d l m Z d d l m Z d d l m Z d d l m  Z! d d l m" Z" d d l m# Z# d d l m$ Z% d d l m& Z& d d l m' Z' d d l m( Z) d d l m* Z* d d l+ m, Z, d d l- m. Z. m/ Z/ m0 Z0 m( Z( m$ Z$ m1 Z1 m2 Z2 d d l3 m4 Z4 y d d l5 m6 Z6 Wn e7 k
 rd d   Z6 Yn Xd Z8 d Z9 d Z: d Z; Gd d   d e<  Z= Gd  d!   d! e=  Z> d S)"z
requests.adapters
~~~~~~~~~~~~~~~~~

This module contains the transport adapters that Requests uses to define
and maintain connections.
    N   )Response)PoolManagerproxy_from_url)HTTPResponse)Timeout)Retry)urlparse
basestring)DEFAULT_CA_BUNDLE_PATHget_encoding_from_headersprepend_scheme_if_neededget_auth_from_urlurldefragauthselect_proxyto_native_string)CaseInsensitiveDict)ClosedPoolError)ConnectTimeoutError)	HTTPError)MaxRetryError)NewConnectionError)
ProxyError)ProtocolError)ReadTimeoutError)SSLError)ResponseError)extract_cookies_to_jar)ConnectionErrorConnectTimeoutReadTimeoutr   r   
RetryErrorInvalidSchema)_basic_auth_str)SOCKSProxyManagerc              O   s   t  d   d  S)Nz'Missing dependencies for SOCKS support.)r"   )argskwargs r'   3/usr/lib/python3/dist-packages/requests/adapters.pyr$   *   s    r$   F
   c                   sO   e  Z d  Z d Z   f d d   Z d d d d d d d  Z d	 d
   Z   S)BaseAdapterzThe Base Transport Adapterc                s   t  t |   j   d  S)N)superr*   __init__)self)	__class__r'   r(   r,   6   s    zBaseAdapter.__init__FNTc             C   s
   t   d S)a  Sends PreparedRequest object. Returns Response object.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param verify: (optional) Whether to verify SSL certificates.
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        N)NotImplementedError)r-   requeststreamtimeoutverifycertproxiesr'   r'   r(   send9   s    zBaseAdapter.sendc             C   s
   t   d S)z!Cleans up adapter specific items.N)r/   )r-   r'   r'   r(   closeI   s    zBaseAdapter.close)__name__
__module____qualname____doc__r,   r6   r7   r'   r'   )r.   r(   r*   3   s
   	r*   c                   s   e  Z d  Z d Z d d d d d g Z e e e e   f d d  Z d	 d
   Z	 d d   Z
 e d d  Z d d   Z d d   Z d d   Z d d d  Z d d   Z d d   Z d d   Z d d   Z d  d d! d d d" d#  Z   S)$HTTPAdaptera  The built-in HTTP Adapter for urllib3.

    Provides a general-case interface for Requests sessions to contact HTTP and
    HTTPS urls by implementing the Transport Adapter interface. This class will
    usually be created by the :class:`Session <Session>` class under the
    covers.

    :param pool_connections: The number of urllib3 connection pools to cache.
    :param pool_maxsize: The maximum number of connections to save in the pool.
    :param max_retries: The maximum number of retries each connection
        should attempt. Note, this applies only to failed DNS lookups, socket
        connections and connection timeouts, never to requests where data has
        made it to the server. By default, Requests does not retry failed
        connections. If you need granular control over the conditions under
        which we retry a request, import urllib3's ``Retry`` class and pass
        that instead.
    :param pool_block: Whether the connection pool should block for connections.

    Usage::

      >>> import requests
      >>> s = requests.Session()
      >>> a = requests.adapters.HTTPAdapter(max_retries=3)
      >>> s.mount('http://', a)
    max_retriesconfig_pool_connections_pool_maxsize_pool_blockc                s   | t  k r$ t d d d |  _ n t j |  |  _ i  |  _ i  |  _ t t |   j   | |  _	 | |  _
 | |  _ |  j | | d | d  S)Nr   readFblock)DEFAULT_RETRIESr   r=   Zfrom_intr>   proxy_managerr+   r<   r,   r?   r@   rA   init_poolmanager)r-   Zpool_connectionsZpool_maxsizer=   Z
pool_block)r.   r'   r(   r,   k   s    					zHTTPAdapter.__init__c                s    t    f d d     j D  S)Nc             3   s'   |  ] } | t    | d   f Vq d  S)N)getattr).0attr)r-   r'   r(   	<genexpr>~   s    z+HTTPAdapter.__getstate__.<locals>.<genexpr>)dict	__attrs__)r-   r'   )r-   r(   __getstate__}   s    zHTTPAdapter.__getstate__c             C   sb   i  |  _  i  |  _ x* | j   D] \ } } t |  | |  q W|  j |  j |  j d |  j d  S)NrC   )rE   r>   itemssetattrrF   r?   r@   rA   )r-   staterI   valuer'   r'   r(   __setstate__   s    		zHTTPAdapter.__setstate__c          
   K   sF   | |  _  | |  _ | |  _ t d | d | d | d d |  |  _ d S)a  Initializes a urllib3 PoolManager.

        This method should not be called from user code, and is only
        exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param connections: The number of urllib3 connection pools to cache.
        :param maxsize: The maximum number of connections to save in the pool.
        :param block: Block when no free connections are available.
        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
        	num_poolsmaxsizerC   strictTN)r?   r@   rA   r   poolmanager)r-   ZconnectionsrT   rC   Zpool_kwargsr'   r'   r(   rF      s
    			zHTTPAdapter.init_poolmanagerc             K   s   | |  j  k r |  j  | } n | j   j d  r t |  \ } } t | d | d | d |  j d |  j d |  j | } |  j  | <nJ |  j |  } t	 | d | d |  j d |  j d |  j | } |  j  | <| S)a  Return urllib3 ProxyManager for the given proxy.

        This method should not be called from user code, and is only
        exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param proxy: The proxy to return a urllib3 ProxyManager for.
        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.
        :returns: ProxyManager
        :rtype: requests.packages.urllib3.ProxyManager
        socksusernamepasswordrS   rT   rC   proxy_headers)
rE   lower
startswithr   r$   r?   r@   rA   rZ   r   )r-   proxyZproxy_kwargsZmanagerrX   rY   rZ   r'   r'   r(   proxy_manager_for   s*    				zHTTPAdapter.proxy_manager_forc             C   s   | j    j d  r | r d } | d k	 r3 | } | s? t } | sQ t d   d | _ t j j |  sx | | _ q | | _	 n d | _ d | _ d | _	 | r t
 | t  s | d | _ | d | _ n	 | | _ d S)	a  Verify a SSL certificate. This method should not be called from user
        code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param conn: The urllib3 connection object associated with the cert.
        :param url: The requested URL.
        :param verify: Whether we should actually verify the certificate.
        :param cert: The SSL certificate to verify.
        httpsNTz4Could not find a suitable SSL CA certificate bundle.ZCERT_REQUIREDZ	CERT_NONEr   r   )r[   r\   r   	ExceptionZ	cert_reqsospathisdirZca_certsZca_cert_dir
isinstancer
   Z	cert_fileZkey_file)r-   connurlr3   r4   Zcert_locr'   r'   r(   cert_verify   s(    
				zHTTPAdapter.cert_verifyc             C   s   t    } t | d d  | _ t t | d i    | _ t | j  | _ | | _ | j j | _ t	 | j
 t  r | j
 j d  | _
 n | j
 | _
 t | j | |  | | _ |  | _ | S)a  Builds a :class:`Response <requests.Response>` object from a urllib3
        response. This should not be called from user code, and is only exposed
        for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`

        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.
        :param resp: The urllib3 response object.
        :rtype: requests.Response
        ZstatusNheaderszutf-8)r   rG   Zstatus_coder   rh   r   encodingrawreasonrd   rf   bytesdecoder   cookiesr0   
connection)r-   ZreqrespZresponser'   r'   r(   build_response   s    
				zHTTPAdapter.build_responseNc             C   ss   t  | |  } | rE t | d  } |  j |  } | j |  } n* t |  } | j   } |  j j |  } | S)a  Returns a urllib3 connection for the given URL. This should not be
        called from user code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param url: The URL to connect to.
        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
        :rtype: requests.packages.urllib3.ConnectionPool
        Zhttp)r   r   r^   Zconnection_from_urlr	   ZgeturlrV   )r-   rf   r5   r]   rE   re   Zparsedr'   r'   r(   get_connection  s    	zHTTPAdapter.get_connectionc             C   s5   |  j  j   x! |  j j   D] } | j   q Wd S)zDisposes of any internal state.

        Currently, this closes the PoolManager and any active ProxyManager,
        which closes any pooled connections.
        N)rV   clearrE   values)r-   r]   r'   r'   r(   r7   ,  s    zHTTPAdapter.closec       	      C   s   t  | j |  } t | j  j } | o3 | d k } d } | rf t |  j j   } | j d  } | j } | r | r t | j  } | S)a?  Obtain the url to use when making the final request.

        If the message is being sent through a HTTP proxy, the full URL has to
        be used. Otherwise, we should only use the path portion of the URL.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.
        :rtype: str
        r_   FrW   )r   rf   r	   schemer[   r\   Zpath_urlr   )	r-   r0   r5   r]   ru   Zis_proxied_http_requestZusing_socks_proxyZproxy_schemerf   r'   r'   r(   request_url6  s    	zHTTPAdapter.request_urlc             K   s   d S)a"  Add any headers needed by the connection. As of v2.0 this does
        nothing by default, but is left for overriding by users that subclass
        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.
        :param kwargs: The keyword arguments from the call to send().
        Nr'   )r-   r0   r&   r'   r'   r(   add_headersS  s    zHTTPAdapter.add_headersc             C   s5   i  } t  |  \ } } | r1 t | |  | d <| S)a
  Returns a dictionary of the headers to add to any request sent
        through a proxy. This works with urllib3 magic to ensure that they are
        correctly sent to the proxy, rather than in a tunnelled request if
        CONNECT is being used.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param proxies: The url of the proxy being used for this request.
        :rtype: dict
        zProxy-Authorization)r   r#   )r-   r]   rh   rX   rY   r'   r'   r(   rZ   a  s    zHTTPAdapter.proxy_headersFTc          ,   C   s  |  j  | j |  } |  j | | j | |  |  j | |  } |  j |  | j d k ph d | j k }	 t | t  r y% | \ }
 } t	 d |
 d |  } Wq t
 k
 r } z  d j |  } t
 |   WYd d } ~ Xq Xn t	 d | d |  } y|	 s[| j d | j d | d | j d	 | j d
 d d d d d d d d |  j d |  
} nkt | d  rs| j } | j d t  } y)| j | j | d d x- | j j   D] \ } } | j | |  qW| j   xd | j D]Y } | j t t |   d d  j d   | j d  | j |  | j d  qW| j d  y | j d d  } Wn t k
 r| j   } Yn Xt j | d | d | d d d d } Wn | j     Yn XWnt  t! j" f k
 r	} z t# | d |  WYd d } ~ Xnt$ k
 r} z t | j% t&  rQt | j% t'  sQt( | d |  t | j% t)  rut* | d |  t | j% t+  rt, | d |  t# | d |  WYd d } ~ Xn t- k
 r} z t# | d |  WYd d } ~ Xn t+ k
 r#} z t, |   WYd d } ~ Xnv t. t/ f k
 r} zP t | t.  r_t0 | d |  n' t | t1  rt2 | d |  n   WYd d } ~ Xn X|  j3 | |  S)a  Sends PreparedRequest object. Returns Response object.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param verify: (optional) Whether to verify SSL certificates.
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        NzContent-LengthconnectrB   zsInvalid timeout {0}. Pass a (connect, read) timeout tuple, or a single float to set both timeouts to the same valuemethodrf   bodyrh   ZredirectFZassert_same_hostZpreload_contentZdecode_contentZretriesr2   
proxy_poolZskip_accept_encodingT   zutf-8s   
s   0

	bufferingZpoolro   r0   )4rr   rf   rg   rv   rw   rz   rh   rd   tupleTimeoutSauce
ValueErrorformatZurlopenry   r=   hasattrr{   Z	_get_connDEFAULT_POOL_TIMEOUTZ
putrequestrN   Z	putheaderZ
endheadersr6   hexlenencodeZgetresponse	TypeErrorr   Zfrom_httplibr7   r   socketerrorr   r   rk   r   r   r   r   r!   _ProxyErrorr   r   	_SSLError
_HTTPErrorr   r   r    rq   )r-   r0   r1   r2   r3   r4   r5   re   rf   Zchunkedrx   rB   eerrrp   Zlow_connheaderrQ   irr'   r'   r(   r6   w  s    	"						
,
$$$zHTTPAdapter.send)r8   r9   r:   r;   rL   DEFAULT_POOLSIZErD   DEFAULT_POOLBLOCKr,   rM   rR   rF   r^   rg   rq   rr   r7   rv   rw   rZ   r6   r'   r'   )r.   r(   r<   N   s$   	%*%
r<   )?r;   os.pathra   r   Zmodelsr   Zpackages.urllib3.poolmanagerr   r   Zpackages.urllib3.responser   Zpackages.urllib3.utilr   r   Zpackages.urllib3.util.retryr   compatr	   r
   Zutilsr   r   r   r   r   r   r   Z
structuresr   Zpackages.urllib3.exceptionsr   r   r   r   r   r   r   r   r   r   r   r   r   rn   r   
exceptionsr   r   r    r!   r"   Zauthr#   Zpackages.urllib3.contrib.socksr$   ImportErrorr   r   rD   r   objectr*   r<   r'   r'   r'   r(   <module>	   sB   44                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
l2XX                 @   se  d  Z  d d l m Z d d l Z e j Z e d d k Z e d d k Z y d d l Z	 Wn$ e
 e f k
 r d d l	 Z	 Yn Xe rvd d l m Z m Z m Z m Z m Z m Z m Z d d l m Z m Z m Z m Z m Z d d	 l m Z d d l Z d d
 l m Z d d l m Z d d l m  Z  d d l! m" Z" e# Z$ e# Z% e& Z# e' Z' e( e) e* f Z+ e( e) f Z, n e rad d l- m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z d d l. m Z m Z m Z d d l/ m0 Z d d
 l1 m Z d d l2 m Z d d l3 m  Z  d d l4 m" Z" e# Z$ e# Z# e% Z% e# e% f Z' e( e* f Z+ e( f Z, d S)zq
requests.compat
~~~~~~~~~~~~~~~

This module handles import compatibility issues between Python 2 and
Python 3.
   )chardet    N      )quoteunquote
quote_plusunquote_plus	urlencode
getproxiesproxy_bypass)urlparse
urlunparseurljoinurlsplit	urldefrag)parse_http_list)Morsel)StringIO)OrderedDict)IncompleteRead)
r   r   r   r   r
   r   r   r   r	   r   )r   r   r   )	cookiejar)5__doc__Zpackagesr   sysversion_infoZ_verZis_py2Zis_py3Z
simplejsonZjsonImportErrorSyntaxErrorZurllibr   r   r   r	   r
   r   r   r   r   r   r   r   Zurllib2r   Z	cookielibZCookier   r   Z&packages.urllib3.packages.ordered_dictr   Zhttplibr   strZbuiltin_strbytesZunicodeZ
basestringintZlongfloatZnumeric_typesZinteger_typesZurllib.parseZurllib.requestZhttpr   Zhttp.cookiesiocollectionsZhttp.client r#   r#   1/usr/lib/python3/dist-packages/requests/compat.py<module>	   sL   	4(F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
QXM                 @   s   d  Z  d d l m Z d d   Z d d d  Z d d	   Z d
 d   Z d d d d  Z d d d  Z d d d  Z	 d d   Z
 d S)z
requests.api
~~~~~~~~~~~~

This module implements the Requests API.

:copyright: (c) 2012 by Kenneth Reitz.
:license: Apache2, see LICENSE for more details.
   )sessionsc             K   s3   t  j     } | j d |  d | |  SWd QRXd S)a  Constructs and sends a :class:`Request <Request>`.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.
        ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``
        or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content-type'`` is a string
        defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers
        to add for the file.
    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.
    :param timeout: (optional) How long to wait for the server to send data
        before giving up, as a float, or a :ref:`(connect timeout, read
        timeout) <timeouts>` tuple.
    :type timeout: float or tuple
    :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection.
    :type allow_redirects: bool
    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
    :param verify: (optional) whether the SSL cert will be verified. A CA_BUNDLE path can also be provided. Defaults to ``True``.
    :param stream: (optional) if ``False``, the response content will be immediately downloaded.
    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response

    Usage::

      >>> import requests
      >>> req = requests.request('GET', 'http://httpbin.org/get')
      <Response [200]>
    methodurlN)r   ZSessionrequest)r   r   kwargsZsession r   ./usr/lib/python3/dist-packages/requests/api.pyr      s    'r   Nc             K   s&   | j  d d  t d |  d | | S)aO  Sends a GET request.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    allow_redirectsTgetparams)
setdefaultr   )r   r   r   r   r   r   r
   ;   s    
r
   c             K   s    | j  d d  t d |  |  S)zSends a OPTIONS request.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    r	   Toptions)r   r   )r   r   r   r   r   r   I   s    	r   c             K   s    | j  d d  t d |  |  S)zSends a HEAD request.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    r	   Fhead)r   r   )r   r   r   r   r   r   V   s    	r   c             K   s   t  d |  d | d | | S)a  Sends a POST request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    postdatajson)r   )r   r   r   r   r   r   r   r   c   s    r   c             K   s   t  d |  d | | S)a  Sends a PUT request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    putr   )r   )r   r   r   r   r   r   r   q   s    r   c             K   s   t  d |  d | | S)a  Sends a PATCH request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    patchr   )r   )r   r   r   r   r   r   r      s    r   c             K   s   t  d |  |  S)zSends a DELETE request.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    delete)r   )r   r   r   r   r   r      s    	r   )__doc__ r   r   r
   r   r   r   r   r   r   r   r   r   r   <module>   s   +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
nJXC%                 @   s.  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l	 m
 Z
 m Z m Z d d l m Z d d l m Z d d l m Z d d	 l m Z d
 Z d Z d d   Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z d S)z]
requests.auth
~~~~~~~~~~~~~

This module contains the authentication handlers for Requests.
    N)	b64encode   )urlparsestr
basestring)extract_cookies_to_jar)to_native_string)parse_dict_header)codesz!application/x-www-form-urlencodedzmultipart/form-datac             C   s   t  |  t  s7 t j d j |   d t t |   }  t  | t  sn t j d j |  d t t |  } t  |  t  r |  j d  }  t  | t  r | j d  } d t t	 d j
 |  | f   j    } | S)zReturns a Basic Auth string.zNon-string usernames will no longer be supported in Requests 3.0.0. Please convert the object you've passed in ({!r}) to a string or bytes object in the near future to avoid problems.categoryzNon-string passwords will no longer be supported in Requests 3.0.0. Please convert the object you've passed in ({!r}) to a string or bytes object in the near future to avoid problems.latin1zBasic    :)
isinstancer   warningswarnformatDeprecationWarningr   encoder   r   joinstrip)usernamepasswordZauthstr r   //usr/lib/python3/dist-packages/requests/auth.py_basic_auth_str   s&    
		%r   c               @   s"   e  Z d  Z d Z d d   Z d S)AuthBasez4Base class that all auth implementations derive fromc             C   s   t  d   d  S)NzAuth hooks must be callable.)NotImplementedError)selfrr   r   r   __call__L   s    zAuthBase.__call__N)__name__
__module____qualname____doc__r   r   r   r   r   r   I   s   r   c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 S)HTTPBasicAuthz?Attaches HTTP Basic Authentication to the given Request object.c             C   s   | |  _  | |  _ d  S)N)r   r   )r   r   r   r   r   r   __init__S   s    	zHTTPBasicAuth.__init__c             C   s:   t  |  j t | d d   k |  j t | d d   k g  S)Nr   r   )allr   getattrr   )r   otherr   r   r   __eq__W   s    zHTTPBasicAuth.__eq__c             C   s   |  | k S)Nr   )r   r(   r   r   r   __ne__]   s    zHTTPBasicAuth.__ne__c             C   s    t  |  j |  j  | j d <| S)NAuthorization)r   r   r   headers)r   r   r   r   r   r   `   s    zHTTPBasicAuth.__call__N)r    r!   r"   r#   r%   r)   r*   r   r   r   r   r   r$   P   s
   r$   c               @   s"   e  Z d  Z d Z d d   Z d S)HTTPProxyAuthz=Attaches HTTP Proxy Authentication to a given Request object.c             C   s    t  |  j |  j  | j d <| S)NzProxy-Authorization)r   r   r   r,   )r   r   r   r   r   r   h   s    zHTTPProxyAuth.__call__N)r    r!   r"   r#   r   r   r   r   r   r-   e   s   r-   c               @   sv   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d S)HTTPDigestAuthz@Attaches HTTP Digest Authentication to the given Request object.c             C   s%   | |  _  | |  _ t j   |  _ d  S)N)r   r   	threadingZlocal_thread_local)r   r   r   r   r   r   r%   p   s    		zHTTPDigestAuth.__init__c             C   s^   t  |  j d  sZ d |  j _ d |  j _ d |  j _ i  |  j _ d  |  j _ d  |  j _ d  S)NinitT r   )hasattrr0   r1   
last_noncenonce_countchalposnum_401_calls)r   r   r   r   init_per_thread_statev   s    z$HTTPDigestAuth.init_per_thread_statec                sH  |  j  j d } |  j  j d } |  j  j j d  } |  j  j j d  } |  j  j j d  } d   | d k rz d } n | j   } | d k s | d k r d	 d
   }	 |	   n | d k r d d   }
 |
     f d d   }   d k r d Sd } t |  } | j pd } | j r.| d | j 7} d |  j | |  j f } d | | f }   |  }   |  } | |  j  j	 k r|  j  j
 d 7_
 n d |  j  _
 d |  j  j
 } t |  j  j
  j d  } | | j d  7} | t j   j d  7} | t j d  7} t j |  j   d d  } | d k rP  d | | | f  } | sr| | d | | f  } nP | d k sd | j d  k rd | | | d | f } | | |  } n d S| |  j  _	 d |  j | | | | f } | r| d | 7} | r| d | 7} | r&| d | 7} | r@| d  | | f 7} d! | S)"z
        :rtype: str
        realmnonceqop	algorithmopaqueNZMD5zMD5-SESSc             S   s1   t  |  t  r |  j d  }  t j |   j   S)Nzutf-8)r   r   r   hashlibZmd5	hexdigest)xr   r   r   md5_utf8   s    z4HTTPDigestAuth.build_digest_header.<locals>.md5_utf8ZSHAc             S   s1   t  |  t  r |  j d  }  t j |   j   S)Nzutf-8)r   r   r   r?   sha1r@   )rA   r   r   r   sha_utf8   s    z4HTTPDigestAuth.build_digest_header.<locals>.sha_utf8c                s     d |  | f  S)Nz%s:%sr   )sd)	hash_utf8r   r   <lambda>   s    z4HTTPDigestAuth.build_digest_header.<locals>.<lambda>/?z%s:%s:%sz%s:%sr   z%08xzutf-8      Zauth,z%s:%s:%s:%s:%sz>username="%s", realm="%s", nonce="%s", uri="%s", response="%s"z, opaque="%s"z, algorithm="%s"z, digest="%s"z , qop="auth", nc=%s, cnonce="%s"z	Digest %s)r0   r6   getupperr   pathZqueryr   r   r4   r5   r   r   timeZctimeosurandomr?   rC   r@   split)r   methodurlr:   r;   r<   r=   r>   Z
_algorithmrB   rD   ZKDZentdigZp_parsedrP   ZA1ZA2ZHA1ZHA2ZncvaluerE   ZcnonceZrespdigZnoncebitbaser   )rG   r   build_digest_header   sr    			!z"HTTPDigestAuth.build_digest_headerc             K   s   | j  r d |  j _ d S)z)Reset num_401_calls counter on redirects.r   N)Zis_redirectr0   r8   )r   r   kwargsr   r   r   handle_redirect   s    	zHTTPDigestAuth.handle_redirectc             K   s\  |  j  j d k	 r+ | j j j |  j  j  | j j d d  } d | j   k rL|  j  j d k  rL|  j  j d 7_ t	 j
 d d t	 j } t | j d | d	 d  |  j  _ | j | j   | j j   } t | j | j | j  | j | j  |  j | j | j  | j d
 <| j j | |  } | j j |  | | _ | Sd |  j  _ | S)zo
        Takes the given response and tries digest-auth, if needed.

        :rtype: requests.Response
        Nzwww-authenticater2   Zdigest   r   zdigest flagscountr+   )r0   r7   Zrequestbodyseekr,   rN   lowerr8   recompile
IGNORECASEr	   subr6   Zcontentclosecopyr   Z_cookiesrawZprepare_cookiesrX   rU   rV   Z
connectionsendhistoryappend)r   r   rY   Zs_authZpatZprepZ_rr   r   r   
handle_401   s(    $$
	zHTTPDigestAuth.handle_401c             C   s   |  j    |  j j r5 |  j | j | j  | j d <y | j j   |  j _	 Wn t
 k
 rn d  |  j _	 Yn X| j d |  j  | j d |  j  d |  j _ | S)Nr+   Zresponser   )r9   r0   r4   rX   rU   rV   r,   r^   tellr7   AttributeErrorZregister_hookrk   rZ   r8   )r   r   r   r   r   r     s    
zHTTPDigestAuth.__call__c             C   s:   t  |  j t | d d   k |  j t | d d   k g  S)Nr   r   )r&   r   r'   r   )r   r(   r   r   r   r)     s    zHTTPDigestAuth.__eq__c             C   s   |  | k S)Nr   )r   r(   r   r   r   r*     s    zHTTPDigestAuth.__ne__N)r    r!   r"   r#   r%   r9   rX   rZ   rk   r   r)   r*   r   r   r   r   r.   m   s   
Z&r.   )r#   rR   ra   rQ   r?   r/   r   base64r   compatr   r   r   Zcookiesr   Z_internal_utilsr   Zutilsr	   Zstatus_codesr
   ZCONTENT_TYPE_FORM_URLENCODEDZCONTENT_TYPE_MULTI_PARTr   objectr   r$   r-   r.   r   r   r   r   <module>   s&   ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
^JXsG                 @   sn  d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m Z m	 Z	 m
 Z
 m Z y d d l Z e Wn e k
 r d d l Z Yn XGd d   d e  Z Gd d	   d	 e  Z d
 d   Z d d   Z d d d d  Z Gd d   d e  Z Gd d   d e j e j  Z d d   Z d d   Z d d   Z d d d d  Z d d   Z d S)z
requests.cookies
~~~~~~~~~~~~~~~~

Compatibility code to be able to use `cookielib.CookieJar` with requests.

requests.utils imports from here, so be careful with imports.
    N   )to_native_string)	cookieliburlparse
urlunparseMorselc               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d d  Z d d   Z d d   Z d d   Z e d d    Z e d d    Z e d d    Z d S)MockRequesta  Wraps a `requests.Request` to mimic a `urllib2.Request`.

    The code in `cookielib.CookieJar` expects this interface in order to correctly
    manage cookie policies, i.e., determine whether a cookie can be set, given the
    domains of the request and the cookie.

    The original request object is read-only. The client is responsible for collecting
    the new headers via `get_new_headers()` and interpreting them appropriately. You
    probably want `get_cookie_header`, defined below.
    c             C   s.   | |  _  i  |  _ t |  j  j  j |  _ d  S)N)_r_new_headersr   urlschemetype)selfrequest r   2/usr/lib/python3/dist-packages/requests/cookies.py__init__(   s    		zMockRequest.__init__c             C   s   |  j  S)N)r   )r   r   r   r   get_type-   s    zMockRequest.get_typec             C   s   t  |  j j  j S)N)r   r	   r   Znetloc)r   r   r   r   get_host0   s    zMockRequest.get_hostc             C   s
   |  j    S)N)r   )r   r   r   r   get_origin_req_host3   s    zMockRequest.get_origin_req_hostc             C   sx   |  j  j j d  s |  j  j St |  j  j d d d } t |  j  j  } t | j | | j | j	 | j
 | j g  S)NZHostencodingzutf-8)r	   headersgetr   r   r   r   r   pathZparamsZqueryZfragment)r   hostZparsedr   r   r   get_full_url6   s    
zMockRequest.get_full_urlc             C   s   d S)NTr   )r   r   r   r   is_unverifiableD   s    zMockRequest.is_unverifiablec             C   s   | |  j  j k p | |  j k S)N)r	   r   r
   )r   namer   r   r   
has_headerG   s    zMockRequest.has_headerNc             C   s%   |  j  j j | |  j j | |   S)N)r	   r   r   r
   )r   r   defaultr   r   r   
get_headerJ   s    zMockRequest.get_headerc             C   s   t  d   d S)zMcookielib has no legitimate use for this method; add it back if you find one.z=Cookie headers should be added with add_unredirected_header()N)NotImplementedError)r   keyvalr   r   r   
add_headerM   s    zMockRequest.add_headerc             C   s   | |  j  | <d  S)N)r
   )r   r   valuer   r   r   add_unredirected_headerQ   s    z#MockRequest.add_unredirected_headerc             C   s   |  j  S)N)r
   )r   r   r   r   get_new_headersT   s    zMockRequest.get_new_headersc             C   s
   |  j    S)N)r   )r   r   r   r   unverifiableW   s    zMockRequest.unverifiablec             C   s
   |  j    S)N)r   )r   r   r   r   origin_req_host[   s    zMockRequest.origin_req_hostc             C   s
   |  j    S)N)r   )r   r   r   r   r   _   s    zMockRequest.host)__name__
__module____qualname____doc__r   r   r   r   r   r   r   r    r$   r&   r'   propertyr(   r)   r   r   r   r   r   r      s   
r   c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	MockResponsezWraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.

    ...what? Basically, expose the parsed HTTP headers from the server response
    the way `cookielib` expects to see them.
    c             C   s   | |  _  d S)zMake a MockResponse for `cookielib` to read.

        :param headers: a httplib.HTTPMessage or analogous carrying the headers
        N)_headers)r   r   r   r   r   r   k   s    zMockResponse.__init__c             C   s   |  j  S)N)r0   )r   r   r   r   infor   s    zMockResponse.infoc             C   s   |  j  j |  d  S)N)r0   
getheaders)r   r   r   r   r   r2   u   s    zMockResponse.getheadersN)r*   r+   r,   r-   r   r1   r2   r   r   r   r   r/   d   s   r/   c             C   sN   t  | d  o | j s d St |  } t | j j  } |  j | |  d S)zExtract the cookies from the response into a CookieJar.

    :param jar: cookielib.CookieJar (not necessarily a RequestsCookieJar)
    :param request: our own requests.Request object
    :param response: urllib3.HTTPResponse object
    _original_responseN)hasattrr3   r   r/   msgZextract_cookies)jarr   ZresponseZreqresr   r   r   extract_cookies_to_jary   s    	r8   c             C   s,   t  |  } |  j |  | j   j d  S)zj
    Produce an appropriate Cookie header string to be sent with `request`, or None.

    :rtype: str
    Cookie)r   Zadd_cookie_headerr'   r   )r6   r   rr   r   r   get_cookie_header   s    r;   c             C   s   g  } x{ |  D]s } | j  | k r% q | d k	 rC | | j k rC q | d k	 ra | | j k ra q | j | j | j | j  f  q Wx* | D]" \ } } } |  j | | |  q Wd S)zkUnsets a cookie by name, by default over all domains and paths.

    Wraps CookieJar.clear(), is O(n).
    N)r   domainr   appendclear)	cookiejarr   r<   r   Z
clearablescookier   r   r   remove_cookie_by_name   s    #rA   c               @   s   e  Z d  Z d Z d S)CookieConflictErrorzThere are two cookies that meet the criteria specified in the cookie jar.
    Use .get and .set and include domain and path args in order to be more specific.
    N)r*   r+   r,   r-   r   r   r   r   rB      s   rB   c                   sW  e  Z d  Z d Z d d d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d d d  Z   f d d   Z d d   Z d d    Z d! d"   Z   f d# d$   Z   f d% d&   Z d d d' d(  Z d d d) d*  Z d+ d,   Z d- d.   Z d/ d0   Z   S)1RequestsCookieJara  Compatibility class; is a cookielib.CookieJar, but exposes a dict
    interface.

    This is the CookieJar we create by default for requests and sessions that
    don't specify one, since some clients may expect response.cookies and
    session.cookies to support dict operations.

    Requests does not use the dict interface internally; it's just for
    compatibility with external client code. All requests code should work
    out of the box with externally provided instances of ``CookieJar``, e.g.
    ``LWPCookieJar`` and ``FileCookieJar``.

    Unlike a regular CookieJar, this class is pickleable.

    .. warning:: dictionary operations that are normally O(1) may be O(n).
    Nc             C   s4   y |  j  | | |  SWn t k
 r/ | SYn Xd S)zDict-like get() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains.

        .. warning:: operation is O(n), not O(1).
        N)_find_no_duplicatesKeyError)r   r   r   r<   r   r   r   r   r      s    zRequestsCookieJar.getc             K   s|   | d k r; t  |  | d | j d  d | j d  d St | t  rY t |  } n t | | |  } |  j |  | S)zDict-like set() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains.
        Nr<   r   )rA   r   
isinstancer   morsel_to_cookiecreate_cookie
set_cookie)r   r   r%   kwargscr   r   r   set   s    +zRequestsCookieJar.setc             c   s#   x t  |   D] } | j Vq Wd S)zDict-like iterkeys() that returns an iterator of names of cookies
        from the jar.

        .. seealso:: itervalues() and iteritems().
        N)iterr   )r   r@   r   r   r   iterkeys   s    zRequestsCookieJar.iterkeysc             C   s   t  |  j    S)zDict-like keys() that returns a list of names of cookies from the
        jar.

        .. seealso:: values() and items().
        )listrN   )r   r   r   r   keys   s    zRequestsCookieJar.keysc             c   s#   x t  |   D] } | j Vq Wd S)zDict-like itervalues() that returns an iterator of values of cookies
        from the jar.

        .. seealso:: iterkeys() and iteritems().
        N)rM   r%   )r   r@   r   r   r   
itervalues   s    zRequestsCookieJar.itervaluesc             C   s   t  |  j    S)zDict-like values() that returns a list of values of cookies from the
        jar.

        .. seealso:: keys() and items().
        )rO   rQ   )r   r   r   r   values   s    zRequestsCookieJar.valuesc             c   s,   x% t  |   D] } | j | j f Vq Wd S)zDict-like iteritems() that returns an iterator of name-value tuples
        from the jar.

        .. seealso:: iterkeys() and itervalues().
        N)rM   r   r%   )r   r@   r   r   r   	iteritems   s    zRequestsCookieJar.iteritemsc             C   s   t  |  j    S)zDict-like items() that returns a list of name-value tuples from the
        jar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a
        vanilla python dict of key value pairs.

        .. seealso:: keys() and values().
        )rO   rS   )r   r   r   r   items  s    zRequestsCookieJar.itemsc             C   s@   g  } x3 t  |   D]% } | j | k r | j | j  q W| S)z2Utility method to list all the domains in the jar.)rM   r<   r=   )r   domainsr@   r   r   r   list_domains  s
    zRequestsCookieJar.list_domainsc             C   s@   g  } x3 t  |   D]% } | j | k r | j | j  q W| S)z0Utility method to list all the paths in the jar.)rM   r   r=   )r   pathsr@   r   r   r   
list_paths  s
    zRequestsCookieJar.list_pathsc             C   sS   g  } xF t  |   D]8 } | j d k	 r; | j | k r; d S| j | j  q Wd S)zvReturns True if there are multiple domains in the jar.
        Returns False otherwise.

        :rtype: bool
        NTF)rM   r<   r=   )r   rU   r@   r   r   r   multiple_domains!  s    z"RequestsCookieJar.multiple_domainsc             C   sg   i  } xZ t  |   D]L } | d k s4 | j | k r | d k sO | j | k r | j | | j <q W| S)zTakes as an argument an optional domain and path and returns a plain
        old Python dict of name-value pairs of cookies that meet the
        requirements.

        :rtype: dict
        N)rM   r<   r   r%   r   )r   r<   r   Z
dictionaryr@   r   r   r   get_dict.  s    'zRequestsCookieJar.get_dictc                s7   y t  t |   j |  SWn t k
 r2 d SYn Xd  S)NT)superrC   __contains__rB   )r   r   )	__class__r   r   r\   <  s    zRequestsCookieJar.__contains__c             C   s   |  j  |  S)zDict-like __getitem__() for compatibility with client code. Throws
        exception if there are more than one cookie with name. In that case,
        use the more explicit get() method instead.

        .. warning:: operation is O(n), not O(1).
        )rD   )r   r   r   r   r   __getitem__B  s    zRequestsCookieJar.__getitem__c             C   s   |  j  | |  d S)zDict-like __setitem__ for compatibility with client code. Throws
        exception if there is already a cookie of that name in the jar. In that
        case, use the more explicit set() method instead.
        N)rL   )r   r   r%   r   r   r   __setitem__K  s    zRequestsCookieJar.__setitem__c             C   s   t  |  |  d S)zlDeletes a cookie given a name. Wraps ``cookielib.CookieJar``'s
        ``remove_cookie_by_name()``.
        N)rA   )r   r   r   r   r   __delitem__R  s    zRequestsCookieJar.__delitem__c                sj   t  | j d  rN | j j d  rN | j j d  rN | j j d d  | _ t t |   j | | |  S)N
startswith"z\" )r4   r%   ra   endswithreplacer[   rC   rI   )r   r@   argsrJ   )r]   r   r   rI   X  s    6zRequestsCookieJar.set_cookiec                sV   t  | t j  r< x= | D] } |  j t j |   q Wn t t |   j |  d S)zAUpdates this jar with cookies from another CookieJar or dict-likeN)rF   r   	CookieJarrI   copyr[   rC   update)r   otherr@   )r]   r   r   ri   ]  s    zRequestsCookieJar.updatec             C   s   x` t  |   D]R } | j | k r | d k s= | j | k r | d k sX | j | k r | j Sq Wt d | | | f   d S)a  Requests uses this method internally to get cookie values.

        If there are conflicting cookies, _find arbitrarily chooses one.
        See _find_no_duplicates if you want an exception thrown if there are
        conflicting cookies.

        :param name: a string containing name of cookie
        :param domain: (optional) string containing domain of cookie
        :param path: (optional) string containing path of cookie
        :return: cookie.value
        Nzname=%r, domain=%r, path=%r)rM   r   r<   r   r%   rE   )r   r   r<   r   r@   r   r   r   _finde  s    zRequestsCookieJar._findc             C   s   d } x~ t  |   D]p } | j | k r | d k sC | j | k r | d k s^ | j | k r | d k	 rz t d |   | j } q W| r | St d | | | f   d S)a  Both ``__get_item__`` and ``get`` call this function: it's never
        used elsewhere in Requests.

        :param name: a string containing name of cookie
        :param domain: (optional) string containing domain of cookie
        :param path: (optional) string containing path of cookie
        :raises KeyError: if cookie is not found
        :raises CookieConflictError: if there are multiple cookies
            that match name and optionally domain and path
        :return: cookie.value
        Nz(There are multiple cookies with name, %rzname=%r, domain=%r, path=%r)rM   r   r<   r   rB   r%   rE   )r   r   r<   r   ZtoReturnr@   r   r   r   rD   y  s    z%RequestsCookieJar._find_no_duplicatesc             C   s    |  j  j   } | j d  | S)z4Unlike a normal CookieJar, this class is pickleable._cookies_lock)__dict__rh   pop)r   stater   r   r   __getstate__  s    zRequestsCookieJar.__getstate__c             C   s2   |  j  j |  d |  j  k r. t j   |  _ d S)z4Unlike a normal CookieJar, this class is pickleable.rl   N)rm   ri   	threadingRLockrl   )r   ro   r   r   r   __setstate__  s    zRequestsCookieJar.__setstate__c             C   s   t    } | j |   | S)z(Return a copy of this RequestsCookieJar.)rC   ri   )r   Znew_cjr   r   r   rh     s    	zRequestsCookieJar.copy)r*   r+   r,   r-   r   rL   rN   rP   rQ   rR   rS   rT   rV   rX   rY   rZ   r\   r^   r_   r`   rI   ri   rk   rD   rp   rs   rh   r   r   )r]   r   rC      s0   					rC   c             C   sm   |  d  k r d  St  |  d  r) |  j   St j |   } | j   x$ |  D] } | j t j |   qI W| S)Nrh   )r4   rh   r>   rI   )r6   Znew_jarr@   r   r   r   _copy_cookie_jar  s    

rt   c             K   s  t  d d d |  d | d d d d d	 d
 d d d d d d d d d d d d d i d d  } t |  t |  } | r d } t | t |    | j |  t | d  | d <t | d  | d <| d j d  | d <t | d	  | d <t j |   S)zMake a cookie from underspecified parameters.

    By default, the pair of `name` and `value` will be set for the domain ''
    and sent on every request (this is sometimes called a "supercookie").
    versionr   r   r%   portNr<   rc   r   /secureFexpiresdiscardTcommentcomment_urlrestHttpOnlyrfc2109z4create_cookie() got unexpected keyword arguments: %sZport_specifiedZdomain_specified.Zdomain_initial_dotZpath_specified)	dictrL   	TypeErrorrO   ri   boolra   r   r9   )r   r%   rJ   resultZbadargserrr   r   r   rH     s0    	rH   c          $   C   s  d } |  d r` y$ t  t j   t  |  d   } Wq t k
 r\ t d |  d   Yq Xn/ |  d r d } t j t j |  d |   } t d |  d d t |  d  d d	 d
 |  d
 d | d |  j	 d |  d d d d d |  d i d d	 d t |  d  d |  j
 d |  d pd  S)zBConvert a Morsel object into a Cookie containing the one k/v pair.Nzmax-agezmax-age: %s must be integerry   z%a, %d-%b-%Y %H:%M:%S GMTr{   r|   rz   Fr<   r   r   rv   r}   r~   Zhttponlyr   rx   r%   ru   r   )inttime
ValueErrorr   calendarZtimegmZstrptimerH   r   r"   r%   )Zmorselry   Ztime_templater   r   r   rG     s0    
$


	
	rG   Tc             C   su   | d k r t    } |  d k	 rq d d   | D } x: |  D]2 } | sS | | k r; | j t | |  |   q; W| S)a-  Returns a CookieJar from a key/value dictionary.

    :param cookie_dict: Dict of key/values to insert into CookieJar.
    :param cookiejar: (optional) A cookiejar to add the cookies to.
    :param overwrite: (optional) If False, will not replace cookies
        already in the jar with new ones.
    Nc             S   s   g  |  ] } | j   q Sr   )r   ).0r@   r   r   r   
<listcomp>  s   	 z'cookiejar_from_dict.<locals>.<listcomp>)rC   rI   rH   )Zcookie_dictr?   	overwriteZnames_from_jarr   r   r   r   cookiejar_from_dict  s    	r   c             C   s   t  |  t j  s t d   t  | t  rH t | d |  d d }  nV t  | t j  r y |  j |  Wn0 t k
 r x | D] } |  j |  q WYn X|  S)zAdd cookies to cookiejar and returns a merged CookieJar.

    :param cookiejar: CookieJar object to add the cookies to.
    :param cookies: Dictionary or CookieJar object to be added.
    z!You can only merge into CookieJarr?   r   F)	rF   r   rg   r   r   r   ri   AttributeErrorrI   )r?   ZcookiesZcookie_in_jarr   r   r   merge_cookies  s    r   )r-   rh   r   r   collectionsZ_internal_utilsr   compatr   r   r   r   rq   ImportErrorZdummy_threadingobjectr   r/   r8   r;   rA   RuntimeErrorrB   rg   MutableMappingrC   rt   rH   rG   r   r   r   r   r   r   <module>
   s.   "H#                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
QX                 @   s   d  Z  d d l m Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd	 d
   d
 e  Z Gd d   d e  Z Gd d   d e  Z	 Gd d   d e e	  Z
 Gd d   d e	  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e e  Z Gd d   d e e  Z Gd d   d e e  Z Gd d   d e e  Z Gd d    d  e  Z Gd! d"   d" e e  Z Gd# d$   d$ e e  Z Gd% d&   d& e  Z Gd' d(   d( e  Z Gd) d*   d* e  Z Gd+ d,   d, e e  Z d- S).z`
requests.exceptions
~~~~~~~~~~~~~~~~~~~

This module contains the set of Requests' exceptions.
   )	HTTPErrorc                   s(   e  Z d  Z d Z   f d d   Z   S)RequestExceptionzTThere was an ambiguous exception that occurred while handling your
    request.
    c                s   | j  d d  } | |  _ | j  d d  |  _ | d k	 rd |  j rd t | d  rd |  j j |  _ t t |   j | |   d S)zBInitialize RequestException with `request` and `response` objects.responseNrequest)popr   r   hasattrsuperr   __init__)selfargskwargsr   )	__class__ 5/usr/lib/python3/dist-packages/requests/exceptions.pyr	      s    	zRequestException.__init__)__name__
__module____qualname____doc__r	   r   r   )r   r   r      s   r   c               @   s   e  Z d  Z d Z d S)r   zAn HTTP error occurred.N)r   r   r   r   r   r   r   r   r      s   r   c               @   s   e  Z d  Z d Z d S)ConnectionErrorzA Connection error occurred.N)r   r   r   r   r   r   r   r   r       s   r   c               @   s   e  Z d  Z d Z d S)
ProxyErrorzA proxy error occurred.N)r   r   r   r   r   r   r   r   r   $   s   r   c               @   s   e  Z d  Z d Z d S)SSLErrorzAn SSL error occurred.N)r   r   r   r   r   r   r   r   r   (   s   r   c               @   s   e  Z d  Z d Z d S)TimeoutzThe request timed out.

    Catching this error will catch both
    :exc:`~requests.exceptions.ConnectTimeout` and
    :exc:`~requests.exceptions.ReadTimeout` errors.
    N)r   r   r   r   r   r   r   r   r   ,   s   r   c               @   s   e  Z d  Z d Z d S)ConnectTimeoutzThe request timed out while trying to connect to the remote server.

    Requests that produced this error are safe to retry.
    N)r   r   r   r   r   r   r   r   r   5   s   r   c               @   s   e  Z d  Z d Z d S)ReadTimeoutz@The server did not send any data in the allotted amount of time.N)r   r   r   r   r   r   r   r   r   <   s   r   c               @   s   e  Z d  Z d Z d S)URLRequiredz*A valid URL is required to make a request.N)r   r   r   r   r   r   r   r   r   @   s   r   c               @   s   e  Z d  Z d Z d S)TooManyRedirectszToo many redirects.N)r   r   r   r   r   r   r   r   r   D   s   r   c               @   s   e  Z d  Z d Z d S)MissingSchemaz/The URL schema (e.g. http or https) is missing.N)r   r   r   r   r   r   r   r   r   H   s   r   c               @   s   e  Z d  Z d Z d S)InvalidSchemaz"See defaults.py for valid schemas.N)r   r   r   r   r   r   r   r   r   L   s   r   c               @   s   e  Z d  Z d Z d S)
InvalidURLz%The URL provided was somehow invalid.N)r   r   r   r   r   r   r   r   r   P   s   r   c               @   s   e  Z d  Z d Z d S)InvalidHeaderz.The header value provided was somehow invalid.N)r   r   r   r   r   r   r   r   r   T   s   r   c               @   s   e  Z d  Z d Z d S)ChunkedEncodingErrorz?The server declared chunked encoding but sent an invalid chunk.N)r   r   r   r   r   r   r   r   r    X   s   r    c               @   s   e  Z d  Z d Z d S)ContentDecodingErrorz!Failed to decode response contentN)r   r   r   r   r   r   r   r   r!   \   s   r!   c               @   s   e  Z d  Z d Z d S)StreamConsumedErrorz2The content for this response was already consumedN)r   r   r   r   r   r   r   r   r"   `   s   r"   c               @   s   e  Z d  Z d Z d S)
RetryErrorzCustom retries logic failedN)r   r   r   r   r   r   r   r   r#   d   s   r#   c               @   s   e  Z d  Z d Z d S)UnrewindableBodyErrorz:Requests encountered an error when trying to rewind a bodyN)r   r   r   r   r   r   r   r   r$   g   s   r$   c               @   s   e  Z d  Z d Z d S)RequestsWarningzBase warning for Requests.N)r   r   r   r   r   r   r   r   r%   m   s   r%   c               @   s   e  Z d  Z d Z d S)FileModeWarningzJA file was opened in text mode, but Requests determined its binary length.N)r   r   r   r   r   r   r   r   r&   r   s   r&   N)r   Zpackages.urllib3.exceptionsr   ZBaseHTTPErrorIOErrorr   r   r   r   r   r   r   r   r   
ValueErrorr   r   r   r   r    r!   	TypeErrorr"   r#   r$   Warningr%   DeprecationWarningr&   r   r   r   r   <module>   s,   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
eEX                 @   s+   d  Z  d g Z d d   Z d d   Z d S)z
requests.hooks
~~~~~~~~~~~~~~

This module provides the capabilities for the Requests hooks system.

Available hooks:

``response``:
    The response generated from a Request.
Zresponsec               C   s   t  d d   t D  S)Nc             s   s   |  ] } | g  f Vq d  S)N ).0Zeventr   r   0/usr/lib/python3/dist-packages/requests/hooks.py	<genexpr>   s    z default_hooks.<locals>.<genexpr>)dictHOOKSr   r   r   r   default_hooks   s    r   c             K   sr   | p t    } | j |   } | rn t | d  r< | g } x/ | D]' } | | |  } | d k	 rC | } qC W| S)z6Dispatches a hook dictionary on a given piece of data.__call__N)r   gethasattr)keyZhooksZ	hook_datakwargshookZ
_hook_datar   r   r   dispatch_hook   s    	
r   N)__doc__r   r   r   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
QXh                 @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z m Z d d l m	 Z	 d d l
 m Z d d l m Z d d l m Z m Z m Z d d	 l m Z d d
 l m Z d d l m Z d d l m Z d d l m Z m Z m Z m Z d d l m  Z  m! Z! m" Z" m# Z# m$ Z$ m% Z% m& Z& d d l' m( Z( m) Z) d d l* m+ Z+ m, Z, m- Z- m. Z. m/ Z/ m0 Z0 m1 Z1 m2 Z2 m3 Z3 m4 Z4 d d l5 m6 Z6 m7 Z7 m8 Z8 m9 Z9 m: Z: m; Z; m< Z< m= Z= m> Z> m? Z? m@ Z@ d d l5 mA ZB d d lC mD ZD eD jE eD jF eD jG eD jH eD jI f ZJ d ZK d d ZL d ZM Gd d   d eN  ZO Gd d   d eN  ZP Gd d   d eP  ZQ Gd d   d eO eP  ZR Gd  d!   d! eN  ZS d S)"z`
requests.models
~~~~~~~~~~~~~~~

This module contains the primary objects that power Requests.
    N)BytesIOUnsupportedOperation   )default_hooks)CaseInsensitiveDict)HTTPBasicAuth)cookiejar_from_dictget_cookie_header_copy_cookie_jar)idna)RequestField)encode_multipart_formdata)	parse_url)DecodeErrorReadTimeoutErrorProtocolErrorLocationParseError)	HTTPErrorMissingSchema
InvalidURLChunkedEncodingErrorContentDecodingErrorConnectionErrorStreamConsumedError)to_native_stringunicode_is_ascii)
guess_filenameget_auth_from_urlrequote_uristream_decode_response_unicodeto_key_val_listparse_header_linksiter_slicesguess_json_utf	super_lencheck_header_validity)	cookielib
urlunparseurlsplit	urlencodestrbytesStringIOis_py2chardetbuiltin_str
basestring)json)codes   
   i   i   c               @   sF   e  Z d  Z e d d    Z e d d    Z e d d    Z d S)RequestEncodingMixinc             C   sm   g  } t  |  j  } | j } | s* d } | j |  | j } | r` | j d  | j |  d j |  S)zBuild the path URL to use./? )r(   urlpathappendqueryjoin)selfr9   pr:   r<    r@   1/usr/lib/python3/dist-packages/requests/models.pypath_url<   s    		zRequestEncodingMixin.path_urlc             C   s
  t  |  t t f  r |  St |  d  r, |  St |  d  rg  } x t |   D] \ } } t  | t  sy t | d  r | g } xi | D]a } | d k	 r | j t  | t  r | j d  n | t  | t  r | j d  n | f  q WqN Wt | d d S|  Sd S)zEncode parameters in a piece of data.

        Will successfully encode parameters when passed as a dict or a list of
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
        if parameters are supplied as a dict.
        read__iter__Nzutf-8ZdoseqT)	
isinstancer*   r+   hasattrr    r0   r;   encoder)   )dataresultkZvsvr@   r@   rA   _encode_paramsQ   s     		!0z#RequestEncodingMixin._encode_paramsc          
   C   sQ  |  s t  d   n t | t  r0 t  d   g  } t | pB i   } t |  pT i   }  x | D] \ } } t | t  s t | d  r | g } x | D]| } | d k	 r t | t  s t |  } | j t | t  r | j d  n | t | t  r| j	 d  n | f  q Wqa Wx|  D]
\ } } d } d }	 t | t
 t f  rt |  d k ru| \ }
 } qt |  d k r| \ }
 } } q| \ }
 } } }	 n t |  p| }
 | } t | t t t f  r| } n | j   } t d | d	 | d
 |
 d |	  } | j d |  | j |  q'Wt |  \ } } | | f S)a  Build the body for a multipart/form-data request.

        Will successfully encode files when passed as a dict or a list of
        tuples. Order is retained if data is a list of tuples but arbitrary
        if parameters are supplied as a dict.
        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
        or 4-tuples (filename, fileobj, contentype, custom_headers).
        zFiles must be provided.zData must not be a string.rD   Nzutf-8      namerH   filenameheaderscontent_type)
ValueErrorrE   r0   r    rF   r+   r*   r;   decoderG   tuplelistlenr   	bytearrayrC   r   Zmake_multipartr   )filesrH   Z
new_fieldsZfieldsZfieldvalrK   rJ   ZftZfhfnfpZfdataZrfbodyrR   r@   r@   rA   _encode_filesl   sH    
	!0	!z"RequestEncodingMixin._encode_filesN)__name__
__module____qualname__propertyrB   staticmethodrL   r^   r@   r@   r@   rA   r5   ;   s   r5   c               @   s(   e  Z d  Z d d   Z d d   Z d S)RequestHooksMixinc             C   s|   | |  j  k r t d |   t | t j  rH |  j  | j |  n0 t | d  rx |  j  | j d d   | D  d S)zProperly register a hook.z1Unsupported event specified, with event name "%s"rD   c             s   s'   |  ] } t  | t j  r | Vq d  S)N)rE   collectionsCallable).0hr@   r@   rA   	<genexpr>   s    z2RequestHooksMixin.register_hook.<locals>.<genexpr>N)hooksrS   rE   re   rf   r;   rF   extend)r>   eventhookr@   r@   rA   register_hook   s    zRequestHooksMixin.register_hookc             C   s9   y |  j  | j |  d SWn t k
 r4 d SYn Xd S)ziDeregister a previously registered hook.
        Returns True if the hook existed, False if not.
        TFN)rj   removerS   )r>   rl   rm   r@   r@   rA   deregister_hook   s
    z!RequestHooksMixin.deregister_hookN)r_   r`   ra   rn   rp   r@   r@   r@   rA   rd      s   rd   c               @   sX   e  Z d  Z d Z d d d d d d d d d d d d 
 Z d d   Z d d   Z d S)	Requesta  A user-created :class:`Request <Request>` object.

    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.

    :param method: HTTP method to use.
    :param url: URL to send.
    :param headers: dictionary of headers to send.
    :param files: dictionary of {filename: fileobject} files to multipart upload.
    :param data: the body to attach to the request. If a dictionary is provided, form-encoding will take place.
    :param json: json for the body to attach to the request (if files or data is not specified).
    :param params: dictionary of URL parameters to append to the URL.
    :param auth: Auth handler or (user, pass) tuple.
    :param cookies: dictionary or CookieJar of cookies to attach to this request.
    :param hooks: dictionary of callback hooks, for internal usage.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'http://httpbin.org/get')
      >>> req.prepare()
      <PreparedRequest [GET]>
    Nc             C   s  | d  k r g  n | } | d  k r* g  n | } | d  k rB i  n | } | d  k rZ i  n | } |	 d  k rr i  n |	 }	 t    |  _ x6 t |	 j    D]" \ } } |  j d | d |  q W| |  _ | |  _ | |  _ | |  _ | |  _	 |
 |  _
 | |  _ | |  _ | |  _ d  S)Nrl   rm   )r   rj   rV   itemsrn   methodr9   rQ   rY   rH   r1   paramsauthcookies)r>   rs   r9   rQ   rY   rH   rt   ru   rv   rj   r1   rJ   rK   r@   r@   rA   __init__   s"    								zRequest.__init__c             C   s   d |  j  S)Nz<Request [%s]>)rs   )r>   r@   r@   rA   __repr__   s    zRequest.__repr__c             C   sq   t    } | j d |  j d |  j d |  j d |  j d |  j d |  j d |  j d |  j	 d	 |  j
 d
 |  j  
| S)zXConstructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.rs   r9   rQ   rY   rH   r1   rt   ru   rv   rj   )PreparedRequestpreparers   r9   rQ   rY   rH   r1   rt   ru   rv   rj   )r>   r?   r@   r@   rA   rz      s    											
zRequest.prepare)r_   r`   ra   __doc__rw   rx   rz   r@   r@   r@   rA   rq      s
   rq   c               @   s   e  Z d  Z d Z d d   Z d d d d d d d d d d d d 
 Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d d  Z d d   Z d d d  Z d d   Z d d   Z d S)ry   a  The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
    containing the exact bytes that will be sent to the server.

    Generated from either a :class:`Request <Request>` object or manually.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'http://httpbin.org/get')
      >>> r = req.prepare()
      <PreparedRequest [GET]>

      >>> s = requests.Session()
      >>> s.send(r)
      <Response [200]>
    c             C   sF   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ t   |  _ d  |  _ d  S)N)rs   r9   rQ   _cookiesr]   r   rj   _body_position)r>   r@   r@   rA   rw     s    					zPreparedRequest.__init__Nc             C   sk   |  j  |  |  j | |  |  j |  |  j |  |  j | | |
  |  j | |  |  j |	  d S)z6Prepares the entire request with the given parameters.N)prepare_methodprepare_urlprepare_headersprepare_cookiesprepare_bodyprepare_authprepare_hooks)r>   rs   r9   rQ   rY   rH   rt   ru   rv   rj   r1   r@   r@   rA   rz   )  s    zPreparedRequest.preparec             C   s   d |  j  S)Nz<PreparedRequest [%s]>)rs   )r>   r@   r@   rA   rx   :  s    zPreparedRequest.__repr__c             C   s   t    } |  j | _ |  j | _ |  j d  k	 r? |  j j   n d  | _ t |  j  | _ |  j | _ |  j | _ |  j	 | _	 | S)N)
ry   rs   r9   rQ   copyr
   r|   r]   rj   r}   )r>   r?   r@   r@   rA   r   =  s    	'zPreparedRequest.copyc             C   s4   | |  _  |  j  d k	 r0 t |  j  j    |  _  d S)zPrepares the given HTTP method.N)rs   r   upper)r>   rs   r@   r@   rA   r~   H  s    	zPreparedRequest.prepare_methodc             C   s  t  | t  r! | j d  } n t r3 t |  n	 t |  } | j   } d | k rz | j   j d  rz | |  _	 d Sy% t
 |  \ } } } } } } }	 Wn4 t k
 r }
 z t |
 j    WYd d }
 ~
 Xn X| sd } | j t | d   } t |   | st d |   y" t j | d d j d	  } WnC t t j f k
 rt |  ss| j d
  rt d   Yn X| pd } | r| d 7} | | 7} | r| d t |  7} | sd } t rlt  | t  r| j d	  } t  | t  r| j d	  } t  | t  r0| j d	  } t  | t  rN| j d	  } t  |	 t  rl|	 j d	  }	 t  | t t f  rt |  } |  j |  } | r| rd | | f } n | } t t | | | d | |	 g   } | |  _	 d S)zPrepares the given HTTP URL.utf8:ZhttpNzDInvalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?z Invalid URL %r: No host suppliedZuts46Tzutf-8*zURL has an invalid label.r8   @r6   z%s&%s)rE   r+   rT   r-   Zunicoder*   lstriplower
startswithr9   r   r   r   argsformatr   r   r   rG   UnicodeErrorZ	IDNAErrorr   rL   r   r'   )r>   r9   rt   schemeru   hostZportr:   r<   ZfragmenteerrorZnetlocZ
enc_paramsr@   r@   rA   r   N  sd    "	%""

$zPreparedRequest.prepare_urlc             C   sV   t    |  _ | rR x= | j   D]/ } t |  | \ } } | |  j t |  <q Wd S)z Prepares the given HTTP headers.N)r   rQ   rr   r%   r   )r>   rQ   headerrO   valuer@   r@   rA   r     s    
zPreparedRequest.prepare_headersc             C   s  d } d } | rR | d k	 rR d } t  j |  } t | t  sR | j d  } t t | d  t | t t t	 t
 j f  g  } y t |  } Wn! t t t f k
 r d } Yn X| rV| } t | d d  d k	 ry | j   |  _ Wn$ t t f k
 rt   |  _ Yn X| r*t d   | rFt |  |  j d <qd |  j d	 <n | rw|  j | |  \ } } nB | r|  j |  } t | t  st | d
  rd } n d } |  j |  | rd |  j k r| |  j d <| |  _ d S)z"Prepares the given HTTP body data.Nzapplication/jsonzutf-8rD   tellz1Streamed bodies and files are mutually exclusive.zContent-LengthZchunkedzTransfer-EncodingrC   z!application/x-www-form-urlencodedzcontent-typezContent-Type)complexjsondumpsrE   r+   rG   allrF   r0   rV   rU   re   Mappingr$   	TypeErrorAttributeErrorr   getattrr   r}   IOErrorOSErrorobjectNotImplementedErrorr/   rQ   r^   rL   prepare_content_lengthr]   )r>   rH   rY   r1   r]   rR   Z	is_streamlengthr@   r@   rA   r     sJ    %	zPreparedRequest.prepare_bodyc             C   sl   | d k	 r4 t  |  } | rh t |  |  j d <n4 |  j d k rh |  j j d  d k rh d |  j d <d S)z>Prepare Content-Length header based on request method and bodyNzContent-LengthGETHEAD0)r   r   )r$   r/   rQ   rs   get)r>   r]   r   r@   r@   rA   r     s    'z&PreparedRequest.prepare_content_lengthr8   c             C   s   | d k r3 t  |  j  } t |  r- | n d } | r t | t  rf t |  d k rf t |   } | |   } |  j j | j  |  j	 |  j
  d S)z"Prepares the given HTTP auth data.NrM   )r   r9   anyrE   rU   rW   r   __dict__updater   r]   )r>   ru   r9   Zurl_authrr@   r@   rA   r     s    !zPreparedRequest.prepare_authc             C   s\   t  | t j  r | |  _ n t |  |  _ t |  j |   } | d k	 rX | |  j d <d S)a  Prepares the given HTTP cookie data.

        This function eventually generates a ``Cookie`` header from the
        given cookies using cookielib. Due to cookielib's design, the header
        will not be regenerated if it already exists, meaning this function
        can only be called once for the life of the
        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls
        to ``prepare_cookies`` will have no actual effect, unless the "Cookie"
        header is removed beforehand.
        NZCookie)rE   r&   Z	CookieJarr|   r   r	   rQ   )r>   rv   Zcookie_headerr@   r@   rA   r     s    zPreparedRequest.prepare_cookiesc             C   s5   | p	 g  } x" | D] } |  j  | | |  q Wd S)zPrepares the given hooks.N)rn   )r>   rj   rl   r@   r@   rA   r   +  s    zPreparedRequest.prepare_hooks)r_   r`   ra   r{   rw   rz   rx   r   r~   r   r   r   r   r   r   r   r@   r@   r@   rA   ry     s   VEry   c            
       s]  e  Z d  Z d Z d d d d d d d d	 d
 d g
 Z   f d d   Z d d   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z e d d    Z e d d    Z e d d    Z e d  d!    Z d" d# d$ d%  Z e d& d& d' d(  Z e d) d*    Z e d+ d,    Z d- d.   Z e d/ d0    Z d1 d2   Z d3 d4   Z   S)5ResponsezhThe :class:`Response <Response>` object, which contains a
    server's response to an HTTP request.
    _contentstatus_coderQ   r9   historyencodingreasonrv   elapsedrequestc                s   t  t |   j   d |  _ d |  _ d  |  _ t   |  _ d  |  _ d  |  _	 d  |  _
 g  |  _ d  |  _ t i   |  _ t j d  |  _ d  |  _ d  S)NFr   )superr   rw   r   _content_consumedr   r   rQ   rawr9   r   r   r   r   rv   datetimeZ	timedeltar   r   )r>   )	__class__r@   rA   rw   ?  s    								zResponse.__init__c                s0     j  s   j t   f d d     j D  S)Nc             3   s'   |  ] } | t    | d   f Vq d  S)N)r   )rg   attr)r>   r@   rA   ri   v  s   z(Response.__getstate__.<locals>.<genexpr>)r   contentdict	__attrs__)r>   r@   )r>   rA   __getstate__o  s
    	zResponse.__getstate__c             C   sQ   x* | j    D] \ } } t |  | |  q Wt |  d d  t |  d d   d  S)Nr   Tr   )rr   setattr)r>   staterO   r   r@   r@   rA   __setstate__z  s    zResponse.__setstate__c             C   s   d |  j  S)Nz<Response [%s]>)r   )r>   r@   r@   rA   rx     s    zResponse.__repr__c             C   s   |  j  S)z,Returns true if :attr:`status_code` is 'OK'.)ok)r>   r@   r@   rA   __bool__  s    zResponse.__bool__c             C   s   |  j  S)z,Returns true if :attr:`status_code` is 'OK'.)r   )r>   r@   r@   rA   __nonzero__  s    zResponse.__nonzero__c             C   s   |  j  d  S)z,Allows you to use a response as an iterator.   )iter_content)r>   r@   r@   rA   rD     s    zResponse.__iter__c             C   s+   y |  j    Wn t k
 r& d SYn Xd S)NFT)raise_for_statusr   )r>   r@   r@   rA   r     s
    	zResponse.okc             C   s   d |  j  k o |  j t k S)zTrue if this Response is a well-formed HTTP redirect that could have
        been processed automatically (by :meth:`Session.resolve_redirects`).
        location)rQ   r   REDIRECT_STATI)r>   r@   r@   rA   is_redirect  s    zResponse.is_redirectc             C   s(   d |  j  k o' |  j t j t j f k S)z?True if this Response one of the permanent versions of redirectr   )rQ   r   r2   Zmoved_permanentlypermanent_redirect)r>   r@   r@   rA   is_permanent_redirect  s    zResponse.is_permanent_redirectc             C   s   t  j |  j  d S)z6The apparent encoding, provided by the chardet libraryr   )r.   Zdetectr   )r>   r@   r@   rA   apparent_encoding  s    zResponse.apparent_encodingr   Fc                s      f d d   }  j  r< t  j t  r< t    n2   d k	 rn t   t  rn t d t      t  j    } |   }  j  r | n | } | r t	 |   } | S)a  Iterates over the response data.  When stream=True is set on the
        request, this avoids reading the content at once into memory for
        large responses.  The chunk size is the number of bytes it should
        read into memory.  This is not necessarily the length of each item
        returned as decoding can take place.

        chunk_size must be of type int or None. A value of None will
        function differently depending on the value of `stream`.
        stream=True will read data as it arrives in whatever size the
        chunks are received. If stream=False, data is returned as
        a single chunk.

        If decode_unicode is True, content will be decoded using the best
        available encoding based on the response.
        c              3   s  t   j d  r y, x%  j j   d d D] }  |  Vq. WWq t k
 rq } z t |   WYd  d  } ~ Xq t k
 r } z t |   WYd  d  } ~ Xq t k
 r } z t |   WYd  d  } ~ Xq Xn% x"  j j	    }  |  s P|  Vq Wd  _
 d  S)NstreamZdecode_contentT)rF   r   r   r   r   r   r   r   r   rC   r   )chunkr   )
chunk_sizer>   r@   rA   generate  s     "	z'Response.iter_content.<locals>.generateNz.chunk_size must be an int, it is instead a %s.)
r   rE   r   boolr   intr   typer"   r   )r>   r   decode_unicoder   Zreused_chunksZstream_chunksZchunksr@   )r   r>   rA   r     s    	zResponse.iter_contentNc             c   s   d } x |  j  d | d |  D] } | d k	 r; | | } | rS | j |  } n | j   } | r | d r | r | d d | d k r | j   } n d } x | D] } | Vq Wq W| d k	 r | Vd S)	zIterates over the response data, one line at a time.  When
        stream=True is set on the request, this avoids reading the
        content at once into memory for large responses.

        .. note:: This method is not reentrant safe.
        Nr   r   r   r   r   r   )r   split
splitlinespop)r>   r   r   Z	delimiterpendingr   linesliner@   r@   rA   
iter_lines  s    
.zResponse.iter_linesc             C   s   |  j  d k ru |  j r$ t d   |  j d k sB |  j d k rN d |  _  n' t   j |  j t   po t   |  _  d |  _ |  j  S)z"Content of the response, in bytes.Fz2The content for this response was already consumedr   NT)	r   r   RuntimeErrorr   r   r+   r=   r   CONTENT_CHUNK_SIZE)r>   r@   r@   rA   r      s    		'	zResponse.contentc             C   s   d } |  j  } |  j s" t d  S|  j  d k r: |  j } y t |  j | d d } Wn- t t f k
 r t |  j d d } Yn X| S)a  Content of the response, in unicode.

        If Response.encoding is None, encoding will be guessed using
        ``chardet``.

        The encoding of the response content is determined based solely on HTTP
        headers, following RFC 2616 to the letter. If you can take advantage of
        non-HTTP knowledge to make a better guess at the encoding, you should
        set ``r.encoding`` appropriately before accessing this property.
        Nr8   errorsreplace)r   r   r*   r   LookupErrorr   )r>   r   r   r@   r@   rA   text  s    		
	zResponse.textc             K   s   |  j  rx |  j rx t |  j  d k rx t |  j  } | d k	 rx y  t j |  j j |  |  SWn t k
 rw Yn Xt j |  j |  S)zReturns the json-encoded content of a response, if any.

        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises ValueError: If the response body does not contain valid json.
        rN   N)	r   r   rW   r#   r   loadsrT   UnicodeDecodeErrorr   )r>   kwargsr   r@   r@   rA   r1   :  s    (zResponse.jsonc             C   sg   |  j  j d  } i  } | rc t |  } x6 | D]. } | j d  pR | j d  } | | | <q1 W| S)z8Returns the parsed header links of the response, if any.linkZrelr9   )rQ   r   r!   )r>   r   llinksr   keyr@   r@   rA   r   T  s    zResponse.linksc             C   s   d } t  |  j t  rX y |  j j d  } Wqa t k
 rT |  j j d  } Yqa Xn	 |  j } d |  j k o{ d k  n r d |  j | |  j f } n8 d |  j k o d k  n r d |  j | |  j f } | r t | d	 |   d
 S)z2Raises stored :class:`HTTPError`, if one occurred.r8   zutf-8z
iso-8859-1i  i  z%s Client Error: %s for url: %siX  z%s Server Error: %s for url: %sZresponseN)rE   r   r+   rT   r   r   r9   r   )r>   Zhttp_error_msgr   r@   r@   rA   r   f  s    	zResponse.raise_for_statusc             C   sB   |  j  s |  j j   t |  j d d  } | d k	 r> |   d S)zReleases the connection back to the pool. Once this method has been
        called the underlying ``raw`` object must not be accessed again.

        *Note: Should not normally need to be called explicitly.*
        release_connN)r   r   closer   )r>   r   r@   r@   rA   r     s
    	zResponse.close)r_   r`   ra   r{   r   rw   r   r   rx   r   r   rD   rb   r   r   r   r   r   ITER_CHUNK_SIZEr   r   r   r1   r   r   r   r@   r@   )r   rA   r   5  s,   07&r   )Tr{   re   r   Zencodings.idna	encodingsior   r   rj   r   Z
structuresr   ru   r   rv   r   r	   r
   Zpackagesr   Zpackages.urllib3.fieldsr   Zpackages.urllib3.filepostr   Zpackages.urllib3.utilr   Zpackages.urllib3.exceptionsr   r   r   r   
exceptionsr   r   r   r   r   r   r   Z_internal_utilsr   r   Zutilsr   r   r   r   r    r!   r"   r#   r$   r%   compatr&   r'   r(   r)   r*   r+   r,   r-   r.   r/   r0   r1   r   Zstatus_codesr2   ZmovedfoundotherZtemporary_redirectr   r   ZDEFAULT_REDIRECT_LIMITr   r   r   r5   rd   rq   ry   r   r@   r@   r@   rA   <module>   sB   "4FL
nE 0                                                                                                                                                                                                                                                                                                                                                                                               
QXhf                 @   s  d  Z  d d l Z d d l m Z d d l m Z d d l m Z d d l m Z m	 Z	 m
 Z
 m Z d d l m Z m Z m Z m Z d d	 l m Z m Z m Z d d
 l m Z m Z d d l m Z d d l m Z m Z d d l m Z m Z m  Z  m! Z! d d l" m# Z# d d l$ m% Z% d d l& m' Z' d d l m( Z( m) Z) m* Z* m+ Z+ m, Z, m- Z- d d l. m/ Z/ d d l m0 Z0 d Z1 e	 d d  Z2 e	 d d  Z3 Gd d   d e4  Z5 Gd d   d e5  Z6 d d   Z7 d S)z
requests.session
~~~~~~~~~~~~~~~~

This module provides a Session object to manage and persist settings across
requests (cookies, auth, proxies).
    N)Mapping)datetime   )_basic_auth_str)	cookielibOrderedDicturljoinurlparse)cookiejar_from_dictextract_cookies_to_jarRequestsCookieJarmerge_cookies)RequestPreparedRequestDEFAULT_REDIRECT_LIMIT)default_hooksdispatch_hook)to_native_string)to_key_val_listdefault_headers)TooManyRedirectsInvalidSchemaChunkedEncodingErrorContentDecodingError)RecentlyUsedContainer)CaseInsensitiveDict)HTTPAdapter)requote_uriget_environ_proxiesget_netrc_authshould_bypass_proxiesget_auth_from_urlrewind_body)codes)REDIRECT_STATIi  c             C   s   | d k r |  S|  d k r  | St  | t  o; t  |  t  sB |  S| t |   } | j t |    d d   | j   D } x | D] } | | =q W| S)zDetermines appropriate setting for a given request, taking into account
    the explicit setting on that request, and the setting in the session. If a
    setting is a dictionary, they will be merged together using `dict_class`
    Nc             S   s(   g  |  ] \ } } | d  k r |  q S)N ).0kvr%   r%   3/usr/lib/python3/dist-packages/requests/sessions.py
<listcomp>B   s   	 z!merge_setting.<locals>.<listcomp>)
isinstancer   r   updateitems)Zrequest_settingZsession_setting
dict_classZmerged_settingZ	none_keyskeyr%   r%   r)   merge_setting*   s    r0   c             C   sZ   | d k s! | j  d  g  k r% |  S|  d k sF |  j  d  g  k rJ | St |  | |  S)zProperly merges both requests and session hooks.

    This is necessary because when request_hooks == {'response': []}, the
    merge breaks Session hooks entirely.
    Nresponse)getr0   )Zrequest_hooksZsession_hooksr.   r%   r%   r)   merge_hooksI   s
    !!r3   c               @   sO   e  Z d  Z d d d d d d d  Z d d   Z d d	   Z d
 d   Z d S)SessionRedirectMixinFNTc             k   s  d }	 g  }
 x| j  r | j   } |	 d k rR |
 j |  t |
  } | | _ y | j Wn. t t t f k
 r | j	 j
 d d  Yn X|	 |  j k r t d |  j d |  | j   | j d } | j d  r t | j  } d | j | f } t |  } | j   } | j s:t | j t |   } n t |  } t |  | _ | j r| j | j k r| j |  j | j <|  j | |  | j t j t j f k rd } x! | D] } | j j | d  qWd | _  | j } y | d =Wn t! k
 r	Yn Xt" | j# | | j	  t$ | j# |  j%  | j& | j#  |  j' | |  } |  j( | |  | j) d k	 od	 | k pd | k } | rt* |  | } |  j+ | d | d | d | d | d | d d | } t" |  j% | | j	  |	 d 7}	 | Vq Wd S)z6Receives a Response. Returns a generator of Responses.r   Zdecode_contentFzExceeded %s redirects.r1   locationz//z%s:%sContent-LengthContent-TypeTransfer-EncodingNZCookiestreamtimeoutverifycertproxiesallow_redirectsr   )r6   r7   r8   ),Zis_redirectcopyappendlisthistorycontentr   r   RuntimeErrorrawreadmax_redirectsr   closeheaders
startswithr	   urlschemeZgeturlZnetlocr   r   r   Zis_permanent_redirectredirect_cacherebuild_methodstatus_coder#   Ztemporary_redirectZpermanent_redirectpopZbodyKeyErrorr   Z_cookiesr   cookiesZprepare_cookiesrebuild_proxiesrebuild_authZ_body_positionr"   send)selfrespreqr9   r:   r;   r<   r=   Zadapter_kwargsiZhistprepared_requestZnew_histrK   Zparsed_rurlZparsedZpurged_headersheaderrI   Z
rewindabler%   r%   r)   resolve_redirectsY   sx    	
			
	
z&SessionRedirectMixin.resolve_redirectsc             C   s   | j  } | j } d | k rU t | j j  } t |  } | j | j k rU | d =|  j rj t |  n d } | d k	 r | j |  d S)zWhen being redirected we may want to strip authentication from the
        request to avoid leaking credentials. This method intelligently removes
        and reapplies authentication where possible to avoid credential loss.
        ZAuthorizationN)rI   rK   r	   requestZhostname	trust_envr   Zprepare_auth)rV   rZ   r1   rI   rK   Zoriginal_parsedZredirect_parsedZnew_authr%   r%   r)   rT      s    		z!SessionRedirectMixin.rebuild_authc             C   s  | j  } | j } t |  j } | d k	 r9 | j   n i  } |  j r t |  r t |  } | j | | j d   } | r | j	 | |  d | k r | d =y t
 | |  \ }	 }
 Wn t k
 r d \ }	 }
 Yn X|	 r |
 r t |	 |
  | d <| S)a  This method re-evaluates the proxy configuration by considering the
        environment variables. If we are redirected to a URL covered by
        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing
        proxy keys for this URL (in case they were stripped by a previous
        redirect).

        This method also replaces the Proxy-Authorization header where
        necessary.

        :rtype: dict
        NallzProxy-Authorization)NN)rI   rK   r	   rL   r?   r^   r    r   r2   
setdefaultr!   rQ   r   )rV   rZ   r=   rI   rK   rL   Znew_proxiesZenviron_proxiesproxyZusernameZpasswordr%   r%   r)   rS      s$    		z$SessionRedirectMixin.rebuild_proxiesc             C   s   | j  } | j t j k r- | d k r- d } | j t j k rQ | d k rQ d } | j t j k ru | d k ru d } | | _  d S)zWhen being redirected we may want to change the method of the request
        based on certain specs or browser behavior.
        HEADGETPOSTN)methodrO   r#   Z	see_otherfoundZmoved)rV   rZ   r1   re   r%   r%   r)   rN     s    	z#SessionRedirectMixin.rebuild_method)__name__
__module____qualname__r\   rT   rS   rN   r%   r%   r%   r)   r4   X   s
   l&r4   c               @   s]  e  Z d  Z d Z d d d d d d d d	 d
 d d d d g Z d d   Z d d   Z d d   Z d d   Z d d d d d d d d d d d d d d d d  Z	 d d   Z
 d d   Z d d    Z d d d! d"  Z d d# d$  Z d d% d&  Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d/ d0   Z d1 d2   Z d3 d4   Z d5 d6   Z d S)7Sessiona~  A Requests session.

    Provides cookie persistence, connection-pooling, and configuration.

    Basic Usage::

      >>> import requests
      >>> s = requests.Session()
      >>> s.get('http://httpbin.org/get')
      <Response [200]>

    Or as a context manager::

      >>> with requests.Session() as s:
      >>>     s.get('http://httpbin.org/get')
      <Response [200]>
    rI   rR   authr=   hooksparamsr;   r<   Zprefetchadaptersr9   r^   rG   c             C   s   t    |  _ d  |  _ i  |  _ t   |  _ i  |  _ d |  _ d |  _ d  |  _	 t
 |  _ d |  _ t i   |  _ t   |  _ |  j d t    |  j d t    t t  |  _ d  S)NFTzhttps://zhttp://)r   rI   rk   r=   r   rl   rm   r9   r;   r<   r   rG   r^   r
   rR   r   rn   mountr   r   REDIRECT_CACHE_SIZErM   )rV   r%   r%   r)   __init__4  s    								zSession.__init__c             C   s   |  S)Nr%   )rV   r%   r%   r)   	__enter__m  s    zSession.__enter__c             G   s   |  j    d  S)N)rH   )rV   argsr%   r%   r)   __exit__p  s    zSession.__exit__c             C   s$  | j  p i  } t | t j  s- t |  } t t t   |  j   |  } | j } |  j r} | r} |  j r} t	 | j
  } t   } | j d | j j   d | j
 d | j d | j d | j d t | j |  j d t d t | j |  j  d	 t | |  j  d
 | d t | j |  j   
| S)a  Constructs a :class:`PreparedRequest <PreparedRequest>` for
        transmission and returns it. The :class:`PreparedRequest` has settings
        merged from the :class:`Request <Request>` instance and those of the
        :class:`Session`.

        :param request: :class:`Request` instance to prepare with this
            session's settings.
        :rtype: requests.PreparedRequest
        re   rK   filesdatajsonrI   r.   rm   rk   rR   rl   )rR   r+   r   Z	CookieJarr
   r   r   rk   r^   r   rK   r   Zpreparere   upperru   rv   rw   r0   rI   r   rm   r3   rl   )rV   r]   rR   Zmerged_cookiesrk   pr%   r%   r)   prepare_requests  s*    
							zSession.prepare_requestNTc             C   s   t  d | j   d | d | d | d | p- i  d | d | p? i  d | d	 | d
 |  
} |  j |  } | po i  } |  j | j | | | |  } d |	 d |
 i } | j |  |  j | |  } | S)a  Constructs a :class:`Request <Request>`, prepares it and sends it.
        Returns :class:`Response <Response>` object.

        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, bytes, or file-like object to send
            in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``'filename': file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) whether the SSL cert will be verified.
            A CA_BUNDLE path can also be provided. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, ('cert', 'key') pair.
        :rtype: requests.Response
        re   rK   rI   ru   rv   rw   rm   rk   rR   rl   r:   r>   )r   rx   rz   merge_environment_settingsrK   r,   rU   )rV   re   rK   rm   rv   rI   rR   ru   rk   r:   r>   r=   rl   r9   r;   r<   rw   rX   ZprepZsettingsZsend_kwargsrW   r%   r%   r)   r]     s(    3	zSession.requestc             K   s#   | j  d d  |  j d | |  S)zSends a GET request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        r>   Trc   )r`   r]   )rV   rK   kwargsr%   r%   r)   r2     s    zSession.getc             K   s#   | j  d d  |  j d | |  S)zSends a OPTIONS request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        r>   TZOPTIONS)r`   r]   )rV   rK   r|   r%   r%   r)   options  s    zSession.optionsc             K   s#   | j  d d  |  j d | |  S)zSends a HEAD request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        r>   Frb   )r`   r]   )rV   rK   r|   r%   r%   r)   head  s    zSession.headc             K   s   |  j  d | d | d | | S)a  Sends a POST request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        rd   rv   rw   )r]   )rV   rK   rv   rw   r|   r%   r%   r)   post  s    
zSession.postc             K   s   |  j  d | d | | S)aY  Sends a PUT request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ZPUTrv   )r]   )rV   rK   rv   r|   r%   r%   r)   put  s    	zSession.putc             K   s   |  j  d | d | | S)a[  Sends a PATCH request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ZPATCHrv   )r]   )rV   rK   rv   r|   r%   r%   r)   patch$  s    	zSession.patchc             K   s   |  j  d | |  S)zSends a DELETE request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ZDELETE)r]   )rV   rK   r|   r%   r%   r)   delete/  s    zSession.deletec             K   s  | j  d |  j  | j  d |  j  | j  d |  j  | j  d |  j  t | t  rg t d   | j d d  } | j	 d  } | j
 } | r t   } xQ | j |  j k r | j | j  |  j j	 | j  } | | k r P| | _ q W|  j d | j  } t j   }	 | j | |  }
 t j   |	 |
 _ t d	 | |
 |  }
 |
 j rx* |
 j D] } t |  j | j | j  qbWt |  j | |
 j  |  j |
 | |  } | rd
 d   | D n g  } | r| j d |
  | j   }
 | |
 _ | s|
 j |
 S)zR
        Send a given PreparedRequest.

        :rtype: requests.Response
        r9   r;   r<   r=   z#You can only send PreparedRequests.r>   TrK   r1   c             S   s   g  |  ] } |  q Sr%   r%   )r&   rW   r%   r%   r)   r*   v  s   	 z Session.send.<locals>.<listcomp>r   )r`   r9   r;   r<   r=   r+   r   
ValueErrorrP   r2   rl   setrK   rM   addget_adapterr   ZutcnowrU   elapsedr   rB   r   rR   r]   rE   r\   insertrC   )rV   r]   r|   r>   r9   rl   Zchecked_urlsZnew_urladapterstartrrW   genrB   r%   r%   r)   rU   9  sF    				zSession.sendc       	      C   s   |  j  r t |  p i  } x* | j   D] \ } } | j | |  q( W| d k s` | d k r t j j d  p t j j d  } t | |  j  } t | |  j	  } t | |  j
  } t | |  j  } d | d | d | d | i S)	z^
        Check the environment and merge it with some settings.

        :rtype: dict
        TNZREQUESTS_CA_BUNDLEZCURL_CA_BUNDLEr;   r=   r9   r<   )r^   r   r-   r`   osenvironr2   r0   r=   r9   r;   r<   )	rV   rK   r=   r9   r;   r<   Zenv_proxiesr'   r(   r%   r%   r)   r{     s    	z"Session.merge_environment_settingsc             C   sM   x6 |  j  j   D]% \ } } | j   j |  r | Sq Wt d |   d S)z~
        Returns the appropriate connection adapter for the given URL.

        :rtype: requests.adapters.BaseAdapter
        z*No connection adapters were found for '%s'N)rn   r-   lowerrJ   r   )rV   rK   prefixr   r%   r%   r)   r     s    zSession.get_adapterc             C   s(   x! |  j  j   D] } | j   q Wd S)z+Closes all adapters and as such the sessionN)rn   valuesrH   )rV   r(   r%   r%   r)   rH     s    zSession.closec                sW   | |  j    <  f d d   |  j  D } x' | D] } |  j  j |  |  j  | <q0 Wd S)ztRegisters a connection adapter to a prefix.

        Adapters are sorted in descending order by key length.
        c                s.   g  |  ]$ } t  |  t     k  r |  q Sr%   )len)r&   r'   )r   r%   r)   r*     s   	 z!Session.mount.<locals>.<listcomp>N)rn   rP   )rV   r   r   Zkeys_to_mover/   r%   )r   r)   ro     s    zSession.mountc                s9   t    f d d     j D  } t    j  | d <| S)Nc             3   s'   |  ] } | t    | d   f Vq d  S)N)getattr)r&   attr)rV   r%   r)   	<genexpr>  s    z'Session.__getstate__.<locals>.<genexpr>rM   )dict	__attrs__rM   )rV   stater%   )rV   r)   __getstate__  s    "zSession.__getstate__c             C   s|   | j  d i   } x* | j   D] \ } } t |  | |  q Wt t  |  _ x' | j   D] \ } } | |  j | <q[ Wd  S)NrM   )rP   r-   setattrr   rp   rM   )rV   r   rM   r   valueZredirectZtor%   r%   r)   __setstate__  s    zSession.__setstate__)rg   rh   ri   __doc__r   rq   rr   rt   rz   r]   r2   r}   r~   r   r   r   r   rU   r{   r   rH   ro   r   r   r%   r%   r%   r)   rj     sH   	9)C
Lrj   c               C   s   t    S)zQ
    Returns a :class:`Session` for context-management.

    :rtype: Session
    )rj   r%   r%   r%   r)   session  s    r   )8r   r   collectionsr   r   rk   r   compatr   r   r   r	   rR   r
   r   r   r   Zmodelsr   r   r   rl   r   r   Z_internal_utilsr   Zutilsr   r   
exceptionsr   r   r   r   Zpackages.urllib3._collectionsr   Z
structuresr   rn   r   r   r   r   r    r!   r"   Zstatus_codesr#   r$   rp   r0   r3   objectr4   rj   r   r%   r%   r%   r)   <module>	   s0   """.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
eEX                 @   s$  d  d l  m Z d d d d d d d d d
 d d d d d d d d d d d d d d! d d$ d d) d d+ d d- d d/ d d3 d d5 d d8 d d: d d< d d> d dB d dF d dI d dK d dN d dP d dS d dV d dX d d\ d d_ d da d dc d de d dh d dj d dl d dp d dt d dv d dz d d| d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d dd dd dd dd diD Z e d d  Z x` e j   D]R \ Z Z xC e D]; Z e e e e  e j	 d  se e e j
   e  qWqWd S(     )
LookupDictd   continuee   switching_protocolsf   
processingg   
checkpointz   uri_too_longrequest_uri_too_long   okokayall_okall_okayall_good\o/      created   accepted   non_authoritative_infonon_authoritative_information   
no_content   reset_contentreset   partial_contentpartial   multi_statusmultiple_statusmulti_statimultiple_stati   already_reported   im_usedi,  multiple_choicesi-  moved_permanentlymoved\o-i.  foundi/  	see_otherotheri0  not_modifiedi1  	use_proxyi2  switch_proxyi3  temporary_redirecttemporary_moved	temporaryi4  permanent_redirectresume_incompleteresumei  bad_requestbadi  unauthorizedi  payment_requiredpaymenti  	forbiddeni  	not_found-o-i  method_not_allowednot_allowedi  not_acceptablei  proxy_authentication_required
proxy_authproxy_authenticationi  request_timeouttimeouti  conflicti  gonei  length_requiredi  precondition_failedpreconditioni  request_entity_too_largei  request_uri_too_largei  unsupported_media_typeunsupported_media
media_typei  requested_range_not_satisfiablerequested_rangerange_not_satisfiablei  expectation_failedi  im_a_teapotteapoti_am_a_teapoti  misdirected_requesti  unprocessable_entityunprocessablei  lockedi  failed_dependency
dependencyi  unordered_collection	unorderedi  upgrade_requiredupgradei  precondition_requiredi  too_many_requeststoo_manyi  header_fields_too_largefields_too_largei  no_responsenonei  
retry_withretryi  $blocked_by_windows_parental_controlsparental_controlsi  unavailable_for_legal_reasonslegal_reasonsi  client_closed_requesti  internal_server_errorserver_error/o\   i  not_implementedi  bad_gatewayi  service_unavailableunavailablei  gateway_timeouti  http_version_not_supportedhttp_versioni  variant_also_negotiatesi  insufficient_storagei  bandwidth_limit_exceeded	bandwidthi  not_extendedi  network_authentication_requirednetwork_authnetwork_authenticationnameZstatus_codes\N)r   )r   )r   )r
   )r   r   )r   r   r   r   r   r   r   )r   )r   )r   r   )r   )r    r!   )r#   r$   )r&   r'   r(   r)   )r+   )r-   )r.   )r/   r0   r1   )r2   )r3   r4   )r5   )r6   )r7   )r8   r9   r:   )r;   r<   r=   )r>   r?   )r@   )rA   rB   )rC   )rD   rE   )rF   rG   )rH   )rI   rJ   rK   )rL   rM   )rN   )rO   )rP   )rQ   rR   )rS   )rT   )rU   rV   rW   )rX   rY   rZ   )r[   )r\   r]   r^   )r_   )r`   ra   )rb   )rc   rd   )re   rf   )rg   rh   )ri   rR   )rj   rk   )rl   rm   )rn   ro   )rp   rq   )rr   rs   )rt   ru   )rv   )rw   rx   ry   rz   )r{   )r|   )r}   r~   )r   )r   r   )r   )r   )r   r   )r   )r   r   r   )Z
structuresr   Z_codesZcodesitemscodeZtitlestitlesetattr
startswithupper r   r   7/usr/lib/python3/dist-packages/requests/status_codes.py<module>   s                                                                                                                                                                                                        '''
Debian and other distributions "unbundle" requests' vendored dependencies, and
rewrite all imports to use the global versions of ``urllib3`` and ``chardet``.
The problem with this is that not only requests itself imports those
dependencies, but third-party code outside of the distros' control too.

In reaction to these problems, the distro maintainers replaced
``requests.packages`` with a magical "stub module" that imports the correct
modules. The implementations were varying in quality and all had severe
problems. For example, a symlink (or hardlink) that links the correct modules
into place introduces problems regarding object identity, since you now have
two modules in `sys.modules` with the same API, but different identities::

    requests.packages.urllib3 is not urllib3

With version ``2.5.2``, requests started to maintain its own stub, so that
distro-specific breakage would be reduced to a minimum, even though the whole
issue is not requests' fault in the first place. See
https://github.com/kennethreitz/requests/pull/2375 for the corresponding pull
request.
'''

from __future__ import absolute_import
import sys

# On Debian we use the unbundling strategy implemented by pip inside
# pip._vendor.__init__.
def vendored(modulename):
    vendored_name = "{0}.{1}".format(__name__, modulename)

    try:
        __import__(vendored_name, globals(), locals(), level=0)
    except ImportError:
        try:
            __import__(modulename, globals(), locals(), level=0)
        except ImportError:
            # We can just silently allow import failures to pass here. If we
            # got to this point it means that ``import requests.packages.whatever``
            # failed and so did ``import whatever``. Since we're importing this
            # upfront in an attempt to alias imports, not erroring here will
            # just mean we get a regular import error whenever requests
            # *actually* tries to import one of these modules to use it, which
            # actually gives us a better error message than we would have
            # otherwise gotten.
            pass
        else:
            sys.modules[vendored_name] = sys.modules[modulename]
            base, head = vendored_name.rsplit(".", 1)
            setattr(sys.modules[base], head, sys.modules[modulename])

vendored('chardet')
vendored('idna')
vendored('urllib3')
vendored('urllib3._collections')
vendored('urllib3.connection')
vendored('urllib3.connectionpool')
vendored('urllib3.contrib')
vendored('urllib3.contrib.ntlmpool')
vendored('urllib3.contrib.pyopenssl')
vendored('urllib3.exceptions')
vendored('urllib3.fields')
vendored('urllib3.filepost')
vendored('urllib3.packages')
vendored('urllib3.packages.ordered_dict')
vendored('urllib3.packages.six')
vendored('urllib3.packages.ssl_match_hostname')
vendored('urllib3.packages.ssl_match_hostname._implementation')
vendored('urllib3.poolmanager')
vendored('urllib3.request')
vendored('urllib3.response')
vendored('urllib3.util')
vendored('urllib3.util.connection')
vendored('urllib3.util.request')
vendored('urllib3.util.response')
vendored('urllib3.util.retry')
vendored('urllib3.util.ssl_')
vendored('urllib3.util.timeout')
vendored('urllib3.util.url')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
eEX                 @   sU   d  Z  d d l Z d d l m Z Gd d   d e j  Z Gd d   d e  Z d S)	zO
requests.structures
~~~~~~~~~~~~~~~~~~~

Data structures that power Requests.
    N   )OrderedDictc               @   s   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d S)CaseInsensitiveDicta  A case-insensitive ``dict``-like object.

    Implements all methods and operations of
    ``collections.MutableMapping`` as well as dict's ``copy``. Also
    provides ``lower_items``.

    All keys are expected to be strings. The structure remembers the
    case of the last key to be set, and ``iter(instance)``,
    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``
    will contain case-sensitive keys. However, querying and contains
    testing is case insensitive::

        cid = CaseInsensitiveDict()
        cid['Accept'] = 'application/json'
        cid['aCCEPT'] == 'application/json'  # True
        list(cid) == ['Accept']  # True

    For example, ``headers['content-encoding']`` will return the
    value of a ``'Content-Encoding'`` response header, regardless
    of how the header name was originally stored.

    If the constructor, ``.update``, or equality comparison
    operations are given keys that have equal ``.lower()``s, the
    behavior is undefined.
    Nc             K   s2   t    |  _ | d  k r i  } |  j | |  d  S)N)r   _storeupdate)selfdatakwargs r
   5/usr/lib/python3/dist-packages/requests/structures.py__init__*   s    zCaseInsensitiveDict.__init__c             C   s   | | f |  j  | j   <d  S)N)r   lower)r   keyvaluer
   r
   r   __setitem__0   s    zCaseInsensitiveDict.__setitem__c             C   s   |  j  | j   d S)Nr   )r   r   )r   r   r
   r
   r   __getitem__5   s    zCaseInsensitiveDict.__getitem__c             C   s   |  j  | j   =d  S)N)r   r   )r   r   r
   r
   r   __delitem__8   s    zCaseInsensitiveDict.__delitem__c             C   s   d d   |  j  j   D S)Nc             s   s   |  ] \ } } | Vq d  S)Nr
   ).0ZcasedkeyZmappedvaluer
   r
   r   	<genexpr><   s    z/CaseInsensitiveDict.__iter__.<locals>.<genexpr>)r   values)r   r
   r
   r   __iter__;   s    zCaseInsensitiveDict.__iter__c             C   s   t  |  j  S)N)lenr   )r   r
   r
   r   __len__>   s    zCaseInsensitiveDict.__len__c             C   s   d d   |  j  j   D S)z.Like iteritems(), but with all lowercase keys.c             s   s%   |  ] \ } } | | d  f Vq d S)r   Nr
   )r   ZlowerkeyZkeyvalr
   r
   r   r   D   s   z2CaseInsensitiveDict.lower_items.<locals>.<genexpr>)r   items)r   r
   r
   r   lower_itemsA   s    	zCaseInsensitiveDict.lower_itemsc             C   sG   t  | t j  r! t |  } n t St |  j    t | j    k S)N)
isinstancecollectionsMappingr   NotImplementeddictr   )r   otherr
   r
   r   __eq__I   s    zCaseInsensitiveDict.__eq__c             C   s   t  |  j j    S)N)r   r   r   )r   r
   r
   r   copyR   s    zCaseInsensitiveDict.copyc             C   s   t  t |  j     S)N)strr   r   )r   r
   r
   r   __repr__U   s    zCaseInsensitiveDict.__repr__)__name__
__module____qualname____doc__r   r   r   r   r   r   r   r!   r"   r$   r
   r
   r
   r   r      s   	r   c                   sR   e  Z d  Z d Z d   f d d  Z d d   Z d d   Z d d	 d
  Z   S)
LookupDictzDictionary lookup object.Nc                s    | |  _  t t |   j   d  S)N)namesuperr)   r   )r   r*   )	__class__r
   r   r   \   s    	zLookupDict.__init__c             C   s   d |  j  S)Nz<lookup '%s'>)r*   )r   r
   r
   r   r$   `   s    zLookupDict.__repr__c             C   s   |  j  j | d   S)N)__dict__get)r   r   r
   r
   r   r   c   s    zLookupDict.__getitem__c             C   s   |  j  j | |  S)N)r-   r.   )r   r   defaultr
   r
   r   r.   h   s    zLookupDict.get)r%   r&   r'   r(   r   r$   r   r.   r
   r
   )r,   r   r)   Y   s
   r)   )r(   r   compatr   MutableMappingr   r   r)   r
   r
   r
   r   <module>   s   J                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
QX`                 @   sW  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 m Z d d l
 m Z d d l m Z d d l m Z d d l m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z d d	 l m Z m Z d d
 l  m! Z! d d l" m# Z# m$ Z$ m% Z% m& Z& e f Z' d\ Z( e j)   Z* d d   Z+ d d   Z, d d d  Z- d d   Z. d d   Z/ d d   Z0 d d   Z1 d d   Z2 d d d   Z3 d! d"   Z4 d# d$   Z5 d% d&   Z6 d' d(   Z7 d) d*   Z8 d+ d,   Z9 d- d.   Z: e; d/ d0  Z< d1 d2   Z= d3 d4   Z> d5 d6   Z? d7 d8   Z@ d9 d:   ZA d; d<   ZB d= d>   ZC d? d@   ZD dA dB   ZE dC dD dE  ZF dF dG   ZG dH dI   ZH dJ jI dK  ZJ eJ dL ZK eJ dM ZL dN dO   ZM dP dQ   ZN dR dS   ZO e jP dT  ZQ e jP dU  ZR dV dW   ZS dX dY   ZT dZ d[   ZU d S)]z
requests.utils
~~~~~~~~~~~~~~

This module provides utility functions that are used within Requests
that are also useful for external consumption.
    N   )__version__)certs)to_native_string)parse_http_list)quoteurlparsebytesstrOrderedDictunquote
getproxiesproxy_bypass
urlunparse
basestringinteger_types)RequestsCookieJarcookiejar_from_dict)CaseInsensitiveDict)
InvalidURLInvalidHeaderFileModeWarningUnrewindableBodyError.netrc_netrcc             C   s   t  |  d  r |  j   }  |  S)z/Returns an internal sequence dictionary update.items)hasattrr   )d r   0/usr/lib/python3/dist-packages/requests/utils.pydict_to_sequence)   s    r    c             C   sf  d  } d } t  |  d  r* t |   } n t  |  d  rE |  j } nh t  |  d  r y |  j   } Wn t j k
 r{ Yn2 Xt j |  j } d |  j k r t	 j
 d t  t  |  d  rCy |  j   } Wn* t t f k
 r | d  k	 r | } YnK Xt  |  d  rC| d  k rC|  j d d	  |  j   } |  j | p?d  | d  k rUd } t d | |  S)
Nr   __len__lenfilenoba%  Requests has determined the content-length for this request using the binary size of the file: however, the file has been opened in text mode (i.e. without the 'b' flag in the mode). This may lead to an incorrect content-length. In Requests 3.0, support will be removed for files in text mode.tellseek   )r   r"   r#   ioUnsupportedOperationosfstatst_sizemodewarningswarnr   r%   OSErrorIOErrorr&   max)oZtotal_lengthZcurrent_positionr#   r   r   r   	super_len2   s:    r4   Fc             C   sb  yCd d l  m  } m } d } x_ t D]W } y t j j d j |   } Wn t k
 rc d SYn Xt j j |  r& | } Pq& W| d k r d St	 |   } d } t
 |  t  r | j d  } | j j |  d }	 yG | |  j |	  }
 |
 r|
 d rd n d } |
 | |
 d f SWn! | t f k
 rA| r=  Yn XWn t t f k
 r]Yn Xd S)	z;Returns the Requests tuple auth for a given url from netrc.r   )netrcNetrcParseErrorNz~/{0}   :asciir   r'   )r5   r6   NETRC_FILESr*   path
expanduserformatKeyErrorexistsr   
isinstancer
   decodenetlocsplitZauthenticatorsr1   ImportErrorAttributeError)urlZraise_errorsr5   r6   Z
netrc_pathflocZriZsplitstrhostr   Zlogin_ir   r   r   get_netrc_authm   s8    	rI   c             C   s[   t  |  d d  } | rW t | t  rW | d d k rW | d d k rW t j j |  Sd S)z0Tries to guess the filename of the given object.nameNr   <r   >)getattrr?   r   r*   r:   basename)objrJ   r   r   r   guess_filename   s    %rQ   c             C   sA   |  d k r d St  |  t t t t f  r7 t d   t |   S)a  Take an object and test to see if it can be represented as a
    dictionary. Unless it can not be represented as such, return an
    OrderedDict, e.g.,

    ::

        >>> from_key_val_list([('key', 'val')])
        OrderedDict([('key', 'val')])
        >>> from_key_val_list('string')
        ValueError: need more than 1 value to unpack
        >>> from_key_val_list({'key': 'val'})
        OrderedDict([('key', 'val')])

    :rtype: OrderedDict
    Nz+cannot encode objects that are not 2-tuples)r?   r
   r	   boolint
ValueErrorr   )valuer   r   r   from_key_val_list   s
    rV   c             C   s_   |  d k r d St  |  t t t t f  r7 t d   t  |  t j  rU |  j   }  t	 |   S)a  Take an object and test to see if it can be represented as a
    dictionary. If it can be, return a list of tuples, e.g.,

    ::

        >>> to_key_val_list([('key', 'val')])
        [('key', 'val')]
        >>> to_key_val_list({'key': 'val'})
        [('key', 'val')]
        >>> to_key_val_list('string')
        ValueError: cannot encode objects that are not 2-tuples.

    :rtype: list
    Nz+cannot encode objects that are not 2-tuples)
r?   r
   r	   rR   rS   rT   collectionsMappingr   list)rU   r   r   r   to_key_val_list   s    rZ   c             C   st   g  } xg t  |   D]Y } | d d  | d d  k oD d k n r_ t | d d   } | j |  q W| S)a  Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Quotes are removed automatically after parsing.

    It basically works like :func:`parse_set_header` just that items
    may appear multiple times and case sensitivity is preserved.

    The return value is a standard :class:`list`:

    >>> parse_list_header('token, "quoted value"')
    ['token', 'quoted value']

    To create a header from the :class:`list` again, use the
    :func:`dump_header` function.

    :param value: a string with a list header.
    :return: :class:`list`
    :rtype: list
    Nr   "rM   rM   )_parse_list_headerunquote_header_valueappend)rU   resultitemr   r   r   parse_list_header   s    0ra   c             C   s   i  } x t  |   D] } d | k r2 d | | <q | j d d  \ } }  |  d d  |  d d  k ou d k n r t |  d d   }  |  | | <q W| S)a^  Parse lists of key, value pairs as described by RFC 2068 Section 2 and
    convert them into a python dict:

    >>> d = parse_dict_header('foo="is a fish", bar="as well"')
    >>> type(d) is dict
    True
    >>> sorted(d.items())
    [('bar', 'as well'), ('foo', 'is a fish')]

    If there is no value for a key it will be `None`:

    >>> parse_dict_header('key_without_value')
    {'key_without_value': None}

    To create a header from the :class:`dict` again, use the
    :func:`dump_header` function.

    :param value: a string with a dict header.
    :return: :class:`dict`
    :rtype: dict
    =Nr   r[   rM   rM   )r\   rB   r]   )rU   r_   r`   rJ   r   r   r   parse_dict_header   s    
0rc   c             C   sw   |  rs |  d |  d	 k o% d k n rs |  d d
  }  | sW |  d d  d k rs |  j  d d  j  d d  S|  S)zUnquotes a header value.  (Reversal of :func:`quote_header_value`).
    This does not use the real unquoting but what browsers are actually
    using for quoting.

    :param value: the header value to unquote.
    :rtype: str
    r   r   r[   Nr'   z\\\z\"rM   rM   )replace)rU   Zis_filenamer   r   r   r]      s
    *r]   c             C   s+   i  } x |  D] } | j  | | j <q W| S)zReturns a key/value dictionary from a CookieJar.

    :param cj: CookieJar object to extract cookies from.
    :rtype: dict
    )rU   rJ   )cjcookie_dictZcookier   r   r   dict_from_cookiejar9  s    rh   c             C   s   t  | |   S)zReturns a CookieJar from a key/value dictionary.

    :param cj: CookieJar to insert cookies into.
    :param cookie_dict: Dict of key/values to insert into CookieJar.
    :rtype: CookieJar
    )r   )rf   rg   r   r   r   add_dict_to_cookiejarH  s    ri   c             C   sv   t  j d t  t j d d t j } t j d d t j } t j d  } | j |   | j |   | j |   S)zlReturns encodings from given content string.

    :param content: bytestring to extract encodings from.
    zIn requests 3.0, get_encodings_from_content will be removed. For more information, please see the discussion on issue #2266. (This warning should only appear once.)z!<meta.*?charset=["\']*(.+?)["\'>]flagsz+<meta.*?content=["\']*;?charset=(.+?)["\'>]z$^<\?xml.*?encoding=["\']*(.+?)["\'>])r.   r/   DeprecationWarningrecompileIfindall)contentZ
charset_reZ	pragma_reZxml_rer   r   r   get_encodings_from_contentS  s    rq   c             C   s_   |  j  d  } | s d St j |  \ } } d | k rK | d j d  Sd | k r[ d Sd S)z}Returns encodings from given HTTP Header Dict.

    :param headers: dictionary to extract encoding from.
    :rtype: str
    zcontent-typeNcharsetz'"textz
ISO-8859-1)getcgiZparse_headerstrip)headersZcontent_typeparamsr   r   r   get_encoding_from_headersg  s    ry   c             c   s   | j  d k r) x |  D] } | Vq Wd St j | j   d d  } x( |  D]  } | j |  } | rK | VqK W| j d d d } | r | Vd S)zStream decodes a iterator.Nerrorsre       finalT)encodingcodecsgetincrementaldecoderr@   )iteratorrr`   decoderchunkrvr   r   r   stream_decode_response_unicode|  s    		r   c             c   sd   d } | d k s | d k r* t  |   } x3 | t  |   k  r_ |  | | |  V| | 7} q- Wd S)z Iterate over slices of a string.r   N)r"   )stringZslice_lengthposr   r   r   iter_slices  s    r   c             C   s   t  j d t  g  } t |  j  } | ra y t |  j |  SWn t k
 r` | j |  Yn Xy t |  j | d d SWn t	 k
 r |  j SYn Xd S)zReturns the requested content back in unicode.

    :param r: Response object to get unicode content from.

    Tried:

    1. charset from content-type
    2. fall back and replace all unicode characters

    :rtype: str
    zIn requests 3.0, get_unicode_from_response will be removed. For more information, please see the discussion on issue #2266. (This warning should only appear once.)rz   re   N)
r.   r/   rk   ry   rw   r
   rp   UnicodeErrorr^   	TypeError)r   Ztried_encodingsr}   r   r   r   get_unicode_from_response  s    r   Z4ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzz0123456789-._~c             C   s   |  j  d  } x t d t |   D] } | | d d  } t |  d k r | j   r y t t | d   } Wn" t k
 r t d |   Yn X| t k r | | | d d  | | <q d | | | | <q% d | | | | <q% Wd j	 |  S)	zUn-escape any percent-escape sequences in a URI that are unreserved
    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.

    :rtype: str
    %r   r   r'      z%Invalid percent-escape sequence: '%s'N )
rB   ranger"   isalnumchrrS   rT   r   UNRESERVED_SETjoin)uripartsihcr   r   r   unquote_unreserved  s    r   c             C   sO   d } d } y t  t |   d | SWn" t k
 rJ t  |  d | SYn Xd S)zRe-quote the given URI.

    This function passes the given URI through an unquote/quote cycle to
    ensure that it is fully and consistently quoted.

    :rtype: str
    z!#$%&'()*+,/:;=?@[]~z!#$&'()*+,/:;=?@[]~ZsafeN)r   r   r   )r   Zsafe_with_percentZsafe_without_percentr   r   r   requote_uri  s    r   c             C   s   t  j d t j |    d } | j d  \ } } t  j d t j t t |     d } t  j d t j |   d | @} | | @| | @k S)zThis function allows you to check if on IP belongs to a network subnet

    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24
             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24

    :rtype: bool
    z=Lr   /)structZunpacksocket	inet_atonrB   dotted_netmaskrS   )ipZnetZipaddrZnetaddrbitsZnetmaskZnetworkr   r   r   address_in_network  s
    +#r   c             C   s/   d d d |  >d A} t  j t j d |   S)zConverts mask from /xx format to xxx.xxx.xxx.xxx

    Example: if mask is 24 function returns 255.255.255.0

    :rtype: str
    l    r       z>I)r   Z	inet_ntoar   Zpack)maskr   r   r   r   r     s    r   c             C   s1   y t  j |   Wn t  j k
 r, d SYn Xd S)z
    :rtype: bool
    FT)r   r   error)Z	string_ipr   r   r   is_ipv4_address
  s
    	r   c             C   s   |  j  d  d k r y t |  j d  d  } Wn t k
 rJ d SYn X| d k  sc | d k rg d Sy t j |  j d  d  Wq t j k
 r d SYq Xn d Sd S)zV
    Very simple check of the cidr format in no_proxy variable.

    :rtype: bool
    r   r   Fr   r   T)countrS   rB   rT   r   r   r   )Zstring_networkr   r   r   r   is_valid_cidr  s    	r   c             C   s<  d d   } | d  } t  |   j } | r d d   | j d d  j d  D } | j d	  d
 } t |  r x | D]8 } t |  r t | |  r d Sq{ | | k r{ d Sq{ Wn@ x= | D]5 } | j |  s | j d	  d
 j |  r d Sq Wy t |  } Wn! t	 t
 j f k
 r-d } Yn X| r8d Sd S)zL
    Returns whether we should bypass proxies or not.

    :rtype: bool
    c             S   s(   t  j j |   p' t  j j |  j    S)N)r*   environrt   upper)kr   r   r   <lambda>3  s    z'should_bypass_proxies.<locals>.<lambda>no_proxyc             s   s   |  ] } | r | Vq d  S)Nr   ).0rH   r   r   r   	<genexpr>>  s    z(should_bypass_proxies.<locals>.<genexpr> r   ,:r   TF)r   rA   re   rB   r   r   r   endswithr   r   r   Zgaierror)rE   Z	get_proxyr   rA   r   Zproxy_iprH   Zbypassr   r   r   should_bypass_proxies-  s.    (+r   c             C   s   t  |   r i  St   Sd S)zA
    Return a dict of environment proxies.

    :rtype: dict
    N)r   r   )rE   r   r   r   get_environ_proxiesc  s    r   c             C   s   | p	 i  } t  |   } | j d k rC | j | j | j d   S| j d | j | j d | j d g } d } x% | D] } | | k rz | | } Pqz W| S)zSelect a proxy for the url, if applicable.

    :param url: The url being for the request
    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
    Nallz://zall://)r   Zhostnamert   scheme)rE   ZproxiesZurlpartsZ
proxy_keysproxyZ	proxy_keyr   r   r   select_proxyo  s    
	
r   zpython-requestsc             C   s   d |  t  f S)zO
    Return a string representing the default user agent.

    :rtype: str
    z%s/%s)r   )rJ   r   r   r   default_user_agent  s    r   c            	   C   s.   t  d t   d d j d
  d d d d	 i  S)z9
    :rtype: requests.structures.CaseInsensitiveDict
    z
User-AgentzAccept-Encodingz, gzipdeflateZAcceptz*/*Z
Connectionz
keep-alive)r   r   )r   r   r   r   r   r   r   default_headers  s
    	r   c       	      C   s   g  } d } x t  j d |   D] } y | j d d  \ } } Wn t k
 rb | d } } Yn Xd | j d  i } xb | j d  D]Q } y | j d  \ } }  Wn t k
 r PYn X|  j |  | | j |  <q W| j |  q W| S)	zReturn a dict of parsed link headers proxies.

    i.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"

    :rtype: list
    z '"z, *<;r   r   rE   z<> '"rb   )rl   rB   rT   rv   r^   )	rU   ZlinksZreplace_charsvalrE   rx   linkZparamkeyr   r   r   parse_header_links  s      r    r8   r'      c             C   s  |  d d  } | t  j t  j f k r, d S| d d  t  j k rI d S| d d  t  j t  j f k ro d S| j t  } | d k r d	 S| d k r | d d d  t k r d
 S| d d d  t k r d S| d k r| d d  t	 k r d S| d d  t	 k rd Sd S)z
    :rtype: str
    N   zutf-32r   z	utf-8-sigr'   zutf-16r   zutf-8z	utf-16-ber   z	utf-16-lez	utf-32-bez	utf-32-le)
r~   BOM_UTF32_LEBOM32_BEBOM_UTF8BOM_UTF16_LEBOM_UTF16_BEr   _null_null2_null3)dataZsampleZ	nullcountr   r   r   guess_json_utf  s*    "r   c             C   sP   t  |  |  \ } } } } } } | s4 | | } } t | | | | | | f  S)zGiven a URL that may or may not have a scheme, prepend the given scheme.
    Does not replace a present scheme with the one provided as an argument.

    :rtype: str
    )r   r   )rE   Z
new_schemer   rA   r:   rx   queryfragmentr   r   r   prepend_scheme_if_needed  s    !r   c             C   sS   t  |   } y" t | j  t | j  f } Wn t t f k
 rN d } Yn X| S)z{Given a url with authentication components, extract them into a tuple of
    username,password.

    :rtype: (str,str)
    r   )r   r   )r   r   ZusernameZpasswordrD   r   )rE   ZparsedZauthr   r   r   get_auth_from_url  s    "r   s   ^\S[^\r\n]*$|^$z^\S[^\r\n]*$|^$c             C   s   |  \ } } t  | t  r$ t } n t } y# | j |  sL t d |   Wn. t k
 r} t d | t |  f   Yn Xd S)zVerifies that header value is a string which doesn't contain
    leading whitespace or return characters. This prevents unintended
    header injection.

    :param header: tuple, in the format (name, value).
    z7Invalid return character or leading space in header: %sz4Header value %s must be of type str or bytes, not %sN)r?   r	   _CLEAN_HEADER_REGEX_BYTE_CLEAN_HEADER_REGEX_STRmatchr   r   type)headerrJ   rU   Zpatr   r   r   check_header_validity
  s    	r   c             C   sc   t  |   \ } } } } } } | s1 | | } } | j d d  d } t | | | | | d f  S)zW
    Given a url remove the fragment and the authentication part.

    :rtype: str
    @r   r   rM   )r   rsplitr   )rE   r   rA   r:   rx   r   r   r   r   r   urldefragauth  s
    r   c             C   s~   t  |  j d d  } | d k	 rn t |  j t  rn y | |  j  Wqz t t f k
 rj t d   Yqz Xn t d   d S)zfMove file pointer back to its recorded starting position
    so it can be read again on redirect.
    r&   Nz:An error occured when rewinding request body for redirect.z+Unable to rewind request body for redirect.)rN   Zbodyr?   Z_body_positionr   r1   r0   r   )Zprepared_requestZ	body_seekr   r   r   rewind_body/  s    r   )r   r   )V__doc__ru   r~   rW   r(   r*   rl   r   r   r.   r   r   r   Z_internal_utilsr   compatr   r\   r   r   r	   r
   r   r   r   r   r   r   r   Zcookiesr   r   Z
structuresr   
exceptionsr   r   r   r   Z_hush_pyflakesr9   ZwhereZDEFAULT_CA_BUNDLE_PATHr    r4   rI   rQ   rV   rZ   ra   rc   r]   rh   ri   rq   ry   r   r   r   	frozensetr   r   r   r   r   r   r   r   r   r   r   r   r   encoder   r   r   r   r   r   rm   r   r   r   r   r   r   r   r   r   <module>	   s|   L"		;3 #
%
6	"

                                                                                                                                                                                                                              
l2XX                 @   sJ  d  Z  d d l m Z d d l Z d d   Z e d  e d  e d  e d	  e d
  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d  e d   e d!  d S)"a:  
Debian and other distributions "unbundle" requests' vendored dependencies, and
rewrite all imports to use the global versions of ``urllib3`` and ``chardet``.
The problem with this is that not only requests itself imports those
dependencies, but third-party code outside of the distros' control too.

In reaction to these problems, the distro maintainers replaced
``requests.packages`` with a magical "stub module" that imports the correct
modules. The implementations were varying in quality and all had severe
problems. For example, a symlink (or hardlink) that links the correct modules
into place introduces problems regarding object identity, since you now have
two modules in `sys.modules` with the same API, but different identities::

    requests.packages.urllib3 is not urllib3

With version ``2.5.2``, requests started to maintain its own stub, so that
distro-specific breakage would be reduced to a minimum, even though the whole
issue is not requests' fault in the first place. See
https://github.com/kennethreitz/requests/pull/2375 for the corresponding pull
request.
    )absolute_importNc             C   s   d j  t |   } y  t | t   t   d d Wn t k
 r y  t |  t   t   d d Wn t k
 rv YnK Xt j |  t j | <| j d d  \ } } t	 t j | | t j |   Yn Xd  S)Nz{0}.{1}levelr   .   )
format__name__
__import__globalslocalsImportErrorsysmodulesrsplitsetattr)Z
modulenameZvendored_namebasehead r   </usr/lib/python3/dist-packages/requests/packages/__init__.pyvendored   s      	r   ZchardetZidnaZurllib3zurllib3._collectionszurllib3.connectionzurllib3.connectionpoolzurllib3.contribzurllib3.contrib.ntlmpoolzurllib3.contrib.pyopensslzurllib3.exceptionszurllib3.fieldszurllib3.filepostzurllib3.packageszurllib3.packages.ordered_dictzurllib3.packages.sixz#urllib3.packages.ssl_match_hostnamez3urllib3.packages.ssl_match_hostname._implementationzurllib3.poolmanagerzurllib3.requestzurllib3.responsezurllib3.utilzurllib3.util.connectionzurllib3.util.requestzurllib3.util.responsezurllib3.util.retryzurllib3.util.ssl_zurllib3.util.timeoutzurllib3.util.url)__doc__Z
__future__r   r   r   r   r   r   r   <module>   s>   


























                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            