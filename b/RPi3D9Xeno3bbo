      "expected token but found '{}'".format(value))
    token, value = get_extended_attrtext(value)
    attribute.append(token)
    if value and value[0] in CFWS_LEADER:
        token, value = get_cfws(value)
        attribute.append(token)
    return attribute, value

def get_section(value):
    """ '*' digits

    The formal BNF is more complicated because leading 0s are not allowed.  We
    check for that and add a defect.  We also assume no CFWS is allowed between
    the '*' and the digits, though the RFC is not crystal clear on that.
    The caller should already have dealt with leading CFWS.

    """
    section = Section()
    if not value or value[0] != '*':
        raise errors.HeaderParseError("Expected section but found {}".format(
                                        value))
    section.append(ValueTerminal('*', 'section-marker'))
    value = value[1:]
    if not value or not value[0].isdigit():
        raise errors.HeaderParseError("Expected section number but "
                                      "found {}".format(value))
    digits = ''
    while value and value[0].isdigit():
        digits += value[0]
        value = value[1:]
    if digits[0] == '0' and digits != '0':
        section.defects.append(errors.InvalidHeaderError("section number"
            "has an invalid leading 0"))
    section.number = int(digits)
    section.append(ValueTerminal(digits, 'digits'))
    return section, value


def get_value(value):
    """ quoted-string / attribute

    """
    v = Value()
    if not value:
        raise errors.HeaderParseError("Expected value but found end of string")
    leader = None
    if value[0] in CFWS_LEADER:
        leader, value = get_cfws(value)
    if not value:
        raise errors.HeaderParseError("Expected value but found "
                                      "only {}".format(leader))
    if value[0] == '"':
        token, value = get_quoted_string(value)
    else:
        token, value = get_extended_attribute(value)
    if leader is not None:
        token[:0] = [leader]
    v.append(token)
    return v, value

def get_parameter(value):
    """ attribute [section] ["*"] [CFWS] "=" value

    The CFWS is implied by the RFC but not made explicit in the BNF.  This
    simplified form of the BNF from the RFC is made to conform with the RFC BNF
    through some extra checks.  We do it this way because it makes both error
    recovery and working with the resulting parse tree easier.
    """
    # It is possible CFWS would also be implicitly allowed between the section
    # and the 'extended-attribute' marker (the '*') , but we've never seen that
    # in the wild and we will therefore ignore the possibility.
    param = Parameter()
    token, value = get_attribute(value)
    param.append(token)
    if not value or value[0] == ';':
        param.defects.append(errors.InvalidHeaderDefect("Parameter contains "
            "name ({}) but no value".format(token)))
        return param, value
    if value[0] == '*':
        try:
            token, value = get_section(value)
            param.sectioned = True
            param.append(token)
        except errors.HeaderParseError:
            pass
        if not value:
            raise errors.HeaderParseError("Incomplete parameter")
        if value[0] == '*':
            param.append(ValueTerminal('*', 'extended-parameter-marker'))
            value = value[1:]
            param.extended = True
    if value[0] != '=':
        raise errors.HeaderParseError("Parameter not followed by '='")
    param.append(ValueTerminal('=', 'parameter-separator'))
    value = value[1:]
    leader = None
    if value and value[0] in CFWS_LEADER:
        token, value = get_cfws(value)
        param.append(token)
    remainder = None
    appendto = param
    if param.extended and value and value[0] == '"':
        # Now for some serious hackery to handle the common invalid case of
        # double quotes around an extended value.  We also accept (with defect)
        # a value marked as encoded that isn't really.
        qstring, remainder = get_quoted_string(value)
        inner_value = qstring.stripped_value
        semi_valid = False
        if param.section_number == 0:
            if inner_value and inner_value[0] == "'":
                semi_valid = True
            else:
                token, rest = get_attrtext(inner_value)
                if rest and rest[0] == "'":
                    semi_valid = True
        else:
            try:
                token, rest = get_extended_attrtext(inner_value)
            except:
                pass
            else:
                if not rest:
                    semi_valid = True
        if semi_valid:
            param.defects.append(errors.InvalidHeaderDefect(
                "Quoted string value for extended parameter is invalid"))
            param.append(qstring)
            for t in qstring:
                if t.token_type == 'bare-quoted-string':
                    t[:] = []
                    appendto = t
                    break
            value = inner_value
        else:
            remainder = None
            param.defects.append(errors.InvalidHeaderDefect(
                "Parameter marked as extended but appears to have a "
                "quoted string value that is non-encoded"))
    if value and value[0] == "'":
        token = None
    else:
        token, value = get_value(value)
    if not param.extended or param.section_number > 0:
        if not value or value[0] != "'":
            appendto.append(token)
            if remainder is not None:
                assert not value, value
                value = remainder
            return param, value
        param.defects.append(errors.InvalidHeaderDefect(
            "Apparent initial-extended-value but attribute "
            "was not marked as extended or was not initial section"))
    if not value:
        # Assume the charset/lang is missing and the token is the value.
        param.defects.append(errors.InvalidHeaderDefect(
            "Missing required charset/lang delimiters"))
        appendto.append(token)
        if remainder is None:
            return param, value
    else:
        if token is not None:
            for t in token:
                if t.token_type == 'extended-attrtext':
                    break
            t.token_type == 'attrtext'
            appendto.append(t)
            param.charset = t.value
        if value[0] != "'":
            raise errors.HeaderParseError("Expected RFC2231 char/lang encoding "
                                          "delimiter, but found {!r}".format(value))
        appendto.append(ValueTerminal("'", 'RFC2231 delimiter'))
        value = value[1:]
        if value and value[0] != "'":
            token, value = get_attrtext(value)
            appendto.append(token)
            param.lang = token.value
            if not value or value[0] != "'":
                raise errors.HeaderParseError("Expected RFC2231 char/lang encoding "
                                  "delimiter, but found {}".format(value))
        appendto.append(ValueTerminal("'", 'RFC2231 delimiter'))
        value = value[1:]
    if remainder is not None:
        # Treat the rest of value as bare quoted string content.
        v = Value()
        while value:
            if value[0] in WSP:
                token, value = get_fws(value)
            else:
                token, value = get_qcontent(value)
            v.append(token)
        token = v
    else:
        token, value = get_value(value)
    appendto.append(token)
    if remainder is not None:
        assert not value, value
        value = remainder
    return param, value

def parse_mime_parameters(value):
    """ parameter *( ";" parameter )

    That BNF is meant to indicate this routine should only be called after
    finding and handling the leading ';'.  There is no corresponding rule in
    the formal RFC grammar, but it is more convenient for us for the set of
    parameters to be treated as its own TokenList.

    This is 'parse' routine because it consumes the reminaing value, but it
    would never be called to parse a full header.  Instead it is called to
    parse everything after the non-parameter value of a specific MIME header.

    """
    mime_parameters = MimeParameters()
    while value:
        try:
            token, value = get_parameter(value)
            mime_parameters.append(token)
        except errors.HeaderParseError as err:
            leader = None
            if value[0] in CFWS_LEADER:
                leader, value = get_cfws(value)
            if not value:
                mime_parameters.append(leader)
                return mime_parameters
            if value[0] == ';':
                if leader is not None:
                    mime_parameters.append(leader)
                mime_parameters.defects.append(errors.InvalidHeaderDefect(
                    "parameter entry with no content"))
            else:
                token, value = get_invalid_parameter(value)
                if leader:
                    token[:0] = [leader]
                mime_parameters.append(token)
                mime_parameters.defects.append(errors.InvalidHeaderDefect(
                    "invalid parameter {!r}".format(token)))
        if value and value[0] != ';':
            # Junk after the otherwise valid parameter.  Mark it as
            # invalid, but it will have a value.
            param = mime_parameters[-1]
            param.token_type = 'invalid-parameter'
            token, value = get_invalid_parameter(value)
            param.extend(token)
            mime_parameters.defects.append(errors.InvalidHeaderDefect(
                "parameter with invalid trailing text {!r}".format(token)))
        if value:
            # Must be a ';' at this point.
            mime_parameters.append(ValueTerminal(';', 'parameter-separator'))
            value = value[1:]
    return mime_parameters

def _find_mime_parameters(tokenlist, value):
    """Do our best to find the parameters in an invalid MIME header

    """
    while value and value[0] != ';':
        if value[0] in PHRASE_ENDS:
            tokenlist.append(ValueTerminal(value[0], 'misplaced-special'))
            value = value[1:]
        else:
            token, value = get_phrase(value)
            tokenlist.append(token)
    if not value:
        return
    tokenlist.append(ValueTerminal(';', 'parameter-separator'))
    tokenlist.append(parse_mime_parameters(value[1:]))

def parse_content_type_header(value):
    """ maintype "/" subtype *( ";" parameter )

    The maintype and substype are tokens.  Theoretically they could
    be checked against the official IANA list + x-token, but we
    don't do that.
    """
    ctype = ContentType()
    recover = False
    if not value:
        ctype.defects.append(errors.HeaderMissingRequiredValue(
            "Missing content type specification"))
        return ctype
    try:
        token, value = get_token(value)
    except errors.HeaderParseError:
        ctype.defects.append(errors.InvalidHeaderDefect(
            "Expected content maintype but found {!r}".format(value)))
        _find_mime_parameters(ctype, value)
        return ctype
    ctype.append(token)
    # XXX: If we really want to follow the formal grammar we should make
    # mantype and subtype specialized TokenLists here.  Probably not worth it.
    if not value or value[0] != '/':
        ctype.defects.append(errors.InvalidHeaderDefect(
            "Invalid content type"))
        if value:
            _find_mime_parameters(ctype, value)
        return ctype
    ctype.maintype = token.value.strip().lower()
    ctype.append(ValueTerminal('/', 'content-type-separator'))
    value = value[1:]
    try:
        token, value = get_token(value)
    except errors.HeaderParseError:
        ctype.defects.append(errors.InvalidHeaderDefect(
            "Expected content subtype but found {!r}".format(value)))
        _find_mime_parameters(ctype, value)
        return ctype
    ctype.append(token)
    ctype.subtype = token.value.strip().lower()
    if not value:
        return ctype
    if value[0] != ';':
        ctype.defects.append(errors.InvalidHeaderDefect(
            "Only parameters are valid after content type, but "
            "found {!r}".format(value)))
        # The RFC requires that a syntactically invalid content-type be treated
        # as text/plain.  Perhaps we should postel this, but we should probably
        # only do that if we were checking the subtype value against IANA.
        del ctype.maintype, ctype.subtype
        _find_mime_parameters(ctype, value)
        return ctype
    ctype.append(ValueTerminal(';', 'parameter-separator'))
    ctype.append(parse_mime_parameters(value[1:]))
    return ctype

def parse_content_disposition_header(value):
    """ disposition-type *( ";" parameter )

    """
    disp_header = ContentDisposition()
    if not value:
        disp_header.defects.append(errors.HeaderMissingRequiredValue(
            "Missing content disposition"))
        return disp_header
    try:
        token, value = get_token(value)
    except errors.HeaderParseError:
        disp_header.defects.append(errors.InvalidHeaderDefect(
            "Expected content disposition but found {!r}".format(value)))
        _find_mime_parameters(disp_header, value)
        return disp_header
    disp_header.append(token)
    disp_header.content_disposition = token.value.strip().lower()
    if not value:
        return disp_header
    if value[0] != ';':
        disp_header.defects.append(errors.InvalidHeaderDefect(
            "Only parameters are valid after content disposition, but "
            "found {!r}".format(value)))
        _find_mime_parameters(disp_header, value)
        return disp_header
    disp_header.append(ValueTerminal(';', 'parameter-separator'))
    disp_header.append(parse_mime_parameters(value[1:]))
    return disp_header

def parse_content_transfer_encoding_header(value):
    """ mechanism

    """
    # We should probably validate the values, since the list is fixed.
    cte_header = ContentTransferEncoding()
    if not value:
        cte_header.defects.append(errors.HeaderMissingRequiredValue(
            "Missing content transfer encoding"))
        return cte_header
    try:
        token, value = get_token(value)
    except errors.HeaderParseError:
        cte_header.defects.append(errors.InvalidHeaderDefect(
            "Expected content transfer encoding but found {!r}".format(value)))
    else:
        cte_header.append(token)
        cte_header.cte = token.value.strip().lower()
    if not value:
        return cte_header
    while value:
        cte_header.defects.append(errors.InvalidHeaderDefect(
            "Extra text after content transfer encoding"))
        if value[0] in PHRASE_ENDS:
            cte_header.append(ValueTerminal(value[0], 'misplaced-special'))
            value = value[1:]
        else:
            token, value = get_phrase(value)
            cte_header.append(token)
    return cte_header
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright (C) 2002-2007 Python Software Foundation
# Contact: email-sig@python.org

"""Email address parsing code.

Lifted directly from rfc822.py.  This should eventually be rewritten.
"""

__all__ = [
    'mktime_tz',
    'parsedate',
    'parsedate_tz',
    'quote',
    ]

import time, calendar

SPACE = ' '
EMPTYSTRING = ''
COMMASPACE = ', '

# Parse a date field
_monthnames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',
               'aug', 'sep', 'oct', 'nov', 'dec',
               'january', 'february', 'march', 'april', 'may', 'june', 'july',
               'august', 'september', 'october', 'november', 'december']

_daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']

# The timezone table does not include the military time zones defined
# in RFC822, other than Z.  According to RFC1123, the description in
# RFC822 gets the signs wrong, so we can't rely on any such time
# zones.  RFC1123 recommends that numeric timezone indicators be used
# instead of timezone names.

_timezones = {'UT':0, 'UTC':0, 'GMT':0, 'Z':0,
              'AST': -400, 'ADT': -300,  # Atlantic (used in Canada)
              'EST': -500, 'EDT': -400,  # Eastern
              'CST': -600, 'CDT': -500,  # Central
              'MST': -700, 'MDT': -600,  # Mountain
              'PST': -800, 'PDT': -700   # Pacific
              }


def parsedate_tz(data):
    """Convert a date string to a time tuple.

    Accounts for military timezones.
    """
    res = _parsedate_tz(data)
    if not res:
        return
    if res[9] is None:
        res[9] = 0
    return tuple(res)

def _parsedate_tz(data):
    """Convert date to extended time tuple.

    The last (additional) element is the time zone offset in seconds, except if
    the timezone was specified as -0000.  In that case the last element is
    None.  This indicates a UTC timestamp that explicitly declaims knowledge of
    the source timezone, as opposed to a +0000 timestamp that indicates the
    source timezone really was UTC.

    """
    if not data:
        return
    data = data.split()
    # The FWS after the comma after the day-of-week is optional, so search and
    # adjust for this.
    if data[0].endswith(',') or data[0].lower() in _daynames:
        # There's a dayname here. Skip it
        del data[0]
    else:
        i = data[0].rfind(',')
        if i >= 0:
            data[0] = data[0][i+1:]
    if len(data) == 3: # RFC 850 date, deprecated
        stuff = data[0].split('-')
        if len(stuff) == 3:
            data = stuff + data[1:]
    if len(data) == 4:
        s = data[3]
        i = s.find('+')
        if i == -1:
            i = s.find('-')
        if i > 0:
            data[3:] = [s[:i], s[i:]]
        else:
            data.append('') # Dummy tz
    if len(data) < 5:
        return None
    data = data[:5]
    [dd, mm, yy, tm, tz] = data
    mm = mm.lower()
    if mm not in _monthnames:
        dd, mm = mm, dd.lower()
        if mm not in _monthnames:
            return None
    mm = _monthnames.index(mm) + 1
    if mm > 12:
        mm -= 12
    if dd[-1] == ',':
        dd = dd[:-1]
    i = yy.find(':')
    if i > 0:
        yy, tm = tm, yy
    if yy[-1] == ',':
        yy = yy[:-1]
    if not yy[0].isdigit():
        yy, tz = tz, yy
    if tm[-1] == ',':
        tm = tm[:-1]
    tm = tm.split(':')
    if len(tm) == 2:
        [thh, tmm] = tm
        tss = '0'
    elif len(tm) == 3:
        [thh, tmm, tss] = tm
    elif len(tm) == 1 and '.' in tm[0]:
        # Some non-compliant MUAs use '.' to separate time elements.
        tm = tm[0].split('.')
        if len(tm) == 2:
            [thh, tmm] = tm
            tss = 0
        elif len(tm) == 3:
            [thh, tmm, tss] = tm
    else:
        return None
    try:
        yy = int(yy)
        dd = int(dd)
        thh = int(thh)
        tmm = int(tmm)
        tss = int(tss)
    except ValueError:
        return None
    # Check for a yy specified in two-digit format, then convert it to the
    # appropriate four-digit format, according to the POSIX standard. RFC 822
    # calls for a two-digit yy, but RFC 2822 (which obsoletes RFC 822)
    # mandates a 4-digit yy. For more information, see the documentation for
    # the time module.
    if yy < 100:
        # The year is between 1969 and 1999 (inclusive).
        if yy > 68:
            yy += 1900
        # The year is between 2000 and 2068 (inclusive).
        else:
            yy += 2000
    tzoffset = None
    tz = tz.upper()
    if tz in _timezones:
        tzoffset = _timezones[tz]
    else:
        try:
            tzoffset = int(tz)
        except ValueError:
            pass
        if tzoffset==0 and tz.startswith('-'):
            tzoffset = None
    # Convert a timezone offset into seconds ; -0500 -> -18000
    if tzoffset:
        if tzoffset < 0:
            tzsign = -1
            tzoffset = -tzoffset
        else:
            tzsign = 1
        tzoffset = tzsign * ( (tzoffset//100)*3600 + (tzoffset % 100)*60)
    # Daylight Saving Time flag is set to -1, since DST is unknown.
    return [yy, mm, dd, thh, tmm, tss, 0, 1, -1, tzoffset]


def parsedate(data):
    """Convert a time string to a time tuple."""
    t = parsedate_tz(data)
    if isinstance(t, tuple):
        return t[:9]
    else:
        return t


def mktime_tz(data):
    """Turn a 10-tuple as returned by parsedate_tz() into a POSIX timestamp."""
    if data[9] is None:
        # No zone info, so localtime is better assumption than GMT
        return time.mktime(data[:8] + (-1,))
    else:
        t = calendar.timegm(data)
        return t - data[9]


def quote(str):
    """Prepare string to be used in a quoted string.

    Turns backslash and double quote characters into quoted pairs.  These
    are the only characters that need to be quoted inside a quoted string.
    Does not add the surrounding double quotes.
    """
    return str.replace('\\', '\\\\').replace('"', '\\"')


class AddrlistClass:
    """Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of RFC 2822 in
    front of you.

    Note: this class interface is deprecated and may be removed in the future.
    Use email.utils.AddressList instead.
    """

    def __init__(self, field):
        """Initialize a new instance.

        `field' is an unparsed address header field, containing
        one or more addresses.
        """
        self.specials = '()<>@,:;.\"[]'
        self.pos = 0
        self.LWS = ' \t'
        self.CR = '\r\n'
        self.FWS = self.LWS + self.CR
        self.atomends = self.specials + self.LWS + self.CR
        # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it
        # is obsolete syntax.  RFC 2822 requires that we recognize obsolete
        # syntax, so allow dots in phrases.
        self.phraseends = self.atomends.replace('.', '')
        self.field = field
        self.commentlist = []

    def gotonext(self):
        """Skip white space and extract comments."""
        wslist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS + '\n\r':
                if self.field[self.pos] not in '\n\r':
                    wslist.append(self.field[self.pos])
                self.pos += 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            else:
                break
        return EMPTYSTRING.join(wslist)

    def getaddrlist(self):
        """Parse all addresses.

        Returns a list containing all of the addresses.
        """
        result = []
        while self.pos < len(self.field):
            ad = self.getaddress()
            if ad:
                result += ad
            else:
                result.append(('', ''))
        return result

    def getaddress(self):
        """Parse the next address."""
        self.commentlist = []
        self.gotonext()

        oldpos = self.pos
        oldcl = self.commentlist
        plist = self.getphraselist()

        self.gotonext()
        returnlist = []

        if self.pos >= len(self.field):
            # Bad email address technically, no domain.
            if plist:
                returnlist = [(SPACE.join(self.commentlist), plist[0])]

        elif self.field[self.pos] in '.@':
            # email address is just an addrspec
            # this isn't very efficient since we start over
            self.pos = oldpos
            self.commentlist = oldcl
            addrspec = self.getaddrspec()
            returnlist = [(SPACE.join(self.commentlist), addrspec)]

        elif self.field[self.pos] == ':':
            # address is a group
            returnlist = []

            fieldlen = len(self.field)
            self.pos += 1
            while self.pos < len(self.field):
                self.gotonext()
                if self.pos < fieldlen and self.field[self.pos] == ';':
                    self.pos += 1
                    break
                returnlist = returnlist + self.getaddress()

        elif self.field[self.pos] == '<':
            # Address is a phrase then a route addr
            routeaddr = self.getrouteaddr()

            if self.commentlist:
                returnlist = [(SPACE.join(plist) + ' (' +
                               ' '.join(self.commentlist) + ')', routeaddr)]
            else:
                returnlist = [(SPACE.join(plist), routeaddr)]

        else:
            if plist:
                returnlist = [(SPACE.join(self.commentlist), plist[0])]
            elif self.field[self.pos] in self.specials:
                self.pos += 1

        self.gotonext()
        if self.pos < len(self.field) and self.field[self.pos] == ',':
            self.pos += 1
        return returnlist

    def getrouteaddr(self):
        """Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        """
        if self.field[self.pos] != '<':
            return

        expectroute = False
        self.pos += 1
        self.gotonext()
        adlist = ''
        while self.pos < len(self.field):
            if expectroute:
                self.getdomain()
                expectroute = False
            elif self.field[self.pos] == '>':
                self.pos += 1
                break
            elif self.field[self.pos] == '@':
                self.pos += 1
                expectroute = True
            elif self.field[self.pos] == ':':
                self.pos += 1
            else:
                adlist = self.getaddrspec()
                self.pos += 1
                break
            self.gotonext()

        return adlist

    def getaddrspec(self):
        """Parse an RFC 2822 addr-spec."""
        aslist = []

        self.gotonext()
        while self.pos < len(self.field):
            preserve_ws = True
            if self.field[self.pos] == '.':
                if aslist and not aslist[-1].strip():
                    aslist.pop()
                aslist.append('.')
                self.pos += 1
                preserve_ws = False
            elif self.field[self.pos] == '"':
                aslist.append('"%s"' % quote(self.getquote()))
            elif self.field[self.pos] in self.atomends:
                if aslist and not aslist[-1].strip():
                    aslist.pop()
                break
            else:
                aslist.append(self.getatom())
            ws = self.gotonext()
            if preserve_ws and ws:
                aslist.append(ws)

        if self.pos >= len(self.field) or self.field[self.pos] != '@':
            return EMPTYSTRING.join(aslist)

        aslist.append('@')
        self.pos += 1
        self.gotonext()
        return EMPTYSTRING.join(aslist) + self.getdomain()

    def getdomain(self):
        """Get the complete domain name from an address."""
        sdlist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] == '[':
                sdlist.append(self.getdomainliteral())
            elif self.field[self.pos] == '.':
                self.pos += 1
                sdlist.append('.')
            elif self.field[self.pos] in self.atomends:
                break
            else:
                sdlist.append(self.getatom())
        return EMPTYSTRING.join(sdlist)

    def getdelimited(self, beginchar, endchars, allowcomments=True):
        """Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.
        If self is not looking at an instance of `beginchar' then
        getdelimited returns the empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        """
        if self.field[self.pos] != beginchar:
            return ''

        slist = ['']
        quote = False
        self.pos += 1
        while self.pos < len(self.field):
            if quote:
                slist.append(self.field[self.pos])
                quote = False
            elif self.field[self.pos] in endchars:
                self.pos += 1
                break
            elif allowcomments and self.field[self.pos] == '(':
                slist.append(self.getcomment())
                continue        # have already advanced pos from getcomment
            elif self.field[self.pos] == '\\':
                quote = True
            else:
                slist.append(self.field[self.pos])
            self.pos += 1

        return EMPTYSTRING.join(slist)

    def getquote(self):
        """Get a quote-delimited fragment from self's field."""
        return self.getdelimited('"', '"\r', False)

    def getcomment(self):
        """Get a parenthesis-delimited fragment from self's field."""
        return self.getdelimited('(', ')\r', True)

    def getdomainliteral(self):
        """Parse an RFC 2822 domain-literal."""
        return '[%s]' % self.getdelimited('[', ']\r', False)

    def getatom(self, atomends=None):
        """Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases)."""
        atomlist = ['']
        if atomends is None:
            atomends = self.atomends

        while self.pos < len(self.field):
            if self.field[self.pos] in atomends:
                break
            else:
                atomlist.append(self.field[self.pos])
            self.pos += 1

        return EMPTYSTRING.join(atomlist)

    def getphraselist(self):
        """Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        """
        plist = []

        while self.pos < len(self.field):
            if self.field[self.pos] in self.FWS:
                self.pos += 1
            elif self.field[self.pos] == '"':
                plist.append(self.getquote())
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] in self.phraseends:
                break
            else:
                plist.append(self.getatom(self.phraseends))

        return plist

class AddressList(AddrlistClass):
    """An AddressList encapsulates a list of parsed RFC 2822 addresses."""
    def __init__(self, field):
        AddrlistClass.__init__(self, field)
        if field:
            self.addresslist = self.getaddrlist()
        else:
            self.addresslist = []

    def __len__(self):
        return len(self.addresslist)

    def __add__(self, other):
        # Set union
        newaddr = AddressList(None)
        newaddr.addresslist = self.addresslist[:]
        for x in other.addresslist:
            if not x in self.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __iadd__(self, other):
        # Set union, in-place
        for x in other.addresslist:
            if not x in self.addresslist:
                self.addresslist.append(x)
        return self

    def __sub__(self, other):
        # Set difference
        newaddr = AddressList(None)
        for x in self.addresslist:
            if not x in other.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __isub__(self, other):
        # Set difference, in-place
        for x in other.addresslist:
            if x in self.addresslist:
                self.addresslist.remove(x)
        return self

    def __getitem__(self, index):
        # Make indexing, slices, and 'in' work
        return self.addresslist[index]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 :mod:`email` Package Architecture
=================================

Overview
--------

The email package consists of three major components:

    Model
        An object structure that represents an email message, and provides an
        API for creating, querying, and modifying a message.

    Parser
        Takes a sequence of characters or bytes and produces a model of the
        email message represented by those characters or bytes.

    Generator
        Takes a model and turns it into a sequence of characters or bytes.  The
        sequence can either be intended for human consumption (a printable
        unicode string) or bytes suitable for transmission over the wire.  In
        the latter case all data is properly encoded using the content transfer
        encodings specified by the relevant RFCs.

Conceptually the package is organized around the model.  The model provides both
"external" APIs intended for use by application programs using the library,
and "internal" APIs intended for use by the Parser and Generator components.
This division is intentionally a bit fuzzy; the API described by this
documentation is all a public, stable API.  This allows for an application
with special needs to implement its own parser and/or generator.

In addition to the three major functional components, there is a third key
component to the architecture:

    Policy
        An object that specifies various behavioral settings and carries
        implementations of various behavior-controlling methods.

The Policy framework provides a simple and convenient way to control the
behavior of the library, making it possible for the library to be used in a
very flexible fashion while leveraging the common code required to parse,
represent, and generate message-like objects.  For example, in addition to the
default :rfc:`5322` email message policy, we also have a policy that manages
HTTP headers in a fashion compliant with :rfc:`2616`.  Individual policy
controls, such as the maximum line length produced by the generator, can also
be controlled individually to meet specialized application requirements.


The Model
---------

The message model is implemented by the :class:`~email.message.Message` class.
The model divides a message into the two fundamental parts discussed by the
RFC: the header section and the body.  The `Message` object acts as a
pseudo-dictionary of named headers.  Its dictionary interface provides
convenient access to individual headers by name.  However, all headers are kept
internally in an ordered list, so that the information about the order of the
headers in the original message is preserved.

The `Message` object also has a `payload` that holds the body.  A `payload` can
be one of two things: data, or a list of `Message` objects.  The latter is used
to represent a multipart MIME message.  Lists can be nested arbitrarily deeply
in order to represent the message, with all terminal leaves having non-list
data payloads.


Message Lifecycle
-----------------

The general lifecyle of a message is:

    Creation
        A `Message` object can be created by a Parser, or it can be
        instantiated as an empty message by an application.

    Manipulation
        The application may examine one or more headers, and/or the
        payload, and it may modify one or more headers and/or
        the payload.  This may be done on the top level `Message`
        object, or on any sub-object.

    Finalization
        The Model is converted into a unicode or binary stream,
        or the model is discarded.



Header Policy Control During Lifecycle
--------------------------------------

One of the major controls exerted by the Policy is the management of headers
during the `Message` lifecycle.  Most applications don't need to be aware of
this.

A header enters the model in one of two ways: via a Parser, or by being set to
a specific value by an application program after the Model already exists.
Similarly, a header exits the model in one of two ways: by being serialized by
a Generator, or by being retrieved from a Model by an application program.  The
Policy object provides hooks for all four of these pathways.

The model storage for headers is a list of (name, value) tuples.

The Parser identifies headers during parsing, and passes them to the
:meth:`~email.policy.Policy.header_source_parse` method of the Policy.  The
result of that method is the (name, value) tuple to be stored in the model.

When an application program supplies a header value (for example, through the
`Message` object `__setitem__` interface), the name and the value are passed to
the :meth:`~email.policy.Policy.header_store_parse` method of the Policy, which
returns the (name, value) tuple to be stored in the model.

When an application program retrieves a header (through any of the dict or list
interfaces of `Message`), the name and value are passed to the
:meth:`~email.policy.Policy.header_fetch_parse` method of the Policy to
obtain the value returned to the application.

When a Generator requests a header during serialization, the name and value are
passed to the :meth:`~email.policy.Policy.fold` method of the Policy, which
returns a string containing line breaks in the appropriate places.  The
:meth:`~email.policy.Policy.cte_type` Policy control determines whether or
not Content Transfer Encoding is performed on the data in the header.  There is
also a :meth:`~email.policy.Policy.binary_fold` method for use by generators
that produce binary output, which returns the folded header as binary data,
possibly folded at different places than the corresponding string would be.


Handling Binary Data
--------------------

In an ideal world all message data would conform to the RFCs, meaning that the
parser could decode the message into the idealized unicode message that the
sender originally wrote.  In the real world, the email package must also be
able to deal with badly formatted messages, including messages containing
non-ASCII characters that either have no indicated character set or are not
valid characters in the indicated character set.

Since email messages are *primarily* text data, and operations on message data
are primarily text operations (except for binary payloads of course), the model
stores all text data as unicode strings.  Un-decodable binary inside text
data is handled by using the `surrogateescape` error handler of the ASCII
codec.  As with the binary filenames the error handler was introduced to
handle, this allows the email package to "carry" the binary data received
during parsing along until the output stage, at which time it is regenerated
in its original form.

This carried binary data is almost entirely an implementation detail.  The one
place where it is visible in the API is in the "internal" API.  A Parser must
do the `surrogateescape` encoding of binary input data, and pass that data to
the appropriate Policy method.  The "internal" interface used by the Generator
to access header values preserves the `surrogateescaped` bytes.  All other
interfaces convert the binary data either back into bytes or into a safe form
(losing information in some cases).


Backward Compatibility
----------------------

The :class:`~email.policy.Policy.Compat32` Policy provides backward
compatibility with version 5.1 of the email package.  It does this via the
following implementation of the four+1 Policy methods described above:

header_source_parse
    Splits the first line on the colon to obtain the name, discards any spaces
    after the colon, and joins the remainder of the line with all of the
    remaining lines, preserving the linesep characters to obtain the value.
    Trailing carriage return and/or linefeed characters are stripped from the
    resulting value string.

header_store_parse
    Returns the name and value exactly as received from the application.

header_fetch_parse
    If the value contains any `surrogateescaped` binary data, return the value
    as a :class:`~email.header.Header` object, using the character set
    `unknown-8bit`.  Otherwise just returns the value.

fold
    Uses :class:`~email.header.Header`'s folding to fold headers in the
    same way the email5.1 generator did.

binary_fold
    Same as fold, but encodes to 'ascii'.


New Algorithm
-------------

header_source_parse
    Same as legacy behavior.

header_store_parse
    Same as legacy behavior.

header_fetch_parse
    If the value is already a header object, returns it.  Otherwise, parses the
    value using the new parser, and returns the resulting object as the value.
    `surrogateescaped` bytes get turned into unicode unknown character code
    points.

fold
    Uses the new header folding algorithm, respecting the policy settings.
    surrogateescaped bytes are encoded using the ``unknown-8bit`` charset for
    ``cte_type=7bit`` or ``8bit``.  Returns a string.

    At some point there will also be a ``cte_type=unicode``, and for that
    policy fold will serialize the idealized unicode message with RFC-like
    folding, converting any surrogateescaped bytes into the unicode
    unknown character glyph.

binary_fold
    Uses the new header folding algorithm, respecting the policy settings.
    surrogateescaped bytes are encoded using the `unknown-8bit` charset for
    ``cte_type=7bit``, and get turned back into bytes for ``cte_type=8bit``.
    Returns bytes.

    At some point there will also be a ``cte_type=unicode``, and for that
    policy binary_fold will serialize the message according to :rfc:``5335``.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Policy framework for the email package.

Allows fine grained feature control of how the package parses and emits data.
"""

import abc
from email import header
from email import charset as _charset
from email.utils import _has_surrogates

__all__ = [
    'Policy',
    'Compat32',
    'compat32',
    ]


class _PolicyBase:

    """Policy Object basic framework.

    This class is useless unless subclassed.  A subclass should define
    class attributes with defaults for any values that are to be
    managed by the Policy object.  The constructor will then allow
    non-default values to be set for these attributes at instance
    creation time.  The instance will be callable, taking these same
    attributes keyword arguments, and returning a new instance
    identical to the called instance except for those values changed
    by the keyword arguments.  Instances may be added, yielding new
    instances with any non-default values from the right hand
    operand overriding those in the left hand operand.  That is,

        A + B == A(<non-default values of B>)

    The repr of an instance can be used to reconstruct the object
    if and only if the repr of the values can be used to reconstruct
    those values.

    """

    def __init__(self, **kw):
        """Create new Policy, possibly overriding some defaults.

        See class docstring for a list of overridable attributes.

        """
        for name, value in kw.items():
            if hasattr(self, name):
                super(_PolicyBase,self).__setattr__(name, value)
            else:
                raise TypeError(
                    "{!r} is an invalid keyword argument for {}".format(
                        name, self.__class__.__name__))

    def __repr__(self):
        args = [ "{}={!r}".format(name, value)
                 for name, value in self.__dict__.items() ]
        return "{}({})".format(self.__class__.__name__, ', '.join(args))

    def clone(self, **kw):
        """Return a new instance with specified attributes changed.

        The new instance has the same attribute values as the current object,
        except for the changes passed in as keyword arguments.

        """
        newpolicy = self.__class__.__new__(self.__class__)
        for attr, value in self.__dict__.items():
            object.__setattr__(newpolicy, attr, value)
        for attr, value in kw.items():
            if not hasattr(self, attr):
                raise TypeError(
                    "{!r} is an invalid keyword argument for {}".format(
                        attr, self.__class__.__name__))
            object.__setattr__(newpolicy, attr, value)
        return newpolicy

    def __setattr__(self, name, value):
        if hasattr(self, name):
            msg = "{!r} object attribute {!r} is read-only"
        else:
            msg = "{!r} object has no attribute {!r}"
        raise AttributeError(msg.format(self.__class__.__name__, name))

    def __add__(self, other):
        """Non-default values from right operand override those from left.

        The object returned is a new instance of the subclass.

        """
        return self.clone(**other.__dict__)


def _append_doc(doc, added_doc):
    doc = doc.rsplit('\n', 1)[0]
    added_doc = added_doc.split('\n', 1)[1]
    return doc + '\n' + added_doc

def _extend_docstrings(cls):
    if cls.__doc__ and cls.__doc__.startswith('+'):
        cls.__doc__ = _append_doc(cls.__bases__[0].__doc__, cls.__doc__)
    for name, attr in cls.__dict__.items():
        if attr.__doc__ and attr.__doc__.startswith('+'):
            for c in (c for base in cls.__bases__ for c in base.mro()):
                doc = getattr(getattr(c, name), '__doc__')
                if doc:
                    attr.__doc__ = _append_doc(doc, attr.__doc__)
                    break
    return cls


class Policy(_PolicyBase, metaclass=abc.ABCMeta):

    r"""Controls for how messages are interpreted and formatted.

    Most of the classes and many of the methods in the email package accept
    Policy objects as parameters.  A Policy object contains a set of values and
    functions that control how input is interpreted and how output is rendered.
    For example, the parameter 'raise_on_defect' controls whether or not an RFC
    violation results in an error being raised or not, while 'max_line_length'
    controls the maximum length of output lines when a Message is serialized.

    Any valid attribute may be overridden when a Policy is created by passing
    it as a keyword argument to the constructor.  Policy objects are immutable,
    but a new Policy object can be created with only certain values changed by
    calling the Policy instance with keyword arguments.  Policy objects can
    also be added, producing a new Policy object in which the non-default
    attributes set in the right hand operand overwrite those specified in the
    left operand.

    Settable attributes:

    raise_on_defect     -- If true, then defects should be raised as errors.
                           Default: False.

    linesep             -- string containing the value to use as separation
                           between output lines.  Default '\n'.

    cte_type            -- Type of allowed content transfer encodings

                           7bit  -- ASCII only
                           8bit  -- Content-Transfer-Encoding: 8bit is allowed

                           Default: 8bit.  Also controls the disposition of
                           (RFC invalid) binary data in headers; see the
                           documentation of the binary_fold method.

    max_line_length     -- maximum length of lines, excluding 'linesep',
                           during serialization.  None or 0 means no line
                           wrapping is done.  Default is 78.

    mangle_from_        -- a flag that, when True escapes From_ lines in the
                           body of the message by putting a `>' in front of
                           them. This is used when the message is being
                           serialized by a generator. Default: True.

    """

    raise_on_defect = False
    linesep = '\n'
    cte_type = '8bit'
    max_line_length = 78
    mangle_from_ = False

    def handle_defect(self, obj, defect):
        """Based on policy, either raise defect or call register_defect.

            handle_defect(obj, defect)

        defect should be a Defect subclass, but in any case must be an
        Exception subclass.  obj is the object on which the defect should be
        registered if it is not raised.  If the raise_on_defect is True, the
        defect is raised as an error, otherwise the object and the defect are
        passed to register_defect.

        This method is intended to be called by parsers that discover defects.
        The email package parsers always call it with Defect instances.

        """
        if self.raise_on_defect:
            raise defect
        self.register_defect(obj, defect)

    def register_defect(self, obj, defect):
        """Record 'defect' on 'obj'.

        Called by handle_defect if raise_on_defect is False.  This method is
        part of the Policy API so that Policy subclasses can implement custom
        defect handling.  The default implementation calls the append method of
        the defects attribute of obj.  The objects used by the email package by
        default that get passed to this method will always have a defects
        attribute with an append method.

        """
        obj.defects.append(defect)

    def header_max_count(self, name):
        """Return the maximum allowed number of headers named 'name'.

        Called when a header is added to a Message object.  If the returned
        value is not 0 or None, and there are already a number of headers with
        the name 'name' equal to the value returned, a ValueError is raised.

        Because the default behavior of Message's __setitem__ is to append the
        value to the list of headers, it is easy to create duplicate headers
        without realizing it.  This method allows certain headers to be limited
        in the number of instances of that header that may be added to a
        Message programmatically.  (The limit is not observed by the parser,
        which will faithfully produce as many headers as exist in the message
        being parsed.)

        The default implementation returns None for all header names.
        """
        return None

    @abc.abstractmethod
    def header_source_parse(self, sourcelines):
        """Given a list of linesep terminated strings constituting the lines of
        a single header, return the (name, value) tuple that should be stored
        in the model.  The input lines should retain their terminating linesep
        characters.  The lines passed in by the email package may contain
        surrogateescaped binary data.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def header_store_parse(self, name, value):
        """Given the header name and the value provided by the application
        program, return the (name, value) that should be stored in the model.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def header_fetch_parse(self, name, value):
        """Given the header name and the value from the model, return the value
        to be returned to the application program that is requesting that
        header.  The value passed in by the email package may contain
        surrogateescaped binary data if the lines were parsed by a BytesParser.
        The returned value should not contain any surrogateescaped data.

        """
        raise NotImplementedError

    @abc.abstractmethod
    def fold(self, name, value):
        """Given the header name and the value from the model, return a string
        containing linesep characters that implement the folding of the header
        according to the policy controls.  The value passed in by the email
        package may contain surrogateescaped binary data if the lines were
        parsed by a BytesParser.  The returned value should not contain any
        surrogateescaped data.

        """
        raise NotImplementedError

    @abc.abstractmethod
    def fold_binary(self, name, value):
        """Given the header name and the value from the model, return binary
        data containing linesep characters that implement the folding of the
        header according to the policy controls.  The value passed in by the
        email package may contain surrogateescaped binary data.

        """
        raise NotImplementedError


@_extend_docstrings
class Compat32(Policy):

    """+
    This particular policy is the backward compatibility Policy.  It
    replicates the behavior of the email package version 5.1.
    """

    mangle_from_ = True

    def _sanitize_header(self, name, value):
        # If the header value contains surrogates, return a Header using
        # the unknown-8bit charset to encode the bytes as encoded words.
        if not isinstance(value, str):
            # Assume it is already a header object
            return value
        if _has_surrogates(value):
            return header.Header(value, charset=_charset.UNKNOWN8BIT,
                                 header_name=name)
        else:
            return value

    def header_source_parse(self, sourcelines):
        """+
        The name is parsed as everything up to the ':' and returned unmodified.
        The value is determined by stripping leading whitespace off the
        remainder of the first line, joining all subsequent lines together, and
        stripping any trailing carriage return or linefeed characters.

        """
        name, value = sourcelines[0].split(':', 1)
        value = value.lstrip(' \t') + ''.join(sourcelines[1:])
        return (name, value.rstrip('\r\n'))

    def header_store_parse(self, name, value):
        """+
        The name and value are returned unmodified.
        """
        return (name, value)

    def header_fetch_parse(self, name, value):
        """+
        If the value contains binary data, it is converted into a Header object
        using the unknown-8bit charset.  Otherwise it is returned unmodified.
        """
        return self._sanitize_header(name, value)

    def fold(self, name, value):
        """+
        Headers are folded using the Header folding algorithm, which preserves
        existing line breaks in the value, and wraps each resulting line to the
        max_line_length.  Non-ASCII binary data are CTE encoded using the
        unknown-8bit charset.

        """
        return self._fold(name, value, sanitize=True)

    def fold_binary(self, name, value):
        """+
        Headers are folded using the Header folding algorithm, which preserves
        existing line breaks in the value, and wraps each resulting line to the
        max_line_length.  If cte_type is 7bit, non-ascii binary data is CTE
        encoded using the unknown-8bit charset.  Otherwise the original source
        header is used, with its existing line breaks and/or binary data.

        """
        folded = self._fold(name, value, sanitize=self.cte_type=='7bit')
        return folded.encode('ascii', 'surrogateescape')

    def _fold(self, name, value, sanitize):
        parts = []
        parts.append('%s: ' % name)
        if isinstance(value, str):
            if _has_surrogates(value):
                if sanitize:
                    h = header.Header(value,
                                      charset=_charset.UNKNOWN8BIT,
                                      header_name=name)
                else:
                    # If we have raw 8bit data in a byte string, we have no idea
                    # what the encoding is.  There is no safe way to split this
                    # string.  If it's ascii-subset, then we could do a normal
                    # ascii split, but if it's multibyte then we could break the
                    # string.  There's no way to know so the least harm seems to
                    # be to not split the string and risk it being too long.
                    parts.append(value)
                    h = None
            else:
                h = header.Header(value, header_name=name)
        else:
            # Assume it is a Header-like object.
            h = value
        if h is not None:
            parts.append(h.encode(linesep=self.linesep,
                                  maxlinelen=self.max_line_length))
        parts.append(self.linesep)
        return ''.join(parts)


compat32 = Compat32()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Copyright (C) 2002-2007 Python Software Foundation
# Author: Ben Gertzfield
# Contact: email-sig@python.org

"""Base64 content transfer encoding per RFCs 2045-2047.

This module handles the content transfer encoding method defined in RFC 2045
to encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit
characters encoding known as Base64.

It is used in the MIME standards for email to attach images, audio, and text
using some 8-bit character sets to messages.

This module provides an interface to encode and decode both headers and bodies
with Base64 encoding.

RFC 2045 defines a method for including character set information in an
`encoded-word' in a header.  This method is commonly used for 8-bit real names
in To:, From:, Cc:, etc. fields, as well as Subject: lines.

This module does not do the line wrapping or end-of-line character conversion
necessary for proper internationalized headers; it only does dumb encoding and
decoding.  To deal with the various line wrapping issues, use the email.header
module.
"""

__all__ = [
    'body_decode',
    'body_encode',
    'decode',
    'decodestring',
    'header_encode',
    'header_length',
    ]


from base64 import b64encode
from binascii import b2a_base64, a2b_base64

CRLF = '\r\n'
NL = '\n'
EMPTYSTRING = ''

# See also Charset.py
MISC_LEN = 7



# Helpers
def header_length(bytearray):
    """Return the length of s when it is encoded with base64."""
    groups_of_3, leftover = divmod(len(bytearray), 3)
    # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in.
    n = groups_of_3 * 4
    if leftover:
        n += 4
    return n



def header_encode(header_bytes, charset='iso-8859-1'):
    """Encode a single header line with Base64 encoding in a given charset.

    charset names the character set to use to encode the header.  It defaults
    to iso-8859-1.  Base64 encoding is defined in RFC 2045.
    """
    if not header_bytes:
        return ""
    if isinstance(header_bytes, str):
        header_bytes = header_bytes.encode(charset)
    encoded = b64encode(header_bytes).decode("ascii")
    return '=?%s?b?%s?=' % (charset, encoded)



def body_encode(s, maxlinelen=76, eol=NL):
    r"""Encode a string with base64.

    Each line will be wrapped at, at most, maxlinelen characters (defaults to
    76 characters).

    Each line of encoded text will end with eol, which defaults to "\n".  Set
    this to "\r\n" if you will be using the result of this function directly
    in an email.
    """
    if not s:
        return s

    encvec = []
    max_unencoded = maxlinelen * 3 // 4
    for i in range(0, len(s), max_unencoded):
        # BAW: should encode() inherit b2a_base64()'s dubious behavior in
        # adding a newline to the encoded string?
        enc = b2a_base64(s[i:i + max_unencoded]).decode("ascii")
        if enc.endswith(NL) and eol != NL:
            enc = enc[:-1] + eol
        encvec.append(enc)
    return EMPTYSTRING.join(encvec)



def decode(string):
    """Decode a raw base64 string, returning a bytes object.

    This function does not parse a full MIME header value encoded with
    base64 (like =?iso-8859-1?b?bmloISBuaWgh?=) -- please use the high
    level email.header class for that functionality.
    """
    if not string:
        return bytes()
    elif isinstance(string, str):
        return a2b_base64(string.encode('raw-unicode-escape'))
    else:
        return a2b_base64(string)


# For convenience and backwards compatibility w/ standard base64 module
body_decode = decode
decodestring = decode
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Copyright (C) 2001-2007 Python Software Foundation
# Author: Ben Gertzfield, Barry Warsaw
# Contact: email-sig@python.org

__all__ = [
    'Charset',
    'add_alias',
    'add_charset',
    'add_codec',
    ]

from functools import partial

import email.base64mime
import email.quoprimime

from email import errors
from email.encoders import encode_7or8bit



# Flags for types of header encodings
QP          = 1 # Quoted-Printable
BASE64      = 2 # Base64
SHORTEST    = 3 # the shorter of QP and base64, but only for headers

# In "=?charset?q?hello_world?=", the =?, ?q?, and ?= add up to 7
RFC2047_CHROME_LEN = 7

DEFAULT_CHARSET = 'us-ascii'
UNKNOWN8BIT = 'unknown-8bit'
EMPTYSTRING = ''



# Defaults
CHARSETS = {
    # input        header enc  body enc output conv
    'iso-8859-1':  (QP,        QP,      None),
    'iso-8859-2':  (QP,        QP,      None),
    'iso-8859-3':  (QP,        QP,      None),
    'iso-8859-4':  (QP,        QP,      None),
    # iso-8859-5 is Cyrillic, and not especially used
    # iso-8859-6 is Arabic, also not particularly used
    # iso-8859-7 is Greek, QP will not make it readable
    # iso-8859-8 is Hebrew, QP will not make it readable
    'iso-8859-9':  (QP,        QP,      None),
    'iso-8859-10': (QP,        QP,      None),
    # iso-8859-11 is Thai, QP will not make it readable
    'iso-8859-13': (QP,        QP,      None),
    'iso-8859-14': (QP,        QP,      None),
    'iso-8859-15': (QP,        QP,      None),
    'iso-8859-16': (QP,        QP,      None),
    'windows-1252':(QP,        QP,      None),
    'viscii':      (QP,        QP,      None),
    'us-ascii':    (None,      None,    None),
    'big5':        (BASE64,    BASE64,  None),
    'gb2312':      (BASE64,    BASE64,  None),
    'euc-jp':      (BASE64,    None,    'iso-2022-jp'),
    'shift_jis':   (BASE64,    None,    'iso-2022-jp'),
    'iso-2022-jp': (BASE64,    None,    None),
    'koi8-r':      (BASE64,    BASE64,  None),
    'utf-8':       (SHORTEST,  BASE64, 'utf-8'),
    }

# Aliases for other commonly-used names for character sets.  Map
# them to the real ones used in email.
ALIASES = {
    'latin_1': 'iso-8859-1',
    'latin-1': 'iso-8859-1',
    'latin_2': 'iso-8859-2',
    'latin-2': 'iso-8859-2',
    'latin_3': 'iso-8859-3',
    'latin-3': 'iso-8859-3',
    'latin_4': 'iso-8859-4',
    'latin-4': 'iso-8859-4',
    'latin_5': 'iso-8859-9',
    'latin-5': 'iso-8859-9',
    'latin_6': 'iso-8859-10',
    'latin-6': 'iso-8859-10',
    'latin_7': 'iso-8859-13',
    'latin-7': 'iso-8859-13',
    'latin_8': 'iso-8859-14',
    'latin-8': 'iso-8859-14',
    'latin_9': 'iso-8859-15',
    'latin-9': 'iso-8859-15',
    'latin_10':'iso-8859-16',
    'latin-10':'iso-8859-16',
    'cp949':   'ks_c_5601-1987',
    'euc_jp':  'euc-jp',
    'euc_kr':  'euc-kr',
    'ascii':   'us-ascii',
    }


# Map charsets to their Unicode codec strings.
CODEC_MAP = {
    'gb2312':      'eucgb2312_cn',
    'big5':        'big5_tw',
    # Hack: We don't want *any* conversion for stuff marked us-ascii, as all
    # sorts of garbage might be sent to us in the guise of 7-bit us-ascii.
    # Let that stuff pass through without conversion to/from Unicode.
    'us-ascii':    None,
    }



# Convenience functions for extending the above mappings
def add_charset(charset, header_enc=None, body_enc=None, output_charset=None):
    """Add character set properties to the global registry.

    charset is the input character set, and must be the canonical name of a
    character set.

    Optional header_enc and body_enc is either Charset.QP for
    quoted-printable, Charset.BASE64 for base64 encoding, Charset.SHORTEST for
    the shortest of qp or base64 encoding, or None for no encoding.  SHORTEST
    is only valid for header_enc.  It describes how message headers and
    message bodies in the input charset are to be encoded.  Default is no
    encoding.

    Optional output_charset is the character set that the output should be
    in.  Conversions will proceed from input charset, to Unicode, to the
    output charset when the method Charset.convert() is called.  The default
    is to output in the same character set as the input.

    Both input_charset and output_charset must have Unicode codec entries in
    the module's charset-to-codec mapping; use add_codec(charset, codecname)
    to add codecs the module does not know about.  See the codecs module's
    documentation for more information.
    """
    if body_enc == SHORTEST:
        raise ValueError('SHORTEST not allowed for body_enc')
    CHARSETS[charset] = (header_enc, body_enc, output_charset)


def add_alias(alias, canonical):
    """Add a character set alias.

    alias is the alias name, e.g. latin-1
    canonical is the character set's canonical name, e.g. iso-8859-1
    """
    ALIASES[alias] = canonical


def add_codec(charset, codecname):
    """Add a codec that map characters in the given charset to/from Unicode.

    charset is the canonical name of a character set.  codecname is the name
    of a Python codec, as appropriate for the second argument to the unicode()
    built-in, or to the encode() method of a Unicode string.
    """
    CODEC_MAP[charset] = codecname



# Convenience function for encoding strings, taking into account
# that they might be unknown-8bit (ie: have surrogate-escaped bytes)
def _encode(string, codec):
    if codec == UNKNOWN8BIT:
        return string.encode('ascii', 'surrogateescape')
    else:
        return string.encode(codec)



class Charset:
    """Map character sets to their email properties.

    This class provides information about the requirements imposed on email
    for a specific character set.  It also provides convenience routines for
    converting between character sets, given the availability of the
    applicable codecs.  Given a character set, it will do its best to provide
    information on how to use that character set in an email in an
    RFC-compliant way.

    Certain character sets must be encoded with quoted-printable or base64
    when used in email headers or bodies.  Certain character sets must be
    converted outright, and are not allowed in email.  Instances of this
    module expose the following information about a character set:

    input_charset: The initial character set specified.  Common aliases
                   are converted to their `official' email names (e.g. latin_1
                   is converted to iso-8859-1).  Defaults to 7-bit us-ascii.

    header_encoding: If the character set must be encoded before it can be
                     used in an email header, this attribute will be set to
                     Charset.QP (for quoted-printable), Charset.BASE64 (for
                     base64 encoding), or Charset.SHORTEST for the shortest of
                     QP or BASE64 encoding.  Otherwise, it will be None.

    body_encoding: Same as header_encoding, but describes the encoding for the
                   mail message's body, which indeed may be different than the
                   header encoding.  Charset.SHORTEST is not allowed for
                   body_encoding.

    output_charset: Some character sets must be converted before they can be
                    used in email headers or bodies.  If the input_charset is
                    one of them, this attribute will contain the name of the
                    charset output will be converted to.  Otherwise, it will
                    be None.

    input_codec: The name of the Python codec used to convert the
                 input_charset to Unicode.  If no conversion codec is
                 necessary, this attribute will be None.

    output_codec: The name of the Python codec used to convert Unicode
                  to the output_charset.  If no conversion codec is necessary,
                  this attribute will have the same value as the input_codec.
    """
    def __init__(self, input_charset=DEFAULT_CHARSET):
        # RFC 2046, $4.1.2 says charsets are not case sensitive.  We coerce to
        # unicode because its .lower() is locale insensitive.  If the argument
        # is already a unicode, we leave it at that, but ensure that the
        # charset is ASCII, as the standard (RFC XXX) requires.
        try:
            if isinstance(input_charset, str):
                input_charset.encode('ascii')
            else:
                input_charset = str(input_charset, 'ascii')
        except UnicodeError:
            raise errors.CharsetError(input_charset)
        input_charset = input_charset.lower()
        # Set the input charset after filtering through the aliases
        self.input_charset = ALIASES.get(input_charset, input_charset)
        # We can try to guess which encoding and conversion to use by the
        # charset_map dictionary.  Try that first, but let the user override
        # it.
        henc, benc, conv = CHARSETS.get(self.input_charset,
                                        (SHORTEST, BASE64, None))
        if not conv:
            conv = self.input_charset
        # Set the attributes, allowing the arguments to override the default.
        self.header_encoding = henc
        self.body_encoding = benc
        self.output_charset = ALIASES.get(conv, conv)
        # Now set the codecs.  If one isn't defined for input_charset,
        # guess and try a Unicode codec with the same name as input_codec.
        self.input_codec = CODEC_MAP.get(self.input_charset,
                                         self.input_charset)
        self.output_codec = CODEC_MAP.get(self.output_charset,
                                          self.output_charset)

    def __str__(self):
        return self.input_charset.lower()

    __repr__ = __str__

    def __eq__(self, other):
        return str(self) == str(other).lower()

    def get_body_encoding(self):
        """Return the content-transfer-encoding used for body encoding.

        This is either the string `quoted-printable' or `base64' depending on
        the encoding used, or it is a function in which case you should call
        the function with a single argument, the Message object being
        encoded.  The function should then set the Content-Transfer-Encoding
        header itself to whatever is appropriate.

        Returns "quoted-printable" if self.body_encoding is QP.
        Returns "base64" if self.body_encoding is BASE64.
        Returns conversion function otherwise.
        """
        assert self.body_encoding != SHORTEST
        if self.body_encoding == QP:
            return 'quoted-printable'
        elif self.body_encoding == BASE64:
            return 'base64'
        else:
            return encode_7or8bit

    def get_output_charset(self):
        """Return the output character set.

        This is self.output_charset if that is not None, otherwise it is
        self.input_charset.
        """
        return self.output_charset or self.input_charset

    def header_encode(self, string):
        """Header-encode a string by converting it first to bytes.

        The type of encoding (base64 or quoted-printable) will be based on
        this charset's `header_encoding`.

        :param string: A unicode string for the header.  It must be possible
            to encode this string to bytes using the character set's
            output codec.
        :return: The encoded string, with RFC 2047 chrome.
        """
        codec = self.output_codec or 'us-ascii'
        header_bytes = _encode(string, codec)
        # 7bit/8bit encodings return the string unchanged (modulo conversions)
        encoder_module = self._get_encoder(header_bytes)
        if encoder_module is None:
            return string
        return encoder_module.header_encode(header_bytes, codec)

    def header_encode_lines(self, string, maxlengths):
        """Header-encode a string by converting it first to bytes.

        This is similar to `header_encode()` except that the string is fit
        into maximum line lengths as given by the argument.

        :param string: A unicode string for the header.  It must be possible
            to encode this string to bytes using the character set's
            output codec.
        :param maxlengths: Maximum line length iterator.  Each element
            returned from this iterator will provide the next maximum line
            length.  This parameter is used as an argument to built-in next()
            and should never be exhausted.  The maximum line lengths should
            not count the RFC 2047 chrome.  These line lengths are only a
            hint; the splitter does the best it can.
        :return: Lines of encoded strings, each with RFC 2047 chrome.
        """
        # See which encoding we should use.
        codec = self.output_codec or 'us-ascii'
        header_bytes = _encode(string, codec)
        encoder_module = self._get_encoder(header_bytes)
        encoder = partial(encoder_module.header_encode, charset=codec)
        # Calculate the number of characters that the RFC 2047 chrome will
        # contribute to each line.
        charset = self.get_output_charset()
        extra = len(charset) + RFC2047_CHROME_LEN
        # Now comes the hard part.  We must encode bytes but we can't split on
        # bytes because some character sets are variable length and each
        # encoded word must stand on its own.  So the problem is you have to
        # encode to bytes to figure out this word's length, but you must split
        # on characters.  This causes two problems: first, we don't know how
        # many octets a specific substring of unicode characters will get
        # encoded to, and second, we don't know how many ASCII characters
        # those octets will get encoded to.  Unless we try it.  Which seems
        # inefficient.  In the interest of being correct rather than fast (and
        # in the hope that there will be few encoded headers in any such
        # message), brute force it. :(
        lines = []
        current_line = []
        maxlen = next(maxlengths) - extra
        for character in string:
            current_line.append(character)
            this_line = EMPTYSTRING.join(current_line)
            length = encoder_module.header_length(_encode(this_line, charset))
            if length > maxlen:
                # This last character doesn't fit so pop it off.
                current_line.pop()
                # Does nothing fit on the first line?
                if not lines and not current_line:
                    lines.append(None)
                else:
                    separator = (' ' if lines else '')
                    joined_line = EMPTYSTRING.join(current_line)
                    header_bytes = _encode(joined_line, codec)
                    lines.append(encoder(header_bytes))
                current_line = [character]
                maxlen = next(maxlengths) - extra
        joined_line = EMPTYSTRING.join(current_line)
        header_bytes = _encode(joined_line, codec)
        lines.append(encoder(header_bytes))
        return lines

    def _get_encoder(self, header_bytes):
        if self.header_encoding == BASE64:
            return email.base64mime
        elif self.header_encoding == QP:
            return email.quoprimime
        elif self.header_encoding == SHORTEST:
            len64 = email.base64mime.header_length(header_bytes)
            lenqp = email.quoprimime.header_length(header_bytes)
            if len64 < lenqp:
                return email.base64mime
            else:
                return email.quoprimime
        else:
            return None

    def body_encode(self, string):
        """Body-encode a string by converting it first to bytes.

        The type of encoding (base64 or quoted-printable) will be based on
        self.body_encoding.  If body_encoding is None, we assume the
        output charset is a 7bit encoding, so re-encoding the decoded
        string using the ascii codec produces the correct string version
        of the content.
        """
        if not string:
            return string
        if self.body_encoding is BASE64:
            if isinstance(string, str):
                string = string.encode(self.output_charset)
            return email.base64mime.body_encode(string)
        elif self.body_encoding is QP:
            # quopromime.body_encode takes a string, but operates on it as if
            # it were a list of byte codes.  For a (minimal) history on why
            # this is so, see changeset 0cf700464177.  To correctly encode a
            # character set, then, we must turn it into pseudo bytes via the
            # latin1 charset, which will encode any byte as a single code point
            # between 0 and 255, which is what body_encode is expecting.
            if isinstance(string, str):
                string = string.encode(self.output_charset)
            string = string.decode('latin1')
            return email.quoprimime.body_encode(string)
        else:
            if isinstance(string, str):
                string = string.encode(self.output_charset).decode('ascii')
            return string
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 import binascii
import email.charset
import email.message
import email.errors
from email import quoprimime

class ContentManager:

    def __init__(self):
        self.get_handlers = {}
        self.set_handlers = {}

    def add_get_handler(self, key, handler):
        self.get_handlers[key] = handler

    def get_content(self, msg, *args, **kw):
        content_type = msg.get_content_type()
        if content_type in self.get_handlers:
            return self.get_handlers[content_type](msg, *args, **kw)
        maintype = msg.get_content_maintype()
        if maintype in self.get_handlers:
            return self.get_handlers[maintype](msg, *args, **kw)
        if '' in self.get_handlers:
            return self.get_handlers[''](msg, *args, **kw)
        raise KeyError(content_type)

    def add_set_handler(self, typekey, handler):
        self.set_handlers[typekey] = handler

    def set_content(self, msg, obj, *args, **kw):
        if msg.get_content_maintype() == 'multipart':
            # XXX: is this error a good idea or not?  We can remove it later,
            # but we can't add it later, so do it for now.
            raise TypeError("set_content not valid on multipart")
        handler = self._find_set_handler(msg, obj)
        msg.clear_content()
        handler(msg, obj, *args, **kw)

    def _find_set_handler(self, msg, obj):
        full_path_for_error = None
        for typ in type(obj).__mro__:
            if typ in self.set_handlers:
                return self.set_handlers[typ]
            qname = typ.__qualname__
            modname = getattr(typ, '__module__', '')
            full_path = '.'.join((modname, qname)) if modname else qname
            if full_path_for_error is None:
                full_path_for_error = full_path
            if full_path in self.set_handlers:
                return self.set_handlers[full_path]
            if qname in self.set_handlers:
                return self.set_handlers[qname]
            name = typ.__name__
            if name in self.set_handlers:
                return self.set_handlers[name]
        if None in self.set_handlers:
            return self.set_handlers[None]
        raise KeyError(full_path_for_error)


raw_data_manager = ContentManager()


def get_text_content(msg, errors='replace'):
    content = msg.get_payload(decode=True)
    charset = msg.get_param('charset', 'ASCII')
    return content.decode(charset, errors=errors)
raw_data_manager.add_get_handler('text', get_text_content)


def get_non_text_content(msg):
    return msg.get_payload(decode=True)
for maintype in 'audio image video application'.split():
    raw_data_manager.add_get_handler(maintype, get_non_text_content)


def get_message_content(msg):
    return msg.get_payload(0)
for subtype in 'rfc822 external-body'.split():
    raw_data_manager.add_get_handler('message/'+subtype, get_message_content)


def get_and_fixup_unknown_message_content(msg):
    # If we don't understand a message subtype, we are supposed to treat it as
    # if it were application/octet-stream, per
    # tools.ietf.org/html/rfc2046#section-5.2.4.  Feedparser doesn't do that,
    # so do our best to fix things up.  Note that it is *not* appropriate to
    # model message/partial content as Message objects, so they are handled
    # here as well.  (How to reassemble them is out of scope for this comment :)
    return bytes(msg.get_payload(0))
raw_data_manager.add_get_handler('message',
                                 get_and_fixup_unknown_message_content)


def _prepare_set(msg, maintype, subtype, headers):
    msg['Content-Type'] = '/'.join((maintype, subtype))
    if headers:
        if not hasattr(headers[0], 'name'):
            mp = msg.policy
            headers = [mp.header_factory(*mp.header_source_parse([header]))
                       for header in headers]
        try:
            for header in headers:
                if header.defects:
                    raise header.defects[0]
                msg[header.name] = header
        except email.errors.HeaderDefect as exc:
            raise ValueError("Invalid header: {}".format(
                                header.fold(policy=msg.policy))) from exc


def _finalize_set(msg, disposition, filename, cid, params):
    if disposition is None and filename is not None:
        disposition = 'attachment'
    if disposition is not None:
        msg['Content-Disposition'] = disposition
    if filename is not None:
        msg.set_param('filename',
                      filename,
                      header='Content-Disposition',
                      replace=True)
    if cid is not None:
        msg['Content-ID'] = cid
    if params is not None:
        for key, value in params.items():
            msg.set_param(key, value)


# XXX: This is a cleaned-up version of base64mime.body_encode (including a bug
# fix in the calculation of unencoded_bytes_per_line).  It would be nice to
# drop both this and quoprimime.body_encode in favor of enhanced binascii
# routines that accepted a max_line_length parameter.
def _encode_base64(data, max_line_length):
    encoded_lines = []
    unencoded_bytes_per_line = max_line_length // 4 * 3
    for i in range(0, len(data), unencoded_bytes_per_line):
        thisline = data[i:i+unencoded_bytes_per_line]
        encoded_lines.append(binascii.b2a_base64(thisline).decode('ascii'))
    return ''.join(encoded_lines)


def _encode_text(string, charset, cte, policy):
    lines = string.encode(charset).splitlines()
    linesep = policy.linesep.encode('ascii')
    def embeded_body(lines): return linesep.join(lines) + linesep
    def normal_body(lines): return b'\n'.join(lines) + b'\n'
    if cte==None:
        # Use heuristics to decide on the "best" encoding.
        try:
            return '7bit', normal_body(lines).decode('ascii')
        except UnicodeDecodeError:
            pass
        if (policy.cte_type == '8bit' and
                max(len(x) for x in lines) <= policy.max_line_length):
            return '8bit', normal_body(lines).decode('ascii', 'surrogateescape')
        sniff = embeded_body(lines[:10])
        sniff_qp = quoprimime.body_encode(sniff.decode('latin-1'),
                                          policy.max_line_length)
        sniff_base64 = binascii.b2a_base64(sniff)
        # This is a little unfair to qp; it includes lineseps, base64 doesn't.
        if len(sniff_qp) > len(sniff_base64):
            cte = 'base64'
        else:
            cte = 'quoted-printable'
            if len(lines) <= 10:
                return cte, sniff_qp
    if cte == '7bit':
        data = normal_body(lines).decode('ascii')
    elif cte == '8bit':
        data = normal_body(lines).decode('ascii', 'surrogateescape')
    elif cte == 'quoted-printable':
        data = quoprimime.body_encode(normal_body(lines).decode('latin-1'),
                                      policy.max_line_length)
    elif cte == 'base64':
        data = _encode_base64(embeded_body(lines), policy.max_line_length)
    else:
        raise ValueError("Unknown content transfer encoding {}".format(cte))
    return cte, data


def set_text_content(msg, string, subtype="plain", charset='utf-8', cte=None,
                     disposition=None, filename=None, cid=None,
                     params=None, headers=None):
    _prepare_set(msg, 'text', subtype, headers)
    cte, payload = _encode_text(string, charset, cte, msg.policy)
    msg.set_payload(payload)
    msg.set_param('charset',
                  email.charset.ALIASES.get(charset, charset),
                  replace=True)
    msg['Content-Transfer-Encoding'] = cte
    _finalize_set(msg, disposition, filename, cid, params)
raw_data_manager.add_set_handler(str, set_text_content)


def set_message_content(msg, message, subtype="rfc822", cte=None,
                       disposition=None, filename=None, cid=None,
                       params=None, headers=None):
    if subtype == 'partial':
        raise ValueError("message/partial is not supported for Message objects")
    if subtype == 'rfc822':
        if cte not in (None, '7bit', '8bit', 'binary'):
            # http://tools.ietf.org/html/rfc2046#section-5.2.1 mandate.
            raise ValueError(
                "message/rfc822 parts do not support cte={}".format(cte))
        # 8bit will get coerced on serialization if policy.cte_type='7bit'.  We
        # may end up claiming 8bit when it isn't needed, but the only negative
        # result of that should be a gateway that needs to coerce to 7bit
        # having to look through the whole embedded message to discover whether
        # or not it actually has to do anything.
        cte = '8bit' if cte is None else cte
    elif subtype == 'external-body':
        if cte not in (None, '7bit'):
            # http://tools.ietf.org/html/rfc2046#section-5.2.3 mandate.
            raise ValueError(
                "message/external-body parts do not support cte={}".format(cte))
        cte = '7bit'
    elif cte is None:
        # http://tools.ietf.org/html/rfc2046#section-5.2.4 says all future
        # subtypes should be restricted to 7bit, so assume that.
        cte = '7bit'
    _prepare_set(msg, 'message', subtype, headers)
    msg.set_payload([message])
    msg['Content-Transfer-Encoding'] = cte
    _finalize_set(msg, disposition, filename, cid, params)
raw_data_manager.add_set_handler(email.message.Message, set_message_content)


def set_bytes_content(msg, data, maintype, subtype, cte='base64',
                     disposition=None, filename=None, cid=None,
                     params=None, headers=None):
    _prepare_set(msg, maintype, subtype, headers)
    if cte == 'base64':
        data = _encode_base64(data, max_line_length=msg.policy.max_line_length)
    elif cte == 'quoted-printable':
        # XXX: quoprimime.body_encode won't encode newline characters in data,
        # so we can't use it.  This means max_line_length is ignored.  Another
        # bug to fix later.  (Note: encoders.quopri is broken on line ends.)
        data = binascii.b2a_qp(data, istext=False, header=False, quotetabs=True)
        data = data.decode('ascii')
    elif cte == '7bit':
        # Make sure it really is only ASCII.  The early warning here seems
        # worth the overhead...if you care write your own content manager :).
        data.encode('ascii')
    elif cte in ('8bit', 'binary'):
        data = data.decode('ascii', 'surrogateescape')
    msg.set_payload(data)
    msg['Content-Transfer-Encoding'] = cte
    _finalize_set(msg, disposition, filename, cid, params)
for typ in (bytes, bytearray, memoryview):
    raw_data_manager.add_set_handler(typ, set_bytes_content)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Encodings and related functions."""

__all__ = [
    'encode_7or8bit',
    'encode_base64',
    'encode_noop',
    'encode_quopri',
    ]


from base64 import encodebytes as _bencode
from quopri import encodestring as _encodestring



def _qencode(s):
    enc = _encodestring(s, quotetabs=True)
    # Must encode spaces, which quopri.encodestring() doesn't do
    return enc.replace(b' ', b'=20')


def encode_base64(msg):
    """Encode the message's payload in Base64.

    Also, add an appropriate Content-Transfer-Encoding header.
    """
    orig = msg.get_payload(decode=True)
    encdata = str(_bencode(orig), 'ascii')
    msg.set_payload(encdata)
    msg['Content-Transfer-Encoding'] = 'base64'



def encode_quopri(msg):
    """Encode the message's payload in quoted-printable.

    Also, add an appropriate Content-Transfer-Encoding header.
    """
    orig = msg.get_payload(decode=True)
    encdata = _qencode(orig)
    msg.set_payload(encdata)
    msg['Content-Transfer-Encoding'] = 'quoted-printable'



def encode_7or8bit(msg):
    """Set the Content-Transfer-Encoding header to 7bit or 8bit."""
    orig = msg.get_payload(decode=True)
    if orig is None:
        # There's no payload.  For backwards compatibility we use 7bit
        msg['Content-Transfer-Encoding'] = '7bit'
        return
    # We play a trick to make this go fast.  If decoding from ASCII succeeds,
    # we know the data must be 7bit, otherwise treat it as 8bit.
    try:
        orig.decode('ascii')
    except UnicodeError:
        msg['Content-Transfer-Encoding'] = '8bit'
    else:
        msg['Content-Transfer-Encoding'] = '7bit'



def encode_noop(msg):
    """Do nothing."""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""email package exception classes."""


class MessageError(Exception):
    """Base class for errors in the email package."""


class MessageParseError(MessageError):
    """Base class for message parsing errors."""


class HeaderParseError(MessageParseError):
    """Error while parsing headers."""


class BoundaryError(MessageParseError):
    """Couldn't find terminating boundary."""


class MultipartConversionError(MessageError, TypeError):
    """Conversion to a multipart is prohibited."""


class CharsetError(MessageError):
    """An illegal charset was given."""


# These are parsing defects which the parser was able to work around.
class MessageDefect(ValueError):
    """Base class for a message defect."""

    def __init__(self, line=None):
        if line is not None:
            super().__init__(line)
        self.line = line

class NoBoundaryInMultipartDefect(MessageDefect):
    """A message claimed to be a multipart but had no boundary parameter."""

class StartBoundaryNotFoundDefect(MessageDefect):
    """The claimed start boundary was never found."""

class CloseBoundaryNotFoundDefect(MessageDefect):
    """A start boundary was found, but not the corresponding close boundary."""

class FirstHeaderLineIsContinuationDefect(MessageDefect):
    """A message had a continuation line as its first header line."""

class MisplacedEnvelopeHeaderDefect(MessageDefect):
    """A 'Unix-from' header was found in the middle of a header block."""

class MissingHeaderBodySeparatorDefect(MessageDefect):
    """Found line with no leading whitespace and no colon before blank line."""
# XXX: backward compatibility, just in case (it was never emitted).
MalformedHeaderDefect = MissingHeaderBodySeparatorDefect

class MultipartInvariantViolationDefect(MessageDefect):
    """A message claimed to be a multipart but no subparts were found."""

class InvalidMultipartContentTransferEncodingDefect(MessageDefect):
    """An invalid content transfer encoding was set on the multipart itself."""

class UndecodableBytesDefect(MessageDefect):
    """Header contained bytes that could not be decoded"""

class InvalidBase64PaddingDefect(MessageDefect):
    """base64 encoded sequence had an incorrect length"""

class InvalidBase64CharactersDefect(MessageDefect):
    """base64 encoded sequence had characters not in base64 alphabet"""

# These errors are specific to header parsing.

class HeaderDefect(MessageDefect):
    """Base class for a header defect."""

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)

class InvalidHeaderDefect(HeaderDefect):
    """Header is not valid, message gives details."""

class HeaderMissingRequiredValue(HeaderDefect):
    """A header that must have a value had none"""

class NonPrintableDefect(HeaderDefect):
    """ASCII characters outside the ascii-printable range found"""

    def __init__(self, non_printables):
        super().__init__(non_printables)
        self.non_printables = non_printables

    def __str__(self):
        return ("the following ASCII non-printables found in header: "
            "{}".format(self.non_printables))

class ObsoleteHeaderDefect(HeaderDefect):
    """Header uses syntax declared obsolete by RFC 5322"""

class NonASCIILocalPartDefect(HeaderDefect):
    """local_part contains non-ASCII characters"""
    # This defect only occurs during unicode parsing, not when
    # parsing messages decoded from binary.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright (C) 2004-2006 Python Software Foundation
# Authors: Baxter, Wouters and Warsaw
# Contact: email-sig@python.org

"""FeedParser - An email feed parser.

The feed parser implements an interface for incrementally parsing an email
message, line by line.  This has advantages for certain applications, such as
those reading email messages off a socket.

FeedParser.feed() is the primary interface for pushing new data into the
parser.  It returns when there's nothing more it can do with the available
data.  When you have no more data to push into the parser, call .close().
This completes the parsing and returns the root message object.

The other advantage of this parser is that it will never raise a parsing
exception.  Instead, when it finds something unexpected, it adds a 'defect' to
the current message.  Defects are just instances that live on the message
object's .defects attribute.
"""

__all__ = ['FeedParser', 'BytesFeedParser']

import re

from email import errors
from email import message
from email._policybase import compat32
from collections import deque
from io import StringIO

NLCRE = re.compile('\r\n|\r|\n')
NLCRE_bol = re.compile('(\r\n|\r|\n)')
NLCRE_eol = re.compile('(\r\n|\r|\n)\Z')
NLCRE_crack = re.compile('(\r\n|\r|\n)')
# RFC 2822 $3.6.8 Optional fields.  ftext is %d33-57 / %d59-126, Any character
# except controls, SP, and ":".
headerRE = re.compile(r'^(From |[\041-\071\073-\176]*:|[\t ])')
EMPTYSTRING = ''
NL = '\n'

NeedMoreData = object()



class BufferedSubFile(object):
    """A file-ish object that can have new data loaded into it.

    You can also push and pop line-matching predicates onto a stack.  When the
    current predicate matches the current line, a false EOF response
    (i.e. empty string) is returned instead.  This lets the parser adhere to a
    simple abstraction -- it parses until EOF closes the current message.
    """
    def __init__(self):
        # Text stream of the last partial line pushed into this object.
        # See issue 22233 for why this is a text stream and not a list.
        self._partial = StringIO(newline='')
        # A deque of full, pushed lines
        self._lines = deque()
        # The stack of false-EOF checking predicates.
        self._eofstack = []
        # A flag indicating whether the file has been closed or not.
        self._closed = False

    def push_eof_matcher(self, pred):
        self._eofstack.append(pred)

    def pop_eof_matcher(self):
        return self._eofstack.pop()

    def close(self):
        # Don't forget any trailing partial line.
        self._partial.seek(0)
        self.pushlines(self._partial.readlines())
        self._partial.seek(0)
        self._partial.truncate()
        self._closed = True

    def readline(self):
        if not self._lines:
            if self._closed:
                return ''
            return NeedMoreData
        # Pop the line off the stack and see if it matches the current
        # false-EOF predicate.
        line = self._lines.popleft()
        # RFC 2046, section 5.1.2 requires us to recognize outer level
        # boundaries at any level of inner nesting.  Do this, but be sure it's
        # in the order of most to least nested.
        for ateof in reversed(self._eofstack):
            if ateof(line):
                # We're at the false EOF.  But push the last line back first.
                self._lines.appendleft(line)
                return ''
        return line

    def unreadline(self, line):
        # Let the consumer push a line back into the buffer.
        assert line is not NeedMoreData
        self._lines.appendleft(line)

    def push(self, data):
        """Push some new data into this object."""
        self._partial.write(data)
        if '\n' not in data and '\r' not in data:
            # No new complete lines, wait for more.
            return

        # Crack into lines, preserving the linesep characters.
        self._partial.seek(0)
        parts = self._partial.readlines()
        self._partial.seek(0)
        self._partial.truncate()

        # If the last element of the list does not end in a newline, then treat
        # it as a partial line.  We only check for '\n' here because a line
        # ending with '\r' might be a line that was split in the middle of a
        # '\r\n' sequence (see bugs 1555570 and 1721862).
        if not parts[-1].endswith('\n'):
            self._partial.write(parts.pop())
        self.pushlines(parts)

    def pushlines(self, lines):
        self._lines.extend(lines)

    def __iter__(self):
        return self

    def __next__(self):
        line = self.readline()
        if line == '':
            raise StopIteration
        return line



class FeedParser:
    """A feed-style parser of email."""

    def __init__(self, _factory=None, *, policy=compat32):
        """_factory is called with no arguments to create a new message obj

        The policy keyword specifies a policy object that controls a number of
        aspects of the parser's operation.  The default policy maintains
        backward compatibility.

        """
        self.policy = policy
        self._old_style_factory = False
        if _factory is None:
            # What this should be:
            #self._factory = policy.default_message_factory
            # but, because we are post 3.4 feature freeze, fix with temp hack:
            if self.policy is compat32:
                self._factory = message.Message
            else:
                self._factory = message.EmailMessage
        else:
            self._factory = _factory
            try:
                _factory(policy=self.policy)
            except TypeError:
                # Assume this is an old-style factory
                self._old_style_factory = True
        self._input = BufferedSubFile()
        self._msgstack = []
        self._parse = self._parsegen().__next__
        self._cur = None
        self._last = None
        self._headersonly = False

    # Non-public interface for supporting Parser's headersonly flag
    def _set_headersonly(self):
        self._headersonly = True

    def feed(self, data):
        """Push more data into the parser."""
        self._input.push(data)
        self._call_parse()

    def _call_parse(self):
        try:
            self._parse()
        except StopIteration:
            pass

    def close(self):
        """Parse all remaining data and return the root message object."""
        self._input.close()
        self._call_parse()
        root = self._pop_message()
        assert not self._msgstack
        # Look for final set of defects
        if root.get_content_maintype() == 'multipart' \
               and not root.is_multipart():
            defect = errors.MultipartInvariantViolationDefect()
            self.policy.handle_defect(root, defect)
        return root

    def _new_message(self):
        if self._old_style_factory:
            msg = self._factory()
        else:
            msg = self._factory(policy=self.policy)
        if self._cur and self._cur.get_content_type() == 'multipart/digest':
            msg.set_default_type('message/rfc822')
        if self._msgstack:
            self._msgstack[-1].attach(msg)
        self._msgstack.append(msg)
        self._cur = msg
        self._last = msg

    def _pop_message(self):
        retval = self._msgstack.pop()
        if self._msgstack:
            self._cur = self._msgstack[-1]
        else:
            self._cur = None
        return retval

    def _parsegen(self):
        # Create a new message and start by parsing headers.
        self._new_message()
        headers = []
        # Collect the headers, searching for a line that doesn't match the RFC
        # 2822 header or continuation pattern (including an empty line).
        for line in self._input:
            if line is NeedMoreData:
                yield NeedMoreData
                continue
            if not headerRE.match(line):
                # If we saw the RFC defined header/body separator
                # (i.e. newline), just throw it away. Otherwise the line is
                # part of the body so push it back.
                if not NLCRE.match(line):
                    defect = errors.MissingHeaderBodySeparatorDefect()
                    self.policy.handle_defect(self._cur, defect)
                    self._input.unreadline(line)
                break
            headers.append(line)
        # Done with the headers, so parse them and figure out what we're
        # supposed to see in the body of the message.
        self._parse_headers(headers)
        # Headers-only parsing is a backwards compatibility hack, which was
        # necessary in the older parser, which could raise errors.  All
        # remaining lines in the input are thrown into the message body.
        if self._headersonly:
            lines = []
            while True:
                line = self._input.readline()
                if line is NeedMoreData:
                    yield NeedMoreData
                    continue
                if line == '':
                    break
                lines.append(line)
            self._cur.set_payload(EMPTYSTRING.join(lines))
            return
        if self._cur.get_content_type() == 'message/delivery-status':
            # message/delivery-status contains blocks of headers separated by
            # a blank line.  We'll represent each header block as a separate
            # nested message object, but the processing is a bit different
            # than standard message/* types because there is no body for the
            # nested messages.  A blank line separates the subparts.
            while True:
                self._input.push_eof_matcher(NLCRE.match)
                for retval in self._parsegen():
                    if retval is NeedMoreData:
                        yield NeedMoreData
                        continue
                    break
                msg = self._pop_message()
                # We need to pop the EOF matcher in order to tell if we're at
                # the end of the current file, not the end of the last block
                # of message headers.
                self._input.pop_eof_matcher()
                # The input stream must be sitting at the newline or at the
                # EOF.  We want to see if we're at the end of this subpart, so
                # first consume the blank line, then test the next line to see
                # if we're at this subpart's EOF.
                while True:
                    line = self._input.readline()
                    if line is NeedMoreData:
                        yield NeedMoreData
                        continue
                    break
                while True:
                    line = self._input.readline()
                    if line is NeedMoreData:
                        yield NeedMoreData
                        continue
                    break
                if line == '':
                    break
                # Not at EOF so this is a line we're going to need.
                self._input.unreadline(line)
            return
        if self._cur.get_content_maintype() == 'message':
            # The message claims to be a message/* type, then what follows is
            # another RFC 2822 message.
            for retval in self._parsegen():
                if retval is NeedMoreData:
                    yield NeedMoreData
                    continue
                break
            self._pop_message()
            return
        if self._cur.get_content_maintype() == 'multipart':
            boundary = self._cur.get_boundary()
            if boundary is None:
                # The message /claims/ to be a multipart but it has not
                # defined a boundary.  That's a problem which we'll handle by
                # reading everything until the EOF and marking the message as
                # defective.
                defect = errors.NoBoundaryInMultipartDefect()
                self.policy.handle_defect(self._cur, defect)
                lines = []
                for line in self._input:
                    if line is NeedMoreData:
                        yield NeedMoreData
                        continue
                    lines.append(line)
                self._cur.set_payload(EMPTYSTRING.join(lines))
                return
            # Make sure a valid content type was specified per RFC 2045:6.4.
            if (self._cur.get('content-transfer-encoding', '8bit').lower()
                    not in ('7bit', '8bit', 'binary')):
                defect = errors.InvalidMultipartContentTransferEncodingDefect()
                self.policy.handle_defect(self._cur, defect)
            # Create a line match predicate which matches the inter-part
            # boundary as well as the end-of-multipart boundary.  Don't push
            # this onto the input stream until we've scanned past the
            # preamble.
            separator = '--' + boundary
            boundaryre = re.compile(
                '(?P<sep>' + re.escape(separator) +
                r')(?P<end>--)?(?P<ws>[ \t]*)(?P<linesep>\r\n|\r|\n)?$')
            capturing_preamble = True
            preamble = []
            linesep = False
            close_boundary_seen = False
            while True:
                line = self._input.readline()
                if line is NeedMoreData:
                    yield NeedMoreData
                    continue
                if line == '':
                    break
                mo = boundaryre.match(line)
                if mo:
                    # If we're looking at the end boundary, we're done with
                    # this multipart.  If there was a newline at the end of
                    # the closing boundary, then we need to initialize the
                    # epilogue with the empty string (see below).
                    if mo.group('end'):
                        close_boundary_seen = True
                        linesep = mo.group('linesep')
                        break
                    # We saw an inter-part boundary.  Were we in the preamble?
                    if capturing_preamble:
                        if preamble:
                            # According to RFC 2046, the last newline belongs
                            # to the boundary.
                            lastline = preamble[-1]
                            eolmo = NLCRE_eol.search(lastline)
                            if eolmo:
                                preamble[-1] = lastline[:-len(eolmo.group(0))]
                            self._cur.preamble = EMPTYSTRING.join(preamble)
                        capturing_preamble = False
                        self._input.unreadline(line)
                        continue
                    # We saw a boundary separating two parts.  Consume any
                    # multiple boundary lines that may be following.  Our
                    # interpretation of RFC 2046 BNF grammar does not produce
                    # body parts within such double boundaries.
                    while True:
                        line = self._input.readline()
                        if line is NeedMoreData:
                            yield NeedMoreData
                            continue
                        mo = boundaryre.match(line)
                        if not mo:
                            self._input.unreadline(line)
                            break
                    # Recurse to parse this subpart; the input stream points
                    # at the subpart's first line.
                    self._input.push_eof_matcher(boundaryre.match)
                    for retval in self._parsegen():
                        if retval is NeedMoreData:
                            yield NeedMoreData
                            continue
                        break
                    # Because of RFC 2046, the newline preceding the boundary
                    # separator actually belongs to the boundary, not the
                    # previous subpart's payload (or epilogue if the previous
                    # part is a multipart).
                    if self._last.get_content_maintype() == 'multipart':
                        epilogue = self._last.epilogue
                        if epilogue == '':
                            self._last.epilogue = None
                        elif epilogue is not None:
                            mo = NLCRE_eol.search(epilogue)
                            if mo:
                                end = len(mo.group(0))
                                self._last.epilogue = epilogue[:-end]
                    else:
                        payload = self._last._payload
                        if isinstance(payload, str):
                            mo = NLCRE_eol.search(payload)
                            if mo:
                                payload = payload[:-len(mo.group(0))]
                                self._last._payload = payload
                    self._input.pop_eof_matcher()
                    self._pop_message()
                    # Set the multipart up for newline cleansing, which will
                    # happen if we're in a nested multipart.
                    self._last = self._cur
                else:
                    # I think we must be in the preamble
                    assert capturing_preamble
                    preamble.append(line)
            # We've seen either the EOF or the end boundary.  If we're still
            # capturing the preamble, we never saw the start boundary.  Note
            # that as a defect and store the captured text as the payload.
            if capturing_preamble:
                defect = errors.StartBoundaryNotFoundDefect()
                self.policy.handle_defect(self._cur, defect)
                self._cur.set_payload(EMPTYSTRING.join(preamble))
                epilogue = []
                for line in self._input:
                    if line is NeedMoreData:
                        yield NeedMoreData
                        continue
                self._cur.epilogue = EMPTYSTRING.join(epilogue)
                return
            # If we're not processing the preamble, then we might have seen
            # EOF without seeing that end boundary...that is also a defect.
            if not close_boundary_seen:
                defect = errors.CloseBoundaryNotFoundDefect()
                self.policy.handle_defect(self._cur, defect)
                return
            # Everything from here to the EOF is epilogue.  If the end boundary
            # ended in a newline, we'll need to make sure the epilogue isn't
            # None
            if linesep:
                epilogue = ['']
            else:
                epilogue = []
            for line in self._input:
                if line is NeedMoreData:
                    yield NeedMoreData
                    continue
                epilogue.append(line)
            # Any CRLF at the front of the epilogue is not technically part of
            # the epilogue.  Also, watch out for an empty string epilogue,
            # which means a single newline.
            if epilogue:
                firstline = epilogue[0]
                bolmo = NLCRE_bol.match(firstline)
                if bolmo:
                    epilogue[0] = firstline[len(bolmo.group(0)):]
            self._cur.epilogue = EMPTYSTRING.join(epilogue)
            return
        # Otherwise, it's some non-multipart type, so the entire rest of the
        # file contents becomes the payload.
        lines = []
        for line in self._input:
            if line is NeedMoreData:
                yield NeedMoreData
                continue
            lines.append(line)
        self._cur.set_payload(EMPTYSTRING.join(lines))

    def _parse_headers(self, lines):
        # Passed a list of lines that make up the headers for the current msg
        lastheader = ''
        lastvalue = []
        for lineno, line in enumerate(lines):
            # Check for continuation
            if line[0] in ' \t':
                if not lastheader:
                    # The first line of the headers was a continuation.  This
                    # is illegal, so let's note the defect, store the illegal
                    # line, and ignore it for purposes of headers.
                    defect = errors.FirstHeaderLineIsContinuationDefect(line)
                    self.policy.handle_defect(self._cur, defect)
                    continue
                lastvalue.append(line)
                continue
            if lastheader:
                self._cur.set_raw(*self.policy.header_source_parse(lastvalue))
                lastheader, lastvalue = '', []
            # Check for envelope header, i.e. unix-from
            if line.startswith('From '):
                if lineno == 0:
                    # Strip off the trailing newline
                    mo = NLCRE_eol.search(line)
                    if mo:
                        line = line[:-len(mo.group(0))]
                    self._cur.set_unixfrom(line)
                    continue
                elif lineno == len(lines) - 1:
                    # Something looking like a unix-from at the end - it's
                    # probably the first line of the body, so push back the
                    # line and stop.
                    self._input.unreadline(line)
                    return
                else:
                    # Weirdly placed unix-from line.  Note this as a defect
                    # and ignore it.
                    defect = errors.MisplacedEnvelopeHeaderDefect(line)
                    self._cur.defects.append(defect)
                    continue
            # Split the line on the colon separating field name from value.
            # There will always be a colon, because if there wasn't the part of
            # the parser that calls us would have started parsing the body.
            i = line.find(':')

            # If the colon is on the start of the line the header is clearly
            # malformed, but we might be able to salvage the rest of the
            # message. Track the error but keep going.
            if i == 0:
                defect = errors.InvalidHeaderDefect("Missing header name.")
                self._cur.defects.append(defect)
                continue

            assert i>0, "_parse_headers fed line with no : and no leading WS"
            lastheader = line[:i]
            lastvalue = [line]
        # Done with all the lines, so handle the last header.
        if lastheader:
            self._cur.set_raw(*self.policy.header_source_parse(lastvalue))


class BytesFeedParser(FeedParser):
    """Like FeedParser, but feed accepts bytes."""

    def feed(self, data):
        super().feed(data.decode('ascii', 'surrogateescape'))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Copyright (C) 2001-2010 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Classes to generate plain text from a message object tree."""

__all__ = ['Generator', 'DecodedGenerator', 'BytesGenerator']

import re
import sys
import time
import random

from copy import deepcopy
from io import StringIO, BytesIO
from email.utils import _has_surrogates

UNDERSCORE = '_'
NL = '\n'  # XXX: no longer used by the code below.

NLCRE = re.compile(r'\r\n|\r|\n')
fcre = re.compile(r'^From ', re.MULTILINE)



class Generator:
    """Generates output from a Message object tree.

    This basic generator writes the message to the given file object as plain
    text.
    """
    #
    # Public interface
    #

    def __init__(self, outfp, mangle_from_=None, maxheaderlen=None, *,
                 policy=None):
        """Create the generator for message flattening.

        outfp is the output file-like object for writing the message to.  It
        must have a write() method.

        Optional mangle_from_ is a flag that, when True (the default if policy
        is not set), escapes From_ lines in the body of the message by putting
        a `>' in front of them.

        Optional maxheaderlen specifies the longest length for a non-continued
        header.  When a header line is longer (in characters, with tabs
        expanded to 8 spaces) than maxheaderlen, the header will split as
        defined in the Header class.  Set maxheaderlen to zero to disable
        header wrapping.  The default is 78, as recommended (but not required)
        by RFC 2822.

        The policy keyword specifies a policy object that controls a number of
        aspects of the generator's operation.  If no policy is specified,
        the policy associated with the Message object passed to the
        flatten method is used.

        """

        if mangle_from_ is None:
            mangle_from_ = True if policy is None else policy.mangle_from_
        self._fp = outfp
        self._mangle_from_ = mangle_from_
        self.maxheaderlen = maxheaderlen
        self.policy = policy

    def write(self, s):
        # Just delegate to the file object
        self._fp.write(s)

    def flatten(self, msg, unixfrom=False, linesep=None):
        r"""Print the message object tree rooted at msg to the output file
        specified when the Generator instance was created.

        unixfrom is a flag that forces the printing of a Unix From_ delimiter
        before the first object in the message tree.  If the original message
        has no From_ delimiter, a `standard' one is crafted.  By default, this
        is False to inhibit the printing of any From_ delimiter.

        Note that for subobjects, no From_ line is printed.

        linesep specifies the characters used to indicate a new line in
        the output.  The default value is determined by the policy specified
        when the Generator instance was created or, if none was specified,
        from the policy associated with the msg.

        """
        # We use the _XXX constants for operating on data that comes directly
        # from the msg, and _encoded_XXX constants for operating on data that
        # has already been converted (to bytes in the BytesGenerator) and
        # inserted into a temporary buffer.
        policy = msg.policy if self.policy is None else self.policy
        if linesep is not None:
            policy = policy.clone(linesep=linesep)
        if self.maxheaderlen is not None:
            policy = policy.clone(max_line_length=self.maxheaderlen)
        self._NL = policy.linesep
        self._encoded_NL = self._encode(self._NL)
        self._EMPTY = ''
        self._encoded_EMPTY = self._encode(self._EMPTY)
        # Because we use clone (below) when we recursively process message
        # subparts, and because clone uses the computed policy (not None),
        # submessages will automatically get set to the computed policy when
        # they are processed by this code.
        old_gen_policy = self.policy
        old_msg_policy = msg.policy
        try:
            self.policy = policy
            msg.policy = policy
            if unixfrom:
                ufrom = msg.get_unixfrom()
                if not ufrom:
                    ufrom = 'From nobody ' + time.ctime(time.time())
                self.write(ufrom + self._NL)
            self._write(msg)
        finally:
            self.policy = old_gen_policy
            msg.policy = old_msg_policy

    def clone(self, fp):
        """Clone this generator with the exact same options."""
        return self.__class__(fp,
                              self._mangle_from_,
                              None, # Use policy setting, which we've adjusted
                              policy=self.policy)

    #
    # Protected interface - undocumented ;/
    #

    # Note that we use 'self.write' when what we are writing is coming from
    # the source, and self._fp.write when what we are writing is coming from a
    # buffer (because the Bytes subclass has already had a chance to transform
    # the data in its write method in that case).  This is an entirely
    # pragmatic split determined by experiment; we could be more general by
    # always using write and having the Bytes subclass write method detect when
    # it has already transformed the input; but, since this whole thing is a
    # hack anyway this seems good enough.

    def _new_buffer(self):
        # BytesGenerator overrides this to return BytesIO.
        return StringIO()

    def _encode(self, s):
        # BytesGenerator overrides this to encode strings to bytes.
        return s

    def _write_lines(self, lines):
        # We have to transform the line endings.
        if not lines:
            return
        lines = NLCRE.split(lines)
        for line in lines[:-1]:
            self.write(line)
            self.write(self._NL)
        if lines[-1]:
            self.write(lines[-1])
        # XXX logic tells me this else should be needed, but the tests fail
        # with it and pass without it.  (NLCRE.split ends with a blank element
        # if and only if there was a trailing newline.)
        #else:
        #    self.write(self._NL)

    def _write(self, msg):
        # We can't write the headers yet because of the following scenario:
        # say a multipart message includes the boundary string somewhere in
        # its body.  We'd have to calculate the new boundary /before/ we write
        # the headers so that we can write the correct Content-Type:
        # parameter.
        #
        # The way we do this, so as to make the _handle_*() methods simpler,
        # is to cache any subpart writes into a buffer.  The we write the
        # headers and the buffer contents.  That way, subpart handlers can
        # Do The Right Thing, and can still modify the Content-Type: header if
        # necessary.
        oldfp = self._fp
        try:
            self._munge_cte = None
            self._fp = sfp = self._new_buffer()
            self._dispatch(msg)
        finally:
            self._fp = oldfp
            munge_cte = self._munge_cte
            del self._munge_cte
        # If we munged the cte, copy the message again and re-fix the CTE.
        if munge_cte:
            msg = deepcopy(msg)
            msg.replace_header('content-transfer-encoding', munge_cte[0])
            msg.replace_header('content-type', munge_cte[1])
        # Write the headers.  First we see if the message object wants to
        # handle that itself.  If not, we'll do it generically.
        meth = getattr(msg, '_write_headers', None)
        if meth is None:
            self._write_headers(msg)
        else:
            meth(self)
        self._fp.write(sfp.getvalue())

    def _dispatch(self, msg):
        # Get the Content-Type: for the message, then try to dispatch to
        # self._handle_<maintype>_<subtype>().  If there's no handler for the
        # full MIME type, then dispatch to self._handle_<maintype>().  If
        # that's missing too, then dispatch to self._writeBody().
        main = msg.get_content_maintype()
        sub = msg.get_content_subtype()
        specific = UNDERSCORE.join((main, sub)).replace('-', '_')
        meth = getattr(self, '_handle_' + specific, None)
        if meth is None:
            generic = main.replace('-', '_')
            meth = getattr(self, '_handle_' + generic, None)
            if meth is None:
                meth = self._writeBody
        meth(msg)

    #
    # Default handlers
    #

    def _write_headers(self, msg):
        for h, v in msg.raw_items():
            self.write(self.policy.fold(h, v))
        # A blank line always separates headers from body
        self.write(self._NL)

    #
    # Handlers for writing types and subtypes
    #

    def _handle_text(self, msg):
        payload = msg.get_payload()
        if payload is None:
            return
        if not isinstance(payload, str):
            raise TypeError('string payload expected: %s' % type(payload))
        if _has_surrogates(msg._payload):
            charset = msg.get_param('charset')
            if charset is not None:
                # XXX: This copy stuff is an ugly hack to avoid modifying the
                # existing message.
                msg = deepcopy(msg)
                del msg['content-transfer-encoding']
                msg.set_payload(payload, charset)
                payload = msg.get_payload()
                self._munge_cte = (msg['content-transfer-encoding'],
                                   msg['content-type'])
        if self._mangle_from_:
            payload = fcre.sub('>From ', payload)
        self._write_lines(payload)

    # Default body handler
    _writeBody = _handle_text

    def _handle_multipart(self, msg):
        # The trick here is to write out each part separately, merge them all
        # together, and then make sure that the boundary we've chosen isn't
        # present in the payload.
        msgtexts = []
        subparts = msg.get_payload()
        if subparts is None:
            subparts = []
        elif isinstance(subparts, str):
            # e.g. a non-strict parse of a message with no starting boundary.
            self.write(subparts)
            return
        elif not isinstance(subparts, list):
            # Scalar payload
            subparts = [subparts]
        for part in subparts:
            s = self._new_buffer()
            g = self.clone(s)
            g.flatten(part, unixfrom=False, linesep=self._NL)
            msgtexts.append(s.getvalue())
        # BAW: What about boundaries that are wrapped in double-quotes?
        boundary = msg.get_boundary()
        if not boundary:
            # Create a boundary that doesn't appear in any of the
            # message texts.
            alltext = self._encoded_NL.join(msgtexts)
            boundary = self._make_boundary(alltext)
            msg.set_boundary(boundary)
        # If there's a preamble, write it out, with a trailing CRLF
        if msg.preamble is not None:
            if self._mangle_from_:
                preamble = fcre.sub('>From ', msg.preamble)
            else:
                preamble = msg.preamble
            self._write_lines(preamble)
            self.write(self._NL)
        # dash-boundary transport-padding CRLF
        self.write('--' + boundary + self._NL)
        # body-part
        if msgtexts:
            self._fp.write(msgtexts.pop(0))
        # *encapsulation
        # --> delimiter transport-padding
        # --> CRLF body-part
        for body_part in msgtexts:
            # delimiter transport-padding CRLF
            self.write(self._NL + '--' + boundary + self._NL)
            # body-part
            self._fp.write(body_part)
        # close-delimiter transport-padding
        self.write(self._NL + '--' + boundary + '--' + self._NL)
        if msg.epilogue is not None:
            if self._mangle_from_:
                epilogue = fcre.sub('>From ', msg.epilogue)
            else:
                epilogue = msg.epilogue
            self._write_lines(epilogue)

    def _handle_multipart_signed(self, msg):
        # The contents of signed parts has to stay unmodified in order to keep
        # the signature intact per RFC1847 2.1, so we disable header wrapping.
        # RDM: This isn't enough to completely preserve the part, but it helps.
        p = self.policy
        self.policy = p.clone(max_line_length=0)
        try:
            self._handle_multipart(msg)
        finally:
            self.policy = p

    def _handle_message_delivery_status(self, msg):
        # We can't just write the headers directly to self's file object
        # because this will leave an extra newline between the last header
        # block and the boundary.  Sigh.
        blocks = []
        for part in msg.get_payload():
            s = self._new_buffer()
            g = self.clone(s)
            g.flatten(part, unixfrom=False, linesep=self._NL)
            text = s.getvalue()
            lines = text.split(self._encoded_NL)
            # Strip off the unnecessary trailing empty line
            if lines and lines[-1] == self._encoded_EMPTY:
                blocks.append(self._encoded_NL.join(lines[:-1]))
            else:
                blocks.append(text)
        # Now join all the blocks with an empty line.  This has the lovely
        # effect of separating each block with an empty line, but not adding
        # an extra one after the last one.
        self._fp.write(self._encoded_NL.join(blocks))

    def _handle_message(self, msg):
        s = self._new_buffer()
        g = self.clone(s)
        # The payload of a message/rfc822 part should be a multipart sequence
        # of length 1.  The zeroth element of the list should be the Message
        # object for the subpart.  Extract that object, stringify it, and
        # write it out.
        # Except, it turns out, when it's a string instead, which happens when
        # and only when HeaderParser is used on a message of mime type
        # message/rfc822.  Such messages are generated by, for example,
        # Groupwise when forwarding unadorned messages.  (Issue 7970.)  So
        # in that case we just emit the string body.
        payload = msg._payload
        if isinstance(payload, list):
            g.flatten(msg.get_payload(0), unixfrom=False, linesep=self._NL)
            payload = s.getvalue()
        else:
            payload = self._encode(payload)
        self._fp.write(payload)

    # This used to be a module level function; we use a classmethod for this
    # and _compile_re so we can continue to provide the module level function
    # for backward compatibility by doing
    #   _make_boundary = Generator._make_boundary
    # at the end of the module.  It *is* internal, so we could drop that...
    @classmethod
    def _make_boundary(cls, text=None):
        # Craft a random boundary.  If text is given, ensure that the chosen
        # boundary doesn't appear in the text.
        token = random.randrange(sys.maxsize)
        boundary = ('=' * 15) + (_fmt % token) + '=='
        if text is None:
            return boundary
        b = boundary
        counter = 0
        while True:
            cre = cls._compile_re('^--' + re.escape(b) + '(--)?$', re.MULTILINE)
            if not cre.search(text):
                break
            b = boundary + '.' + str(counter)
            counter += 1
        return b

    @classmethod
    def _compile_re(cls, s, flags):
        return re.compile(s, flags)


class BytesGenerator(Generator):
    """Generates a bytes version of a Message object tree.

    Functionally identical to the base Generator except that the output is
    bytes and not string.  When surrogates were used in the input to encode
    bytes, these are decoded back to bytes for output.  If the policy has
    cte_type set to 7bit, then the message is transformed such that the
    non-ASCII bytes are properly content transfer encoded, using the charset
    unknown-8bit.

    The outfp object must accept bytes in its write method.
    """

    def write(self, s):
        self._fp.write(s.encode('ascii', 'surrogateescape'))

    def _new_buffer(self):
        return BytesIO()

    def _encode(self, s):
        return s.encode('ascii')

    def _write_headers(self, msg):
        # This is almost the same as the string version, except for handling
        # strings with 8bit bytes.
        for h, v in msg.raw_items():
            self._fp.write(self.policy.fold_binary(h, v))
        # A blank line always separates headers from body
        self.write(self._NL)

    def _handle_text(self, msg):
        # If the string has surrogates the original source was bytes, so
        # just write it back out.
        if msg._payload is None:
            return
        if _has_surrogates(msg._payload) and not self.policy.cte_type=='7bit':
            if self._mangle_from_:
                msg._payload = fcre.sub(">From ", msg._payload)
            self._write_lines(msg._payload)
        else:
            super(BytesGenerator,self)._handle_text(msg)

    # Default body handler
    _writeBody = _handle_text

    @classmethod
    def _compile_re(cls, s, flags):
        return re.compile(s.encode('ascii'), flags)



_FMT = '[Non-text (%(type)s) part of message omitted, filename %(filename)s]'

class DecodedGenerator(Generator):
    """Generates a text representation of a message.

    Like the Generator base class, except that non-text parts are substituted
    with a format string representing the part.
    """
    def __init__(self, outfp, mangle_from_=None, maxheaderlen=78, fmt=None):
        """Like Generator.__init__() except that an additional optional
        argument is allowed.

        Walks through all subparts of a message.  If the subpart is of main
        type `text', then it prints the decoded payload of the subpart.

        Otherwise, fmt is a format string that is used instead of the message
        payload.  fmt is expanded with the following keywords (in
        %(keyword)s format):

        type       : Full MIME type of the non-text part
        maintype   : Main MIME type of the non-text part
        subtype    : Sub-MIME type of the non-text part
        filename   : Filename of the non-text part
        description: Description associated with the non-text part
        encoding   : Content transfer encoding of the non-text part

        The default value for fmt is None, meaning

        [Non-text (%(type)s) part of message omitted, filename %(filename)s]
        """
        Generator.__init__(self, outfp, mangle_from_, maxheaderlen)
        if fmt is None:
            self._fmt = _FMT
        else:
            self._fmt = fmt

    def _dispatch(self, msg):
        for part in msg.walk():
            maintype = part.get_content_maintype()
            if maintype == 'text':
                print(part.get_payload(decode=False), file=self)
            elif maintype == 'multipart':
                # Just skip this
                pass
            else:
                print(self._fmt % {
                    'type'       : part.get_content_type(),
                    'maintype'   : part.get_content_maintype(),
                    'subtype'    : part.get_content_subtype(),
                    'filename'   : part.get_filename('[no filename]'),
                    'description': part.get('Content-Description',
                                            '[no description]'),
                    'encoding'   : part.get('Content-Transfer-Encoding',
                                            '[no encoding]'),
                    }, file=self)



# Helper used by Generator._make_boundary
_width = len(repr(sys.maxsize-1))
_fmt = '%%0%dd' % _width

# Backward compatibility
_make_boundary = Generator._make_boundary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright (C) 2002-2007 Python Software Foundation
# Author: Ben Gertzfield, Barry Warsaw
# Contact: email-sig@python.org

"""Header encoding and decoding functionality."""

__all__ = [
    'Header',
    'decode_header',
    'make_header',
    ]

import re
import binascii

import email.quoprimime
import email.base64mime

from email.errors import HeaderParseError
from email import charset as _charset
Charset = _charset.Charset

NL = '\n'
SPACE = ' '
BSPACE = b' '
SPACE8 = ' ' * 8
EMPTYSTRING = ''
MAXLINELEN = 78
FWS = ' \t'

USASCII = Charset('us-ascii')
UTF8 = Charset('utf-8')

# Match encoded-word strings in the form =?charset?q?Hello_World?=
ecre = re.compile(r'''
  =\?                   # literal =?
  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset
  \?                    # literal ?
  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive
  \?                    # literal ?
  (?P<encoded>.*?)      # non-greedy up to the next ?= is the encoded string
  \?=                   # literal ?=
  ''', re.VERBOSE | re.IGNORECASE | re.MULTILINE)

# Field name regexp, including trailing colon, but not separating whitespace,
# according to RFC 2822.  Character range is from tilde to exclamation mark.
# For use with .match()
fcre = re.compile(r'[\041-\176]+:$')

# Find a header embedded in a putative header value.  Used to check for
# header injection attack.
_embeded_header = re.compile(r'\n[^ \t]+:')



# Helpers
_max_append = email.quoprimime._max_append



def decode_header(header):
    """Decode a message header value without converting charset.

    Returns a list of (string, charset) pairs containing each of the decoded
    parts of the header.  Charset is None for non-encoded parts of the header,
    otherwise a lower-case string containing the name of the character set
    specified in the encoded string.

    header may be a string that may or may not contain RFC2047 encoded words,
    or it may be a Header object.

    An email.errors.HeaderParseError may be raised when certain decoding error
    occurs (e.g. a base64 decoding exception).
    """
    # If it is a Header object, we can just return the encoded chunks.
    if hasattr(header, '_chunks'):
        return [(_charset._encode(string, str(charset)), str(charset))
                    for string, charset in header._chunks]
    # If no encoding, just return the header with no charset.
    if not ecre.search(header):
        return [(header, None)]
    # First step is to parse all the encoded parts into triplets of the form
    # (encoded_string, encoding, charset).  For unencoded strings, the last
    # two parts will be None.
    words = []
    for line in header.splitlines():
        parts = ecre.split(line)
        first = True
        while parts:
            unencoded = parts.pop(0)
            if first:
                unencoded = unencoded.lstrip()
                first = False
            if unencoded:
                words.append((unencoded, None, None))
            if parts:
                charset = parts.pop(0).lower()
                encoding = parts.pop(0).lower()
                encoded = parts.pop(0)
                words.append((encoded, encoding, charset))
    # Now loop over words and remove words that consist of whitespace
    # between two encoded strings.
    droplist = []
    for n, w in enumerate(words):
        if n>1 and w[1] and words[n-2][1] and words[n-1][0].isspace():
            droplist.append(n-1)
    for d in reversed(droplist):
        del words[d]

    # The next step is to decode each encoded word by applying the reverse
    # base64 or quopri transformation.  decoded_words is now a list of the
    # form (decoded_word, charset).
    decoded_words = []
    for encoded_string, encoding, charset in words:
        if encoding is None:
            # This is an unencoded word.
            decoded_words.append((encoded_string, charset))
        elif encoding == 'q':
            word = email.quoprimime.header_decode(encoded_string)
            decoded_words.append((word, charset))
        elif encoding == 'b':
            paderr = len(encoded_string) % 4   # Postel's law: add missing padding
            if paderr:
                encoded_string += '==='[:4 - paderr]
            try:
                word = email.base64mime.decode(encoded_string)
            except binascii.Error:
                raise HeaderParseError('Base64 decoding error')
            else:
                decoded_words.append((word, charset))
        else:
            raise AssertionError('Unexpected encoding: ' + encoding)
    # Now convert all words to bytes and collapse consecutive runs of
    # similarly encoded words.
    collapsed = []
    last_word = last_charset = None
    for word, charset in decoded_words:
        if isinstance(word, str):
            word = bytes(word, 'raw-unicode-escape')
        if last_word is None:
            last_word = word
            last_charset = charset
        elif charset != last_charset:
            collapsed.append((last_word, last_charset))
            last_word = word
            last_charset = charset
        elif last_charset is None:
            last_word += BSPACE + word
        else:
            last_word += word
    collapsed.append((last_word, last_charset))
    return collapsed



def make_header(decoded_seq, maxlinelen=None, header_name=None,
                continuation_ws=' '):
    """Create a Header from a sequence of pairs as returned by decode_header()

    decode_header() takes a header value string and returns a sequence of
    pairs of the format (decoded_string, charset) where charset is the string
    name of the character set.

    This function takes one of those sequence of pairs and returns a Header
    instance.  Optional maxlinelen, header_name, and continuation_ws are as in
    the Header constructor.
    """
    h = Header(maxlinelen=maxlinelen, header_name=header_name,
               continuation_ws=continuation_ws)
    for s, charset in decoded_seq:
        # None means us-ascii but we can simply pass it on to h.append()
        if charset is not None and not isinstance(charset, Charset):
            charset = Charset(charset)
        h.append(s, charset)
    return h



class Header:
    def __init__(self, s=None, charset=None,
                 maxlinelen=None, header_name=None,
                 continuation_ws=' ', errors='strict'):
        """Create a MIME-compliant header that can contain many character sets.

        Optional s is the initial header value.  If None, the initial header
        value is not set.  You can later append to the header with .append()
        method calls.  s may be a byte string or a Unicode string, but see the
        .append() documentation for semantics.

        Optional charset serves two purposes: it has the same meaning as the
        charset argument to the .append() method.  It also sets the default
        character set for all subsequent .append() calls that omit the charset
        argument.  If charset is not provided in the constructor, the us-ascii
        charset is used both as s's initial charset and as the default for
        subsequent .append() calls.

        The maximum line length can be specified explicitly via maxlinelen. For
        splitting the first line to a shorter value (to account for the field
        header which isn't included in s, e.g. `Subject') pass in the name of
        the field in header_name.  The default maxlinelen is 78 as recommended
        by RFC 2822.

        continuation_ws must be RFC 2822 compliant folding whitespace (usually
        either a space or a hard tab) which will be prepended to continuation
        lines.

        errors is passed through to the .append() call.
        """
        if charset is None:
            charset = USASCII
        elif not isinstance(charset, Charset):
            charset = Charset(charset)
        self._charset = charset
        self._continuation_ws = continuation_ws
        self._chunks = []
        if s is not None:
            self.append(s, charset, errors)
        if maxlinelen is None:
            maxlinelen = MAXLINELEN
        self._maxlinelen = maxlinelen
        if header_name is None:
            self._headerlen = 0
        else:
            # Take the separating colon and space into account.
            self._headerlen = len(header_name) + 2

    def __str__(self):
        """Return the string value of the header."""
        self._normalize()
        uchunks = []
        lastcs = None
        lastspace = None
        for string, charset in self._chunks:
            # We must preserve spaces between encoded and non-encoded word
            # boundaries, which means for us we need to add a space when we go
            # from a charset to None/us-ascii, or from None/us-ascii to a
            # charset.  Only do this for the second and subsequent chunks.
            # Don't add a space if the None/us-ascii string already has
            # a space (trailing or leading depending on transition)
            nextcs = charset
            if nextcs == _charset.UNKNOWN8BIT:
                original_bytes = string.encode('ascii', 'surrogateescape')
                string = original_bytes.decode('ascii', 'replace')
            if uchunks:
                hasspace = string and self._nonctext(string[0])
                if lastcs not in (None, 'us-ascii'):
                    if nextcs in (None, 'us-ascii') and not hasspace:
                        uchunks.append(SPACE)
                        nextcs = None
                elif nextcs not in (None, 'us-ascii') and not lastspace:
                    uchunks.append(SPACE)
            lastspace = string and self._nonctext(string[-1])
            lastcs = nextcs
            uchunks.append(string)
        return EMPTYSTRING.join(uchunks)

    # Rich comparison operators for equality only.  BAW: does it make sense to
    # have or explicitly disable <, <=, >, >= operators?
    def __eq__(self, other):
        # other may be a Header or a string.  Both are fine so coerce
        # ourselves to a unicode (of the unencoded header value), swap the
        # args and do another comparison.
        return other == str(self)

    def append(self, s, charset=None, errors='strict'):
        """Append a string to the MIME header.

        Optional charset, if given, should be a Charset instance or the name
        of a character set (which will be converted to a Charset instance).  A
        value of None (the default) means that the charset given in the
        constructor is used.

        s may be a byte string or a Unicode string.  If it is a byte string
        (i.e. isinstance(s, str) is false), then charset is the encoding of
        that byte string, and a UnicodeError will be raised if the string
        cannot be decoded with that charset.  If s is a Unicode string, then
        charset is a hint specifying the character set of the characters in
        the string.  In either case, when producing an RFC 2822 compliant
        header using RFC 2047 rules, the string will be encoded using the
        output codec of the charset.  If the string cannot be encoded to the
        output codec, a UnicodeError will be raised.

        Optional `errors' is passed as the errors argument to the decode
        call if s is a byte string.
        """
        if charset is None:
            charset = self._charset
        elif not isinstance(charset, Charset):
            charset = Charset(charset)
        if not isinstance(s, str):
            input_charset = charset.input_codec or 'us-ascii'
            if input_charset == _charset.UNKNOWN8BIT:
                s = s.decode('us-ascii', 'surrogateescape')
            else:
                s = s.decode(input_charset, errors)
        # Ensure that the bytes we're storing can be decoded to the output
        # character set, otherwise an early error is raised.
        output_charset = charset.output_codec or 'us-ascii'
        if output_charset != _charset.UNKNOWN8BIT:
            try:
                s.encode(output_charset, errors)
            except UnicodeEncodeError:
                if output_charset!='us-ascii':
                    raise
                charset = UTF8
        self._chunks.append((s, charset))

    def _nonctext(self, s):
        """True if string s is not a ctext character of RFC822.
        """
        return s.isspace() or s in ('(', ')', '\\')

    def encode(self, splitchars=';, \t', maxlinelen=None, linesep='\n'):
        r"""Encode a message header into an RFC-compliant format.

        There are many issues involved in converting a given string for use in
        an email header.  Only certain character sets are readable in most
        email clients, and as header strings can only contain a subset of
        7-bit ASCII, care must be taken to properly convert and encode (with
        Base64 or quoted-printable) header strings.  In addition, there is a
        75-character length limit on any given encoded header field, so
        line-wrapping must be performed, even with double-byte character sets.

        Optional maxlinelen specifies the maximum length of each generated
        line, exclusive of the linesep string.  Individual lines may be longer
        than maxlinelen if a folding point cannot be found.  The first line
        will be shorter by the length of the header name plus ": " if a header
        name was specified at Header construction time.  The default value for
        maxlinelen is determined at header construction time.

        Optional splitchars is a string containing characters which should be
        given extra weight by the splitting algorithm during normal header
        wrapping.  This is in very rough support of RFC 2822's `higher level
        syntactic breaks':  split points preceded by a splitchar are preferred
        during line splitting, with the characters preferred in the order in
        which they appear in the string.  Space and tab may be included in the
        string to indicate whether preference should be given to one over the
        other as a split point when other split chars do not appear in the line
        being split.  Splitchars does not affect RFC 2047 encoded lines.

        Optional linesep is a string to be used to separate the lines of
        the value.  The default value is the most useful for typical
        Python applications, but it can be set to \r\n to produce RFC-compliant
        line separators when needed.
        """
        self._normalize()
        if maxlinelen is None:
            maxlinelen = self._maxlinelen
        # A maxlinelen of 0 means don't wrap.  For all practical purposes,
        # choosing a huge number here accomplishes that and makes the
        # _ValueFormatter algorithm much simpler.
        if maxlinelen == 0:
            maxlinelen = 1000000
        formatter = _ValueFormatter(self._headerlen, maxlinelen,
                                    self._continuation_ws, splitchars)
        lastcs = None
        hasspace = lastspace = None
        for string, charset in self._chunks:
            if hasspace is not None:
                hasspace = string and self._nonctext(string[0])
                if lastcs not in (None, 'us-ascii'):
                    if not hasspace or charset not in (None, 'us-ascii'):
                        formatter.add_transition()
                elif charset not in (None, 'us-ascii') and not lastspace:
                    formatter.add_transition()
            lastspace = string and self._nonctext(string[-1])
            lastcs = charset
            hasspace = False
            lines = string.splitlines()
            if lines:
                formatter.feed('', lines[0], charset)
            else:
                formatter.feed('', '', charset)
            for line in lines[1:]:
                formatter.newline()
                if charset.header_encoding is not None:
                    formatter.feed(self._continuation_ws, ' ' + line.lstrip(),
                                   charset)
                else:
                    sline = line.lstrip()
                    fws = line[:len(line)-len(sline)]
                    formatter.feed(fws, sline, charset)
            if len(lines) > 1:
                formatter.newline()
        if self._chunks:
            formatter.add_transition()
        value = formatter._str(linesep)
        if _embeded_header.search(value):
            raise HeaderParseError("header value appears to contain "
                "an embedded header: {!r}".format(value))
        return value

    def _normalize(self):
        # Step 1: Normalize the chunks so that all runs of identical charsets
        # get collapsed into a single unicode string.
        chunks = []
        last_charset = None
        last_chunk = []
        for string, charset in self._chunks:
            if charset == last_charset:
                last_chunk.append(string)
            else:
                if last_charset is not None:
                    chunks.append((SPACE.join(last_chunk), last_charset))
                last_chunk = [string]
                last_charset = charset
        if last_chunk:
            chunks.append((SPACE.join(last_chunk), last_charset))
        self._chunks = chunks



class _ValueFormatter:
    def __init__(self, headerlen, maxlen, continuation_ws, splitchars):
        self._maxlen = maxlen
        self._continuation_ws = continuation_ws
        self._continuation_ws_len = len(continuation_ws)
        self._splitchars = splitchars
        self._lines = []
        self._current_line = _Accumulator(headerlen)

    def _str(self, linesep):
        self.newline()
        return linesep.join(self._lines)

    def __str__(self):
        return self._str(NL)

    def newline(self):
        end_of_line = self._current_line.pop()
        if end_of_line != (' ', ''):
            self._current_line.push(*end_of_line)
        if len(self._current_line) > 0:
            if self._current_line.is_onlyws():
                self._lines[-1] += str(self._current_line)
            else:
                self._lines.append(str(self._current_line))
        self._current_line.reset()

    def add_transition(self):
        self._current_line.push(' ', '')

    def feed(self, fws, string, charset):
        # If the charset has no header encoding (i.e. it is an ASCII encoding)
        # then we must split the header at the "highest level syntactic break"
        # possible. Note that we don't have a lot of smarts about field
        # syntax; we just try to break on semi-colons, then commas, then
        # whitespace.  Eventually, this should be pluggable.
        if charset.header_encoding is None:
            self._ascii_split(fws, string, self._splitchars)
            return
        # Otherwise, we're doing either a Base64 or a quoted-printable
        # encoding which means we don't need to split the line on syntactic
        # breaks.  We can basically just find enough characters to fit on the
        # current line, minus the RFC 2047 chrome.  What makes this trickier
        # though is that we have to split at octet boundaries, not character
        # boundaries but it's only safe to split at character boundaries so at
        # best we can only get close.
        encoded_lines = charset.header_encode_lines(string, self._maxlengths())
        # The first element extends the current line, but if it's None then
        # nothing more fit on the current line so start a new line.
        try:
            first_line = encoded_lines.pop(0)
        except IndexError:
            # There are no encoded lines, so we're done.
            return
        if first_line is not None:
            self._append_chunk(fws, first_line)
        try:
            last_line = encoded_lines.pop()
        except IndexError:
            # There was only one line.
            return
        self.newline()
        self._current_line.push(self._continuation_ws, last_line)
        # Everything else are full lines in themselves.
        for line in encoded_lines:
            self._lines.append(self._continuation_ws + line)

    def _maxlengths(self):
        # The first line's length.
        yield self._maxlen - len(self._current_line)
        while True:
            yield self._maxlen - self._continuation_ws_len

    def _ascii_split(self, fws, string, splitchars):
        # The RFC 2822 header folding algorithm is simple in principle but
        # complex in practice.  Lines may be folded any place where "folding
        # white space" appears by inserting a linesep character in front of the
        # FWS.  The complication is that not all spaces or tabs qualify as FWS,
        # and we are also supposed to prefer to break at "higher level
        # syntactic breaks".  We can't do either of these without intimate
        # knowledge of the structure of structured headers, which we don't have
        # here.  So the best we can do here is prefer to break at the specified
        # splitchars, and hope that we don't choose any spaces or tabs that
        # aren't legal FWS.  (This is at least better than the old algorithm,
        # where we would sometimes *introduce* FWS after a splitchar, or the
        # algorithm before that, where we would turn all white space runs into
        # single spaces or tabs.)
        parts = re.split("(["+FWS+"]+)", fws+string)
        if parts[0]:
            parts[:0] = ['']
        else:
            parts.pop(0)
        for fws, part in zip(*[iter(parts)]*2):
            self._append_chunk(fws, part)

    def _append_chunk(self, fws, string):
        self._current_line.push(fws, string)
        if len(self._current_line) > self._maxlen:
            # Find the best split point, working backward from the end.
            # There might be none, on a long first line.
            for ch in self._splitchars:
                for i in range(self._current_line.part_count()-1, 0, -1):
                    if ch.isspace():
                        fws = self._current_line[i][0]
                        if fws and fws[0]==ch:
                            break
                    prevpart = self._current_line[i-1][1]
                    if prevpart and prevpart[-1]==ch:
                        break
                else:
                    continue
                break
            else:
                fws, part = self._current_line.pop()
                if self._current_line._initial_size > 0:
                    # There will be a header, so leave it on a line by itself.
                    self.newline()
                    if not fws:
                        # We don't use continuation_ws here because the whitespace
                        # after a header should always be a space.
                        fws = ' '
                self._current_line.push(fws, part)
                return
            remainder = self._current_line.pop_from(i)
            self._lines.append(str(self._current_line))
            self._current_line.reset(remainder)


class _Accumulator(list):

    def __init__(self, initial_size=0):
        self._initial_size = initial_size
        super().__init__()

    def push(self, fws, string):
        self.append((fws, string))

    def pop_from(self, i=0):
        popped = self[i:]
        self[i:] = []
        return popped

    def pop(self):
        if self.part_count()==0:
            return ('', '')
        return super().pop()

    def __len__(self):
        return sum((len(fws)+len(part) for fws, part in self),
                   self._initial_size)

    def __str__(self):
        return EMPTYSTRING.join((EMPTYSTRING.join((fws, part))
                                for fws, part in self))

    def reset(self, startval=None):
        if startval is None:
            startval = []
        self[:] = startval
        self._initial_size = 0

    def is_onlyws(self):
        return self._initial_size==0 and (not self or str(self).isspace())

    def part_count(self):
        return super().__len__()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Representing and manipulating email headers via custom objects.

This module provides an implementation of the HeaderRegistry API.
The implementation is designed to flexibly follow RFC5322 rules.

Eventually HeaderRegistry will be a public API, but it isn't yet,
and will probably change some before that happens.

"""
from types import MappingProxyType

from email import utils
from email import errors
from email import _header_value_parser as parser

class Address:

    def __init__(self, display_name='', username='', domain='', addr_spec=None):
        """Create an object representing a full email address.

        An address can have a 'display_name', a 'username', and a 'domain'.  In
        addition to specifying the username and domain separately, they may be
        specified together by using the addr_spec keyword *instead of* the
        username and domain keywords.  If an addr_spec string is specified it
        must be properly quoted according to RFC 5322 rules; an error will be
        raised if it is not.

        An Address object has display_name, username, domain, and addr_spec
        attributes, all of which are read-only.  The addr_spec and the string
        value of the object are both quoted according to RFC5322 rules, but
        without any Content Transfer Encoding.

        """
        # This clause with its potential 'raise' may only happen when an
        # application program creates an Address object using an addr_spec
        # keyword.  The email library code itself must always supply username
        # and domain.
        if addr_spec is not None:
            if username or domain:
                raise TypeError("addrspec specified when username and/or "
                                "domain also specified")
            a_s, rest = parser.get_addr_spec(addr_spec)
            if rest:
                raise ValueError("Invalid addr_spec; only '{}' "
                                 "could be parsed from '{}'".format(
                                    a_s, addr_spec))
            if a_s.all_defects:
                raise a_s.all_defects[0]
            username = a_s.local_part
            domain = a_s.domain
        self._display_name = display_name
        self._username = username
        self._domain = domain

    @property
    def display_name(self):
        return self._display_name

    @property
    def username(self):
        return self._username

    @property
    def domain(self):
        return self._domain

    @property
    def addr_spec(self):
        """The addr_spec (username@domain) portion of the address, quoted
        according to RFC 5322 rules, but with no Content Transfer Encoding.
        """
        nameset = set(self.username)
        if len(nameset) > len(nameset-parser.DOT_ATOM_ENDS):
            lp = parser.quote_string(self.username)
        else:
            lp = self.username
        if self.domain:
            return lp + '@' + self.domain
        if not lp:
            return '<>'
        return lp

    def __repr__(self):
        return "{}(display_name={!r}, username={!r}, domain={!r})".format(
                        self.__class__.__name__,
                        self.display_name, self.username, self.domain)

    def __str__(self):
        nameset = set(self.display_name)
        if len(nameset) > len(nameset-parser.SPECIALS):
            disp = parser.quote_string(self.display_name)
        else:
            disp = self.display_name
        if disp:
            addr_spec = '' if self.addr_spec=='<>' else self.addr_spec
            return "{} <{}>".format(disp, addr_spec)
        return self.addr_spec

    def __eq__(self, other):
        if type(other) != type(self):
            return False
        return (self.display_name == other.display_name and
                self.username == other.username and
                self.domain == other.domain)


class Group:

    def __init__(self, display_name=None, addresses=None):
        """Create an object representing an address group.

        An address group consists of a display_name followed by colon and a
        list of addresses (see Address) terminated by a semi-colon.  The Group
        is created by specifying a display_name and a possibly empty list of
        Address objects.  A Group can also be used to represent a single
        address that is not in a group, which is convenient when manipulating
        lists that are a combination of Groups and individual Addresses.  In
        this case the display_name should be set to None.  In particular, the
        string representation of a Group whose display_name is None is the same
        as the Address object, if there is one and only one Address object in
        the addresses list.

        """
        self._display_name = display_name
        self._addresses = tuple(addresses) if addresses else tuple()

    @property
    def display_name(self):
        return self._display_name

    @property
    def addresses(self):
        return self._addresses

    def __repr__(self):
        return "{}(display_name={!r}, addresses={!r}".format(
                 self.__class__.__name__,
                 self.display_name, self.addresses)

    def __str__(self):
        if self.display_name is None and len(self.addresses)==1:
            return str(self.addresses[0])
        disp = self.display_name
        if disp is not None:
            nameset = set(disp)
            if len(nameset) > len(nameset-parser.SPECIALS):
                disp = parser.quote_string(disp)
        adrstr = ", ".join(str(x) for x in self.addresses)
        adrstr = ' ' + adrstr if adrstr else adrstr
        return "{}:{};".format(disp, adrstr)

    def __eq__(self, other):
        if type(other) != type(self):
            return False
        return (self.display_name == other.display_name and
                self.addresses == other.addresses)


# Header Classes #

class BaseHeader(str):

    """Base class for message headers.

    Implements generic behavior and provides tools for subclasses.

    A subclass must define a classmethod named 'parse' that takes an unfolded
    value string and a dictionary as its arguments.  The dictionary will
    contain one key, 'defects', initialized to an empty list.  After the call
    the dictionary must contain two additional keys: parse_tree, set to the
    parse tree obtained from parsing the header, and 'decoded', set to the
    string value of the idealized representation of the data from the value.
    (That is, encoded words are decoded, and values that have canonical
    representations are so represented.)

    The defects key is intended to collect parsing defects, which the message
    parser will subsequently dispose of as appropriate.  The parser should not,
    insofar as practical, raise any errors.  Defects should be added to the
    list instead.  The standard header parsers register defects for RFC
    compliance issues, for obsolete RFC syntax, and for unrecoverable parsing
    errors.

    The parse method may add additional keys to the dictionary.  In this case
    the subclass must define an 'init' method, which will be passed the
    dictionary as its keyword arguments.  The method should use (usually by
    setting them as the value of similarly named attributes) and remove all the
    extra keys added by its parse method, and then use super to call its parent
    class with the remaining arguments and keywords.

    The subclass should also make sure that a 'max_count' attribute is defined
    that is either None or 1. XXX: need to better define this API.

    """

    def __new__(cls, name, value):
        kwds = {'defects': []}
        cls.parse(value, kwds)
        if utils._has_surrogates(kwds['decoded']):
            kwds['decoded'] = utils._sanitize(kwds['decoded'])
        self = str.__new__(cls, kwds['decoded'])
        del kwds['decoded']
        self.init(name, **kwds)
        return self

    def init(self, name, *, parse_tree, defects):
        self._name = name
        self._parse_tree = parse_tree
        self._defects = defects

    @property
    def name(self):
        return self._name

    @property
    def defects(self):
        return tuple(self._defects)

    def __reduce__(self):
        return (
            _reconstruct_header,
            (
                self.__class__.__name__,
                self.__class__.__bases__,
                str(self),
            ),
            self.__dict__)

    @classmethod
    def _reconstruct(cls, value):
        return str.__new__(cls, value)

    def fold(self, *, policy):
        """Fold header according to policy.

        The parsed representation of the header is folded according to
        RFC5322 rules, as modified by the policy.  If the parse tree
        contains surrogateescaped bytes, the bytes are CTE encoded using
        the charset 'unknown-8bit".

        Any non-ASCII characters in the parse tree are CTE encoded using
        charset utf-8. XXX: make this a policy setting.

        The returned value is an ASCII-only string possibly containing linesep
        characters, and ending with a linesep character.  The string includes
        the header name and the ': ' separator.

        """
        # At some point we need to only put fws here if it was in the source.
        header = parser.Header([
            parser.HeaderLabel([
                parser.ValueTerminal(self.name, 'header-name'),
                parser.ValueTerminal(':', 'header-sep')]),
            parser.CFWSList([parser.WhiteSpaceTerminal(' ', 'fws')]),
                             self._parse_tree])
        return header.fold(policy=policy)


def _reconstruct_header(cls_name, bases, value):
    return type(cls_name, bases, {})._reconstruct(value)


class UnstructuredHeader:

    max_count = None
    value_parser = staticmethod(parser.get_unstructured)

    @classmethod
    def parse(cls, value, kwds):
        kwds['parse_tree'] = cls.value_parser(value)
        kwds['decoded'] = str(kwds['parse_tree'])


class UniqueUnstructuredHeader(UnstructuredHeader):

    max_count = 1


class DateHeader:

    """Header whose value consists of a single timestamp.

    Provides an additional attribute, datetime, which is either an aware
    datetime using a timezone, or a naive datetime if the timezone
    in the input string is -0000.  Also accepts a datetime as input.
    The 'value' attribute is the normalized form of the timestamp,
    which means it is the output of format_datetime on the datetime.
    """

    max_count = None

    # This is used only for folding, not for creating 'decoded'.
    value_parser = staticmethod(parser.get_unstructured)

    @classmethod
    def parse(cls, value, kwds):
        if not value:
            kwds['defects'].append(errors.HeaderMissingRequiredValue())
            kwds['datetime'] = None
            kwds['decoded'] = ''
            kwds['parse_tree'] = parser.TokenList()
            return
        if isinstance(value, str):
            value = utils.parsedate_to_datetime(value)
        kwds['datetime'] = value
        kwds['decoded'] = utils.format_datetime(kwds['datetime'])
        kwds['parse_tree'] = cls.value_parser(kwds['decoded'])

    def init(self, *args, **kw):
        self._datetime = kw.pop('datetime')
        super().init(*args, **kw)

    @property
    def datetime(self):
        return self._datetime


class UniqueDateHeader(DateHeader):

    max_count = 1


class AddressHeader:

    max_count = None

    @staticmethod
    def value_parser(value):
        address_list, value = parser.get_address_list(value)
        assert not value, 'this should not happen'
        return address_list

    @classmethod
    def parse(cls, value, kwds):
        if isinstance(value, str):
            # We are translating here from the RFC language (address/mailbox)
            # to our API language (group/address).
            kwds['parse_tree'] = address_list = cls.value_parser(value)
            groups = []
            for addr in address_list.addresses:
                groups.append(Group(addr.display_name,
                                    [Address(mb.display_name or '',
                                             mb.local_part or '',
                                             mb.domain or '')
                                     for mb in addr.all_mailboxes]))
            defects = list(address_list.all_defects)
        else:
            # Assume it is Address/Group stuff
            if not hasattr(value, '__iter__'):
                value = [value]
            groups = [Group(None, [item]) if not hasattr(item, 'addresses')
                                          else item
                                    for item in value]
            defects = []
        kwds['groups'] = groups
        kwds['defects'] = defects
        kwds['decoded'] = ', '.join([str(item) for item in groups])
        if 'parse_tree' not in kwds:
            kwds['parse_tree'] = cls.value_parser(kwds['decoded'])

    def init(self, *args, **kw):
        self._groups = tuple(kw.pop('groups'))
        self._addresses = None
        super().init(*args, **kw)

    @property
    def groups(self):
        return self._groups

    @property
    def addresses(self):
        if self._addresses is None:
            self._addresses = tuple([address for group in self._groups
                                             for address in group.addresses])
        return self._addresses


class UniqueAddressHeader(AddressHeader):

    max_count = 1


class SingleAddressHeader(AddressHeader):

    @property
    def address(self):
        if len(self.addresses)!=1:
            raise ValueError(("value of single address header {} is not "
                "a single address").format(self.name))
        return self.addresses[0]


class UniqueSingleAddressHeader(SingleAddressHeader):

    max_count = 1


class MIMEVersionHeader:

    max_count = 1

    value_parser = staticmethod(parser.parse_mime_version)

    @classmethod
    def parse(cls, value, kwds):
        kwds['parse_tree'] = parse_tree = cls.value_parser(value)
        kwds['decoded'] = str(parse_tree)
        kwds['defects'].extend(parse_tree.all_defects)
        kwds['major'] = None if parse_tree.minor is None else parse_tree.major
        kwds['minor'] = parse_tree.minor
        if parse_tree.minor is not None:
            kwds['version'] = '{}.{}'.format(kwds['major'], kwds['minor'])
        else:
            kwds['version'] = None

    def init(self, *args, **kw):
        self._version = kw.pop('version')
        self._major = kw.pop('major')
        self._minor = kw.pop('minor')
        super().init(*args, **kw)

    @property
    def major(self):
        return self._major

    @property
    def minor(self):
        return self._minor

    @property
    def version(self):
        return self._version


class ParameterizedMIMEHeader:

    # Mixin that handles the params dict.  Must be subclassed and
    # a property value_parser for the specific header provided.

    max_count = 1

    @classmethod
    def parse(cls, value, kwds):
        kwds['parse_tree'] = parse_tree = cls.value_parser(value)
        kwds['decoded'] = str(parse_tree)
        kwds['defects'].extend(parse_tree.all_defects)
        if parse_tree.params is None:
            kwds['params'] = {}
        else:
            # The MIME RFCs specify that parameter ordering is arbitrary.
            kwds['params'] = {utils._sanitize(name).lower():
                                    utils._sanitize(value)
                               for name, value in parse_tree.params}

    def init(self, *args, **kw):
        self._params = kw.pop('params')
        super().init(*args, **kw)

    @property
    def params(self):
        return MappingProxyType(self._params)


class ContentTypeHeader(ParameterizedMIMEHeader):

    value_parser = staticmethod(parser.parse_content_type_header)

    def init(self, *args, **kw):
        super().init(*args, **kw)
        self._maintype = utils._sanitize(self._parse_tree.maintype)
        self._subtype = utils._sanitize(self._parse_tree.subtype)

    @property
    def maintype(self):
        return self._maintype

    @property
    def subtype(self):
        return self._subtype

    @property
    def content_type(self):
        return self.maintype + '/' + self.subtype


class ContentDispositionHeader(ParameterizedMIMEHeader):

    value_parser = staticmethod(parser.parse_content_disposition_header)

    def init(self, *args, **kw):
        super().init(*args, **kw)
        cd = self._parse_tree.content_disposition
        self._content_disposition = cd if cd is None else utils._sanitize(cd)

    @property
    def content_disposition(self):
        return self._content_disposition


class ContentTransferEncodingHeader:

    max_count = 1

    value_parser = staticmethod(parser.parse_content_transfer_encoding_header)

    @classmethod
    def parse(cls, value, kwds):
        kwds['parse_tree'] = parse_tree = cls.value_parser(value)
        kwds['decoded'] = str(parse_tree)
        kwds['defects'].extend(parse_tree.all_defects)

    def init(self, *args, **kw):
        super().init(*args, **kw)
        self._cte = utils._sanitize(self._parse_tree.cte)

    @property
    def cte(self):
        return self._cte


# The header factory #

_default_header_map = {
    'subject':                      UniqueUnstructuredHeader,
    'date':                         UniqueDateHeader,
    'resent-date':                  DateHeader,
    'orig-date':                    UniqueDateHeader,
    'sender':                       UniqueSingleAddressHeader,
    'resent-sender':                SingleAddressHeader,
    'to':                           UniqueAddressHeader,
    'resent-to':                    AddressHeader,
    'cc':                           UniqueAddressHeader,
    'resent-cc':                    AddressHeader,
    'bcc':                          UniqueAddressHeader,
    'resent-bcc':                   AddressHeader,
    'from':                         UniqueAddressHeader,
    'resent-from':                  AddressHeader,
    'reply-to':                     UniqueAddressHeader,
    'mime-version':                 MIMEVersionHeader,
    'content-type':                 ContentTypeHeader,
    'content-disposition':          ContentDispositionHeader,
    'content-transfer-encoding':    ContentTransferEncodingHeader,
    }

class HeaderRegistry:

    """A header_factory and header registry."""

    def __init__(self, base_class=BaseHeader, default_class=UnstructuredHeader,
                       use_default_map=True):
        """Create a header_factory that works with the Policy API.

        base_class is the class that will be the last class in the created
        header class's __bases__ list.  default_class is the class that will be
        used if "name" (see __call__) does not appear in the registry.
        use_default_map controls whether or not the default mapping of names to
        specialized classes is copied in to the registry when the factory is
        created.  The default is True.

        """
        self.registry = {}
        self.base_class = base_class
        self.default_class = default_class
        if use_default_map:
            self.registry.update(_default_header_map)

    def map_to_type(self, name, cls):
        """Register cls as the specialized class for handling "name" headers.

        """
        self.registry[name.lower()] = cls

    def __getitem__(self, name):
        cls = self.registry.get(name.lower(), self.default_class)
        return type('_'+cls.__name__, (cls, self.base_class), {})

    def __call__(self, name, value):
        """Create a header instance for header 'name' from 'value'.

        Creates a header instance by creating a specialized class for parsing
        and representing the specified header by combining the factory
        base_class with a specialized class from the registry or the
        default_class, and passing the name and value to the constructed
        class's constructor.

        """
        return self[name](name, value)
                                                                                                                                                                                                                                                                                                                            # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Various types of useful iterators and generators."""

__all__ = [
    'body_line_iterator',
    'typed_subpart_iterator',
    'walk',
    # Do not include _structure() since it's part of the debugging API.
    ]

import sys
from io import StringIO



# This function will become a method of the Message class
def walk(self):
    """Walk over the message tree, yielding each subpart.

    The walk is performed in depth-first order.  This method is a
    generator.
    """
    yield self
    if self.is_multipart():
        for subpart in self.get_payload():
            yield from subpart.walk()



# These two functions are imported into the Iterators.py interface module.
def body_line_iterator(msg, decode=False):
    """Iterate over the parts, returning string payloads line-by-line.

    Optional decode (default False) is passed through to .get_payload().
    """
    for subpart in msg.walk():
        payload = subpart.get_payload(decode=decode)
        if isinstance(payload, str):
            yield from StringIO(payload)


def typed_subpart_iterator(msg, maintype='text', subtype=None):
    """Iterate over the subparts with a given MIME type.

    Use `maintype' as the main MIME type to match against; this defaults to
    "text".  Optional `subtype' is the MIME subtype to match against; if
    omitted, only the main type is matched.
    """
    for subpart in msg.walk():
        if subpart.get_content_maintype() == maintype:
            if subtype is None or subpart.get_content_subtype() == subtype:
                yield subpart



def _structure(msg, fp=None, level=0, include_default=False):
    """A handy debugging aid"""
    if fp is None:
        fp = sys.stdout
    tab = ' ' * (level * 4)
    print(tab + msg.get_content_type(), end='', file=fp)
    if include_default:
        print(' [%s]' % msg.get_default_type(), file=fp)
    else:
        print(file=fp)
    if msg.is_multipart():
        for subpart in msg.get_payload():
            _structure(subpart, fp, level+1, include_default)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # Copyright (C) 2001-2007 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Basic message object for the email package object model."""

__all__ = ['Message']

import re
import uu
import quopri
import warnings
from io import BytesIO, StringIO

# Intrapackage imports
from email import utils
from email import errors
from email._policybase import compat32
from email import charset as _charset
from email._encoded_words import decode_b
Charset = _charset.Charset

SEMISPACE = '; '

# Regular expression that matches `special' characters in parameters, the
# existence of which force quoting of the parameter value.
tspecials = re.compile(r'[ \(\)<>@,;:\\"/\[\]\?=]')


def _splitparam(param):
    # Split header parameters.  BAW: this may be too simple.  It isn't
    # strictly RFC 2045 (section 5.1) compliant, but it catches most headers
    # found in the wild.  We may eventually need a full fledged parser.
    # RDM: we might have a Header here; for now just stringify it.
    a, sep, b = str(param).partition(';')
    if not sep:
        return a.strip(), None
    return a.strip(), b.strip()

def _formatparam(param, value=None, quote=True):
    """Convenience function to format and return a key=value pair.

    This will quote the value if needed or if quote is true.  If value is a
    three tuple (charset, language, value), it will be encoded according
    to RFC2231 rules.  If it contains non-ascii characters it will likewise
    be encoded according to RFC2231 rules, using the utf-8 charset and
    a null language.
    """
    if value is not None and len(value) > 0:
        # A tuple is used for RFC 2231 encoded parameter values where items
        # are (charset, language, value).  charset is a string, not a Charset
        # instance.  RFC 2231 encoded values are never quoted, per RFC.
        if isinstance(value, tuple):
            # Encode as per RFC 2231
            param += '*'
            value = utils.encode_rfc2231(value[2], value[0], value[1])
            return '%s=%s' % (param, value)
        else:
            try:
                value.encode('ascii')
            except UnicodeEncodeError:
                param += '*'
                value = utils.encode_rfc2231(value, 'utf-8', '')
                return '%s=%s' % (param, value)
        # BAW: Please check this.  I think that if quote is set it should
        # force quoting even if not necessary.
        if quote or tspecials.search(value):
            return '%s="%s"' % (param, utils.quote(value))
        else:
            return '%s=%s' % (param, value)
    else:
        return param

def _parseparam(s):
    # RDM This might be a Header, so for now stringify it.
    s = ';' + str(s)
    plist = []
    while s[:1] == ';':
        s = s[1:]
        end = s.find(';')
        while end > 0 and (s.count('"', 0, end) - s.count('\\"', 0, end)) % 2:
            end = s.find(';', end + 1)
        if end < 0:
            end = len(s)
        f = s[:end]
        if '=' in f:
            i = f.index('=')
            f = f[:i].strip().lower() + '=' + f[i+1:].strip()
        plist.append(f.strip())
        s = s[end:]
    return plist


def _unquotevalue(value):
    # This is different than utils.collapse_rfc2231_value() because it doesn't
    # try to convert the value to a unicode.  Message.get_param() and
    # Message.get_params() are both currently defined to return the tuple in
    # the face of RFC 2231 parameters.
    if isinstance(value, tuple):
        return value[0], value[1], utils.unquote(value[2])
    else:
        return utils.unquote(value)



class Message:
    """Basic message object.

    A message object is defined as something that has a bunch of RFC 2822
    headers and a payload.  It may optionally have an envelope header
    (a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a
    multipart or a message/rfc822), then the payload is a list of Message
    objects, otherwise it is a string.

    Message objects implement part of the `mapping' interface, which assumes
    there is exactly one occurrence of the header per message.  Some headers
    do in fact appear multiple times (e.g. Received) and for those headers,
    you must use the explicit API to set or get all the headers.  Not all of
    the mapping methods are implemented.
    """
    def __init__(self, policy=compat32):
        self.policy = policy
        self._headers = []
        self._unixfrom = None
        self._payload = None
        self._charset = None
        # Defaults for multipart messages
        self.preamble = self.epilogue = None
        self.defects = []
        # Default content type
        self._default_type = 'text/plain'

    def __str__(self):
        """Return the entire formatted message as a string.
        """
        return self.as_string()

    def as_string(self, unixfrom=False, maxheaderlen=0, policy=None):
        """Return the entire formatted message as a string.

        Optional 'unixfrom', when true, means include the Unix From_ envelope
        header.  For backward compatibility reasons, if maxheaderlen is
        not specified it defaults to 0, so you must override it explicitly
        if you want a different maxheaderlen.  'policy' is passed to the
        Generator instance used to serialize the mesasge; if it is not
        specified the policy associated with the message instance is used.

        If the message object contains binary data that is not encoded
        according to RFC standards, the non-compliant data will be replaced by
        unicode "unknown character" code points.
        """
        from email.generator import Generator
        policy = self.policy if policy is None else policy
        fp = StringIO()
        g = Generator(fp,
                      mangle_from_=False,
                      maxheaderlen=maxheaderlen,
                      policy=policy)
        g.flatten(self, unixfrom=unixfrom)
        return fp.getvalue()

    def __bytes__(self):
        """Return the entire formatted message as a bytes object.
        """
        return self.as_bytes()

    def as_bytes(self, unixfrom=False, policy=None):
        """Return the entire formatted message as a bytes object.

        Optional 'unixfrom', when true, means include the Unix From_ envelope
        header.  'policy' is passed to the BytesGenerator instance used to
        serialize the message; if not specified the policy associated with
        the message instance is used.
        """
        from email.generator import BytesGenerator
        policy = self.policy if policy is None else policy
        fp = BytesIO()
        g = BytesGenerator(fp, mangle_from_=False, policy=policy)
        g.flatten(self, unixfrom=unixfrom)
        return fp.getvalue()

    def is_multipart(self):
        """Return True if the message consists of multiple parts."""
        return isinstance(self._payload, list)

    #
    # Unix From_ line
    #
    def set_unixfrom(self, unixfrom):
        self._unixfrom = unixfrom

    def get_unixfrom(self):
        return self._unixfrom

    #
    # Payload manipulation.
    #
    def attach(self, payload):
        """Add the given payload to the current payload.

        The current payload will always be a list of objects after this method
        is called.  If you want to set the payload to a scalar object, use
        set_payload() instead.
        """
        if self._payload is None:
            self._payload = [payload]
        else:
            try:
                self._payload.append(payload)
            except AttributeError:
                raise TypeError("Attach is not valid on a message with a"
                                " non-multipart payload")

    def get_payload(self, i=None, decode=False):
        """Return a reference to the payload.

        The payload will either be a list object or a string.  If you mutate
        the list object, you modify the message's payload in place.  Optional
        i returns that index into the payload.

        Optional decode is a flag indicating whether the payload should be
        decoded or not, according to the Content-Transfer-Encoding header
        (default is False).

        When True and the message is not a multipart, the payload will be
        decoded if this header's value is `quoted-printable' or `base64'.  If
        some other encoding is used, or the header is missing, or if the
        payload has bogus data (i.e. bogus base64 or uuencoded data), the
        payload is returned as-is.

        If the message is a multipart and the decode flag is True, then None
        is returned.
        """
        # Here is the logic table for this code, based on the email5.0.0 code:
        #   i     decode  is_multipart  result
        # ------  ------  ------------  ------------------------------
        #  None   True    True          None
        #   i     True    True          None
        #  None   False   True          _payload (a list)
        #   i     False   True          _payload element i (a Message)
        #   i     False   False         error (not a list)
        #   i     True    False         error (not a list)
        #  None   False   False         _payload
        #  None   True    False         _payload decoded (bytes)
        # Note that Barry planned to factor out the 'decode' case, but that
        # isn't so easy now that we handle the 8 bit data, which needs to be
        # converted in both the decode and non-decode path.
        if self.is_multipart():
            if decode:
                return None
            if i is None:
                return self._payload
            else:
                return self._payload[i]
        # For backward compatibility, Use isinstance and this error message
        # instead of the more logical is_multipart test.
        if i is not None and not isinstance(self._payload, list):
            raise TypeError('Expected list, got %s' % type(self._payload))
        payload = self._payload
        # cte might be a Header, so for now stringify it.
        cte = str(self.get('content-transfer-encoding', '')).lower()
        # payload may be bytes here.
        if isinstance(payload, str):
            if utils._has_surrogates(payload):
                bpayload = payload.encode('ascii', 'surrogateescape')
                if not decode:
                    try:
                        payload = bpayload.decode(self.get_param('charset', 'ascii'), 'replace')
                    except LookupError:
                        payload = bpayload.decode('ascii', 'replace')
            elif decode:
                try:
                    bpayload = payload.encode('ascii')
                except UnicodeError:
                    # This won't happen for RFC compliant messages (messages
                    # containing only ASCII code points in the unicode input).
                    # If it does happen, turn the string into bytes in a way
                    # guaranteed not to fail.
                    bpayload = payload.encode('raw-unicode-escape')
        if not decode:
            return payload
        if cte == 'quoted-printable':
            return quopri.decodestring(bpayload)
        elif cte == 'base64':
            # XXX: this is a bit of a hack; decode_b should probably be factored
            # out somewhere, but I haven't figured out where yet.
            value, defects = decode_b(b''.join(bpayload.splitlines()))
            for defect in defects:
                self.policy.handle_defect(self, defect)
            return value
        elif cte in ('x-uuencode', 'uuencode', 'uue', 'x-uue'):
            in_file = BytesIO(bpayload)
            out_file = BytesIO()
            try:
                uu.decode(in_file, out_file, quiet=True)
                return out_file.getvalue()
            except uu.Error:
                # Some decoding problem
                return bpayload
        if isinstance(payload, str):
            return bpayload
        return payload

    def set_payload(self, payload, charset=None):
        """Set the payload to the given value.

        Optional charset sets the message's default character set.  See
        set_charset() for details.
        """
        if hasattr(payload, 'encode'):
            if charset is None:
                self._payload = payload
                return
            if not isinstance(charset, Charset):
                charset = Charset(charset)
            payload = payload.encode(charset.output_charset)
        if hasattr(payload, 'decode'):
            self._payload = payload.decode('ascii', 'surrogateescape')
        else:
            self._payload = payload
        if charset is not None:
            self.set_charset(charset)

    def set_charset(self, charset):
        """Set the charset of the payload to a given character set.

        charset can be a Charset instance, a string naming a character set, or
        None.  If it is a string it will be converted to a Charset instance.
        If charset is None, the charset parameter will be removed from the
        Content-Type field.  Anything else will generate a TypeError.

        The message will be assumed to be of type text/* encoded with
        charset.input_charset.  It will be converted to charset.output_charset
        and encoded properly, if needed, when generating the plain text
        representation of the message.  MIME headers (MIME-Version,
        Content-Type, Content-Transfer-Encoding) will be added as needed.
        """
        if charset is None:
            self.del_param('charset')
            self._charset = None
            return
        if not isinstance(charset, Charset):
            charset = Charset(charset)
        self._charset = charset
        if 'MIME-Version' not in self:
            self.add_header('MIME-Version', '1.0')
        if 'Content-Type' not in self:
            self.add_header('Content-Type', 'text/plain',
                            charset=charset.get_output_charset())
        else:
            self.set_param('charset', charset.get_output_charset())
        if charset != charset.get_output_charset():
            self._payload = charset.body_encode(self._payload)
        if 'Content-Transfer-Encoding' not in self:
            cte = charset.get_body_encoding()
            try:
                cte(self)
            except TypeError:
                # This 'if' is for backward compatibility, it allows unicode
                # through even though that won't work correctly if the
                # message is serialized.
                payload = self._payload
                if payload:
                    try:
                        payload = payload.encode('ascii', 'surrogateescape')
                    except UnicodeError:
                        payload = payload.encode(charset.output_charset)
                self._payload = charset.body_encode(payload)
                self.add_header('Content-Transfer-Encoding', cte)

    def get_charset(self):
        """Return the Charset instance associated with the message's payload.
        """
        return self._charset

    #
    # MAPPING INTERFACE (partial)
    #
    def __len__(self):
        """Return the total number of headers, including duplicates."""
        return len(self._headers)

    def __getitem__(self, name):
        """Get a header value.

        Return None if the header is missing instead of raising an exception.

        Note that if the header appeared multiple times, exactly which
        occurrence gets returned is undefined.  Use get_all() to get all
        the values matching a header field name.
        """
        return self.get(name)

    def __setitem__(self, name, val):
        """Set the value of a header.

        Note: this does not overwrite an existing header with the same field
        name.  Use __delitem__() first to delete any existing headers.
        """
        max_count = self.policy.header_max_count(name)
        if max_count:
            lname = name.lower()
            found = 0
            for k, v in self._headers:
                if k.lower() == lname:
                    found += 1
                    if found >= max_count:
                        raise ValueError("There may be at most {} {} headers "
                                         "in a message".format(max_count, name))
        self._headers.append(self.policy.header_store_parse(name, val))

    def __delitem__(self, name):
        """Delete all occurrences of a header, if present.

        Does not raise an exception if the header is missing.
        """
        name = name.lower()
        newheaders = []
        for k, v in self._headers:
            if k.lower() != name:
                newheaders.append((k, v))
        self._headers = newheaders

    def __contains__(self, name):
        return name.lower() in [k.lower() for k, v in self._headers]

    def __iter__(self):
        for field, value in self._headers:
            yield field

    def keys(self):
        """Return a list of all the message's header field names.

        These will be sorted in the order they appeared in the original
        message, or were added to the message, and may contain duplicates.
        Any fields deleted and re-inserted are always appended to the header
        list.
        """
        return [k for k, v in self._headers]

    def values(self):
        """Return a list of all the message's header values.

        These will be sorted in the order they appeared in the original
        message, or were added to the message, and may contain duplicates.
        Any fields deleted and re-inserted are always appended to the header
        list.
        """
        return [self.policy.header_fetch_parse(k, v)
                for k, v in self._headers]

    def items(self):
        """Get all the message's header fields and values.

        These will be sorted in the order they appeared in the original
        message, or were added to the message, and may contain duplicates.
        Any fields deleted and re-inserted are always appended to the header
        list.
        """
        return [(k, self.policy.header_fetch_parse(k, v))
                for k, v in self._headers]

    def get(self, name, failobj=None):
        """Get a header value.

        Like __getitem__() but return failobj instead of None when the field
        is missing.
        """
        name = name.lower()
        for k, v in self._headers:
            if k.lower() == name:
                return self.policy.header_fetch_parse(k, v)
        return failobj

    #
    # "Internal" methods (public API, but only intended for use by a parser
    # or generator, not normal application code.
    #

    def set_raw(self, name, value):
        """Store name and value in the model without modification.

        This is an "internal" API, intended only for use by a parser.
        """
        self._headers.append((name, value))

    def raw_items(self):
        """Return the (name, value) header pairs without modification.

        This is an "internal" API, intended only for use by a generator.
        """
        return iter(self._headers.copy())

    #
    # Additional useful stuff
    #

    def get_all(self, name, failobj=None):
        """Return a list of all the values for the named field.

        These will be sorted in the order they appeared in the original
        message, and may contain duplicates.  Any fields deleted and
        re-inserted are always appended to the header list.

        If no such fields exist, failobj is returned (defaults to None).
        """
        values = []
        name = name.lower()
        for k, v in self._headers:
            if k.lower() == name:
                values.append(self.policy.header_fetch_parse(k, v))
        if not values:
            return failobj
        return values

    def add_header(self, _name, _value, **_params):
        """Extended header setting.

        name is the header field to add.  keyword arguments can be used to set
        additional parameters for the header field, with underscores converted
        to dashes.  Normally the parameter will be added as key="value" unless
        value is None, in which case only the key will be added.  If a
        parameter value contains non-ASCII characters it can be specified as a
        three-tuple of (charset, language, value), in which case it will be
        encoded according to RFC2231 rules.  Otherwise it will be encoded using
        the utf-8 charset and a language of ''.

        Examples:

        msg.add_header('content-disposition', 'attachment', filename='bud.gif')
        msg.add_header('content-disposition', 'attachment',
                       filename=('utf-8', '', Fuballer.ppt'))
        msg.add_header('content-disposition', 'attachment',
                       filename='Fuballer.ppt'))
        """
        parts = []
        for k, v in _params.items():
            if v is None:
                parts.append(k.replace('_', '-'))
            else:
                parts.append(_formatparam(k.replace('_', '-'), v))
        if _value is not None:
            parts.insert(0, _value)
        self[_name] = SEMISPACE.join(parts)

    def replace_header(self, _name, _value):
        """Replace a header.

        Replace the first matching header found in the message, retaining
        header order and case.  If no matching header was found, a KeyError is
        raised.
        """
        _name = _name.lower()
        for i, (k, v) in zip(range(len(self._headers)), self._headers):
            if k.lower() == _name:
                self._headers[i] = self.policy.header_store_parse(k, _value)
                break
        else:
            raise KeyError(_name)

    #
    # Use these three methods instead of the three above.
    #

    def get_content_type(self):
        """Return the message's content type.

        The returned string is coerced to lower case of the form
        `maintype/subtype'.  If there was no Content-Type header in the
        message, the default type as given by get_default_type() will be
        returned.  Since according to RFC 2045, messages always have a default
        type this will always return a value.

        RFC 2045 defines a message's default type to be text/plain unless it
        appears inside a multipart/digest container, in which case it would be
        message/rfc822.
        """
        missing = object()
        value = self.get('content-type', missing)
        if value is missing:
            # This should have no parameters
            return self.get_default_type()
        ctype = _splitparam(value)[0].lower()
        # RFC 2045, section 5.2 says if its invalid, use text/plain
        if ctype.count('/') != 1:
            return 'text/plain'
        return ctype

    def get_content_maintype(self):
        """Return the message's main content type.

        This is the `maintype' part of the string returned by
        get_content_type().
        """
        ctype = self.get_content_type()
        return ctype.split('/')[0]

    def get_content_subtype(self):
        """Returns the message's sub-content type.

        This is the `subtype' part of the string returned by
        get_content_type().
        """
        ctype = self.get_content_type()
        return ctype.split('/')[1]

    def get_default_type(self):
        """Return the `default' content type.

        Most messages have a default content type of text/plain, except for
        messages that are subparts of multipart/digest containers.  Such
        subparts have a default content type of message/rfc822.
        """
        return self._default_type

    def set_default_type(self, ctype):
        """Set the `default' content type.

        ctype should be either "text/plain" or "message/rfc822", although this
        is not enforced.  The default content type is not stored in the
        Content-Type header.
        """
        self._default_type = ctype

    def _get_params_preserve(self, failobj, header):
        # Like get_params() but preserves the quoting of values.  BAW:
        # should this be part of the public interface?
        missing = object()
        value = self.get(header, missing)
        if value is missing:
            return failobj
        params = []
        for p in _parseparam(value):
            try:
                name, val = p.split('=', 1)
                name = name.strip()
                val = val.strip()
            except ValueError:
                # Must have been a bare attribute
                name = p.strip()
                val = ''
            params.append((name, val))
        params = utils.decode_params(params)
        return params

    def get_params(self, failobj=None, header='content-type', unquote=True):
        """Return the message's Content-Type parameters, as a list.

        The elements of the returned list are 2-tuples of key/value pairs, as
        split on the `=' sign.  The left hand side of the `=' is the key,
        while the right hand side is the value.  If there is no `=' sign in
        the parameter the value is the empty string.  The value is as
        described in the get_param() method.

        Optional failobj is the object to return if there is no Content-Type
        header.  Optional header is the header to search instead of
        Content-Type.  If unquote is True, the value is unquoted.
        """
        missing = object()
        params = self._get_params_preserve(missing, header)
        if params is missing:
            return failobj
        if unquote:
            return [(k, _unquotevalue(v)) for k, v in params]
        else:
            return params

    def get_param(self, param, failobj=None, header='content-type',
                  unquote=True):
        """Return the parameter value if found in the Content-Type header.

        Optional failobj is the object to return if there is no Content-Type
        header, or the Content-Type header has no such parameter.  Optional
        header is the header to search instead of Content-Type.

        Parameter keys are always compared case insensitively.  The return
        value can either be a string, or a 3-tuple if the parameter was RFC
        2231 encoded.  When it's a 3-tuple, the elements of the value are of
        the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and
        LANGUAGE can be None, in which case you should consider VALUE to be
        encoded in the us-ascii charset.  You can usually ignore LANGUAGE.
        The parameter value (either the returned string, or the VALUE item in
        the 3-tuple) is always unquoted, unless unquote is set to False.

        If your application doesn't care whether the parameter was RFC 2231
        encoded, it can turn the return value into a string as follows:

            rawparam = msg.get_param('foo')
            param = email.utils.collapse_rfc2231_value(rawparam)

        """
        if header not in self:
            return failobj
        for k, v in self._get_params_preserve(failobj, header):
            if k.lower() == param.lower():
                if unquote:
                    return _unquotevalue(v)
                else:
                    return v
        return failobj

    def set_param(self, param, value, header='Content-Type', requote=True,
                  charset=None, language='', replace=False):
        """Set a parameter in the Content-Type header.

        If the parameter already exists in the header, its value will be
        replaced with the new value.

        If header is Content-Type and has not yet been defined for this
        message, it will be set to "text/plain" and the new parameter and
        value will be appended as per RFC 2045.

        An alternate header can be specified in the header argument, and all
        parameters will be quoted as necessary unless requote is False.

        If charset is specified, the parameter will be encoded according to RFC
        2231.  Optional language specifies the RFC 2231 language, defaulting
        to the empty string.  Both charset and language should be strings.
        """
        if not isinstance(value, tuple) and charset:
            value = (charset, language, value)

        if header not in self and header.lower() == 'content-type':
            ctype = 'text/plain'
        else:
            ctype = self.get(header)
        if not self.get_param(param, header=header):
            if not ctype:
                ctype = _formatparam(param, value, requote)
            else:
                ctype = SEMISPACE.join(
                    [ctype, _formatparam(param, value, requote)])
        else:
            ctype = ''
            for old_param, old_value in self.get_params(header=header,
                                                        unquote=requote):
                append_param = ''
                if old_param.lower() == param.lower():
                    append_param = _formatparam(param, value, requote)
                else:
                    append_param = _formatparam(old_param, old_value, requote)
                if not ctype:
                    ctype = append_param
                else:
                    ctype = SEMISPACE.join([ctype, append_param])
        if ctype != self.get(header):
            if replace:
                self.replace_header(header, ctype)
            else:
                del self[header]
                self[header] = ctype

    def del_param(self, param, header='content-type', requote=True):
        """Remove the given parameter completely from the Content-Type header.

        The header will be re-written in place without the parameter or its
        value. All values will be quoted as necessary unless requote is
        False.  Optional header specifies an alternative to the Content-Type
        header.
        """
        if header not in self:
            return
        new_ctype = ''
        for p, v in self.get_params(header=header, unquote=requote):
            if p.lower() != param.lower():
                if not new_ctype:
                    new_ctype = _formatparam(p, v, requote)
                else:
                    new_ctype = SEMISPACE.join([new_ctype,
                                                _formatparam(p, v, requote)])
        if new_ctype != self.get(header):
            del self[header]
            self[header] = new_ctype

    def set_type(self, type, header='Content-Type', requote=True):
        """Set the main type and subtype for the Content-Type header.

        type must be a string in the form "maintype/subtype", otherwise a
        ValueError is raised.

        This method replaces the Content-Type header, keeping all the
        parameters in place.  If requote is False, this leaves the existing
        header's quoting as is.  Otherwise, the parameters will be quoted (the
        default).

        An alternative header can be specified in the header argument.  When
        the Content-Type header is set, we'll always also add a MIME-Version
        header.
        """
        # BAW: should we be strict?
        if not type.count('/') == 1:
            raise ValueError
        # Set the Content-Type, you get a MIME-Version
        if header.lower() == 'content-type':
            del self['mime-version']
            self['MIME-Version'] = '1.0'
        if header not in self:
            self[header] = type
            return
        params = self.get_params(header=header, unquote=requote)
        del self[header]
        self[header] = type
        # Skip the first param; it's the old type.
        for p, v in params[1:]:
            self.set_param(p, v, header, requote)

    def get_filename(self, failobj=None):
        """Return the filename associated with the payload if present.

        The filename is extracted from the Content-Disposition header's
        `filename' parameter, and it is unquoted.  If that header is missing
        the `filename' parameter, this method falls back to looking for the
        `name' parameter.
        """
        missing = object()
        filename = self.get_param('filename', missing, 'content-disposition')
        if filename is missing:
            filename = self.get_param('name', missing, 'content-type')
        if filename is missing:
            return failobj
        return utils.collapse_rfc2231_value(filename).strip()

    def get_boundary(self, failobj=None):
        """Return the boundary associated with the payload if present.

        The boundary is extracted from the Content-Type header's `boundary'
        parameter, and it is unquoted.
        """
        missing = object()
        boundary = self.get_param('boundary', missing)
        if boundary is missing:
            return failobj
        # RFC 2046 says that boundaries may begin but not end in w/s
        return utils.collapse_rfc2231_value(boundary).rstrip()

    def set_boundary(self, boundary):
        """Set the boundary parameter in Content-Type to 'boundary'.

        This is subtly different than deleting the Content-Type header and
        adding a new one with a new boundary parameter via add_header().  The
        main difference is that using the set_boundary() method preserves the
        order of the Content-Type header in the original message.

        HeaderParseError is raised if the message has no Content-Type header.
        """
        missing = object()
        params = self._get_params_preserve(missing, 'content-type')
        if params is missing:
            # There was no Content-Type header, and we don't know what type
            # to set it to, so raise an exception.
            raise errors.HeaderParseError('No Content-Type header found')
        newparams = []
        foundp = False
        for pk, pv in params:
            if pk.lower() == 'boundary':
                newparams.append(('boundary', '"%s"' % boundary))
                foundp = True
            else:
                newparams.append((pk, pv))
        if not foundp:
            # The original Content-Type header had no boundary attribute.
            # Tack one on the end.  BAW: should we raise an exception
            # instead???
            newparams.append(('boundary', '"%s"' % boundary))
        # Replace the existing Content-Type header with the new value
        newheaders = []
        for h, v in self._headers:
            if h.lower() == 'content-type':
                parts = []
                for k, v in newparams:
                    if v == '':
                        parts.append(k)
                    else:
                        parts.append('%s=%s' % (k, v))
                val = SEMISPACE.join(parts)
                newheaders.append(self.policy.header_store_parse(h, val))

            else:
                newheaders.append((h, v))
        self._headers = newheaders

    def get_content_charset(self, failobj=None):
        """Return the charset parameter of the Content-Type header.

        The returned string is always coerced to lower case.  If there is no
        Content-Type header, or if that header has no charset parameter,
        failobj is returned.
        """
        missing = object()
        charset = self.get_param('charset', missing)
        if charset is missing:
            return failobj
        if isinstance(charset, tuple):
            # RFC 2231 encoded, so decode it, and it better end up as ascii.
            pcharset = charset[0] or 'us-ascii'
            try:
                # LookupError will be raised if the charset isn't known to
                # Python.  UnicodeError will be raised if the encoded text
                # contains a character not in the charset.
                as_bytes = charset[2].encode('raw-unicode-escape')
                charset = str(as_bytes, pcharset)
            except (LookupError, UnicodeError):
                charset = charset[2]
        # charset characters must be in us-ascii range
        try:
            charset.encode('us-ascii')
        except UnicodeError:
            return failobj
        # RFC 2046, $4.1.2 says charsets are not case sensitive
        return charset.lower()

    def get_charsets(self, failobj=None):
        """Return a list containing the charset(s) used in this message.

        The returned list of items describes the Content-Type headers'
        charset parameter for this message and all the subparts in its
        payload.

        Each item will either be a string (the value of the charset parameter
        in the Content-Type header of that part) or the value of the
        'failobj' parameter (defaults to None), if the part does not have a
        main MIME type of "text", or the charset is not defined.

        The list will contain one string for each part of the message, plus
        one for the container message (i.e. self), so that a non-multipart
        message will still return a list of length 1.
        """
        return [part.get_content_charset(failobj) for part in self.walk()]

    def get_content_disposition(self):
        """Return the message's content-disposition if it exists, or None.

        The return values can be either 'inline', 'attachment' or None
        according to the rfc2183.
        """
        value = self.get('content-disposition')
        if value is None:
            return None
        c_d = _splitparam(value)[0].lower()
        return c_d

    # I.e. def walk(self): ...
    from email.iterators import walk


class MIMEPart(Message):

    def __init__(self, policy=None):
        if policy is None:
            from email.policy import default
            policy = default
        Message.__init__(self, policy)

    def is_attachment(self):
        c_d = self.get('content-disposition')
        return False if c_d is None else c_d.content_disposition == 'attachment'

    def _find_body(self, part, preferencelist):
        if part.is_attachment():
            return
        maintype, subtype = part.get_content_type().split('/')
        if maintype == 'text':
            if subtype in preferencelist:
                yield (preferencelist.index(subtype), part)
            return
        if maintype != 'multipart':
            return
        if subtype != 'related':
            for subpart in part.iter_parts():
                yield from self._find_body(subpart, preferencelist)
            return
        if 'related' in preferencelist:
            yield (preferencelist.index('related'), part)
        candidate = None
        start = part.get_param('start')
        if start:
            for subpart in part.iter_parts():
                if subpart['content-id'] == start:
                    candidate = subpart
                    break
        if candidate is None:
            subparts = part.get_payload()
            candidate = subparts[0] if subparts else None
        if candidate is not None:
            yield from self._find_body(candidate, preferencelist)

    def get_body(self, preferencelist=('related', 'html', 'plain')):
        """Return best candidate mime part for display as 'body' of message.

        Do a depth first search, starting with self, looking for the first part
        matching each of the items in preferencelist, and return the part
        corresponding to the first item that has a match, or None if no items
        have a match.  If 'related' is not included in preferencelist, consider
        the root part of any multipart/related encountered as a candidate
        match.  Ignore parts with 'Content-Disposition: attachment'.
        """
        best_prio = len(preferencelist)
        body = None
        for prio, part in self._find_body(self, preferencelist):
            if prio < best_prio:
                best_prio = prio
                body = part
                if prio == 0:
                    break
        return body

    _body_types = {('text', 'plain'),
                   ('text', 'html'),
                   ('multipart', 'related'),
                   ('multipart', 'alternative')}
    def iter_attachments(self):
        """Return an iterator over the non-main parts of a multipart.

        Skip the first of each occurrence of text/plain, text/html,
        multipart/related, or multipart/alternative in the multipart (unless
        they have a 'Content-Disposition: attachment' header) and include all
        remaining subparts in the returned iterator.  When applied to a
        multipart/related, return all parts except the root part.  Return an
        empty iterator when applied to a multipart/alternative or a
        non-multipart.
        """
        maintype, subtype = self.get_content_type().split('/')
        if maintype != 'multipart' or subtype == 'alternative':
            return
        parts = self.get_payload().copy()
        if maintype == 'multipart' and subtype == 'related':
            # For related, we treat everything but the root as an attachment.
            # The root may be indicated by 'start'; if there's no start or we
            # can't find the named start, treat the first subpart as the root.
            start = self.get_param('start')
            if start:
                found = False
                attachments = []
                for part in parts:
                    if part.get('content-id') == start:
                        found = True
                    else:
                        attachments.append(part)
                if found:
                    yield from attachments
                    return
            parts.pop(0)
            yield from parts
            return
        # Otherwise we more or less invert the remaining logic in get_body.
        # This only really works in edge cases (ex: non-text related or
        # alternatives) if the sending agent sets content-disposition.
        seen = []   # Only skip the first example of each candidate type.
        for part in parts:
            maintype, subtype = part.get_content_type().split('/')
            if ((maintype, subtype) in self._body_types and
                    not part.is_attachment() and subtype not in seen):
                seen.append(subtype)
                continue
            yield part

    def iter_parts(self):
        """Return an iterator over all immediate subparts of a multipart.

        Return an empty iterator for a non-multipart.
        """
        if self.get_content_maintype() == 'multipart':
            yield from self.get_payload()

    def get_content(self, *args, content_manager=None, **kw):
        if content_manager is None:
            content_manager = self.policy.content_manager
        return content_manager.get_content(self, *args, **kw)

    def set_content(self, *args, content_manager=None, **kw):
        if content_manager is None:
            content_manager = self.policy.content_manager
        content_manager.set_content(self, *args, **kw)

    def _make_multipart(self, subtype, disallowed_subtypes, boundary):
        if self.get_content_maintype() == 'multipart':
            existing_subtype = self.get_content_subtype()
            disallowed_subtypes = disallowed_subtypes + (subtype,)
            if existing_subtype in disallowed_subtypes:
                raise ValueError("Cannot convert {} to {}".format(
                    existing_subtype, subtype))
        keep_headers = []
        part_headers = []
        for name, value in self._headers:
            if name.lower().startswith('content-'):
                part_headers.append((name, value))
            else:
                keep_headers.append((name, value))
        if part_headers:
            # There is existing content, move it to the first subpart.
            part = type(self)(policy=self.policy)
            part._headers = part_headers
            part._payload = self._payload
            self._payload = [part]
        else:
            self._payload = []
        self._headers = keep_headers
        self['Content-Type'] = 'multipart/' + subtype
        if boundary is not None:
            self.set_param('boundary', boundary)

    def make_related(self, boundary=None):
        self._make_multipart('related', ('alternative', 'mixed'), boundary)

    def make_alternative(self, boundary=None):
        self._make_multipart('alternative', ('mixed',), boundary)

    def make_mixed(self, boundary=None):
        self._make_multipart('mixed', (), boundary)

    def _add_multipart(self, _subtype, *args, _disp=None, **kw):
        if (self.get_content_maintype() != 'multipart' or
                self.get_content_subtype() != _subtype):
            getattr(self, 'make_' + _subtype)()
        part = type(self)(policy=self.policy)
        part.set_content(*args, **kw)
        if _disp and 'content-disposition' not in part:
            part['Content-Disposition'] = _disp
        self.attach(part)

    def add_related(self, *args, **kw):
        self._add_multipart('related', *args, _disp='inline', **kw)

    def add_alternative(self, *args, **kw):
        self._add_multipart('alternative', *args, **kw)

    def add_attachment(self, *args, **kw):
        self._add_multipart('mixed', *args, _disp='attachment', **kw)

    def clear(self):
        self._headers = []
        self._payload = None

    def clear_content(self):
        self._headers = [(n, v) for n, v in self._headers
                         if not n.lower().startswith('content-')]
        self._payload = None


class EmailMessage(MIMEPart):

    def set_content(self, *args, **kw):
        super().set_content(*args, **kw)
        if 'MIME-Version' not in self:
            self['MIME-Version'] = '1.0'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # Copyright (C) 2001-2007 Python Software Foundation
# Author: Barry Warsaw, Thomas Wouters, Anthony Baxter
# Contact: email-sig@python.org

"""A parser of RFC 2822 and MIME email messages."""

__all__ = ['Parser', 'HeaderParser', 'BytesParser', 'BytesHeaderParser',
           'FeedParser', 'BytesFeedParser']

from io import StringIO, TextIOWrapper

from email.feedparser import FeedParser, BytesFeedParser
from email._policybase import compat32



class Parser:
    def __init__(self, _class=None, *, policy=compat32):
        """Parser of RFC 2822 and MIME email messages.

        Creates an in-memory object tree representing the email message, which
        can then be manipulated and turned over to a Generator to return the
        textual representation of the message.

        The string must be formatted as a block of RFC 2822 headers and header
        continuation lines, optionally preceded by a `Unix-from' header.  The
        header block is terminated either by the end of the string or by a
        blank line.

        _class is the class to instantiate for new message objects when they
        must be created.  This class must have a constructor that can take
        zero arguments.  Default is Message.Message.

        The policy keyword specifies a policy object that controls a number of
        aspects of the parser's operation.  The default policy maintains
        backward compatibility.

        """
        self._class = _class
        self.policy = policy

    def parse(self, fp, headersonly=False):
        """Create a message structure from the data in a file.

        Reads all the data from the file and returns the root of the message
        structure.  Optional headersonly is a flag specifying whether to stop
        parsing after reading the headers or not.  The default is False,
        meaning it parses the entire contents of the file.
        """
        feedparser = FeedParser(self._class, policy=self.policy)
        if headersonly:
            feedparser._set_headersonly()
        while True:
            data = fp.read(8192)
            if not data:
                break
            feedparser.feed(data)
        return feedparser.close()

    def parsestr(self, text, headersonly=False):
        """Create a message structure from a string.

        Returns the root of the message structure.  Optional headersonly is a
        flag specifying whether to stop parsing after reading the headers or
        not.  The default is False, meaning it parses the entire contents of
        the file.
        """
        return self.parse(StringIO(text), headersonly=headersonly)



class HeaderParser(Parser):
    def parse(self, fp, headersonly=True):
        return Parser.parse(self, fp, True)

    def parsestr(self, text, headersonly=True):
        return Parser.parsestr(self, text, True)


class BytesParser:

    def __init__(self, *args, **kw):
        """Parser of binary RFC 2822 and MIME email messages.

        Creates an in-memory object tree representing the email message, which
        can then be manipulated and turned over to a Generator to return the
        textual representation of the message.

        The input must be formatted as a block of RFC 2822 headers and header
        continuation lines, optionally preceded by a `Unix-from' header.  The
        header block is terminated either by the end of the input or by a
        blank line.

        _class is the class to instantiate for new message objects when they
        must be created.  This class must have a constructor that can take
        zero arguments.  Default is Message.Message.
        """
        self.parser = Parser(*args, **kw)

    def parse(self, fp, headersonly=False):
        """Create a message structure from the data in a binary file.

        Reads all the data from the file and returns the root of the message
        structure.  Optional headersonly is a flag specifying whether to stop
        parsing after reading the headers or not.  The default is False,
        meaning it parses the entire contents of the file.
        """
        fp = TextIOWrapper(fp, encoding='ascii', errors='surrogateescape')
        try:
            return self.parser.parse(fp, headersonly)
        finally:
            fp.detach()


    def parsebytes(self, text, headersonly=False):
        """Create a message structure from a byte string.

        Returns the root of the message structure.  Optional headersonly is a
        flag specifying whether to stop parsing after reading the headers or
        not.  The default is False, meaning it parses the entire contents of
        the file.
        """
        text = text.decode('ASCII', errors='surrogateescape')
        return self.parser.parsestr(text, headersonly)


class BytesHeaderParser(BytesParser):
    def parse(self, fp, headersonly=True):
        return BytesParser.parse(self, fp, headersonly=True)

    def parsebytes(self, text, headersonly=True):
        return BytesParser.parsebytes(self, text, headersonly=True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """This will be the home for the policy that hooks in the new
code that adds all the email6 features.
"""

import re
from email._policybase import Policy, Compat32, compat32, _extend_docstrings
from email.utils import _has_surrogates
from email.headerregistry import HeaderRegistry as HeaderRegistry
from email.contentmanager import raw_data_manager

__all__ = [
    'Compat32',
    'compat32',
    'Policy',
    'EmailPolicy',
    'default',
    'strict',
    'SMTP',
    'HTTP',
    ]

linesep_splitter = re.compile(r'\n|\r')

@_extend_docstrings
class EmailPolicy(Policy):

    """+
    PROVISIONAL

    The API extensions enabled by this policy are currently provisional.
    Refer to the documentation for details.

    This policy adds new header parsing and folding algorithms.  Instead of
    simple strings, headers are custom objects with custom attributes
    depending on the type of the field.  The folding algorithm fully
    implements RFCs 2047 and 5322.

    In addition to the settable attributes listed above that apply to
    all Policies, this policy adds the following additional attributes:

    utf8                -- if False (the default) message headers will be
                           serialized as ASCII, using encoded words to encode
                           any non-ASCII characters in the source strings.  If
                           True, the message headers will be serialized using
                           utf8 and will not contain encoded words (see RFC
                           6532 for more on this serialization format).

    refold_source       -- if the value for a header in the Message object
                           came from the parsing of some source, this attribute
                           indicates whether or not a generator should refold
                           that value when transforming the message back into
                           stream form.  The possible values are:

                           none  -- all source values use original folding
                           long  -- source values that have any line that is
                                    longer than max_line_length will be
                                    refolded
                           all  -- all values are refolded.

                           The default is 'long'.

    header_factory      -- a callable that takes two arguments, 'name' and
                           'value', where 'name' is a header field name and
                           'value' is an unfolded header field value, and
                           returns a string-like object that represents that
                           header.  A default header_factory is provided that
                           understands some of the RFC5322 header field types.
                           (Currently address fields and date fields have
                           special treatment, while all other fields are
                           treated as unstructured.  This list will be
                           completed before the extension is marked stable.)

    content_manager     -- an object with at least two methods: get_content
                           and set_content.  When the get_content or
                           set_content method of a Message object is called,
                           it calls the corresponding method of this object,
                           passing it the message object as its first argument,
                           and any arguments or keywords that were passed to
                           it as additional arguments.  The default
                           content_manager is
                           :data:`~email.contentmanager.raw_data_manager`.

    """

    utf8 = False
    refold_source = 'long'
    header_factory = HeaderRegistry()
    content_manager = raw_data_manager

    def __init__(self, **kw):
        # Ensure that each new instance gets a unique header factory
        # (as opposed to clones, which share the factory).
        if 'header_factory' not in kw:
            object.__setattr__(self, 'header_factory', HeaderRegistry())
        super().__init__(**kw)

    def header_max_count(self, name):
        """+
        The implementation for this class returns the max_count attribute from
        the specialized header class that would be used to construct a header
        of type 'name'.
        """
        return self.header_factory[name].max_count

    # The logic of the next three methods is chosen such that it is possible to
    # switch a Message object between a Compat32 policy and a policy derived
    # from this class and have the results stay consistent.  This allows a
    # Message object constructed with this policy to be passed to a library
    # that only handles Compat32 objects, or to receive such an object and
    # convert it to use the newer style by just changing its policy.  It is
    # also chosen because it postpones the relatively expensive full rfc5322
    # parse until as late as possible when parsing from source, since in many
    # applications only a few headers will actually be inspected.

    def header_source_parse(self, sourcelines):
        """+
        The name is parsed as everything up to the ':' and returned unmodified.
        The value is determined by stripping leading whitespace off the
        remainder of the first line, joining all subsequent lines together, and
        stripping any trailing carriage return or linefeed characters.  (This
        is the same as Compat32).

        """
        name, value = sourcelines[0].split(':', 1)
        value = value.lstrip(' \t') + ''.join(sourcelines[1:])
        return (name, value.rstrip('\r\n'))

    def header_store_parse(self, name, value):
        """+
        The name is returned unchanged.  If the input value has a 'name'
        attribute and it matches the name ignoring case, the value is returned
        unchanged.  Otherwise the name and value are passed to header_factory
        method, and the resulting custom header object is returned as the
        value.  In this case a ValueError is raised if the input value contains
        CR or LF characters.

        """
        if hasattr(value, 'name') and value.name.lower() == name.lower():
            return (name, value)
        if isinstance(value, str) and len(value.splitlines())>1:
            # XXX this error message isn't quite right when we use splitlines
            # (see issue 22233), but I'm not sure what should happen here.
            raise ValueError("Header values may not contain linefeed "
                             "or carriage return characters")
        return (name, self.header_factory(name, value))

    def header_fetch_parse(self, name, value):
        """+
        If the value has a 'name' attribute, it is returned to unmodified.
        Otherwise the name and the value with any linesep characters removed
        are passed to the header_factory method, and the resulting custom
        header object is returned.  Any surrogateescaped bytes get turned
        into the unicode unknown-character glyph.

        """
        if hasattr(value, 'name'):
            return value
        # We can't use splitlines here because it splits on more than \r and \n.
        value = ''.join(linesep_splitter.split(value))
        return self.header_factory(name, value)

    def fold(self, name, value):
        """+
        Header folding is controlled by the refold_source policy setting.  A
        value is considered to be a 'source value' if and only if it does not
        have a 'name' attribute (having a 'name' attribute means it is a header
        object of some sort).  If a source value needs to be refolded according
        to the policy, it is converted into a custom header object by passing
        the name and the value with any linesep characters removed to the
        header_factory method.  Folding of a custom header object is done by
        calling its fold method with the current policy.

        Source values are split into lines using splitlines.  If the value is
        not to be refolded, the lines are rejoined using the linesep from the
        policy and returned.  The exception is lines containing non-ascii
        binary data.  In that case the value is refolded regardless of the
        refold_source setting, which causes the binary data to be CTE encoded
        using the unknown-8bit charset.

        """
        return self._fold(name, value, refold_binary=True)

    def fold_binary(self, name, value):
        """+
        The same as fold if cte_type is 7bit, except that the returned value is
        bytes.

        If cte_type is 8bit, non-ASCII binary data is converted back into
        bytes.  Headers with binary data are not refolded, regardless of the
        refold_header setting, since there is no way to know whether the binary
        data consists of single byte characters or multibyte characters.

        If utf8 is true, headers are encoded to utf8, otherwise to ascii with
        non-ASCII unicode rendered as encoded words.

        """
        folded = self._fold(name, value, refold_binary=self.cte_type=='7bit')
        charset = 'utf8' if self.utf8 else 'ascii'
        return folded.encode(charset, 'surrogateescape')

    def _fold(self, name, value, refold_binary=False):
        if hasattr(value, 'name'):
            return value.fold(policy=self)
        maxlen = self.max_line_length if self.max_line_length else float('inf')
        lines = value.splitlines()
        refold = (self.refold_source == 'all' or
                  self.refold_source == 'long' and
                    (lines and len(lines[0])+len(name)+2 > maxlen or
                     any(len(x) > maxlen for x in lines[1:])))
        if refold or refold_binary and _has_surrogates(value):
            return self.header_factory(name, ''.join(lines)).fold(policy=self)
        return name + ': ' + self.linesep.join(lines) + self.linesep


default = EmailPolicy()
# Make the default policy use the class default header_factory
del default.header_factory
strict = default.clone(raise_on_defect=True)
SMTP = default.clone(linesep='\r\n')
HTTP = default.clone(linesep='\r\n', max_line_length=None)
SMTPUTF8 = SMTP.clone(utf8=True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Copyright (C) 2001-2006 Python Software Foundation
# Author: Ben Gertzfield
# Contact: email-sig@python.org

"""Quoted-printable content transfer encoding per RFCs 2045-2047.

This module handles the content transfer encoding method defined in RFC 2045
to encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to
safely encode text that is in a character set similar to the 7-bit US ASCII
character set, but that includes some 8-bit characters that are normally not
allowed in email bodies or headers.

Quoted-printable is very space-inefficient for encoding binary files; use the
email.base64mime module for that instead.

This module provides an interface to encode and decode both headers and bodies
with quoted-printable encoding.

RFC 2045 defines a method for including character set information in an
`encoded-word' in a header.  This method is commonly used for 8-bit real names
in To:/From:/Cc: etc. fields, as well as Subject: lines.

This module does not do the line wrapping or end-of-line character
conversion necessary for proper internationalized headers; it only
does dumb encoding and decoding.  To deal with the various line
wrapping issues, use the email.header module.
"""

__all__ = [
    'body_decode',
    'body_encode',
    'body_length',
    'decode',
    'decodestring',
    'header_decode',
    'header_encode',
    'header_length',
    'quote',
    'unquote',
    ]

import re

from string import ascii_letters, digits, hexdigits

CRLF = '\r\n'
NL = '\n'
EMPTYSTRING = ''

# Build a mapping of octets to the expansion of that octet.  Since we're only
# going to have 256 of these things, this isn't terribly inefficient
# space-wise.  Remember that headers and bodies have different sets of safe
# characters.  Initialize both maps with the full expansion, and then override
# the safe bytes with the more compact form.
_QUOPRI_MAP = ['=%02X' % c for c in range(256)]
_QUOPRI_HEADER_MAP = _QUOPRI_MAP[:]
_QUOPRI_BODY_MAP = _QUOPRI_MAP[:]

# Safe header bytes which need no encoding.
for c in b'-!*+/' + ascii_letters.encode('ascii') + digits.encode('ascii'):
    _QUOPRI_HEADER_MAP[c] = chr(c)
# Headers have one other special encoding; spaces become underscores.
_QUOPRI_HEADER_MAP[ord(' ')] = '_'

# Safe body bytes which need no encoding.
for c in (b' !"#$%&\'()*+,-./0123456789:;<>'
          b'?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`'
          b'abcdefghijklmnopqrstuvwxyz{|}~\t'):
    _QUOPRI_BODY_MAP[c] = chr(c)



# Helpers
def header_check(octet):
    """Return True if the octet should be escaped with header quopri."""
    return chr(octet) != _QUOPRI_HEADER_MAP[octet]


def body_check(octet):
    """Return True if the octet should be escaped with body quopri."""
    return chr(octet) != _QUOPRI_BODY_MAP[octet]


def header_length(bytearray):
    """Return a header quoted-printable encoding length.

    Note that this does not include any RFC 2047 chrome added by
    `header_encode()`.

    :param bytearray: An array of bytes (a.k.a. octets).
    :return: The length in bytes of the byte array when it is encoded with
        quoted-printable for headers.
    """
    return sum(len(_QUOPRI_HEADER_MAP[octet]) for octet in bytearray)


def body_length(bytearray):
    """Return a body quoted-printable encoding length.

    :param bytearray: An array of bytes (a.k.a. octets).
    :return: The length in bytes of the byte array when it is encoded with
        quoted-printable for bodies.
    """
    return sum(len(_QUOPRI_BODY_MAP[octet]) for octet in bytearray)


def _max_append(L, s, maxlen, extra=''):
    if not isinstance(s, str):
        s = chr(s)
    if not L:
        L.append(s.lstrip())
    elif len(L[-1]) + len(s) <= maxlen:
        L[-1] += extra + s
    else:
        L.append(s.lstrip())


def unquote(s):
    """Turn a string in the form =AB to the ASCII character with value 0xab"""
    return chr(int(s[1:3], 16))


def quote(c):
    return _QUOPRI_MAP[ord(c)]


def header_encode(header_bytes, charset='iso-8859-1'):
    """Encode a single header line with quoted-printable (like) encoding.

    Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but
    used specifically for email header fields to allow charsets with mostly 7
    bit characters (and some 8 bit) to remain more or less readable in non-RFC
    2045 aware mail clients.

    charset names the character set to use in the RFC 2046 header.  It
    defaults to iso-8859-1.
    """
    # Return empty headers as an empty string.
    if not header_bytes:
        return ''
    # Iterate over every byte, encoding if necessary.
    encoded = header_bytes.decode('latin1').translate(_QUOPRI_HEADER_MAP)
    # Now add the RFC chrome to each encoded chunk and glue the chunks
    # together.
    return '=?%s?q?%s?=' % (charset, encoded)


_QUOPRI_BODY_ENCODE_MAP = _QUOPRI_BODY_MAP[:]
for c in b'\r\n':
    _QUOPRI_BODY_ENCODE_MAP[c] = chr(c)

def body_encode(body, maxlinelen=76, eol=NL):
    """Encode with quoted-printable, wrapping at maxlinelen characters.

    Each line of encoded text will end with eol, which defaults to "\\n".  Set
    this to "\\r\\n" if you will be using the result of this function directly
    in an email.

    Each line will be wrapped at, at most, maxlinelen characters before the
    eol string (maxlinelen defaults to 76 characters, the maximum value
    permitted by RFC 2045).  Long lines will have the 'soft line break'
    quoted-printable character "=" appended to them, so the decoded text will
    be identical to the original text.

    The minimum maxlinelen is 4 to have room for a quoted character ("=XX")
    followed by a soft line break.  Smaller values will generate a
    ValueError.

    """

    if maxlinelen < 4:
        raise ValueError("maxlinelen must be at least 4")
    if not body:
        return body

    # quote speacial characters
    body = body.translate(_QUOPRI_BODY_ENCODE_MAP)

    soft_break = '=' + eol
    # leave space for the '=' at the end of a line
    maxlinelen1 = maxlinelen - 1

    encoded_body = []
    append = encoded_body.append

    for line in body.splitlines():
        # break up the line into pieces no longer than maxlinelen - 1
        start = 0
        laststart = len(line) - 1 - maxlinelen
        while start <= laststart:
            stop = start + maxlinelen1
            # make sure we don't break up an escape sequence
            if line[stop - 2] == '=':
                append(line[start:stop - 1])
                start = stop - 2
            elif line[stop - 1] == '=':
                append(line[start:stop])
                start = stop - 1
            else:
                append(line[start:stop] + '=')
                start = stop

        # handle rest of line, special case if line ends in whitespace
        if line and line[-1] in ' \t':
            room = start - laststart
            if room >= 3:
                # It's a whitespace character at end-of-line, and we have room
                # for the three-character quoted encoding.
                q = quote(line[-1])
            elif room == 2:
                # There's room for the whitespace character and a soft break.
                q = line[-1] + soft_break
            else:
                # There's room only for a soft break.  The quoted whitespace
                # will be the only content on the subsequent line.
                q = soft_break + quote(line[-1])
            append(line[start:-1] + q)
        else:
            append(line[start:])

    # add back final newline if present
    if body[-1] in CRLF:
        append('')

    return eol.join(encoded_body)



# BAW: I'm not sure if the intent was for the signature of this function to be
# the same as base64MIME.decode() or not...
def decode(encoded, eol=NL):
    """Decode a quoted-printable string.

    Lines are separated with eol, which defaults to \\n.
    """
    if not encoded:
        return encoded
    # BAW: see comment in encode() above.  Again, we're building up the
    # decoded string with string concatenation, which could be done much more
    # efficiently.
    decoded = ''

    for line in encoded.splitlines():
        line = line.rstrip()
        if not line:
            decoded += eol
            continue

        i = 0
        n = len(line)
        while i < n:
            c = line[i]
            if c != '=':
                decoded += c
                i += 1
            # Otherwise, c == "=".  Are we at the end of the line?  If so, add
            # a soft line break.
            elif i+1 == n:
                i += 1
                continue
            # Decode if in form =AB
            elif i+2 < n and line[i+1] in hexdigits and line[i+2] in hexdigits:
                decoded += unquote(line[i:i+3])
                i += 3
            # Otherwise, not in form =AB, pass literally
            else:
                decoded += c
                i += 1

            if i == n:
                decoded += eol
    # Special case if original string did not end with eol
    if encoded[-1] not in '\r\n' and decoded.endswith(eol):
        decoded = decoded[:-1]
    return decoded


# For convenience and backwards compatibility w/ standard base64 module
body_decode = decode
decodestring = decode



def _unquote_match(match):
    """Turn a match in the form =AB to the ASCII character with value 0xab"""
    s = match.group(0)
    return unquote(s)


# Header decoding is done a bit differently
def header_decode(s):
    """Decode a string encoded with RFC 2045 MIME header `Q' encoding.

    This function does not parse a full MIME header value encoded with
    quoted-printable (like =?iso-8859-1?q?Hello_World?=) -- please use
    the high level email.header class for that functionality.
    """
    s = s.replace('_', ' ')
    return re.sub(r'=[a-fA-F0-9]{2}', _unquote_match, s, flags=re.ASCII)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
[                 @   ss   d  Z  d d d d d d d d d	 d
 d d d d d d d g Z d d   Z d d   Z d d
   Z d d   Z d S)z?A package for parsing, handling, and generating email messages.Z
base64mimecharsetZencoderserrorsZ
feedparser	generatorheaderZ	iteratorsmessagemessage_from_filemessage_from_binary_filemessage_from_stringmessage_from_bytesZmimeparserZ
quoprimimeZutilsc             O   s&   d d l  m } | | |   j |   S)zvParse a string into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
        )Parser)email.parserr   Zparsestr)sargskwsr    r   $/usr/lib/python3.5/email/__init__.pyr       s    c             O   s&   d d l  m } | | |   j |   S)z|Parse a bytes string into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    r   )BytesParser)r   r   Z
parsebytes)r   r   r   r   r   r   r   r	   (   s    c             O   s&   d d l  m } | | |   j |   S)zRead a file and parse its contents into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    r   )r   )r   r   parse)fpr   r   r   r   r   r   r   0   s    c             O   s&   d d l  m } | | |   j |   S)zRead a binary file and parse its contents into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    r   )r   )r   r   r   )r   r   r   r   r   r   r   r   8   s    N)__doc____all__r   r	   r   r   r   r   r   r   <module>   s*   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
[                 @   s   d  Z  d d d d d d g Z d d l m Z d d	 l m Z m Z d
 Z d Z d Z	 d Z
 d d   Z d d d  Z d e d d  Z d d   Z e Z e Z d S)a  Base64 content transfer encoding per RFCs 2045-2047.

This module handles the content transfer encoding method defined in RFC 2045
to encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit
characters encoding known as Base64.

It is used in the MIME standards for email to attach images, audio, and text
using some 8-bit character sets to messages.

This module provides an interface to encode and decode both headers and bodies
with Base64 encoding.

RFC 2045 defines a method for including character set information in an
`encoded-word' in a header.  This method is commonly used for 8-bit real names
in To:, From:, Cc:, etc. fields, as well as Subject: lines.

This module does not do the line wrapping or end-of-line character conversion
necessary for proper internationalized headers; it only does dumb encoding and
decoding.  To deal with the various line wrapping issues, use the email.header
module.
body_decodebody_encodedecodedecodestringheader_encodeheader_length    )	b64encode)
b2a_base64
a2b_base64z

    c             C   s9   t  t |   d  \ } } | d } | r5 | d 7} | S)z6Return the length of s when it is encoded with base64.      )divmodlen)	bytearrayZgroups_of_3Zleftovern r   &/usr/lib/python3.5/email/base64mime.pyr   2   s
    

z
iso-8859-1c             C   sK   |  s
 d St  |  t  r( |  j |  }  t |   j d  } d | | f S)zEncode a single header line with Base64 encoding in a given charset.

    charset names the character set to use to encode the header.  It defaults
    to iso-8859-1.  Base64 encoding is defined in RFC 2045.
    r   asciiz=?%s?b?%s?=)
isinstancestrencoder   r   )Zheader_bytescharsetZencodedr   r   r   r   =   s    L   c             C   s   |  s
 |  Sg  } | d d } x t  d t |   |  D]e } t |  | | |   j d  } | j t  r | t k r | d d  | } | j |  q7 Wt j |  S)a1  Encode a string with base64.

    Each line will be wrapped at, at most, maxlinelen characters (defaults to
    76 characters).

    Each line of encoded text will end with eol, which defaults to "\n".  Set
    this to "\r\n" if you will be using the result of this function directly
    in an email.
    r   r   r   r   N   )	ranger   r	   r   endswithNLappendEMPTYSTRINGjoin)sZ
maxlinelenZeolZencvecZmax_unencodediencr   r   r   r   L   s    
#c             C   s=   |  s t    St |  t  r/ t |  j d   St |   Sd S)zDecode a raw base64 string, returning a bytes object.

    This function does not parse a full MIME header value encoded with
    base64 (like =?iso-8859-1?b?bmloISBuaWgh?=) -- please use the high
    level email.header class for that functionality.
    zraw-unicode-escapeN)bytesr   r   r
   r   )stringr   r   r   r   f   s
    N)__doc____all__base64r   Zbinasciir	   r
   ZCRLFr    r"   ZMISC_LENr   r   r   r   r   r   r   r   r   r   <module>   s$   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright (C) 2001-2010 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Miscellaneous utilities."""

__all__ = [
    'collapse_rfc2231_value',
    'decode_params',
    'decode_rfc2231',
    'encode_rfc2231',
    'formataddr',
    'formatdate',
    'format_datetime',
    'getaddresses',
    'make_msgid',
    'mktime_tz',
    'parseaddr',
    'parsedate',
    'parsedate_tz',
    'parsedate_to_datetime',
    'unquote',
    ]

import os
import re
import time
import random
import socket
import datetime
import urllib.parse

from email._parseaddr import quote
from email._parseaddr import AddressList as _AddressList
from email._parseaddr import mktime_tz

from email._parseaddr import parsedate, parsedate_tz, _parsedate_tz

# Intrapackage imports
from email.charset import Charset

COMMASPACE = ', '
EMPTYSTRING = ''
UEMPTYSTRING = ''
CRLF = '\r\n'
TICK = "'"

specialsre = re.compile(r'[][\\()<>@,:;".]')
escapesre = re.compile(r'[\\"]')

def _has_surrogates(s):
    """Return True if s contains surrogate-escaped binary data."""
    # This check is based on the fact that unless there are surrogates, utf8
    # (Python's default encoding) can encode any string.  This is the fastest
    # way to check for surrogates, see issue 11454 for timings.
    try:
        s.encode()
        return False
    except UnicodeEncodeError:
        return True

# How to deal with a string containing bytes before handing it to the
# application through the 'normal' interface.
def _sanitize(string):
    # Turn any escaped bytes into unicode 'unknown' char.  If the escaped
    # bytes happen to be utf-8 they will instead get decoded, even if they
    # were invalid in the charset the source was supposed to be in.  This
    # seems like it is not a bad thing; a defect was still registered.
    original_bytes = string.encode('utf-8', 'surrogateescape')
    return original_bytes.decode('utf-8', 'replace')



# Helpers

def formataddr(pair, charset='utf-8'):
    """The inverse of parseaddr(), this takes a 2-tuple of the form
    (realname, email_address) and returns the string value suitable
    for an RFC 2822 From, To or Cc header.

    If the first element of pair is false, then the second element is
    returned unmodified.

    Optional charset if given is the character set that is used to encode
    realname in case realname is not ASCII safe.  Can be an instance of str or
    a Charset-like object which has a header_encode method.  Default is
    'utf-8'.
    """
    name, address = pair
    # The address MUST (per RFC) be ascii, so raise a UnicodeError if it isn't.
    address.encode('ascii')
    if name:
        try:
            name.encode('ascii')
        except UnicodeEncodeError:
            if isinstance(charset, str):
                charset = Charset(charset)
            encoded_name = charset.header_encode(name)
            return "%s <%s>" % (encoded_name, address)
        else:
            quotes = ''
            if specialsre.search(name):
                quotes = '"'
            name = escapesre.sub(r'\\\g<0>', name)
            return '%s%s%s <%s>' % (quotes, name, quotes, address)
    return address



def getaddresses(fieldvalues):
    """Return a list of (REALNAME, EMAIL) for each fieldvalue."""
    all = COMMASPACE.join(fieldvalues)
    a = _AddressList(all)
    return a.addresslist



ecre = re.compile(r'''
  =\?                   # literal =?
  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset
  \?                    # literal ?
  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive
  \?                    # literal ?
  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom
  \?=                   # literal ?=
  ''', re.VERBOSE | re.IGNORECASE)


def _format_timetuple_and_zone(timetuple, zone):
    return '%s, %02d %s %04d %02d:%02d:%02d %s' % (
        ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][timetuple[6]],
        timetuple[2],
        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][timetuple[1] - 1],
        timetuple[0], timetuple[3], timetuple[4], timetuple[5],
        zone)

def formatdate(timeval=None, localtime=False, usegmt=False):
    """Returns a date string as specified by RFC 2822, e.g.:

    Fri, 09 Nov 2001 01:08:47 -0000

    Optional timeval if given is a floating point time value as accepted by
    gmtime() and localtime(), otherwise the current time is used.

    Optional localtime is a flag that when True, interprets timeval, and
    returns a date relative to the local timezone instead of UTC, properly
    taking daylight savings time into account.

    Optional argument usegmt means that the timezone is written out as
    an ascii string, not numeric one (so "GMT" instead of "+0000"). This
    is needed for HTTP, and is only used when localtime==False.
    """
    # Note: we cannot use strftime() because that honors the locale and RFC
    # 2822 requires that day and month names be the English abbreviations.
    if timeval is None:
        timeval = time.time()
    if localtime or usegmt:
        dt = datetime.datetime.fromtimestamp(timeval, datetime.timezone.utc)
    else:
        dt = datetime.datetime.utcfromtimestamp(timeval)
    if localtime:
        dt = dt.astimezone()
        usegmt = False
    return format_datetime(dt, usegmt)

def format_datetime(dt, usegmt=False):
    """Turn a datetime into a date string as specified in RFC 2822.

    If usegmt is True, dt must be an aware datetime with an offset of zero.  In
    this case 'GMT' will be rendered instead of the normal +0000 required by
    RFC2822.  This is to support HTTP headers involving date stamps.
    """
    now = dt.timetuple()
    if usegmt:
        if dt.tzinfo is None or dt.tzinfo != datetime.timezone.utc:
            raise ValueError("usegmt option requires a UTC datetime")
        zone = 'GMT'
    elif dt.tzinfo is None:
        zone = '-0000'
    else:
        zone = dt.strftime("%z")
    return _format_timetuple_and_zone(now, zone)


def make_msgid(idstring=None, domain=None):
    """Returns a string suitable for RFC 2822 compliant Message-ID, e.g:

    <142480216486.20800.16526388040877946887@nightshade.la.mastaler.com>

    Optional idstring if given is a string used to strengthen the
    uniqueness of the message id.  Optional domain if given provides the
    portion of the message id after the '@'.  It defaults to the locally
    defined hostname.
    """
    timeval = int(time.time()*100)
    pid = os.getpid()
    randint = random.getrandbits(64)
    if idstring is None:
        idstring = ''
    else:
        idstring = '.' + idstring
    if domain is None:
        domain = socket.getfqdn()
    msgid = '<%d.%d.%d%s@%s>' % (timeval, pid, randint, idstring, domain)
    return msgid


def parsedate_to_datetime(data):
    *dtuple, tz = _parsedate_tz(data)
    if tz is None:
        return datetime.datetime(*dtuple[:6])
    return datetime.datetime(*dtuple[:6],
            tzinfo=datetime.timezone(datetime.timedelta(seconds=tz)))


def parseaddr(addr):
    addrs = _AddressList(addr).addresslist
    if not addrs:
        return '', ''
    return addrs[0]


# rfc822.unquote() doesn't properly de-backslash-ify in Python pre-2.3.
def unquote(str):
    """Remove quotes from a string."""
    if len(str) > 1:
        if str.startswith('"') and str.endswith('"'):
            return str[1:-1].replace('\\\\', '\\').replace('\\"', '"')
        if str.startswith('<') and str.endswith('>'):
            return str[1:-1]
    return str



# RFC2231-related functions - parameter encoding and decoding
def decode_rfc2231(s):
    """Decode string according to RFC 2231"""
    parts = s.split(TICK, 2)
    if len(parts) <= 2:
        return None, None, s
    return parts


def encode_rfc2231(s, charset=None, language=None):
    """Encode string according to RFC 2231.

    If neither charset nor language is given, then s is returned as-is.  If
    charset is given but not language, the string is encoded using the empty
    string for language.
    """
    s = urllib.parse.quote(s, safe='', encoding=charset or 'ascii')
    if charset is None and language is None:
        return s
    if language is None:
        language = ''
    return "%s'%s'%s" % (charset, language, s)


rfc2231_continuation = re.compile(r'^(?P<name>\w+)\*((?P<num>[0-9]+)\*?)?$',
    re.ASCII)

def decode_params(params):
    """Decode parameters list according to RFC 2231.

    params is a sequence of 2-tuples containing (param name, string value).
    """
    # Copy params so we don't mess with the original
    params = params[:]
    new_params = []
    # Map parameter's name to a list of continuations.  The values are a
    # 3-tuple of the continuation number, the string value, and a flag
    # specifying whether a particular segment is %-encoded.
    rfc2231_params = {}
    name, value = params.pop(0)
    new_params.append((name, value))
    while params:
        name, value = params.pop(0)
        if name.endswith('*'):
            encoded = True
        else:
            encoded = False
        value = unquote(value)
        mo = rfc2231_continuation.match(name)
        if mo:
            name, num = mo.group('name', 'num')
            if num is not None:
                num = int(num)
            rfc2231_params.setdefault(name, []).append((num, value, encoded))
        else:
            new_params.append((name, '"%s"' % quote(value)))
    if rfc2231_params:
        for name, continuations in rfc2231_params.items():
            value = []
            extended = False
            # Sort by number
            continuations.sort()
            # And now append all values in numerical order, converting
            # %-encodings for the encoded segments.  If any of the
            # continuation names ends in a *, then the entire string, after
            # decoding segments and concatenating, must have the charset and
            # language specifiers at the beginning of the string.
            for num, s, encoded in continuations:
                if encoded:
                    # Decode as "latin-1", so the characters in s directly
                    # represent the percent-encoded octet values.
                    # collapse_rfc2231_value treats this as an octet sequence.
                    s = urllib.parse.unquote(s, encoding="latin-1")
                    extended = True
                value.append(s)
            value = quote(EMPTYSTRING.join(value))
            if extended:
                charset, language, value = decode_rfc2231(value)
                new_params.append((name, (charset, language, '"%s"' % value)))
            else:
                new_params.append((name, '"%s"' % value))
    return new_params

def collapse_rfc2231_value(value, errors='replace',
                           fallback_charset='us-ascii'):
    if not isinstance(value, tuple) or len(value) != 3:
        return unquote(value)
    # While value comes to us as a unicode string, we need it to be a bytes
    # object.  We do not want bytes() normal utf-8 decoder, we want a straight
    # interpretation of the string as character bytes.
    charset, language, text = value
    if charset is None:
        # Issue 17369: if charset/lang is None, decode_rfc2231 couldn't parse
        # the value, so use the fallback_charset.
        charset = fallback_charset
    rawbytes = bytes(text, 'raw-unicode-escape')
    try:
        return str(rawbytes, charset, errors)
    except LookupError:
        # charset is not a known codec.
        return unquote(text)


#
# datetime doesn't provide a localtime function yet, so provide one.  Code
# adapted from the patch in issue 9527.  This may not be perfect, but it is
# better than not having it.
#

def localtime(dt=None, isdst=-1):
    """Return local time as an aware datetime object.

    If called without arguments, return current time.  Otherwise *dt*
    argument should be a datetime instance, and it is converted to the
    local time zone according to the system time zone database.  If *dt* is
    naive (that is, dt.tzinfo is None), it is assumed to be in local time.
    In this case, a positive or zero value for *isdst* causes localtime to
    presume initially that summer time (for example, Daylight Saving Time)
    is or is not (respectively) in effect for the specified time.  A
    negative value for *isdst* causes the localtime() function to attempt
    to divine whether summer time is in effect for the specified time.

    """
    if dt is None:
        return datetime.datetime.now(datetime.timezone.utc).astimezone()
    if dt.tzinfo is not None:
        return dt.astimezone()
    # We have a naive datetime.  Convert to a (localtime) timetuple and pass to
    # system mktime together with the isdst hint.  System mktime will return
    # seconds since epoch.
    tm = dt.timetuple()[:-1] + (isdst,)
    seconds = time.mktime(tm)
    localtm = time.localtime(seconds)
    try:
        delta = datetime.timedelta(seconds=localtm.tm_gmtoff)
        tz = datetime.timezone(delta, localtm.tm_zone)
    except AttributeError:
        # Compute UTC offset and compare with the value implied by tm_isdst.
        # If the values match, use the zone name implied by tm_isdst.
        delta = dt - datetime.datetime(*time.gmtime(seconds)[:6])
        dst = time.daylight and localtm.tm_isdst > 0
        gmtoff = -(time.altzone if dst else time.timezone)
        if delta == datetime.timedelta(seconds=gmtoff):
            tz = datetime.timezone(delta, time.tzname[dst])
        else:
            tz = datetime.timezone(delta)
    return dt.replace(tzinfo=tz)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
[                 @   sp  d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z m Z d d l m	 Z	 d d d d d	 d
 d d g Z
 e j e j d  j d d    Z d d   Z Gd d   d e  Z e   Z d e e d  <d d   Z d d	   Z d d   Z d d   Z d d
   Z d e d e i Z d d   Z d e d e i Z d e d e i Z d d d d d  Z d S) z Routines for manipulating RFC2047 encoded words.

This is currently a package-private API, but will be considered for promotion
to a public API if there is demand.

    N)ascii_lettersdigits)errorsdecode_qencode_qdecode_bencode_blen_qlen_bdecodeencodes   =([a-fA-F0-9]{2})c             C   s   t  t |  j d  d  g  S)N      )bytesintgroup)m r   */usr/lib/python3.5/email/_encoded_words.py<lambda>A   s    r   c             C   s"   |  j  d d  }  t |   g  f S)N   _    )replace_q_byte_subber)encodedr   r   r   r   C   s    c               @   s<   e  Z d  Z d e j d  e j d  Z d d   Z d S)	_QByteMaps   -!*+/asciic             C   s=   | |  j  k r" t |  |  | <n d j |  |  | <|  | S)Nz={:02X})safechrformat)selfkeyr   r   r   __missing__M   s    z_QByteMap.__missing__N)__name__
__module____qualname__r   r   r   r   r"   r   r   r   r   r   I   s    r   _ c             C   s   d j  d d   |  D  S)N c             s   s   |  ] } t  | Vq d  S)N)_q_byte_map).0xr   r   r   	<genexpr>Z   s    zencode_q.<locals>.<genexpr>)join)bstringr   r   r   r   Y   s    c             C   s   t  d d   |  D  S)Nc             s   s   |  ] } t  t |  Vq d  S)N)lenr)   )r*   r+   r   r   r   r,   ]   s    zlen_q.<locals>.<genexpr>)sum)r.   r   r   r   r	   \   s    c             C   s  g  } t  |   d } | rJ | j t j    |  d d  d |  } n |  } y t j | d d | f SWn t j k
 rt j   g } xv d D]b } y% t j |  d	 | d d
 | f SWq t j k
 r | d k r | j t j    Yq Xq Wt	 d   Yn Xd  S)N   s   ===ZvalidateTr   r            =Fzunexpected binascii.Error)r   r   r2   r3   )
r/   appendr   ZInvalidBase64PaddingDefectbase64Z	b64decodebinasciiErrorZInvalidBase64CharactersDefectAssertionError)r   defectsZpad_errZpadded_encodedir   r   r   r   d   s"    %c             C   s   t  j |   j d  S)Nr   )r6   Z	b64encoder   )r.   r   r   r   r   ~   s    c             C   s3   t  t |   d  \ } } | d | r. d n d S)Nr3   r1   r   )divmodr/   )r.   Zgroups_of_3Zleftoverr   r   r   r
      s    qbc       	      C   s'  |  j  d  \ } } } } } | j d  \ } } } | j   } | j d d  } t | |  \ } } y | j |  } Wn t k
 r | j t j	 d j
 |    | j | d  } YnU t k
 r| j d d  } | j   d k r| j t j d j
 |    Yn X| | | | f S)a  Decode encoded word and return (string, charset, lang, defects) tuple.

    An RFC 2047/2243 encoded word has the form:

        =?charset*lang?cte?encoded_string?=

    where '*lang' may be omitted but the other parts may not be.

    This function expects exactly such a string (that is, it does not check the
    syntax and may raise errors if the string is not well formed), and returns
    the encoded_string decoded first from its Content Transfer Encoding and
    then from the resulting bytes into unicode using the specified charset.  If
    the cte-decoded string does not successfully decode using the specified
    character set, a defect is added to the defects list and the unknown octets
    are replaced by the unicode 'unknown' character \uFDFF.

    The specified charset and language are returned.  The default for language,
    which is rarely if ever encountered, is the empty string.

    ?*r   surrogateescapez:Encoded word contains bytes not decodable using {} charsetzunknown-8bitz<Unknown charset {} in encoded word; decoded as unknown bytes)split	partitionlowerr   _cte_decodersr   UnicodeErrorr5   r   ZUndecodableBytesDefectr   LookupErrorZCharsetError)	Zewr&   charsetZcteZ
cte_stringlangr.   r:   stringr   r   r   r      s"    zutf-8r(   c             C   s   | d k r! |  j  d d  } n |  j  |  } | d k rx t d |  } t d |  } | | d k  rr d n d } t | |  } | r d | } d	 j | | | |  S)
a  Encode string using the CTE encoding that produces the shorter result.

    Produces an RFC 2047/2243 encoded word of the form:

        =?charset*lang?cte?encoded_string?=

    where '*lang' is omitted unless the 'lang' parameter is given a value.
    Optional argument charset (defaults to utf-8) specifies the charset to use
    to encode the string to binary before CTE encoding it.  Optional argument
    'encoding' is the cte specifier for the encoding that should be used ('q'
    or 'b'); if it is None (the default) the encoding which produces the
    shortest encoded sequence is used, except that 'q' is preferred if it is up
    to five characters longer.  Optional argument 'lang' (default '') gives the
    RFC 2243 language string to specify in the encoded word.

    zunknown-8bitr   rA   Nr=   r>      r@   z=?{}{}?{}?{}?=)r   _cte_encode_length_cte_encodersr   )rJ   rH   encodingrI   r.   ZqlenZblenr   r   r   r   r      s    
)__doc__rer6   r7   	functoolsrJ   r   r   Zemailr   __all__partialcompilesubr   r   dictr   r)   ordr   r	   r   r   r
   rE   r   rM   rL   r   r   r   r   r   <module>   sB   $		+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
[                @   s	  d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z d d l	 m Z d d l	 m Z e d	  Z e e d
  BZ e d  Z e e BZ e e d  Z e e d  Z e e d  Be d  Z e e BZ e e d  BZ e e BZ e e d  Z d d   Z Gd d   d  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z  Gd d   d e  Z! Gd d    d  e  Z" Gd! d"   d" e  Z# Gd# d$   d$ e  Z$ Gd% d&   d& e  Z% Gd' d(   d( e  Z& Gd) d*   d* e&  Z' Gd+ d,   d, e  Z( Gd- d.   d. e  Z) Gd/ d0   d0 e  Z* Gd1 d2   d2 e  Z+ Gd3 d4   d4 e  Z, Gd5 d6   d6 e  Z- Gd7 d8   d8 e  Z. Gd9 d:   d: e  Z/ Gd; d<   d< e  Z0 Gd= d>   d> e  Z1 Gd? d@   d@ e  Z2 GdA dB   dB e  Z3 GdC dD   dD e  Z4 GdE dF   dF e  Z5 GdG dH   dH e  Z6 GdI dJ   dJ e  Z7 GdK dL   dL e   Z8 GdM dN   dN e  Z9 GdO dP   dP e  Z: GdQ dR   dR e  Z; GdS dT   dT e  Z< GdU dV   dV e<  Z= GdW dX   dX e  Z> GdY dZ   dZ e  Z? Gd[ d\   d\ e  Z@ Gd] d^   d^ e  ZA Gd_ d`   d` e  ZB Gda db   db eB  ZC Gdc dd   dd eB  ZD Gde df   df e  ZE Gdg dh   dh e  ZF Gdi dj   dj e  ZG Gdk dl   dl eH  ZI Gdm dn   dn eI  ZJ Gdo dp   dp eI  ZK Gdq dr   dr eJ  ZL eK d ds  ZM eK dt du  ZN eK dv dw  ZO e jP dx jQ dy jR e    jS ZT e jP dz jQ dy jR e  jU d{ d|  jU d} d~    jV ZW e jP d  jX ZY e jP dz jQ dy jR e  jU d{ d|  jU d} d~    jV ZZ e jP dz jQ dy jR e  jU d{ d|  jU d} d~    jV Z[ e jP dz jQ dy jR e  jU d{ d|  jU d} d~    jV Z\ d d   Z] d d   Z^ d d   Z_ d d   Z` d d   Za d d   Zb d d   Zc d d   Zd d d   Ze d d   Zf d d   Zg d d   Zh d d   Zi d d   Zj d d   Zk d d   Zl d d   Zm d d   Zn d d   Zo d d   Zp d d   Zq d d   Zr d d   Zs d d   Zt d d   Zu d d   Zv d d   Zw d d   Zx d d   Zy d d   Zz d d   Z{ d d   Z| d d   Z} d d   Z~ d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)al  Header value parser implementing various email-related RFC parsing rules.

The parsing methods defined in this module implement various email related
parsing rules.  Principal among them is RFC 5322, which is the followon
to RFC 2822 and primarily a clarification of the former.  It also implements
RFC 2047 encoded word decoding.

RFC 5322 goes to considerable trouble to maintain backward compatibility with
RFC 822 in the parse phase, while cleaning up the structure on the generation
phase.  This parser supports correct RFC 5322 generation by tagging white space
as folding white space only when folding is allowed in the non-obsolete rule
sets.  Actually, the parser is even more generous when accepting input than RFC
5322 mandates, following the spirit of Postel's Law, which RFC 5322 encourages.
Where possible deviations from the standard are annotated on the 'defects'
attribute of tokens that deviate.

The general structure of the parser follows RFC 5322, and uses its terminology
where there is a direct correspondence.  Where the implementation requires a
somewhat different structure than that used by the formal grammar, new terms
that mimic the closest existing terms are used.  Thus, it really helps to have
a copy of RFC 5322 handy when studying this code.

Input to the parser is a string that has already been unfolded according to
RFC 5322 rules.  According to the RFC this unfolding is the very first step, and
this parser leaves the unfolding step to a higher level message parser, which
will have already detected the line breaks that need unfolding while
determining the beginning and end of each header.

The output of the parser is a TokenList object, which is a list subclass.  A
TokenList is a recursive data structure.  The terminal nodes of the structure
are Terminal objects, which are subclasses of str.  These do not correspond
directly to terminal objects in the formal grammar, but are instead more
practical higher level combinations of true terminals.

All TokenList and Terminal objects have a 'value' attribute, which produces the
semantically meaningful value of that part of the parse subtree.  The value of
all whitespace tokens (no matter how many sub-tokens they may contain) is a
single space, as per the RFC rules.  This includes 'CFWS', which is herein
included in the general class of whitespace tokens.  There is one exception to
the rule that whitespace tokens are collapsed into single spaces in values: in
the value of a 'bare-quoted-string' (a quoted-string with no leading or
trailing whitespace), any whitespace that appeared between the quotation marks
is preserved in the returned value.  Note that in all Terminal strings quoted
pairs are turned into their unquoted values.

All TokenList and Terminal objects also have a string value, which attempts to
be a "canonical" representation of the RFC-compliant form of the substring that
produced the parsed subtree, including minimal use of quoted pair quoting.
Whitespace runs are not collapsed.

Comment tokens also have a 'content' attribute providing the string found
between the parens (including any nested comments) with whitespace preserved.

All TokenList and Terminal objects have a 'defects' attribute which is a
possibly empty list all of the defects found while creating the token.  Defects
may appear on any token in the tree, and a composite list of all defects in the
subtree is available through the 'all_defects' attribute of any node.  (For
Terminal notes x.defects == x.all_defects.)

Each object in a parse tree is called a 'token', and each has a 'token_type'
attribute that gives the name from the RFC 5322 grammar that it represents.
Not all RFC 5322 nodes are produced, and there is one non-RFC 5322 node that
may be produced: 'ptext'.  A 'ptext' is a string of printable ascii characters.
It is returned in place of lists of (ctext/quoted-pair) and
(qtext/quoted-pair).

XXX: provide complete list of token types.
    N)	hexdigits)OrderedDict)
itemgetter)_encoded_words)errors)utilsz 	(z()<>@,:;.\"[].z."(z/?=z*'%%c             C   s*   d t  |   j d d  j d d  d S)N"\z\\z\")strreplace)value r   0/usr/lib/python3.5/email/_header_value_parser.pyquote_string`   s    r   c               @   s[   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d d  Z d S)_Foldedc             C   sC   | |  _  | |  _ d |  _ d  |  _ d |  _ g  |  _ g  |  _ d  S)Nr   T)maxlenpolicylastlenstickyspace	firstlinedonecurrent)selfr   r   r   r   r   __init__i   s    						z_Folded.__init__c             C   sC   |  j  j |  j  |  j  j |  j j  |  j j   d |  _ d  S)Nr   )r   extendr   appendr   linesepclearr   )r   r   r   r   newliner   s    z_Folded.newlinec             C   s   |  j  r |  j   d  S)N)r   r!   )r   r   r   r   finalizex   s    	z_Folded.finalizec             C   s   d j  |  j  S)N )joinr   )r   r   r   r   __str__|   s    z_Folded.__str__c             C   s   |  j  j |  d  S)N)r   r   )r   stokenr   r   r   r      s    z_Folded.appendNc             C   s  | d  k r t  |  } t |  } |  j d  k	 r+t |  j  } |  j | | |  j k r |  j j |  j  |  j | 7_ |  j j |  |  j | 7_ d  |  _ d |  _ d S| j r
| j	   } | d  k	 r |  j t  |  7_ | t |  7} | j
 |   d S| r| d |  j k r|  j | } d | k  oG| k  n r| | } |  j j |  j d  |   |  j | d   |  _ | } |  j   |  j j |  j  |  j j |  | | |  _ d  |  _ d |  _ d S|  j s|  j   |  j j |  j  |  j j |  d  |  _ d |  _ d S|  j | |  j k rd|  j j |  |  j | 7_ d S| |  j k  r|  j   |  j j |  | |  _ d Sd S)NFT   r   )r   lenr   r   r   r   r   r   has_fwspop_leading_fws_foldr!   )r   tokenr&   lZstickyspace_lenwsZmarginZtrimr   r   r   append_if_fits   sf    			

			
		
	z_Folded.append_if_fits)	__name__
__module____qualname__r   r!   r"   r%   r   r/   r   r   r   r   r   g   s   	r   c                   s-  e  Z d  Z d Z   f d d   Z d d   Z   f d d   Z e d d	    Z e d
 d    Z	 e d d    Z
 d d   Z d d   Z d d   Z e d d    Z d d   Z e d d    Z d d   Z d d   Z d d   Z d  d!   Z d" d# d$  Z d" d% d&  Z d" d' d(  Z   S))	TokenListNc                s    t    j | |   g  |  _ d  S)N)superr   defects)r   argskw)	__class__r   r   r      s    zTokenList.__init__c             C   s   d j  d d   |  D  S)Nr#   c             s   s   |  ] } t  |  Vq d  S)N)r   ).0xr   r   r   	<genexpr>   s    z$TokenList.__str__.<locals>.<genexpr>)r$   )r   r   r   r   r%      s    zTokenList.__str__c                s   d j  |  j j t   j    S)Nz{}({}))formatr8   r0   r4   __repr__)r   )r8   r   r   r=      s    zTokenList.__repr__c             C   s   d j  d d   |  D  S)Nr#   c             s   s!   |  ] } | j  r | j  Vq d  S)N)r   )r9   r:   r   r   r   r;      s    z"TokenList.value.<locals>.<genexpr>)r$   )r   r   r   r   r      s    zTokenList.valuec             C   s   t  d d   |  D |  j  S)Nc             s   s   |  ] } | j  Vq d  S)N)all_defects)r9   r:   r   r   r   r;      s    z(TokenList.all_defects.<locals>.<genexpr>)sumr5   )r   r   r   r   r>      s    zTokenList.all_defectsc             c   s   |  j  } g  } x |  D]| } | j   r_ | r_ t |  d k rJ | d n	 | |  V| j   | j   } | j |  | r | |  V| g } q W| r t |  d k r | d n	 | |  Vd  S)Nr'   r   )r8   startswith_fwsr(   r    pop_trailing_wsr   )r   klassthisr,   Zend_wsr   r   r   parts   s    	'
zTokenList.partsc             C   s   |  d j    S)Nr   )r@   )r   r   r   r   r@   
  s    zTokenList.startswith_fwsc             C   s.   |  d j  d k r  |  j d  S|  d j   S)Nr   fws)
token_typepopr*   )r   r   r   r   r*     s    zTokenList.pop_leading_fwsc             C   s.   |  d j  d k r  |  j d  S|  d j   S)Nr'   cfwsrI   rI   )rF   rG   rA   )r   r   r   r   rA     s    zTokenList.pop_trailing_wsc             C   s"   x |  D] } | j  r d Sq Wd S)NTF)r)   )r   partr   r   r   r)     s    	zTokenList.has_fwsc             C   s   |  d j    S)Nr   )has_leading_comment)r   r   r   r   rK     s    zTokenList.has_leading_commentc             C   s+   g  } x |  D] } | j  | j  q W| S)N)r   comments)r   rL   r,   r   r   r   rL   !  s    zTokenList.commentsc            C   sE   | j  p t d  } t | |  } |  j |  | j   t |  S)Nz+inf)Zmax_line_lengthfloatr   r+   r"   r   )r   r   r   foldedr   r   r   fold(  s
    
zTokenList.foldc             C   s   g  } |  j    } | r% | j |  |  d j d k rG |  j d  n d } | j t j t |   |   | j |  d j |  S)Nr'   rE   r#   rI   rI   )r*   r   rF   rG   _ewencoder   r$   )r   charsetresr.   Ztrailerr   r   r   as_encoded_word0  s    (zTokenList.as_encoded_wordc             C   s=   g  } x' |  D] } | j  | j | |   q Wd j |  S)Nr#   )r   
cte_encoder$   )r   rR   r   rS   rJ   r   r   r   rU   <  s    zTokenList.cte_encodec             C   sG  | j  j r d n d } x(|  j D]} t |  } t |  } y t |  j |  Wn^ t k
 r t d d   | j D  r d } n d } | j	 | | j   } t |  } Yn X| j
 | |  r q" | j   } | d  k	 rt | j d   | _ | j
 |  rq" | j r(| j |  q" | j |  | j   q" Wd  S)Nzutf-8asciic             s   s!   |  ] } t  | t j  Vq d  S)N)
isinstancer   UndecodableBytesDefect)r9   r:   r   r   r   r;   J  s   z"TokenList._fold.<locals>.<genexpr>zunknown-8bitr   )r   utf8rD   r   r(   rQ   UnicodeEncodeErroranyr>   rU   r/   r*   rG   r   r)   r+   r   r!   )r   rN   encodingrJ   tstrtlenrR   r.   r   r   r   r+   B  s2    		zTokenList._foldr#   c             C   s#   t  d j |  j d d    d  S)N
indentr#   )printr$   _pp)r   r`   r   r   r   pprinte  s    zTokenList.pprintc             C   s   d j  |  j d d   S)Nr_   r`   r#   )r$   rb   )r   r`   r   r   r   ppstrh  s    zTokenList.ppstrc             c   s   d j  | |  j j |  j  VxH |  D]@ } t | d  sN | d j  |  Vq$ | j | d  Ed  Hq$ W|  j r d j  |  j  } n d } d j  | |  Vd  S)Nz{}{}/{}(rb   z*    !! invalid element in token list: {!r}z    z Defects: {}r#   z{}){})r<   r8   r0   rF   hasattrrb   r5   )r   r`   r,   Zextrar   r   r   rb   k  s    			zTokenList._pp)r0   r1   r2   rF   r   r%   r=   propertyr   r>   rD   r@   r*   rA   r)   rK   rL   rO   rT   rU   r+   rc   rd   rb   r   r   )r8   r   r3      s(   +#r3   c               @   s4   e  Z d  Z e d d    Z e d d    Z d S)WhiteSpaceTokenListc             C   s   d S)N r   )r   r   r   r   r     s    zWhiteSpaceTokenList.valuec             C   s   d d   |  D S)Nc             S   s(   g  |  ] } | j  d  k r | j  q S)comment)rF   content)r9   r:   r   r   r   
<listcomp>  s   	 z0WhiteSpaceTokenList.comments.<locals>.<listcomp>r   )r   r   r   r   rL     s    zWhiteSpaceTokenList.commentsN)r0   r1   r2   rf   r   rL   r   r   r   r   rg   }  s   rg   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)UnstructuredTokenListunstructuredc             C   s)  d  } | j  j r d n d } x|  j D]} t |  } d } y t |  j |  Wnt k
 rgt d d   | j D  r d } n d } | d  k	 rNt d j	 | j
 | d   | g   j |  } t d d   | j
 d  |  D  }	 t |  }
 t |
  } |	 | | j k rN| j
 | d   =| j |
  |	 | | _ w( | j |  } d	 } Yn X| j | |  r| r( t | j
  d
 } q( | s| r| j |  q( | j   } | d  k	 rt |  | _ | j |  rq( | j r| j |  q( | j |  | j   d  } q( Wd  S)Nzutf-8rV   Fc             s   s!   |  ] } t  | t j  Vq d  S)N)rW   r   rX   )r9   r:   r   r   r   r;     s   z.UnstructuredTokenList._fold.<locals>.<genexpr>zunknown-8bitr#   c             s   s   |  ] } t  |  Vq d  S)N)r(   )r9   r:   r   r   r   r;     s    Tr'   )r   rY   rD   r   rQ   rZ   r[   r>   get_unstructuredr$   r   rT   r?   r(   r   r   r   r/   Z_fold_as_ewr*   r   r)   r+   r!   )r   rN   last_ewr\   rJ   r]   is_ewrR   chunkZ
oldlastlenschunklchunkr.   r   r   r   r+     sV    	/&	
zUnstructuredTokenList._foldc             C   s   g  } d  } x |  D] } t  |  } y | j d  | j |  Wq t k
 r | d  k r | j | j | |   t |  } n< t d j | | d   | g   } | j | j |   Yq Xq Wd j |  S)Nzus-asciir#   )	r   rQ   r   rZ   rU   r(   rn   r$   rT   )r   rR   r   rS   ro   rJ   sparttlr   r   r   rU     s    &z UnstructuredTokenList.cte_encodeN)r0   r1   r2   rF   r+   rU   r   r   r   r   rl     s   5rl   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)Phrasephrasec             C   sa  d  } | j  j r d n d } x<|  j D]1} t |  } t |  } d } y t |  j |  Wnt k
 rt d d   | j D  r d } n d } | d  k	 r| j	   r| d j
 d k r | j r | j d  }	 n d	 }	 xC t |  D]5 \ }
 } | j
 d
 k r t | d  d    | |
 <q Wt d	 j | j | d   | g   j |  } t |  } t |  } | | | j k r| j | d   =| j |  t d d   | j D  | _ w( | j |  } t |  } d } Yn X| j | |  rL| r+| j r+t | j  d } q( | j sC| j
 d k r( d  } q( | j |  q( Wd  S)Nzutf-8rV   Fc             s   s!   |  ] } t  | t j  Vq d  S)N)rW   r   rX   )r9   r:   r   r   r   r;     s   zPhrase._fold.<locals>.<genexpr>zunknown-8bitr'   rH   r#   zbare-quoted-stringc             s   s   |  ] } t  |  Vq d  S)N)r(   )r9   r:   r   r   r   r;     s    Tzquoted-stringrI   rI   )r   rY   rD   r   r(   rQ   rZ   r[   r>   rK   rF   rL   rG   	enumeraterl   rn   r$   r   rT   r   r   r?   r   r/   r+   )r   rN   ro   r\   rJ   r]   r^   Zhas_ewrR   	remainderir,   rq   rr   rs   r   r   r   r+     sN    	/zPhrase._foldc             C   s  g  } d  } d } x}|  D]u} t  |  } y | j d  | j |  Wnt k
 rhd } | d  k r | j s t |  } | j | j | |   n | j   sd| d	 j d k r | j r | j	 d
  } n d } xC t
 |  D]5 \ }	 }
 |
 j d k r t |
 d  d    | |	 <q Wt d j | | d   | g   } | j |  g | | d   <Yn X| j s| r | j d k r d  } q Wd j |  S)NFzus-asciiTr'   rH   r#   zbare-quoted-stringzquoted-stringrI   rI   )r   rQ   r   rZ   rL   r(   rU   rK   rF   rG   rx   rl   rn   r$   rT   )r   rR   r   rS   ro   rp   rJ   rt   ry   rz   r,   ru   r   r   r   rU     s4    	&!
zPhrase.cte_encodeN)r0   r1   r2   rF   r+   rU   r   r   r   r   rv     s   ?rv   c               @   s   e  Z d  Z d Z d S)WordZwordN)r0   r1   r2   rF   r   r   r   r   r{   3  s   r{   c               @   s"   e  Z d  Z d Z d d   Z d S)CFWSListrH   c             C   s   t  |  j  S)N)boolrL   )r   r   r   r   rK   <  s    zCFWSList.has_leading_commentN)r0   r1   r2   rF   rK   r   r   r   r   r|   8  s   r|   c               @   s   e  Z d  Z d Z d S)AtomatomN)r0   r1   r2   rF   r   r   r   r   r~   @  s   r~   c               @   s   e  Z d  Z d Z d S)Tokenr,   N)r0   r1   r2   rF   r   r   r   r   r   E  s   r   c               @   s:   e  Z d  Z d Z d Z d Z d Z e d d    Z d S)EncodedWordzencoded-wordNc             C   s3   |  j  d  k	 r |  j  St j t |   |  j  d  S)N)cterP   rQ   r   rR   )r   r   r   r   encodedQ  s    zEncodedWord.encoded)	r0   r1   r2   rF   r   rR   langrf   r   r   r   r   r   r   J  s
   r   c               @   sL   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z d S)	QuotedStringzquoted-stringc             C   s+   x$ |  D] } | j  d k r | j Sq Wd  S)Nzbare-quoted-string)rF   r   )r   r:   r   r   r   rj   ]  s    zQuotedString.contentc             C   sY   g  } xC |  D]; } | j  d k r8 | j t |   q | j | j  q Wd j |  S)Nzbare-quoted-stringr#   )rF   r   r   r   r$   )r   rS   r:   r   r   r   quoted_valuec  s    zQuotedString.quoted_valuec             C   s+   x$ |  D] } | j  d k r | j Sq Wd  S)Nzbare-quoted-string)rF   r   )r   r,   r   r   r   stripped_valuem  s    zQuotedString.stripped_valueN)r0   r1   r2   rF   rf   rj   r   r   r   r   r   r   r   Y  s   
r   c               @   s4   e  Z d  Z d Z d d   Z e d d    Z d S)BareQuotedStringzbare-quoted-stringc             C   s    t  d j d d   |  D   S)Nr#   c             s   s   |  ] } t  |  Vq d  S)N)r   )r9   r:   r   r   r   r;   y  s    z+BareQuotedString.__str__.<locals>.<genexpr>)r   r$   )r   r   r   r   r%   x  s    zBareQuotedString.__str__c             C   s   d j  d d   |  D  S)Nr#   c             s   s   |  ] } t  |  Vq d  S)N)r   )r9   r:   r   r   r   r;   }  s    z)BareQuotedString.value.<locals>.<genexpr>)r$   )r   r   r   r   r   {  s    zBareQuotedString.valueN)r0   r1   r2   rF   r%   rf   r   r   r   r   r   r   t  s   r   c               @   sR   e  Z d  Z d Z d d   Z d d   Z e d d    Z e d d	    Z d
 S)Commentri   c                s8   d j  t d g   f d d     D d g g g    S)Nr#   r   c                s   g  |  ] }   j  |   q Sr   )quote)r9   r:   )r   r   r   rk     s   	 z#Comment.__str__.<locals>.<listcomp>))r$   r?   )r   r   )r   r   r%     s
    		zComment.__str__c             C   sG   | j  d k r t |  St |  j d d  j d d  j d d  S)Nri   r   z\\r   z\(r   z\))rF   r   r   )r   r   r   r   r   r     s
    
zComment.quotec             C   s   d j  d d   |  D  S)Nr#   c             s   s   |  ] } t  |  Vq d  S)N)r   )r9   r:   r   r   r   r;     s    z"Comment.content.<locals>.<genexpr>)r$   )r   r   r   r   rj     s    zComment.contentc             C   s
   |  j  g S)N)rj   )r   r   r   r   rL     s    zComment.commentsN)	r0   r1   r2   rF   r%   r   rf   rj   rL   r   r   r   r   r     s
   r   c               @   sL   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z d S)	AddressListzaddress-listc             C   s   d d   |  D S)Nc             S   s%   g  |  ] } | j  d  k r |  q S)address)rF   )r9   r:   r   r   r   rk     s   	 z)AddressList.addresses.<locals>.<listcomp>r   )r   r   r   r   	addresses  s    zAddressList.addressesc             C   s   t  d d   |  D g   S)Nc             s   s'   |  ] } | j  d  k r | j Vq d S)r   N)rF   	mailboxes)r9   r:   r   r   r   r;     s   z(AddressList.mailboxes.<locals>.<genexpr>)r?   )r   r   r   r   r     s    zAddressList.mailboxesc             C   s   t  d d   |  D g   S)Nc             s   s'   |  ] } | j  d  k r | j Vq d S)r   N)rF   all_mailboxes)r9   r:   r   r   r   r;     s   z,AddressList.all_mailboxes.<locals>.<genexpr>)r?   )r   r   r   r   r     s    zAddressList.all_mailboxesN)r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r     s   r   c               @   sL   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z d S)	Addressr   c             C   s"   |  d j  d k r |  d j Sd  S)Nr   group)rF   display_name)r   r   r   r   r     s    zAddress.display_namec             C   s@   |  d j  d k r |  d g S|  d j  d k r5 g  S|  d j S)Nr   mailboxzinvalid-mailbox)rF   r   )r   r   r   r   r     s
    zAddress.mailboxesc             C   sG   |  d j  d k r |  d g S|  d j  d k r< |  d g S|  d j S)Nr   r   zinvalid-mailbox)rF   r   )r   r   r   r   r     s
    zAddress.all_mailboxesN)r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r     s   r   c               @   s:   e  Z d  Z d Z e d d    Z e d d    Z d S)MailboxListzmailbox-listc             C   s   d d   |  D S)Nc             S   s%   g  |  ] } | j  d  k r |  q S)r   )rF   )r9   r:   r   r   r   rk     s   	 z)MailboxList.mailboxes.<locals>.<listcomp>r   )r   r   r   r   r     s    zMailboxList.mailboxesc             C   s   d d   |  D S)Nc             S   s%   g  |  ] } | j  d k r |  q S)r   invalid-mailbox)r   r   )rF   )r9   r:   r   r   r   rk     s   	 z-MailboxList.all_mailboxes.<locals>.<listcomp>r   )r   r   r   r   r     s    zMailboxList.all_mailboxesN)r0   r1   r2   rF   rf   r   r   r   r   r   r   r     s   r   c               @   s:   e  Z d  Z d Z e d d    Z e d d    Z d S)	GroupListz
group-listc             C   s)   |  s |  d j  d k r g  S|  d j S)Nr   zmailbox-list)rF   r   )r   r   r   r   r     s    zGroupList.mailboxesc             C   s)   |  s |  d j  d k r g  S|  d j S)Nr   zmailbox-list)rF   r   )r   r   r   r   r     s    zGroupList.all_mailboxesN)r0   r1   r2   rF   rf   r   r   r   r   r   r   r     s   r   c               @   sL   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z d S)	Groupr   c             C   s"   |  d j  d k r g  S|  d j S)N   z
group-list)rF   r   )r   r   r   r   r     s    zGroup.mailboxesc             C   s"   |  d j  d k r g  S|  d j S)Nr   z
group-list)rF   r   )r   r   r   r   r     s    zGroup.all_mailboxesc             C   s   |  d j  S)Nr   )r   )r   r   r   r   r     s    zGroup.display_nameN)r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r     s   r   c               @   sp   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z e d d	    Z e d
 d    Z	 d S)NameAddrz	name-addrc             C   s!   t  |   d k r d  S|  d j S)Nr'   r   )r(   r   )r   r   r   r   r     s    zNameAddr.display_namec             C   s   |  d j  S)Nr'   rI   )
local_part)r   r   r   r   r     s    zNameAddr.local_partc             C   s   |  d j  S)Nr'   rI   )domain)r   r   r   r   r     s    zNameAddr.domainc             C   s   |  d j  S)Nr'   rI   )route)r   r   r   r   r     s    zNameAddr.routec             C   s   |  d j  S)Nr'   rI   )	addr_spec)r   r   r   r   r     s    zNameAddr.addr_specN)
r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r   r   r     s   r   c               @   s^   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z e d d	    Z d
 S)	AngleAddrz
angle-addrc             C   s+   x$ |  D] } | j  d k r | j Sq Wd  S)Nz	addr-spec)rF   r   )r   r:   r   r   r   r     s    zAngleAddr.local_partc             C   s+   x$ |  D] } | j  d k r | j Sq Wd  S)Nz	addr-spec)rF   r   )r   r:   r   r   r   r     s    zAngleAddr.domainc             C   s+   x$ |  D] } | j  d k r | j Sq Wd  S)Nz	obs-route)rF   domains)r   r:   r   r   r   r   %  s    zAngleAddr.routec             C   s/   x( |  D] } | j  d k r | j Sq Wd Sd  S)Nz	addr-specz<>)rF   r   )r   r:   r   r   r   r   +  s    zAngleAddr.addr_specN)	r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r   r     s
   r   c               @   s(   e  Z d  Z d Z e d d    Z d S)ObsRoutez	obs-routec             C   s   d d   |  D S)Nc             S   s(   g  |  ] } | j  d  k r | j  q S)r   )rF   r   )r9   r:   r   r   r   rk   :  s   	 z$ObsRoute.domains.<locals>.<listcomp>r   )r   r   r   r   r   8  s    zObsRoute.domainsN)r0   r1   r2   rF   rf   r   r   r   r   r   r   4  s   r   c               @   sp   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z e d d	    Z e d
 d    Z	 d S)Mailboxr   c             C   s"   |  d j  d k r |  d j Sd  S)Nr   z	name-addr)rF   r   )r   r   r   r   r   A  s    zMailbox.display_namec             C   s   |  d j  S)Nr   )r   )r   r   r   r   r   F  s    zMailbox.local_partc             C   s   |  d j  S)Nr   )r   )r   r   r   r   r   J  s    zMailbox.domainc             C   s"   |  d j  d k r |  d j Sd  S)Nr   z	name-addr)rF   r   )r   r   r   r   r   N  s    zMailbox.routec             C   s   |  d j  S)Nr   )r   )r   r   r   r   r   S  s    zMailbox.addr_specN)
r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r   r   r   =  s   r   c               @   s:   e  Z d  Z d Z e d d    Z e Z Z Z Z	 d S)InvalidMailboxzinvalid-mailboxc             C   s   d  S)Nr   )r   r   r   r   r   \  s    zInvalidMailbox.display_nameN)
r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r   r   r   X  s   r   c                   s.   e  Z d  Z d Z e   f d d    Z   S)Domainr   c                s   d j  t   j j    S)Nr#   )r$   r4   r   split)r   )r8   r   r   r   g  s    zDomain.domain)r0   r1   r2   rF   rf   r   r   r   )r8   r   r   c  s   r   c               @   s   e  Z d  Z d Z d S)DotAtomzdot-atomN)r0   r1   r2   rF   r   r   r   r   r   l  s   r   c               @   s   e  Z d  Z d Z d S)DotAtomTextzdot-atom-textN)r0   r1   r2   rF   r   r   r   r   r   q  s   r   c               @   s^   e  Z d  Z d Z e d d    Z e d d    Z e d d    Z e d d	    Z d
 S)AddrSpecz	addr-specc             C   s   |  d j  S)Nr   )r   )r   r   r   r   r   z  s    zAddrSpec.local_partc             C   s!   t  |   d k  r d  S|  d j S)N   r'   rI   )r(   r   )r   r   r   r   r   ~  s    zAddrSpec.domainc             C   sJ   t  |   d k  r |  d j S|  d j j   |  d j |  d j j   S)Nr   r   r'   r   )r(   r   rstriplstrip)r   r   r   r   r     s    zAddrSpec.valuec             C   sh   t  |  j  } t |  t | t  k r= t |  j  } n	 |  j } |  j d  k	 rd | d |  j S| S)N@)setr   r(   DOT_ATOM_ENDSr   r   )r   ZnamesetZlpr   r   r   r     s    	zAddrSpec.addr_specN)	r0   r1   r2   rF   rf   r   r   r   r   r   r   r   r   r   v  s
   r   c               @   s   e  Z d  Z d Z d S)ObsLocalPartzobs-local-partN)r0   r1   r2   rF   r   r   r   r   r     s   r   c                   s@   e  Z d  Z d Z e d d    Z e   f d d    Z   S)DisplayNamezdisplay-namec             C   s   t  |   } | d j d k r/ | j d  n5 | d d j d k rd t  | d d d    | d <| d j d k r | j   n5 | d d j d k r t  | d d  d   | d	 <| j S)
Nr   rH   r'   rI   rI   rI   rI   rI   rI   )r3   rF   rG   r   )r   rS   r   r   r   r     s    zDisplayName.display_namec                s   d } |  j  r d } n& x# |  D] } | j d k r d } q W| r d } } |  d j d k sx |  d d j d k r~ d } |  d	 j d k s |  d
 d j d k r d } | t |  j  | St   j Sd  S)NFTzquoted-stringr#   r   rH   rh   r'   rI   rI   rI   )r5   rF   r   r   r4   r   )r   r   r:   ZpreZpost)r8   r   r   r     s    		

**zDisplayName.value)r0   r1   r2   rF   rf   r   r   r   r   )r8   r   r     s   r   c               @   s:   e  Z d  Z d Z e d d    Z e d d    Z d S)	LocalPartz
local-partc             C   s-   |  d j  d k r |  d j S|  d j Sd  S)Nr   zquoted-string)rF   r   r   )r   r   r   r   r     s    zLocalPart.valuec             C   s  t  g } t  } d } x |  d t  g D] } | j d k r? q' | r | j d k r | d j d k r t | d  d   | d <t | t  } | r | j d k r | d j d k r | j t | d d     n | j |  | d	 } | } q' Wt | d d
   } | j S)NFr   rH   dotr'   rI   rI   rI   rI   rI   )DOTrF   r3   rW   r   r   )r   rS   ZlastZ
last_is_tltokZis_tlr   r   r   r     s$    	 

zLocalPart.local_partN)r0   r1   r2   rF   rf   r   r   r   r   r   r   r     s   r   c                   s@   e  Z d  Z d Z e   f d d    Z e d d    Z   S)DomainLiteralzdomain-literalc                s   d j  t   j j    S)Nr#   )r$   r4   r   r   )r   )r8   r   r   r     s    zDomainLiteral.domainc             C   s+   x$ |  D] } | j  d k r | j Sq Wd  S)Nptext)rF   r   )r   r:   r   r   r   ip  s    zDomainLiteral.ip)r0   r1   r2   rF   rf   r   r   r   r   )r8   r   r     s   r   c               @   s"   e  Z d  Z d Z d Z d Z d S)MIMEVersionzmime-versionN)r0   r1   r2   rF   majorminorr   r   r   r   r     s   r   c               @   sL   e  Z d  Z d Z d Z d Z d Z e d d    Z e d d    Z	 d S)		Parameter	parameterFzus-asciic             C   s   |  j  r |  d j Sd S)Nr'   r   )	sectionednumber)r   r   r   r   section_number  s    zParameter.section_numberc             C   s   xz |  D]r } | j  d k r# | j S| j  d k r xD | D]< } | j  d k r9 x$ | D] } | j  d k rU | j SqU Wq9 Wq Wd S)Nr   zquoted-stringzbare-quoted-stringr#   )rF   r   )r   r,   r   r   r   param_value  s    zParameter.param_valueN)
r0   r1   r2   rF   r   extendedrR   rf   r   r   r   r   r   r   r     s   r   c               @   s   e  Z d  Z d Z d S)InvalidParameterzinvalid-parameterN)r0   r1   r2   rF   r   r   r   r   r     s   r   c               @   s(   e  Z d  Z d Z e d d    Z d S)	Attribute	attributec             C   s.   x' |  D] } | j  j d  r | j Sq Wd  S)Nattrtext)rF   endswithr   )r   r,   r   r   r   r      s    zAttribute.stripped_valueN)r0   r1   r2   rF   rf   r   r   r   r   r   r     s   r   c               @   s   e  Z d  Z d Z d Z d S)SectionsectionN)r0   r1   r2   rF   r   r   r   r   r   r   &  s   r   c               @   s(   e  Z d  Z d Z e d d    Z d S)Valuer   c             C   sC   |  d } | j  d k r# |  d } | j  j d  r< | j S|  j S)Nr   rH   r'   quoted-stringr   extended-attribute)r   r   r   )rF   r   r   r   )r   r,   r   r   r   r   0  s    

		zValue.stripped_valueN)r0   r1   r2   rF   rf   r   r   r   r   r   r   ,  s   r   c               @   s4   e  Z d  Z d Z e d d    Z d d   Z d S)MimeParameterszmime-parametersc             c   s  t    } x| |  D]t } | j j d  s+ q | d j d k rA q | d j j   } | | k rj g  | | <| | j | j | f  q Wx| j   D]\ } } t | d t	 d  } | d d } | j
 } | j r1t |  d k r1| d d d k r1| d d j j t j d   | d  d  } g  } d } x/| D]'\ }	 }
 |	 | k r|
 j s|
 j j t j d   qDn |
 j j t j d   | d 7} |
 j } |
 j r^y t j j |  } Wn* t k
 rt j j | d	 d
 } Ync Xy | j | d  } Wn$ t k
 r8| j d d  } Yn Xt j |  r^|
 j j t j    | j |  qDWd j |  } | | f Vq Wd  S)Nr   r   r   keyr'   z.duplicate parameter name; duplicate(s) ignoredz+duplicate parameter name; duplicate ignoredz(inconsistent RFC2231 parameter numberingr\   zlatin-1surrogateescapezus-asciir#   )r   rF   r   r   stripr   r   itemssortedr   rR   r   r(   r5   r   InvalidHeaderDefectr   urllibparseZunquote_to_bytesrZ   ZunquotedecodeLookupErrorr   _has_surrogatesrX   r$   )r   paramsr,   namerD   Zfirst_paramrR   Zvalue_partsrz   r   paramr   r   r   r   r   ?  sZ    	
	
	


		zMimeParameters.paramsc             C   sv   g  } xL |  j  D]A \ } } | rD | j d j | t |    q | j |  q Wd j |  } | rr d | Sd S)Nz{}={}z; rh   r#   )r   r   r<   r   r$   )r   r   r   r   r   r   r   r%     s    "zMimeParameters.__str__N)r0   r1   r2   rF   rf   r   r%   r   r   r   r   r   ;  s   Fr   c               @   s4   e  Z d  Z e d d    Z e d d    Z d S)ParameterizedHeaderValuec             C   s1   x* t  |   D] } | j d k r | j Sq Wi  S)Nzmime-parameters)reversedrF   r   )r   r,   r   r   r   r     s    zParameterizedHeaderValue.paramsc             C   sB   |  r5 |  d j  d k r5 t |  d  d  |  d  St |   j S)Nr'   zmime-parametersrI   rI   rI   )rF   r3   rD   )r   r   r   r   rD     s    zParameterizedHeaderValue.partsN)r0   r1   r2   rf   r   rD   r   r   r   r   r     s   r   c               @   s"   e  Z d  Z d Z d Z d Z d S)ContentTypezcontent-typetextZplainN)r0   r1   r2   rF   maintypesubtyper   r   r   r   r     s   r   c               @   s   e  Z d  Z d Z d Z d S)ContentDispositionzcontent-dispositionN)r0   r1   r2   rF   content_dispositionr   r   r   r   r     s   r   c               @   s   e  Z d  Z d Z d Z d S)ContentTransferEncodingzcontent-transfer-encodingZ7bitN)r0   r1   r2   rF   r   r   r   r   r   r     s   r   c               @   s   e  Z d  Z d Z d S)HeaderLabelzheader-labelN)r0   r1   r2   rF   r   r   r   r   r     s   r   c               @   s"   e  Z d  Z d Z d d   Z d S)Headerheaderc             C   s   | j  t |  j d    t | j d  | _ |  d j d k rZ t |  j d   n d | _ |  j d  } |  r t d   | j	 |  d  S)Nr   rH   r#   zMalformed Header token list)
r   r   rG   r(   r   r   rF   r   
ValueErrorr+   )r   rN   restr   r   r   r+     s    1zHeader._foldN)r0   r1   r2   rF   r+   r   r   r   r   r     s   r   c                   s   e  Z d  Z   f d d   Z   f d d   Z e d d    Z d   f d d	  Z d
 d   Z d d   Z	 d d   Z
 e d d    Z d d   Z d d   Z   S)Terminalc                s+   t    j |  |  } | | _ g  | _ | S)N)r4   __new__rF   r5   )clsr   rF   r   )r8   r   r   r     s    		zTerminal.__new__c                s   d j  |  j j t   j    S)Nz{}({}))r<   r8   r0   r4   r=   )r   )r8   r   r   r=     s    zTerminal.__repr__c             C   s   t  |  j  S)N)listr5   )r   r   r   r   r>     s    zTerminal.all_defectsr#   c                sI   d j  | |  j j |  j t   j   |  j s3 d n d j  |  j   g S)Nz{}{}/{}({}){}r#   z {})r<   r8   r0   rF   r4   r=   r5   )r   r`   )r8   r   r   rb     s    	zTerminal._ppc             C   sJ   t  |   } y | j d  | SWn" t k
 rE t j | |  SYn Xd  S)Nzus-ascii)r   rQ   rZ   rP   )r   rR   r   r   r   r   r   rU     s    zTerminal.cte_encodec             C   s   d  S)Nr   )r   r   r   r   rA     s    zTerminal.pop_trailing_wsc             C   s   d  S)Nr   )r   r   r   r   r*     s    zTerminal.pop_leading_fwsc             C   s   g  S)Nr   )r   r   r   r   rL     s    zTerminal.commentsc             C   s   d S)NFr   )r   r   r   r   rK     s    zTerminal.has_leading_commentc             C   s   t  |   |  j f S)N)r   rF   )r   r   r   r   __getnewargs__  s    zTerminal.__getnewargs__)r0   r1   r2   r   r=   rf   r>   rb   rU   rA   r*   rL   rK   r   r   r   )r8   r   r     s   	r   c               @   s4   e  Z d  Z e d d    Z d d   Z d Z d S)WhiteSpaceTerminalc             C   s   d S)Nrh   r   )r   r   r   r   r     s    zWhiteSpaceTerminal.valuec             C   s   d S)NTr   )r   r   r   r   r@     s    z!WhiteSpaceTerminal.startswith_fwsTN)r0   r1   r2   rf   r   r@   r)   r   r   r   r   r     s   r   c               @   s@   e  Z d  Z e d d    Z d d   Z d Z d d   Z d S)	ValueTerminalc             C   s   |  S)Nr   )r   r   r   r   r     s    zValueTerminal.valuec             C   s   d S)NFr   )r   r   r   r   r@     s    zValueTerminal.startswith_fwsFc             C   s   t  j t |   |  S)N)rP   rQ   r   )r   rR   r   r   r   rT     s    zValueTerminal.as_encoded_wordN)r0   r1   r2   rf   r   r@   r)   rT   r   r   r   r   r     s   r   c               @   sF   e  Z d  Z e d d    Z e d d    Z d d   Z d Z d S)	EWWhiteSpaceTerminalc             C   s   d S)Nr#   r   )r   r   r   r   r   #  s    zEWWhiteSpaceTerminal.valuec             C   s   |  d  d   S)Nr   )r   r   r   r   r   '  s    zEWWhiteSpaceTerminal.encodedc             C   s   d S)Nr#   r   )r   r   r   r   r%   +  s    zEWWhiteSpaceTerminal.__str__TN)r0   r1   r2   rf   r   r   r%   r)   r   r   r   r   r   !  s   r   r   ,zlist-separatorr   zroute-component-markerz([{}]+)r#   z[^{}]+r   z\\]z\]z[\x00-\x20\x7F]c             C   sW   t  |   } | r+ |  j j t j |   t j |   rS |  j j t j d   d S)z@If input token contains ASCII non-printables, register a defect.z*Non-ASCII characters found in header tokenN)_non_printable_finderr5   r   r   ZNonPrintableDefectr   r   rX   )xtextZnon_printablesr   r   r   _validate_xtextY  s    r   c             C   s   t  |  d  ^ } } g  } d } d } x t t |   D]e } | | d k rn | re d } d } n	 d } q: | r} d } n | | | k r P| j | |  q: W| d } d j |  d j | | d  g |  | f S)ak  Scan printables/quoted-pairs until endchars and return unquoted ptext.

    This function turns a run of qcontent, ccontent-without-comments, or
    dtext-with-quoted-printables into a single string by unquoting any
    quoted printables.  It returns the string, the remaining value, and
    a flag that is True iff there were any quoted printables decoded.

    r'   Fr   Tr#   N)_wsp_splitterranger(   r   r$   )r   endcharsZfragmentry   Zvcharsescapehad_qpposr   r   r   _get_ptext_to_endcharsc  s$    			
r   c             C   s?   |  j    } t |  d t |   t |   d  } | | f S)zFWS = 1*WSP

    This isn't the RFC definition.  We're using fws to represent tokens where
    folding can be done, but when we are parsing the *un*folding has already
    been done so we don't need to watch out for CRLF.

    NrE   )r   r   r(   )r   ZnewvaluerE   r   r   r   get_fws  s    )r   c             C   s<  t    } |  j d  s0 t j d j |     |  d d  j d d  ^ } } | |  d d  k r t j d j |     d j |  } t |  d k r | d t k r | d t k r | j d d  ^ } } | d | } t | j    d k r| j	 j
 t j d	   |  | _ d j |  }  y' t j d | d  \ } } } }	 Wn- t k
 rt j d
 j | j    Yn X| | _ | | _ | j	 j |	  x | r1| d t k rt |  \ }
 } | j
 |
  qt | d  ^ } } t | d  } t |  | j
 |  d j |  } qW| |  f S)zE encoded-word = "=?" charset "?" encoding "?" encoded-text "?="

    z=?z"expected encoded word but found {}r   Nz?=r'   r#   r   zwhitespace inside encoded wordz!encoded word format invalid: '{}'vtext)r   
startswithr   HeaderParseErrorr<   r   r$   r(   r   r5   r   r   r   rP   r   r   rR   r   r   WSPr   r   r   r   )r   Zewr   ry   Zremstrr   r   rR   r   r5   r,   charsr   r   r   r   get_encoded_word  sH    	"2
	'			
r  c             C   so  t    } x_|  rj|  d t k rD t |   \ } }  | j |  q |  j d  ry t |   \ } }  Wn t j k
 r Yn Xd } t |  d k r | d j	 d k r | j
 j t j d   d } | rt |  d k r| d j	 d	 k rt | d d  | d <| j |  q t |  d  ^ } } t | d
  } t |  | j |  d j |  }  q W| S)aO  unstructured = (*([FWS] vchar) *WSP) / obs-unstruct
       obs-unstruct = *((*LF *CR *(obs-utext) *LF *CR)) / FWS)
       obs-utext = %d0 / obs-NO-WS-CTL / LF / CR

       obs-NO-WS-CTL is control characters except WSP/CR/LF.

    So, basically, we have printable runs, plus control characters or nulls in
    the obsolete syntax, separated by whitespace.  Since RFC 2047 uses the
    obsolete syntax in its specification, but requires whitespace on either
    side of the encoded words, I can see no reason to need to separate the
    non-printable-non-whitespace from the printable runs if they occur, so we
    parse this into xtext tokens separated by WSP tokens.

    Because an 'unstructured' value must by definition constitute the entire
    value, this 'get' routine does not return a remaining value, only the
    parsed TokenList.

    r   z=?Tr'   rE   z&missing whitespace before encoded wordFr   zencoded-wordr   r#   rI   rI   rI   )rl   r  r   r   r   r  r   r   r(   rF   r5   r   r   r   r   r   r$   )r   rm   r,   Zhave_wsr   ry   r   r   r   r   rn     s:    		

rn   c             C   s;   t  |  d  \ } }  } t | d  } t |  | |  f S)a  ctext = <printable ascii except \ ( )>

    This is not the RFC ctext, since we are handling nested comments in comment
    and unquoting quoted-pairs here.  We allow anything except the '()'
    characters, but if we find any ASCII other than the RFC defined printable
    ASCII, a NonPrintableDefect is added to the token's defects list.  Since
    quoted pairs are converted to their unquoted values, what is returned is
    a 'ptext' token.  In this case it is a WhiteSpaceTerminal, so it's value
    is ' '.

    z()r   )r   r   r   )r   r   _r   r   r   get_qp_ctext  s    
r  c             C   s;   t  |  d  \ } }  } t | d  } t |  | |  f S)ao  qcontent = qtext / quoted-pair

    We allow anything except the DQUOTE character, but if we find any ASCII
    other than the RFC defined printable ASCII, a NonPrintableDefect is
    added to the token's defects list.  Any quoted pairs are converted to their
    unquoted values, so what is returned is a 'ptext' token.  In this case it
    is a ValueTerminal.

    r   r   )r   r   r   )r   r   r  r   r   r   get_qcontent   s    

r  c             C   so   t  |   } | s* t j d j |     | j   } |  t |  d  }  t | d  } t |  | |  f S)zatext = <matches _atext_matcher>

    We allow any non-ATOM_ENDS in atext, but add an InvalidATextDefect to
    the token's defects list if we find non-atext characters.
    zexpected atext but found '{}'Natext)_non_atom_end_matcherr   r   r<   r   r(   r   r   )r   mr  r   r   r   	get_atext  s    
r  c             C   sQ  |  d d k r( t  j d j |     t   } |  d d  }  x |  r|  d d k r|  d t k r t |   \ } }  n |  d d  d k r y/ t |   \ } }  | j j t  j	 d   Wqt  j k
 r t
 |   \ } }  YqXn t
 |   \ } }  | j |  qD W|  s=| j j t  j	 d	   | |  f S| |  d d  f S)
zbare-quoted-string = DQUOTE *([FWS] qcontent) [FWS] DQUOTE

    A quoted-string without the leading or trailing white space.  Its
    value is the text between the quote marks, with whitespace
    preserved and quoted pairs decoded.
    r   r   zexpected '"' but found '{}'r'   Nr   z=?z!encoded word inside quoted stringz"end of header inside quoted string)r   r   r<   r   r  r   r  r5   r   r   r  )r   Zbare_quoted_stringr,   r   r   r   get_bare_quoted_string  s,    	

r  c             C   s
  |  r. |  d d k r. t  j d j |     t   } |  d d  }  x |  r |  d d k r |  d t k r t |   \ } }  n7 |  d d k r t |   \ } }  n t |   \ } }  | j |  qJ W|  s | j	 j t  j
 d   | |  f S| |  d d  f S)zcomment = "(" *([FWS] ccontent) [FWS] ")"
       ccontent = ctext / quoted-pair / comment

    We handle nested comments here, and quoted-pair in our qp-ctext routine.
    r   r   zexpected '(' but found '{}'r'   Nr   zend of header inside comment)r   r   r<   r   r  r   get_commentr  r   r5   r   )r   ri   r,   r   r   r   r  >  s"    	

r  c             C   st   t    } x^ |  ri |  d t k ri |  d t k rG t |   \ } }  n t |   \ } }  | j |  q W| |  f S)z,CFWS = (1*([FWS] comment) [FWS]) / FWS

    r   )r|   CFWS_LEADERr  r   r  r   )r   rH   r,   r   r   r   get_cfwsW  s    	r  c             C   s   t    } |  r> |  d t k r> t |   \ } }  | j |  t |   \ } }  | j |  |  r |  d t k r t |   \ } }  | j |  | |  f S)zquoted-string = [CFWS] <bare-quoted-string> [CFWS]

    'bare-quoted-string' is an intermediate class defined by this
    parser and not by the RFC grammar.  It is the quoted string
    without any attached CFWS.
    r   )r   r  r  r   r  )r   Zquoted_stringr,   r   r   r   get_quoted_stringd  s    	r  c             C   s  t    } |  r> |  d t k r> t |   \ } }  | j |  |  rl |  d t k rl t j d j |     |  j d  r y t	 |   \ } }  Wq t j k
 r t
 |   \ } }  Yq Xn t
 |   \ } }  | j |  |  r|  d t k rt |   \ } }  | j |  | |  f S)zPatom = [CFWS] 1*atext [CFWS]

    An atom could be an rfc2047 encoded word.
    r   zexpected atom but found '{}'z=?)r~   r  r  r   	ATOM_ENDSr   r   r<   r   r  r  )r   r   r,   r   r   r   get_atomv  s$    	r  c             C   s   t    } |  s  |  d t k r8 t j d j |     xl |  r |  d t k r t |   \ } }  | j |  |  r; |  d d k r; | j t  |  d d  }  q; W| d t k r t j d j d |     | |  f S)z( dot-text = 1*atext *("." 1*atext)

    r   z8expected atom at a start of dot-atom-text but found '{}'r	   r'   Nz4expected atom at end of dot-atom-text but found '{}'rI   )r   r  r   r   r<   r  r   r   )r   Zdot_atom_textr,   r   r   r   get_dot_atom_text  s    	r  c             C   s   t    } |  d t k r8 t |   \ } }  | j |  |  j d  r y t |   \ } }  Wq t j k
 r t |   \ } }  Yq Xn t |   \ } }  | j |  |  r |  d t k r t |   \ } }  | j |  | |  f S)z dot-atom = [CFWS] dot-atom-text [CFWS]

    Any place we can have a dot atom, we could instead have an rfc2047 encoded
    word.
    r   z=?)	r   r  r  r   r   r  r   r   r  )r   Zdot_atomr,   r   r   r   get_dot_atom  s    	r  c             C   s   |  d t  k r% t |   \ } }  n d } |  d d k rP t |   \ } }  n= |  d t k r{ t j d j |     n t |   \ } }  | d k	 r | g | d d  <| |  f S)a  word = atom / quoted-string

    Either atom or quoted-string may start with CFWS.  We have to peel off this
    CFWS first to determine which type of word to parse.  Afterward we splice
    the leading CFWS, if any, into the parsed sub-token.

    If neither an atom or a quoted-string is found before the next special, a
    HeaderParseError is raised.

    The token returned is either an Atom or a QuotedString, as appropriate.
    This means the 'word' level of the formal grammar is not represented in the
    parse tree; this is because having that extra layer when manipulating the
    parse tree is more confusing than it is helpful.

    r   Nr   z1Expected 'atom' or 'quoted-string' but found '{}')r  r  r  SPECIALSr   r   r<   r  )r   leaderr,   r   r   r   get_word  s    r  c             C   sI  t    } y# t |   \ } }  | j |  Wn. t j k
 r\ | j j t j d   Yn Xx |  r>|  d t k r>|  d d k r | j t  | j j t j	 d   |  d d  }  q` y t |   \ } }  WnV t j k
 r-|  d t
 k r&t |   \ } }  | j j t j	 d   n   Yn X| j |  q` W| |  f S)a   phrase = 1*word / obs-phrase
        obs-phrase = word *(word / "." / CFWS)

    This means a phrase can be a sequence of words, periods, and CFWS in any
    order as long as it starts with at least one word.  If anything other than
    words is detected, an ObsoleteHeaderDefect is added to the token's defect
    list.  We also accept a phrase that starts with CFWS followed by a dot;
    this is registered as an InvalidHeaderDefect, since it is not supported by
    even the obsolete grammar.

    zphrase does not start with wordr   r	   zperiod in 'phrase'r'   Nzcomment found without atom)rv   r  r   r   r   r5   r   PHRASE_ENDSr   ObsoleteHeaderDefectr  r  )r   rw   r,   r   r   r   
get_phrase  s.    	
r  c             C   s  t    } d } |  d t k r1 t |   \ } }  |  sO t j d j |     y t |   \ } }  Wno t j k
 r y t |   \ } }  WnA t j k
 r |  d d k r |  d t k r   t	   } Yn XYn X| d k	 r | g | d d  <| j
 |  |  r|  d d k s)|  d t k rt t |  |   \ } }  | j d k rp| j j
 t j d   n | j j
 t j d   | | d <y | j j d  Wn+ t k
 r| j j
 t j d	   Yn X| |  f S)
z= local-part = dot-atom / quoted-string / obs-local-part

    Nr   z"expected local-part but found '{}'r   zinvalid-obs-local-partz<local-part is not dot-atom, quoted-string, or obs-local-partz,local-part is not a dot-atom (contains CFWS)rV   z)local-part contains non-ASCII characters))r   r  r  r   r   r<   r  r  r  r3   r   get_obs_local_partr   rF   r5   r   r  r   rQ   rZ   ZNonASCIILocalPartDefect)r   r   r  r,   obs_local_partr   r   r   get_local_part  sB    	 &

r  c             C   sH  t    } d } xv|  r|  d d k s8 |  d t k r|  d d k r | rg | j j t j d   | j t  d } |  d d  }  q n\ |  d d k r | j t |  d d	   |  d d  }  | j j t j d
   d } q | r| d j d k r| j j t j d   y t	 |   \ } }  d } Wn: t j
 k
 rv|  d t k r`  t |   \ } }  Yn X| j |  q W| d j d k s| d j d k r| d j d k r| j j t j d   | d j d k s| d j d k r,| d j d k r,| j j t j d   | j r>d | _ | |  f S)z' obs-local-part = word *("." word)
    Fr   r   r	   zinvalid repeated '.'Tr'   Nzmisplaced-specialz/'\' character outside of quoted-string/ccontentr   zmissing '.' between wordsrH   z!Invalid leading '.' in local partr   z"Invalid trailing '.' in local partzinvalid-obs-local-partrI   rI   rI   r  )r   r  r5   r   r   r   r   r   rF   r  r   r  r  )r   r  Zlast_non_ws_was_dotr,   r   r   r   r  )  sV    	)






		r  c             C   sZ   t  |  d  \ } }  } t | d  } | rF | j j t j d   t |  | |  f S)a   dtext = <printable ascii except \ [ ]> / obs-dtext
        obs-dtext = obs-NO-WS-CTL / quoted-pair

    We allow anything except the excluded characters, but if we find any
    ASCII other than the RFC defined printable ASCII, a NonPrintableDefect is
    added to the token's defects list.  Quoted pairs are converted to their
    unquoted values, so what is returned is a ptext token, in this case a
    ValueTerminal.  If there were quoted-printables, an ObsoleteHeaderDefect is
    added to the returned token's defect list.

    z[]r   z(quoted printable found in domain-literal)r   r   r5   r   r   r  r   )r   r   r   r   r   r   	get_dtextX  s    

r  c             C   s:   |  r
 d S| j  t j d   | j  t d d   d S)NFz"end of input inside domain-literalr   zdomain-literal-endT)r   r   r   r   )r   domain_literalr   r   r   _check_for_early_dl_endl  s    
r   c             C   s  t    } |  d t k r8 t |   \ } }  | j |  |  sM t j d   |  d d k ru t j d j |     |  d d  }  t |  |  r | |  f S| j t d d   |  d t	 k r t
 |   \ } }  | j |  t |   \ } }  | j |  t |  |  r| |  f S|  d t	 k rJt
 |   \ } }  | j |  t |  |  rc| |  f S|  d d k rt j d	 j |     | j t d d
   |  d d  }  |  r|  d t k rt |   \ } }  | j |  | |  f S)zB domain-literal = [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]

    r   zexpected domain-literal[z6expected '[' at start of domain-literal but found '{}'r'   Nzdomain-literal-startr   z4expected ']' at end of domain-literal but found '{}'zdomain-literal-end)r   r  r  r   r   r   r<   r   r   r  r   r  )r   r  r,   r   r   r   get_domain_literalt  sD    	


r"  c             C   s  t    } d } |  d t k r1 t |   \ } }  |  sO t j d j |     |  d d k r t |   \ } }  | d k	 r | g | d d  <| j |  | |  f Sy t |   \ } }  Wn' t j k
 r t	 |   \ } }  Yn X| d k	 r| g | d d  <| j |  |  r|  d d k r| j
 j t j d   | d j d k ri| d | d d  <xP |  r|  d d k r| j t  t	 |  d d   \ } }  | j |  qlW| |  f S)	z] domain = dot-atom / domain-literal / obs-domain
        obs-domain = atom *("." atom))

    Nr   zexpected domain but found '{}'r!  r	   z(domain is not a dot-atom (contains CFWS)zdot-atomr'   )r   r  r  r   r   r<   r"  r   r  r  r5   r  rF   r   )r   r   r  r,   r   r   r   
get_domain  s<    	

r#  c             C   s   t    } t |   \ } }  | j |  |  s? |  d d k rb | j j t j d   | |  f S| j t d d   t |  d d   \ } }  | j |  | |  f S)z( addr-spec = local-part "@" domain

    r   r   z"add-spec local part with no domainzaddress-at-symbolr'   N)r   r  r   r5   r   r   r   r#  )r   r   r,   r   r   r   get_addr_spec  s    	

r$  c             C   s  t    } x |  r |  d d k s2 |  d t k r |  d t k rd t |   \ } }  | j |  q |  d d k r | j t  |  d d  }  q W|  s |  d d k r t j d j |     | j t  t	 |  d d   \ } }  | j |  x |  r|  d d k r| j t  |  d d  }  |  s7P|  d t k rft |   \ } }  | j |  |  d d k r | j t  t	 |  d d   \ } }  | j |  q W|  st j d   |  d d k rt j d	 j |     | j t
 d d
   | |  d d  f S)z obs-route = obs-domain-list ":"
        obs-domain-list = *(CFWS / ",") "@" domain *("," [CFWS] ["@" domain])

        Returns an obs-route token with the appropriate sub-tokens (that is,
        there is no obs-domain-list in the parse tree).
    r   r   r'   Nr   z(expected obs-route domain but found '{}'z%end of header while parsing obs-route:z4expected ':' marking end of obs-route but found '{}'zend-of-obs-route-marker)r   r  r  r   ListSeparatorr   r   r<   RouteComponentMarkerr#  r   )r   Z	obs_router,   r   r   r   get_obs_route  sB    	)r(  c             C   s6  t    } |  d t k r8 t |   \ } }  | j |  |  sO |  d d k rg t j d j |     | j t d d   |  d d  }  |  d d k r | j t d d   | j j t j	 d	   |  d d  }  | |  f Sy t
 |   \ } }  Wn t j k
 ry/ t |   \ } }  | j j t j d
   Wn- t j k
 rmt j d j |     Yn X| j |  t
 |   \ } }  Yn X| j |  |  r|  d d k r|  d d  }  n | j j t j	 d   | j t d d   |  r,|  d t k r,t |   \ } }  | j |  | |  f S)z angle-addr = [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
        obs-angle-addr = [CFWS] "<" obs-route addr-spec ">" [CFWS]

    r   <z"expected angle-addr but found '{}'zangle-addr-startr'   N>zangle-addr-endznull addr-spec in angle-addrz*obsolete route specification in angle-addrz.expected addr-spec or obs-route but found '{}'z"missing trailing '>' on angle-addr)r   r  r  r   r   r   r<   r   r5   r   r$  r(  r  )r   Z
angle_addrr,   r   r   r   get_angle_addr  sJ    	


r+  c             C   sR   t    } t |   \ } }  | j | d d   | j d d  | _ | |  f S)z display-name = phrase

    Because this is simply a name-rule, we don't return a display-name
    token containing a phrase, but rather a display-name token with
    the content of the phrase.

    N)r   r  r   r5   )r   r   r,   r   r   r   get_display_name&  s
    	r,  c             C   s5  t    } d } |  d t k rO t |   \ } }  |  sO t j d j |    |  d d k r |  d t k r t j d j |     t |   \ } }  |  s t j d j |    | d k	 r | g | d d d  <d } | j |  t	 |   \ } }  | d k	 r| g | d d  <| j |  | |  f S)z, name-addr = [display-name] angle-addr

    Nr   z!expected name-addr but found '{}'r)  )
r   r  r  r   r   r<   r  r,  r   r+  )r   Z	name_addrr  r,   r   r   r   get_name_addr5  s0    	r-  c             C   s   t    } y t |   \ } }  Wn[ t j k
 r| y t |   \ } }  Wn- t j k
 rw t j d j |     Yn XYn Xt d d   | j D  r d | _ | j	 |  | |  f S)z& mailbox = name-addr / addr-spec

    zexpected mailbox but found '{}'c             s   s!   |  ] } t  | t j  Vq d  S)N)rW   r   r   )r9   r:   r   r   r   r;   b  s   zget_mailbox.<locals>.<genexpr>zinvalid-mailbox)
r   r-  r   r   r$  r<   r[   r>   rF   r   )r   r   r,   r   r   r   get_mailboxS  s    		r.  c             C   s   t    } xv |  r |  d | k r |  d t k r_ | j t |  d d   |  d d  }  q t |   \ } }  | j |  q W| |  f S)z Read everything up to one of the chars in endchars.

    This is outside the formal grammar.  The InvalidMailbox TokenList that is
    returned acts like a Mailbox, but the data attributes are None.

    r   zmisplaced-specialr'   N)r   r  r   r   r  )r   r   Zinvalid_mailboxr,   r   r   r   get_invalid_mailboxh  s    	
r/  c             C   sM  t    } x7|  rB|  d d k rBy# t |   \ } }  | j |  Wn`t j k
 rd } |  d t k rt |   \ } }  |  s |  d d k r | j |  | j j t j d   qt	 |  d  \ } }  | d k	 r | g | d d  <| j |  | j j t j
 d   n |  d d k rI| j j t j d   nZ t	 |  d  \ } }  | d k	 r}| g | d d  <| j |  | j j t j
 d   Yn X|  r|  d d k r| d
 } d	 | _ t	 |  d  \ } }  | j |  | j j t j
 d   |  r |  d d k r | j t  |  d d  }  q W| |  f S)aJ   mailbox-list = (mailbox *("," mailbox)) / obs-mbox-list
        obs-mbox-list = *([CFWS] ",") mailbox *("," [mailbox / CFWS])

    For this routine we go outside the formal grammar in order to improve error
    handling.  We recognize the end of the mailbox list only at the end of the
    value or at a ';' (the group terminator).  This is so that we can turn
    invalid mailboxes into InvalidMailbox tokens and continue parsing any
    remaining valid mailboxes.  We also allow all mailbox entries to be null,
    and this condition is handled appropriately at a higher level.

    r   ;Nz,;zempty element in mailbox-listzinvalid mailbox in mailbox-listr   r'   zinvalid-mailboxrI   )r   r.  r   r   r   r  r  r5   r  r/  r   rF   r   r&  )r   Zmailbox_listr,   r  r   r   r   r   get_mailbox_listz  sN    	
	
r1  c             C   sc  t    } |  s2 | j j t j d   | |  f Sd } |  r |  d t k r t |   \ } }  |  s | j j t j d   | j |  | |  f S|  d d k r | j |  | |  f St |   \ } }  t | j	  d k r-| d k	 r | j |  | j
 |  | j j t j d   | |  f S| d k	 rL| g | d d  <| j |  | |  f S)zg group-list = mailbox-list / CFWS / obs-group-list
        obs-group-list = 1*([CFWS] ",") [CFWS]

    zend of header before group-listNr   zend of header in group-listr0  zgroup-list with empty entries)r   r5   r   r   r   r  r  r1  r(   r   r   r  )r   Z
group_listr  r,   r   r   r   get_group_list  s8    	






r2  c             C   s  t    } t |   \ } }  |  s2 |  d d k rJ t j d j |     | j |  | j t d d   |  d d  }  |  r |  d d k r | j t d d   | |  d d  f St |   \ } }  | j |  |  s | j j t j	 d	   |  d d k r#t j d
 j |     | j t d d   |  d d  }  |  r~|  d t
 k r~t |   \ } }  | j |  | |  f S)z7 group = display-name ":" [group-list] ";" [CFWS]

    r   r%  z8expected ':' at end of group display name but found '{}'zgroup-display-name-terminatorr'   Nr0  zgroup-terminatorzend of header in groupz)expected ';' at end of group but found {})r   r,  r   r   r<   r   r   r2  r5   r   r  r  )r   r   r,   r   r   r   	get_group  s2    	
r3  c             C   s   t    } y t |   \ } }  Wn[ t j k
 r| y t |   \ } }  Wn- t j k
 rw t j d j |     Yn XYn X| j |  | |  f S)a   address = mailbox / group

    Note that counter-intuitively, an address can be either a single address or
    a list of addresses (a group).  This is why the returned Address object has
    a 'mailboxes' attribute which treats a single address as a list of length
    one.  When you need to differentiate between to two cases, extract the single
    element, which is either a mailbox or a group token.

    zexpected address but found '{}')r   r3  r   r   r.  r<   r   )r   r   r,   r   r   r   get_address  s    	r4  c             C   s_  t    } xI|  rTy# t |   \ } }  | j |  Wnt j k
 r} zbd } |  d t k rt |   \ } }  |  s |  d d k r | j |  | j j t j d   qt	 |  d  \ } }  | d k	 r | g | d d  <| j t
 | g   | j j t j d   n |  d d k rG| j j t j d   nc t	 |  d  \ } }  | d k	 r{| g | d d  <| j t
 | g   | j j t j d   WYd d } ~ Xn X|  r%|  d d k r%| d
 d } d | _ t	 |  d  \ } }  | j |  | j j t j d   |  r | j t d d	   |  d d  }  q W| |  f S)a   address_list = (address *("," address)) / obs-addr-list
        obs-addr-list = *([CFWS] ",") address *("," [address / CFWS])

    We depart from the formal grammar here by continuing to parse until the end
    of the input, assuming the input to be entirely composed of an
    address-list.  This is always true in email parsing, and allows us
    to skip invalid addresses to parse additional valid ones.

    Nr   r   z"address-list entry with no contentzinvalid address in address-listzempty element in address-listr'   zinvalid-mailboxzlist-separatorrI   )r   r4  r   r   r   r  r  r5   r  r/  r   r   rF   r   r   )r   Zaddress_listr,   errr  r   r   r   r   get_address_list	  sN    
			
r6  c             C   ss  t    } |  s, | j j t j d   | S|  d t k rz t |   \ } }  | j |  |  sz | j j t j d   d } xH |  r |  d d k r |  d t k r | |  d 7} |  d d  }  q W| j   s| j j t j d j	 |    | j t
 | d	   n% t |  | _ | j t
 | d
   |  rl|  d t k rlt |   \ } }  | j |  |  s|  d d k r| j d k	 r| j j t j d   |  r| j t
 |  d	   | S| j t
 d d   |  d d  }  |  r&|  d t k r&t |   \ } }  | j |  |  sX| j d k	 rT| j j t j d   | Sd } x8 |  r|  d t k r| |  d 7} |  d d  }  qaW| j   s| j j t j d j	 |    | j t
 | d	   n% t |  | _ | j t
 | d
   |  r:|  d t k r:t |   \ } }  | j |  |  ro| j j t j d   | j t
 |  d	   | S)zE mime-version = [CFWS] 1*digit [CFWS] "." [CFWS] 1*digit [CFWS]

    z%Missing MIME version number (eg: 1.0)r   z0Expected MIME version number but found only CFWSr#   r	   r'   Nz1Expected MIME major version number but found {!r}r   digitsz0Incomplete MIME version; found only major numberzversion-separatorz1Expected MIME minor version number but found {!r}z'Excess non-CFWS text after MIME version)r   r5   r   r   HeaderMissingRequiredValuer  r  isdigitr   r<   r   intr   r   )r   Zmime_versionr,   r7  r   r   r   parse_mime_versionQ	  sv    	

)


r;  c             C   s   t    } xv |  r |  d d k r |  d t k r_ | j t |  d d   |  d d  }  q t |   \ } }  | j |  q W| |  f S)z Read everything up to the next ';'.

    This is outside the formal grammar.  The InvalidParameter TokenList that is
    returned acts like a Parameter, but the data attributes are None.

    r   r0  zmisplaced-specialr'   N)r   r  r   r   r  )r   Zinvalid_parameterr,   r   r   r   get_invalid_parameter	  s    	
r<  c             C   so   t  |   } | s* t j d j |     | j   } |  t |  d  }  t | d  } t |  | |  f S)a8  ttext = <matches _ttext_matcher>

    We allow any non-TOKEN_ENDS in ttext, but add defects to the token's
    defects list if we find non-ttext characters.  We also register defects for
    *any* non-printables even though the RFC doesn't exclude all of them,
    because we follow the spirit of RFC 5322.

    zexpected ttext but found '{}'Nttext)_non_token_end_matcherr   r   r<   r   r(   r   r   )r   r
  r=  r   r   r   	get_ttext	  s    	
r?  c             C   s   t    } |  r> |  d t k r> t |   \ } }  | j |  |  rl |  d t k rl t j d j |     t |   \ } }  | j |  |  r |  d t k r t |   \ } }  | j |  | |  f S)ztoken = [CFWS] 1*ttext [CFWS]

    The RFC equivalent of ttext is any US-ASCII chars except space, ctls, or
    tspecials.  We also exclude tabs even though the RFC doesn't.

    The RFC implies the CFWS but is not explicit about it in the BNF.

    r   zexpected token but found '{}')	r   r  r  r   
TOKEN_ENDSr   r   r<   r?  )r   Zmtokenr,   r   r   r   	get_token	  s    		rA  c             C   so   t  |   } | s* t j d j |     | j   } |  t |  d  }  t | d  } t |  | |  f S)aQ  attrtext = 1*(any non-ATTRIBUTE_ENDS character)

    We allow any non-ATTRIBUTE_ENDS in attrtext, but add defects to the
    token's defects list if we find non-attrtext characters.  We also register
    defects for *any* non-printables even though the RFC doesn't exclude all of
    them, because we follow the spirit of RFC 5322.

    z expected attrtext but found {!r}Nr   )_non_attribute_end_matcherr   r   r<   r   r(   r   r   )r   r
  r   r   r   r   get_attrtext	  s    	
rC  c             C   s   t    } |  r> |  d t k r> t |   \ } }  | j |  |  rl |  d t k rl t j d j |     t |   \ } }  | j |  |  r |  d t k r t |   \ } }  | j |  | |  f S)aH   [CFWS] 1*attrtext [CFWS]

    This version of the BNF makes the CFWS explicit, and as usual we use a
    value terminal for the actual run of characters.  The RFC equivalent of
    attrtext is the token characters, with the subtraction of '*', "'", and '%'.
    We include tab in the excluded set just as we do for token.

    r   zexpected token but found '{}')	r   r  r  r   ATTRIBUTE_ENDSr   r   r<   rC  )r   r   r,   r   r   r   get_attribute	  s    		rE  c             C   so   t  |   } | s* t j d j |     | j   } |  t |  d  }  t | d  } t |  | |  f S)zattrtext = 1*(any non-ATTRIBUTE_ENDS character plus '%')

    This is a special parsing routine so that we get a value that
    includes % escapes as a single string (which we decode as a single
    string later).

    z)expected extended attrtext but found {!r}Nzextended-attrtext)#_non_extended_attribute_end_matcherr   r   r<   r   r(   r   r   )r   r
  r   r   r   r   get_extended_attrtext	  s    
rG  c             C   s   t    } |  r> |  d t k r> t |   \ } }  | j |  |  rl |  d t k rl t j d j |     t |   \ } }  | j |  |  r |  d t k r t |   \ } }  | j |  | |  f S)z [CFWS] 1*extended_attrtext [CFWS]

    This is like the non-extended version except we allow % characters, so that
    we can pick up an encoded value as a single string.

    r   zexpected token but found '{}')	r   r  r  r   EXTENDED_ATTRIBUTE_ENDSr   r   r<   rG  )r   r   r,   r   r   r   get_extended_attribute
  s    	rI  c             C   s3  t    } |  s  |  d d k r8 t j d j |     | j t d d   |  d d  }  |  sv |  d j   r t j d j |     d } x8 |  r |  d j   r | |  d 7} |  d d  }  q W| d d	 k r| d	 k r| j j t j d
   t	 |  | _
 | j t | d   | |  f S)a6   '*' digits

    The formal BNF is more complicated because leading 0s are not allowed.  We
    check for that and add a defect.  We also assume no CFWS is allowed between
    the '*' and the digits, though the RFC is not crystal clear on that.
    The caller should already have dealt with leading CFWS.

    r   *zExpected section but found {}zsection-markerr'   Nz$Expected section number but found {}r#   0z&section numberhas an invalid leading 0r7  )r   r   r   r<   r   r   r9  r5   ZInvalidHeaderErrorr:  r   )r   r   r7  r   r   r   get_section#
  s$    		rL  c             C   s   t    } |  s t j d   d } |  d t k rF t |   \ } }  |  sd t j d j |    |  d d k r t |   \ } }  n t |   \ } }  | d k	 r | g | d d  <| j |  | |  f S)z  quoted-string / attribute

    z&Expected value but found end of stringNr   z Expected value but found only {}r   )	r   r   r   r  r  r<   r  rI  r   )r   vr  r,   r   r   r   	get_valueA
  s     	rN  c             C   s  t    } t |   \ } }  | j |  |  s? |  d d k rk | j j t j d j |    | |  f S|  d d k ry, t |   \ } }  d | _ | j |  Wn t j	 k
 r Yn X|  s t j	 d   |  d d k r| j t
 d d   |  d d	  }  d | _ |  d d
 k r2t j	 d   | j t
 d
 d   |  d d	  }  d	 } |  r|  d t k rt |   \ } }  | j |  d	 } | } | j r|  r|  d d k rt |   \ } } | j } d } | j d k r>| r| d d k rd } qkt |  \ } }	 |	 rk|	 d d k rkd } n- y t |  \ } }	 Wn Yn X|	 skd } | r| j j t j d   | j |  x4 | D], }
 |
 j d k rg  |
 d	 d	  <|
 } PqW| }  n d	 } | j j t j d   |  r|  d d k rd	 } n t |   \ } }  | j s@| j d k r|  sW|  d d k r| j |  | d	 k	 r|  st |    | }  | |  f S| j j t j d   |  s| j j t j d   | j |  | d	 k r(| |  f Sn7| d	 k	 rDx | D] }
 |
 j d k rPqW|
 j d k | j |
  |
 j | _ |  d d k rlt j	 d j |     | j t
 d d   |  d d	  }  |  r|  d d k rt |   \ } }  | j |  | j | _ |  s|  d d k rt j	 d j |     | j t
 d d   |  d d	  }  | d	 k	 rt   } xN |  r|  d t k rkt |   \ } }  n t |   \ } }  | j |  q@W| } n t |   \ } }  | j |  | d	 k	 r|  st |    | }  | |  f S)aY   attribute [section] ["*"] [CFWS] "=" value

    The CFWS is implied by the RFC but not made explicit in the BNF.  This
    simplified form of the BNF from the RFC is made to conform with the RFC BNF
    through some extra checks.  We do it this way because it makes both error
    recovery and working with the resulting parse tree easier.
    r   r0  z)Parameter contains name ({}) but no valuerJ  TzIncomplete parameterzextended-parameter-markerr'   N=zParameter not followed by '='zparameter-separatorr   F'z5Quoted string value for extended parameter is invalidzbare-quoted-stringzZParameter marked as extended but appears to have a quoted string value that is non-encodedzcApparent initial-extended-value but attribute was not marked as extended or was not initial sectionz(Missing required charset/lang delimiterszextended-attrtextr   z=Expected RFC2231 char/lang encoding delimiter, but found {!r}zRFC2231 delimiterz;Expected RFC2231 char/lang encoding delimiter, but found {})r   rE  r   r5   r   r   r<   rL  r   r   r   r   r  r  r  r   r   rC  rG  rF   rN  AssertionErrorr   rR   r   r   r  r   r  )r   r   r,   r  ry   ZappendtoZqstringZinner_valueZ
semi_validr   trM  r   r   r   get_parameterW
  s    	
					
	
	


			rS  c             C   s  t    } x|  ry# t |   \ } }  | j |  Wnt j k
 r=} z d } |  d t k ru t |   \ } }  |  s | j |  | S|  d d k r | d k	 r | j |  | j j t j d   nZ t	 |   \ } }  | r | g | d d  <| j |  | j j t j d j
 |    WYd d } ~ Xn X|  r|  d d k r| d
 } d | _ t	 |   \ } }  | j |  | j j t j d j
 |    |  r | j t d d	   |  d d  }  q W| S)a!   parameter *( ";" parameter )

    That BNF is meant to indicate this routine should only be called after
    finding and handling the leading ';'.  There is no corresponding rule in
    the formal RFC grammar, but it is more convenient for us for the set of
    parameters to be treated as its own TokenList.

    This is 'parse' routine because it consumes the reminaing value, but it
    would never be called to parse a full header.  Instead it is called to
    parse everything after the non-parameter value of a specific MIME header.

    Nr   r0  zparameter entry with no contentzinvalid parameter {!r}r'   zinvalid-parameterz)parameter with invalid trailing text {!r}zparameter-separatorrI   )r   rS  r   r   r   r  r  r5   r   r<  r<   rF   r   r   )r   Zmime_parametersr,   r5  r  r   r   r   r   parse_mime_parameters
  sD    		&
	rT  c             C   s   xv | rx | d d k rx | d t  k rV |  j t | d d   | d d  } q t |  \ } } |  j |  q W| s d S|  j t d d   |  j t | d d    d S)zBDo our best to find the parameters in an invalid MIME header

    r   r0  zmisplaced-specialr'   Nzparameter-separator)r  r   r   r  rT  )Z	tokenlistr   r,   r   r   r   _find_mime_parameters  s    rU  c             C   s;  t    } d } |  s2 | j j t j d   | Sy t |   \ } }  WnH t j k
 r | j j t j d j |     t	 | |   | SYn X| j |  |  s |  d d k r | j j t j d   |  r t	 | |   | S| j
 j   j   | _ | j t d d   |  d d	  }  y t |   \ } }  WnH t j k
 r| j j t j d
 j |     t	 | |   | SYn X| j |  | j
 j   j   | _ |  s| S|  d d k r| j j t j d j |     | ` | ` t	 | |   | S| j t d d   | j t |  d d	    | S)z maintype "/" subtype *( ";" parameter )

    The maintype and substype are tokens.  Theoretically they could
    be checked against the official IANA list + x-token, but we
    don't do that.
    Fz"Missing content type specificationz(Expected content maintype but found {!r}r   /zInvalid content typezcontent-type-separatorr'   Nz'Expected content subtype but found {!r}r0  z<Only parameters are valid after content type, but found {!r}zparameter-separator)r   r5   r   r   r8  rA  r   r   r<   rU  r   r   lowerr   r   r   rT  )r   ZctypeZrecoverr,   r   r   r   parse_content_type_header&  sX    	
	
	rX  c             C   s6  t    } |  s, | j j t j d   | Sy t |   \ } }  WnH t j k
 r | j j t j d j |     t	 | |   | SYn X| j |  | j
 j   j   | _ |  s | S|  d d k r | j j t j d j |     t	 | |   | S| j t d d   | j t |  d d    | S)	z* disposition-type *( ";" parameter )

    zMissing content dispositionz+Expected content disposition but found {!r}r   r0  zCOnly parameters are valid after content disposition, but found {!r}zparameter-separatorr'   N)r   r5   r   r   r8  rA  r   r   r<   rU  r   r   rW  r   r   rT  )r   Zdisp_headerr,   r   r   r    parse_content_disposition_header_  s2    	
	rY  c             C   s1  t    } |  s, | j j t j d   | Sy t |   \ } }  Wn7 t j k
 r{ | j j t j d j |     Yn& X| j |  | j	 j
   j   | _ |  s | Sx |  r,| j j t j d   |  d t k r
| j t |  d d   |  d d  }  q t |   \ } }  | j |  q W| S)z mechanism

    z!Missing content transfer encodingz1Expected content transfer encoding but found {!r}z*Extra text after content transfer encodingr   zmisplaced-specialr'   N)r   r5   r   r   r8  rA  r   r   r<   r   r   rW  r   r  r   r  )r   Z
cte_headerr,   r   r   r   &parse_content_transfer_encoding_header}  s.    	
	
rZ  )__doc__rer   stringr   collectionsr   operatorr   Zemailr   rP   r   r   r   r  r  r  r  r   r  Z	TSPECIALSr@  Z	ASPECIALSrD  rH  r   r   r   r3   rg   rl   rv   r{   r|   r~   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r&  r'  compiler<   r$   r   r   r   matchr	  findallr   r>  rB  rF  r   r   r   r  rn   r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r   r"  r#  r$  r(  r+  r,  r-  r.  r/  r1  r2  r3  r4  r6  r;  r<  r?  rA  rC  rE  rG  rI  rL  rN  rS  rT  rU  rX  rY  rZ  r   r   r   r   <module>D   s
  


TK`		 '#
U3$000!
*8&'/'$).9%>D49                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
[/C                 @   sx  d  Z  d d d d g Z d d l Z d d l Z d Z d Z d	 Z d
 d d d d d d d d d d d d d d d d d d d d d d d  g Z d! d" d# d$ d% d& d' g Z d( d d) d d* d d+ d d, d- d. d/ d0 d1 d2 d- d3 d4 d5 d1 d6 d7 d8 d4 d9 d: d; d7 i Z	 d< d   Z
 d= d>   Z d? d   Z d@ d   Z dA d   Z GdB dC   dC  Z GdD dE   dE e  Z d S)FzcEmail address parsing code.

Lifted directly from rfc822.py.  This should eventually be rewritten.
	mktime_tz	parsedateparsedate_tzquote    N  z, ZjanZfebZmarZaprZmayZjunZjulZaugsepoctZnovZdecZjanuaryZfebruaryZmarchZaprilZjuneZjulyZaugustZ	septemberZoctoberZnovemberZdecemberZmonZtueZwedZthuZfriZsatZsunZUTZUTCZGMTZZASTi  ZADTi,  ZESTi  ZEDTZCSTiX  ZCDTZMSTi  ZMDTZPSTi   ZPDTc             C   s:   t  |   } | s d S| d d k r0 d | d <t |  S)zQConvert a date string to a time tuple.

    Accounts for military timezones.
    N	   r   )_parsedate_tztuple)dataZres r   &/usr/lib/python3.5/email/_parseaddr.pyr   -   s    
c             C   s  |  s
 d S|  j    }  |  d j d  s? |  d j   t k rI |  d =n; |  d j d  } | d k r |  d | d d  |  d <t |   d k r |  d j  d  } t |  d k r | |  d d  }  t |   d k r[|  d } | j d  } | d k r| j d  } | d k rN| d |  | | d  g |  d d  <n |  j d	  t |   d
 k  rqd S|  d d
  }  |  \ } } } } } | j   } | t k r| | j   } } | t k rd St j	 |  d } | d k r| d 8} | d d k r| d d  } | j d  } | d k rB| | } } | d d k rb| d d  } | d j
   s| | } } | d d k r| d d  } | j  d  } t |  d k r| \ }	 }
 d } n t |  d k r| \ }	 }
 } n t |  d k ryd | d k ry| d j  d  } t |  d k rU| \ }	 }
 d } q}t |  d k r}| \ }	 }
 } n d Sy@ t |  } t |  } t |	  }	 t |
  }
 t |  } Wn t k
 rd SYn X| d k  r| d k r| d 7} n
 | d 7} d } | j   } | t k r0t | } nF y t |  } Wn t k
 rTYn X| d k rv| j d  rvd } | r| d k  rd } | } n d } | | d d | d d } | | | |	 |
 | d d d | g
 S)a  Convert date to extended time tuple.

    The last (additional) element is the time zone offset in seconds, except if
    the timezone was specified as -0000.  In that case the last element is
    None.  This indicates a UTC timestamp that explicitly declaims knowledge of
    the source timezone, as opposed to a +0000 timestamp that indicates the
    source timezone really was UTC.

    Nr   ,      -   +r         :   0.d   D   il  i  i  <   r    r    r    r    r    r    r    r    )splitendswithlower	_daynamesrfindlenfindappend_monthnamesindexisdigitint
ValueErrorupper
_timezones
startswith)r   iZstuffsZddZmmZyyZtmZtzZthhZtmmZtssZtzoffsetZtzsignr   r   r   r   9   s    
)

-
	"		

r   c             C   s1   t  |   } t | t  r) | d d  S| Sd S)z&Convert a time string to a time tuple.Nr   )r   
isinstancer   )r   tr   r   r   r      s    c             C   sJ   |  d d k r+ t  j |  d d  d  St j |   } | |  d Sd S)zETurn a 10-tuple as returned by parsedate_tz() into a POSIX timestamp.r   N   r   r    )r    )timeZmktimecalendarZtimegm)r   r4   r   r   r   r      s    c             C   s   |  j  d d  j  d d  S)zPrepare string to be used in a quoted string.

    Turns backslash and double quote characters into quoted pairs.  These
    are the only characters that need to be quoted inside a quoted string.
    Does not add the surrounding double quotes.
    \z\\"z\")replace)strr   r   r   r      s    c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d d  Z d d   Z d d   Z d d   Z d d d  Z d d   Z d S)AddrlistClassa  Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of RFC 2822 in
    front of you.

    Note: this class interface is deprecated and may be removed in the future.
    Use email.utils.AddressList instead.
    c             C   s   d |  _  d |  _ d |  _ d |  _ |  j |  j |  _ |  j  |  j |  j |  _ |  j j d d  |  _ | |  _ g  |  _	 d S)zInitialize a new instance.

        `field' is an unparsed address header field, containing
        one or more addresses.
        z()<>@,:;."[]r   z 	z
r   r   N)
specialsposLWSZCRFWSatomendsr:   
phraseendsfieldcommentlist)selfrC   r   r   r   __init__   s    					zAddrlistClass.__init__c             C   s   g  } x |  j  t |  j  k  r |  j |  j  |  j d k r} |  j |  j  d k rk | j |  j |  j   |  j  d 7_  q	 |  j |  j  d k r |  j j |  j    q	 Pq	 Wt j |  S)z&Skip white space and extract comments.z
r   ()	r>   r&   rC   r?   r(   rD   
getcommentEMPTYSTRINGjoin)rE   Zwslistr   r   r   gotonext   s    zAddrlistClass.gotonextc             C   sU   g  } xH |  j  t |  j  k  rP |  j   } | r@ | | 7} q	 | j d  q	 W| S)zVParse all addresses.

        Returns a list containing all of the addresses.
        r   )r   r   )r>   r&   rC   
getaddressr(   )rE   resultZadr   r   r   getaddrlist   s    zAddrlistClass.getaddrlistc             C   s  g  |  _  |  j   |  j } |  j  } |  j   } |  j   g  } |  j t |  j  k r | rGt j |  j   | d f g } n|  j |  j d k r | |  _ | |  _  |  j   } t j |  j   | f g } nt|  j |  j d k r~g  } t |  j  } |  j d 7_ x7|  j t |  j  k  rz|  j   |  j | k  rg|  j |  j d k rg|  j d 7_ P| |  j	   } qWn |  j |  j d k r|  j
   } |  j  rt j |  d d j |  j   d	 | f g } qGt j |  | f g } nP | rt j |  j   | d f g } n( |  j |  j |  j k rG|  j d 7_ |  j   |  j t |  j  k  r|  j |  j d
 k r|  j d 7_ | S)zParse the next address.r   z.@r   r   ;<z (r   )r   )rD   rK   r>   getphraselistr&   rC   SPACErJ   getaddrspecrL   getrouteaddrr=   )rE   ZoldposZoldclplistZ
returnlistZaddrspecZfieldlenZ	routeaddrr   r   r   rL     sL    	
		
"		
%	3"
.zAddrlistClass.getaddressc             C   s   |  j  |  j d k r d Sd } |  j d 7_ |  j   d } x |  j t |  j   k  r| rs |  j   d } n |  j  |  j d k r |  j d 7_ Pnr |  j  |  j d k r |  j d 7_ d } nD |  j  |  j d	 k r |  j d 7_ n |  j   } |  j d 7_ P|  j   qB W| S)
zParse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        rP   NFr   r   >@Tr   )rC   r>   rK   r&   	getdomainrT   )rE   ZexpectrouteZadlistr   r   r   rU   ?  s.    

		zAddrlistClass.getrouteaddrc             C   s  g  } |  j    x*|  j t |  j  k  r<d } |  j |  j d k r | rh | d j   rh | j   | j d  |  j d 7_ d } n |  j |  j d k r | j d t |  j     nQ |  j |  j |  j	 k r| r | d	 j   r | j   Pn | j |  j
    |  j    } | r | r | j |  q W|  j t |  j  k sk|  j |  j d k rxt j |  S| j d  |  j d 7_ |  j    t j |  |  j   S)
zParse an RFC 2822 addr-spec.Tr   r   Fr9   z"%s"rX   r    r    )rK   r>   r&   rC   strippopr(   r   getquoterA   getatomrI   rJ   rY   )rE   ZaslistZpreserve_wsZwsr   r   r   rT   _  s4    

	 
.
zAddrlistClass.getaddrspecc             C   s  g  } x|  j  t |  j  k  r|  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k r{ |  j j |  j    q	 |  j |  j  d k r | j |  j    q	 |  j |  j  d k r |  j  d 7_  | j d  q	 |  j |  j  |  j k r Pq	 | j |  j	    q	 Wt
 j |  S)z-Get the complete domain name from an address.r   rG   [r   )r>   r&   rC   r?   rD   r(   rH   getdomainliteralrA   r]   rI   rJ   )rE   Zsdlistr   r   r   rY     s    zAddrlistClass.getdomainTc             C   s-  |  j  |  j | k r d Sd g } d } |  j d 7_ x |  j t |  j   k  r| ry | j |  j  |  j  d } n |  j  |  j | k r |  j d 7_ Pnk | r |  j  |  j d k r | j |  j    q; n6 |  j  |  j d k r d } n | j |  j  |  j  |  j d 7_ q; Wt j |  S)a  Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.
        If self is not looking at an instance of `beginchar' then
        getdelimited returns the empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        r   Fr   rG   r8   T)rC   r>   r&   r(   rH   rI   rJ   )rE   Z	begincharZendcharsZallowcommentsZslistr   r   r   r   getdelimited  s(    			zAddrlistClass.getdelimitedc             C   s   |  j  d d d  S)z1Get a quote-delimited fragment from self's field.r9   z"F)r`   )rE   r   r   r   r\     s    zAddrlistClass.getquotec             C   s   |  j  d d d  S)z7Get a parenthesis-delimited fragment from self's field.rG   z)T)r`   )rE   r   r   r   rH     s    zAddrlistClass.getcommentc             C   s   d |  j  d d d  S)z!Parse an RFC 2822 domain-literal.z[%s]r^   z]F)r`   )rE   r   r   r   r_     s    zAddrlistClass.getdomainliteralNc             C   s   d g } | d k r |  j  } x\ |  j t |  j  k  r| |  j |  j | k rS Pn | j |  j |  j  |  j d 7_ q! Wt j |  S)a  Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases).r   Nr   )rA   r>   r&   rC   r(   rI   rJ   )rE   rA   Zatomlistr   r   r   r]     s    		zAddrlistClass.getatomc             C   s   g  } x |  j  t |  j  k  r |  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k rx | j |  j    q	 |  j |  j  d k r |  j j |  j    q	 |  j |  j  |  j k r Pq	 | j |  j	 |  j   q	 W| S)zParse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        r   r9   rG   )
r>   r&   rC   r@   r(   r\   rD   rH   rB   r]   )rE   rV   r   r   r   rR     s    zAddrlistClass.getphraselist)__name__
__module____qualname____doc__rF   rK   rN   rL   rU   rT   rY   r`   r\   rH   r_   r]   rR   r   r   r   r   r<      s   ; !%r<   c               @   sj   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d S)AddressListz@An AddressList encapsulates a list of parsed RFC 2822 addresses.c             C   s5   t  j |  |  | r( |  j   |  _ n	 g  |  _ d  S)N)r<   rF   rN   addresslist)rE   rC   r   r   r   rF     s    zAddressList.__init__c             C   s   t  |  j  S)N)r&   rf   )rE   r   r   r   __len__  s    zAddressList.__len__c             C   sY   t  d   } |  j d  d   | _ x0 | j D]% } | |  j k r, | j j |  q, W| S)N)re   rf   r(   )rE   othernewaddrxr   r   r   __add__  s    zAddressList.__add__c             C   s7   x0 | j  D]% } | |  j  k r
 |  j  j |  q
 W|  S)N)rf   r(   )rE   rh   rj   r   r   r   __iadd__  s    zAddressList.__iadd__c             C   sC   t  d   } x0 |  j D]% } | | j k r | j j |  q W| S)N)re   rf   r(   )rE   rh   ri   rj   r   r   r   __sub__  s
    zAddressList.__sub__c             C   s7   x0 | j  D]% } | |  j  k r
 |  j  j |  q
 W|  S)N)rf   remove)rE   rh   rj   r   r   r   __isub__  s    zAddressList.__isub__c             C   s   |  j  | S)N)rf   )rE   r*   r   r   r   __getitem__  s    zAddressList.__getitem__N)ra   rb   rc   rd   rF   rg   rk   rl   rm   ro   rp   r   r   r   r   re     s   	re   )rd   __all__r6   r7   rS   rI   Z
COMMASPACEr)   r$   r/   r   r   r   r   r   r<   re   r   r   r   r   <module>   s6   	u	

 %                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
[P9                 @   s   d  Z  d d l Z d d l m Z d d l m Z d d l m Z d d d g Z Gd	 d
   d
  Z	 d d   Z
 d d   Z Gd d   d e	 d e j Z e Gd d   d e   Z e   Z d S)zwPolicy framework for the email package.

Allows fine grained feature control of how the package parses and emits data.
    N)header)charset)_has_surrogatesPolicyCompat32compat32c                   sX   e  Z d  Z d Z   f d d   Z d d   Z d d   Z d d	   Z d
 d   Z   S)_PolicyBasea  Policy Object basic framework.

    This class is useless unless subclassed.  A subclass should define
    class attributes with defaults for any values that are to be
    managed by the Policy object.  The constructor will then allow
    non-default values to be set for these attributes at instance
    creation time.  The instance will be callable, taking these same
    attributes keyword arguments, and returning a new instance
    identical to the called instance except for those values changed
    by the keyword arguments.  Instances may be added, yielding new
    instances with any non-default values from the right hand
    operand overriding those in the left hand operand.  That is,

        A + B == A(<non-default values of B>)

    The repr of an instance can be used to reconstruct the object
    if and only if the repr of the values can be used to reconstruct
    those values.

    c                sj   xc | j    D]U \ } } t |  |  rD t t |   j | |  q t d j | |  j j    q Wd S)zCreate new Policy, possibly overriding some defaults.

        See class docstring for a list of overridable attributes.

        z*{!r} is an invalid keyword argument for {}N)	itemshasattrsuperr   __setattr__	TypeErrorformat	__class____name__)selfkwnamevalue)r    '/usr/lib/python3.5/email/_policybase.py__init__)   s    z_PolicyBase.__init__c             C   s;   d d   |  j  j   D } d j |  j j d j |   S)Nc             S   s(   g  |  ] \ } } d  j  | |   q S)z{}={!r})r   ).0r   r   r   r   r   
<listcomp>8   s   	z(_PolicyBase.__repr__.<locals>.<listcomp>z{}({})z, )__dict__r	   r   r   r   join)r   argsr   r   r   __repr__7   s    	z_PolicyBase.__repr__c             K   s   |  j  j |  j   } x0 |  j j   D] \ } } t j | | |  q% WxZ | j   D]L \ } } t |  |  s t d j | |  j  j	    t j | | |  qU W| S)zReturn a new instance with specified attributes changed.

        The new instance has the same attribute values as the current object,
        except for the changes passed in as keyword arguments.

        z*{!r} is an invalid keyword argument for {})
r   __new__r   r	   objectr   r
   r   r   r   )r   r   Z	newpolicyattrr   r   r   r   clone<   s    z_PolicyBase.clonec             C   s@   t  |  |  r d } n d } t | j |  j j |    d  S)Nz'{!r} object attribute {!r} is read-onlyz!{!r} object has no attribute {!r})r
   AttributeErrorr   r   r   )r   r   r   msgr   r   r   r   N   s    	z_PolicyBase.__setattr__c             C   s   |  j  | j   S)zNon-default values from right operand override those from left.

        The object returned is a new instance of the subclass.

        )r!   r   )r   otherr   r   r   __add__U   s    z_PolicyBase.__add__)	r   
__module____qualname____doc__r   r   r!   r   r%   r   r   )r   r   r      s   r   c             C   s8   |  j  d d  d }  | j d d  d } |  d | S)N
   r   )rsplitsplit)docZ	added_docr   r   r   _append_doc^   s    r.   c             C   s   |  j  r: |  j  j d  r: t |  j d j  |  j   |  _  x |  j j   D]| \ } } | j  rJ | j  j d  rJ xR d d   |  j D D]: } t t | |  d  } | r t | | j   | _  Pq WqJ W|  S)N+r   c             s   s(   |  ] } | j    D] } | Vq q d  S)N)mro)r   basecr   r   r   	<genexpr>h   s    z%_extend_docstrings.<locals>.<genexpr>r(   )r(   
startswithr.   	__bases__r   r	   getattr)clsr   r    r2   r-   r   r   r   _extend_docstringsc   s    	r8   c               @   s   e  Z d  Z d Z d Z d Z d Z d Z d Z d d   Z	 d d	   Z
 d
 d   Z e j d d    Z e j d d    Z e j d d    Z e j d d    Z e j d d    Z d S)r   a  Controls for how messages are interpreted and formatted.

    Most of the classes and many of the methods in the email package accept
    Policy objects as parameters.  A Policy object contains a set of values and
    functions that control how input is interpreted and how output is rendered.
    For example, the parameter 'raise_on_defect' controls whether or not an RFC
    violation results in an error being raised or not, while 'max_line_length'
    controls the maximum length of output lines when a Message is serialized.

    Any valid attribute may be overridden when a Policy is created by passing
    it as a keyword argument to the constructor.  Policy objects are immutable,
    but a new Policy object can be created with only certain values changed by
    calling the Policy instance with keyword arguments.  Policy objects can
    also be added, producing a new Policy object in which the non-default
    attributes set in the right hand operand overwrite those specified in the
    left operand.

    Settable attributes:

    raise_on_defect     -- If true, then defects should be raised as errors.
                           Default: False.

    linesep             -- string containing the value to use as separation
                           between output lines.  Default '\n'.

    cte_type            -- Type of allowed content transfer encodings

                           7bit  -- ASCII only
                           8bit  -- Content-Transfer-Encoding: 8bit is allowed

                           Default: 8bit.  Also controls the disposition of
                           (RFC invalid) binary data in headers; see the
                           documentation of the binary_fold method.

    max_line_length     -- maximum length of lines, excluding 'linesep',
                           during serialization.  None or 0 means no line
                           wrapping is done.  Default is 78.

    mangle_from_        -- a flag that, when True escapes From_ lines in the
                           body of the message by putting a `>' in front of
                           them. This is used when the message is being
                           serialized by a generator. Default: True.

    Fr)   Z8bitN   c             C   s#   |  j  r |  |  j | |  d S)aZ  Based on policy, either raise defect or call register_defect.

            handle_defect(obj, defect)

        defect should be a Defect subclass, but in any case must be an
        Exception subclass.  obj is the object on which the defect should be
        registered if it is not raised.  If the raise_on_defect is True, the
        defect is raised as an error, otherwise the object and the defect are
        passed to register_defect.

        This method is intended to be called by parsers that discover defects.
        The email package parsers always call it with Defect instances.

        N)raise_on_defectregister_defect)r   objdefectr   r   r   handle_defect   s    	zPolicy.handle_defectc             C   s   | j  j |  d S)a  Record 'defect' on 'obj'.

        Called by handle_defect if raise_on_defect is False.  This method is
        part of the Policy API so that Policy subclasses can implement custom
        defect handling.  The default implementation calls the append method of
        the defects attribute of obj.  The objects used by the email package by
        default that get passed to this method will always have a defects
        attribute with an append method.

        N)Zdefectsappend)r   r<   r=   r   r   r   r;      s    zPolicy.register_defectc             C   s   d S)a[  Return the maximum allowed number of headers named 'name'.

        Called when a header is added to a Message object.  If the returned
        value is not 0 or None, and there are already a number of headers with
        the name 'name' equal to the value returned, a ValueError is raised.

        Because the default behavior of Message's __setitem__ is to append the
        value to the list of headers, it is easy to create duplicate headers
        without realizing it.  This method allows certain headers to be limited
        in the number of instances of that header that may be added to a
        Message programmatically.  (The limit is not observed by the parser,
        which will faithfully produce as many headers as exist in the message
        being parsed.)

        The default implementation returns None for all header names.
        Nr   )r   r   r   r   r   header_max_count   s    zPolicy.header_max_countc             C   s
   t   d S)aZ  Given a list of linesep terminated strings constituting the lines of
        a single header, return the (name, value) tuple that should be stored
        in the model.  The input lines should retain their terminating linesep
        characters.  The lines passed in by the email package may contain
        surrogateescaped binary data.
        N)NotImplementedError)r   sourcelinesr   r   r   header_source_parse   s    zPolicy.header_source_parsec             C   s
   t   d S)zGiven the header name and the value provided by the application
        program, return the (name, value) that should be stored in the model.
        N)rA   )r   r   r   r   r   r   header_store_parse   s    zPolicy.header_store_parsec             C   s
   t   d S)aw  Given the header name and the value from the model, return the value
        to be returned to the application program that is requesting that
        header.  The value passed in by the email package may contain
        surrogateescaped binary data if the lines were parsed by a BytesParser.
        The returned value should not contain any surrogateescaped data.

        N)rA   )r   r   r   r   r   r   header_fetch_parse   s    	zPolicy.header_fetch_parsec             C   s
   t   d S)a  Given the header name and the value from the model, return a string
        containing linesep characters that implement the folding of the header
        according to the policy controls.  The value passed in by the email
        package may contain surrogateescaped binary data if the lines were
        parsed by a BytesParser.  The returned value should not contain any
        surrogateescaped data.

        N)rA   )r   r   r   r   r   r   fold   s    
zPolicy.foldc             C   s
   t   d S)a%  Given the header name and the value from the model, return binary
        data containing linesep characters that implement the folding of the
        header according to the policy controls.  The value passed in by the
        email package may contain surrogateescaped binary data.

        N)rA   )r   r   r   r   r   r   fold_binary   s    zPolicy.fold_binaryN)r   r&   r'   r(   r:   linesepcte_typemax_line_lengthmangle_from_r>   r;   r@   abcabstractmethodrC   rD   rE   rF   rG   r   r   r   r   r   p   s   -
	metaclassc               @   sp   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z	 d d   Z
 d d   Z d S)r   z+
    This particular policy is the backward compatibility Policy.  It
    replicates the behavior of the email package version 5.1.
    Tc             C   sC   t  | t  s | St |  r; t j | d t j d | S| Sd  S)Nr   header_name)
isinstancestrr   r   Header_charsetUNKNOWN8BIT)r   r   r   r   r   r   _sanitize_header  s    zCompat32._sanitize_headerc             C   sU   | d j  d d  \ } } | j d  d j | d d   } | | j d  f S)a:  +
        The name is parsed as everything up to the ':' and returned unmodified.
        The value is determined by stripping leading whitespace off the
        remainder of the first line, joining all subsequent lines together, and
        stripping any trailing carriage return or linefeed characters.

        r   :r*   z 	 Nz
)r,   lstripr   rstrip)r   rB   r   r   r   r   r   rC   !  s    &zCompat32.header_source_parsec             C   s
   | | f S)z>+
        The name and value are returned unmodified.
        r   )r   r   r   r   r   r   rD   -  s    zCompat32.header_store_parsec             C   s   |  j  | |  S)z+
        If the value contains binary data, it is converted into a Header object
        using the unknown-8bit charset.  Otherwise it is returned unmodified.
        )rU   )r   r   r   r   r   r   rE   3  s    zCompat32.header_fetch_parsec             C   s   |  j  | | d d S)a  +
        Headers are folded using the Header folding algorithm, which preserves
        existing line breaks in the value, and wraps each resulting line to the
        max_line_length.  Non-ASCII binary data are CTE encoded using the
        unknown-8bit charset.

        sanitizeT)_fold)r   r   r   r   r   r   rF   :  s    zCompat32.foldc             C   s1   |  j  | | d |  j d k } | j d d  S)a  +
        Headers are folded using the Header folding algorithm, which preserves
        existing line breaks in the value, and wraps each resulting line to the
        max_line_length.  If cte_type is 7bit, non-ascii binary data is CTE
        encoded using the unknown-8bit charset.  Otherwise the original source
        header is used, with its existing line breaks and/or binary data.

        rZ   Z7bitasciisurrogateescape)r[   rI   encode)r   r   r   Zfoldedr   r   r   rG   D  s    	!zCompat32.fold_binaryc             C   s   g  } | j  d |  t | t  r t |  ro | rY t j | d t j d | } q | j  |  d  } q t j | d | } n | } | d  k	 r | j  | j d |  j	 d |  j
   | j  |  j	  d j |  S)Nz%s: r   rO   rH   Z
maxlinelenrW   )r?   rP   rQ   r   r   rR   rS   rT   r^   rH   rJ   r   )r   r   r   rZ   partshr   r   r   r[   P  s"    		zCompat32._foldN)r   r&   r'   r(   rK   rU   rC   rD   rE   rF   rG   r[   r   r   r   r   r     s   
)r(   rL   Zemailr   r   rS   Zemail.utilsr   __all__r   r.   r8   ABCMetar   r   r   r   r   r   r   <module>   s   	Lb                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
[B              0   @   s  d  d d d g Z  d d l m Z d d l Z d d l Z d d l m Z d d l m Z d	 Z	 d
 Z
 d Z d Z d Z d Z d Z d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d e	 e	 d f d dE d e
 e
 d f d e
 e
 d f d e
 d d f d  e
 d d f d e
 d d f d! e
 e
 d f d" e e
 d" f i Z d# d d$ d d% d d& d d' d d( d d) d d* d d+ d d, d d- d d. d d/ d d0 d d1 d d2 d d3 d d4 d d5 d d6 d d7 d8 d9 d d: d; d< d i Z d d= d d> d d i Z d d d d? d  Z d@ d   Z dA d   Z dB dC   Z GdD d    d   Z d S)FCharset	add_aliasadd_charset	add_codec    )partialN)errors)encode_7or8bit            zus-asciizunknown-8bit z
iso-8859-1z
iso-8859-2z
iso-8859-3z
iso-8859-4z
iso-8859-9ziso-8859-10ziso-8859-13ziso-8859-14ziso-8859-15ziso-8859-16zwindows-1252Zvisciibig5gb2312zeuc-jpziso-2022-jp	shift_jiszkoi8-rzutf-8latin_1zlatin-1Zlatin_2zlatin-2Zlatin_3zlatin-3Zlatin_4zlatin-4Zlatin_5zlatin-5Zlatin_6zlatin-6Zlatin_7zlatin-7Zlatin_8zlatin-8Zlatin_9zlatin-9Zlatin_10zlatin-10cp949zks_c_5601-1987euc_jpeuc_krzeuc-krasciieucgb2312_cnbig5_twc             C   s/   | t  k r t d   | | | f t |  <d S)a>  Add character set properties to the global registry.

    charset is the input character set, and must be the canonical name of a
    character set.

    Optional header_enc and body_enc is either Charset.QP for
    quoted-printable, Charset.BASE64 for base64 encoding, Charset.SHORTEST for
    the shortest of qp or base64 encoding, or None for no encoding.  SHORTEST
    is only valid for header_enc.  It describes how message headers and
    message bodies in the input charset are to be encoded.  Default is no
    encoding.

    Optional output_charset is the character set that the output should be
    in.  Conversions will proceed from input charset, to Unicode, to the
    output charset when the method Charset.convert() is called.  The default
    is to output in the same character set as the input.

    Both input_charset and output_charset must have Unicode codec entries in
    the module's charset-to-codec mapping; use add_codec(charset, codecname)
    to add codecs the module does not know about.  See the codecs module's
    documentation for more information.
    z!SHORTEST not allowed for body_encN)SHORTEST
ValueErrorCHARSETS)charsetZ
header_encZbody_encoutput_charset r   #/usr/lib/python3.5/email/charset.pyr   m   s    c             C   s   | t  |  <d S)zAdd a character set alias.

    alias is the alias name, e.g. latin-1
    canonical is the character set's canonical name, e.g. iso-8859-1
    N)ALIASES)aliasZ	canonicalr   r   r   r      s    c             C   s   | t  |  <d S)a$  Add a codec that map characters in the given charset to/from Unicode.

    charset is the canonical name of a character set.  codecname is the name
    of a Python codec, as appropriate for the second argument to the unicode()
    built-in, or to the encode() method of a Unicode string.
    N)	CODEC_MAP)r   Z	codecnamer   r   r   r      s    c             C   s-   | t  k r |  j d d  S|  j |  Sd  S)Nr   surrogateescape)UNKNOWN8BITencode)stringcodecr   r   r   _encode   s    r'   c               @   s   e  Z d  Z d Z e d d  Z d d   Z e Z d d   Z d d	   Z	 d
 d   Z
 d d   Z d d   Z d d   Z d d   Z d S)r   a@	  Map character sets to their email properties.

    This class provides information about the requirements imposed on email
    for a specific character set.  It also provides convenience routines for
    converting between character sets, given the availability of the
    applicable codecs.  Given a character set, it will do its best to provide
    information on how to use that character set in an email in an
    RFC-compliant way.

    Certain character sets must be encoded with quoted-printable or base64
    when used in email headers or bodies.  Certain character sets must be
    converted outright, and are not allowed in email.  Instances of this
    module expose the following information about a character set:

    input_charset: The initial character set specified.  Common aliases
                   are converted to their `official' email names (e.g. latin_1
                   is converted to iso-8859-1).  Defaults to 7-bit us-ascii.

    header_encoding: If the character set must be encoded before it can be
                     used in an email header, this attribute will be set to
                     Charset.QP (for quoted-printable), Charset.BASE64 (for
                     base64 encoding), or Charset.SHORTEST for the shortest of
                     QP or BASE64 encoding.  Otherwise, it will be None.

    body_encoding: Same as header_encoding, but describes the encoding for the
                   mail message's body, which indeed may be different than the
                   header encoding.  Charset.SHORTEST is not allowed for
                   body_encoding.

    output_charset: Some character sets must be converted before they can be
                    used in email headers or bodies.  If the input_charset is
                    one of them, this attribute will contain the name of the
                    charset output will be converted to.  Otherwise, it will
                    be None.

    input_codec: The name of the Python codec used to convert the
                 input_charset to Unicode.  If no conversion codec is
                 necessary, this attribute will be None.

    output_codec: The name of the Python codec used to convert Unicode
                  to the output_charset.  If no conversion codec is necessary,
                  this attribute will have the same value as the input_codec.
    c             C   s  y2 t  | t  r" | j d  n t | d  } Wn! t k
 rU t j |   Yn X| j   } t j | |  |  _	 t
 j |  j	 t t d  f  \ } } } | s |  j	 } | |  _ | |  _ t j | |  |  _ t j |  j	 |  j	  |  _ t j |  j |  j  |  _ d  S)Nr   )
isinstancestrr$   UnicodeErrorr   ZCharsetErrorlowerr   getinput_charsetr   r   BASE64header_encodingbody_encodingr   r!   Zinput_codecoutput_codec)selfr-   ZhencZbencZconvr   r   r   __init__   s&    			zCharset.__init__c             C   s   |  j  j   S)N)r-   r+   )r2   r   r   r   __str__   s    zCharset.__str__c             C   s   t  |   t  |  j   k S)N)r)   r+   )r2   otherr   r   r   __eq__   s    zCharset.__eq__c             C   sC   |  j  t k s t  |  j  t k r( d S|  j  t k r; d St Sd S)aP  Return the content-transfer-encoding used for body encoding.

        This is either the string `quoted-printable' or `base64' depending on
        the encoding used, or it is a function in which case you should call
        the function with a single argument, the Message object being
        encoded.  The function should then set the Content-Transfer-Encoding
        header itself to whatever is appropriate.

        Returns "quoted-printable" if self.body_encoding is QP.
        Returns "base64" if self.body_encoding is BASE64.
        Returns conversion function otherwise.
        zquoted-printablebase64N)r0   r   AssertionErrorQPr.   r   )r2   r   r   r   get_body_encoding   s    zCharset.get_body_encodingc             C   s   |  j  p |  j S)zReturn the output character set.

        This is self.output_charset if that is not None, otherwise it is
        self.input_charset.
        )r   r-   )r2   r   r   r   get_output_charset  s    zCharset.get_output_charsetc             C   sM   |  j  p d } t | |  } |  j |  } | d k r= | S| j | |  S)a  Header-encode a string by converting it first to bytes.

        The type of encoding (base64 or quoted-printable) will be based on
        this charset's `header_encoding`.

        :param string: A unicode string for the header.  It must be possible
            to encode this string to bytes using the character set's
            output codec.
        :return: The encoded string, with RFC 2047 chrome.
        zus-asciiN)r1   r'   _get_encoderheader_encode)r2   r%   r&   header_bytesencoder_moduler   r   r   r=     s    zCharset.header_encodec             C   s  |  j  p d } t | |  } |  j |  } t | j d | } |  j   } t |  t } g  }	 g  }
 t |  | } x | D] } |
 j	 |  t
 j |
  } | j t | |   } | | k r |
 j   |	 r |
 r |	 j	 d  nC |	 r d n d } t
 j |
  } t | |  } |	 j	 | |   | g }
 t |  | } q Wt
 j |
  } t | |  } |	 j	 | |   |	 S)af  Header-encode a string by converting it first to bytes.

        This is similar to `header_encode()` except that the string is fit
        into maximum line lengths as given by the argument.

        :param string: A unicode string for the header.  It must be possible
            to encode this string to bytes using the character set's
            output codec.
        :param maxlengths: Maximum line length iterator.  Each element
            returned from this iterator will provide the next maximum line
            length.  This parameter is used as an argument to built-in next()
            and should never be exhausted.  The maximum line lengths should
            not count the RFC 2047 chrome.  These line lengths are only a
            hint; the splitter does the best it can.
        :return: Lines of encoded strings, each with RFC 2047 chrome.
        zus-asciir   N r   )r1   r'   r<   r   r=   r;   lenRFC2047_CHROME_LENnextappendEMPTYSTRINGjoinheader_lengthpop)r2   r%   Z
maxlengthsr&   r>   r?   encoderr   ZextralinesZcurrent_linemaxlen	characterZ	this_lineZlengthZ	separatorZjoined_liner   r   r   header_encode_lines,  s6    
	zCharset.header_encode_linesc             C   s   |  j  t k r t j S|  j  t k r, t j S|  j  t k r| t j j |  } t j j |  } | | k  rr t j St j Sn d  Sd  S)N)r/   r.   email
base64mimer9   
quoprimimer   rG   )r2   r>   Zlen64Zlenqpr   r   r   r<   j  s    
zCharset._get_encoderc             C   s   | s
 | S|  j  t k rJ t | t  r: | j |  j  } t j j |  S|  j  t	 k r t | t  rz | j |  j  } | j
 d  } t j j |  St | t  r | j |  j  j
 d  } | Sd S)av  Body-encode a string by converting it first to bytes.

        The type of encoding (base64 or quoted-printable) will be based on
        self.body_encoding.  If body_encoding is None, we assume the
        output charset is a 7bit encoding, so re-encoding the decoded
        string using the ascii codec produces the correct string version
        of the content.
        latin1r   N)r0   r.   r(   r)   r$   r   rN   rO   body_encoder9   decoderP   )r2   r%   r   r   r   rR   y  s    	zCharset.body_encodeN)__name__
__module____qualname____doc__DEFAULT_CHARSETr3   r4   __repr__r6   r:   r;   r=   rM   r<   rR   r   r   r   r   r      s   +!>)NNN)__all__	functoolsr   Zemail.base64mimerN   Zemail.quoprimimer   Zemail.encodersr   r9   r.   r   rB   rX   r#   rE   r   r   r!   r   r   r   r'   r   r   r   r   r   <module>   s   		                                                                                                                                                                                                                                                       
[                 @   sx   d  Z  d d d d g Z d d l m Z d d l m Z d d	   Z d
 d   Z	 d d   Z
 d d   Z d d   Z d S)z Encodings and related functions.encode_7or8bitencode_base64encode_noopencode_quopri    )encodebytes)encodestringc             C   s"   t  |  d d } | j d d  S)NZ	quotetabsT    s   =20)_encodestringreplace)senc r   $/usr/lib/python3.5/email/encoders.py_qencode   s    r   c             C   sB   |  j  d d  } t t |  d  } |  j |  d |  d <d S)zlEncode the message's payload in Base64.

    Also, add an appropriate Content-Transfer-Encoding header.
    decodeTasciibase64zContent-Transfer-EncodingN)get_payloadstr_bencodeset_payload)msgorigencdatar   r   r   r      s    c             C   s9   |  j  d d  } t |  } |  j |  d |  d <d S)zvEncode the message's payload in quoted-printable.

    Also, add an appropriate Content-Transfer-Encoding header.
    r   Tzquoted-printablezContent-Transfer-EncodingN)r   r   r   )r   r   r   r   r   r   r   &   s    c             C   sj   |  j  d d  } | d k r, d |  d <d Sy | j d  Wn t k
 r[ d |  d <Yn Xd |  d <d S)z9Set the Content-Transfer-Encoding header to 7bit or 8bit.r   TNZ7bitzContent-Transfer-Encodingr   Z8bit)r   r   UnicodeError)r   r   r   r   r   r   2   s    
c             C   s   d S)zDo nothing.Nr   )r   r   r   r   r   D   s    N)__doc____all__r   r   r   quoprir   r	   r   r   r   r   r   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[)              
   @   s  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l m Z Gd d   d  Z e   Z d d d  Z e j	 d e  d	 d
   Z
 x$ d j   D] Z e j	 e e
  q Wd d   Z x( d j   D] Z e j	 d e e  q Wd d   Z e j	 d e  d d   Z d d   Z d d   Z d d   Z d d d d d d d d d d  Z e j e e  d d d d d d d d  d!  Z e j e j j e  d" d d d d d d# d$  Z x' e e e f D] Z e j e e  qWd S)%    N)
quoprimimec               @   sX   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d S)ContentManagerc             C   s   i  |  _  i  |  _ d  S)N)get_handlersset_handlers)self r   */usr/lib/python3.5/email/contentmanager.py__init__	   s    	zContentManager.__init__c             C   s   | |  j  | <d  S)N)r   )r   keyhandlerr   r   r   add_get_handler   s    zContentManager.add_get_handlerc             O   s   | j    } | |  j k r2 |  j | | | |  S| j   } | |  j k rd |  j | | | |  Sd |  j k r |  j d | | |  St |   d  S)N )Zget_content_typer   get_content_maintypeKeyError)r   msgargskwZcontent_typemaintyper   r   r   get_content   s    zContentManager.get_contentc             C   s   | |  j  | <d  S)N)r   )r   Ztypekeyr   r   r   r   add_set_handler   s    zContentManager.add_set_handlerc             O   sQ   | j    d k r t d   |  j | |  } | j   | | | | |  d  S)NZ	multipartz"set_content not valid on multipart)r   	TypeError_find_set_handlerZclear_content)r   r   objr   r   r   r   r   r   set_content   s
    
zContentManager.set_contentc       	      C   s	  d  } x t  |  j D] } | |  j k r6 |  j | S| j } t | d d  } | rl d j | | f  n | } | d  k r | } | |  j k r |  j | S| |  j k r |  j | S| j } | |  j k r |  j | Sq Wd  |  j k r |  j d  St |   d  S)N
__module__r   .)type__mro__r   __qualname__getattrjoin__name__r   )	r   r   r   Zfull_path_for_errortypZqnamemodname	full_pathnamer   r   r   r   '   s&    	!	z ContentManager._find_set_handlerN)	r!   r   r   r	   r   r   r   r   r   r   r   r   r   r      s   	r   replacec             C   s7   |  j  d d  } |  j d d  } | j | d | S)NdecodeTcharsetASCIIerrors)get_payloadZ	get_paramr'   )r   r*   Zcontentr(   r   r   r   get_text_content@   s    r,   textc             C   s   |  j  d d  S)Nr'   T)r+   )r   r   r   r   get_non_text_contentG   s    r.   zaudio image video applicationc             C   s   |  j  d  S)Nr   )r+   )r   r   r   r   get_message_contentM   s    r/   zrfc822 external-bodyzmessage/c             C   s   t  |  j d   S)Nr   )bytesr+   )r   r   r   r   %get_and_fixup_unknown_message_contentS   s    r1   messagec                s   d j  | | f  |  d <| r t | d d  sT |  j     f d d   | D } y8 x1 | D]) } | j rz | j d  | |  | j <q^ WWnR t j j k
 r } z, t d j	 | j
 d |  j    |  WYd  d  } ~ Xn Xd  S)	N/zContent-Typer   r%   c                s+   g  |  ]! }   j    j | g     q Sr   )Zheader_factoryZheader_source_parse).0header)mpr   r   
<listcomp>d   s   	z _prepare_set.<locals>.<listcomp>zInvalid header: {}policy)r    hasattrr8   Zdefectsr%   emailr*   ZHeaderDefect
ValueErrorformatZfold)r   r   subtypeheadersr5   excr   )r6   r   _prepare_set_   s    	
		r@   c             C   s   | d  k r | d  k	 r d } | d  k	 r4 | |  d <| d  k	 r\ |  j  d | d d d d | d  k	 rr | |  d <| d  k	 r x* | j   D] \ } } |  j  | |  q Wd  S)NZ
attachmentzContent-Dispositionfilenamer5   r&   Tz
Content-ID)	set_paramitems)r   dispositionrA   cidparamsr
   valuer   r   r   _finalize_setp   s    
	
rH   c             C   sw   g  } | d d } xS t  d t |   |  D]9 } |  | | |  } | j t j |  j d   q- Wd j |  S)N      r   asciir   )rangelenappendbinascii
b2a_base64r'   r    )datamax_line_lengthZencoded_linesZunencoded_bytes_per_lineiZthisliner   r   r   _encode_base64   s    #rT   c                s  |  j  |  j   } | j j  d      f d d   } d d   } | d  k rVy d | |  j d  f SWn t k
 r Yn X| j d k r t d d	   | D  | j k r d | |  j d d
  f S| | d  d   } t j	 | j d  | j  } t
 j |  }	 t |  t |	  k r4d } n" d } t |  d k rV| | f S| d k rz| |  j d  }
 n | d k r| |  j d d
  }
 no | d k rt j	 | |  j d  | j  }
 n< | d k rt | |  | j  }
 n t d j |    | |
 f S)NrK   c                s     j  |     S)N)r    )lines)linesepr   r   embeded_body   s    z"_encode_text.<locals>.embeded_bodyc             S   s   d j  |   d S)Ns   
)r    )rU   r   r   r   normal_body   s    z!_encode_text.<locals>.normal_body7bit8bitc             s   s   |  ] } t  |  Vq d  S)N)rM   )r4   xr   r   r   	<genexpr>   s    z_encode_text.<locals>.<genexpr>surrogateescape
   zlatin-1base64zquoted-printablez$Unknown content transfer encoding {})encode
splitlinesrV   r'   UnicodeDecodeErrorZcte_typemaxrR   r   Zbody_encoderO   rP   rM   rT   r;   r<   )stringr(   cter8   rU   rW   rX   ZsniffZsniff_qpZsniff_base64rQ   r   )rV   r   _encode_text   s@    "	
rf   Zplainzutf-8c
             C   s   t  |  d | |	  t | | | |  j  \ } }
 |  j |
  |  j d t j j j | |  d d | |  d <t	 |  | | | |  d  S)Nr-   r(   r&   TzContent-Transfer-Encoding)
r@   rf   r8   set_payloadrB   r:   r(   ZALIASESgetrH   )r   rd   r=   r(   re   rD   rA   rE   rF   r>   Zpayloadr   r   r   set_text_content   s    	
ri   rfc822c	       	      C   s   | d k r t  d   | d k r` | d k rE t  d j |    | d  k rW d n | } nH | d k r | d k r t  d	 j |    d } n | d  k r d } t |  d
 | |  |  j | g  | |  d <t |  | | | |  d  S)Npartialz4message/partial is not supported for Message objectsrj   rY   rZ   binaryz*message/rfc822 parts do not support cte={}zexternal-bodyz1message/external-body parts do not support cte={}r2   zContent-Transfer-Encoding)NrY   rZ   rl   )NrY   )r;   r<   r@   rg   rH   )	r   r2   r=   re   rD   rA   rE   rF   r>   r   r   r   set_message_content   s$    	
rm   r_   c
       
      C   s   t  |  | | |	  | d k r: t | d |  j j } ny | d k ry t j | d d d d d d } | j d	  } n: | d
 k r | j d	  n | d k r | j d	 d  } |  j |  | |  d <t	 |  | | | |  d  S)Nr_   rR   zquoted-printableistextFr5   Z	quotetabsTrK   rY   rZ   rl   r]   zContent-Transfer-Encoding)rZ   rl   )
r@   rT   r8   rR   rO   Zb2a_qpr'   r`   rg   rH   )
r   rQ   r   r=   re   rD   rA   rE   rF   r>   r   r   r   set_bytes_content   s    !
ro   )rO   Zemail.charsetr:   Zemail.messageZemail.errorsr   r   Zraw_data_managerr,   r   r.   splitr   r/   r=   r1   r@   rH   rT   rf   ri   r   strrm   r2   ZMessagero   r0   	bytearray
memoryviewr"   r   r   r   r   <module>   sD   6			'					                                                                                                             
[                 @   s#  d  Z  Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd	 d
   d
 e e  Z Gd d   d e  Z Gd d   d e	  Z
 Gd d   d e
  Z Gd d   d e
  Z Gd d   d e
  Z Gd d   d e
  Z Gd d   d e
  Z Gd d   d e
  Z e Z Gd d   d e
  Z Gd d   d e
  Z Gd d    d  e
  Z Gd! d"   d" e
  Z Gd# d$   d$ e
  Z Gd% d&   d& e
  Z Gd' d(   d( e  Z Gd) d*   d* e  Z Gd+ d,   d, e  Z Gd- d.   d. e  Z Gd/ d0   d0 e  Z d1 S)2z email package exception classes.c               @   s   e  Z d  Z d Z d S)MessageErrorz+Base class for errors in the email package.N)__name__
__module____qualname____doc__ r   r   "/usr/lib/python3.5/email/errors.pyr      s   r   c               @   s   e  Z d  Z d Z d S)MessageParseErrorz&Base class for message parsing errors.N)r   r   r   r   r   r   r   r   r      s   r   c               @   s   e  Z d  Z d Z d S)HeaderParseErrorzError while parsing headers.N)r   r   r   r   r   r   r   r   r	      s   r	   c               @   s   e  Z d  Z d Z d S)BoundaryErrorz#Couldn't find terminating boundary.N)r   r   r   r   r   r   r   r   r
      s   r
   c               @   s   e  Z d  Z d Z d S)MultipartConversionErrorz(Conversion to a multipart is prohibited.N)r   r   r   r   r   r   r   r   r      s   r   c               @   s   e  Z d  Z d Z d S)CharsetErrorzAn illegal charset was given.N)r   r   r   r   r   r   r   r   r      s   r   c                   s+   e  Z d  Z d Z d   f d d  Z   S)MessageDefectz Base class for a message defect.Nc                s)   | d  k	 r t    j |  | |  _ d  S)N)super__init__line)selfr   )	__class__r   r   r   $   s    zMessageDefect.__init__)r   r   r   r   r   r   r   )r   r   r   !   s   r   c               @   s   e  Z d  Z d Z d S)NoBoundaryInMultipartDefectzBA message claimed to be a multipart but had no boundary parameter.N)r   r   r   r   r   r   r   r   r   )   s   r   c               @   s   e  Z d  Z d Z d S)StartBoundaryNotFoundDefectz+The claimed start boundary was never found.N)r   r   r   r   r   r   r   r   r   ,   s   r   c               @   s   e  Z d  Z d Z d S)CloseBoundaryNotFoundDefectzEA start boundary was found, but not the corresponding close boundary.N)r   r   r   r   r   r   r   r   r   /   s   r   c               @   s   e  Z d  Z d Z d S)#FirstHeaderLineIsContinuationDefectz;A message had a continuation line as its first header line.N)r   r   r   r   r   r   r   r   r   2   s   r   c               @   s   e  Z d  Z d Z d S)MisplacedEnvelopeHeaderDefectz?A 'Unix-from' header was found in the middle of a header block.N)r   r   r   r   r   r   r   r   r   5   s   r   c               @   s   e  Z d  Z d Z d S) MissingHeaderBodySeparatorDefectzEFound line with no leading whitespace and no colon before blank line.N)r   r   r   r   r   r   r   r   r   8   s   r   c               @   s   e  Z d  Z d Z d S)!MultipartInvariantViolationDefectz?A message claimed to be a multipart but no subparts were found.N)r   r   r   r   r   r   r   r   r   =   s   r   c               @   s   e  Z d  Z d Z d S)-InvalidMultipartContentTransferEncodingDefectzEAn invalid content transfer encoding was set on the multipart itself.N)r   r   r   r   r   r   r   r   r   @   s   r   c               @   s   e  Z d  Z d Z d S)UndecodableBytesDefectz0Header contained bytes that could not be decodedN)r   r   r   r   r   r   r   r   r   C   s   r   c               @   s   e  Z d  Z d Z d S)InvalidBase64PaddingDefectz/base64 encoded sequence had an incorrect lengthN)r   r   r   r   r   r   r   r   r   F   s   r   c               @   s   e  Z d  Z d Z d S)InvalidBase64CharactersDefectz=base64 encoded sequence had characters not in base64 alphabetN)r   r   r   r   r   r   r   r   r   I   s   r   c                   s(   e  Z d  Z d Z   f d d   Z   S)HeaderDefectzBase class for a header defect.c                s   t    j | |   d  S)N)r   r   )r   argskw)r   r   r   r   Q   s    zHeaderDefect.__init__)r   r   r   r   r   r   r   )r   r   r   N   s   r   c               @   s   e  Z d  Z d Z d S)InvalidHeaderDefectz+Header is not valid, message gives details.N)r   r   r   r   r   r   r   r   r!   T   s   r!   c               @   s   e  Z d  Z d Z d S)HeaderMissingRequiredValuez(A header that must have a value had noneN)r   r   r   r   r   r   r   r   r"   W   s   r"   c                   s4   e  Z d  Z d Z   f d d   Z d d   Z   S)NonPrintableDefectz8ASCII characters outside the ascii-printable range foundc                s   t    j |  | |  _ d  S)N)r   r   non_printables)r   r$   )r   r   r   r   ]   s    zNonPrintableDefect.__init__c             C   s   d j  |  j  S)Nz6the following ASCII non-printables found in header: {})formatr$   )r   r   r   r   __str__a   s    zNonPrintableDefect.__str__)r   r   r   r   r   r&   r   r   )r   r   r#   Z   s   r#   c               @   s   e  Z d  Z d Z d S)ObsoleteHeaderDefectz0Header uses syntax declared obsolete by RFC 5322N)r   r   r   r   r   r   r   r   r'   e   s   r'   c               @   s   e  Z d  Z d Z d S)NonASCIILocalPartDefectz(local_part contains non-ASCII charactersN)r   r   r   r   r   r   r   r   r(   h   s   r(   N)r   	Exceptionr   r   r	   r
   	TypeErrorr   r   
ValueErrorr   r   r   r   r   r   r   ZMalformedHeaderDefectr   r   r   r   r   r   r!   r"   r#   r'   r(   r   r   r   r   <module>   s2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[Y                 @   s  d  Z  d d g Z d d l Z d d l m Z d d l m Z d d l m Z d d l m	 Z	 d d	 l
 m Z e j d
  Z e j d  Z e j d  Z e j d  Z e j d  Z d Z d Z e   Z Gd d   d e  Z Gd d   d  Z Gd d   d e  Z d S)a  FeedParser - An email feed parser.

The feed parser implements an interface for incrementally parsing an email
message, line by line.  This has advantages for certain applications, such as
those reading email messages off a socket.

FeedParser.feed() is the primary interface for pushing new data into the
parser.  It returns when there's nothing more it can do with the available
data.  When you have no more data to push into the parser, call .close().
This completes the parsing and returns the root message object.

The other advantage of this parser is that it will never raise a parsing
exception.  Instead, when it finds something unexpected, it adds a 'defect' to
the current message.  Defects are just instances that live on the message
object's .defects attribute.

FeedParserBytesFeedParser    N)errors)message)compat32)deque)StringIOz
||
z(
||
)z
(
||
)\Zz%^(From |[\041-\071\073-\176]*:|[\t ]) 
c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d S)BufferedSubFileak  A file-ish object that can have new data loaded into it.

    You can also push and pop line-matching predicates onto a stack.  When the
    current predicate matches the current line, a false EOF response
    (i.e. empty string) is returned instead.  This lets the parser adhere to a
    simple abstraction -- it parses until EOF closes the current message.
    c             C   s4   t  d d  |  _ t   |  _ g  |  _ d |  _ d  S)Nnewliner	   F)r   _partialr   _lines	_eofstack_closed)self r   &/usr/lib/python3.5/email/feedparser.py__init__6   s    	zBufferedSubFile.__init__c             C   s   |  j  j |  d  S)N)r   append)r   Zpredr   r   r   push_eof_matcherA   s    z BufferedSubFile.push_eof_matcherc             C   s   |  j  j   S)N)r   pop)r   r   r   r   pop_eof_matcherD   s    zBufferedSubFile.pop_eof_matcherc             C   sP   |  j  j d  |  j |  j  j    |  j  j d  |  j  j   d |  _ d  S)Nr   T)r   seek	pushlines	readlinestruncater   )r   r   r   r   closeG   s
    zBufferedSubFile.closec             C   sg   |  j  s |  j r d St S|  j  j   } x7 t |  j  D]& } | |  r9 |  j  j |  d Sq9 W| S)Nr	   )r   r   NeedMoreDatapopleftreversedr   
appendleft)r   lineZateofr   r   r   readlineO   s    		zBufferedSubFile.readlinec             C   s&   | t  k	 s t  |  j j |  d  S)N)r   AssertionErrorr   r!   )r   r"   r   r   r   
unreadlinea   s    zBufferedSubFile.unreadlinec             C   s   |  j  j |  d | k r, d | k r, d S|  j  j d  |  j  j   } |  j  j d  |  j  j   | d j d  s |  j  j | j    |  j |  d S)z$Push some new data into this object.r
   Nr      )r   writer   r   r   endswithr   r   )r   datapartsr   r   r   pushf   s    zBufferedSubFile.pushc             C   s   |  j  j |  d  S)N)r   extend)r   linesr   r   r   r   {   s    zBufferedSubFile.pushlinesc             C   s   |  S)Nr   )r   r   r   r   __iter__~   s    zBufferedSubFile.__iter__c             C   s"   |  j    } | d k r t  | S)Nr	   )r#   StopIteration)r   r"   r   r   r   __next__   s    zBufferedSubFile.__next__N)__name__
__module____qualname____doc__r   r   r   r   r#   r%   r-   r   r0   r2   r   r   r   r   r   .   s   r   c               @   s   e  Z d  Z d Z d d e d d Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d S)r   zA feed-style parser of email.Npolicyc            C   s   | |  _  d |  _ | d k rK |  j  t k r< t j |  _ q t j |  _ n; | |  _ y | d |  j   Wn t k
 r d |  _ Yn Xt   |  _	 g  |  _
 |  j   j |  _ d |  _ d |  _ d |  _ d S)a  _factory is called with no arguments to create a new message obj

        The policy keyword specifies a policy object that controls a number of
        aspects of the parser's operation.  The default policy maintains
        backward compatibility.

        FNr7   T)r7   _old_style_factoryr   r   ZMessage_factoryZEmailMessage	TypeErrorr   _input	_msgstack	_parsegenr2   _parse_cur_last_headersonly)r   r9   r7   r   r   r   r      s"    						zFeedParser.__init__c             C   s   d |  _  d  S)NT)rA   )r   r   r   r   _set_headersonly   s    zFeedParser._set_headersonlyc             C   s   |  j  j |  |  j   d S)zPush more data into the parser.N)r;   r-   _call_parse)r   r+   r   r   r   feed   s    zFeedParser.feedc             C   s'   y |  j    Wn t k
 r" Yn Xd  S)N)r>   r1   )r   r   r   r   rC      s    zFeedParser._call_parsec             C   su   |  j  j   |  j   |  j   } |  j s3 t  | j   d k rq | j   rq t j	   } |  j
 j | |  | S)z<Parse all remaining data and return the root message object.	multipart)r;   r   rC   _pop_messager<   r$   get_content_maintypeZis_multipartr   Z!MultipartInvariantViolationDefectr7   handle_defect)r   rootdefectr   r   r   r      s    
zFeedParser.closec             C   s   |  j  r |  j   } n |  j d |  j  } |  j rX |  j j   d k rX | j d  |  j ru |  j d j |  |  j j |  | |  _ | |  _	 d  S)Nr7   zmultipart/digestzmessage/rfc822r'   r(   )
r8   r9   r7   r?   get_content_typeZset_default_typer<   Zattachr   r@   )r   msgr   r   r   _new_message   s    			zFeedParser._new_messagec             C   s8   |  j  j   } |  j  r+ |  j  d |  _ n	 d  |  _ | S)Nr'   r(   )r<   r   r?   )r   retvalr   r   r   rF      s
    		zFeedParser._pop_messagec             c   s  |  j    g  } x |  j D]x } | t k r4 t Vq t j |  s t j |  s t j   } |  j j	 |  j
 |  |  j j |  P| j |  q W|  j |  |  j rg  } xA |  j j   } | t k r t Vq | d k r P| j |  q W|  j
 j t j |   d  S|  j
 j   d k rx |  j j t j  x) |  j   D] } | t k ret VqKPqKW|  j   } |  j j   x( |  j j   } | t k rt VqPqWx( |  j j   } | t k rt VqPqW| d k rP|  j j |  q+Wd  S|  j
 j   d k rMx) |  j   D] } | t k r:t Vq Pq W|  j   d  S|  j
 j   d k r|  j
 j   } | d  k rt j   } |  j j	 |  j
 |  g  } x2 |  j D]' } | t k rt Vq| j |  qW|  j
 j t j |   d  S|  j
 j d d  j   d k r:t j   } |  j j	 |  j
 |  d	 | } t j d
 t j  |  d  }	 d }
 g  } d } d } x|  j j   } | t k rt Vq| d k rP|	 j |  } | r| j! d  rd } | j! d  } P|
 rf| rM| d } t" j# |  } | r8| d  t$ | j! d    | d <t j |  |  j
 _% d }
 |  j j |  qxM |  j j   } | t k rt Vqi|	 j |  } | si|  j j |  PqiW|  j j |	 j  x) |  j   D] } | t k rt VqPqW|  j& j   d k r|  j& j' } | d k r1d  |  j& _' q| d  k	 rt" j# |  } | rt$ | j! d   } | d  |  |  j& _' n\ |  j& j( } t) | t*  rt" j# |  } | r| d  t$ | j! d    } | |  j& _( |  j j   |  j   |  j
 |  _& q|
 st+  | j |  qW|
 rt j,   } |  j j	 |  j
 |  |  j
 j t j |   g  } x% |  j D] } | t k rqt VqqqqWt j |  |  j
 _' d  S| st j-   } |  j j	 |  j
 |  d  S| rd g } n g  } x2 |  j D]' } | t k rt Vq| j |  qW| ri| d } t. j |  } | ri| t$ | j! d   d   | d <t j |  |  j
 _' d  Sg  } x2 |  j D]' } | t k rt Vq| j |  qW|  j
 j t j |   d  S)Nr	   zmessage/delivery-statusr   rE   zcontent-transfer-encoding8bit7bitbinaryz--z(?P<sep>z4)(?P<end>--)?(?P<ws>[ \t]*)(?P<linesep>\r\n|\r|\n)?$TFendlinesepr'   r   )rP   rO   rQ   r(   r(   )/rM   r;   r   headerREmatchNLCREr   Z MissingHeaderBodySeparatorDefectr7   rH   r?   r%   r   _parse_headersrA   r#   Zset_payloadEMPTYSTRINGjoinrK   r   r=   rF   r   rG   Zget_boundaryZNoBoundaryInMultipartDefectgetlowerZ-InvalidMultipartContentTransferEncodingDefectrecompileescapegroup	NLCRE_eolsearchlenpreambler@   epilogueZ_payload
isinstancestrr$   ZStartBoundaryNotFoundDefectZCloseBoundaryNotFoundDefect	NLCRE_bol)r   Zheadersr"   rJ   r/   rN   rL   boundaryZ	separatorZ
boundaryreZcapturing_preamblerc   rS   Zclose_boundary_seenmoZlastlineZeolmord   rR   Zpayload	firstlineZbolmor   r   r   r=      sh   
	
	


$ 

#zFeedParser._parsegenc       	      C   s  d } g  } xt  |  D]\ } } | d d k rs | sc t j |  } |  j j |  j |  q | j |  q | r |  j j |  j j |    d g  } } | j	 d  rW| d k rt
 j |  } | r | d  t | j d    } |  j j |  q nO | t |  d k r2|  j j |  d  St j |  } |  j j j |  q | j d  } | d k rt j d  } |  j j j |  q | d k st d   | d  |  } | g } q W| r|  j j |  j j |    d  S)	Nr	   r   z 	zFrom r'   :zMissing header name.z3_parse_headers fed line with no : and no leading WS)	enumerater   Z#FirstHeaderLineIsContinuationDefectr7   rH   r?   r   Zset_rawZheader_source_parse
startswithr`   ra   rb   r_   Zset_unixfromr;   r%   ZMisplacedEnvelopeHeaderDefectZdefectsfindZInvalidHeaderDefectr$   )	r   r/   Z
lastheaderZ	lastvaluelinenor"   rJ   ri   ir   r   r   rW     sH     zFeedParser._parse_headers)r3   r4   r5   r6   r   r   rB   rD   rC   r   rM   rF   r=   rW   r   r   r   r   r      s   !c                   s(   e  Z d  Z d Z   f d d   Z   S)r   z(Like FeedParser, but feed accepts bytes.c                s    t    j | j d d   d  S)Nasciisurrogateescape)superrD   decode)r   r+   )	__class__r   r   rD     s    zBytesFeedParser.feed)r3   r4   r5   r6   rD   r   r   )ru   r   r     s   )r6   __all__r\   Zemailr   r   Zemail._policybaser   collectionsr   ior   r]   rV   rg   r`   ZNLCRE_crackrT   rX   NLobjectr   r   r   r   r   r   r   r   <module>   s&   	[                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
[W                 @   sw   d  Z  d d d g Z d d l Z d d l m Z d d   Z d d	 d  Z d
 d d d  Z d d d d d  Z d S)z1Various types of useful iterators and generators.body_line_iteratortyped_subpart_iteratorwalk    N)StringIOc             c   s;   |  V|  j    r7 x# |  j   D] } | j   Ed Hq Wd S)zWalk over the message tree, yielding each subpart.

    The walk is performed in depth-first order.  This method is a
    generator.
    N)is_multipartget_payloadr   )selfsubpart r
   %/usr/lib/python3.5/email/iterators.pyr      s    Fc             c   sK   xD |  j    D]6 } | j d |  } t | t  r t |  Ed Hq Wd S)zIterate over the parts, returning string payloads line-by-line.

    Optional decode (default False) is passed through to .get_payload().
    decodeN)r   r   
isinstancestrr   )msgr   r	   Zpayloadr
   r
   r   r   "   s    textc             c   sP   xI |  j    D]; } | j   | k r | d k sC | j   | k r | Vq Wd S)zIterate over the subparts with a given MIME type.

    Use `maintype' as the main MIME type to match against; this defaults to
    "text".  Optional `subtype' is the MIME subtype to match against; if
    omitted, only the main type is matched.
    N)r   Zget_content_maintypeZget_content_subtype)r   Zmaintypesubtyper	   r
   r
   r   r   -   s    c             C   s   | d k r t  j } d | d } t | |  j   d d d | | rf t d |  j   d | n t d |  |  j   r x+ |  j   D] } t | | | d |  q Wd S)	zA handy debugging aidN    end filez [%s]   )sysstdoutprintZget_content_typeZget_default_typer   r   
_structure)r   fplevelZinclude_defaultZtabr	   r
   r
   r   r   ;   s    	 r   )	__doc____all__r   ior   r   r   r   r   r
   r
   r
   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
[M                 @   s   d  Z  d d d g Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m	 Z	 m
 Z
 d d l m Z d	 Z d
 Z e j d  Z e j d e j  Z Gd d   d  Z Gd d   d e  Z d Z Gd d   d e  Z e e e j d   Z d e Z e j Z d S)z:Classes to generate plain text from a message object tree.	GeneratorDecodedGeneratorBytesGenerator    N)deepcopy)StringIOBytesIO)_has_surrogates_
z
\r\n|\r|\nz^From c               @   s	  e  Z d  Z d Z d d d d d d Z d d   Z d d d	 d
  Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z e Z d d   Z d d   Z d d    Z d! d"   Z e d d# d$   Z e d% d&    Z d S)'r   zGenerates output from a Message object tree.

    This basic generator writes the message to the given file object as plain
    text.
    Npolicyc            C   sO   | d k r' | d k r d n | j  } | |  _ | |  _ | |  _ | |  _ d S)a  Create the generator for message flattening.

        outfp is the output file-like object for writing the message to.  It
        must have a write() method.

        Optional mangle_from_ is a flag that, when True (the default if policy
        is not set), escapes From_ lines in the body of the message by putting
        a `>' in front of them.

        Optional maxheaderlen specifies the longest length for a non-continued
        header.  When a header line is longer (in characters, with tabs
        expanded to 8 spaces) than maxheaderlen, the header will split as
        defined in the Header class.  Set maxheaderlen to zero to disable
        header wrapping.  The default is 78, as recommended (but not required)
        by RFC 2822.

        The policy keyword specifies a policy object that controls a number of
        aspects of the generator's operation.  If no policy is specified,
        the policy associated with the Message object passed to the
        flatten method is used.

        NT)mangle_from__fp_mangle_from_maxheaderlenr   )selfoutfpr   r   r    r   %/usr/lib/python3.5/email/generator.py__init__$   s    			zGenerator.__init__c             C   s   |  j  j |  d  S)N)r   write)r   sr   r   r   r   D   s    zGenerator.writeFc             C   s6  |  j  d k r | j  n |  j  } | d k	 r? | j d |  } |  j d k	 rc | j d |  j  } | j |  _ |  j |  j  |  _ d |  _ |  j |  j  |  _ |  j  } | j  } zh | |  _  | | _  | r| j	   } | s d t
 j t
 j
    } |  j | |  j  |  j |  Wd | |  _  | | _  Xd S)a  Print the message object tree rooted at msg to the output file
        specified when the Generator instance was created.

        unixfrom is a flag that forces the printing of a Unix From_ delimiter
        before the first object in the message tree.  If the original message
        has no From_ delimiter, a `standard' one is crafted.  By default, this
        is False to inhibit the printing of any From_ delimiter.

        Note that for subobjects, no From_ line is printed.

        linesep specifies the characters used to indicate a new line in
        the output.  The default value is determined by the policy specified
        when the Generator instance was created or, if none was specified,
        from the policy associated with the msg.

        Nlinesepmax_line_length zFrom nobody )r   cloner   r   _NL_encode_encoded_NLZ_EMPTY_encoded_EMPTYZget_unixfromtimeZctimer   _write)r   msgunixfromr   r   Zold_gen_policyZold_msg_policyZufromr   r   r   flattenH   s,    !						zGenerator.flattenc             C   s   |  j  | |  j d d |  j S)z1Clone this generator with the exact same options.Nr   )	__class__r   r   )r   fpr   r   r   r   y   s    	zGenerator.clonec             C   s   t    S)N)r   )r   r   r   r   _new_buffer   s    zGenerator._new_bufferc             C   s   | S)Nr   )r   r   r   r   r   r      s    zGenerator._encodec             C   sp   | s
 d  St  j |  } x5 | d  d  D]# } |  j |  |  j |  j  q* W| d rl |  j | d  d  S)N   r(   r(   )NLCREsplitr   r   )r   linesliner   r   r   _write_lines   s    
zGenerator._write_linesc             C   s   |  j  } z- d  |  _ |  j   |  _  } |  j |  Wd  | |  _  |  j } |  ` X| r t |  } | j d | d  | j d | d  t | d d   } | d  k r |  j |  n
 | |   |  j  j | j	    d  S)Nzcontent-transfer-encodingr   zcontent-typer'   _write_headers)
r   
_munge_cter&   	_dispatchr   Zreplace_headergetattrr.   r   getvalue)r   r!   ZoldfpZsfpZ	munge_ctemethr   r   r   r       s"    				
zGenerator._writec             C   s   | j    } | j   } t j | | f  j d d  } t |  d | d   } | d  k r | j d d  } t |  d | d   } | d  k r |  j } | |  d  S)N-r	   Z_handle_)get_content_maintypeget_content_subtype
UNDERSCOREjoinreplacer1   
_writeBody)r   r!   mainsubZspecificr3   Zgenericr   r   r   r0      s    !	zGenerator._dispatchc             C   sM   x6 | j    D]( \ } } |  j |  j j | |   q W|  j |  j  d  S)N)	raw_itemsr   r   Zfoldr   )r   r!   hvr   r   r   r.      s     zGenerator._write_headersc             C   s   | j    } | d  k r d  St | t  sA t d t |    t | j  r | j d  } | d  k	 r t |  } | d =| j	 | |  | j    } | d | d f |  _
 |  j r t j d |  } |  j |  d  S)Nzstring payload expected: %scharsetzcontent-transfer-encodingzcontent-typez>From )get_payload
isinstancestr	TypeErrortyper   _payloadZ	get_paramr   Zset_payloadr/   r   fcrer<   r-   )r   r!   payloadr@   r   r   r   _handle_text   s"    	zGenerator._handle_textc             C   s4  g  } | j    } | d  k r' g  } n8 t | t  rG |  j |  d  St | t  s_ | g } xX | D]P } |  j   } |  j |  } | j | d d d |  j | j	 | j
    qf W| j   } | s |  j j |  } |  j |  } | j |  | j d  k	 rP|  j r*t j d | j  }	 n	 | j }	 |  j |	  |  j |  j  |  j d | |  j  | r|  j j | j d   x= | D]5 }
 |  j |  j d | |  j  |  j j |
  qW|  j |  j d | d |  j  | j d  k	 r0|  j rt j d | j  } n	 | j } |  j |  d  S)Nr"   Fr   z>From z--r   )rA   rB   rC   r   listr&   r   r#   r   appendr2   Zget_boundaryr   r8   _make_boundaryZset_boundarypreambler   rG   r<   r-   r   popepilogue)r   r!   ZmsgtextsZsubpartspartr   gboundaryZalltextrM   Z	body_partrO   r   r   r   _handle_multipart   sJ    				#		zGenerator._handle_multipartc             C   s@   |  j  } | j d d  |  _  z |  j |  Wd  | |  _  Xd  S)Nr   r   )r   r   rS   )r   r!   pr   r   r   _handle_multipart_signed8  s
    	z"Generator._handle_multipart_signedc             C   s   g  } x | j    D] } |  j   } |  j |  } | j | d d d |  j | j   } | j |  j  } | r | d |  j k r | j	 |  j j
 | d  d    q | j	 |  q W|  j j |  j j
 |   d  S)Nr"   Fr   r'   r(   r(   )rA   r&   r   r#   r   r2   r*   r   r   rK   r8   r   r   )r   r!   ZblocksrP   r   rQ   textr+   r   r   r   _handle_message_delivery_statusC  s    &z)Generator._handle_message_delivery_statusc             C   s   |  j    } |  j |  } | j } t | t  rg | j | j d  d d d |  j | j   } n |  j	 |  } |  j
 j |  d  S)Nr   r"   Fr   )r&   r   rF   rB   rJ   r#   rA   r   r2   r   r   r   )r   r!   r   rQ   rH   r   r   r   _handle_messageX  s    
	%zGenerator._handle_messagec             C   s   t  j t j  } d	 t | d } | d  k r4 | S| } d } xX |  j d t j |  d t j  } | j	 |  sy P| d t
 |  } | d 7} qC W| S)
N=   z==r   z^--z(--)?$.r'   z===============)randomZ	randrangesysmaxsize_fmt_compile_rereescape	MULTILINEsearchrC   )clsrV   tokenrR   bZcounterZcrer   r   r   rL   q  s    &zGenerator._make_boundaryc             C   s   t  j | |  S)N)ra   compile)re   r   flagsr   r   r   r`     s    zGenerator._compile_re)__name__
__module____qualname____doc__r   r   r#   r   r&   r   r-   r    r0   r.   rI   r:   rS   rU   rW   rX   classmethodrL   r`   r   r   r   r   r      s*   	1#
:c                   sp   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z   f d
 d   Z e Z	 e
 d d    Z   S)r   a  Generates a bytes version of a Message object tree.

    Functionally identical to the base Generator except that the output is
    bytes and not string.  When surrogates were used in the input to encode
    bytes, these are decoded back to bytes for output.  If the policy has
    cte_type set to 7bit, then the message is transformed such that the
    non-ASCII bytes are properly content transfer encoded, using the charset
    unknown-8bit.

    The outfp object must accept bytes in its write method.
    c             C   s    |  j  j | j d d   d  S)Nasciisurrogateescape)r   r   encode)r   r   r   r   r   r     s    zBytesGenerator.writec             C   s   t    S)N)r   )r   r   r   r   r&     s    zBytesGenerator._new_bufferc             C   s   | j  d  S)Nro   )rq   )r   r   r   r   r   r     s    zBytesGenerator._encodec             C   sP   x9 | j    D]+ \ } } |  j j |  j j | |   q W|  j |  j  d  S)N)r=   r   r   r   Zfold_binaryr   )r   r!   r>   r?   r   r   r   r.     s    #zBytesGenerator._write_headersc                s   | j  d  k r d  St | j   ri |  j j d k ri |  j rV t j d | j   | _  |  j | j   n t t	 |   j
 |  d  S)NZ7bitz>From )rF   r   r   Zcte_typer   rG   r<   r-   superr   rI   )r   r!   )r$   r   r   rI     s    "	zBytesGenerator._handle_textc             C   s   t  j | j d  |  S)Nro   )ra   rh   rq   )re   r   ri   r   r   r   r`     s    zBytesGenerator._compile_re)rj   rk   rl   rm   r   r&   r   r.   rI   r:   rn   r`   r   r   )r$   r   r     s   zD[Non-text (%(type)s) part of message omitted, filename %(filename)s]c               @   s7   e  Z d  Z d Z d d d d d  Z d d   Z d S)r   zGenerates a text representation of a message.

    Like the Generator base class, except that non-text parts are substituted
    with a format string representing the part.
    NN   c             C   s;   t  j |  | | |  | d k r. t |  _ n	 | |  _ d S)a  Like Generator.__init__() except that an additional optional
        argument is allowed.

        Walks through all subparts of a message.  If the subpart is of main
        type `text', then it prints the decoded payload of the subpart.

        Otherwise, fmt is a format string that is used instead of the message
        payload.  fmt is expanded with the following keywords (in
        %(keyword)s format):

        type       : Full MIME type of the non-text part
        maintype   : Main MIME type of the non-text part
        subtype    : Sub-MIME type of the non-text part
        filename   : Filename of the non-text part
        description: Description associated with the non-text part
        encoding   : Content transfer encoding of the non-text part

        The default value for fmt is None, meaning

        [Non-text (%(type)s) part of message omitted, filename %(filename)s]
        N)r   r   _FMTr_   )r   r   r   r   Zfmtr   r   r   r     s    zDecodedGenerator.__init__c             C   s   x | j    D] } | j   } | d k rJ t | j d d  d |  q | d k rY q t |  j d | j   d | j   d | j   d	 | j d
  d | j d d  d | j d d  i d |  q Wd  S)NrV   decodeFfileZ	multipartrE   maintypesubtypefilenamez[no filename]ZdescriptionzContent-Descriptionz[no description]encodingzContent-Transfer-Encodingz[no encoding])	walkr5   printrA   r_   Zget_content_typer6   get_filenameget)r   r!   rP   rw   r   r   r   r0     s     	zDecodedGenerator._dispatch)rj   rk   rl   rm   r   r0   r   r   r   r   r     s   r'   z%%0%dd)rm   __all__ra   r]   r   r\   copyr   ior   r   Zemail.utilsr   r7   NLrh   r)   rc   rG   r   r   rt   r   lenreprr^   Z_widthr_   rL   r   r   r   r   <module>   s(    o39
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
[$^                 @   s^  d  Z  d d d g Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m	 Z
 e
 j Z d Z d	 Z d
 Z d Z d Z d Z d Z e d  Z e d  Z e j d e j e j Be j B Z e j d  Z e j d  Z e j j Z d d   Z d d d	 d d  Z Gd d   d  Z  Gd d   d  Z! Gd d   d e"  Z# d S)z+Header encoding and decoding functionality.Headerdecode_headermake_header    N)HeaderParseError)charset
         N   z 	zus-asciizutf-8ai  
  =\?                   # literal =?
  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset
  \?                    # literal ?
  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive
  \?                    # literal ?
  (?P<encoded>.*?)      # non-greedy up to the next ?= is the encoded string
  \?=                   # literal ?=
  z[\041-\176]+:$z
\n[^ \t]+:c             C   s  t  |  d  r# d d   |  j D St j |   s? |  d f g Sg  } x |  j   D] } t j |  } d } x | r| j d  } | r | j   } d } | r | j | d d f  | rp | j d  j	   } | j d  j	   } | j d  } | j | | | f  qp WqR Wg  }	 xk t
 |  D]] \ }
 } |
 d k r)| d r)| |
 d	 d r)| |
 d d j   r)|	 j |
 d  q)Wx t |	  D] } | | =qWg  } x| D] \ } } } | d k r| j | | f  q| d
 k rt j j |  } | j | | f  q| d k rt |  d } | rT| d d d |  7} y t j j |  } Wn! t j k
 rt d   YqX| j | | f  qt d |   qWg  } d } } x | D] \ } } t | t  rt | d  } | d k r| } | } q| | k rB| j | | f  | } | } q| d k r_| t | 7} q| | 7} qW| j | | f  | S)a;  Decode a message header value without converting charset.

    Returns a list of (string, charset) pairs containing each of the decoded
    parts of the header.  Charset is None for non-encoded parts of the header,
    otherwise a lower-case string containing the name of the character set
    specified in the encoded string.

    header may be a string that may or may not contain RFC2047 encoded words,
    or it may be a Header object.

    An email.errors.HeaderParseError may be raised when certain decoding error
    occurs (e.g. a base64 decoding exception).
    _chunksc             S   s:   g  |  ]0 \ } } t  j | t |   t |  f  q S )_charsetZ_encodestr).0stringr   r   r   "/usr/lib/python3.5/email/header.py
<listcomp>M   s   	z!decode_header.<locals>.<listcomp>NTr   F      qb   z===zBase64 decoding errorzUnexpected encoding: zraw-unicode-escape)hasattrr   ecresearch
splitlinessplitpoplstripappendlower	enumerateisspacereversedemail
quoprimimeZheader_decodelenZ
base64mimedecodebinasciiErrorr   AssertionError
isinstancer   bytesBSPACE)headerZwordslinepartsfirstZ	unencodedr   encodingZencodedZdroplistnwdZdecoded_wordsZencoded_stringZwordZpaderrZ	collapsedZ	last_wordlast_charsetr   r   r   r   =   sz    		@
		c             C   sn   t  d | d | d |  } xL |  D]D \ } } | d k	 rV t | t  rV t |  } | j | |  q" W| S)a  Create a Header from a sequence of pairs as returned by decode_header()

    decode_header() takes a header value string and returns a sequence of
    pairs of the format (decoded_string, charset) where charset is the string
    name of the character set.

    This function takes one of those sequence of pairs and returns a Header
    instance.  Optional maxlinelen, header_name, and continuation_ws are as in
    the Header constructor.
    
maxlinelenheader_namecontinuation_wsN)r   r-   Charsetr!   )Zdecoded_seqr9   r:   r;   hsr   r   r   r   r      s    	c               @   s   e  Z d  Z d d d d d d d d  Z d d   Z d d	   Z d d d
 d  Z d d   Z d d d d d  Z d d   Z	 d S)r   Nr   strictc             C   s   | d k r t  } n t | t  s0 t |  } | |  _ | |  _ g  |  _ | d k	 rj |  j | | |  | d k r| t } | |  _ | d k r d |  _	 n t
 |  d |  _	 d S)aD  Create a MIME-compliant header that can contain many character sets.

        Optional s is the initial header value.  If None, the initial header
        value is not set.  You can later append to the header with .append()
        method calls.  s may be a byte string or a Unicode string, but see the
        .append() documentation for semantics.

        Optional charset serves two purposes: it has the same meaning as the
        charset argument to the .append() method.  It also sets the default
        character set for all subsequent .append() calls that omit the charset
        argument.  If charset is not provided in the constructor, the us-ascii
        charset is used both as s's initial charset and as the default for
        subsequent .append() calls.

        The maximum line length can be specified explicitly via maxlinelen. For
        splitting the first line to a shorter value (to account for the field
        header which isn't included in s, e.g. `Subject') pass in the name of
        the field in header_name.  The default maxlinelen is 78 as recommended
        by RFC 2822.

        continuation_ws must be RFC 2822 compliant folding whitespace (usually
        either a space or a hard tab) which will be prepended to continuation
        lines.

        errors is passed through to the .append() call.
        Nr   r   )USASCIIr-   r<   r   _continuation_wsr   r!   
MAXLINELEN_maxlinelen
_headerlenr(   )selfr>   r   r9   r:   r;   errorsr   r   r   __init__   s    					zHeader.__init__c       	      C   s  |  j    g  } d } d } x |  j D] \ } } | } | t j k rk | j d d  } | j d d  } | r | o |  j | d  } | d k r | d	 k r | r | j t  d } n  | d
 k r | r | j t  | o |  j | d  } | } | j |  q& Wt	 j
 |  S)z&Return the string value of the header.Nasciisurrogateescapereplacer   us-asciir   )NrK   )NrK   )NrK   )
_normalizer   r   UNKNOWN8BITencoder)   	_nonctextr!   SPACEEMPTYSTRINGjoin)	rE   Zuchunkslastcs	lastspacer   r   ZnextcsZoriginal_byteshasspacer   r   r   __str__   s*    
	zHeader.__str__c             C   s   | t  |   k S)N)r   )rE   otherr   r   r   __eq__  s    zHeader.__eq__c             C   s   | d k r |  j  } n t | t  s3 t |  } t | t  s | j pN d } | t  j k ru | j d d  } n | j | |  } | j p d } | t  j k r y | j | |  Wn' t	 k
 r | d k r   t
 } Yn X|  j j | | f  d S)a.  Append a string to the MIME header.

        Optional charset, if given, should be a Charset instance or the name
        of a character set (which will be converted to a Charset instance).  A
        value of None (the default) means that the charset given in the
        constructor is used.

        s may be a byte string or a Unicode string.  If it is a byte string
        (i.e. isinstance(s, str) is false), then charset is the encoding of
        that byte string, and a UnicodeError will be raised if the string
        cannot be decoded with that charset.  If s is a Unicode string, then
        charset is a hint specifying the character set of the characters in
        the string.  In either case, when producing an RFC 2822 compliant
        header using RFC 2047 rules, the string will be encoded using the
        output codec of the charset.  If the string cannot be encoded to the
        output codec, a UnicodeError will be raised.

        Optional `errors' is passed as the errors argument to the decode
        call if s is a byte string.
        Nzus-asciirI   )r   r-   r<   r   Zinput_codecrN   r)   Zoutput_codecrO   UnicodeEncodeErrorUTF8r   r!   )rE   r>   r   rF   Zinput_charsetZoutput_charsetr   r   r   r!   	  s$    zHeader.appendc             C   s   | j    p | d k S)z=True if string s is not a ctext character of RFC822.
        ()\)r\   r]   r^   )r$   )rE   r>   r   r   r   rP   4  s    zHeader._nonctextz;, 	r   c             C   sD  |  j    | d k r |  j } | d k r1 d } t |  j | |  j |  } d } d } } x|  j D]\ } }	 | d k	 r | o |  j | d  } | d
 k r | s |	 d k r | j   n |	 d k r | r | j   | o |  j | d  } |	 } d } | j   }
 |
 r1| j	 d |
 d |	  n | j	 d d |	  x |
 d d  D] } | j
   |	 j d k	 r| j	 |  j d | j   |	  qU| j   } | d t |  t |   } | j	 | | |	  qUWt |
  d k rf | j
   qf W|  j r| j   | j |  } t j |  r@t d	 j |    | S)a  Encode a message header into an RFC-compliant format.

        There are many issues involved in converting a given string for use in
        an email header.  Only certain character sets are readable in most
        email clients, and as header strings can only contain a subset of
        7-bit ASCII, care must be taken to properly convert and encode (with
        Base64 or quoted-printable) header strings.  In addition, there is a
        75-character length limit on any given encoded header field, so
        line-wrapping must be performed, even with double-byte character sets.

        Optional maxlinelen specifies the maximum length of each generated
        line, exclusive of the linesep string.  Individual lines may be longer
        than maxlinelen if a folding point cannot be found.  The first line
        will be shorter by the length of the header name plus ": " if a header
        name was specified at Header construction time.  The default value for
        maxlinelen is determined at header construction time.

        Optional splitchars is a string containing characters which should be
        given extra weight by the splitting algorithm during normal header
        wrapping.  This is in very rough support of RFC 2822's `higher level
        syntactic breaks':  split points preceded by a splitchar are preferred
        during line splitting, with the characters preferred in the order in
        which they appear in the string.  Space and tab may be included in the
        string to indicate whether preference should be given to one over the
        other as a split point when other split chars do not appear in the line
        being split.  Splitchars does not affect RFC 2047 encoded lines.

        Optional linesep is a string to be used to separate the lines of
        the value.  The default value is the most useful for typical
        Python applications, but it can be set to \r\n to produce RFC-compliant
        line separators when needed.
        Nr   i@B us-asciir   Fr   r   z8header value appears to contain an embedded header: {!r})Nr_   )Nr_   )Nr_   rL   )rM   rC   _ValueFormatterrD   rA   r   rP   add_transitionr   feednewlineheader_encodingr    r(   _str_embeded_headerr   r   format)rE   
splitcharsr9   linesepZ	formatterrT   rV   rU   r   r   linesr1   Zslinefwsvaluer   r   r   rO   9  sR    !
	



 	
	zHeader.encodec             C   s   g  } d  } g  } xj |  j  D]_ \ } } | | k rD | j |  q | d  k	 rl | j t j |  | f  | g } | } q W| r | j t j |  | f  | |  _  d  S)N)r   r!   rQ   rS   )rE   Zchunksr8   Z
last_chunkr   r   r   r   r   rM     s    	
zHeader._normalize)
__name__
__module____qualname__rG   rW   rY   r!   rP   rO   rM   r   r   r   r   r      s   - +Pc               @   s|   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d S)r`   c             C   sF   | |  _  | |  _ t |  |  _ | |  _ g  |  _ t |  |  _ d  S)N)_maxlenrA   r(   _continuation_ws_len_splitchars_lines_Accumulator_current_line)rE   Z	headerlenmaxlenr;   rh   r   r   r   rG     s    				z_ValueFormatter.__init__c             C   s   |  j    | j |  j  S)N)rc   rS   rs   )rE   ri   r   r   r   re     s    
z_ValueFormatter._strc             C   s   |  j  t  S)N)re   NL)rE   r   r   r   rW     s    z_ValueFormatter.__str__c             C   s   |  j  j   } | d k r+ |  j  j |   t |  j   d k r |  j  j   rl |  j d t |  j   7<n |  j j t |  j    |  j  j   d  S)Nr   r   r   r   )r   r   rL   )	ru   r   pushr(   	is_onlywsrs   r   r!   reset)rE   Zend_of_liner   r   r   rc     s    z_ValueFormatter.newlinec             C   s   |  j  j d d  d  S)Nr   r   )ru   rx   )rE   r   r   r   ra     s    z_ValueFormatter.add_transitionc             C   s   | j  d  k r) |  j | | |  j  d  S| j | |  j    } y | j d  } Wn t k
 rl d  SYn X| d  k	 r |  j | |  y | j   } Wn t k
 r d  SYn X|  j   |  j	 j
 |  j |  x% | D] } |  j j |  j |  q Wd  S)Nr   )rd   _ascii_splitrr   Zheader_encode_lines_maxlengthsr   
IndexError_append_chunkrc   ru   rx   rA   rs   r!   )rE   rk   r   r   Zencoded_linesZ
first_lineZ	last_liner1   r   r   r   rb     s$    		
z_ValueFormatter.feedc             c   s/   |  j  t |  j  Vx |  j  |  j Vq Wd  S)N)rp   r(   ru   rq   )rE   r   r   r   r|     s    z_ValueFormatter._maxlengthsc             C   s   t  j d t d | |  } | d r> d g | d  d  <n | j d  x7 t t |  g d   D] \ } } |  j | |  qe Wd  S)Nz([z]+)r   r   r   )rer   FWSr   zipiterr~   )rE   rk   r   rh   r2   partr   r   r   r{     s    
&z_ValueFormatter._ascii_splitc             C   s`  |  j  j | |  t |  j   |  j k r\x |  j D] } x t |  j  j   d d d  D]f } | j   r |  j  | d } | r | d | k r P|  j  | d d } | r[ | d | k r[ Pq[ Wq5 Pq5 W|  j  j   \ } } |  j  j	 d k r
|  j
   | s
d } |  j  j | |  d  S|  j  j |  } |  j j t |  j    |  j  j |  d  S)Nr   r   r   rL   rL   )ru   rx   r(   rp   rr   range
part_countr$   r   _initial_sizerc   pop_fromrs   r!   r   rz   )rE   rk   r   ZchiZprevpartr   Z	remainderr   r   r   r~     s.    &
z_ValueFormatter._append_chunkN)rm   rn   ro   rG   re   rW   rc   ra   rb   r|   r{   r~   r   r   r   r   r`     s   %r`   c                   s   e  Z d  Z d   f d d  Z d d   Z d d d  Z   f d d	   Z d
 d   Z d d   Z d d d  Z	 d d   Z
   f d d   Z   S)rt   r   c                s   | |  _  t   j   d  S)N)r   superrG   )rE   Zinitial_size)	__class__r   r   rG     s    	z_Accumulator.__init__c             C   s   |  j  | | f  d  S)N)r!   )rE   rk   r   r   r   r   rx   #  s    z_Accumulator.pushc             C   s$   |  | d   } g  |  | d   <| S)Nr   )rE   r   Zpoppedr   r   r   r   &  s    z_Accumulator.pop_fromc                s#   |  j    d k r d St   j   S)Nr   r   )r   r   )r   r   r   )rE   )r   r   r   r   +  s    z_Accumulator.popc             C   s   t  d d   |  D |  j  S)Nc             s   s+   |  ]! \ } } t  |  t  |  Vq d  S)N)r(   )r   rk   r   r   r   r   	<genexpr>1  s    z'_Accumulator.__len__.<locals>.<genexpr>)sumr   )rE   r   r   r   __len__0  s    z_Accumulator.__len__c             C   s   t  j d d   |  D  S)Nc             s   s*   |  ]  \ } } t  j | | f  Vq d  S)N)rR   rS   )r   rk   r   r   r   r   r   5  s   z'_Accumulator.__str__.<locals>.<genexpr>)rR   rS   )rE   r   r   r   rW   4  s    z_Accumulator.__str__Nc             C   s/   | d  k r g  } | |  d  d   <d |  _  d  S)Nr   )r   )rE   Zstartvalr   r   r   rz   8  s    z_Accumulator.resetc             C   s&   |  j  d k o% |  p% t |   j   S)Nr   )r   r   r$   )rE   r   r   r   ry   >  s    z_Accumulator.is_onlywsc                s   t    j   S)N)r   r   )rE   )r   r   r   r   A  s    z_Accumulator.part_count)rm   rn   ro   rG   rx   r   r   r   rW   rz   ry   r   r   r   )r   r   rt     s   rt   z        )$__doc____all__r   r*   Zemail.quoprimimer&   Zemail.base64mimeZemail.errorsr   r   r   r<   rw   rQ   r/   ZSPACE8rR   rB   r   r@   r[   compileVERBOSE
IGNORECASE	MULTILINEr   Zfcrerf   r'   Z_max_appendr   r   r   r`   listrt   r   r   r   r   <module>   s<   		_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
[N              &   @   s)  d  Z  d d l m Z d d l m Z d d l m Z d d l m Z Gd d   d  Z Gd d	   d	  Z	 Gd
 d   d e
  Z d d   Z Gd d   d  Z Gd d   d e  Z Gd d   d  Z Gd d   d e  Z Gd d   d  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d  Z Gd  d!   d!  Z Gd" d#   d# e  Z Gd$ d%   d% e  Z Gd& d'   d'  Z d( e d) e d* e d+ e d, e d- e d. e d/ e d0 e d1 e d2 e d3 e d4 e d5 e d6 e d7 e d8 e d9 e d: e i Z Gd; d<   d<  Z d= S)>a;  Representing and manipulating email headers via custom objects.

This module provides an implementation of the HeaderRegistry API.
The implementation is designed to flexibly follow RFC5322 rules.

Eventually HeaderRegistry will be a public API, but it isn't yet,
and will probably change some before that happens.

    )MappingProxyType)utils)errors)_header_value_parserc               @   s   e  Z d  Z d d d d d d  Z e d d    Z e d d    Z e d	 d
    Z e d d    Z d d   Z	 d d   Z
 d d   Z d S)Address Nc             C   s   | d k	 r | s | r$ t  d   t j |  \ } } | rW t d j | |    | j rm | j d  | j } | j } | |  _ | |  _	 | |  _
 d S)a  Create an object representing a full email address.

        An address can have a 'display_name', a 'username', and a 'domain'.  In
        addition to specifying the username and domain separately, they may be
        specified together by using the addr_spec keyword *instead of* the
        username and domain keywords.  If an addr_spec string is specified it
        must be properly quoted according to RFC 5322 rules; an error will be
        raised if it is not.

        An Address object has display_name, username, domain, and addr_spec
        attributes, all of which are read-only.  The addr_spec and the string
        value of the object are both quoted according to RFC5322 rules, but
        without any Content Transfer Encoding.

        Nz=addrspec specified when username and/or domain also specifiedz6Invalid addr_spec; only '{}' could be parsed from '{}'r   )	TypeErrorparserZget_addr_spec
ValueErrorformatall_defects
local_partdomain_display_name	_username_domain)selfdisplay_nameusernamer   	addr_specZa_srest r   */usr/lib/python3.5/email/headerregistry.py__init__   s    						zAddress.__init__c             C   s   |  j  S)N)r   )r   r   r   r   r   7   s    zAddress.display_namec             C   s   |  j  S)N)r   )r   r   r   r   r   ;   s    zAddress.usernamec             C   s   |  j  S)N)r   )r   r   r   r   r   ?   s    zAddress.domainc             C   sr   t  |  j  } t |  t | t j  k rC t j |  j  } n	 |  j } |  j rd | d |  j S| sn d S| S)zThe addr_spec (username@domain) portion of the address, quoted
        according to RFC 5322 rules, but with no Content Transfer Encoding.
        @z<>)setr   lenr	   ZDOT_ATOM_ENDSquote_stringr   )r   namesetZlpr   r   r   r   C   s    		zAddress.addr_specc             C   s%   d j  |  j j |  j |  j |  j  S)Nz1{}(display_name={!r}, username={!r}, domain={!r}))r   	__class____name__r   r   r   )r   r   r   r   __repr__S   s    	zAddress.__repr__c             C   s   t  |  j  } t |  t | t j  k rC t j |  j  } n	 |  j } | r |  j d k rg d n |  j } d j | |  S|  j S)Nz<>r   z{} <{}>)r   r   r   r	   SPECIALSr   r   r   )r   r   dispr   r   r   r   __str__X   s    	zAddress.__str__c             C   sP   t  |  t  |   k r d S|  j | j k oO |  j | j k oO |  j | j k S)NF)typer   r   r   )r   otherr   r   r   __eq__c   s
    zAddress.__eq__)r    
__module____qualname__r   propertyr   r   r   r   r!   r$   r'   r   r   r   r   r      s   %r   c               @   sj   e  Z d  Z d d d d  Z e d d    Z e d d    Z d d	   Z d
 d   Z d d   Z	 d S)GroupNc             C   s+   | |  _  | r t |  n t   |  _ d S)a  Create an object representing an address group.

        An address group consists of a display_name followed by colon and a
        list of addresses (see Address) terminated by a semi-colon.  The Group
        is created by specifying a display_name and a possibly empty list of
        Address objects.  A Group can also be used to represent a single
        address that is not in a group, which is convenient when manipulating
        lists that are a combination of Groups and individual Addresses.  In
        this case the display_name should be set to None.  In particular, the
        string representation of a Group whose display_name is None is the same
        as the Address object, if there is one and only one Address object in
        the addresses list.

        N)r   tuple
_addresses)r   r   	addressesr   r   r   r   m   s    	zGroup.__init__c             C   s   |  j  S)N)r   )r   r   r   r   r      s    zGroup.display_namec             C   s   |  j  S)N)r-   )r   r   r   r   r.      s    zGroup.addressesc             C   s   d j  |  j j |  j |  j  S)Nz${}(display_name={!r}, addresses={!r})r   r   r    r   r.   )r   r   r   r   r!      s    	zGroup.__repr__c             C   s   |  j  d  k r5 t |  j  d k r5 t |  j d  S|  j  } | d  k	 r t |  } t |  t | t j  k r t j |  } d j d d   |  j D  } | r d | n | } d j	 | |  S)N   r   z, c             s   s   |  ] } t  |  Vq d  S)N)str).0xr   r   r   	<genexpr>   s    z Group.__str__.<locals>.<genexpr> z{}:{};)
r   r   r.   r0   r   r	   r"   r   joinr   )r   r#   r   Zadrstrr   r   r   r$      s    $	zGroup.__str__c             C   s>   t  |  t  |   k r d S|  j | j k o= |  j | j k S)NF)r%   r   r.   )r   r&   r   r   r   r'      s    zGroup.__eq__)
r    r(   r)   r   r*   r   r.   r!   r$   r'   r   r   r   r   r+   k   s   r+   c               @   s|   e  Z d  Z d Z d d   Z d d   Z e d d    Z e d d	    Z d
 d   Z	 e
 d d    Z d d   Z d S)
BaseHeadera|  Base class for message headers.

    Implements generic behavior and provides tools for subclasses.

    A subclass must define a classmethod named 'parse' that takes an unfolded
    value string and a dictionary as its arguments.  The dictionary will
    contain one key, 'defects', initialized to an empty list.  After the call
    the dictionary must contain two additional keys: parse_tree, set to the
    parse tree obtained from parsing the header, and 'decoded', set to the
    string value of the idealized representation of the data from the value.
    (That is, encoded words are decoded, and values that have canonical
    representations are so represented.)

    The defects key is intended to collect parsing defects, which the message
    parser will subsequently dispose of as appropriate.  The parser should not,
    insofar as practical, raise any errors.  Defects should be added to the
    list instead.  The standard header parsers register defects for RFC
    compliance issues, for obsolete RFC syntax, and for unrecoverable parsing
    errors.

    The parse method may add additional keys to the dictionary.  In this case
    the subclass must define an 'init' method, which will be passed the
    dictionary as its keyword arguments.  The method should use (usually by
    setting them as the value of similarly named attributes) and remove all the
    extra keys added by its parse method, and then use super to call its parent
    class with the remaining arguments and keywords.

    The subclass should also make sure that a 'max_count' attribute is defined
    that is either None or 1. XXX: need to better define this API.

    c             C   sw   d g  i } |  j  | |  t j | d  rF t j | d  | d <t j |  | d  } | d =| j | |  | S)Ndefectsdecoded)parser   Z_has_surrogates	_sanitizer0   __new__init)clsnamevaluekwdsr   r   r   r   r;      s    zBaseHeader.__new__c            C   s   | |  _  | |  _ | |  _ d  S)N)_name_parse_tree_defects)r   r>   
parse_treer7   r   r   r   r<      s    		zBaseHeader.initc             C   s   |  j  S)N)rA   )r   r   r   r   r>      s    zBaseHeader.namec             C   s   t  |  j  S)N)r,   rC   )r   r   r   r   r7      s    zBaseHeader.defectsc             C   s+   t  |  j j |  j j t |   f |  j f S)N)_reconstruct_headerr   r    	__bases__r0   __dict__)r   r   r   r   
__reduce__   s
    		zBaseHeader.__reduce__c             C   s   t  j |  |  S)N)r0   r;   )r=   r?   r   r   r   _reconstruct   s    zBaseHeader._reconstructc            C   sm   t  j t  j t  j |  j d  t  j d d  g  t  j t  j d d  g  |  j g  } | j d |  S)at  Fold header according to policy.

        The parsed representation of the header is folded according to
        RFC5322 rules, as modified by the policy.  If the parse tree
        contains surrogateescaped bytes, the bytes are CTE encoded using
        the charset 'unknown-8bit".

        Any non-ASCII characters in the parse tree are CTE encoded using
        charset utf-8. XXX: make this a policy setting.

        The returned value is an ASCII-only string possibly containing linesep
        characters, and ending with a linesep character.  The string includes
        the header name and the ': ' separator.

        zheader-name:z
header-sepr4   Zfwspolicy)	r	   ZHeaderZHeaderLabelZValueTerminalr>   ZCFWSListZWhiteSpaceTerminalrB   fold)r   rK   headerr   r   r   rL      s    zBaseHeader.foldN)r    r(   r)   __doc__r;   r<   r*   r>   r7   rH   classmethodrI   rL   r   r   r   r   r6      s    

r6   c             C   s   t  |  | i   j |  S)N)r%   rI   )Zcls_namebasesr?   r   r   r   rE     s    rE   c               @   s7   e  Z d  Z d Z e e j  Z e d d    Z	 d S)UnstructuredHeaderNc             C   s+   |  j  |  | d <t | d  | d <d  S)NrD   r8   )value_parserr0   )r=   r?   r@   r   r   r   r9     s    zUnstructuredHeader.parse)
r    r(   r)   	max_countstaticmethodr	   get_unstructuredrR   rO   r9   r   r   r   r   rQ     s   rQ   c               @   s   e  Z d  Z d Z d S)UniqueUnstructuredHeaderr/   N)r    r(   r)   rS   r   r   r   r   rV     s   rV   c                   sa   e  Z d  Z d Z d Z e e j  Z e	 d d    Z
   f d d   Z e d d    Z   S)	
DateHeadera  Header whose value consists of a single timestamp.

    Provides an additional attribute, datetime, which is either an aware
    datetime using a timezone, or a naive datetime if the timezone
    in the input string is -0000.  Also accepts a datetime as input.
    The 'value' attribute is the normalized form of the timestamp,
    which means it is the output of format_datetime on the datetime.
    Nc             C   s   | sE | d j  t j    d  | d <d | d <t j   | d <d  St | t  rc t j |  } | | d <t j	 | d  | d <|  j
 | d  | d <d  S)Nr7   datetimer   r8   rD   )appendr   ZHeaderMissingRequiredValuer	   Z	TokenList
isinstancer0   r   Zparsedate_to_datetimeZformat_datetimerR   )r=   r?   r@   r   r   r   r9   &  s    


zDateHeader.parsec                s)   | j  d  |  _ t   j | |   d  S)NrX   )pop	_datetimesuperr<   )r   argskw)r   r   r   r<   4  s    zDateHeader.initc             C   s   |  j  S)N)r\   )r   r   r   r   rX   8  s    zDateHeader.datetime)r    r(   r)   rN   rS   rT   r	   rU   rR   rO   r9   r<   r*   rX   r   r   )r   r   rW     s   	rW   c               @   s   e  Z d  Z d Z d S)UniqueDateHeaderr/   N)r    r(   r)   rS   r   r   r   r   r`   =  s   r`   c                   sp   e  Z d  Z d Z e d d    Z e d d    Z   f d d   Z e	 d d	    Z
 e	 d
 d    Z   S)AddressHeaderNc             C   s,   t  j |   \ } }  |  s( t d   | S)Nzthis should not happen)r	   Zget_address_listAssertionError)r?   address_listr   r   r   rR   F  s    zAddressHeader.value_parserc             C   s  t  | t  r{ |  j |  | d <} g  } x: | j D]/ } | j t | j d d   | j D   q6 Wt | j	  } n1 t
 | d  s | g } d d   | D } g  } | | d <| | d <d j d	 d   | D  | d
 <d | k r|  j | d
  | d <d  S)NrD   c             S   s=   g  |  ]3 } t  | j p d  | j p' d  | j p3 d    q S)r   )r   r   r   r   )r1   Zmbr   r   r   
<listcomp>U  s   	z'AddressHeader.parse.<locals>.<listcomp>__iter__c             S   s7   g  |  ]- } t  | d   s- t d | g  n |  q S)r.   N)hasattrr+   )r1   itemr   r   r   rd   ^  s   	groupsr7   z, c             S   s   g  |  ] } t  |   q Sr   )r0   )r1   rg   r   r   r   rd   d  s   	 r8   )rZ   r0   rR   r.   rY   r+   r   Zall_mailboxeslistr   rf   r5   )r=   r?   r@   rc   rh   Zaddrr7   r   r   r   r9   L  s$    			


 zAddressHeader.parsec                s8   t  | j d   |  _ d  |  _ t   j | |   d  S)Nrh   )r,   r[   _groupsr-   r]   r<   )r   r^   r_   )r   r   r   r<   h  s    	zAddressHeader.initc             C   s   |  j  S)N)rj   )r   r   r   r   rh   m  s    zAddressHeader.groupsc             C   s5   |  j  d  k r. t d d   |  j D  |  _  |  j  S)Nc             S   s&   g  |  ] } | j  D] } |  q q Sr   )r.   )r1   groupaddressr   r   r   rd   t  s   	 z+AddressHeader.addresses.<locals>.<listcomp>)r-   r,   rj   )r   r   r   r   r.   q  s    zAddressHeader.addresses)r    r(   r)   rS   rT   rR   rO   r9   r<   r*   rh   r.   r   r   )r   r   ra   B  s   ra   c               @   s   e  Z d  Z d Z d S)UniqueAddressHeaderr/   N)r    r(   r)   rS   r   r   r   r   rm   y  s   rm   c               @   s"   e  Z d  Z e d d    Z d S)SingleAddressHeaderc             C   s8   t  |  j  d k r- t d j |  j    |  j d S)Nr/   z9value of single address header {} is not a single addressr   )r   r.   r
   r   r>   )r   r   r   r   rl     s    	zSingleAddressHeader.addressN)r    r(   r)   r*   rl   r   r   r   r   rn   ~  s   rn   c               @   s   e  Z d  Z d Z d S)UniqueSingleAddressHeaderr/   N)r    r(   r)   rS   r   r   r   r   ro     s   ro   c                   s   e  Z d  Z d Z e e j  Z e d d    Z	   f d d   Z
 e d d    Z e d d	    Z e d
 d    Z   S)MIMEVersionHeaderr/   c             C   s   |  j  |  | d <} t |  | d <| d j | j  | j d  k rP d  n | j | d <| j | d <| j d  k	 r d j | d | d  | d <n
 d  | d <d  S)NrD   r8   r7   majorminorz{}.{}version)rR   r0   extendr   rr   rq   r   )r=   r?   r@   rD   r   r   r   r9     s    "!zMIMEVersionHeader.parsec                sM   | j  d  |  _ | j  d  |  _ | j  d  |  _ t   j | |   d  S)Nrs   rq   rr   )r[   _version_major_minorr]   r<   )r   r^   r_   )r   r   r   r<     s    zMIMEVersionHeader.initc             C   s   |  j  S)N)rv   )r   r   r   r   rq     s    zMIMEVersionHeader.majorc             C   s   |  j  S)N)rw   )r   r   r   r   rr     s    zMIMEVersionHeader.minorc             C   s   |  j  S)N)ru   )r   r   r   r   rs     s    zMIMEVersionHeader.version)r    r(   r)   rS   rT   r	   Zparse_mime_versionrR   rO   r9   r<   r*   rq   rr   rs   r   r   )r   r   rp     s   rp   c                   sL   e  Z d  Z d Z e d d    Z   f d d   Z e d d    Z   S)ParameterizedMIMEHeaderr/   c             C   su   |  j  |  | d <} t |  | d <| d j | j  | j d  k rW i  | d <n d d   | j D | d <d  S)NrD   r8   r7   paramsc             S   s7   i  |  ]- \ } } t  j |  t  j |  j    q Sr   )r   r:   lower)r1   r>   r?   r   r   r   
<dictcomp>  s   	z1ParameterizedMIMEHeader.parse.<locals>.<dictcomp>)rR   r0   rt   r   ry   )r=   r?   r@   rD   r   r   r   r9     s    	zParameterizedMIMEHeader.parsec                s)   | j  d  |  _ t   j | |   d  S)Nry   )r[   _paramsr]   r<   )r   r^   r_   )r   r   r   r<     s    zParameterizedMIMEHeader.initc             C   s   t  |  j  S)N)r   r|   )r   r   r   r   ry     s    zParameterizedMIMEHeader.params)	r    r(   r)   rS   rO   r9   r<   r*   ry   r   r   )r   r   rx     s   rx   c                   sg   e  Z d  Z e e j  Z   f d d   Z e d d    Z	 e d d    Z
 e d d    Z   S)	ContentTypeHeaderc                sG   t    j | |   t j |  j j  |  _ t j |  j j  |  _ d  S)N)	r]   r<   r   r:   rB   maintype	_maintypesubtype_subtype)r   r^   r_   )r   r   r   r<     s    zContentTypeHeader.initc             C   s   |  j  S)N)r   )r   r   r   r   r~     s    zContentTypeHeader.maintypec             C   s   |  j  S)N)r   )r   r   r   r   r     s    zContentTypeHeader.subtypec             C   s   |  j  d |  j S)N/)r~   r   )r   r   r   r   content_type  s    zContentTypeHeader.content_type)r    r(   r)   rT   r	   Zparse_content_type_headerrR   r<   r*   r~   r   r   r   r   )r   r   r}     s
   r}   c                   sC   e  Z d  Z e e j  Z   f d d   Z e d d    Z	   S)ContentDispositionHeaderc                sG   t    j | |   |  j j } | d  k r1 | n t j |  |  _ d  S)N)r]   r<   rB   content_dispositionr   r:   _content_disposition)r   r^   r_   Zcd)r   r   r   r<     s    zContentDispositionHeader.initc             C   s   |  j  S)N)r   )r   r   r   r   r     s    z,ContentDispositionHeader.content_disposition)
r    r(   r)   rT   r	   Z parse_content_disposition_headerrR   r<   r*   r   r   r   )r   r   r     s   r   c                   s[   e  Z d  Z d Z e e j  Z e d d    Z	   f d d   Z
 e d d    Z   S)ContentTransferEncodingHeaderr/   c             C   s?   |  j  |  | d <} t |  | d <| d j | j  d  S)NrD   r8   r7   )rR   r0   rt   r   )r=   r?   r@   rD   r   r   r   r9     s    z#ContentTransferEncodingHeader.parsec                s/   t    j | |   t j |  j j  |  _ d  S)N)r]   r<   r   r:   rB   cte_cte)r   r^   r_   )r   r   r   r<     s    z"ContentTransferEncodingHeader.initc             C   s   |  j  S)N)r   )r   r   r   r   r     s    z!ContentTransferEncodingHeader.cte)r    r(   r)   rS   rT   r	   Z&parse_content_transfer_encoding_headerrR   rO   r9   r<   r*   r   r   r   )r   r   r     s
   r   ZsubjectZdatezresent-datez	orig-dateZsenderzresent-senderZtoz	resent-toZccz	resent-ccZbccz
resent-bccfromzresent-fromzreply-tozmime-versionzcontent-typezcontent-dispositionzcontent-transfer-encodingc               @   sO   e  Z d  Z d Z e e d d d  Z d d   Z d d   Z d	 d
   Z	 d S)HeaderRegistryz%A header_factory and header registry.Tc             C   s5   i  |  _  | |  _ | |  _ | r1 |  j  j t  d S)a  Create a header_factory that works with the Policy API.

        base_class is the class that will be the last class in the created
        header class's __bases__ list.  default_class is the class that will be
        used if "name" (see __call__) does not appear in the registry.
        use_default_map controls whether or not the default mapping of names to
        specialized classes is copied in to the registry when the factory is
        created.  The default is True.

        N)registry
base_classdefault_classupdate_default_header_map)r   r   r   Zuse_default_mapr   r   r   r   $  s
    			zHeaderRegistry.__init__c             C   s   | |  j  | j   <d S)zLRegister cls as the specialized class for handling "name" headers.

        N)r   rz   )r   r>   r=   r   r   r   map_to_type6  s    zHeaderRegistry.map_to_typec             C   s>   |  j  j | j   |  j  } t d | j | |  j f i   S)N_)r   getrz   r   r%   r    r   )r   r>   r=   r   r   r   __getitem__<  s    zHeaderRegistry.__getitem__c             C   s   |  | | |  S)a  Create a header instance for header 'name' from 'value'.

        Creates a header instance by creating a specialized class for parsing
        and representing the specified header by combining the factory
        base_class with a specialized class from the registry or the
        default_class, and passing the name and value to the constructed
        class's constructor.

        r   )r   r>   r?   r   r   r   __call__@  s    
zHeaderRegistry.__call__N)
r    r(   r)   rN   r6   rQ   r   r   r   r   r   r   r   r   r      s   r   N)rN   typesr   Zemailr   r   r   r	   r   r+   r0   r6   rE   rQ   rV   rW   r`   ra   rm   rn   ro   rp   rx   r}   r   r   r   r   r   r   r   r   <module>	   sR   [6a'7
%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
[                 @   s<  d  Z  d g Z d d l Z d d l Z d d l Z d d l Z d d l m Z m Z d d l	 m
 Z
 d d l	 m Z d d l m Z d d l	 m Z d d	 l m Z e j Z d
 Z e j d  Z d d   Z d d d d  Z d d   Z d d   Z Gd d   d  Z Gd d   d e  Z Gd d   d e  Z d S)z8Basic message object for the email package object model.Message    N)BytesIOStringIO)utils)errors)compat32)charset)decode_bz; z[ \(\)<>@,;:\\"/\[\]\?=]c             C   sJ   t  |   j d  \ } } } | s4 | j   d  f S| j   | j   f S)N;)str	partitionstrip)paramasepb r   #/usr/lib/python3.5/email/message.py_splitparam   s    r   Tc             C   s   | d k	 r t  |  d k r t | t  rf |  d 7}  t j | d | d | d  } d |  | f Sy | j d  Wn? t k
 r |  d 7}  t j | d d	  } d |  | f SYn X| s t j |  r d
 |  t j	 |  f Sd |  | f Sn |  Sd S)a~  Convenience function to format and return a key=value pair.

    This will quote the value if needed or if quote is true.  If value is a
    three tuple (charset, language, value), it will be encoded according
    to RFC2231 rules.  If it contains non-ascii characters it will likewise
    be encoded according to RFC2231 rules, using the utf-8 charset and
    a null language.
    Nr   *      z%s=%sasciizutf-8 z%s="%s")
len
isinstancetupler   Zencode_rfc2231encodeUnicodeEncodeError	tspecialssearchquote)r   valuer!   r   r   r   _formatparam(   s    	
!
r#   c             C   sI  d t  |   }  g  } x,|  d  d  d k rD|  d d   }  |  j d  } xR | d k r |  j d d |  |  j d d |  d r |  j d | d  } qQ W| d k  r t |   } |  d  |  } d | k r| j d  } | d  |  j   j   d | | d d   j   } | j | j    |  | d   }  q W| S)Nr
   r   r   "z\"r   =)r   findcountr   indexr   lowerappend)sZplistendfir   r   r   _parseparamJ   s     ;8r/   c             C   sB   t  |  t  r1 |  d |  d t j |  d  f St j |   Sd  S)Nr   r   r   )r   r   r   unquote)r"   r   r   r   _unquotevalue^   s    "r1   c               @   s  e  Z d  Z d Z e d d  Z d d   Z d d d d	 d
  Z d d   Z d d d d  Z	 d d   Z
 d d   Z d d   Z d d   Z d d d d  Z d d d  Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d/ d0   Z d d1 d2  Z d3 d4   Z d5 d6   Z d d7 d8  Z d9 d:   Z d; d<   Z  d= d>   Z! d? d@   Z" dA dB   Z# dC dD   Z$ dE dF   Z% dG dH   Z& d dI dJ dK dL  Z' d dI dJ dM dN  Z( dO dJ d dP d dQ dR  Z) dI dJ dS dT  Z* dO dJ dU dV  Z+ d dW dX  Z, d dY dZ  Z- d[ d\   Z. d d] d^  Z/ d d_ d`  Z0 da db   Z1 d dc l2 m3 Z3 d S)dr   a  Basic message object.

    A message object is defined as something that has a bunch of RFC 2822
    headers and a payload.  It may optionally have an envelope header
    (a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a
    multipart or a message/rfc822), then the payload is a list of Message
    objects, otherwise it is a string.

    Message objects implement part of the `mapping' interface, which assumes
    there is exactly one occurrence of the header per message.  Some headers
    do in fact appear multiple times (e.g. Received) and for those headers,
    you must use the explicit API to set or get all the headers.  Not all of
    the mapping methods are implemented.
    c             C   sS   | |  _  g  |  _ d  |  _ d  |  _ d  |  _ d  |  _ |  _ g  |  _ d |  _ d  S)Nz
text/plain)	policy_headers	_unixfrom_payload_charsetZpreambleZepiloguedefects_default_type)selfr2   r   r   r   __init__y   s    						zMessage.__init__c             C   s
   |  j    S)z9Return the entire formatted message as a string.
        )	as_string)r9   r   r   r   __str__   s    zMessage.__str__Fr   Nc             C   so   d d l  m } | d k r% |  j n | } t   } | | d d d | d | } | j |  d | | j   S)	a  Return the entire formatted message as a string.

        Optional 'unixfrom', when true, means include the Unix From_ envelope
        header.  For backward compatibility reasons, if maxheaderlen is
        not specified it defaults to 0, so you must override it explicitly
        if you want a different maxheaderlen.  'policy' is passed to the
        Generator instance used to serialize the mesasge; if it is not
        specified the policy associated with the message instance is used.

        If the message object contains binary data that is not encoded
        according to RFC standards, the non-compliant data will be replaced by
        unicode "unknown character" code points.
        r   )	GeneratorNmangle_from_Fmaxheaderlenr2   unixfrom)email.generatorr=   r2   r   flattengetvalue)r9   r@   r?   r2   r=   fpgr   r   r   r;      s    			zMessage.as_stringc             C   s
   |  j    S)z?Return the entire formatted message as a bytes object.
        )as_bytes)r9   r   r   r   	__bytes__   s    zMessage.__bytes__c             C   si   d d l  m } | d k r% |  j n | } t   } | | d d d | } | j |  d | | j   S)aJ  Return the entire formatted message as a bytes object.

        Optional 'unixfrom', when true, means include the Unix From_ envelope
        header.  'policy' is passed to the BytesGenerator instance used to
        serialize the message; if not specified the policy associated with
        the message instance is used.
        r   )BytesGeneratorNr>   Fr2   r@   )rA   rH   r2   r   rB   rC   )r9   r@   r2   rH   rD   rE   r   r   r   rF      s    	zMessage.as_bytesc             C   s   t  |  j t  S)z6Return True if the message consists of multiple parts.)r   r5   list)r9   r   r   r   is_multipart   s    zMessage.is_multipartc             C   s   | |  _  d  S)N)r4   )r9   r@   r   r   r   set_unixfrom   s    zMessage.set_unixfromc             C   s   |  j  S)N)r4   )r9   r   r   r   get_unixfrom   s    zMessage.get_unixfromc             C   sW   |  j  d k r | g |  _  n5 y |  j  j |  Wn t k
 rR t d   Yn Xd S)zAdd the given payload to the current payload.

        The current payload will always be a list of objects after this method
        is called.  If you want to set the payload to a scalar object, use
        set_payload() instead.
        Nz=Attach is not valid on a message with a non-multipart payload)r5   r*   AttributeError	TypeError)r9   payloadr   r   r   attach   s    zMessage.attachc             C   sB  |  j    r4 | r d S| d k r) |  j S|  j | S| d k	 rl t |  j t  rl t d t |  j    |  j } t |  j d d   j   } t | t  rRt	 j
 |  r| j d d  } | sRy" | j |  j d d  d  } WqRt k
 r| j d d  } YqRXn= | rRy | j d  } Wn! t k
 rQ| j d	  } Yn X| s\| S| d
 k rut j |  S| d k rt d j | j     \ } } x! | D] } |  j j |  |  qW| S| d k r+t |  }	 t   }
 y$ t j |	 |
 d d |
 j   SWn t j k
 r*| SYn Xt | t  r>| S| S)aZ  Return a reference to the payload.

        The payload will either be a list object or a string.  If you mutate
        the list object, you modify the message's payload in place.  Optional
        i returns that index into the payload.

        Optional decode is a flag indicating whether the payload should be
        decoded or not, according to the Content-Transfer-Encoding header
        (default is False).

        When True and the message is not a multipart, the payload will be
        decoded if this header's value is `quoted-printable' or `base64'.  If
        some other encoding is used, or the header is missing, or if the
        payload has bogus data (i.e. bogus base64 or uuencoded data), the
        payload is returned as-is.

        If the message is a multipart and the decode flag is True, then None
        is returned.
        NzExpected list, got %szcontent-transfer-encodingr   r   surrogateescaper   replacezraw-unicode-escapezquoted-printablebase64    
x-uuencodeuuencodeuuex-uuequietT)rU   rV   rW   rX   )rJ   r5   r   rI   rN   typer   getr)   r   Z_has_surrogatesr   decode	get_paramLookupErrorUnicodeErrorquopriZdecodestringr	   join
splitlinesr2   Zhandle_defectr   uurC   Error)r9   r.   r\   rO   cteZbpayloadr"   r7   ZdefectZin_fileZout_filer   r   r   get_payload   sV    "	"!		zMessage.get_payloadc             C   s   t  | d  rU | d k r( | |  _ d St | t  sC t |  } | j | j  } t  | d  r| | j d d  |  _ n	 | |  _ | d k	 r |  j |  d S)zSet the payload to the given value.

        Optional charset sets the message's default character set.  See
        set_charset() for details.
        r   Nr\   r   rQ   )hasattrr5   r   Charsetr   output_charsetr\   set_charset)r9   rO   r   r   r   r   set_payload0  s    		zMessage.set_payloadc             C   s{  | d k r& |  j  d  d |  _ d St | t  sA t |  } | |  _ d |  k rf |  j d d  d |  k r |  j d d d | j   n |  j d | j    | | j   k r | j |  j  |  _ d |  k rw| j	   } y | |   Wn t
 k
 rv|  j } | rPy | j d d	  } Wn$ t k
 rO| j | j  } Yn X| j |  |  _ |  j d |  Yn Xd S)
a  Set the charset of the payload to a given character set.

        charset can be a Charset instance, a string naming a character set, or
        None.  If it is a string it will be converted to a Charset instance.
        If charset is None, the charset parameter will be removed from the
        Content-Type field.  Anything else will generate a TypeError.

        The message will be assumed to be of type text/* encoded with
        charset.input_charset.  It will be converted to charset.output_charset
        and encoded properly, if needed, when generating the plain text
        representation of the message.  MIME headers (MIME-Version,
        Content-Type, Content-Transfer-Encoding) will be added as needed.
        Nr   zMIME-Versionz1.0zContent-Typez
text/plainzContent-Transfer-Encodingr   rQ   )	del_paramr6   r   rh   
add_headerZget_output_charset	set_paramZbody_encoder5   Zget_body_encodingrN   r   r_   ri   )r9   r   re   rO   r   r   r   rj   D  s8    			zMessage.set_charsetc             C   s   |  j  S)zKReturn the Charset instance associated with the message's payload.
        )r6   )r9   r   r   r   get_charsets  s    zMessage.get_charsetc             C   s   t  |  j  S)z9Return the total number of headers, including duplicates.)r   r3   )r9   r   r   r   __len__{  s    zMessage.__len__c             C   s   |  j  |  S)a-  Get a header value.

        Return None if the header is missing instead of raising an exception.

        Note that if the header appeared multiple times, exactly which
        occurrence gets returned is undefined.  Use get_all() to get all
        the values matching a header field name.
        )r[   )r9   namer   r   r   __getitem__  s    	zMessage.__getitem__c             C   s   |  j  j |  } | r | j   } d } xW |  j D]L \ } } | j   | k r4 | d 7} | | k r4 t d j | |    q4 W|  j j |  j  j | |   d S)zSet the value of a header.

        Note: this does not overwrite an existing header with the same field
        name.  Use __delitem__() first to delete any existing headers.
        r   r   z/There may be at most {} {} headers in a messageN)r2   Zheader_max_countr)   r3   
ValueErrorformatr*   header_store_parse)r9   rq   valZ	max_countZlnamefoundkvr   r   r   __setitem__  s    
	zMessage.__setitem__c             C   s^   | j    } g  } x< |  j D]1 \ } } | j    | k r | j | | f  q W| |  _ d S)zwDelete all occurrences of a header, if present.

        Does not raise an exception if the header is missing.
        N)r)   r3   r*   )r9   rq   
newheadersrx   ry   r   r   r   __delitem__  s    zMessage.__delitem__c             C   s    | j    d d   |  j D k S)Nc             S   s"   g  |  ] \ } } | j     q Sr   )r)   ).0rx   ry   r   r   r   
<listcomp>  s   	 z(Message.__contains__.<locals>.<listcomp>)r)   r3   )r9   rq   r   r   r   __contains__  s    zMessage.__contains__c             c   s#   x |  j  D] \ } } | Vq
 Wd  S)N)r3   )r9   Zfieldr"   r   r   r   __iter__  s    zMessage.__iter__c             C   s   d d   |  j  D S)a.  Return a list of all the message's header field names.

        These will be sorted in the order they appeared in the original
        message, or were added to the message, and may contain duplicates.
        Any fields deleted and re-inserted are always appended to the header
        list.
        c             S   s   g  |  ] \ } } |  q Sr   r   )r}   rx   ry   r   r   r   r~     s   	 z Message.keys.<locals>.<listcomp>)r3   )r9   r   r   r   keys  s    zMessage.keysc                s     f d d     j  D S)a)  Return a list of all the message's header values.

        These will be sorted in the order they appeared in the original
        message, or were added to the message, and may contain duplicates.
        Any fields deleted and re-inserted are always appended to the header
        list.
        c                s+   g  |  ]! \ } }   j  j | |   q Sr   )r2   header_fetch_parse)r}   rx   ry   )r9   r   r   r~     s   	z"Message.values.<locals>.<listcomp>)r3   )r9   r   )r9   r   values  s    zMessage.valuesc                s     f d d     j  D S)a'  Get all the message's header fields and values.

        These will be sorted in the order they appeared in the original
        message, or were added to the message, and may contain duplicates.
        Any fields deleted and re-inserted are always appended to the header
        list.
        c                s1   g  |  ]' \ } } |   j  j | |  f  q Sr   )r2   r   )r}   rx   ry   )r9   r   r   r~     s   	z!Message.items.<locals>.<listcomp>)r3   )r9   r   )r9   r   items  s    zMessage.itemsc             C   sO   | j    } x< |  j D]1 \ } } | j    | k r |  j j | |  Sq W| S)z~Get a header value.

        Like __getitem__() but return failobj instead of None when the field
        is missing.
        )r)   r3   r2   r   )r9   rq   failobjrx   ry   r   r   r   r[     s
    zMessage.getc             C   s   |  j  j | | f  d S)zStore name and value in the model without modification.

        This is an "internal" API, intended only for use by a parser.
        N)r3   r*   )r9   rq   r"   r   r   r   set_raw  s    zMessage.set_rawc             C   s   t  |  j j    S)zReturn the (name, value) header pairs without modification.

        This is an "internal" API, intended only for use by a generator.
        )iterr3   copy)r9   r   r   r   	raw_items  s    zMessage.raw_itemsc             C   sh   g  } | j    } xE |  j D]: \ } } | j    | k r | j |  j j | |   q W| sd | S| S)aQ  Return a list of all the values for the named field.

        These will be sorted in the order they appeared in the original
        message, and may contain duplicates.  Any fields deleted and
        re-inserted are always appended to the header list.

        If no such fields exist, failobj is returned (defaults to None).
        )r)   r3   r*   r2   r   )r9   rq   r   r   rx   ry   r   r   r   get_all  s    	 zMessage.get_allc             K   s   g  } xd | j    D]V \ } } | d k rG | j | j d d   q | j t | j d d  |   q W| d k	 r | j d |  t j |  |  | <d S)u  Extended header setting.

        name is the header field to add.  keyword arguments can be used to set
        additional parameters for the header field, with underscores converted
        to dashes.  Normally the parameter will be added as key="value" unless
        value is None, in which case only the key will be added.  If a
        parameter value contains non-ASCII characters it can be specified as a
        three-tuple of (charset, language, value), in which case it will be
        encoded according to RFC2231 rules.  Otherwise it will be encoded using
        the utf-8 charset and a language of ''.

        Examples:

        msg.add_header('content-disposition', 'attachment', filename='bud.gif')
        msg.add_header('content-disposition', 'attachment',
                       filename=('utf-8', '', Fuballer.ppt'))
        msg.add_header('content-disposition', 'attachment',
                       filename='Fuballer.ppt'))
        N_-r   )r   r*   rR   r#   insert	SEMISPACEra   )r9   _name_valueZ_paramspartsrx   ry   r   r   r   rm     s    &zMessage.add_headerc             C   s   | j    } xp t t t |  j   |  j  D]A \ } \ } } | j    | k r. |  j j | |  |  j | <Pq. Wt |   d S)zReplace a header.

        Replace the first matching header found in the message, retaining
        header order and case.  If no matching header was found, a KeyError is
        raised.
        N)r)   zipranger   r3   r2   ru   KeyError)r9   r   r   r.   rx   ry   r   r   r   replace_header"  s    4zMessage.replace_headerc             C   sd   t    } |  j d |  } | | k r1 |  j   St |  d j   } | j d  d k r` d S| S)a0  Return the message's content type.

        The returned string is coerced to lower case of the form
        `maintype/subtype'.  If there was no Content-Type header in the
        message, the default type as given by get_default_type() will be
        returned.  Since according to RFC 2045, messages always have a default
        type this will always return a value.

        RFC 2045 defines a message's default type to be text/plain unless it
        appears inside a multipart/digest container, in which case it would be
        message/rfc822.
        zcontent-typer   /r   z
text/plain)objectr[   get_default_typer   r)   r'   )r9   missingr"   ctyper   r   r   get_content_type5  s    	
zMessage.get_content_typec             C   s   |  j    } | j d  d S)zReturn the message's main content type.

        This is the `maintype' part of the string returned by
        get_content_type().
        r   r   )r   split)r9   r   r   r   r   get_content_maintypeM  s    zMessage.get_content_maintypec             C   s   |  j    } | j d  d S)zReturns the message's sub-content type.

        This is the `subtype' part of the string returned by
        get_content_type().
        r   r   )r   r   )r9   r   r   r   r   get_content_subtypeV  s    zMessage.get_content_subtypec             C   s   |  j  S)a  Return the `default' content type.

        Most messages have a default content type of text/plain, except for
        messages that are subparts of multipart/digest containers.  Such
        subparts have a default content type of message/rfc822.
        )r8   )r9   r   r   r   r   _  s    zMessage.get_default_typec             C   s   | |  _  d S)zSet the `default' content type.

        ctype should be either "text/plain" or "message/rfc822", although this
        is not enforced.  The default content type is not stored in the
        Content-Type header.
        N)r8   )r9   r   r   r   r   set_default_typeh  s    zMessage.set_default_typec       	      C   s   t    } |  j | |  } | | k r+ | Sg  } x t |  D]t } y4 | j d d  \ } } | j   } | j   } Wn$ t k
 r | j   } d } Yn X| j | | f  q> Wt j |  } | S)Nr%   r   r   )	r   r[   r/   r   r   rs   r*   r   Zdecode_params)	r9   r   headerr   r"   paramsprq   rv   r   r   r   _get_params_preserveq  s     	zMessage._get_params_preservezcontent-typeTc             C   sJ   t    } |  j | |  } | | k r+ | S| rB d d   | D S| Sd S)am  Return the message's Content-Type parameters, as a list.

        The elements of the returned list are 2-tuples of key/value pairs, as
        split on the `=' sign.  The left hand side of the `=' is the key,
        while the right hand side is the value.  If there is no `=' sign in
        the parameter the value is the empty string.  The value is as
        described in the get_param() method.

        Optional failobj is the object to return if there is no Content-Type
        header.  Optional header is the header to search instead of
        Content-Type.  If unquote is True, the value is unquoted.
        c             S   s(   g  |  ] \ } } | t  |  f  q Sr   )r1   )r}   rx   ry   r   r   r   r~     s   	 z&Message.get_params.<locals>.<listcomp>N)r   r   )r9   r   r   r0   r   r   r   r   r   
get_params  s    	zMessage.get_paramsc             C   sc   | |  k r | SxL |  j  | |  D]8 \ } } | j   | j   k r# | rW t |  S| Sq# W| S)a  Return the parameter value if found in the Content-Type header.

        Optional failobj is the object to return if there is no Content-Type
        header, or the Content-Type header has no such parameter.  Optional
        header is the header to search instead of Content-Type.

        Parameter keys are always compared case insensitively.  The return
        value can either be a string, or a 3-tuple if the parameter was RFC
        2231 encoded.  When it's a 3-tuple, the elements of the value are of
        the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and
        LANGUAGE can be None, in which case you should consider VALUE to be
        encoded in the us-ascii charset.  You can usually ignore LANGUAGE.
        The parameter value (either the returned string, or the VALUE item in
        the 3-tuple) is always unquoted, unless unquote is set to False.

        If your application doesn't care whether the parameter was RFC 2231
        encoded, it can turn the return value into a string as follows:

            rawparam = msg.get_param('foo')
            param = email.utils.collapse_rfc2231_value(rawparam)

        )r   r)   r1   )r9   r   r   r   r0   rx   ry   r   r   r   r]     s    
zMessage.get_paramzContent-Typer   c             C   s  t  | t  r% | r% | | | f } | |  k rL | j   d k rL d } n |  j |  } |  j | d | s | s t | | |  } qGt j | t | | |  g  } n d } x |  j d | d |  D]u \ }	 }
 d } |	 j   | j   k rt | | |  } n t |	 |
 |  } | s.| } q t j | | g  } q W| |  j |  k r| ru|  j	 | |  n |  | =| |  | <d S)a  Set a parameter in the Content-Type header.

        If the parameter already exists in the header, its value will be
        replaced with the new value.

        If header is Content-Type and has not yet been defined for this
        message, it will be set to "text/plain" and the new parameter and
        value will be appended as per RFC 2045.

        An alternate header can be specified in the header argument, and all
        parameters will be quoted as necessary unless requote is False.

        If charset is specified, the parameter will be encoded according to RFC
        2231.  Optional language specifies the RFC 2231 language, defaulting
        to the empty string.  Both charset and language should be strings.
        zcontent-typez
text/plainr   r   r0   N)
r   r   r)   r[   r]   r#   r   ra   r   r   )r9   r   r"   r   requoter   ZlanguagerR   r   Z	old_paramZ	old_valueZappend_paramr   r   r   rn     s2    		zMessage.set_paramc             C   s   | |  k r d Sd } xz |  j  d | d |  D]` \ } } | j   | j   k r/ | sn t | | |  } q/ t j | t | | |  g  } q/ W| |  j |  k r |  | =| |  | <d S)a>  Remove the given parameter completely from the Content-Type header.

        The header will be re-written in place without the parameter or its
        value. All values will be quoted as necessary unless requote is
        False.  Optional header specifies an alternative to the Content-Type
        header.
        Nr   r   r0   )r   r)   r#   r   ra   r[   )r9   r   r   r   Z	new_ctyper   ry   r   r   r   rl     s    %	zMessage.del_paramc             C   s   | j  d  d k s t  | j   d k r> |  d =d |  d <| |  k rX | |  | <d S|  j d | d	 |  } |  | =| |  | <x4 | d d  D]" \ } } |  j | | | |  q Wd S)
aK  Set the main type and subtype for the Content-Type header.

        type must be a string in the form "maintype/subtype", otherwise a
        ValueError is raised.

        This method replaces the Content-Type header, keeping all the
        parameters in place.  If requote is False, this leaves the existing
        header's quoting as is.  Otherwise, the parameters will be quoted (the
        default).

        An alternative header can be specified in the header argument.  When
        the Content-Type header is set, we'll always also add a MIME-Version
        header.
        r   r   zcontent-typezmime-versionz1.0zMIME-VersionNr   r0   )r'   rs   r)   r   rn   )r9   rZ   r   r   r   r   ry   r   r   r   set_type  s    


zMessage.set_typec             C   sb   t    } |  j d | d  } | | k r? |  j d | d  } | | k rO | St j |  j   S)a@  Return the filename associated with the payload if present.

        The filename is extracted from the Content-Disposition header's
        `filename' parameter, and it is unquoted.  If that header is missing
        the `filename' parameter, this method falls back to looking for the
        `name' parameter.
        filenamezcontent-dispositionrq   zcontent-type)r   r]   r   collapse_rfc2231_valuer   )r9   r   r   r   r   r   r   get_filename'  s    	zMessage.get_filenamec             C   s>   t    } |  j d |  } | | k r+ | St j |  j   S)zReturn the boundary associated with the payload if present.

        The boundary is extracted from the Content-Type header's `boundary'
        parameter, and it is unquoted.
        boundary)r   r]   r   r   rstrip)r9   r   r   r   r   r   r   get_boundary7  s
    	zMessage.get_boundaryc             C   s  t    } |  j | d  } | | k r6 t j d   g  } d } xY | D]Q \ } } | j   d k r | j d d | f  d } qI | j | | f  qI W| s | j d d | f  g  } x |  j D] \ }	 }
 |	 j   d k rgg  } xG | D]? \ } }
 |
 d k r| j |  q | j d | |
 f  q Wt j |  } | j |  j	 j
 |	 |   q | j |	 |
 f  q W| |  _ d	 S)
a  Set the boundary parameter in Content-Type to 'boundary'.

        This is subtly different than deleting the Content-Type header and
        adding a new one with a new boundary parameter via add_header().  The
        main difference is that using the set_boundary() method preserves the
        order of the Content-Type header in the original message.

        HeaderParseError is raised if the message has no Content-Type header.
        zcontent-typezNo Content-Type header foundFr   z"%s"Tr   z%s=%sN)r   r   r   ZHeaderParseErrorr)   r*   r3   r   ra   r2   ru   )r9   r   r   r   Z	newparamsZfoundpZpkZpvr{   hry   r   rx   rv   r   r   r   set_boundaryD  s2    
		zMessage.set_boundaryc             C   s   t    } |  j d |  } | | k r+ | St | t  r | d pG d } y& | d j d  } t | |  } Wn" t t f k
 r | d } Yn Xy | j d  Wn t k
 r | SYn X| j   S)zReturn the charset parameter of the Content-Type header.

        The returned string is always coerced to lower case.  If there is no
        Content-Type header, or if that header has no charset parameter,
        failobj is returned.
        r   r   zus-asciir   zraw-unicode-escape)	r   r]   r   r   r   r   r^   r_   r)   )r9   r   r   r   ZpcharsetrF   r   r   r   get_content_charsetr  s     		zMessage.get_content_charsetc                s     f d d   |  j    D S)a  Return a list containing the charset(s) used in this message.

        The returned list of items describes the Content-Type headers'
        charset parameter for this message and all the subparts in its
        payload.

        Each item will either be a string (the value of the charset parameter
        in the Content-Type header of that part) or the value of the
        'failobj' parameter (defaults to None), if the part does not have a
        main MIME type of "text", or the charset is not defined.

        The list will contain one string for each part of the message, plus
        one for the container message (i.e. self), so that a non-multipart
        message will still return a list of length 1.
        c                s   g  |  ] } | j      q Sr   )r   )r}   part)r   r   r   r~     s   	 z(Message.get_charsets.<locals>.<listcomp>)walk)r9   r   r   )r   r   get_charsets  s    zMessage.get_charsetsc             C   s9   |  j  d  } | d k r d St |  d j   } | S)zReturn the message's content-disposition if it exists, or None.

        The return values can be either 'inline', 'attachment' or None
        according to the rfc2183.
        zcontent-dispositionNr   )r[   r   r)   )r9   r"   c_dr   r   r   get_content_disposition  s
    zMessage.get_content_disposition)r   )4__name__
__module____qualname____doc__r   r:   r<   r;   rG   rF   rJ   rK   rL   rP   rf   rk   rj   ro   rp   rr   rz   r|   r   r   r   r   r   r[   r   r   r   rm   r   r   r   r   r   r   r   r   r]   rn   rl   r   r   r   r   r   r   r   Zemail.iteratorsr   r   r   r   r   r   j   sb   Z/
				!2 .c               @   s  e  Z d  Z d d d  Z d d   Z d d   Z d. d d  Z d/ d0 d1 d2 h Z d d   Z d d   Z	 d d d d  Z
 d d d d  Z d d   Z d d d  Z d d d  Z d d d   Z d! d d" d#  Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d S)3MIMEPartNc             C   s6   | d  k r" d d l  m } | } t j |  |  d  S)Nr   )default)Zemail.policyr   r   r:   )r9   r2   r   r   r   r   r:     s    zMIMEPart.__init__c             C   s,   |  j  d  } | d  k r d S| j d k S)Nzcontent-dispositionF
attachment)r[   Zcontent_disposition)r9   r   r   r   r   is_attachment  s    zMIMEPart.is_attachmentc       	      c   sc  | j    r d  S| j   j d  \ } } | d k r[ | | k rW | j |  | f Vd  S| d k rk d  S| d k r x) | j   D] } |  j | |  Ed  Hq Wd  Sd | k r | j d  | f Vd  } | j d  } | rx+ | j   D] } | d | k r | } Pq W| d  k r>| j   } | r8| d n d  } | d  k	 r_|  j | |  Ed  Hd  S)Nr   text	multipartrelatedstartz
content-idr   )r   r   r   r(   
iter_parts
_find_bodyr]   rf   )	r9   r   preferencelistmaintypesubtypeZsubpart	candidater   Zsubpartsr   r   r   r     s6    zMIMEPart._find_bodyr   htmlplainc             C   s^   t  |  } d } xE |  j |  |  D]1 \ } } | | k  r% | } | } | d k r% Pq% W| S)a  Return best candidate mime part for display as 'body' of message.

        Do a depth first search, starting with self, looking for the first part
        matching each of the items in preferencelist, and return the part
        corresponding to the first item that has a match, or None if no items
        have a match.  If 'related' is not included in preferencelist, consider
        the root part of any multipart/related encountered as a candidate
        match.  Ignore parts with 'Content-Disposition: attachment'.
        Nr   )r   r   )r9   r   Z	best_prioZbodyZprior   r   r   r   get_body  s    
zMIMEPart.get_bodyr   r   alternativec       	      c   sd  |  j    j d  \ } } | d k s3 | d k r7 d S|  j   j   } | d k r | d k r |  j d  } | r d } g  } x9 | D]1 } | j d  | k r d	 } q | j |  q W| r | Ed Hd S| j d
  | Ed Hd Sg  } xl | D]d } | j    j d  \ } } | | f |  j k rW| j	   rW| | k rW| j |  q | Vq Wd S)a  Return an iterator over the non-main parts of a multipart.

        Skip the first of each occurrence of text/plain, text/html,
        multipart/related, or multipart/alternative in the multipart (unless
        they have a 'Content-Disposition: attachment' header) and include all
        remaining subparts in the returned iterator.  When applied to a
        multipart/related, return all parts except the root part.  Return an
        empty iterator when applied to a multipart/alternative or a
        non-multipart.
        r   r   r   Nr   r   Fz
content-idTr   )
r   r   rf   r   r]   r[   r*   pop_body_typesr   )	r9   r   r   r   r   rw   Zattachmentsr   seenr   r   r   iter_attachments  s6    			zMIMEPart.iter_attachmentsc             c   s%   |  j    d k r! |  j   Ed Hd S)z~Return an iterator over all immediate subparts of a multipart.

        Return an empty iterator for a non-multipart.
        r   N)r   rf   )r9   r   r   r   r   !  s    zMIMEPart.iter_partscontent_managerc            O   s+   | d  k r |  j  j } | j |  | |  S)N)r2   r   get_content)r9   r   argskwr   r   r   r   )  s    zMIMEPart.get_contentc            O   s/   | d  k r |  j  j } | j |  | |  d  S)N)r2   r   set_content)r9   r   r   r   r   r   r   r   .  s    zMIMEPart.set_contentc       
      C   s5  |  j    d k rO |  j   } | | f } | | k rO t d j | |    g  } g  } xU |  j D]J \ } } | j   j d  r | j | | f  qe | j | | f  qe W| r t |   d |  j	  }	 | |	 _ |  j
 |	 _
 |	 g |  _
 n	 g  |  _
 | |  _ d | |  d <| d  k	 r1|  j d |  d  S)Nr   zCannot convert {} to {}zcontent-r2   z
multipart/zContent-Typer   )r   r   rs   rt   r3   r)   
startswithr*   rZ   r2   r5   rn   )
r9   r   Zdisallowed_subtypesr   Zexisting_subtypeZkeep_headersZpart_headersrq   r"   r   r   r   r   _make_multipart3  s,    				zMIMEPart._make_multipartc             C   s   |  j  d d |  d  S)Nr   r   mixed)r   r   )r   )r9   r   r   r   r   make_relatedN  s    zMIMEPart.make_relatedc             C   s   |  j  d d |  d  S)Nr   r   )r   )r   )r9   r   r   r   r   make_alternativeQ  s    zMIMEPart.make_alternativec             C   s   |  j  d f  |  d  S)Nr   )r   )r9   r   r   r   r   
make_mixedT  s    zMIMEPart.make_mixed_dispc            O   s   |  j    d k s$ |  j   | k r8 t |  d |    t |   d |  j  } | j | |   | r| d | k r| | | d <|  j |  d  S)Nr   Zmake_r2   zcontent-dispositionzContent-Disposition)r   r   getattrrZ   r2   r   rP   )r9   Z_subtyper   r   r   r   r   r   r   _add_multipartW  s    
zMIMEPart._add_multipartc             O   s   |  j  d | d d | d  S)Nr   r   Zinline)r   )r9   r   r   r   r   r   add_relateda  s    zMIMEPart.add_relatedc             O   s   |  j  d | |  d  S)Nr   )r   )r9   r   r   r   r   r   add_alternatived  s    zMIMEPart.add_alternativec             O   s   |  j  d | d d | d  S)Nr   r   r   )r   )r9   r   r   r   r   r   add_attachmentg  s    zMIMEPart.add_attachmentc             C   s   g  |  _  d  |  _ d  S)N)r3   r5   )r9   r   r   r   clearj  s    	zMIMEPart.clearc             C   s&   d d   |  j  D |  _  d  |  _ d  S)Nc             S   s7   g  |  ]- \ } } | j    j d   s | | f  q S)zcontent-)r)   r   )r}   nry   r   r   r   r~   o  s   	 	z*MIMEPart.clear_content.<locals>.<listcomp>)r3   r5   )r9   r   r   r   clear_contentn  s    zMIMEPart.clear_content)r   r   r   )r   r   )r   r   )r   r   )r   r   )r   r   r   r:   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r     s,   	.
r   c                   s"   e  Z d  Z   f d d   Z   S)EmailMessagec                s-   t    j | |   d |  k r) d |  d <d  S)NzMIME-Versionz1.0)superr   )r9   r   r   )	__class__r   r   r   v  s    zEmailMessage.set_content)r   r   r   r   r   r   )r   r   r   t  s   r   )r   __all__rerc   r`   warningsior   r   Zemailr   r   Zemail._policybaser   r   r6   Zemail._encoded_wordsr	   rh   r   compiler   r   r#   r/   r1   r   r   r   r   r   r   r   <module>   s0   		
"   K                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Copyright (C) 2001-2006 Python Software Foundation
# Author: Keith Dart
# Contact: email-sig@python.org

"""Class representing application/* type MIME documents."""

__all__ = ["MIMEApplication"]

from email import encoders
from email.mime.nonmultipart import MIMENonMultipart


class MIMEApplication(MIMENonMultipart):
    """Class for generating application/* MIME documents."""

    def __init__(self, _data, _subtype='octet-stream',
                 _encoder=encoders.encode_base64, **_params):
        """Create an application/* type MIME document.

        _data is a string containing the raw application data.

        _subtype is the MIME content type subtype, defaulting to
        'octet-stream'.

        _encoder is a function which will perform the actual encoding for
        transport of the application data, defaulting to base64 encoding.

        Any additional keyword arguments are passed to the base class
        constructor, which turns them into parameters on the Content-Type
        header.
        """
        if _subtype is None:
            raise TypeError('Invalid application MIME subtype')
        MIMENonMultipart.__init__(self, 'application', _subtype, **_params)
        self.set_payload(_data)
        _encoder(self)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
[                 @   s   d  Z  d d d d d d g Z d d l m Z m Z d d	 l m Z m Z d d
 l m	 Z	 Gd d   d  Z
 Gd d   d e
  Z Gd d   d  Z Gd d   d e  Z d S)z-A parser of RFC 2822 and MIME email messages.ParserHeaderParserBytesParserBytesHeaderParser
FeedParserBytesFeedParser    )StringIOTextIOWrapper)r   r   )compat32c               @   sC   e  Z d  Z d d e d d Z d d d  Z d d d	  Z d S)
r   Npolicyc            C   s   | |  _  | |  _ d S)a  Parser of RFC 2822 and MIME email messages.

        Creates an in-memory object tree representing the email message, which
        can then be manipulated and turned over to a Generator to return the
        textual representation of the message.

        The string must be formatted as a block of RFC 2822 headers and header
        continuation lines, optionally preceded by a `Unix-from' header.  The
        header block is terminated either by the end of the string or by a
        blank line.

        _class is the class to instantiate for new message objects when they
        must be created.  This class must have a constructor that can take
        zero arguments.  Default is Message.Message.

        The policy keyword specifies a policy object that controls a number of
        aspects of the parser's operation.  The default policy maintains
        backward compatibility.

        N)_classr   )selfr   r    r   "/usr/lib/python3.5/email/parser.py__init__   s    	zParser.__init__Fc             C   s\   t  |  j d |  j } | r( | j   x' | j d  } | sA P| j |  q+ W| j   S)a\  Create a message structure from the data in a file.

        Reads all the data from the file and returns the root of the message
        structure.  Optional headersonly is a flag specifying whether to stop
        parsing after reading the headers or not.  The default is False,
        meaning it parses the entire contents of the file.
        r   i    )r   r   r   Z_set_headersonlyreadZfeedclose)r   fpheadersonlyZ
feedparserdatar   r   r   parse*   s    
zParser.parsec             C   s   |  j  t |  d | S)a-  Create a message structure from a string.

        Returns the root of the message structure.  Optional headersonly is a
        flag specifying whether to stop parsing after reading the headers or
        not.  The default is False, meaning it parses the entire contents of
        the file.
        r   )r   r   )r   textr   r   r   r   parsestr<   s    zParser.parsestr)__name__
__module____qualname__r
   r   r   r   r   r   r   r   r      s   c               @   s.   e  Z d  Z d d d  Z d d d  Z d S)r   Tc             C   s   t  j |  | d  S)NT)r   r   )r   r   r   r   r   r   r   I   s    zHeaderParser.parsec             C   s   t  j |  | d  S)NT)r   r   )r   r   r   r   r   r   r   L   s    zHeaderParser.parsestrN)r   r   r   r   r   r   r   r   r   r   H   s   c               @   s:   e  Z d  Z d d   Z d d d  Z d d d  Z d S)	r   c             O   s   t  | |   |  _ d S)a  Parser of binary RFC 2822 and MIME email messages.

        Creates an in-memory object tree representing the email message, which
        can then be manipulated and turned over to a Generator to return the
        textual representation of the message.

        The input must be formatted as a block of RFC 2822 headers and header
        continuation lines, optionally preceded by a `Unix-from' header.  The
        header block is terminated either by the end of the input or by a
        blank line.

        _class is the class to instantiate for new message objects when they
        must be created.  This class must have a constructor that can take
        zero arguments.  Default is Message.Message.
        N)r   parser)r   argskwr   r   r   r   R   s    zBytesParser.__init__Fc          
   C   sA   t  | d d d d } z |  j j | |  SWd | j   Xd S)ac  Create a message structure from the data in a binary file.

        Reads all the data from the file and returns the root of the message
        structure.  Optional headersonly is a flag specifying whether to stop
        parsing after reading the headers or not.  The default is False,
        meaning it parses the entire contents of the file.
        encodingasciierrorssurrogateescapeN)r	   r   r   detach)r   r   r   r   r   r   r   d   s    zBytesParser.parsec             C   s(   | j  d d d } |  j j | |  S)a2  Create a message structure from a byte string.

        Returns the root of the message structure.  Optional headersonly is a
        flag specifying whether to stop parsing after reading the headers or
        not.  The default is False, meaning it parses the entire contents of
        the file.
        ASCIIr!   r"   )decoder   r   )r   r   r   r   r   r   
parsebytess   s    zBytesParser.parsebytesN)r   r   r   r   r   r&   r   r   r   r   r   P   s   c               @   s.   e  Z d  Z d d d  Z d d d  Z d S)r   Tc             C   s   t  j |  | d d S)Nr   T)r   r   )r   r   r   r   r   r   r      s    zBytesHeaderParser.parsec             C   s   t  j |  | d d S)Nr   T)r   r&   )r   r   r   r   r   r   r&      s    zBytesHeaderParser.parsebytesN)r   r   r   r   r&   r   r   r   r   r      s   N)__doc____all__ior   r	   Zemail.feedparserr   r   Zemail._policybaser
   r   r   r   r   r   r   r   r   <module>   s   7/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
[;(                 @   s  d  Z  d d l Z d d l m Z m Z m Z m Z d d l m Z d d l	 m
 Z
 d d l m Z d d d	 d
 d d d d g Z e j d  Z e Gd d
   d
 e   Z e   Z e ` e j d d  Z e j d d  Z e j d d d d  Z e j d d  Z d S)zcThis will be the home for the policy that hooks in the new
code that adds all the email6 features.
    N)PolicyCompat32compat32_extend_docstrings)_has_surrogates)HeaderRegistry)raw_data_managerr   r   r   EmailPolicydefaultstrictSMTPHTTPz\n|\rc                   s   e  Z d  Z d Z d Z d Z e   Z e Z	   f d d   Z
 d d   Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z d d d  Z   S)r	   aQ  +
    PROVISIONAL

    The API extensions enabled by this policy are currently provisional.
    Refer to the documentation for details.

    This policy adds new header parsing and folding algorithms.  Instead of
    simple strings, headers are custom objects with custom attributes
    depending on the type of the field.  The folding algorithm fully
    implements RFCs 2047 and 5322.

    In addition to the settable attributes listed above that apply to
    all Policies, this policy adds the following additional attributes:

    utf8                -- if False (the default) message headers will be
                           serialized as ASCII, using encoded words to encode
                           any non-ASCII characters in the source strings.  If
                           True, the message headers will be serialized using
                           utf8 and will not contain encoded words (see RFC
                           6532 for more on this serialization format).

    refold_source       -- if the value for a header in the Message object
                           came from the parsing of some source, this attribute
                           indicates whether or not a generator should refold
                           that value when transforming the message back into
                           stream form.  The possible values are:

                           none  -- all source values use original folding
                           long  -- source values that have any line that is
                                    longer than max_line_length will be
                                    refolded
                           all  -- all values are refolded.

                           The default is 'long'.

    header_factory      -- a callable that takes two arguments, 'name' and
                           'value', where 'name' is a header field name and
                           'value' is an unfolded header field value, and
                           returns a string-like object that represents that
                           header.  A default header_factory is provided that
                           understands some of the RFC5322 header field types.
                           (Currently address fields and date fields have
                           special treatment, while all other fields are
                           treated as unstructured.  This list will be
                           completed before the extension is marked stable.)

    content_manager     -- an object with at least two methods: get_content
                           and set_content.  When the get_content or
                           set_content method of a Message object is called,
                           it calls the corresponding method of this object,
                           passing it the message object as its first argument,
                           and any arguments or keywords that were passed to
                           it as additional arguments.  The default
                           content_manager is
                           :data:`~email.contentmanager.raw_data_manager`.

    Flongc                s6   d | k r" t  j |  d t    t   j |   d  S)Nheader_factory)object__setattr__r   super__init__)selfkw)	__class__ "/usr/lib/python3.5/email/policy.pyr   Z   s    zEmailPolicy.__init__c             C   s   |  j  | j S)z+
        The implementation for this class returns the max_count attribute from
        the specialized header class that would be used to construct a header
        of type 'name'.
        )r   Z	max_count)r   namer   r   r   header_max_counta   s    zEmailPolicy.header_max_countc             C   sU   | d j  d d  \ } } | j d  d j | d d   } | | j d  f S)ac  +
        The name is parsed as everything up to the ':' and returned unmodified.
        The value is determined by stripping leading whitespace off the
        remainder of the first line, joining all subsequent lines together, and
        stripping any trailing carriage return or linefeed characters.  (This
        is the same as Compat32).

        r   :   z 	 Nz
)splitlstripjoinrstrip)r   Zsourcelinesr   valuer   r   r   header_source_parses   s    	&zEmailPolicy.header_source_parsec             C   s}   t  | d  r4 | j j   | j   k r4 | | f St | t  rg t | j    d k rg t d   | |  j | |  f S)a  +
        The name is returned unchanged.  If the input value has a 'name'
        attribute and it matches the name ignoring case, the value is returned
        unchanged.  Otherwise the name and value are passed to header_factory
        method, and the resulting custom header object is returned as the
        value.  In this case a ValueError is raised if the input value contains
        CR or LF characters.

        r   r   zDHeader values may not contain linefeed or carriage return characters)	hasattrr   lower
isinstancestrlen
splitlines
ValueErrorr   )r   r   r"   r   r   r   header_store_parse   s
    
*
'zEmailPolicy.header_store_parsec             C   s;   t  | d  r | Sd j t j |   } |  j | |  S)ai  +
        If the value has a 'name' attribute, it is returned to unmodified.
        Otherwise the name and the value with any linesep characters removed
        are passed to the header_factory method, and the resulting custom
        header object is returned.  Any surrogateescaped bytes get turned
        into the unicode unknown-character glyph.

        r   r   )r$   r    linesep_splitterr   r   )r   r   r"   r   r   r   header_fetch_parse   s    	zEmailPolicy.header_fetch_parsec             C   s   |  j  | | d d S)a  +
        Header folding is controlled by the refold_source policy setting.  A
        value is considered to be a 'source value' if and only if it does not
        have a 'name' attribute (having a 'name' attribute means it is a header
        object of some sort).  If a source value needs to be refolded according
        to the policy, it is converted into a custom header object by passing
        the name and the value with any linesep characters removed to the
        header_factory method.  Folding of a custom header object is done by
        calling its fold method with the current policy.

        Source values are split into lines using splitlines.  If the value is
        not to be refolded, the lines are rejoined using the linesep from the
        policy and returned.  The exception is lines containing non-ascii
        binary data.  In that case the value is refolded regardless of the
        refold_source setting, which causes the binary data to be CTE encoded
        using the unknown-8bit charset.

        refold_binaryT)_fold)r   r   r"   r   r   r   fold   s    zEmailPolicy.foldc             C   sF   |  j  | | d |  j d k } |  j r0 d n d } | j | d  S)a  +
        The same as fold if cte_type is 7bit, except that the returned value is
        bytes.

        If cte_type is 8bit, non-ASCII binary data is converted back into
        bytes.  Headers with binary data are not refolded, regardless of the
        refold_header setting, since there is no way to know whether the binary
        data consists of single byte characters or multibyte characters.

        If utf8 is true, headers are encoded to utf8, otherwise to ascii with
        non-ASCII unicode rendered as encoded words.

        r.   Z7bitutf8asciisurrogateescape)r/   Zcte_typer1   encode)r   r   r"   Zfoldedcharsetr   r   r   fold_binary   s    !zEmailPolicy.fold_binaryc                s  t  | d  r | j d |   S|  j r1 |  j n	 t d    | j   } |  j d k p |  j d k o | r t | d  t |  d   k p t   f d d	   | d
 d   D  } | s | r t |  r |  j	 | d j
 |   j d |   S| d |  j j
 |  |  j S)Nr   Zpolicyinfallr   r      c             3   s!   |  ] } t  |    k Vq d  S)N)r(   ).0x)maxlenr   r   	<genexpr>   s    z$EmailPolicy._fold.<locals>.<genexpr>r   r   z: )r$   r0   max_line_lengthfloatr)   refold_sourcer(   anyr   r   r    linesep)r   r   r"   r.   linesZrefoldr   )r<   r   r/      s    *)%zEmailPolicy._fold)__name__
__module____qualname____doc__r1   r@   r   r   r   Zcontent_managerr   r   r#   r+   r-   r0   r6   r/   r   r   )r   r   r	      s   ;	Zraise_on_defectTrB   z
r>   r1   )rG   reZemail._policybaser   r   r   r   Zemail.utilsr   Zemail.headerregistryr   Zemail.contentmanagerr   __all__compiler,   r	   r
   r   Zcloner   r   r   ZSMTPUTF8r   r   r   r   <module>   s,   "		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Copyright (C) 2001-2007 Python Software Foundation
# Author: Anthony Baxter
# Contact: email-sig@python.org

"""Class representing audio/* type MIME documents."""

__all__ = ['MIMEAudio']

import sndhdr

from io import BytesIO
from email import encoders
from email.mime.nonmultipart import MIMENonMultipart



_sndhdr_MIMEmap = {'au'  : 'basic',
                   'wav' :'x-wav',
                   'aiff':'x-aiff',
                   'aifc':'x-aiff',
                   }

# There are others in sndhdr that don't have MIME types. :(
# Additional ones to be added to sndhdr? midi, mp3, realaudio, wma??
def _whatsnd(data):
    """Try to identify a sound file type.

    sndhdr.what() has a pretty cruddy interface, unfortunately.  This is why
    we re-do it here.  It would be easier to reverse engineer the Unix 'file'
    command and use the standard 'magic' file, as shipped with a modern Unix.
    """
    hdr = data[:512]
    fakefile = BytesIO(hdr)
    for testfn in sndhdr.tests:
        res = testfn(hdr, fakefile)
        if res is not None:
            return _sndhdr_MIMEmap.get(res[0])
    return None



class MIMEAudio(MIMENonMultipart):
    """Class for generating audio/* MIME documents."""

    def __init__(self, _audiodata, _subtype=None,
                 _encoder=encoders.encode_base64, **_params):
        """Create an audio/* type MIME document.

        _audiodata is a string containing the raw audio data.  If this data
        can be decoded by the standard Python `sndhdr' module, then the
        subtype will be automatically included in the Content-Type header.
        Otherwise, you can specify  the specific audio subtype via the
        _subtype parameter.  If _subtype is not given, and no subtype can be
        guessed, a TypeError is raised.

        _encoder is a function which will perform the actual encoding for
        transport of the image data.  It takes one argument, which is this
        Image instance.  It should use get_payload() and set_payload() to
        change the payload to the encoded form.  It should also add any
        Content-Transfer-Encoding or other headers to the message as
        necessary.  The default encoding is Base64.

        Any additional keyword arguments are passed to the base class
        constructor, which turns them into parameters on the Content-Type
        header.
        """
        if _subtype is None:
            _subtype = _whatsnd(_audiodata)
        if _subtype is None:
            raise TypeError('Could not find audio MIME subtype')
        MIMENonMultipart.__init__(self, 'audio', _subtype, **_params)
        self.set_payload(_audiodata)
        _encoder(self)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
[&              
   @   s  d  Z  d d d d d d d d d	 d
 g
 Z d d l Z d d l m Z m Z m Z d Z d Z d Z	 d d   e
 d  D Z e d d  Z e d d  Z x8 d e j d  e j d  D] Z e e  e e <q Wd e e d  <x d D] Z e e  e e <q Wd d   Z d d   Z d d   Z d d   Z d d d   Z d! d
   Z d" d	   Z d# d$ d  Z e d d  Z x d% D] Z e e  e e <qWd& e d' d  Z e d( d  Z e Z e Z d) d*   Z d+ d   Z  d S),aF  Quoted-printable content transfer encoding per RFCs 2045-2047.

This module handles the content transfer encoding method defined in RFC 2045
to encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to
safely encode text that is in a character set similar to the 7-bit US ASCII
character set, but that includes some 8-bit characters that are normally not
allowed in email bodies or headers.

Quoted-printable is very space-inefficient for encoding binary files; use the
email.base64mime module for that instead.

This module provides an interface to encode and decode both headers and bodies
with quoted-printable encoding.

RFC 2045 defines a method for including character set information in an
`encoded-word' in a header.  This method is commonly used for 8-bit real names
in To:/From:/Cc: etc. fields, as well as Subject: lines.

This module does not do the line wrapping or end-of-line character
conversion necessary for proper internationalized headers; it only
does dumb encoding and decoding.  To deal with the various line
wrapping issues, use the email.header module.
body_decodebody_encodebody_lengthdecodedecodestringheader_decodeheader_encodeheader_lengthquoteunquote    N)ascii_lettersdigits	hexdigitsz

 c             C   s   g  |  ] } d  |  q S)z=%02X ).0cr   r   &/usr/lib/python3.5/email/quoprimime.py
<listcomp>7   s   	 r      s   -!*+/ascii_ s_    !"#$%&'()*+,-./0123456789:;<>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~	c             C   s   t  |   t |  k S)z>Return True if the octet should be escaped with header quopri.)chr_QUOPRI_HEADER_MAP)octetr   r   r   header_checkJ   s    r   c             C   s   t  |   t |  k S)z<Return True if the octet should be escaped with body quopri.)r   _QUOPRI_BODY_MAP)r   r   r   r   
body_checkO   s    r   c             C   s   t  d d   |  D  S)a:  Return a header quoted-printable encoding length.

    Note that this does not include any RFC 2047 chrome added by
    `header_encode()`.

    :param bytearray: An array of bytes (a.k.a. octets).
    :return: The length in bytes of the byte array when it is encoded with
        quoted-printable for headers.
    c             s   s   |  ] } t  t |  Vq d  S)N)lenr   )r   r   r   r   r   	<genexpr>^   s    z header_length.<locals>.<genexpr>)sum)	bytearrayr   r   r   r   T   s    
c             C   s   t  d d   |  D  S)zReturn a body quoted-printable encoding length.

    :param bytearray: An array of bytes (a.k.a. octets).
    :return: The length in bytes of the byte array when it is encoded with
        quoted-printable for bodies.
    c             s   s   |  ] } t  t |  Vq d  S)N)r    r   )r   r   r   r   r   r!   h   s    zbody_length.<locals>.<genexpr>)r"   )r#   r   r   r   r   a   s    c             C   s   t  | t  s t |  } |  s7 |  j | j    nH t |  d  t |  | k rl |  d | | 7<n |  j | j    d  S)N   r%   )
isinstancestrr   appendlstripr    )LsmaxlenZextrar   r   r   _max_appendk   s     r-   c             C   s   t  t |  d d  d   S)zDTurn a string in the form =AB to the ASCII character with value 0xabr$         )r   int)r+   r   r   r   r
   v   s    c             C   s   t  t |   S)N)_QUOPRI_MAPord)r   r   r   r   r	   {   s    z
iso-8859-1c             C   s0   |  s
 d S|  j  d  j t  } d | | f S)a  Encode a single header line with quoted-printable (like) encoding.

    Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but
    used specifically for email header fields to allow charsets with mostly 7
    bit characters (and some 8 bit) to remain more or less readable in non-RFC
    2045 aware mail clients.

    charset names the character set to use in the RFC 2046 header.  It
    defaults to iso-8859-1.
    r   latin1z=?%s?q?%s?=)r   	translater   )Zheader_bytescharsetencodedr   r   r   r      s    s   
L   c             C   s  | d k  r t  d   |  s" |  S|  j t  }  d | } | d } g  } | j } xv|  j   D]h} d } t |  d | }	 x | |	 k r)| | }
 | |
 d d k r | | | |
 d   |
 d } q | |
 d d k r| | | |
   |
 d } q | | | |
  d  |
 } q W| r| d d k r| |	 } | d k rit | d  } n1 | d k r| d | } n | t | d  } | | | d  |  qa | | | d	   qa W|  d t k r| d
  | j |  S)a  Encode with quoted-printable, wrapping at maxlinelen characters.

    Each line of encoded text will end with eol, which defaults to "\n".  Set
    this to "\r\n" if you will be using the result of this function directly
    in an email.

    Each line will be wrapped at, at most, maxlinelen characters before the
    eol string (maxlinelen defaults to 76 characters, the maximum value
    permitted by RFC 2045).  Long lines will have the 'soft line break'
    quoted-printable character "=" appended to them, so the decoded text will
    be identical to the original text.

    The minimum maxlinelen is 4 to have room for a quoted character ("=XX")
    followed by a soft line break.  Smaller values will generate a
    ValueError.

       zmaxlinelen must be at least 4=r$   r      z 	r.   Nr   r%   r%   r%   r%   r%   r%   )	
ValueErrorr4   _QUOPRI_BODY_ENCODE_MAPr(   
splitlinesr    r	   CRLFjoin)ZbodyZ
maxlineleneolZ
soft_breakZmaxlinelen1Zencoded_bodyr(   linestartZ	laststartstopZroomqr   r   r   r      sD    

	



c             C   sx  |  s
 |  Sd } x2|  j    D]$} | j   } | sB | | 7} q d } t |  } x | | k  r@| | } | d k r | | 7} | d 7} n | d | k r | d 7} qW nw | d | k  r| | d t k r| | d t k r| t | | | d   7} | d 7} n | | 7} | d 7} | | k rW | | 7} qW Wq W|  d	 d k rt| j |  rt| d d
  } | S)z_Decode a quoted-printable string.

    Lines are separated with eol, which defaults to \n.
    r   r   r9   r$   r:   r.   z
Nr%   r%   )r=   rstripr    r   r
   endswith)r6   r@   ZdecodedrA   inr   r   r   r   r      s8    



8

c             C   s   |  j  d  } t |  S)zCTurn a match in the form =AB to the ASCII character with value 0xabr   )groupr
   )matchr+   r   r   r   _unquote_match  s    rK   c             C   s.   |  j  d d  }  t j d t |  d t j S)a  Decode a string encoded with RFC 2045 MIME header `Q' encoding.

    This function does not parse a full MIME header value encoded with
    quoted-printable (like =?iso-8859-1?q?Hello_World?=) -- please use
    the high level email.header class for that functionality.
    r   r   z=[a-fA-F0-9]{2}flags)replaceresubrK   ASCII)r+   r   r   r   r   #  s    )!__doc____all__rN   stringr   r   r   r>   NLZEMPTYSTRINGranger1   r   r   encoder   r   r2   r   r   r   r   r-   r
   r	   r   r<   r   r   r   r   rK   r   r   r   r   r   <module>   sP   	'
O0                                                                                                  
[x5                 @   sA  d  Z  d d d d d d d d d	 d
 d d d d d g Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z	 d d l
 m Z d d l
 m Z d d l
 m Z d d l
 m Z m Z m Z d d l m Z d Z d Z d Z d Z d Z e j d  Z e j d  Z d d   Z d d    Z d! d" d  Z d# d   Z e j d$ e j  e j! B Z" d% d&   Z# d d' d' d( d  Z$ d' d) d  Z% d d d* d	  Z& d+ d   Z' d, d   Z( d- d   Z) d. d   Z* d d d/ d  Z+ e j d0 e j,  Z- d1 d   Z. d2 d3 d4 d  Z/ d d8 d6 d7  Z0 d S)9zMiscellaneous utilities.collapse_rfc2231_valuedecode_paramsdecode_rfc2231encode_rfc2231
formataddr
formatdateformat_datetimegetaddresses
make_msgid	mktime_tz	parseaddr	parsedateparsedate_tzparsedate_to_datetimeunquote    N)quote)AddressList)r
   )r   r   _parsedate_tz)Charsetz,  z
'z[][\\()<>@,:;".]z[\\"]c             C   s/   y |  j    d SWn t k
 r* d SYn Xd S)z8Return True if s contains surrogate-escaped binary data.FTN)encodeUnicodeEncodeError)s r   !/usr/lib/python3.5/email/utils.py_has_surrogates3   s
    
r   c             C   s"   |  j  d d  } | j d d  S)Nzutf-8surrogateescapereplace)r   decode)stringZoriginal_bytesr   r   r   	_sanitize@   s    r!   zutf-8c             C   s   |  \ } } | j  d  | r y | j  d  WnJ t k
 r| t | t  r[ t |  } | j |  } d | | f SYnB Xd } t j |  r d } t j	 d |  } d | | | | f S| S)a  The inverse of parseaddr(), this takes a 2-tuple of the form
    (realname, email_address) and returns the string value suitable
    for an RFC 2822 From, To or Cc header.

    If the first element of pair is false, then the second element is
    returned unmodified.

    Optional charset if given is the character set that is used to encode
    realname in case realname is not ASCII safe.  Can be an instance of str or
    a Charset-like object which has a header_encode method.  Default is
    'utf-8'.
    asciiz%s <%s>r   "z\\\g<0>z%s%s%s <%s>)
r   r   
isinstancestrr   Zheader_encode
specialsresearch	escapesresub)ZpaircharsetnameZaddressZencoded_nameZquotesr   r   r   r   L   s     c             C   s"   t  j |   } t |  } | j S)z7Return a list of (REALNAME, EMAIL) for each fieldvalue.)
COMMASPACEjoin_AddressListaddresslist)Zfieldvaluesallar   r   r   r   n   s    a_  
  =\?                   # literal =?
  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset
  \?                    # literal ?
  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive
  \?                    # literal ?
  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom
  \?=                   # literal ?=
  c             C   s   d d d d d d d d g |  d	 |  d
 d d d d d d d d d d d d g |  d d |  d |  d |  d |  d | f S)Nz"%s, %02d %s %04d %02d:%02d:%02d %sZMonZTueZWedZThuZFriZSatZSun      ZJanZFebZMarZAprZMayZJunZJulZAugZSepZOctZNovZDec   r            r   )	timetuplezoner   r   r   _format_timetuple_and_zone   s     !r:   Fc             C   sy   |  d k r t  j    }  | s$ | rB t j j |  t j j  } n t j j |   } | rl | j   } d } t | |  S)a  Returns a date string as specified by RFC 2822, e.g.:

    Fri, 09 Nov 2001 01:08:47 -0000

    Optional timeval if given is a floating point time value as accepted by
    gmtime() and localtime(), otherwise the current time is used.

    Optional localtime is a flag that when True, interprets timeval, and
    returns a date relative to the local timezone instead of UTC, properly
    taking daylight savings time into account.

    Optional argument usegmt means that the timezone is written out as
    an ascii string, not numeric one (so "GMT" instead of "+0000"). This
    is needed for HTTP, and is only used when localtime==False.
    NF)timedatetimeZfromtimestamptimezoneutcZutcfromtimestamp
astimezoner   )timeval	localtimeusegmtdtr   r   r   r      s    c             C   s   |  j    } | rK |  j d k s6 |  j t j j k rB t d   d } n' |  j d k rc d } n |  j d  } t | |  S)a$  Turn a datetime into a date string as specified in RFC 2822.

    If usegmt is True, dt must be an aware datetime with an offset of zero.  In
    this case 'GMT' will be rendered instead of the normal +0000 required by
    RFC2822.  This is to support HTTP headers involving date stamps.
    Nz%usegmt option requires a UTC datetimeZGMTz-0000z%z)r8   tzinfor<   r=   r>   
ValueErrorZstrftimer:   )rC   rB   nowr9   r   r   r   r      s    $		c             C   s   t  t j   d  } t j   } t j d  } |  d k rF d }  n
 d |  }  | d k rh t j   } d | | | |  | f } | S)a{  Returns a string suitable for RFC 2822 compliant Message-ID, e.g:

    <142480216486.20800.16526388040877946887@nightshade.la.mastaler.com>

    Optional idstring if given is a string used to strengthen the
    uniqueness of the message id.  Optional domain if given provides the
    portion of the message id after the '@'.  It defaults to the locally
    defined hostname.
    d   @   Nr   .z<%d.%d.%d%s@%s>)intr;   osgetpidrandomZgetrandbitssocketZgetfqdn)ZidstringZdomainr@   pidZrandintZmsgidr   r   r   r	      s    
	
c             C   sg   t  |   ^ } } | d  k r5 t j | d  d    St j | d  d  d t j t j d |    S)Nr2   rD   seconds)r   r<   r=   	timedelta)dataZdtupletzr   r   r   r      s
    c             C   s!   t  |   j } | s d S| d S)Nr   r   )r   r   )r.   r/   )ZaddrZaddrsr   r   r   r      s    c             C   s   t  |   d k r |  j d  rV |  j d  rV |  d d  j d d  j d d  S|  j d  r |  j d  r |  d d	  S|  S)
zRemove quotes from a string.r4   r#   z\\\z\"<>rW   )len
startswithendswithr   )r%   r   r   r   r      s    &c             C   s5   |  j  t d  } t |  d k r1 d d |  f S| S)z#Decode string according to RFC 2231r3   N)splitTICKrX   )r   partsr   r   r   r      s    c             C   sc   t  j j |  d d d | p d }  | d k r@ | d k r@ |  S| d k rR d } d | | |  f S)zEncode string according to RFC 2231.

    If neither charset nor language is given, then s is returned as-is.  If
    charset is given but not language, the string is encoded using the empty
    string for language.
    Zsafer   encodingr"   Nz%s'%s'%s)urllibparser   )r   r*   languager   r   r   r      s    $z&^(?P<name>\w+)\*((?P<num>[0-9]+)\*?)?$c             C   s	  |  d d  }  g  } i  } |  j  d  \ } } | j | | f  x |  r|  j  d  \ } } | j d  rz d } n d } t |  } t j |  } | r | j d d  \ } } | d k	 r t |  } | j | g   j | | | f  qG | j | d t	 |  f  qG W| rx | j
   D] \ } } g  } d }	 | j   xH | D]@ \ } }
 } | rt j j |
 d	 d
 }
 d }	 | j |
  qSWt	 t j |   } |	 rt |  \ } } } | j | | | d | f f  q*| j | d | f  q*W| S)zDecode parameters list according to RFC 2231.

    params is a sequence of 2-tuples containing (param name, string value).
    Nr   *TFr+   numz"%s"r^   zlatin-1)popappendrZ   r   rfc2231_continuationmatchgrouprJ   
setdefaultr   itemssortr_   r`   EMPTYSTRINGr-   r   )ZparamsZ
new_paramsZrfc2231_paramsr+   valueZencodedZmorc   ZcontinuationsZextendedr   r*   ra   r   r   r   r     sD    		%!
#r   zus-asciic             C   s   t  |  t  s" t |   d k r, t |   S|  \ } } } | d  k rM | } t | d  } y t | | |  SWn t k
 r t |  SYn Xd  S)Nr5   zraw-unicode-escape)r$   tuplerX   r   bytesr%   LookupError)rm   errorsZfallback_charsetr*   ra   textZrawbytesr   r   r   r   ?  s    "
r4   c       	      C   si  |  d k r( t  j  j t  j j  j   S|  j d k	 rA |  j   S|  j   d d  | f } t j |  } t j	 |  } y. t  j
 d | j  } t  j | | j  } Wn t k
 rX|  t  j  t j |  d d    } t j o | j d k } | rt j n t j } | t  j
 d |  k rEt  j | t j |  } n t  j |  } Yn X|  j d |  S)a  Return local time as an aware datetime object.

    If called without arguments, return current time.  Otherwise *dt*
    argument should be a datetime instance, and it is converted to the
    local time zone according to the system time zone database.  If *dt* is
    naive (that is, dt.tzinfo is None), it is assumed to be in local time.
    In this case, a positive or zero value for *isdst* causes localtime to
    presume initially that summer time (for example, Daylight Saving Time)
    is or is not (respectively) in effect for the specified time.  A
    negative value for *isdst* causes the localtime() function to attempt
    to divine whether summer time is in effect for the specified time.

    Nr4   rP   r2   r   rD   rW   )r<   rF   r=   r>   r?   rD   r8   r;   ZmktimerA   rQ   Z	tm_gmtoffZtm_zoneAttributeErrorZgmtimeZdaylightZtm_isdstZaltzoneZtznamer   )	rC   ZisdstZtmrP   ZlocaltmZdeltarS   ZdstZgmtoffr   r   r   rA   Y  s$    
&rA   rW   )1__doc____all__rK   rer;   rM   rN   r<   Zurllib.parser_   Zemail._parseaddrr   r   r.   r
   r   r   r   Zemail.charsetr   r,   rl   ZUEMPTYSTRINGZCRLFr\   compiler&   r(   r   r!   r   r   VERBOSE
IGNORECASEZecrer:   r   r   r	   r   r   r   r   r   ASCIIrf   r   r   rA   r   r   r   r   <module>   sn   	"		8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Base class for MIME specializations."""

__all__ = ['MIMEBase']

from email import message



class MIMEBase(message.Message):
    """Base class for MIME specializations."""

    def __init__(self, _maintype, _subtype, **_params):
        """This constructor adds a Content-Type: and a MIME-Version: header.

        The Content-Type: header is taken from the _maintype and _subtype
        arguments.  Additional parameters for this header are taken from the
        keyword arguments.
        """
        message.Message.__init__(self)
        ctype = '%s/%s' % (_maintype, _subtype)
        self.add_header('Content-Type', ctype, **_params)
        self['MIME-Version'] = '1.0'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Class representing image/* type MIME documents."""

__all__ = ['MIMEImage']

import imghdr

from email import encoders
from email.mime.nonmultipart import MIMENonMultipart



class MIMEImage(MIMENonMultipart):
    """Class for generating image/* type MIME documents."""

    def __init__(self, _imagedata, _subtype=None,
                 _encoder=encoders.encode_base64, **_params):
        """Create an image/* type MIME document.

        _imagedata is a string containing the raw image data.  If this data
        can be decoded by the standard Python `imghdr' module, then the
        subtype will be automatically included in the Content-Type header.
        Otherwise, you can specify the specific image subtype via the _subtype
        parameter.

        _encoder is a function which will perform the actual encoding for
        transport of the image data.  It takes one argument, which is this
        Image instance.  It should use get_payload() and set_payload() to
        change the payload to the encoded form.  It should also add any
        Content-Transfer-Encoding or other headers to the message as
        necessary.  The default encoding is Base64.

        Any additional keyword arguments are passed to the base class
        constructor, which turns them into parameters on the Content-Type
        header.
        """
        if _subtype is None:
            _subtype = imghdr.what(None, _imagedata)
        if _subtype is None:
            raise TypeError('Could not guess image MIME subtype')
        MIMENonMultipart.__init__(self, 'image', _subtype, **_params)
        self.set_payload(_imagedata)
        _encoder(self)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Class representing message/* MIME documents."""

__all__ = ['MIMEMessage']

from email import message
from email.mime.nonmultipart import MIMENonMultipart



class MIMEMessage(MIMENonMultipart):
    """Class representing message/* MIME documents."""

    def __init__(self, _msg, _subtype='rfc822'):
        """Create a message/* type MIME document.

        _msg is a message object and must be an instance of Message, or a
        derived class of Message, otherwise a TypeError is raised.

        Optional _subtype defines the subtype of the contained message.  The
        default is "rfc822" (this is defined by the MIME standard, even though
        the term "rfc822" is technically outdated by RFC 2822).
        """
        MIMENonMultipart.__init__(self, 'message', _subtype)
        if not isinstance(_msg, message.Message):
            raise TypeError('Argument is not an instance of Message')
        # It's convenient to use this base class method.  We need to do it
        # this way or we'll get an exception
        message.Message.attach(self, _msg)
        # And be sure our default type is set correctly
        self.set_default_type('message/rfc822')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Copyright (C) 2002-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Base class for MIME multipart/* type messages."""

__all__ = ['MIMEMultipart']

from email.mime.base import MIMEBase



class MIMEMultipart(MIMEBase):
    """Base class for MIME multipart/* type messages."""

    def __init__(self, _subtype='mixed', boundary=None, _subparts=None,
                 **_params):
        """Creates a multipart/* type message.

        By default, creates a multipart/mixed message, with proper
        Content-Type and MIME-Version headers.

        _subtype is the subtype of the multipart content type, defaulting to
        `mixed'.

        boundary is the multipart boundary string.  By default it is
        calculated as needed.

        _subparts is a sequence of initial subparts for the payload.  It
        must be an iterable object, such as a list.  You can always
        attach new subparts to the message by using the attach() method.

        Additional parameters for the Content-Type header are taken from the
        keyword arguments (or passed into the _params argument).
        """
        MIMEBase.__init__(self, 'multipart', _subtype, **_params)

        # Initialise _payload to an empty list as the Message superclass's
        # implementation of is_multipart assumes that _payload is a list for
        # multipart messages.
        self._payload = []

        if _subparts:
            for p in _subparts:
                self.attach(p)
        if boundary:
            self.set_boundary(boundary)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Copyright (C) 2002-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Base class for MIME type messages that are not multipart."""

__all__ = ['MIMENonMultipart']

from email import errors
from email.mime.base import MIMEBase



class MIMENonMultipart(MIMEBase):
    """Base class for MIME non-multipart type messages."""

    def attach(self, payload):
        # The public API prohibits attaching multiple subparts to MIMEBase
        # derived subtypes since none of them are, by definition, of content
        # type multipart/*
        raise errors.MultipartConversionError(
            'Cannot attach additional subparts to non-multipart/*')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Class representing text/* type MIME documents."""

__all__ = ['MIMEText']

from email.charset import Charset
from email.mime.nonmultipart import MIMENonMultipart



class MIMEText(MIMENonMultipart):
    """Class for generating text/* type MIME documents."""

    def __init__(self, _text, _subtype='plain', _charset=None):
        """Create a text/* type MIME document.

        _text is the string for this message object.

        _subtype is the MIME sub content type, defaulting to "plain".

        _charset is the character set parameter added to the Content-Type
        header.  This defaults to "us-ascii".  Note that as a side-effect, the
        Content-Transfer-Encoding header will also be set.
        """

        # If no _charset was specified, check to see if there are non-ascii
        # characters present. If not, use 'us-ascii', otherwise use utf-8.
        # XXX: This can be removed once #7304 is fixed.
        if _charset is None:
            try:
                _text.encode('us-ascii')
                _charset = 'us-ascii'
            except UnicodeEncodeError:
                _charset = 'utf-8'

        MIMENonMultipart.__init__(self, 'text', _subtype,
                                  **{'charset': str(_charset)})

        self.set_payload(_text, _charset)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
[                   @   s   d  S)N r   r   r   )/usr/lib/python3.5/email/mime/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
[                 @   sI   d  Z  d g Z d d l m Z d d l m Z Gd d   d e  Z d S)z5Class representing application/* type MIME documents.MIMEApplication    )encoders)MIMENonMultipartc               @   s+   e  Z d  Z d Z d e j d d  Z d S)r   z2Class for generating application/* MIME documents.zoctet-streamc             K   sI   | d k r t  d   t j |  d | |  |  j |  | |   d S)a  Create an application/* type MIME document.

        _data is a string containing the raw application data.

        _subtype is the MIME content type subtype, defaulting to
        'octet-stream'.

        _encoder is a function which will perform the actual encoding for
        transport of the application data, defaulting to base64 encoding.

        Any additional keyword arguments are passed to the base class
        constructor, which turns them into parameters on the Content-Type
        header.
        Nz Invalid application MIME subtypeZapplication)	TypeErrorr   __init__Zset_payload)self_dataZ_subtypeZ_encoderZ_params r	   ,/usr/lib/python3.5/email/mime/application.pyr      s
    zMIMEApplication.__init__N)__name__
__module____qualname____doc__r   Zencode_base64r   r	   r	   r	   r
   r      s   N)r   __all__Zemailr   Zemail.mime.nonmultipartr   r   r	   r	   r	   r
   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
[r
                 @   s   d  Z  d g Z d d l Z d d l m Z d d l m Z d d l m Z d d d	 d
 d d d d i Z	 d d   Z
 Gd d   d e  Z d S)z/Class representing audio/* type MIME documents.	MIMEAudio    N)BytesIO)encoders)MIMENonMultipartZauZbasicZwavzx-wavZaiffzx-aiffZaifcc             C   s`   |  d d  } t  |  } x= t j D]2 } | | |  } | d k	 r& t j | d  Sq& Wd S)a  Try to identify a sound file type.

    sndhdr.what() has a pretty cruddy interface, unfortunately.  This is why
    we re-do it here.  It would be easier to reverse engineer the Unix 'file'
    command and use the standard 'magic' file, as shipped with a modern Unix.
    Ni   r   )r   sndhdrZtests_sndhdr_MIMEmapget)dataZhdrZfakefileZtestfnZres r
   &/usr/lib/python3.5/email/mime/audio.py_whatsnd   s    r   c               @   s+   e  Z d  Z d Z d e j d d  Z d S)r   z,Class for generating audio/* MIME documents.Nc             K   sa   | d k r t  |  } | d k r0 t d   t j |  d | |  |  j |  | |   d S)a  Create an audio/* type MIME document.

        _audiodata is a string containing the raw audio data.  If this data
        can be decoded by the standard Python `sndhdr' module, then the
        subtype will be automatically included in the Content-Type header.
        Otherwise, you can specify  the specific audio subtype via the
        _subtype parameter.  If _subtype is not given, and no subtype can be
        guessed, a TypeError is raised.

        _encoder is a function which will perform the actual encoding for
        transport of the image data.  It takes one argument, which is this
        Image instance.  It should use get_payload() and set_payload() to
        change the payload to the encoded form.  It should also add any
        Content-Transfer-Encoding or other headers to the message as
        necessary.  The default encoding is Base64.

        Any additional keyword arguments are passed to the base class
        constructor, which turns them into parameters on the Content-Type
        header.
        Nz!Could not find audio MIME subtypeZaudio)r   	TypeErrorr   __init__Zset_payload)selfZ
_audiodataZ_subtypeZ_encoderZ_paramsr
   r
   r   r   -   s    zMIMEAudio.__init__)__name__
__module____qualname____doc__r   Zencode_base64r   r
   r
   r
   r   r   *   s   )r   __all__r   ior   Zemailr   Zemail.mime.nonmultipartr   r   r   r   r
   r
   r
   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
[                 @   s<   d  Z  d g Z d d l m Z Gd d   d e j  Z d S)z$Base class for MIME specializations.MIMEBase    )messagec               @   s"   e  Z d  Z d Z d d   Z d S)r   z$Base class for MIME specializations.c             K   sA   t  j j |   d | | f } |  j d | |  d |  d <d S)zThis constructor adds a Content-Type: and a MIME-Version: header.

        The Content-Type: header is taken from the _maintype and _subtype
        arguments.  Additional parameters for this header are taken from the
        keyword arguments.
        z%s/%szContent-Typez1.0zMIME-VersionN)r   Message__init__Z
add_header)selfZ	_maintypeZ_subtypeZ_paramsZctype r   %/usr/lib/python3.5/email/mime/base.pyr      s    zMIMEBase.__init__N)__name__
__module____qualname____doc__r   r   r   r   r   r      s   N)r   __all__Zemailr   r   r   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
[                 @   sU   d  Z  d g Z d d l Z d d l m Z d d l m Z Gd d   d e  Z d S)z/Class representing image/* type MIME documents.	MIMEImage    N)encoders)MIMENonMultipartc               @   s+   e  Z d  Z d Z d e j d d  Z d S)r   z1Class for generating image/* type MIME documents.Nc             K   sg   | d k r t  j d |  } | d k r6 t d   t j |  d | |  |  j |  | |   d S)a  Create an image/* type MIME document.

        _imagedata is a string containing the raw image data.  If this data
        can be decoded by the standard Python `imghdr' module, then the
        subtype will be automatically included in the Content-Type header.
        Otherwise, you can specify the specific image subtype via the _subtype
        parameter.

        _encoder is a function which will perform the actual encoding for
        transport of the image data.  It takes one argument, which is this
        Image instance.  It should use get_payload() and set_payload() to
        change the payload to the encoded form.  It should also add any
        Content-Transfer-Encoding or other headers to the message as
        necessary.  The default encoding is Base64.

        Any additional keyword arguments are passed to the base class
        constructor, which turns them into parameters on the Content-Type
        header.
        Nz"Could not guess image MIME subtypeZimage)imghdrZwhat	TypeErrorr   __init__Zset_payload)selfZ
_imagedataZ_subtypeZ_encoderZ_params r	   &/usr/lib/python3.5/email/mime/image.pyr      s    zMIMEImage.__init__)__name__
__module____qualname____doc__r   Zencode_base64r   r	   r	   r	   r
   r      s   )r   __all__r   Zemailr   Zemail.mime.nonmultipartr   r   r	   r	   r	   r
   <module>   s
   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[                 @   sI   d  Z  d g Z d d l m Z d d l m Z Gd d   d e  Z d S)z,Class representing message/* MIME documents.MIMEMessage    )message)MIMENonMultipartc               @   s%   e  Z d  Z d Z d d d  Z d S)r   z,Class representing message/* MIME documents.Zrfc822c             C   sU   t  j |  d |  t | t j  s1 t d   t j j |  |  |  j d  d S)a  Create a message/* type MIME document.

        _msg is a message object and must be an instance of Message, or a
        derived class of Message, otherwise a TypeError is raised.

        Optional _subtype defines the subtype of the contained message.  The
        default is "rfc822" (this is defined by the MIME standard, even though
        the term "rfc822" is technically outdated by RFC 2822).
        r   z&Argument is not an instance of Messagezmessage/rfc822N)r   __init__
isinstancer   ZMessage	TypeErrorZattachZset_default_type)selfZ_msgZ_subtype r	   (/usr/lib/python3.5/email/mime/message.pyr      s
    
zMIMEMessage.__init__N)__name__
__module____qualname____doc__r   r	   r	   r	   r
   r      s   N)r   __all__Zemailr   Zemail.mime.nonmultipartr   r   r	   r	   r	   r
   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
[%                 @   s9   d  Z  d g Z d d l m Z Gd d   d e  Z d S)z.Base class for MIME multipart/* type messages.MIMEMultipart    )MIMEBasec               @   s+   e  Z d  Z d Z d d d d d  Z d S)r   z.Base class for MIME multipart/* type messages.ZmixedNc             K   sZ   t  j |  d | |  g  |  _ | rC x | D] } |  j |  q, W| rV |  j |  d S)a  Creates a multipart/* type message.

        By default, creates a multipart/mixed message, with proper
        Content-Type and MIME-Version headers.

        _subtype is the subtype of the multipart content type, defaulting to
        `mixed'.

        boundary is the multipart boundary string.  By default it is
        calculated as needed.

        _subparts is a sequence of initial subparts for the payload.  It
        must be an iterable object, such as a list.  You can always
        attach new subparts to the message by using the attach() method.

        Additional parameters for the Content-Type header are taken from the
        keyword arguments (or passed into the _params argument).
        Z	multipartN)r   __init__Z_payloadZattachZset_boundary)selfZ_subtypeboundaryZ	_subpartsZ_paramsp r   */usr/lib/python3.5/email/mime/multipart.pyr      s    	zMIMEMultipart.__init__)__name__
__module____qualname____doc__r   r   r   r   r	   r      s   N)r   __all__Zemail.mime.baser   r   r   r   r   r	   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
[                 @   sI   d  Z  d g Z d d l m Z d d l m Z Gd d   d e  Z d S)z9Base class for MIME type messages that are not multipart.MIMENonMultipart    )errors)MIMEBasec               @   s"   e  Z d  Z d Z d d   Z d S)r   z0Base class for MIME non-multipart type messages.c             C   s   t  j d   d  S)Nz4Cannot attach additional subparts to non-multipart/*)r   ZMultipartConversionError)selfZpayload r   -/usr/lib/python3.5/email/mime/nonmultipart.pyattach   s    zMIMENonMultipart.attachN)__name__
__module____qualname____doc__r   r   r   r   r   r      s   N)r   __all__Zemailr   Zemail.mime.baser   r   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
[~                 @   sI   d  Z  d g Z d d l m Z d d l m Z Gd d   d e  Z d S)z.Class representing text/* type MIME documents.MIMEText    )Charset)MIMENonMultipartc               @   s(   e  Z d  Z d Z d d d d  Z d S)r   z0Class for generating text/* type MIME documents.ZplainNc             C   st   | d k r> y | j  d  d } Wn t k
 r= d } Yn Xt j |  d | d t |  i  |  j | |  d S)a~  Create a text/* type MIME document.

        _text is the string for this message object.

        _subtype is the MIME sub content type, defaulting to "plain".

        _charset is the character set parameter added to the Content-Type
        header.  This defaults to "us-ascii".  Note that as a side-effect, the
        Content-Transfer-Encoding header will also be set.
        Nzus-asciizutf-8textcharset)encodeUnicodeEncodeErrorr   __init__strZset_payload)selfZ_textZ_subtypeZ_charset r   %/usr/lib/python3.5/email/mime/text.pyr	      s    
zMIMEText.__init__)__name__
__module____qualname____doc__r	   r   r   r   r   r      s   N)r   __all__Zemail.charsetr   Zemail.mime.nonmultipartr   r   r   r   r   r   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """ Standard "encodings" Package

    Standard Python encoding modules are stored in this package
    directory.

    Codec modules must have names corresponding to normalized encoding
    names as defined in the normalize_encoding() function below, e.g.
    'utf-8' must be implemented by the module 'utf_8.py'.

    Each codec module must export the following interface:

    * getregentry() -> codecs.CodecInfo object
    The getregentry() API must return a CodecInfo object with encoder, decoder,
    incrementalencoder, incrementaldecoder, streamwriter and streamreader
    atttributes which adhere to the Python Codec Interface Standard.

    In addition, a module may optionally also define the following
    APIs which are then used by the package's codec search function:

    * getaliases() -> sequence of encoding name strings to use as aliases

    Alias names returned by getaliases() must be normalized encoding
    names as defined by normalize_encoding().

Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""#"

import codecs
from . import aliases

_cache = {}
_unknown = '--unknown--'
_import_tail = ['*']
_aliases = aliases.aliases

class CodecRegistryError(LookupError, SystemError):
    pass

def normalize_encoding(encoding):

    """ Normalize an encoding name.

        Normalization works as follows: all non-alphanumeric
        characters except the dot used for Python package names are
        collapsed and replaced with a single underscore, e.g. '  -;#'
        becomes '_'. Leading and trailing underscores are removed.

        Note that encoding names should be ASCII only; if they do use
        non-ASCII characters, these must be Latin-1 compatible.

    """
    if isinstance(encoding, bytes):
        encoding = str(encoding, "ascii")
    chars = []
    punct = False
    for c in encoding:
        if c.isalnum() or c == '.':
            if punct and chars:
                chars.append('_')
            chars.append(c)
            punct = False
        else:
            punct = True
    return ''.join(chars)

def search_function(encoding):

    # Cache lookup
    entry = _cache.get(encoding, _unknown)
    if entry is not _unknown:
        return entry

    # Import the module:
    #
    # First try to find an alias for the normalized encoding
    # name and lookup the module using the aliased name, then try to
    # lookup the module using the standard import scheme, i.e. first
    # try in the encodings package, then at top-level.
    #
    norm_encoding = normalize_encoding(encoding)
    aliased_encoding = _aliases.get(norm_encoding) or \
                       _aliases.get(norm_encoding.replace('.', '_'))
    if aliased_encoding is not None:
        modnames = [aliased_encoding,
                    norm_encoding]
    else:
        modnames = [norm_encoding]
    for modname in modnames:
        if not modname or '.' in modname:
            continue
        try:
            # Import is absolute to prevent the possibly malicious import of a
            # module with side-effects that is not in the 'encodings' package.
            mod = __import__('encodings.' + modname, fromlist=_import_tail,
                             level=0)
        except ImportError:
            pass
        else:
            break
    else:
        mod = None

    try:
        getregentry = mod.getregentry
    except AttributeError:
        # Not a codec module
        mod = None

    if mod is None:
        # Cache misses
        _cache[encoding] = None
        return None

    # Now ask the module for the registry entry
    entry = getregentry()
    if not isinstance(entry, codecs.CodecInfo):
        if not 4 <= len(entry) <= 7:
            raise CodecRegistryError('module "%s" (%s) failed to register'
                                     % (mod.__name__, mod.__file__))
        if not callable(entry[0]) or not callable(entry[1]) or \
           (entry[2] is not None and not callable(entry[2])) or \
           (entry[3] is not None and not callable(entry[3])) or \
           (len(entry) > 4 and entry[4] is not None and not callable(entry[4])) or \
           (len(entry) > 5 and entry[5] is not None and not callable(entry[5])):
            raise CodecRegistryError('incompatible codecs in module "%s" (%s)'
                                     % (mod.__name__, mod.__file__))
        if len(entry)<7 or entry[6] is None:
            entry += (None,)*(6-len(entry)) + (mod.__name__.split(".", 1)[1],)
        entry = codecs.CodecInfo(*entry)

    # Cache the codec registry entry
    _cache[encoding] = entry

    # Register its aliases (without overwriting previously registered
    # aliases)
    try:
        codecaliases = mod.getaliases()
    except AttributeError:
        pass
    else:
        for alias in codecaliases:
            if alias not in _aliases:
                _aliases[alias] = modname

    # Return the registry entry
    return entry

# Register the search_function in the Python codec registry
codecs.register(search_function)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     """ Python 'ascii' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""
import codecs

### Codec APIs

class Codec(codecs.Codec):

    # Note: Binding these as C functions will result in the class not
    # converting them to methods. This is intended.
    encode = codecs.ascii_encode
    decode = codecs.ascii_decode

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.ascii_encode(input, self.errors)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.ascii_decode(input, self.errors)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

class StreamConverter(StreamWriter,StreamReader):

    encode = codecs.ascii_decode
    decode = codecs.ascii_encode

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='ascii',
        encode=Codec.encode,
        decode=Codec.decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """Python 'base64_codec' Codec - base64 content transfer encoding.

This codec de/encodes from bytes to bytes.

Written by Marc-Andre Lemburg (mal@lemburg.com).
"""

import codecs
import base64

### Codec APIs

def base64_encode(input, errors='strict'):
    assert errors == 'strict'
    return (base64.encodebytes(input), len(input))

def base64_decode(input, errors='strict'):
    assert errors == 'strict'
    return (base64.decodebytes(input), len(input))

class Codec(codecs.Codec):
    def encode(self, input, errors='strict'):
        return base64_encode(input, errors)
    def decode(self, input, errors='strict'):
        return base64_decode(input, errors)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        assert self.errors == 'strict'
        return base64.encodebytes(input)

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        assert self.errors == 'strict'
        return base64.decodebytes(input)

class StreamWriter(Codec, codecs.StreamWriter):
    charbuffertype = bytes

class StreamReader(Codec, codecs.StreamReader):
    charbuffertype = bytes

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='base64',
        encode=base64_encode,
        decode=base64_decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
        _is_text_encoding=False,
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """ Encoding Aliases Support

    This module is used by the encodings package search function to
    map encodings names to module names.

    Note that the search function normalizes the encoding names before
    doing the lookup, so the mapping will have to map normalized
    encoding names to module names.

    Contents:

        The following aliases dictionary contains mappings of all IANA
        character set names for which the Python core library provides
        codecs. In addition to these, a few Python specific codec
        aliases have also been added.

"""
aliases = {

    # Please keep this list sorted alphabetically by value !

    # ascii codec
    '646'                : 'ascii',
    'ansi_x3.4_1968'     : 'ascii',
    'ansi_x3_4_1968'     : 'ascii', # some email headers use this non-standard name
    'ansi_x3.4_1986'     : 'ascii',
    'cp367'              : 'ascii',
    'csascii'            : 'ascii',
    'ibm367'             : 'ascii',
    'iso646_us'          : 'ascii',
    'iso_646.irv_1991'   : 'ascii',
    'iso_ir_6'           : 'ascii',
    'us'                 : 'ascii',
    'us_ascii'           : 'ascii',

    # base64_codec codec
    'base64'             : 'base64_codec',
    'base_64'            : 'base64_codec',

    # big5 codec
    'big5_tw'            : 'big5',
    'csbig5'             : 'big5',

    # big5hkscs codec
    'big5_hkscs'         : 'big5hkscs',
    'hkscs'              : 'big5hkscs',

    # bz2_codec codec
    'bz2'                : 'bz2_codec',

    # cp037 codec
    '037'                : 'cp037',
    'csibm037'           : 'cp037',
    'ebcdic_cp_ca'       : 'cp037',
    'ebcdic_cp_nl'       : 'cp037',
    'ebcdic_cp_us'       : 'cp037',
    'ebcdic_cp_wt'       : 'cp037',
    'ibm037'             : 'cp037',
    'ibm039'             : 'cp037',

    # cp1026 codec
    '1026'               : 'cp1026',
    'csibm1026'          : 'cp1026',
    'ibm1026'            : 'cp1026',

    # cp1125 codec
    '1125'                : 'cp1125',
    'ibm1125'             : 'cp1125',
    'cp866u'              : 'cp1125',
    'ruscii'              : 'cp1125',

    # cp1140 codec
    '1140'               : 'cp1140',
    'ibm1140'            : 'cp1140',

    # cp1250 codec
    '1250'               : 'cp1250',
    'windows_1250'       : 'cp1250',

    # cp1251 codec
    '1251'               : 'cp1251',
    'windows_1251'       : 'cp1251',

    # cp1252 codec
    '1252'               : 'cp1252',
    'windows_1252'       : 'cp1252',

    # cp1253 codec
    '1253'               : 'cp1253',
    'windows_1253'       : 'cp1253',

    # cp1254 codec
    '1254'               : 'cp1254',
    'windows_1254'       : 'cp1254',

    # cp1255 codec
    '1255'               : 'cp1255',
    'windows_1255'       : 'cp1255',

    # cp1256 codec
    '1256'               : 'cp1256',
    'windows_1256'       : 'cp1256',

    # cp1257 codec
    '1257'               : 'cp1257',
    'windows_1257'       : 'cp1257',

    # cp1258 codec
    '1258'               : 'cp1258',
    'windows_1258'       : 'cp1258',

    # cp273 codec
    '273'                : 'cp273',
    'ibm273'             : 'cp273',
    'csibm273'           : 'cp273',

    # cp424 codec
    '424'                : 'cp424',
    'csibm424'           : 'cp424',
    'ebcdic_cp_he'       : 'cp424',
    'ibm424'             : 'cp424',

    # cp437 codec
    '437'                : 'cp437',
    'cspc8codepage437'   : 'cp437',
    'ibm437'             : 'cp437',

    # cp500 codec
    '500'                : 'cp500',
    'csibm500'           : 'cp500',
    'ebcdic_cp_be'       : 'cp500',
    'ebcdic_cp_ch'       : 'cp500',
    'ibm500'             : 'cp500',

    # cp775 codec
    '775'                : 'cp775',
    'cspc775baltic'      : 'cp775',
    'ibm775'             : 'cp775',

    # cp850 codec
    '850'                : 'cp850',
    'cspc850multilingual' : 'cp850',
    'ibm850'             : 'cp850',

    # cp852 codec
    '852'                : 'cp852',
    'cspcp852'           : 'cp852',
    'ibm852'             : 'cp852',

    # cp855 codec
    '855'                : 'cp855',
    'csibm855'           : 'cp855',
    'ibm855'             : 'cp855',

    # cp857 codec
    '857'                : 'cp857',
    'csibm857'           : 'cp857',
    'ibm857'             : 'cp857',

    # cp858 codec
    '858'                : 'cp858',
    'csibm858'           : 'cp858',
    'ibm858'             : 'cp858',

    # cp860 codec
    '860'                : 'cp860',
    'csibm860'           : 'cp860',
    'ibm860'             : 'cp860',

    # cp861 codec
    '861'                : 'cp861',
    'cp_is'              : 'cp861',
    'csibm861'           : 'cp861',
    'ibm861'             : 'cp861',

    # cp862 codec
    '862'                : 'cp862',
    'cspc862latinhebrew' : 'cp862',
    'ibm862'             : 'cp862',

    # cp863 codec
    '863'                : 'cp863',
    'csibm863'           : 'cp863',
    'ibm863'             : 'cp863',

    # cp864 codec
    '864'                : 'cp864',
    'csibm864'           : 'cp864',
    'ibm864'             : 'cp864',

    # cp865 codec
    '865'                : 'cp865',
    'csibm865'           : 'cp865',
    'ibm865'             : 'cp865',

    # cp866 codec
    '866'                : 'cp866',
    'csibm866'           : 'cp866',
    'ibm866'             : 'cp866',

    # cp869 codec
    '869'                : 'cp869',
    'cp_gr'              : 'cp869',
    'csibm869'           : 'cp869',
    'ibm869'             : 'cp869',

    # cp932 codec
    '932'                : 'cp932',
    'ms932'              : 'cp932',
    'mskanji'            : 'cp932',
    'ms_kanji'           : 'cp932',

    # cp949 codec
    '949'                : 'cp949',
    'ms949'              : 'cp949',
    'uhc'                : 'cp949',

    # cp950 codec
    '950'                : 'cp950',
    'ms950'              : 'cp950',

    # euc_jis_2004 codec
    'jisx0213'           : 'euc_jis_2004',
    'eucjis2004'         : 'euc_jis_2004',
    'euc_jis2004'        : 'euc_jis_2004',

    # euc_jisx0213 codec
    'eucjisx0213'        : 'euc_jisx0213',

    # euc_jp codec
    'eucjp'              : 'euc_jp',
    'ujis'               : 'euc_jp',
    'u_jis'              : 'euc_jp',

    # euc_kr codec
    'euckr'              : 'euc_kr',
    'korean'             : 'euc_kr',
    'ksc5601'            : 'euc_kr',
    'ks_c_5601'          : 'euc_kr',
    'ks_c_5601_1987'     : 'euc_kr',
    'ksx1001'            : 'euc_kr',
    'ks_x_1001'          : 'euc_kr',

    # gb18030 codec
    'gb18030_2000'       : 'gb18030',

    # gb2312 codec
    'chinese'            : 'gb2312',
    'csiso58gb231280'    : 'gb2312',
    'euc_cn'             : 'gb2312',
    'euccn'              : 'gb2312',
    'eucgb2312_cn'       : 'gb2312',
    'gb2312_1980'        : 'gb2312',
    'gb2312_80'          : 'gb2312',
    'iso_ir_58'          : 'gb2312',

    # gbk codec
    '936'                : 'gbk',
    'cp936'              : 'gbk',
    'ms936'              : 'gbk',

    # hex_codec codec
    'hex'                : 'hex_codec',

    # hp_roman8 codec
    'roman8'             : 'hp_roman8',
    'r8'                 : 'hp_roman8',
    'csHPRoman8'         : 'hp_roman8',

    # hz codec
    'hzgb'               : 'hz',
    'hz_gb'              : 'hz',
    'hz_gb_2312'         : 'hz',

    # iso2022_jp codec
    'csiso2022jp'        : 'iso2022_jp',
    'iso2022jp'          : 'iso2022_jp',
    'iso_2022_jp'        : 'iso2022_jp',

    # iso2022_jp_1 codec
    'iso2022jp_1'        : 'iso2022_jp_1',
    'iso_2022_jp_1'      : 'iso2022_jp_1',

    # iso2022_jp_2 codec
    'iso2022jp_2'        : 'iso2022_jp_2',
    'iso_2022_jp_2'      : 'iso2022_jp_2',

    # iso2022_jp_2004 codec
    'iso_2022_jp_2004'   : 'iso2022_jp_2004',
    'iso2022jp_2004'     : 'iso2022_jp_2004',

    # iso2022_jp_3 codec
    'iso2022jp_3'        : 'iso2022_jp_3',
    'iso_2022_jp_3'      : 'iso2022_jp_3',

    # iso2022_jp_ext codec
    'iso2022jp_ext'      : 'iso2022_jp_ext',
    'iso_2022_jp_ext'    : 'iso2022_jp_ext',

    # iso2022_kr codec
    'csiso2022kr'        : 'iso2022_kr',
    'iso2022kr'          : 'iso2022_kr',
    'iso_2022_kr'        : 'iso2022_kr',

    # iso8859_10 codec
    'csisolatin6'        : 'iso8859_10',
    'iso_8859_10'        : 'iso8859_10',
    'iso_8859_10_1992'   : 'iso8859_10',
    'iso_ir_157'         : 'iso8859_10',
    'l6'                 : 'iso8859_10',
    'latin6'             : 'iso8859_10',

    # iso8859_11 codec
    'thai'               : 'iso8859_11',
    'iso_8859_11'        : 'iso8859_11',
    'iso_8859_11_2001'   : 'iso8859_11',

    # iso8859_13 codec
    'iso_8859_13'        : 'iso8859_13',
    'l7'                 : 'iso8859_13',
    'latin7'             : 'iso8859_13',

    # iso8859_14 codec
    'iso_8859_14'        : 'iso8859_14',
    'iso_8859_14_1998'   : 'iso8859_14',
    'iso_celtic'         : 'iso8859_14',
    'iso_ir_199'         : 'iso8859_14',
    'l8'                 : 'iso8859_14',
    'latin8'             : 'iso8859_14',

    # iso8859_15 codec
    'iso_8859_15'        : 'iso8859_15',
    'l9'                 : 'iso8859_15',
    'latin9'             : 'iso8859_15',

    # iso8859_16 codec
    'iso_8859_16'        : 'iso8859_16',
    'iso_8859_16_2001'   : 'iso8859_16',
    'iso_ir_226'         : 'iso8859_16',
    'l10'                : 'iso8859_16',
    'latin10'            : 'iso8859_16',

    # iso8859_2 codec
    'csisolatin2'        : 'iso8859_2',
    'iso_8859_2'         : 'iso8859_2',
    'iso_8859_2_1987'    : 'iso8859_2',
    'iso_ir_101'         : 'iso8859_2',
    'l2'                 : 'iso8859_2',
    'latin2'             : 'iso8859_2',

    # iso8859_3 codec
    'csisolatin3'        : 'iso8859_3',
    'iso_8859_3'         : 'iso8859_3',
    'iso_8859_3_1988'    : 'iso8859_3',
    'iso_ir_109'         : 'iso8859_3',
    'l3'                 : 'iso8859_3',
    'latin3'             : 'iso8859_3',

    # iso8859_4 codec
    'csisolatin4'        : 'iso8859_4',
    'iso_8859_4'         : 'iso8859_4',
    'iso_8859_4_1988'    : 'iso8859_4',
    'iso_ir_110'         : 'iso8859_4',
    'l4'                 : 'iso8859_4',
    'latin4'             : 'iso8859_4',

    # iso8859_5 codec
    'csisolatincyrillic' : 'iso8859_5',
    'cyrillic'           : 'iso8859_5',
    'iso_8859_5'         : 'iso8859_5',
    'iso_8859_5_1988'    : 'iso8859_5',
    'iso_ir_144'         : 'iso8859_5',

    # iso8859_6 codec
    'arabic'             : 'iso8859_6',
    'asmo_708'           : 'iso8859_6',
    'csisolatinarabic'   : 'iso8859_6',
    'ecma_114'           : 'iso8859_6',
    'iso_8859_6'         : 'iso8859_6',
    'iso_8859_6_1987'    : 'iso8859_6',
    'iso_ir_127'         : 'iso8859_6',

    # iso8859_7 codec
    'csisolatingreek'    : 'iso8859_7',
    'ecma_118'           : 'iso8859_7',
    'elot_928'           : 'iso8859_7',
    'greek'              : 'iso8859_7',
    'greek8'             : 'iso8859_7',
    'iso_8859_7'         : 'iso8859_7',
    'iso_8859_7_1987'    : 'iso8859_7',
    'iso_ir_126'         : 'iso8859_7',

    # iso8859_8 codec
    'csisolatinhebrew'   : 'iso8859_8',
    'hebrew'             : 'iso8859_8',
    'iso_8859_8'         : 'iso8859_8',
    'iso_8859_8_1988'    : 'iso8859_8',
    'iso_ir_138'         : 'iso8859_8',

    # iso8859_9 codec
    'csisolatin5'        : 'iso8859_9',
    'iso_8859_9'         : 'iso8859_9',
    'iso_8859_9_1989'    : 'iso8859_9',
    'iso_ir_148'         : 'iso8859_9',
    'l5'                 : 'iso8859_9',
    'latin5'             : 'iso8859_9',

    # johab codec
    'cp1361'             : 'johab',
    'ms1361'             : 'johab',

    # koi8_r codec
    'cskoi8r'            : 'koi8_r',

    # kz1048 codec
    'kz_1048'           : 'kz1048',
    'rk1048'            : 'kz1048',
    'strk1048_2002'     : 'kz1048',

    # latin_1 codec
    #
    # Note that the latin_1 codec is implemented internally in C and a
    # lot faster than the charmap codec iso8859_1 which uses the same
    # encoding. This is why we discourage the use of the iso8859_1
    # codec and alias it to latin_1 instead.
    #
    '8859'               : 'latin_1',
    'cp819'              : 'latin_1',
    'csisolatin1'        : 'latin_1',
    'ibm819'             : 'latin_1',
    'iso8859'            : 'latin_1',
    'iso8859_1'          : 'latin_1',
    'iso_8859_1'         : 'latin_1',
    'iso_8859_1_1987'    : 'latin_1',
    'iso_ir_100'         : 'latin_1',
    'l1'                 : 'latin_1',
    'latin'              : 'latin_1',
    'latin1'             : 'latin_1',

    # mac_cyrillic codec
    'maccyrillic'        : 'mac_cyrillic',

    # mac_greek codec
    'macgreek'           : 'mac_greek',

    # mac_iceland codec
    'maciceland'         : 'mac_iceland',

    # mac_latin2 codec
    'maccentraleurope'   : 'mac_latin2',
    'maclatin2'          : 'mac_latin2',

    # mac_roman codec
    'macintosh'          : 'mac_roman',
    'macroman'           : 'mac_roman',

    # mac_turkish codec
    'macturkish'         : 'mac_turkish',

    # mbcs codec
    'dbcs'               : 'mbcs',

    # ptcp154 codec
    'csptcp154'          : 'ptcp154',
    'pt154'              : 'ptcp154',
    'cp154'              : 'ptcp154',
    'cyrillic_asian'     : 'ptcp154',

    # quopri_codec codec
    'quopri'             : 'quopri_codec',
    'quoted_printable'   : 'quopri_codec',
    'quotedprintable'    : 'quopri_codec',

    # rot_13 codec
    'rot13'              : 'rot_13',

    # shift_jis codec
    'csshiftjis'         : 'shift_jis',
    'shiftjis'           : 'shift_jis',
    'sjis'               : 'shift_jis',
    's_jis'              : 'shift_jis',

    # shift_jis_2004 codec
    'shiftjis2004'       : 'shift_jis_2004',
    'sjis_2004'          : 'shift_jis_2004',
    's_jis_2004'         : 'shift_jis_2004',

    # shift_jisx0213 codec
    'shiftjisx0213'      : 'shift_jisx0213',
    'sjisx0213'          : 'shift_jisx0213',
    's_jisx0213'         : 'shift_jisx0213',

    # tactis codec
    'tis260'             : 'tactis',

    # tis_620 codec
    'tis620'             : 'tis_620',
    'tis_620_0'          : 'tis_620',
    'tis_620_2529_0'     : 'tis_620',
    'tis_620_2529_1'     : 'tis_620',
    'iso_ir_166'         : 'tis_620',

    # utf_16 codec
    'u16'                : 'utf_16',
    'utf16'              : 'utf_16',

    # utf_16_be codec
    'unicodebigunmarked' : 'utf_16_be',
    'utf_16be'           : 'utf_16_be',

    # utf_16_le codec
    'unicodelittleunmarked' : 'utf_16_le',
    'utf_16le'           : 'utf_16_le',

    # utf_32 codec
    'u32'                : 'utf_32',
    'utf32'              : 'utf_32',

    # utf_32_be codec
    'utf_32be'           : 'utf_32_be',

    # utf_32_le codec
    'utf_32le'           : 'utf_32_le',

    # utf_7 codec
    'u7'                 : 'utf_7',
    'utf7'               : 'utf_7',
    'unicode_1_1_utf_7'  : 'utf_7',

    # utf_8 codec
    'u8'                 : 'utf_8',
    'utf'                : 'utf_8',
    'utf8'               : 'utf_8',
    'utf8_ucs2'          : 'utf_8',
    'utf8_ucs4'          : 'utf_8',

    # uu_codec codec
    'uu'                 : 'uu_codec',

    # zlib_codec codec
    'zip'                : 'zlib_codec',
    'zlib'               : 'zlib_codec',

    # temporary mac CJK aliases, will be replaced by proper codecs in 3.1
    'x_mac_japanese'      : 'shift_jis',
    'x_mac_korean'        : 'euc_kr',
    'x_mac_simp_chinese'  : 'gb2312',
    'x_mac_trad_chinese'  : 'big5',
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #
# big5.py: Python Unicode Codec for BIG5
#
# Written by Hye-Shik Chang <perky@FreeBSD.org>
#

import _codecs_tw, codecs
import _multibytecodec as mbc

codec = _codecs_tw.getcodec('big5')

class Codec(codecs.Codec):
    encode = codec.encode
    decode = codec.decode

class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,
                         codecs.IncrementalEncoder):
    codec = codec

class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,
                         codecs.IncrementalDecoder):
    codec = codec

class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):
    codec = codec

class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):
    codec = codec

def getregentry():
    return codecs.CodecInfo(
        name='big5',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #
# big5hkscs.py: Python Unicode Codec for BIG5HKSCS
#
# Written by Hye-Shik Chang <perky@FreeBSD.org>
#

import _codecs_hk, codecs
import _multibytecodec as mbc

codec = _codecs_hk.getcodec('big5hkscs')

class Codec(codecs.Codec):
    encode = codec.encode
    decode = codec.decode

class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,
                         codecs.IncrementalEncoder):
    codec = codec

class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,
                         codecs.IncrementalDecoder):
    codec = codec

class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):
    codec = codec

class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):
    codec = codec

def getregentry():
    return codecs.CodecInfo(
        name='big5hkscs',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """Python 'bz2_codec' Codec - bz2 compression encoding.

This codec de/encodes from bytes to bytes and is therefore usable with
bytes.transform() and bytes.untransform().

Adapted by Raymond Hettinger from zlib_codec.py which was written
by Marc-Andre Lemburg (mal@lemburg.com).
"""

import codecs
import bz2 # this codec needs the optional bz2 module !

### Codec APIs

def bz2_encode(input, errors='strict'):
    assert errors == 'strict'
    return (bz2.compress(input), len(input))

def bz2_decode(input, errors='strict'):
    assert errors == 'strict'
    return (bz2.decompress(input), len(input))

class Codec(codecs.Codec):
    def encode(self, input, errors='strict'):
        return bz2_encode(input, errors)
    def decode(self, input, errors='strict'):
        return bz2_decode(input, errors)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def __init__(self, errors='strict'):
        assert errors == 'strict'
        self.errors = errors
        self.compressobj = bz2.BZ2Compressor()

    def encode(self, input, final=False):
        if final:
            c = self.compressobj.compress(input)
            return c + self.compressobj.flush()
        else:
            return self.compressobj.compress(input)

    def reset(self):
        self.compressobj = bz2.BZ2Compressor()

class IncrementalDecoder(codecs.IncrementalDecoder):
    def __init__(self, errors='strict'):
        assert errors == 'strict'
        self.errors = errors
        self.decompressobj = bz2.BZ2Decompressor()

    def decode(self, input, final=False):
        try:
            return self.decompressobj.decompress(input)
        except EOFError:
            return ''

    def reset(self):
        self.decompressobj = bz2.BZ2Decompressor()

class StreamWriter(Codec, codecs.StreamWriter):
    charbuffertype = bytes

class StreamReader(Codec, codecs.StreamReader):
    charbuffertype = bytes

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name="bz2",
        encode=bz2_encode,
        decode=bz2_decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
        _is_text_encoding=False,
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """ Generic Python Character Mapping Codec.

    Use this codec directly rather than through the automatic
    conversion mechanisms supplied by unicode() and .encode().


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    # Note: Binding these as C functions will result in the class not
    # converting them to methods. This is intended.
    encode = codecs.charmap_encode
    decode = codecs.charmap_decode

class IncrementalEncoder(codecs.IncrementalEncoder):
    def __init__(self, errors='strict', mapping=None):
        codecs.IncrementalEncoder.__init__(self, errors)
        self.mapping = mapping

    def encode(self, input, final=False):
        return codecs.charmap_encode(input, self.errors, self.mapping)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def __init__(self, errors='strict', mapping=None):
        codecs.IncrementalDecoder.__init__(self, errors)
        self.mapping = mapping

    def decode(self, input, final=False):
        return codecs.charmap_decode(input, self.errors, self.mapping)[0]

class StreamWriter(Codec,codecs.StreamWriter):

    def __init__(self,stream,errors='strict',mapping=None):
        codecs.StreamWriter.__init__(self,stream,errors)
        self.mapping = mapping

    def encode(self,input,errors='strict'):
        return Codec.encode(input,errors,self.mapping)

class StreamReader(Codec,codecs.StreamReader):

    def __init__(self,stream,errors='strict',mapping=None):
        codecs.StreamReader.__init__(self,stream,errors)
        self.mapping = mapping

    def decode(self,input,errors='strict'):
        return Codec.decode(input,errors,self.mapping)

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='charmap',
        encode=Codec.encode,
        decode=Codec.decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """ Python Character Mapping Codec cp037 generated from 'MAPPINGS/VENDORS/MICSFT/EBCDIC/CP037.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp037',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x9c'     #  0x04 -> CONTROL
    '\t'       #  0x05 -> HORIZONTAL TABULATION
    '\x86'     #  0x06 -> CONTROL
    '\x7f'     #  0x07 -> DELETE
    '\x97'     #  0x08 -> CONTROL
    '\x8d'     #  0x09 -> CONTROL
    '\x8e'     #  0x0A -> CONTROL
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x9d'     #  0x14 -> CONTROL
    '\x85'     #  0x15 -> CONTROL
    '\x08'     #  0x16 -> BACKSPACE
    '\x87'     #  0x17 -> CONTROL
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x92'     #  0x1A -> CONTROL
    '\x8f'     #  0x1B -> CONTROL
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    '\x80'     #  0x20 -> CONTROL
    '\x81'     #  0x21 -> CONTROL
    '\x82'     #  0x22 -> CONTROL
    '\x83'     #  0x23 -> CONTROL
    '\x84'     #  0x24 -> CONTROL
    '\n'       #  0x25 -> LINE FEED
    '\x17'     #  0x26 -> END OF TRANSMISSION BLOCK
    '\x1b'     #  0x27 -> ESCAPE
    '\x88'     #  0x28 -> CONTROL
    '\x89'     #  0x29 -> CONTROL
    '\x8a'     #  0x2A -> CONTROL
    '\x8b'     #  0x2B -> CONTROL
    '\x8c'     #  0x2C -> CONTROL
    '\x05'     #  0x2D -> ENQUIRY
    '\x06'     #  0x2E -> ACKNOWLEDGE
    '\x07'     #  0x2F -> BELL
    '\x90'     #  0x30 -> CONTROL
    '\x91'     #  0x31 -> CONTROL
    '\x16'     #  0x32 -> SYNCHRONOUS IDLE
    '\x93'     #  0x33 -> CONTROL
    '\x94'     #  0x34 -> CONTROL
    '\x95'     #  0x35 -> CONTROL
    '\x96'     #  0x36 -> CONTROL
    '\x04'     #  0x37 -> END OF TRANSMISSION
    '\x98'     #  0x38 -> CONTROL
    '\x99'     #  0x39 -> CONTROL
    '\x9a'     #  0x3A -> CONTROL
    '\x9b'     #  0x3B -> CONTROL
    '\x14'     #  0x3C -> DEVICE CONTROL FOUR
    '\x15'     #  0x3D -> NEGATIVE ACKNOWLEDGE
    '\x9e'     #  0x3E -> CONTROL
    '\x1a'     #  0x3F -> SUBSTITUTE
    ' '        #  0x40 -> SPACE
    '\xa0'     #  0x41 -> NO-BREAK SPACE
    '\xe2'     #  0x42 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\xe4'     #  0x43 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe0'     #  0x44 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'     #  0x45 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe3'     #  0x46 -> LATIN SMALL LETTER A WITH TILDE
    '\xe5'     #  0x47 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe7'     #  0x48 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xf1'     #  0x49 -> LATIN SMALL LETTER N WITH TILDE
    '\xa2'     #  0x4A -> CENT SIGN
    '.'        #  0x4B -> FULL STOP
    '<'        #  0x4C -> LESS-THAN SIGN
    '('        #  0x4D -> LEFT PARENTHESIS
    '+'        #  0x4E -> PLUS SIGN
    '|'        #  0x4F -> VERTICAL LINE
    '&'        #  0x50 -> AMPERSAND
    '\xe9'     #  0x51 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0x52 -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0x53 -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xe8'     #  0x54 -> LATIN SMALL LETTER E WITH GRAVE
    '\xed'     #  0x55 -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0x56 -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0x57 -> LATIN SMALL LETTER I WITH DIAERESIS
    '\xec'     #  0x58 -> LATIN SMALL LETTER I WITH GRAVE
    '\xdf'     #  0x59 -> LATIN SMALL LETTER SHARP S (GERMAN)
    '!'        #  0x5A -> EXCLAMATION MARK
    '$'        #  0x5B -> DOLLAR SIGN
    '*'        #  0x5C -> ASTERISK
    ')'        #  0x5D -> RIGHT PARENTHESIS
    ';'        #  0x5E -> SEMICOLON
    '\xac'     #  0x5F -> NOT SIGN
    '-'        #  0x60 -> HYPHEN-MINUS
    '/'        #  0x61 -> SOLIDUS
    '\xc2'     #  0x62 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\xc4'     #  0x63 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc0'     #  0x64 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'     #  0x65 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc3'     #  0x66 -> LATIN CAPITAL LETTER A WITH TILDE
    '\xc5'     #  0x67 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc7'     #  0x68 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xd1'     #  0x69 -> LATIN CAPITAL LETTER N WITH TILDE
    '\xa6'     #  0x6A -> BROKEN BAR
    ','        #  0x6B -> COMMA
    '%'        #  0x6C -> PERCENT SIGN
    '_'        #  0x6D -> LOW LINE
    '>'        #  0x6E -> GREATER-THAN SIGN
    '?'        #  0x6F -> QUESTION MARK
    '\xf8'     #  0x70 -> LATIN SMALL LETTER O WITH STROKE
    '\xc9'     #  0x71 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'     #  0x72 -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'     #  0x73 -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\xc8'     #  0x74 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xcd'     #  0x75 -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0x76 -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'     #  0x77 -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\xcc'     #  0x78 -> LATIN CAPITAL LETTER I WITH GRAVE
    '`'        #  0x79 -> GRAVE ACCENT
    ':'        #  0x7A -> COLON
    '#'        #  0x7B -> NUMBER SIGN
    '@'        #  0x7C -> COMMERCIAL AT
    "'"        #  0x7D -> APOSTROPHE
    '='        #  0x7E -> EQUALS SIGN
    '"'        #  0x7F -> QUOTATION MARK
    '\xd8'     #  0x80 -> LATIN CAPITAL LETTER O WITH STROKE
    'a'        #  0x81 -> LATIN SMALL LETTER A
    'b'        #  0x82 -> LATIN SMALL LETTER B
    'c'        #  0x83 -> LATIN SMALL LETTER C
    'd'        #  0x84 -> LATIN SMALL LETTER D
    'e'        #  0x85 -> LATIN SMALL LETTER E
    'f'        #  0x86 -> LATIN SMALL LETTER F
    'g'        #  0x87 -> LATIN SMALL LETTER G
    'h'        #  0x88 -> LATIN SMALL LETTER H
    'i'        #  0x89 -> LATIN SMALL LETTER I
    '\xab'     #  0x8A -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbb'     #  0x8B -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xf0'     #  0x8C -> LATIN SMALL LETTER ETH (ICELANDIC)
    '\xfd'     #  0x8D -> LATIN SMALL LETTER Y WITH ACUTE
    '\xfe'     #  0x8E -> LATIN SMALL LETTER THORN (ICELANDIC)
    '\xb1'     #  0x8F -> PLUS-MINUS SIGN
    '\xb0'     #  0x90 -> DEGREE SIGN
    'j'        #  0x91 -> LATIN SMALL LETTER J
    'k'        #  0x92 -> LATIN SMALL LETTER K
    'l'        #  0x93 -> LATIN SMALL LETTER L
    'm'        #  0x94 -> LATIN SMALL LETTER M
    'n'        #  0x95 -> LATIN SMALL LETTER N
    'o'        #  0x96 -> LATIN SMALL LETTER O
    'p'        #  0x97 -> LATIN SMALL LETTER P
    'q'        #  0x98 -> LATIN SMALL LETTER Q
    'r'        #  0x99 -> LATIN SMALL LETTER R
    '\xaa'     #  0x9A -> FEMININE ORDINAL INDICATOR
    '\xba'     #  0x9B -> MASCULINE ORDINAL INDICATOR
    '\xe6'     #  0x9C -> LATIN SMALL LIGATURE AE
    '\xb8'     #  0x9D -> CEDILLA
    '\xc6'     #  0x9E -> LATIN CAPITAL LIGATURE AE
    '\xa4'     #  0x9F -> CURRENCY SIGN
    '\xb5'     #  0xA0 -> MICRO SIGN
    '~'        #  0xA1 -> TILDE
    's'        #  0xA2 -> LATIN SMALL LETTER S
    't'        #  0xA3 -> LATIN SMALL LETTER T
    'u'        #  0xA4 -> LATIN SMALL LETTER U
    'v'        #  0xA5 -> LATIN SMALL LETTER V
    'w'        #  0xA6 -> LATIN SMALL LETTER W
    'x'        #  0xA7 -> LATIN SMALL LETTER X
    'y'        #  0xA8 -> LATIN SMALL LETTER Y
    'z'        #  0xA9 -> LATIN SMALL LETTER Z
    '\xa1'     #  0xAA -> INVERTED EXCLAMATION MARK
    '\xbf'     #  0xAB -> INVERTED QUESTION MARK
    '\xd0'     #  0xAC -> LATIN CAPITAL LETTER ETH (ICELANDIC)
    '\xdd'     #  0xAD -> LATIN CAPITAL LETTER Y WITH ACUTE
    '\xde'     #  0xAE -> LATIN CAPITAL LETTER THORN (ICELANDIC)
    '\xae'     #  0xAF -> REGISTERED SIGN
    '^'        #  0xB0 -> CIRCUMFLEX ACCENT
    '\xa3'     #  0xB1 -> POUND SIGN
    '\xa5'     #  0xB2 -> YEN SIGN
    '\xb7'     #  0xB3 -> MIDDLE DOT
    '\xa9'     #  0xB4 -> COPYRIGHT SIGN
    '\xa7'     #  0xB5 -> SECTION SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xbc'     #  0xB7 -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xB8 -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xB9 -> VULGAR FRACTION THREE QUARTERS
    '['        #  0xBA -> LEFT SQUARE BRACKET
    ']'        #  0xBB -> RIGHT SQUARE BRACKET
    '\xaf'     #  0xBC -> MACRON
    '\xa8'     #  0xBD -> DIAERESIS
    '\xb4'     #  0xBE -> ACUTE ACCENT
    '\xd7'     #  0xBF -> MULTIPLICATION SIGN
    '{'        #  0xC0 -> LEFT CURLY BRACKET
    'A'        #  0xC1 -> LATIN CAPITAL LETTER A
    'B'        #  0xC2 -> LATIN CAPITAL LETTER B
    'C'        #  0xC3 -> LATIN CAPITAL LETTER C
    'D'        #  0xC4 -> LATIN CAPITAL LETTER D
    'E'        #  0xC5 -> LATIN CAPITAL LETTER E
    'F'        #  0xC6 -> LATIN CAPITAL LETTER F
    'G'        #  0xC7 -> LATIN CAPITAL LETTER G
    'H'        #  0xC8 -> LATIN CAPITAL LETTER H
    'I'        #  0xC9 -> LATIN CAPITAL LETTER I
    '\xad'     #  0xCA -> SOFT HYPHEN
    '\xf4'     #  0xCB -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\xf6'     #  0xCC -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf2'     #  0xCD -> LATIN SMALL LETTER O WITH GRAVE
    '\xf3'     #  0xCE -> LATIN SMALL LETTER O WITH ACUTE
    '\xf5'     #  0xCF -> LATIN SMALL LETTER O WITH TILDE
    '}'        #  0xD0 -> RIGHT CURLY BRACKET
    'J'        #  0xD1 -> LATIN CAPITAL LETTER J
    'K'        #  0xD2 -> LATIN CAPITAL LETTER K
    'L'        #  0xD3 -> LATIN CAPITAL LETTER L
    'M'        #  0xD4 -> LATIN CAPITAL LETTER M
    'N'        #  0xD5 -> LATIN CAPITAL LETTER N
    'O'        #  0xD6 -> LATIN CAPITAL LETTER O
    'P'        #  0xD7 -> LATIN CAPITAL LETTER P
    'Q'        #  0xD8 -> LATIN CAPITAL LETTER Q
    'R'        #  0xD9 -> LATIN CAPITAL LETTER R
    '\xb9'     #  0xDA -> SUPERSCRIPT ONE
    '\xfb'     #  0xDB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xfc'     #  0xDC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\xf9'     #  0xDD -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'     #  0xDE -> LATIN SMALL LETTER U WITH ACUTE
    '\xff'     #  0xDF -> LATIN SMALL LETTER Y WITH DIAERESIS
    '\\'       #  0xE0 -> REVERSE SOLIDUS
    '\xf7'     #  0xE1 -> DIVISION SIGN
    'S'        #  0xE2 -> LATIN CAPITAL LETTER S
    'T'        #  0xE3 -> LATIN CAPITAL LETTER T
    'U'        #  0xE4 -> LATIN CAPITAL LETTER U
    'V'        #  0xE5 -> LATIN CAPITAL LETTER V
    'W'        #  0xE6 -> LATIN CAPITAL LETTER W
    'X'        #  0xE7 -> LATIN CAPITAL LETTER X
    'Y'        #  0xE8 -> LATIN CAPITAL LETTER Y
    'Z'        #  0xE9 -> LATIN CAPITAL LETTER Z
    '\xb2'     #  0xEA -> SUPERSCRIPT TWO
    '\xd4'     #  0xEB -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\xd6'     #  0xEC -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd2'     #  0xED -> LATIN CAPITAL LETTER O WITH GRAVE
    '\xd3'     #  0xEE -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd5'     #  0xEF -> LATIN CAPITAL LETTER O WITH TILDE
    '0'        #  0xF0 -> DIGIT ZERO
    '1'        #  0xF1 -> DIGIT ONE
    '2'        #  0xF2 -> DIGIT TWO
    '3'        #  0xF3 -> DIGIT THREE
    '4'        #  0xF4 -> DIGIT FOUR
    '5'        #  0xF5 -> DIGIT FIVE
    '6'        #  0xF6 -> DIGIT SIX
    '7'        #  0xF7 -> DIGIT SEVEN
    '8'        #  0xF8 -> DIGIT EIGHT
    '9'        #  0xF9 -> DIGIT NINE
    '\xb3'     #  0xFA -> SUPERSCRIPT THREE
    '\xdb'     #  0xFB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    '\xdc'     #  0xFC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\xd9'     #  0xFD -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'     #  0xFE -> LATIN CAPITAL LETTER U WITH ACUTE
    '\x9f'     #  0xFF -> CONTROL
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """ Python Character Mapping Codec cp1006 generated from 'MAPPINGS/VENDORS/MISC/CP1006.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1006',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\x80'     #  0x80 -> <control>
    '\x81'     #  0x81 -> <control>
    '\x82'     #  0x82 -> <control>
    '\x83'     #  0x83 -> <control>
    '\x84'     #  0x84 -> <control>
    '\x85'     #  0x85 -> <control>
    '\x86'     #  0x86 -> <control>
    '\x87'     #  0x87 -> <control>
    '\x88'     #  0x88 -> <control>
    '\x89'     #  0x89 -> <control>
    '\x8a'     #  0x8A -> <control>
    '\x8b'     #  0x8B -> <control>
    '\x8c'     #  0x8C -> <control>
    '\x8d'     #  0x8D -> <control>
    '\x8e'     #  0x8E -> <control>
    '\x8f'     #  0x8F -> <control>
    '\x90'     #  0x90 -> <control>
    '\x91'     #  0x91 -> <control>
    '\x92'     #  0x92 -> <control>
    '\x93'     #  0x93 -> <control>
    '\x94'     #  0x94 -> <control>
    '\x95'     #  0x95 -> <control>
    '\x96'     #  0x96 -> <control>
    '\x97'     #  0x97 -> <control>
    '\x98'     #  0x98 -> <control>
    '\x99'     #  0x99 -> <control>
    '\x9a'     #  0x9A -> <control>
    '\x9b'     #  0x9B -> <control>
    '\x9c'     #  0x9C -> <control>
    '\x9d'     #  0x9D -> <control>
    '\x9e'     #  0x9E -> <control>
    '\x9f'     #  0x9F -> <control>
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\u06f0'   #  0xA1 -> EXTENDED ARABIC-INDIC DIGIT ZERO
    '\u06f1'   #  0xA2 -> EXTENDED ARABIC-INDIC DIGIT ONE
    '\u06f2'   #  0xA3 -> EXTENDED ARABIC-INDIC DIGIT TWO
    '\u06f3'   #  0xA4 -> EXTENDED ARABIC-INDIC DIGIT THREE
    '\u06f4'   #  0xA5 -> EXTENDED ARABIC-INDIC DIGIT FOUR
    '\u06f5'   #  0xA6 -> EXTENDED ARABIC-INDIC DIGIT FIVE
    '\u06f6'   #  0xA7 -> EXTENDED ARABIC-INDIC DIGIT SIX
    '\u06f7'   #  0xA8 -> EXTENDED ARABIC-INDIC DIGIT SEVEN
    '\u06f8'   #  0xA9 -> EXTENDED ARABIC-INDIC DIGIT EIGHT
    '\u06f9'   #  0xAA -> EXTENDED ARABIC-INDIC DIGIT NINE
    '\u060c'   #  0xAB -> ARABIC COMMA
    '\u061b'   #  0xAC -> ARABIC SEMICOLON
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\u061f'   #  0xAE -> ARABIC QUESTION MARK
    '\ufe81'   #  0xAF -> ARABIC LETTER ALEF WITH MADDA ABOVE ISOLATED FORM
    '\ufe8d'   #  0xB0 -> ARABIC LETTER ALEF ISOLATED FORM
    '\ufe8e'   #  0xB1 -> ARABIC LETTER ALEF FINAL FORM
    '\ufe8e'   #  0xB2 -> ARABIC LETTER ALEF FINAL FORM
    '\ufe8f'   #  0xB3 -> ARABIC LETTER BEH ISOLATED FORM
    '\ufe91'   #  0xB4 -> ARABIC LETTER BEH INITIAL FORM
    '\ufb56'   #  0xB5 -> ARABIC LETTER PEH ISOLATED FORM
    '\ufb58'   #  0xB6 -> ARABIC LETTER PEH INITIAL FORM
    '\ufe93'   #  0xB7 -> ARABIC LETTER TEH MARBUTA ISOLATED FORM
    '\ufe95'   #  0xB8 -> ARABIC LETTER TEH ISOLATED FORM
    '\ufe97'   #  0xB9 -> ARABIC LETTER TEH INITIAL FORM
    '\ufb66'   #  0xBA -> ARABIC LETTER TTEH ISOLATED FORM
    '\ufb68'   #  0xBB -> ARABIC LETTER TTEH INITIAL FORM
    '\ufe99'   #  0xBC -> ARABIC LETTER THEH ISOLATED FORM
    '\ufe9b'   #  0xBD -> ARABIC LETTER THEH INITIAL FORM
    '\ufe9d'   #  0xBE -> ARABIC LETTER JEEM ISOLATED FORM
    '\ufe9f'   #  0xBF -> ARABIC LETTER JEEM INITIAL FORM
    '\ufb7a'   #  0xC0 -> ARABIC LETTER TCHEH ISOLATED FORM
    '\ufb7c'   #  0xC1 -> ARABIC LETTER TCHEH INITIAL FORM
    '\ufea1'   #  0xC2 -> ARABIC LETTER HAH ISOLATED FORM
    '\ufea3'   #  0xC3 -> ARABIC LETTER HAH INITIAL FORM
    '\ufea5'   #  0xC4 -> ARABIC LETTER KHAH ISOLATED FORM
    '\ufea7'   #  0xC5 -> ARABIC LETTER KHAH INITIAL FORM
    '\ufea9'   #  0xC6 -> ARABIC LETTER DAL ISOLATED FORM
    '\ufb84'   #  0xC7 -> ARABIC LETTER DAHAL ISOLATED FORMN
    '\ufeab'   #  0xC8 -> ARABIC LETTER THAL ISOLATED FORM
    '\ufead'   #  0xC9 -> ARABIC LETTER REH ISOLATED FORM
    '\ufb8c'   #  0xCA -> ARABIC LETTER RREH ISOLATED FORM
    '\ufeaf'   #  0xCB -> ARABIC LETTER ZAIN ISOLATED FORM
    '\ufb8a'   #  0xCC -> ARABIC LETTER JEH ISOLATED FORM
    '\ufeb1'   #  0xCD -> ARABIC LETTER SEEN ISOLATED FORM
    '\ufeb3'   #  0xCE -> ARABIC LETTER SEEN INITIAL FORM
    '\ufeb5'   #  0xCF -> ARABIC LETTER SHEEN ISOLATED FORM
    '\ufeb7'   #  0xD0 -> ARABIC LETTER SHEEN INITIAL FORM
    '\ufeb9'   #  0xD1 -> ARABIC LETTER SAD ISOLATED FORM
    '\ufebb'   #  0xD2 -> ARABIC LETTER SAD INITIAL FORM
    '\ufebd'   #  0xD3 -> ARABIC LETTER DAD ISOLATED FORM
    '\ufebf'   #  0xD4 -> ARABIC LETTER DAD INITIAL FORM
    '\ufec1'   #  0xD5 -> ARABIC LETTER TAH ISOLATED FORM
    '\ufec5'   #  0xD6 -> ARABIC LETTER ZAH ISOLATED FORM
    '\ufec9'   #  0xD7 -> ARABIC LETTER AIN ISOLATED FORM
    '\ufeca'   #  0xD8 -> ARABIC LETTER AIN FINAL FORM
    '\ufecb'   #  0xD9 -> ARABIC LETTER AIN INITIAL FORM
    '\ufecc'   #  0xDA -> ARABIC LETTER AIN MEDIAL FORM
    '\ufecd'   #  0xDB -> ARABIC LETTER GHAIN ISOLATED FORM
    '\ufece'   #  0xDC -> ARABIC LETTER GHAIN FINAL FORM
    '\ufecf'   #  0xDD -> ARABIC LETTER GHAIN INITIAL FORM
    '\ufed0'   #  0xDE -> ARABIC LETTER GHAIN MEDIAL FORM
    '\ufed1'   #  0xDF -> ARABIC LETTER FEH ISOLATED FORM
    '\ufed3'   #  0xE0 -> ARABIC LETTER FEH INITIAL FORM
    '\ufed5'   #  0xE1 -> ARABIC LETTER QAF ISOLATED FORM
    '\ufed7'   #  0xE2 -> ARABIC LETTER QAF INITIAL FORM
    '\ufed9'   #  0xE3 -> ARABIC LETTER KAF ISOLATED FORM
    '\ufedb'   #  0xE4 -> ARABIC LETTER KAF INITIAL FORM
    '\ufb92'   #  0xE5 -> ARABIC LETTER GAF ISOLATED FORM
    '\ufb94'   #  0xE6 -> ARABIC LETTER GAF INITIAL FORM
    '\ufedd'   #  0xE7 -> ARABIC LETTER LAM ISOLATED FORM
    '\ufedf'   #  0xE8 -> ARABIC LETTER LAM INITIAL FORM
    '\ufee0'   #  0xE9 -> ARABIC LETTER LAM MEDIAL FORM
    '\ufee1'   #  0xEA -> ARABIC LETTER MEEM ISOLATED FORM
    '\ufee3'   #  0xEB -> ARABIC LETTER MEEM INITIAL FORM
    '\ufb9e'   #  0xEC -> ARABIC LETTER NOON GHUNNA ISOLATED FORM
    '\ufee5'   #  0xED -> ARABIC LETTER NOON ISOLATED FORM
    '\ufee7'   #  0xEE -> ARABIC LETTER NOON INITIAL FORM
    '\ufe85'   #  0xEF -> ARABIC LETTER WAW WITH HAMZA ABOVE ISOLATED FORM
    '\ufeed'   #  0xF0 -> ARABIC LETTER WAW ISOLATED FORM
    '\ufba6'   #  0xF1 -> ARABIC LETTER HEH GOAL ISOLATED FORM
    '\ufba8'   #  0xF2 -> ARABIC LETTER HEH GOAL INITIAL FORM
    '\ufba9'   #  0xF3 -> ARABIC LETTER HEH GOAL MEDIAL FORM
    '\ufbaa'   #  0xF4 -> ARABIC LETTER HEH DOACHASHMEE ISOLATED FORM
    '\ufe80'   #  0xF5 -> ARABIC LETTER HAMZA ISOLATED FORM
    '\ufe89'   #  0xF6 -> ARABIC LETTER YEH WITH HAMZA ABOVE ISOLATED FORM
    '\ufe8a'   #  0xF7 -> ARABIC LETTER YEH WITH HAMZA ABOVE FINAL FORM
    '\ufe8b'   #  0xF8 -> ARABIC LETTER YEH WITH HAMZA ABOVE INITIAL FORM
    '\ufef1'   #  0xF9 -> ARABIC LETTER YEH ISOLATED FORM
    '\ufef2'   #  0xFA -> ARABIC LETTER YEH FINAL FORM
    '\ufef3'   #  0xFB -> ARABIC LETTER YEH INITIAL FORM
    '\ufbb0'   #  0xFC -> ARABIC LETTER YEH BARREE WITH HAMZA ABOVE ISOLATED FORM
    '\ufbae'   #  0xFD -> ARABIC LETTER YEH BARREE ISOLATED FORM
    '\ufe7c'   #  0xFE -> ARABIC SHADDA ISOLATED FORM
    '\ufe7d'   #  0xFF -> ARABIC SHADDA MEDIAL FORM
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """ Python Character Mapping Codec cp1026 generated from 'MAPPINGS/VENDORS/MICSFT/EBCDIC/CP1026.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1026',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x9c'     #  0x04 -> CONTROL
    '\t'       #  0x05 -> HORIZONTAL TABULATION
    '\x86'     #  0x06 -> CONTROL
    '\x7f'     #  0x07 -> DELETE
    '\x97'     #  0x08 -> CONTROL
    '\x8d'     #  0x09 -> CONTROL
    '\x8e'     #  0x0A -> CONTROL
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x9d'     #  0x14 -> CONTROL
    '\x85'     #  0x15 -> CONTROL
    '\x08'     #  0x16 -> BACKSPACE
    '\x87'     #  0x17 -> CONTROL
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x92'     #  0x1A -> CONTROL
    '\x8f'     #  0x1B -> CONTROL
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    '\x80'     #  0x20 -> CONTROL
    '\x81'     #  0x21 -> CONTROL
    '\x82'     #  0x22 -> CONTROL
    '\x83'     #  0x23 -> CONTROL
    '\x84'     #  0x24 -> CONTROL
    '\n'       #  0x25 -> LINE FEED
    '\x17'     #  0x26 -> END OF TRANSMISSION BLOCK
    '\x1b'     #  0x27 -> ESCAPE
    '\x88'     #  0x28 -> CONTROL
    '\x89'     #  0x29 -> CONTROL
    '\x8a'     #  0x2A -> CONTROL
    '\x8b'     #  0x2B -> CONTROL
    '\x8c'     #  0x2C -> CONTROL
    '\x05'     #  0x2D -> ENQUIRY
    '\x06'     #  0x2E -> ACKNOWLEDGE
    '\x07'     #  0x2F -> BELL
    '\x90'     #  0x30 -> CONTROL
    '\x91'     #  0x31 -> CONTROL
    '\x16'     #  0x32 -> SYNCHRONOUS IDLE
    '\x93'     #  0x33 -> CONTROL
    '\x94'     #  0x34 -> CONTROL
    '\x95'     #  0x35 -> CONTROL
    '\x96'     #  0x36 -> CONTROL
    '\x04'     #  0x37 -> END OF TRANSMISSION
    '\x98'     #  0x38 -> CONTROL
    '\x99'     #  0x39 -> CONTROL
    '\x9a'     #  0x3A -> CONTROL
    '\x9b'     #  0x3B -> CONTROL
    '\x14'     #  0x3C -> DEVICE CONTROL FOUR
    '\x15'     #  0x3D -> NEGATIVE ACKNOWLEDGE
    '\x9e'     #  0x3E -> CONTROL
    '\x1a'     #  0x3F -> SUBSTITUTE
    ' '        #  0x40 -> SPACE
    '\xa0'     #  0x41 -> NO-BREAK SPACE
    '\xe2'     #  0x42 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\xe4'     #  0x43 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe0'     #  0x44 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'     #  0x45 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe3'     #  0x46 -> LATIN SMALL LETTER A WITH TILDE
    '\xe5'     #  0x47 -> LATIN SMALL LETTER A WITH RING ABOVE
    '{'        #  0x48 -> LEFT CURLY BRACKET
    '\xf1'     #  0x49 -> LATIN SMALL LETTER N WITH TILDE
    '\xc7'     #  0x4A -> LATIN CAPITAL LETTER C WITH CEDILLA
    '.'        #  0x4B -> FULL STOP
    '<'        #  0x4C -> LESS-THAN SIGN
    '('        #  0x4D -> LEFT PARENTHESIS
    '+'        #  0x4E -> PLUS SIGN
    '!'        #  0x4F -> EXCLAMATION MARK
    '&'        #  0x50 -> AMPERSAND
    '\xe9'     #  0x51 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0x52 -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0x53 -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xe8'     #  0x54 -> LATIN SMALL LETTER E WITH GRAVE
    '\xed'     #  0x55 -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0x56 -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0x57 -> LATIN SMALL LETTER I WITH DIAERESIS
    '\xec'     #  0x58 -> LATIN SMALL LETTER I WITH GRAVE
    '\xdf'     #  0x59 -> LATIN SMALL LETTER SHARP S (GERMAN)
    '\u011e'   #  0x5A -> LATIN CAPITAL LETTER G WITH BREVE
    '\u0130'   #  0x5B -> LATIN CAPITAL LETTER I WITH DOT ABOVE
    '*'        #  0x5C -> ASTERISK
    ')'        #  0x5D -> RIGHT PARENTHESIS
    ';'        #  0x5E -> SEMICOLON
    '^'        #  0x5F -> CIRCUMFLEX ACCENT
    '-'        #  0x60 -> HYPHEN-MINUS
    '/'        #  0x61 -> SOLIDUS
    '\xc2'     #  0x62 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\xc4'     #  0x63 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc0'     #  0x64 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'     #  0x65 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc3'     #  0x66 -> LATIN CAPITAL LETTER A WITH TILDE
    '\xc5'     #  0x67 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '['        #  0x68 -> LEFT SQUARE BRACKET
    '\xd1'     #  0x69 -> LATIN CAPITAL LETTER N WITH TILDE
    '\u015f'   #  0x6A -> LATIN SMALL LETTER S WITH CEDILLA
    ','        #  0x6B -> COMMA
    '%'        #  0x6C -> PERCENT SIGN
    '_'        #  0x6D -> LOW LINE
    '>'        #  0x6E -> GREATER-THAN SIGN
    '?'        #  0x6F -> QUESTION MARK
    '\xf8'     #  0x70 -> LATIN SMALL LETTER O WITH STROKE
    '\xc9'     #  0x71 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'     #  0x72 -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'     #  0x73 -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\xc8'     #  0x74 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xcd'     #  0x75 -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0x76 -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'     #  0x77 -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\xcc'     #  0x78 -> LATIN CAPITAL LETTER I WITH GRAVE
    '\u0131'   #  0x79 -> LATIN SMALL LETTER DOTLESS I
    ':'        #  0x7A -> COLON
    '\xd6'     #  0x7B -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\u015e'   #  0x7C -> LATIN CAPITAL LETTER S WITH CEDILLA
    "'"        #  0x7D -> APOSTROPHE
    '='        #  0x7E -> EQUALS SIGN
    '\xdc'     #  0x7F -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\xd8'     #  0x80 -> LATIN CAPITAL LETTER O WITH STROKE
    'a'        #  0x81 -> LATIN SMALL LETTER A
    'b'        #  0x82 -> LATIN SMALL LETTER B
    'c'        #  0x83 -> LATIN SMALL LETTER C
    'd'        #  0x84 -> LATIN SMALL LETTER D
    'e'        #  0x85 -> LATIN SMALL LETTER E
    'f'        #  0x86 -> LATIN SMALL LETTER F
    'g'        #  0x87 -> LATIN SMALL LETTER G
    'h'        #  0x88 -> LATIN SMALL LETTER H
    'i'        #  0x89 -> LATIN SMALL LETTER I
    '\xab'     #  0x8A -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbb'     #  0x8B -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '}'        #  0x8C -> RIGHT CURLY BRACKET
    '`'        #  0x8D -> GRAVE ACCENT
    '\xa6'     #  0x8E -> BROKEN BAR
    '\xb1'     #  0x8F -> PLUS-MINUS SIGN
    '\xb0'     #  0x90 -> DEGREE SIGN
    'j'        #  0x91 -> LATIN SMALL LETTER J
    'k'        #  0x92 -> LATIN SMALL LETTER K
    'l'        #  0x93 -> LATIN SMALL LETTER L
    'm'        #  0x94 -> LATIN SMALL LETTER M
    'n'        #  0x95 -> LATIN SMALL LETTER N
    'o'        #  0x96 -> LATIN SMALL LETTER O
    'p'        #  0x97 -> LATIN SMALL LETTER P
    'q'        #  0x98 -> LATIN SMALL LETTER Q
    'r'        #  0x99 -> LATIN SMALL LETTER R
    '\xaa'     #  0x9A -> FEMININE ORDINAL INDICATOR
    '\xba'     #  0x9B -> MASCULINE ORDINAL INDICATOR
    '\xe6'     #  0x9C -> LATIN SMALL LIGATURE AE
    '\xb8'     #  0x9D -> CEDILLA
    '\xc6'     #  0x9E -> LATIN CAPITAL LIGATURE AE
    '\xa4'     #  0x9F -> CURRENCY SIGN
    '\xb5'     #  0xA0 -> MICRO SIGN
    '\xf6'     #  0xA1 -> LATIN SMALL LETTER O WITH DIAERESIS
    's'        #  0xA2 -> LATIN SMALL LETTER S
    't'        #  0xA3 -> LATIN SMALL LETTER T
    'u'        #  0xA4 -> LATIN SMALL LETTER U
    'v'        #  0xA5 -> LATIN SMALL LETTER V
    'w'        #  0xA6 -> LATIN SMALL LETTER W
    'x'        #  0xA7 -> LATIN SMALL LETTER X
    'y'        #  0xA8 -> LATIN SMALL LETTER Y
    'z'        #  0xA9 -> LATIN SMALL LETTER Z
    '\xa1'     #  0xAA -> INVERTED EXCLAMATION MARK
    '\xbf'     #  0xAB -> INVERTED QUESTION MARK
    ']'        #  0xAC -> RIGHT SQUARE BRACKET
    '$'        #  0xAD -> DOLLAR SIGN
    '@'        #  0xAE -> COMMERCIAL AT
    '\xae'     #  0xAF -> REGISTERED SIGN
    '\xa2'     #  0xB0 -> CENT SIGN
    '\xa3'     #  0xB1 -> POUND SIGN
    '\xa5'     #  0xB2 -> YEN SIGN
    '\xb7'     #  0xB3 -> MIDDLE DOT
    '\xa9'     #  0xB4 -> COPYRIGHT SIGN
    '\xa7'     #  0xB5 -> SECTION SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xbc'     #  0xB7 -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xB8 -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xB9 -> VULGAR FRACTION THREE QUARTERS
    '\xac'     #  0xBA -> NOT SIGN
    '|'        #  0xBB -> VERTICAL LINE
    '\xaf'     #  0xBC -> MACRON
    '\xa8'     #  0xBD -> DIAERESIS
    '\xb4'     #  0xBE -> ACUTE ACCENT
    '\xd7'     #  0xBF -> MULTIPLICATION SIGN
    '\xe7'     #  0xC0 -> LATIN SMALL LETTER C WITH CEDILLA
    'A'        #  0xC1 -> LATIN CAPITAL LETTER A
    'B'        #  0xC2 -> LATIN CAPITAL LETTER B
    'C'        #  0xC3 -> LATIN CAPITAL LETTER C
    'D'        #  0xC4 -> LATIN CAPITAL LETTER D
    'E'        #  0xC5 -> LATIN CAPITAL LETTER E
    'F'        #  0xC6 -> LATIN CAPITAL LETTER F
    'G'        #  0xC7 -> LATIN CAPITAL LETTER G
    'H'        #  0xC8 -> LATIN CAPITAL LETTER H
    'I'        #  0xC9 -> LATIN CAPITAL LETTER I
    '\xad'     #  0xCA -> SOFT HYPHEN
    '\xf4'     #  0xCB -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '~'        #  0xCC -> TILDE
    '\xf2'     #  0xCD -> LATIN SMALL LETTER O WITH GRAVE
    '\xf3'     #  0xCE -> LATIN SMALL LETTER O WITH ACUTE
    '\xf5'     #  0xCF -> LATIN SMALL LETTER O WITH TILDE
    '\u011f'   #  0xD0 -> LATIN SMALL LETTER G WITH BREVE
    'J'        #  0xD1 -> LATIN CAPITAL LETTER J
    'K'        #  0xD2 -> LATIN CAPITAL LETTER K
    'L'        #  0xD3 -> LATIN CAPITAL LETTER L
    'M'        #  0xD4 -> LATIN CAPITAL LETTER M
    'N'        #  0xD5 -> LATIN CAPITAL LETTER N
    'O'        #  0xD6 -> LATIN CAPITAL LETTER O
    'P'        #  0xD7 -> LATIN CAPITAL LETTER P
    'Q'        #  0xD8 -> LATIN CAPITAL LETTER Q
    'R'        #  0xD9 -> LATIN CAPITAL LETTER R
    '\xb9'     #  0xDA -> SUPERSCRIPT ONE
    '\xfb'     #  0xDB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\\'       #  0xDC -> REVERSE SOLIDUS
    '\xf9'     #  0xDD -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'     #  0xDE -> LATIN SMALL LETTER U WITH ACUTE
    '\xff'     #  0xDF -> LATIN SMALL LETTER Y WITH DIAERESIS
    '\xfc'     #  0xE0 -> LATIN SMALL LETTER U WITH DIAERESIS
    '\xf7'     #  0xE1 -> DIVISION SIGN
    'S'        #  0xE2 -> LATIN CAPITAL LETTER S
    'T'        #  0xE3 -> LATIN CAPITAL LETTER T
    'U'        #  0xE4 -> LATIN CAPITAL LETTER U
    'V'        #  0xE5 -> LATIN CAPITAL LETTER V
    'W'        #  0xE6 -> LATIN CAPITAL LETTER W
    'X'        #  0xE7 -> LATIN CAPITAL LETTER X
    'Y'        #  0xE8 -> LATIN CAPITAL LETTER Y
    'Z'        #  0xE9 -> LATIN CAPITAL LETTER Z
    '\xb2'     #  0xEA -> SUPERSCRIPT TWO
    '\xd4'     #  0xEB -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '#'        #  0xEC -> NUMBER SIGN
    '\xd2'     #  0xED -> LATIN CAPITAL LETTER O WITH GRAVE
    '\xd3'     #  0xEE -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd5'     #  0xEF -> LATIN CAPITAL LETTER O WITH TILDE
    '0'        #  0xF0 -> DIGIT ZERO
    '1'        #  0xF1 -> DIGIT ONE
    '2'        #  0xF2 -> DIGIT TWO
    '3'        #  0xF3 -> DIGIT THREE
    '4'        #  0xF4 -> DIGIT FOUR
    '5'        #  0xF5 -> DIGIT FIVE
    '6'        #  0xF6 -> DIGIT SIX
    '7'        #  0xF7 -> DIGIT SEVEN
    '8'        #  0xF8 -> DIGIT EIGHT
    '9'        #  0xF9 -> DIGIT NINE
    '\xb3'     #  0xFA -> SUPERSCRIPT THREE
    '\xdb'     #  0xFB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    '"'        #  0xFC -> QUOTATION MARK
    '\xd9'     #  0xFD -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'     #  0xFE -> LATIN CAPITAL LETTER U WITH ACUTE
    '\x9f'     #  0xFF -> CONTROL
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """ Python Character Mapping Codec for CP1125

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_map)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_map)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1125',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )

### Decoding Map

decoding_map = codecs.make_identity_dict(range(256))
decoding_map.update({
    0x0080: 0x0410,     #  CYRILLIC CAPITAL LETTER A
    0x0081: 0x0411,     #  CYRILLIC CAPITAL LETTER BE
    0x0082: 0x0412,     #  CYRILLIC CAPITAL LETTER VE
    0x0083: 0x0413,     #  CYRILLIC CAPITAL LETTER GHE
    0x0084: 0x0414,     #  CYRILLIC CAPITAL LETTER DE
    0x0085: 0x0415,     #  CYRILLIC CAPITAL LETTER IE
    0x0086: 0x0416,     #  CYRILLIC CAPITAL LETTER ZHE
    0x0087: 0x0417,     #  CYRILLIC CAPITAL LETTER ZE
    0x0088: 0x0418,     #  CYRILLIC CAPITAL LETTER I
    0x0089: 0x0419,     #  CYRILLIC CAPITAL LETTER SHORT I
    0x008a: 0x041a,     #  CYRILLIC CAPITAL LETTER KA
    0x008b: 0x041b,     #  CYRILLIC CAPITAL LETTER EL
    0x008c: 0x041c,     #  CYRILLIC CAPITAL LETTER EM
    0x008d: 0x041d,     #  CYRILLIC CAPITAL LETTER EN
    0x008e: 0x041e,     #  CYRILLIC CAPITAL LETTER O
    0x008f: 0x041f,     #  CYRILLIC CAPITAL LETTER PE
    0x0090: 0x0420,     #  CYRILLIC CAPITAL LETTER ER
    0x0091: 0x0421,     #  CYRILLIC CAPITAL LETTER ES
    0x0092: 0x0422,     #  CYRILLIC CAPITAL LETTER TE
    0x0093: 0x0423,     #  CYRILLIC CAPITAL LETTER U
    0x0094: 0x0424,     #  CYRILLIC CAPITAL LETTER EF
    0x0095: 0x0425,     #  CYRILLIC CAPITAL LETTER HA
    0x0096: 0x0426,     #  CYRILLIC CAPITAL LETTER TSE
    0x0097: 0x0427,     #  CYRILLIC CAPITAL LETTER CHE
    0x0098: 0x0428,     #  CYRILLIC CAPITAL LETTER SHA
    0x0099: 0x0429,     #  CYRILLIC CAPITAL LETTER SHCHA
    0x009a: 0x042a,     #  CYRILLIC CAPITAL LETTER HARD SIGN
    0x009b: 0x042b,     #  CYRILLIC CAPITAL LETTER YERU
    0x009c: 0x042c,     #  CYRILLIC CAPITAL LETTER SOFT SIGN
    0x009d: 0x042d,     #  CYRILLIC CAPITAL LETTER E
    0x009e: 0x042e,     #  CYRILLIC CAPITAL LETTER YU
    0x009f: 0x042f,     #  CYRILLIC CAPITAL LETTER YA
    0x00a0: 0x0430,     #  CYRILLIC SMALL LETTER A
    0x00a1: 0x0431,     #  CYRILLIC SMALL LETTER BE
    0x00a2: 0x0432,     #  CYRILLIC SMALL LETTER VE
    0x00a3: 0x0433,     #  CYRILLIC SMALL LETTER GHE
    0x00a4: 0x0434,     #  CYRILLIC SMALL LETTER DE
    0x00a5: 0x0435,     #  CYRILLIC SMALL LETTER IE
    0x00a6: 0x0436,     #  CYRILLIC SMALL LETTER ZHE
    0x00a7: 0x0437,     #  CYRILLIC SMALL LETTER ZE
    0x00a8: 0x0438,     #  CYRILLIC SMALL LETTER I
    0x00a9: 0x0439,     #  CYRILLIC SMALL LETTER SHORT I
    0x00aa: 0x043a,     #  CYRILLIC SMALL LETTER KA
    0x00ab: 0x043b,     #  CYRILLIC SMALL LETTER EL
    0x00ac: 0x043c,     #  CYRILLIC SMALL LETTER EM
    0x00ad: 0x043d,     #  CYRILLIC SMALL LETTER EN
    0x00ae: 0x043e,     #  CYRILLIC SMALL LETTER O
    0x00af: 0x043f,     #  CYRILLIC SMALL LETTER PE
    0x00b0: 0x2591,     #  LIGHT SHADE
    0x00b1: 0x2592,     #  MEDIUM SHADE
    0x00b2: 0x2593,     #  DARK SHADE
    0x00b3: 0x2502,     #  BOX DRAWINGS LIGHT VERTICAL
    0x00b4: 0x2524,     #  BOX DRAWINGS LIGHT VERTICAL AND LEFT
    0x00b5: 0x2561,     #  BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
    0x00b6: 0x2562,     #  BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
    0x00b7: 0x2556,     #  BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
    0x00b8: 0x2555,     #  BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
    0x00b9: 0x2563,     #  BOX DRAWINGS DOUBLE VERTICAL AND LEFT
    0x00ba: 0x2551,     #  BOX DRAWINGS DOUBLE VERTICAL
    0x00bb: 0x2557,     #  BOX DRAWINGS DOUBLE DOWN AND LEFT
    0x00bc: 0x255d,     #  BOX DRAWINGS DOUBLE UP AND LEFT
    0x00bd: 0x255c,     #  BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
    0x00be: 0x255b,     #  BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
    0x00bf: 0x2510,     #  BOX DRAWINGS LIGHT DOWN AND LEFT
    0x00c0: 0x2514,     #  BOX DRAWINGS LIGHT UP AND RIGHT
    0x00c1: 0x2534,     #  BOX DRAWINGS LIGHT UP AND HORIZONTAL
    0x00c2: 0x252c,     #  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
    0x00c3: 0x251c,     #  BOX DRAWINGS LIGHT VERTICAL AND RIGHT
    0x00c4: 0x2500,     #  BOX DRAWINGS LIGHT HORIZONTAL
    0x00c5: 0x253c,     #  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
    0x00c6: 0x255e,     #  BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
    0x00c7: 0x255f,     #  BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
    0x00c8: 0x255a,     #  BOX DRAWINGS DOUBLE UP AND RIGHT
    0x00c9: 0x2554,     #  BOX DRAWINGS DOUBLE DOWN AND RIGHT
    0x00ca: 0x2569,     #  BOX DRAWINGS DOUBLE UP AND HORIZONTAL
    0x00cb: 0x2566,     #  BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
    0x00cc: 0x2560,     #  BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
    0x00cd: 0x2550,     #  BOX DRAWINGS DOUBLE HORIZONTAL
    0x00ce: 0x256c,     #  BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
    0x00cf: 0x2567,     #  BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
    0x00d0: 0x2568,     #  BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
    0x00d1: 0x2564,     #  BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
    0x00d2: 0x2565,     #  BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
    0x00d3: 0x2559,     #  BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
    0x00d4: 0x2558,     #  BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
    0x00d5: 0x2552,     #  BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
    0x00d6: 0x2553,     #  BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
    0x00d7: 0x256b,     #  BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
    0x00d8: 0x256a,     #  BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
    0x00d9: 0x2518,     #  BOX DRAWINGS LIGHT UP AND LEFT
    0x00da: 0x250c,     #  BOX DRAWINGS LIGHT DOWN AND RIGHT
    0x00db: 0x2588,     #  FULL BLOCK
    0x00dc: 0x2584,     #  LOWER HALF BLOCK
    0x00dd: 0x258c,     #  LEFT HALF BLOCK
    0x00de: 0x2590,     #  RIGHT HALF BLOCK
    0x00df: 0x2580,     #  UPPER HALF BLOCK
    0x00e0: 0x0440,     #  CYRILLIC SMALL LETTER ER
    0x00e1: 0x0441,     #  CYRILLIC SMALL LETTER ES
    0x00e2: 0x0442,     #  CYRILLIC SMALL LETTER TE
    0x00e3: 0x0443,     #  CYRILLIC SMALL LETTER U
    0x00e4: 0x0444,     #  CYRILLIC SMALL LETTER EF
    0x00e5: 0x0445,     #  CYRILLIC SMALL LETTER HA
    0x00e6: 0x0446,     #  CYRILLIC SMALL LETTER TSE
    0x00e7: 0x0447,     #  CYRILLIC SMALL LETTER CHE
    0x00e8: 0x0448,     #  CYRILLIC SMALL LETTER SHA
    0x00e9: 0x0449,     #  CYRILLIC SMALL LETTER SHCHA
    0x00ea: 0x044a,     #  CYRILLIC SMALL LETTER HARD SIGN
    0x00eb: 0x044b,     #  CYRILLIC SMALL LETTER YERU
    0x00ec: 0x044c,     #  CYRILLIC SMALL LETTER SOFT SIGN
    0x00ed: 0x044d,     #  CYRILLIC SMALL LETTER E
    0x00ee: 0x044e,     #  CYRILLIC SMALL LETTER YU
    0x00ef: 0x044f,     #  CYRILLIC SMALL LETTER YA
    0x00f0: 0x0401,     #  CYRILLIC CAPITAL LETTER IO
    0x00f1: 0x0451,     #  CYRILLIC SMALL LETTER IO
    0x00f2: 0x0490,     #  CYRILLIC CAPITAL LETTER GHE WITH UPTURN
    0x00f3: 0x0491,     #  CYRILLIC SMALL LETTER GHE WITH UPTURN
    0x00f4: 0x0404,     #  CYRILLIC CAPITAL LETTER UKRAINIAN IE
    0x00f5: 0x0454,     #  CYRILLIC SMALL LETTER UKRAINIAN IE
    0x00f6: 0x0406,     #  CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
    0x00f7: 0x0456,     #  CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
    0x00f8: 0x0407,     #  CYRILLIC CAPITAL LETTER YI
    0x00f9: 0x0457,     #  CYRILLIC SMALL LETTER YI
    0x00fa: 0x00b7,     #  MIDDLE DOT
    0x00fb: 0x221a,     #  SQUARE ROOT
    0x00fc: 0x2116,     #  NUMERO SIGN
    0x00fd: 0x00a4,     #  CURRENCY SIGN
    0x00fe: 0x25a0,     #  BLACK SQUARE
    0x00ff: 0x00a0,     #  NO-BREAK SPACE
})

### Decoding Table

decoding_table = (
    '\x00'     #  0x0000 -> NULL
    '\x01'     #  0x0001 -> START OF HEADING
    '\x02'     #  0x0002 -> START OF TEXT
    '\x03'     #  0x0003 -> END OF TEXT
    '\x04'     #  0x0004 -> END OF TRANSMISSION
    '\x05'     #  0x0005 -> ENQUIRY
    '\x06'     #  0x0006 -> ACKNOWLEDGE
    '\x07'     #  0x0007 -> BELL
    '\x08'     #  0x0008 -> BACKSPACE
    '\t'       #  0x0009 -> HORIZONTAL TABULATION
    '\n'       #  0x000a -> LINE FEED
    '\x0b'     #  0x000b -> VERTICAL TABULATION
    '\x0c'     #  0x000c -> FORM FEED
    '\r'       #  0x000d -> CARRIAGE RETURN
    '\x0e'     #  0x000e -> SHIFT OUT
    '\x0f'     #  0x000f -> SHIFT IN
    '\x10'     #  0x0010 -> DATA LINK ESCAPE
    '\x11'     #  0x0011 -> DEVICE CONTROL ONE
    '\x12'     #  0x0012 -> DEVICE CONTROL TWO
    '\x13'     #  0x0013 -> DEVICE CONTROL THREE
    '\x14'     #  0x0014 -> DEVICE CONTROL FOUR
    '\x15'     #  0x0015 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x0016 -> SYNCHRONOUS IDLE
    '\x17'     #  0x0017 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x0018 -> CANCEL
    '\x19'     #  0x0019 -> END OF MEDIUM
    '\x1a'     #  0x001a -> SUBSTITUTE
    '\x1b'     #  0x001b -> ESCAPE
    '\x1c'     #  0x001c -> FILE SEPARATOR
    '\x1d'     #  0x001d -> GROUP SEPARATOR
    '\x1e'     #  0x001e -> RECORD SEPARATOR
    '\x1f'     #  0x001f -> UNIT SEPARATOR
    ' '        #  0x0020 -> SPACE
    '!'        #  0x0021 -> EXCLAMATION MARK
    '"'        #  0x0022 -> QUOTATION MARK
    '#'        #  0x0023 -> NUMBER SIGN
    '$'        #  0x0024 -> DOLLAR SIGN
    '%'        #  0x0025 -> PERCENT SIGN
    '&'        #  0x0026 -> AMPERSAND
    "'"        #  0x0027 -> APOSTROPHE
    '('        #  0x0028 -> LEFT PARENTHESIS
    ')'        #  0x0029 -> RIGHT PARENTHESIS
    '*'        #  0x002a -> ASTERISK
    '+'        #  0x002b -> PLUS SIGN
    ','        #  0x002c -> COMMA
    '-'        #  0x002d -> HYPHEN-MINUS
    '.'        #  0x002e -> FULL STOP
    '/'        #  0x002f -> SOLIDUS
    '0'        #  0x0030 -> DIGIT ZERO
    '1'        #  0x0031 -> DIGIT ONE
    '2'        #  0x0032 -> DIGIT TWO
    '3'        #  0x0033 -> DIGIT THREE
    '4'        #  0x0034 -> DIGIT FOUR
    '5'        #  0x0035 -> DIGIT FIVE
    '6'        #  0x0036 -> DIGIT SIX
    '7'        #  0x0037 -> DIGIT SEVEN
    '8'        #  0x0038 -> DIGIT EIGHT
    '9'        #  0x0039 -> DIGIT NINE
    ':'        #  0x003a -> COLON
    ';'        #  0x003b -> SEMICOLON
    '<'        #  0x003c -> LESS-THAN SIGN
    '='        #  0x003d -> EQUALS SIGN
    '>'        #  0x003e -> GREATER-THAN SIGN
    '?'        #  0x003f -> QUESTION MARK
    '@'        #  0x0040 -> COMMERCIAL AT
    'A'        #  0x0041 -> LATIN CAPITAL LETTER A
    'B'        #  0x0042 -> LATIN CAPITAL LETTER B
    'C'        #  0x0043 -> LATIN CAPITAL LETTER C
    'D'        #  0x0044 -> LATIN CAPITAL LETTER D
    'E'        #  0x0045 -> LATIN CAPITAL LETTER E
    'F'        #  0x0046 -> LATIN CAPITAL LETTER F
    'G'        #  0x0047 -> LATIN CAPITAL LETTER G
    'H'        #  0x0048 -> LATIN CAPITAL LETTER H
    'I'        #  0x0049 -> LATIN CAPITAL LETTER I
    'J'        #  0x004a -> LATIN CAPITAL LETTER J
    'K'        #  0x004b -> LATIN CAPITAL LETTER K
    'L'        #  0x004c -> LATIN CAPITAL LETTER L
    'M'        #  0x004d -> LATIN CAPITAL LETTER M
    'N'        #  0x004e -> LATIN CAPITAL LETTER N
    'O'        #  0x004f -> LATIN CAPITAL LETTER O
    'P'        #  0x0050 -> LATIN CAPITAL LETTER P
    'Q'        #  0x0051 -> LATIN CAPITAL LETTER Q
    'R'        #  0x0052 -> LATIN CAPITAL LETTER R
    'S'        #  0x0053 -> LATIN CAPITAL LETTER S
    'T'        #  0x0054 -> LATIN CAPITAL LETTER T
    'U'        #  0x0055 -> LATIN CAPITAL LETTER U
    'V'        #  0x0056 -> LATIN CAPITAL LETTER V
    'W'        #  0x0057 -> LATIN CAPITAL LETTER W
    'X'        #  0x0058 -> LATIN CAPITAL LETTER X
    'Y'        #  0x0059 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x005a -> LATIN CAPITAL LETTER Z
    '['        #  0x005b -> LEFT SQUARE BRACKET
    '\\'       #  0x005c -> REVERSE SOLIDUS
    ']'        #  0x005d -> RIGHT SQUARE BRACKET
    '^'        #  0x005e -> CIRCUMFLEX ACCENT
    '_'        #  0x005f -> LOW LINE
    '`'        #  0x0060 -> GRAVE ACCENT
    'a'        #  0x0061 -> LATIN SMALL LETTER A
    'b'        #  0x0062 -> LATIN SMALL LETTER B
    'c'        #  0x0063 -> LATIN SMALL LETTER C
    'd'        #  0x0064 -> LATIN SMALL LETTER D
    'e'        #  0x0065 -> LATIN SMALL LETTER E
    'f'        #  0x0066 -> LATIN SMALL LETTER F
    'g'        #  0x0067 -> LATIN SMALL LETTER G
    'h'        #  0x0068 -> LATIN SMALL LETTER H
    'i'        #  0x0069 -> LATIN SMALL LETTER I
    'j'        #  0x006a -> LATIN SMALL LETTER J
    'k'        #  0x006b -> LATIN SMALL LETTER K
    'l'        #  0x006c -> LATIN SMALL LETTER L
    'm'        #  0x006d -> LATIN SMALL LETTER M
    'n'        #  0x006e -> LATIN SMALL LETTER N
    'o'        #  0x006f -> LATIN SMALL LETTER O
    'p'        #  0x0070 -> LATIN SMALL LETTER P
    'q'        #  0x0071 -> LATIN SMALL LETTER Q
    'r'        #  0x0072 -> LATIN SMALL LETTER R
    's'        #  0x0073 -> LATIN SMALL LETTER S
    't'        #  0x0074 -> LATIN SMALL LETTER T
    'u'        #  0x0075 -> LATIN SMALL LETTER U
    'v'        #  0x0076 -> LATIN SMALL LETTER V
    'w'        #  0x0077 -> LATIN SMALL LETTER W
    'x'        #  0x0078 -> LATIN SMALL LETTER X
    'y'        #  0x0079 -> LATIN SMALL LETTER Y
    'z'        #  0x007a -> LATIN SMALL LETTER Z
    '{'        #  0x007b -> LEFT CURLY BRACKET
    '|'        #  0x007c -> VERTICAL LINE
    '}'        #  0x007d -> RIGHT CURLY BRACKET
    '~'        #  0x007e -> TILDE
    '\x7f'     #  0x007f -> DELETE
    '\u0410'   #  0x0080 -> CYRILLIC CAPITAL LETTER A
    '\u0411'   #  0x0081 -> CYRILLIC CAPITAL LETTER BE
    '\u0412'   #  0x0082 -> CYRILLIC CAPITAL LETTER VE
    '\u0413'   #  0x0083 -> CYRILLIC CAPITAL LETTER GHE
    '\u0414'   #  0x0084 -> CYRILLIC CAPITAL LETTER DE
    '\u0415'   #  0x0085 -> CYRILLIC CAPITAL LETTER IE
    '\u0416'   #  0x0086 -> CYRILLIC CAPITAL LETTER ZHE
    '\u0417'   #  0x0087 -> CYRILLIC CAPITAL LETTER ZE
    '\u0418'   #  0x0088 -> CYRILLIC CAPITAL LETTER I
    '\u0419'   #  0x0089 -> CYRILLIC CAPITAL LETTER SHORT I
    '\u041a'   #  0x008a -> CYRILLIC CAPITAL LETTER KA
    '\u041b'   #  0x008b -> CYRILLIC CAPITAL LETTER EL
    '\u041c'   #  0x008c -> CYRILLIC CAPITAL LETTER EM
    '\u041d'   #  0x008d -> CYRILLIC CAPITAL LETTER EN
    '\u041e'   #  0x008e -> CYRILLIC CAPITAL LETTER O
    '\u041f'   #  0x008f -> CYRILLIC CAPITAL LETTER PE
    '\u0420'   #  0x0090 -> CYRILLIC CAPITAL LETTER ER
    '\u0421'   #  0x0091 -> CYRILLIC CAPITAL LETTER ES
    '\u0422'   #  0x0092 -> CYRILLIC CAPITAL LETTER TE
    '\u0423'   #  0x0093 -> CYRILLIC CAPITAL LETTER U
    '\u0424'   #  0x0094 -> CYRILLIC CAPITAL LETTER EF
    '\u0425'   #  0x0095 -> CYRILLIC CAPITAL LETTER HA
    '\u0426'   #  0x0096 -> CYRILLIC CAPITAL LETTER TSE
    '\u0427'   #  0x0097 -> CYRILLIC CAPITAL LETTER CHE
    '\u0428'   #  0x0098 -> CYRILLIC CAPITAL LETTER SHA
    '\u0429'   #  0x0099 -> CYRILLIC CAPITAL LETTER SHCHA
    '\u042a'   #  0x009a -> CYRILLIC CAPITAL LETTER HARD SIGN
    '\u042b'   #  0x009b -> CYRILLIC CAPITAL LETTER YERU
    '\u042c'   #  0x009c -> CYRILLIC CAPITAL LETTER SOFT SIGN
    '\u042d'   #  0x009d -> CYRILLIC CAPITAL LETTER E
    '\u042e'   #  0x009e -> CYRILLIC CAPITAL LETTER YU
    '\u042f'   #  0x009f -> CYRILLIC CAPITAL LETTER YA
    '\u0430'   #  0x00a0 -> CYRILLIC SMALL LETTER A
    '\u0431'   #  0x00a1 -> CYRILLIC SMALL LETTER BE
    '\u0432'   #  0x00a2 -> CYRILLIC SMALL LETTER VE
    '\u0433'   #  0x00a3 -> CYRILLIC SMALL LETTER GHE
    '\u0434'   #  0x00a4 -> CYRILLIC SMALL LETTER DE
    '\u0435'   #  0x00a5 -> CYRILLIC SMALL LETTER IE
    '\u0436'   #  0x00a6 -> CYRILLIC SMALL LETTER ZHE
    '\u0437'   #  0x00a7 -> CYRILLIC SMALL LETTER ZE
    '\u0438'   #  0x00a8 -> CYRILLIC SMALL LETTER I
    '\u0439'   #  0x00a9 -> CYRILLIC SMALL LETTER SHORT I
    '\u043a'   #  0x00aa -> CYRILLIC SMALL LETTER KA
    '\u043b'   #  0x00ab -> CYRILLIC SMALL LETTER EL
    '\u043c'   #  0x00ac -> CYRILLIC SMALL LETTER EM
    '\u043d'   #  0x00ad -> CYRILLIC SMALL LETTER EN
    '\u043e'   #  0x00ae -> CYRILLIC SMALL LETTER O
    '\u043f'   #  0x00af -> CYRILLIC SMALL LETTER PE
    '\u2591'   #  0x00b0 -> LIGHT SHADE
    '\u2592'   #  0x00b1 -> MEDIUM SHADE
    '\u2593'   #  0x00b2 -> DARK SHADE
    '\u2502'   #  0x00b3 -> BOX DRAWINGS LIGHT VERTICAL
    '\u2524'   #  0x00b4 -> BOX DRAWINGS LIGHT VERTICAL AND LEFT
    '\u2561'   #  0x00b5 -> BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
    '\u2562'   #  0x00b6 -> BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
    '\u2556'   #  0x00b7 -> BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
    '\u2555'   #  0x00b8 -> BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
    '\u2563'   #  0x00b9 -> BOX DRAWINGS DOUBLE VERTICAL AND LEFT
    '\u2551'   #  0x00ba -> BOX DRAWINGS DOUBLE VERTICAL
    '\u2557'   #  0x00bb -> BOX DRAWINGS DOUBLE DOWN AND LEFT
    '\u255d'   #  0x00bc -> BOX DRAWINGS DOUBLE UP AND LEFT
    '\u255c'   #  0x00bd -> BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
    '\u255b'   #  0x00be -> BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
    '\u2510'   #  0x00bf -> BOX DRAWINGS LIGHT DOWN AND LEFT
    '\u2514'   #  0x00c0 -> BOX DRAWINGS LIGHT UP AND RIGHT
    '\u2534'   #  0x00c1 -> BOX DRAWINGS LIGHT UP AND HORIZONTAL
    '\u252c'   #  0x00c2 -> BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
    '\u251c'   #  0x00c3 -> BOX DRAWINGS LIGHT VERTICAL AND RIGHT
    '\u2500'   #  0x00c4 -> BOX DRAWINGS LIGHT HORIZONTAL
    '\u253c'   #  0x00c5 -> BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
    '\u255e'   #  0x00c6 -> BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
    '\u255f'   #  0x00c7 -> BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
    '\u255a'   #  0x00c8 -> BOX DRAWINGS DOUBLE UP AND RIGHT
    '\u2554'   #  0x00c9 -> BOX DRAWINGS DOUBLE DOWN AND RIGHT
    '\u2569'   #  0x00ca -> BOX DRAWINGS DOUBLE UP AND HORIZONTAL
    '\u2566'   #  0x00cb -> BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
    '\u2560'   #  0x00cc -> BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
    '\u2550'   #  0x00cd -> BOX DRAWINGS DOUBLE HORIZONTAL
    '\u256c'   #  0x00ce -> BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
    '\u2567'   #  0x00cf -> BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
    '\u2568'   #  0x00d0 -> BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
    '\u2564'   #  0x00d1 -> BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
    '\u2565'   #  0x00d2 -> BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
    '\u2559'   #  0x00d3 -> BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
    '\u2558'   #  0x00d4 -> BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
    '\u2552'   #  0x00d5 -> BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
    '\u2553'   #  0x00d6 -> BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
    '\u256b'   #  0x00d7 -> BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
    '\u256a'   #  0x00d8 -> BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
    '\u2518'   #  0x00d9 -> BOX DRAWINGS LIGHT UP AND LEFT
    '\u250c'   #  0x00da -> BOX DRAWINGS LIGHT DOWN AND RIGHT
    '\u2588'   #  0x00db -> FULL BLOCK
    '\u2584'   #  0x00dc -> LOWER HALF BLOCK
    '\u258c'   #  0x00dd -> LEFT HALF BLOCK
    '\u2590'   #  0x00de -> RIGHT HALF BLOCK
    '\u2580'   #  0x00df -> UPPER HALF BLOCK
    '\u0440'   #  0x00e0 -> CYRILLIC SMALL LETTER ER
    '\u0441'   #  0x00e1 -> CYRILLIC SMALL LETTER ES
    '\u0442'   #  0x00e2 -> CYRILLIC SMALL LETTER TE
    '\u0443'   #  0x00e3 -> CYRILLIC SMALL LETTER U
    '\u0444'   #  0x00e4 -> CYRILLIC SMALL LETTER EF
    '\u0445'   #  0x00e5 -> CYRILLIC SMALL LETTER HA
    '\u0446'   #  0x00e6 -> CYRILLIC SMALL LETTER TSE
    '\u0447'   #  0x00e7 -> CYRILLIC SMALL LETTER CHE
    '\u0448'   #  0x00e8 -> CYRILLIC SMALL LETTER SHA
    '\u0449'   #  0x00e9 -> CYRILLIC SMALL LETTER SHCHA
    '\u044a'   #  0x00ea -> CYRILLIC SMALL LETTER HARD SIGN
    '\u044b'   #  0x00eb -> CYRILLIC SMALL LETTER YERU
    '\u044c'   #  0x00ec -> CYRILLIC SMALL LETTER SOFT SIGN
    '\u044d'   #  0x00ed -> CYRILLIC SMALL LETTER E
    '\u044e'   #  0x00ee -> CYRILLIC SMALL LETTER YU
    '\u044f'   #  0x00ef -> CYRILLIC SMALL LETTER YA
    '\u0401'   #  0x00f0 -> CYRILLIC CAPITAL LETTER IO
    '\u0451'   #  0x00f1 -> CYRILLIC SMALL LETTER IO
    '\u0490'   #  0x00f2 -> CYRILLIC CAPITAL LETTER GHE WITH UPTURN
    '\u0491'   #  0x00f3 -> CYRILLIC SMALL LETTER GHE WITH UPTURN
    '\u0404'   #  0x00f4 -> CYRILLIC CAPITAL LETTER UKRAINIAN IE
    '\u0454'   #  0x00f5 -> CYRILLIC SMALL LETTER UKRAINIAN IE
    '\u0406'   #  0x00f6 -> CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
    '\u0456'   #  0x00f7 -> CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
    '\u0407'   #  0x00f8 -> CYRILLIC CAPITAL LETTER YI
    '\u0457'   #  0x00f9 -> CYRILLIC SMALL LETTER YI
    '\xb7'     #  0x00fa -> MIDDLE DOT
    '\u221a'   #  0x00fb -> SQUARE ROOT
    '\u2116'   #  0x00fc -> NUMERO SIGN
    '\xa4'     #  0x00fd -> CURRENCY SIGN
    '\u25a0'   #  0x00fe -> BLACK SQUARE
    '\xa0'     #  0x00ff -> NO-BREAK SPACE
)

### Encoding Map

encoding_map = {
    0x0000: 0x0000,     #  NULL
    0x0001: 0x0001,     #  START OF HEADING
    0x0002: 0x0002,     #  START OF TEXT
    0x0003: 0x0003,     #  END OF TEXT
    0x0004: 0x0004,     #  END OF TRANSMISSION
    0x0005: 0x0005,     #  ENQUIRY
    0x0006: 0x0006,     #  ACKNOWLEDGE
    0x0007: 0x0007,     #  BELL
    0x0008: 0x0008,     #  BACKSPACE
    0x0009: 0x0009,     #  HORIZONTAL TABULATION
    0x000a: 0x000a,     #  LINE FEED
    0x000b: 0x000b,     #  VERTICAL TABULATION
    0x000c: 0x000c,     #  FORM FEED
    0x000d: 0x000d,     #  CARRIAGE RETURN
    0x000e: 0x000e,     #  SHIFT OUT
    0x000f: 0x000f,     #  SHIFT IN
    0x0010: 0x0010,     #  DATA LINK ESCAPE
    0x0011: 0x0011,     #  DEVICE CONTROL ONE
    0x0012: 0x0012,     #  DEVICE CONTROL TWO
    0x0013: 0x0013,     #  DEVICE CONTROL THREE
    0x0014: 0x0014,     #  DEVICE CONTROL FOUR
    0x0015: 0x0015,     #  NEGATIVE ACKNOWLEDGE
    0x0016: 0x0016,     #  SYNCHRONOUS IDLE
    0x0017: 0x0017,     #  END OF TRANSMISSION BLOCK
    0x0018: 0x0018,     #  CANCEL
    0x0019: 0x0019,     #  END OF MEDIUM
    0x001a: 0x001a,     #  SUBSTITUTE
    0x001b: 0x001b,     #  ESCAPE
    0x001c: 0x001c,     #  FILE SEPARATOR
    0x001d: 0x001d,     #  GROUP SEPARATOR
    0x001e: 0x001e,     #  RECORD SEPARATOR
    0x001f: 0x001f,     #  UNIT SEPARATOR
    0x0020: 0x0020,     #  SPACE
    0x0021: 0x0021,     #  EXCLAMATION MARK
    0x0022: 0x0022,     #  QUOTATION MARK
    0x0023: 0x0023,     #  NUMBER SIGN
    0x0024: 0x0024,     #  DOLLAR SIGN
    0x0025: 0x0025,     #  PERCENT SIGN
    0x0026: 0x0026,     #  AMPERSAND
    0x0027: 0x0027,     #  APOSTROPHE
    0x0028: 0x0028,     #  LEFT PARENTHESIS
    0x0029: 0x0029,     #  RIGHT PARENTHESIS
    0x002a: 0x002a,     #  ASTERISK
    0x002b: 0x002b,     #  PLUS SIGN
    0x002c: 0x002c,     #  COMMA
    0x002d: 0x002d,     #  HYPHEN-MINUS
    0x002e: 0x002e,     #  FULL STOP
    0x002f: 0x002f,     #  SOLIDUS
    0x0030: 0x0030,     #  DIGIT ZERO
    0x0031: 0x0031,     #  DIGIT ONE
    0x0032: 0x0032,     #  DIGIT TWO
    0x0033: 0x0033,     #  DIGIT THREE
    0x0034: 0x0034,     #  DIGIT FOUR
    0x0035: 0x0035,     #  DIGIT FIVE
    0x0036: 0x0036,     #  DIGIT SIX
    0x0037: 0x0037,     #  DIGIT SEVEN
    0x0038: 0x0038,     #  DIGIT EIGHT
    0x0039: 0x0039,     #  DIGIT NINE
    0x003a: 0x003a,     #  COLON
    0x003b: 0x003b,     #  SEMICOLON
    0x003c: 0x003c,     #  LESS-THAN SIGN
    0x003d: 0x003d,     #  EQUALS SIGN
    0x003e: 0x003e,     #  GREATER-THAN SIGN
    0x003f: 0x003f,     #  QUESTION MARK
    0x0040: 0x0040,     #  COMMERCIAL AT
    0x0041: 0x0041,     #  LATIN CAPITAL LETTER A
    0x0042: 0x0042,     #  LATIN CAPITAL LETTER B
    0x0043: 0x0043,     #  LATIN CAPITAL LETTER C
    0x0044: 0x0044,     #  LATIN CAPITAL LETTER D
    0x0045: 0x0045,     #  LATIN CAPITAL LETTER E
    0x0046: 0x0046,     #  LATIN CAPITAL LETTER F
    0x0047: 0x0047,     #  LATIN CAPITAL LETTER G
    0x0048: 0x0048,     #  LATIN CAPITAL LETTER H
    0x0049: 0x0049,     #  LATIN CAPITAL LETTER I
    0x004a: 0x004a,     #  LATIN CAPITAL LETTER J
    0x004b: 0x004b,     #  LATIN CAPITAL LETTER K
    0x004c: 0x004c,     #  LATIN CAPITAL LETTER L
    0x004d: 0x004d,     #  LATIN CAPITAL LETTER M
    0x004e: 0x004e,     #  LATIN CAPITAL LETTER N
    0x004f: 0x004f,     #  LATIN CAPITAL LETTER O
    0x0050: 0x0050,     #  LATIN CAPITAL LETTER P
    0x0051: 0x0051,     #  LATIN CAPITAL LETTER Q
    0x0052: 0x0052,     #  LATIN CAPITAL LETTER R
    0x0053: 0x0053,     #  LATIN CAPITAL LETTER S
    0x0054: 0x0054,     #  LATIN CAPITAL LETTER T
    0x0055: 0x0055,     #  LATIN CAPITAL LETTER U
    0x0056: 0x0056,     #  LATIN CAPITAL LETTER V
    0x0057: 0x0057,     #  LATIN CAPITAL LETTER W
    0x0058: 0x0058,     #  LATIN CAPITAL LETTER X
    0x0059: 0x0059,     #  LATIN CAPITAL LETTER Y
    0x005a: 0x005a,     #  LATIN CAPITAL LETTER Z
    0x005b: 0x005b,     #  LEFT SQUARE BRACKET
    0x005c: 0x005c,     #  REVERSE SOLIDUS
    0x005d: 0x005d,     #  RIGHT SQUARE BRACKET
    0x005e: 0x005e,     #  CIRCUMFLEX ACCENT
    0x005f: 0x005f,     #  LOW LINE
    0x0060: 0x0060,     #  GRAVE ACCENT
    0x0061: 0x0061,     #  LATIN SMALL LETTER A
    0x0062: 0x0062,     #  LATIN SMALL LETTER B
    0x0063: 0x0063,     #  LATIN SMALL LETTER C
    0x0064: 0x0064,     #  LATIN SMALL LETTER D
    0x0065: 0x0065,     #  LATIN SMALL LETTER E
    0x0066: 0x0066,     #  LATIN SMALL LETTER F
    0x0067: 0x0067,     #  LATIN SMALL LETTER G
    0x0068: 0x0068,     #  LATIN SMALL LETTER H
    0x0069: 0x0069,     #  LATIN SMALL LETTER I
    0x006a: 0x006a,     #  LATIN SMALL LETTER J
    0x006b: 0x006b,     #  LATIN SMALL LETTER K
    0x006c: 0x006c,     #  LATIN SMALL LETTER L
    0x006d: 0x006d,     #  LATIN SMALL LETTER M
    0x006e: 0x006e,     #  LATIN SMALL LETTER N
    0x006f: 0x006f,     #  LATIN SMALL LETTER O
    0x0070: 0x0070,     #  LATIN SMALL LETTER P
    0x0071: 0x0071,     #  LATIN SMALL LETTER Q
    0x0072: 0x0072,     #  LATIN SMALL LETTER R
    0x0073: 0x0073,     #  LATIN SMALL LETTER S
    0x0074: 0x0074,     #  LATIN SMALL LETTER T
    0x0075: 0x0075,     #  LATIN SMALL LETTER U
    0x0076: 0x0076,     #  LATIN SMALL LETTER V
    0x0077: 0x0077,     #  LATIN SMALL LETTER W
    0x0078: 0x0078,     #  LATIN SMALL LETTER X
    0x0079: 0x0079,     #  LATIN SMALL LETTER Y
    0x007a: 0x007a,     #  LATIN SMALL LETTER Z
    0x007b: 0x007b,     #  LEFT CURLY BRACKET
    0x007c: 0x007c,     #  VERTICAL LINE
    0x007d: 0x007d,     #  RIGHT CURLY BRACKET
    0x007e: 0x007e,     #  TILDE
    0x007f: 0x007f,     #  DELETE
    0x00a0: 0x00ff,     #  NO-BREAK SPACE
    0x00a4: 0x00fd,     #  CURRENCY SIGN
    0x00b7: 0x00fa,     #  MIDDLE DOT
    0x0401: 0x00f0,     #  CYRILLIC CAPITAL LETTER IO
    0x0404: 0x00f4,     #  CYRILLIC CAPITAL LETTER UKRAINIAN IE
    0x0406: 0x00f6,     #  CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
    0x0407: 0x00f8,     #  CYRILLIC CAPITAL LETTER YI
    0x0410: 0x0080,     #  CYRILLIC CAPITAL LETTER A
    0x0411: 0x0081,     #  CYRILLIC CAPITAL LETTER BE
    0x0412: 0x0082,     #  CYRILLIC CAPITAL LETTER VE
    0x0413: 0x0083,     #  CYRILLIC CAPITAL LETTER GHE
    0x0414: 0x0084,     #  CYRILLIC CAPITAL LETTER DE
    0x0415: 0x0085,     #  CYRILLIC CAPITAL LETTER IE
    0x0416: 0x0086,     #  CYRILLIC CAPITAL LETTER ZHE
    0x0417: 0x0087,     #  CYRILLIC CAPITAL LETTER ZE
    0x0418: 0x0088,     #  CYRILLIC CAPITAL LETTER I
    0x0419: 0x0089,     #  CYRILLIC CAPITAL LETTER SHORT I
    0x041a: 0x008a,     #  CYRILLIC CAPITAL LETTER KA
    0x041b: 0x008b,     #  CYRILLIC CAPITAL LETTER EL
    0x041c: 0x008c,     #  CYRILLIC CAPITAL LETTER EM
    0x041d: 0x008d,     #  CYRILLIC CAPITAL LETTER EN
    0x041e: 0x008e,     #  CYRILLIC CAPITAL LETTER O
    0x041f: 0x008f,     #  CYRILLIC CAPITAL LETTER PE
    0x0420: 0x0090,     #  CYRILLIC CAPITAL LETTER ER
    0x0421: 0x0091,     #  CYRILLIC CAPITAL LETTER ES
    0x0422: 0x0092,     #  CYRILLIC CAPITAL LETTER TE
    0x0423: 0x0093,     #  CYRILLIC CAPITAL LETTER U
    0x0424: 0x0094,     #  CYRILLIC CAPITAL LETTER EF
    0x0425: 0x0095,     #  CYRILLIC CAPITAL LETTER HA
    0x0426: 0x0096,     #  CYRILLIC CAPITAL LETTER TSE
    0x0427: 0x0097,     #  CYRILLIC CAPITAL LETTER CHE
    0x0428: 0x0098,     #  CYRILLIC CAPITAL LETTER SHA
    0x0429: 0x0099,     #  CYRILLIC CAPITAL LETTER SHCHA
    0x042a: 0x009a,     #  CYRILLIC CAPITAL LETTER HARD SIGN
    0x042b: 0x009b,     #  CYRILLIC CAPITAL LETTER YERU
    0x042c: 0x009c,     #  CYRILLIC CAPITAL LETTER SOFT SIGN
    0x042d: 0x009d,     #  CYRILLIC CAPITAL LETTER E
    0x042e: 0x009e,     #  CYRILLIC CAPITAL LETTER YU
    0x042f: 0x009f,     #  CYRILLIC CAPITAL LETTER YA
    0x0430: 0x00a0,     #  CYRILLIC SMALL LETTER A
    0x0431: 0x00a1,     #  CYRILLIC SMALL LETTER BE
    0x0432: 0x00a2,     #  CYRILLIC SMALL LETTER VE
    0x0433: 0x00a3,     #  CYRILLIC SMALL LETTER GHE
    0x0434: 0x00a4,     #  CYRILLIC SMALL LETTER DE
    0x0435: 0x00a5,     #  CYRILLIC SMALL LETTER IE
    0x0436: 0x00a6,     #  CYRILLIC SMALL LETTER ZHE
    0x0437: 0x00a7,     #  CYRILLIC SMALL LETTER ZE
    0x0438: 0x00a8,     #  CYRILLIC SMALL LETTER I
    0x0439: 0x00a9,     #  CYRILLIC SMALL LETTER SHORT I
    0x043a: 0x00aa,     #  CYRILLIC SMALL LETTER KA
    0x043b: 0x00ab,     #  CYRILLIC SMALL LETTER EL
    0x043c: 0x00ac,     #  CYRILLIC SMALL LETTER EM
    0x043d: 0x00ad,     #  CYRILLIC SMALL LETTER EN
    0x043e: 0x00ae,     #  CYRILLIC SMALL LETTER O
    0x043f: 0x00af,     #  CYRILLIC SMALL LETTER PE
    0x0440: 0x00e0,     #  CYRILLIC SMALL LETTER ER
    0x0441: 0x00e1,     #  CYRILLIC SMALL LETTER ES
    0x0442: 0x00e2,     #  CYRILLIC SMALL LETTER TE
    0x0443: 0x00e3,     #  CYRILLIC SMALL LETTER U
    0x0444: 0x00e4,     #  CYRILLIC SMALL LETTER EF
    0x0445: 0x00e5,     #  CYRILLIC SMALL LETTER HA
    0x0446: 0x00e6,     #  CYRILLIC SMALL LETTER TSE
    0x0447: 0x00e7,     #  CYRILLIC SMALL LETTER CHE
    0x0448: 0x00e8,     #  CYRILLIC SMALL LETTER SHA
    0x0449: 0x00e9,     #  CYRILLIC SMALL LETTER SHCHA
    0x044a: 0x00ea,     #  CYRILLIC SMALL LETTER HARD SIGN
    0x044b: 0x00eb,     #  CYRILLIC SMALL LETTER YERU
    0x044c: 0x00ec,     #  CYRILLIC SMALL LETTER SOFT SIGN
    0x044d: 0x00ed,     #  CYRILLIC SMALL LETTER E
    0x044e: 0x00ee,     #  CYRILLIC SMALL LETTER YU
    0x044f: 0x00ef,     #  CYRILLIC SMALL LETTER YA
    0x0451: 0x00f1,     #  CYRILLIC SMALL LETTER IO
    0x0454: 0x00f5,     #  CYRILLIC SMALL LETTER UKRAINIAN IE
    0x0456: 0x00f7,     #  CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
    0x0457: 0x00f9,     #  CYRILLIC SMALL LETTER YI
    0x0490: 0x00f2,     #  CYRILLIC CAPITAL LETTER GHE WITH UPTURN
    0x0491: 0x00f3,     #  CYRILLIC SMALL LETTER GHE WITH UPTURN
    0x2116: 0x00fc,     #  NUMERO SIGN
    0x221a: 0x00fb,     #  SQUARE ROOT
    0x2500: 0x00c4,     #  BOX DRAWINGS LIGHT HORIZONTAL
    0x2502: 0x00b3,     #  BOX DRAWINGS LIGHT VERTICAL
    0x250c: 0x00da,     #  BOX DRAWINGS LIGHT DOWN AND RIGHT
    0x2510: 0x00bf,     #  BOX DRAWINGS LIGHT DOWN AND LEFT
    0x2514: 0x00c0,     #  BOX DRAWINGS LIGHT UP AND RIGHT
    0x2518: 0x00d9,     #  BOX DRAWINGS LIGHT UP AND LEFT
    0x251c: 0x00c3,     #  BOX DRAWINGS LIGHT VERTICAL AND RIGHT
    0x2524: 0x00b4,     #  BOX DRAWINGS LIGHT VERTICAL AND LEFT
    0x252c: 0x00c2,     #  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
    0x2534: 0x00c1,     #  BOX DRAWINGS LIGHT UP AND HORIZONTAL
    0x253c: 0x00c5,     #  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
    0x2550: 0x00cd,     #  BOX DRAWINGS DOUBLE HORIZONTAL
    0x2551: 0x00ba,     #  BOX DRAWINGS DOUBLE VERTICAL
    0x2552: 0x00d5,     #  BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
    0x2553: 0x00d6,     #  BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
    0x2554: 0x00c9,     #  BOX DRAWINGS DOUBLE DOWN AND RIGHT
    0x2555: 0x00b8,     #  BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
    0x2556: 0x00b7,     #  BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
    0x2557: 0x00bb,     #  BOX DRAWINGS DOUBLE DOWN AND LEFT
    0x2558: 0x00d4,     #  BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
    0x2559: 0x00d3,     #  BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
    0x255a: 0x00c8,     #  BOX DRAWINGS DOUBLE UP AND RIGHT
    0x255b: 0x00be,     #  BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
    0x255c: 0x00bd,     #  BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
    0x255d: 0x00bc,     #  BOX DRAWINGS DOUBLE UP AND LEFT
    0x255e: 0x00c6,     #  BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
    0x255f: 0x00c7,     #  BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
    0x2560: 0x00cc,     #  BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
    0x2561: 0x00b5,     #  BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
    0x2562: 0x00b6,     #  BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
    0x2563: 0x00b9,     #  BOX DRAWINGS DOUBLE VERTICAL AND LEFT
    0x2564: 0x00d1,     #  BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
    0x2565: 0x00d2,     #  BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
    0x2566: 0x00cb,     #  BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
    0x2567: 0x00cf,     #  BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
    0x2568: 0x00d0,     #  BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
    0x2569: 0x00ca,     #  BOX DRAWINGS DOUBLE UP AND HORIZONTAL
    0x256a: 0x00d8,     #  BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
    0x256b: 0x00d7,     #  BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
    0x256c: 0x00ce,     #  BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
    0x2580: 0x00df,     #  UPPER HALF BLOCK
    0x2584: 0x00dc,     #  LOWER HALF BLOCK
    0x2588: 0x00db,     #  FULL BLOCK
    0x258c: 0x00dd,     #  LEFT HALF BLOCK
    0x2590: 0x00de,     #  RIGHT HALF BLOCK
    0x2591: 0x00b0,     #  LIGHT SHADE
    0x2592: 0x00b1,     #  MEDIUM SHADE
    0x2593: 0x00b2,     #  DARK SHADE
    0x25a0: 0x00fe,     #  BLACK SQUARE
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """ Python Character Mapping Codec cp424 generated from 'MAPPINGS/VENDORS/MISC/CP424.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp424',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x9c'     #  0x04 -> SELECT
    '\t'       #  0x05 -> HORIZONTAL TABULATION
    '\x86'     #  0x06 -> REQUIRED NEW LINE
    '\x7f'     #  0x07 -> DELETE
    '\x97'     #  0x08 -> GRAPHIC ESCAPE
    '\x8d'     #  0x09 -> SUPERSCRIPT
    '\x8e'     #  0x0A -> REPEAT
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x9d'     #  0x14 -> RESTORE/ENABLE PRESENTATION
    '\x85'     #  0x15 -> NEW LINE
    '\x08'     #  0x16 -> BACKSPACE
    '\x87'     #  0x17 -> PROGRAM OPERATOR COMMUNICATION
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x92'     #  0x1A -> UNIT BACK SPACE
    '\x8f'     #  0x1B -> CUSTOMER USE ONE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    '\x80'     #  0x20 -> DIGIT SELECT
    '\x81'     #  0x21 -> START OF SIGNIFICANCE
    '\x82'     #  0x22 -> FIELD SEPARATOR
    '\x83'     #  0x23 -> WORD UNDERSCORE
    '\x84'     #  0x24 -> BYPASS OR INHIBIT PRESENTATION
    '\n'       #  0x25 -> LINE FEED
    '\x17'     #  0x26 -> END OF TRANSMISSION BLOCK
    '\x1b'     #  0x27 -> ESCAPE
    '\x88'     #  0x28 -> SET ATTRIBUTE
    '\x89'     #  0x29 -> START FIELD EXTENDED
    '\x8a'     #  0x2A -> SET MODE OR SWITCH
    '\x8b'     #  0x2B -> CONTROL SEQUENCE PREFIX
    '\x8c'     #  0x2C -> MODIFY FIELD ATTRIBUTE
    '\x05'     #  0x2D -> ENQUIRY
    '\x06'     #  0x2E -> ACKNOWLEDGE
    '\x07'     #  0x2F -> BELL
    '\x90'     #  0x30 -> <reserved>
    '\x91'     #  0x31 -> <reserved>
    '\x16'     #  0x32 -> SYNCHRONOUS IDLE
    '\x93'     #  0x33 -> INDEX RETURN
    '\x94'     #  0x34 -> PRESENTATION POSITION
    '\x95'     #  0x35 -> TRANSPARENT
    '\x96'     #  0x36 -> NUMERIC BACKSPACE
    '\x04'     #  0x37 -> END OF TRANSMISSION
    '\x98'     #  0x38 -> SUBSCRIPT
    '\x99'     #  0x39 -> INDENT TABULATION
    '\x9a'     #  0x3A -> REVERSE FORM FEED
    '\x9b'     #  0x3B -> CUSTOMER USE THREE
    '\x14'     #  0x3C -> DEVICE CONTROL FOUR
    '\x15'     #  0x3D -> NEGATIVE ACKNOWLEDGE
    '\x9e'     #  0x3E -> <reserved>
    '\x1a'     #  0x3F -> SUBSTITUTE
    ' '        #  0x40 -> SPACE
    '\u05d0'   #  0x41 -> HEBREW LETTER ALEF
    '\u05d1'   #  0x42 -> HEBREW LETTER BET
    '\u05d2'   #  0x43 -> HEBREW LETTER GIMEL
    '\u05d3'   #  0x44 -> HEBREW LETTER DALET
    '\u05d4'   #  0x45 -> HEBREW LETTER HE
    '\u05d5'   #  0x46 -> HEBREW LETTER VAV
    '\u05d6'   #  0x47 -> HEBREW LETTER ZAYIN
    '\u05d7'   #  0x48 -> HEBREW LETTER HET
    '\u05d8'   #  0x49 -> HEBREW LETTER TET
    '\xa2'     #  0x4A -> CENT SIGN
    '.'        #  0x4B -> FULL STOP
    '<'        #  0x4C -> LESS-THAN SIGN
    '('        #  0x4D -> LEFT PARENTHESIS
    '+'        #  0x4E -> PLUS SIGN
    '|'        #  0x4F -> VERTICAL LINE
    '&'        #  0x50 -> AMPERSAND
    '\u05d9'   #  0x51 -> HEBREW LETTER YOD
    '\u05da'   #  0x52 -> HEBREW LETTER FINAL KAF
    '\u05db'   #  0x53 -> HEBREW LETTER KAF
    '\u05dc'   #  0x54 -> HEBREW LETTER LAMED
    '\u05dd'   #  0x55 -> HEBREW LETTER FINAL MEM
    '\u05de'   #  0x56 -> HEBREW LETTER MEM
    '\u05df'   #  0x57 -> HEBREW LETTER FINAL NUN
    '\u05e0'   #  0x58 -> HEBREW LETTER NUN
    '\u05e1'   #  0x59 -> HEBREW LETTER SAMEKH
    '!'        #  0x5A -> EXCLAMATION MARK
    '$'        #  0x5B -> DOLLAR SIGN
    '*'        #  0x5C -> ASTERISK
    ')'        #  0x5D -> RIGHT PARENTHESIS
    ';'        #  0x5E -> SEMICOLON
    '\xac'     #  0x5F -> NOT SIGN
    '-'        #  0x60 -> HYPHEN-MINUS
    '/'        #  0x61 -> SOLIDUS
    '\u05e2'   #  0x62 -> HEBREW LETTER AYIN
    '\u05e3'   #  0x63 -> HEBREW LETTER FINAL PE
    '\u05e4'   #  0x64 -> HEBREW LETTER PE
    '\u05e5'   #  0x65 -> HEBREW LETTER FINAL TSADI
    '\u05e6'   #  0x66 -> HEBREW LETTER TSADI
    '\u05e7'   #  0x67 -> HEBREW LETTER QOF
    '\u05e8'   #  0x68 -> HEBREW LETTER RESH
    '\u05e9'   #  0x69 -> HEBREW LETTER SHIN
    '\xa6'     #  0x6A -> BROKEN BAR
    ','        #  0x6B -> COMMA
    '%'        #  0x6C -> PERCENT SIGN
    '_'        #  0x6D -> LOW LINE
    '>'        #  0x6E -> GREATER-THAN SIGN
    '?'        #  0x6F -> QUESTION MARK
    '\ufffe'   #  0x70 -> UNDEFINED
    '\u05ea'   #  0x71 -> HEBREW LETTER TAV
    '\ufffe'   #  0x72 -> UNDEFINED
    '\ufffe'   #  0x73 -> UNDEFINED
    '\xa0'     #  0x74 -> NO-BREAK SPACE
    '\ufffe'   #  0x75 -> UNDEFINED
    '\ufffe'   #  0x76 -> UNDEFINED
    '\ufffe'   #  0x77 -> UNDEFINED
    '\u2017'   #  0x78 -> DOUBLE LOW LINE
    '`'        #  0x79 -> GRAVE ACCENT
    ':'        #  0x7A -> COLON
    '#'        #  0x7B -> NUMBER SIGN
    '@'        #  0x7C -> COMMERCIAL AT
    "'"        #  0x7D -> APOSTROPHE
    '='        #  0x7E -> EQUALS SIGN
    '"'        #  0x7F -> QUOTATION MARK
    '\ufffe'   #  0x80 -> UNDEFINED
    'a'        #  0x81 -> LATIN SMALL LETTER A
    'b'        #  0x82 -> LATIN SMALL LETTER B
    'c'        #  0x83 -> LATIN SMALL LETTER C
    'd'        #  0x84 -> LATIN SMALL LETTER D
    'e'        #  0x85 -> LATIN SMALL LETTER E
    'f'        #  0x86 -> LATIN SMALL LETTER F
    'g'        #  0x87 -> LATIN SMALL LETTER G
    'h'        #  0x88 -> LATIN SMALL LETTER H
    'i'        #  0x89 -> LATIN SMALL LETTER I
    '\xab'     #  0x8A -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbb'     #  0x8B -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\ufffe'   #  0x8C -> UNDEFINED
    '\ufffe'   #  0x8D -> UNDEFINED
    '\ufffe'   #  0x8E -> UNDEFINED
    '\xb1'     #  0x8F -> PLUS-MINUS SIGN
    '\xb0'     #  0x90 -> DEGREE SIGN
    'j'        #  0x91 -> LATIN SMALL LETTER J
    'k'        #  0x92 -> LATIN SMALL LETTER K
    'l'        #  0x93 -> LATIN SMALL LETTER L
    'm'        #  0x94 -> LATIN SMALL LETTER M
    'n'        #  0x95 -> LATIN SMALL LETTER N
    'o'        #  0x96 -> LATIN SMALL LETTER O
    'p'        #  0x97 -> LATIN SMALL LETTER P
    'q'        #  0x98 -> LATIN SMALL LETTER Q
    'r'        #  0x99 -> LATIN SMALL LETTER R
    '\ufffe'   #  0x9A -> UNDEFINED
    '\ufffe'   #  0x9B -> UNDEFINED
    '\ufffe'   #  0x9C -> UNDEFINED
    '\xb8'     #  0x9D -> CEDILLA
    '\ufffe'   #  0x9E -> UNDEFINED
    '\xa4'     #  0x9F -> CURRENCY SIGN
    '\xb5'     #  0xA0 -> MICRO SIGN
    '~'        #  0xA1 -> TILDE
    's'        #  0xA2 -> LATIN SMALL LETTER S
    't'        #  0xA3 -> LATIN SMALL LETTER T
    'u'        #  0xA4 -> LATIN SMALL LETTER U
    'v'        #  0xA5 -> LATIN SMALL LETTER V
    'w'        #  0xA6 -> LATIN SMALL LETTER W
    'x'        #  0xA7 -> LATIN SMALL LETTER X
    'y'        #  0xA8 -> LATIN SMALL LETTER Y
    'z'        #  0xA9 -> LATIN SMALL LETTER Z
    '\ufffe'   #  0xAA -> UNDEFINED
    '\ufffe'   #  0xAB -> UNDEFINED
    '\ufffe'   #  0xAC -> UNDEFINED
    '\ufffe'   #  0xAD -> UNDEFINED
    '\ufffe'   #  0xAE -> UNDEFINED
    '\xae'     #  0xAF -> REGISTERED SIGN
    '^'        #  0xB0 -> CIRCUMFLEX ACCENT
    '\xa3'     #  0xB1 -> POUND SIGN
    '\xa5'     #  0xB2 -> YEN SIGN
    '\xb7'     #  0xB3 -> MIDDLE DOT
    '\xa9'     #  0xB4 -> COPYRIGHT SIGN
    '\xa7'     #  0xB5 -> SECTION SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xbc'     #  0xB7 -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xB8 -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xB9 -> VULGAR FRACTION THREE QUARTERS
    '['        #  0xBA -> LEFT SQUARE BRACKET
    ']'        #  0xBB -> RIGHT SQUARE BRACKET
    '\xaf'     #  0xBC -> MACRON
    '\xa8'     #  0xBD -> DIAERESIS
    '\xb4'     #  0xBE -> ACUTE ACCENT
    '\xd7'     #  0xBF -> MULTIPLICATION SIGN
    '{'        #  0xC0 -> LEFT CURLY BRACKET
    'A'        #  0xC1 -> LATIN CAPITAL LETTER A
    'B'        #  0xC2 -> LATIN CAPITAL LETTER B
    'C'        #  0xC3 -> LATIN CAPITAL LETTER C
    'D'        #  0xC4 -> LATIN CAPITAL LETTER D
    'E'        #  0xC5 -> LATIN CAPITAL LETTER E
    'F'        #  0xC6 -> LATIN CAPITAL LETTER F
    'G'        #  0xC7 -> LATIN CAPITAL LETTER G
    'H'        #  0xC8 -> LATIN CAPITAL LETTER H
    'I'        #  0xC9 -> LATIN CAPITAL LETTER I
    '\xad'     #  0xCA -> SOFT HYPHEN
    '\ufffe'   #  0xCB -> UNDEFINED
    '\ufffe'   #  0xCC -> UNDEFINED
    '\ufffe'   #  0xCD -> UNDEFINED
    '\ufffe'   #  0xCE -> UNDEFINED
    '\ufffe'   #  0xCF -> UNDEFINED
    '}'        #  0xD0 -> RIGHT CURLY BRACKET
    'J'        #  0xD1 -> LATIN CAPITAL LETTER J
    'K'        #  0xD2 -> LATIN CAPITAL LETTER K
    'L'        #  0xD3 -> LATIN CAPITAL LETTER L
    'M'        #  0xD4 -> LATIN CAPITAL LETTER M
    'N'        #  0xD5 -> LATIN CAPITAL LETTER N
    'O'        #  0xD6 -> LATIN CAPITAL LETTER O
    'P'        #  0xD7 -> LATIN CAPITAL LETTER P
    'Q'        #  0xD8 -> LATIN CAPITAL LETTER Q
    'R'        #  0xD9 -> LATIN CAPITAL LETTER R
    '\xb9'     #  0xDA -> SUPERSCRIPT ONE
    '\ufffe'   #  0xDB -> UNDEFINED
    '\ufffe'   #  0xDC -> UNDEFINED
    '\ufffe'   #  0xDD -> UNDEFINED
    '\ufffe'   #  0xDE -> UNDEFINED
    '\ufffe'   #  0xDF -> UNDEFINED
    '\\'       #  0xE0 -> REVERSE SOLIDUS
    '\xf7'     #  0xE1 -> DIVISION SIGN
    'S'        #  0xE2 -> LATIN CAPITAL LETTER S
    'T'        #  0xE3 -> LATIN CAPITAL LETTER T
    'U'        #  0xE4 -> LATIN CAPITAL LETTER U
    'V'        #  0xE5 -> LATIN CAPITAL LETTER V
    'W'        #  0xE6 -> LATIN CAPITAL LETTER W
    'X'        #  0xE7 -> LATIN CAPITAL LETTER X
    'Y'        #  0xE8 -> LATIN CAPITAL LETTER Y
    'Z'        #  0xE9 -> LATIN CAPITAL LETTER Z
    '\xb2'     #  0xEA -> SUPERSCRIPT TWO
    '\ufffe'   #  0xEB -> UNDEFINED
    '\ufffe'   #  0xEC -> UNDEFINED
    '\ufffe'   #  0xED -> UNDEFINED
    '\ufffe'   #  0xEE -> UNDEFINED
    '\ufffe'   #  0xEF -> UNDEFINED
    '0'        #  0xF0 -> DIGIT ZERO
    '1'        #  0xF1 -> DIGIT ONE
    '2'        #  0xF2 -> DIGIT TWO
    '3'        #  0xF3 -> DIGIT THREE
    '4'        #  0xF4 -> DIGIT FOUR
    '5'        #  0xF5 -> DIGIT FIVE
    '6'        #  0xF6 -> DIGIT SIX
    '7'        #  0xF7 -> DIGIT SEVEN
    '8'        #  0xF8 -> DIGIT EIGHT
    '9'        #  0xF9 -> DIGIT NINE
    '\xb3'     #  0xFA -> SUPERSCRIPT THREE
    '\ufffe'   #  0xFB -> UNDEFINED
    '\ufffe'   #  0xFC -> UNDEFINED
    '\ufffe'   #  0xFD -> UNDEFINED
    '\ufffe'   #  0xFE -> UNDEFINED
    '\x9f'     #  0xFF -> EIGHT ONES
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                         """ Python Character Mapping Codec cp1140 generated from 'python-mappings/CP1140.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1140',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x9c'     #  0x04 -> CONTROL
    '\t'       #  0x05 -> HORIZONTAL TABULATION
    '\x86'     #  0x06 -> CONTROL
    '\x7f'     #  0x07 -> DELETE
    '\x97'     #  0x08 -> CONTROL
    '\x8d'     #  0x09 -> CONTROL
    '\x8e'     #  0x0A -> CONTROL
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x9d'     #  0x14 -> CONTROL
    '\x85'     #  0x15 -> CONTROL
    '\x08'     #  0x16 -> BACKSPACE
    '\x87'     #  0x17 -> CONTROL
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x92'     #  0x1A -> CONTROL
    '\x8f'     #  0x1B -> CONTROL
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    '\x80'     #  0x20 -> CONTROL
    '\x81'     #  0x21 -> CONTROL
    '\x82'     #  0x22 -> CONTROL
    '\x83'     #  0x23 -> CONTROL
    '\x84'     #  0x24 -> CONTROL
    '\n'       #  0x25 -> LINE FEED
    '\x17'     #  0x26 -> END OF TRANSMISSION BLOCK
    '\x1b'     #  0x27 -> ESCAPE
    '\x88'     #  0x28 -> CONTROL
    '\x89'     #  0x29 -> CONTROL
    '\x8a'     #  0x2A -> CONTROL
    '\x8b'     #  0x2B -> CONTROL
    '\x8c'     #  0x2C -> CONTROL
    '\x05'     #  0x2D -> ENQUIRY
    '\x06'     #  0x2E -> ACKNOWLEDGE
    '\x07'     #  0x2F -> BELL
    '\x90'     #  0x30 -> CONTROL
    '\x91'     #  0x31 -> CONTROL
    '\x16'     #  0x32 -> SYNCHRONOUS IDLE
    '\x93'     #  0x33 -> CONTROL
    '\x94'     #  0x34 -> CONTROL
    '\x95'     #  0x35 -> CONTROL
    '\x96'     #  0x36 -> CONTROL
    '\x04'     #  0x37 -> END OF TRANSMISSION
    '\x98'     #  0x38 -> CONTROL
    '\x99'     #  0x39 -> CONTROL
    '\x9a'     #  0x3A -> CONTROL
    '\x9b'     #  0x3B -> CONTROL
    '\x14'     #  0x3C -> DEVICE CONTROL FOUR
    '\x15'     #  0x3D -> NEGATIVE ACKNOWLEDGE
    '\x9e'     #  0x3E -> CONTROL
    '\x1a'     #  0x3F -> SUBSTITUTE
    ' '        #  0x40 -> SPACE
    '\xa0'     #  0x41 -> NO-BREAK SPACE
    '\xe2'     #  0x42 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\xe4'     #  0x43 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe0'     #  0x44 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'     #  0x45 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe3'     #  0x46 -> LATIN SMALL LETTER A WITH TILDE
    '\xe5'     #  0x47 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe7'     #  0x48 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xf1'     #  0x49 -> LATIN SMALL LETTER N WITH TILDE
    '\xa2'     #  0x4A -> CENT SIGN
    '.'        #  0x4B -> FULL STOP
    '<'        #  0x4C -> LESS-THAN SIGN
    '('        #  0x4D -> LEFT PARENTHESIS
    '+'        #  0x4E -> PLUS SIGN
    '|'        #  0x4F -> VERTICAL LINE
    '&'        #  0x50 -> AMPERSAND
    '\xe9'     #  0x51 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0x52 -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0x53 -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xe8'     #  0x54 -> LATIN SMALL LETTER E WITH GRAVE
    '\xed'     #  0x55 -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0x56 -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0x57 -> LATIN SMALL LETTER I WITH DIAERESIS
    '\xec'     #  0x58 -> LATIN SMALL LETTER I WITH GRAVE
    '\xdf'     #  0x59 -> LATIN SMALL LETTER SHARP S (GERMAN)
    '!'        #  0x5A -> EXCLAMATION MARK
    '$'        #  0x5B -> DOLLAR SIGN
    '*'        #  0x5C -> ASTERISK
    ')'        #  0x5D -> RIGHT PARENTHESIS
    ';'        #  0x5E -> SEMICOLON
    '\xac'     #  0x5F -> NOT SIGN
    '-'        #  0x60 -> HYPHEN-MINUS
    '/'        #  0x61 -> SOLIDUS
    '\xc2'     #  0x62 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\xc4'     #  0x63 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc0'     #  0x64 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'     #  0x65 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc3'     #  0x66 -> LATIN CAPITAL LETTER A WITH TILDE
    '\xc5'     #  0x67 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc7'     #  0x68 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xd1'     #  0x69 -> LATIN CAPITAL LETTER N WITH TILDE
    '\xa6'     #  0x6A -> BROKEN BAR
    ','        #  0x6B -> COMMA
    '%'        #  0x6C -> PERCENT SIGN
    '_'        #  0x6D -> LOW LINE
    '>'        #  0x6E -> GREATER-THAN SIGN
    '?'        #  0x6F -> QUESTION MARK
    '\xf8'     #  0x70 -> LATIN SMALL LETTER O WITH STROKE
    '\xc9'     #  0x71 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'     #  0x72 -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'     #  0x73 -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\xc8'     #  0x74 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xcd'     #  0x75 -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0x76 -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'     #  0x77 -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\xcc'     #  0x78 -> LATIN CAPITAL LETTER I WITH GRAVE
    '`'        #  0x79 -> GRAVE ACCENT
    ':'        #  0x7A -> COLON
    '#'        #  0x7B -> NUMBER SIGN
    '@'        #  0x7C -> COMMERCIAL AT
    "'"        #  0x7D -> APOSTROPHE
    '='        #  0x7E -> EQUALS SIGN
    '"'        #  0x7F -> QUOTATION MARK
    '\xd8'     #  0x80 -> LATIN CAPITAL LETTER O WITH STROKE
    'a'        #  0x81 -> LATIN SMALL LETTER A
    'b'        #  0x82 -> LATIN SMALL LETTER B
    'c'        #  0x83 -> LATIN SMALL LETTER C
    'd'        #  0x84 -> LATIN SMALL LETTER D
    'e'        #  0x85 -> LATIN SMALL LETTER E
    'f'        #  0x86 -> LATIN SMALL LETTER F
    'g'        #  0x87 -> LATIN SMALL LETTER G
    'h'        #  0x88 -> LATIN SMALL LETTER H
    'i'        #  0x89 -> LATIN SMALL LETTER I
    '\xab'     #  0x8A -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbb'     #  0x8B -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xf0'     #  0x8C -> LATIN SMALL LETTER ETH (ICELANDIC)
    '\xfd'     #  0x8D -> LATIN SMALL LETTER Y WITH ACUTE
    '\xfe'     #  0x8E -> LATIN SMALL LETTER THORN (ICELANDIC)
    '\xb1'     #  0x8F -> PLUS-MINUS SIGN
    '\xb0'     #  0x90 -> DEGREE SIGN
    'j'        #  0x91 -> LATIN SMALL LETTER J
    'k'        #  0x92 -> LATIN SMALL LETTER K
    'l'        #  0x93 -> LATIN SMALL LETTER L
    'm'        #  0x94 -> LATIN SMALL LETTER M
    'n'        #  0x95 -> LATIN SMALL LETTER N
    'o'        #  0x96 -> LATIN SMALL LETTER O
    'p'        #  0x97 -> LATIN SMALL LETTER P
    'q'        #  0x98 -> LATIN SMALL LETTER Q
    'r'        #  0x99 -> LATIN SMALL LETTER R
    '\xaa'     #  0x9A -> FEMININE ORDINAL INDICATOR
    '\xba'     #  0x9B -> MASCULINE ORDINAL INDICATOR
    '\xe6'     #  0x9C -> LATIN SMALL LIGATURE AE
    '\xb8'     #  0x9D -> CEDILLA
    '\xc6'     #  0x9E -> LATIN CAPITAL LIGATURE AE
    '\u20ac'   #  0x9F -> EURO SIGN
    '\xb5'     #  0xA0 -> MICRO SIGN
    '~'        #  0xA1 -> TILDE
    's'        #  0xA2 -> LATIN SMALL LETTER S
    't'        #  0xA3 -> LATIN SMALL LETTER T
    'u'        #  0xA4 -> LATIN SMALL LETTER U
    'v'        #  0xA5 -> LATIN SMALL LETTER V
    'w'        #  0xA6 -> LATIN SMALL LETTER W
    'x'        #  0xA7 -> LATIN SMALL LETTER X
    'y'        #  0xA8 -> LATIN SMALL LETTER Y
    'z'        #  0xA9 -> LATIN SMALL LETTER Z
    '\xa1'     #  0xAA -> INVERTED EXCLAMATION MARK
    '\xbf'     #  0xAB -> INVERTED QUESTION MARK
    '\xd0'     #  0xAC -> LATIN CAPITAL LETTER ETH (ICELANDIC)
    '\xdd'     #  0xAD -> LATIN CAPITAL LETTER Y WITH ACUTE
    '\xde'     #  0xAE -> LATIN CAPITAL LETTER THORN (ICELANDIC)
    '\xae'     #  0xAF -> REGISTERED SIGN
    '^'        #  0xB0 -> CIRCUMFLEX ACCENT
    '\xa3'     #  0xB1 -> POUND SIGN
    '\xa5'     #  0xB2 -> YEN SIGN
    '\xb7'     #  0xB3 -> MIDDLE DOT
    '\xa9'     #  0xB4 -> COPYRIGHT SIGN
    '\xa7'     #  0xB5 -> SECTION SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xbc'     #  0xB7 -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xB8 -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xB9 -> VULGAR FRACTION THREE QUARTERS
    '['        #  0xBA -> LEFT SQUARE BRACKET
    ']'        #  0xBB -> RIGHT SQUARE BRACKET
    '\xaf'     #  0xBC -> MACRON
    '\xa8'     #  0xBD -> DIAERESIS
    '\xb4'     #  0xBE -> ACUTE ACCENT
    '\xd7'     #  0xBF -> MULTIPLICATION SIGN
    '{'        #  0xC0 -> LEFT CURLY BRACKET
    'A'        #  0xC1 -> LATIN CAPITAL LETTER A
    'B'        #  0xC2 -> LATIN CAPITAL LETTER B
    'C'        #  0xC3 -> LATIN CAPITAL LETTER C
    'D'        #  0xC4 -> LATIN CAPITAL LETTER D
    'E'        #  0xC5 -> LATIN CAPITAL LETTER E
    'F'        #  0xC6 -> LATIN CAPITAL LETTER F
    'G'        #  0xC7 -> LATIN CAPITAL LETTER G
    'H'        #  0xC8 -> LATIN CAPITAL LETTER H
    'I'        #  0xC9 -> LATIN CAPITAL LETTER I
    '\xad'     #  0xCA -> SOFT HYPHEN
    '\xf4'     #  0xCB -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\xf6'     #  0xCC -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf2'     #  0xCD -> LATIN SMALL LETTER O WITH GRAVE
    '\xf3'     #  0xCE -> LATIN SMALL LETTER O WITH ACUTE
    '\xf5'     #  0xCF -> LATIN SMALL LETTER O WITH TILDE
    '}'        #  0xD0 -> RIGHT CURLY BRACKET
    'J'        #  0xD1 -> LATIN CAPITAL LETTER J
    'K'        #  0xD2 -> LATIN CAPITAL LETTER K
    'L'        #  0xD3 -> LATIN CAPITAL LETTER L
    'M'        #  0xD4 -> LATIN CAPITAL LETTER M
    'N'        #  0xD5 -> LATIN CAPITAL LETTER N
    'O'        #  0xD6 -> LATIN CAPITAL LETTER O
    'P'        #  0xD7 -> LATIN CAPITAL LETTER P
    'Q'        #  0xD8 -> LATIN CAPITAL LETTER Q
    'R'        #  0xD9 -> LATIN CAPITAL LETTER R
    '\xb9'     #  0xDA -> SUPERSCRIPT ONE
    '\xfb'     #  0xDB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xfc'     #  0xDC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\xf9'     #  0xDD -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'     #  0xDE -> LATIN SMALL LETTER U WITH ACUTE
    '\xff'     #  0xDF -> LATIN SMALL LETTER Y WITH DIAERESIS
    '\\'       #  0xE0 -> REVERSE SOLIDUS
    '\xf7'     #  0xE1 -> DIVISION SIGN
    'S'        #  0xE2 -> LATIN CAPITAL LETTER S
    'T'        #  0xE3 -> LATIN CAPITAL LETTER T
    'U'        #  0xE4 -> LATIN CAPITAL LETTER U
    'V'        #  0xE5 -> LATIN CAPITAL LETTER V
    'W'        #  0xE6 -> LATIN CAPITAL LETTER W
    'X'        #  0xE7 -> LATIN CAPITAL LETTER X
    'Y'        #  0xE8 -> LATIN CAPITAL LETTER Y
    'Z'        #  0xE9 -> LATIN CAPITAL LETTER Z
    '\xb2'     #  0xEA -> SUPERSCRIPT TWO
    '\xd4'     #  0xEB -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\xd6'     #  0xEC -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd2'     #  0xED -> LATIN CAPITAL LETTER O WITH GRAVE
    '\xd3'     #  0xEE -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd5'     #  0xEF -> LATIN CAPITAL LETTER O WITH TILDE
    '0'        #  0xF0 -> DIGIT ZERO
    '1'        #  0xF1 -> DIGIT ONE
    '2'        #  0xF2 -> DIGIT TWO
    '3'        #  0xF3 -> DIGIT THREE
    '4'        #  0xF4 -> DIGIT FOUR
    '5'        #  0xF5 -> DIGIT FIVE
    '6'        #  0xF6 -> DIGIT SIX
    '7'        #  0xF7 -> DIGIT SEVEN
    '8'        #  0xF8 -> DIGIT EIGHT
    '9'        #  0xF9 -> DIGIT NINE
    '\xb3'     #  0xFA -> SUPERSCRIPT THREE
    '\xdb'     #  0xFB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    '\xdc'     #  0xFC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\xd9'     #  0xFD -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'     #  0xFE -> LATIN CAPITAL LETTER U WITH ACUTE
    '\x9f'     #  0xFF -> CONTROL
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """ Python Character Mapping Codec cp1250 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1250.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1250',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\ufffe'   #  0x83 -> UNDEFINED
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\ufffe'   #  0x88 -> UNDEFINED
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\u0160'   #  0x8A -> LATIN CAPITAL LETTER S WITH CARON
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\u015a'   #  0x8C -> LATIN CAPITAL LETTER S WITH ACUTE
    '\u0164'   #  0x8D -> LATIN CAPITAL LETTER T WITH CARON
    '\u017d'   #  0x8E -> LATIN CAPITAL LETTER Z WITH CARON
    '\u0179'   #  0x8F -> LATIN CAPITAL LETTER Z WITH ACUTE
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\ufffe'   #  0x98 -> UNDEFINED
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\u0161'   #  0x9A -> LATIN SMALL LETTER S WITH CARON
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\u015b'   #  0x9C -> LATIN SMALL LETTER S WITH ACUTE
    '\u0165'   #  0x9D -> LATIN SMALL LETTER T WITH CARON
    '\u017e'   #  0x9E -> LATIN SMALL LETTER Z WITH CARON
    '\u017a'   #  0x9F -> LATIN SMALL LETTER Z WITH ACUTE
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\u02c7'   #  0xA1 -> CARON
    '\u02d8'   #  0xA2 -> BREVE
    '\u0141'   #  0xA3 -> LATIN CAPITAL LETTER L WITH STROKE
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\u0104'   #  0xA5 -> LATIN CAPITAL LETTER A WITH OGONEK
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\u015e'   #  0xAA -> LATIN CAPITAL LETTER S WITH CEDILLA
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\u017b'   #  0xAF -> LATIN CAPITAL LETTER Z WITH DOT ABOVE
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\u02db'   #  0xB2 -> OGONEK
    '\u0142'   #  0xB3 -> LATIN SMALL LETTER L WITH STROKE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xb8'     #  0xB8 -> CEDILLA
    '\u0105'   #  0xB9 -> LATIN SMALL LETTER A WITH OGONEK
    '\u015f'   #  0xBA -> LATIN SMALL LETTER S WITH CEDILLA
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\u013d'   #  0xBC -> LATIN CAPITAL LETTER L WITH CARON
    '\u02dd'   #  0xBD -> DOUBLE ACUTE ACCENT
    '\u013e'   #  0xBE -> LATIN SMALL LETTER L WITH CARON
    '\u017c'   #  0xBF -> LATIN SMALL LETTER Z WITH DOT ABOVE
    '\u0154'   #  0xC0 -> LATIN CAPITAL LETTER R WITH ACUTE
    '\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\u0102'   #  0xC3 -> LATIN CAPITAL LETTER A WITH BREVE
    '\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\u0139'   #  0xC5 -> LATIN CAPITAL LETTER L WITH ACUTE
    '\u0106'   #  0xC6 -> LATIN CAPITAL LETTER C WITH ACUTE
    '\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\u010c'   #  0xC8 -> LATIN CAPITAL LETTER C WITH CARON
    '\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\u0118'   #  0xCA -> LATIN CAPITAL LETTER E WITH OGONEK
    '\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\u011a'   #  0xCC -> LATIN CAPITAL LETTER E WITH CARON
    '\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\u010e'   #  0xCF -> LATIN CAPITAL LETTER D WITH CARON
    '\u0110'   #  0xD0 -> LATIN CAPITAL LETTER D WITH STROKE
    '\u0143'   #  0xD1 -> LATIN CAPITAL LETTER N WITH ACUTE
    '\u0147'   #  0xD2 -> LATIN CAPITAL LETTER N WITH CARON
    '\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\u0150'   #  0xD5 -> LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
    '\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
    '\u0158'   #  0xD8 -> LATIN CAPITAL LETTER R WITH CARON
    '\u016e'   #  0xD9 -> LATIN CAPITAL LETTER U WITH RING ABOVE
    '\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE
    '\u0170'   #  0xDB -> LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
    '\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\xdd'     #  0xDD -> LATIN CAPITAL LETTER Y WITH ACUTE
    '\u0162'   #  0xDE -> LATIN CAPITAL LETTER T WITH CEDILLA
    '\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S
    '\u0155'   #  0xE0 -> LATIN SMALL LETTER R WITH ACUTE
    '\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\u0103'   #  0xE3 -> LATIN SMALL LETTER A WITH BREVE
    '\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\u013a'   #  0xE5 -> LATIN SMALL LETTER L WITH ACUTE
    '\u0107'   #  0xE6 -> LATIN SMALL LETTER C WITH ACUTE
    '\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA
    '\u010d'   #  0xE8 -> LATIN SMALL LETTER C WITH CARON
    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
    '\u0119'   #  0xEA -> LATIN SMALL LETTER E WITH OGONEK
    '\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS
    '\u011b'   #  0xEC -> LATIN SMALL LETTER E WITH CARON
    '\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\u010f'   #  0xEF -> LATIN SMALL LETTER D WITH CARON
    '\u0111'   #  0xF0 -> LATIN SMALL LETTER D WITH STROKE
    '\u0144'   #  0xF1 -> LATIN SMALL LETTER N WITH ACUTE
    '\u0148'   #  0xF2 -> LATIN SMALL LETTER N WITH CARON
    '\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE
    '\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\u0151'   #  0xF5 -> LATIN SMALL LETTER O WITH DOUBLE ACUTE
    '\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf7'     #  0xF7 -> DIVISION SIGN
    '\u0159'   #  0xF8 -> LATIN SMALL LETTER R WITH CARON
    '\u016f'   #  0xF9 -> LATIN SMALL LETTER U WITH RING ABOVE
    '\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE
    '\u0171'   #  0xFB -> LATIN SMALL LETTER U WITH DOUBLE ACUTE
    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\xfd'     #  0xFD -> LATIN SMALL LETTER Y WITH ACUTE
    '\u0163'   #  0xFE -> LATIN SMALL LETTER T WITH CEDILLA
    '\u02d9'   #  0xFF -> DOT ABOVE
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          """ Python Character Mapping Codec cp1251 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1251.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1251',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u0402'   #  0x80 -> CYRILLIC CAPITAL LETTER DJE
    '\u0403'   #  0x81 -> CYRILLIC CAPITAL LETTER GJE
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0453'   #  0x83 -> CYRILLIC SMALL LETTER GJE
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\u20ac'   #  0x88 -> EURO SIGN
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\u0409'   #  0x8A -> CYRILLIC CAPITAL LETTER LJE
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\u040a'   #  0x8C -> CYRILLIC CAPITAL LETTER NJE
    '\u040c'   #  0x8D -> CYRILLIC CAPITAL LETTER KJE
    '\u040b'   #  0x8E -> CYRILLIC CAPITAL LETTER TSHE
    '\u040f'   #  0x8F -> CYRILLIC CAPITAL LETTER DZHE
    '\u0452'   #  0x90 -> CYRILLIC SMALL LETTER DJE
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\ufffe'   #  0x98 -> UNDEFINED
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\u0459'   #  0x9A -> CYRILLIC SMALL LETTER LJE
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\u045a'   #  0x9C -> CYRILLIC SMALL LETTER NJE
    '\u045c'   #  0x9D -> CYRILLIC SMALL LETTER KJE
    '\u045b'   #  0x9E -> CYRILLIC SMALL LETTER TSHE
    '\u045f'   #  0x9F -> CYRILLIC SMALL LETTER DZHE
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\u040e'   #  0xA1 -> CYRILLIC CAPITAL LETTER SHORT U
    '\u045e'   #  0xA2 -> CYRILLIC SMALL LETTER SHORT U
    '\u0408'   #  0xA3 -> CYRILLIC CAPITAL LETTER JE
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\u0490'   #  0xA5 -> CYRILLIC CAPITAL LETTER GHE WITH UPTURN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\u0401'   #  0xA8 -> CYRILLIC CAPITAL LETTER IO
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\u0404'   #  0xAA -> CYRILLIC CAPITAL LETTER UKRAINIAN IE
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\u0407'   #  0xAF -> CYRILLIC CAPITAL LETTER YI
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\u0406'   #  0xB2 -> CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
    '\u0456'   #  0xB3 -> CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
    '\u0491'   #  0xB4 -> CYRILLIC SMALL LETTER GHE WITH UPTURN
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\u0451'   #  0xB8 -> CYRILLIC SMALL LETTER IO
    '\u2116'   #  0xB9 -> NUMERO SIGN
    '\u0454'   #  0xBA -> CYRILLIC SMALL LETTER UKRAINIAN IE
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\u0458'   #  0xBC -> CYRILLIC SMALL LETTER JE
    '\u0405'   #  0xBD -> CYRILLIC CAPITAL LETTER DZE
    '\u0455'   #  0xBE -> CYRILLIC SMALL LETTER DZE
    '\u0457'   #  0xBF -> CYRILLIC SMALL LETTER YI
    '\u0410'   #  0xC0 -> CYRILLIC CAPITAL LETTER A
    '\u0411'   #  0xC1 -> CYRILLIC CAPITAL LETTER BE
    '\u0412'   #  0xC2 -> CYRILLIC CAPITAL LETTER VE
    '\u0413'   #  0xC3 -> CYRILLIC CAPITAL LETTER GHE
    '\u0414'   #  0xC4 -> CYRILLIC CAPITAL LETTER DE
    '\u0415'   #  0xC5 -> CYRILLIC CAPITAL LETTER IE
    '\u0416'   #  0xC6 -> CYRILLIC CAPITAL LETTER ZHE
    '\u0417'   #  0xC7 -> CYRILLIC CAPITAL LETTER ZE
    '\u0418'   #  0xC8 -> CYRILLIC CAPITAL LETTER I
    '\u0419'   #  0xC9 -> CYRILLIC CAPITAL LETTER SHORT I
    '\u041a'   #  0xCA -> CYRILLIC CAPITAL LETTER KA
    '\u041b'   #  0xCB -> CYRILLIC CAPITAL LETTER EL
    '\u041c'   #  0xCC -> CYRILLIC CAPITAL LETTER EM
    '\u041d'   #  0xCD -> CYRILLIC CAPITAL LETTER EN
    '\u041e'   #  0xCE -> CYRILLIC CAPITAL LETTER O
    '\u041f'   #  0xCF -> CYRILLIC CAPITAL LETTER PE
    '\u0420'   #  0xD0 -> CYRILLIC CAPITAL LETTER ER
    '\u0421'   #  0xD1 -> CYRILLIC CAPITAL LETTER ES
    '\u0422'   #  0xD2 -> CYRILLIC CAPITAL LETTER TE
    '\u0423'   #  0xD3 -> CYRILLIC CAPITAL LETTER U
    '\u0424'   #  0xD4 -> CYRILLIC CAPITAL LETTER EF
    '\u0425'   #  0xD5 -> CYRILLIC CAPITAL LETTER HA
    '\u0426'   #  0xD6 -> CYRILLIC CAPITAL LETTER TSE
    '\u0427'   #  0xD7 -> CYRILLIC CAPITAL LETTER CHE
    '\u0428'   #  0xD8 -> CYRILLIC CAPITAL LETTER SHA
    '\u0429'   #  0xD9 -> CYRILLIC CAPITAL LETTER SHCHA
    '\u042a'   #  0xDA -> CYRILLIC CAPITAL LETTER HARD SIGN
    '\u042b'   #  0xDB -> CYRILLIC CAPITAL LETTER YERU
    '\u042c'   #  0xDC -> CYRILLIC CAPITAL LETTER SOFT SIGN
    '\u042d'   #  0xDD -> CYRILLIC CAPITAL LETTER E
    '\u042e'   #  0xDE -> CYRILLIC CAPITAL LETTER YU
    '\u042f'   #  0xDF -> CYRILLIC CAPITAL LETTER YA
    '\u0430'   #  0xE0 -> CYRILLIC SMALL LETTER A
    '\u0431'   #  0xE1 -> CYRILLIC SMALL LETTER BE
    '\u0432'   #  0xE2 -> CYRILLIC SMALL LETTER VE
    '\u0433'   #  0xE3 -> CYRILLIC SMALL LETTER GHE
    '\u0434'   #  0xE4 -> CYRILLIC SMALL LETTER DE
    '\u0435'   #  0xE5 -> CYRILLIC SMALL LETTER IE
    '\u0436'   #  0xE6 -> CYRILLIC SMALL LETTER ZHE
    '\u0437'   #  0xE7 -> CYRILLIC SMALL LETTER ZE
    '\u0438'   #  0xE8 -> CYRILLIC SMALL LETTER I
    '\u0439'   #  0xE9 -> CYRILLIC SMALL LETTER SHORT I
    '\u043a'   #  0xEA -> CYRILLIC SMALL LETTER KA
    '\u043b'   #  0xEB -> CYRILLIC SMALL LETTER EL
    '\u043c'   #  0xEC -> CYRILLIC SMALL LETTER EM
    '\u043d'   #  0xED -> CYRILLIC SMALL LETTER EN
    '\u043e'   #  0xEE -> CYRILLIC SMALL LETTER O
    '\u043f'   #  0xEF -> CYRILLIC SMALL LETTER PE
    '\u0440'   #  0xF0 -> CYRILLIC SMALL LETTER ER
    '\u0441'   #  0xF1 -> CYRILLIC SMALL LETTER ES
    '\u0442'   #  0xF2 -> CYRILLIC SMALL LETTER TE
    '\u0443'   #  0xF3 -> CYRILLIC SMALL LETTER U
    '\u0444'   #  0xF4 -> CYRILLIC SMALL LETTER EF
    '\u0445'   #  0xF5 -> CYRILLIC SMALL LETTER HA
    '\u0446'   #  0xF6 -> CYRILLIC SMALL LETTER TSE
    '\u0447'   #  0xF7 -> CYRILLIC SMALL LETTER CHE
    '\u0448'   #  0xF8 -> CYRILLIC SMALL LETTER SHA
    '\u0449'   #  0xF9 -> CYRILLIC SMALL LETTER SHCHA
    '\u044a'   #  0xFA -> CYRILLIC SMALL LETTER HARD SIGN
    '\u044b'   #  0xFB -> CYRILLIC SMALL LETTER YERU
    '\u044c'   #  0xFC -> CYRILLIC SMALL LETTER SOFT SIGN
    '\u044d'   #  0xFD -> CYRILLIC SMALL LETTER E
    '\u044e'   #  0xFE -> CYRILLIC SMALL LETTER YU
    '\u044f'   #  0xFF -> CYRILLIC SMALL LETTER YA
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """ Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1252',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\u0160'   #  0x8A -> LATIN CAPITAL LETTER S WITH CARON
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE
    '\ufffe'   #  0x8D -> UNDEFINED
    '\u017d'   #  0x8E -> LATIN CAPITAL LETTER Z WITH CARON
    '\ufffe'   #  0x8F -> UNDEFINED
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\u02dc'   #  0x98 -> SMALL TILDE
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\u0161'   #  0x9A -> LATIN SMALL LETTER S WITH CARON
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE
    '\ufffe'   #  0x9D -> UNDEFINED
    '\u017e'   #  0x9E -> LATIN SMALL LETTER Z WITH CARON
    '\u0178'   #  0x9F -> LATIN CAPITAL LETTER Y WITH DIAERESIS
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK
    '\xa2'     #  0xA2 -> CENT SIGN
    '\xa3'     #  0xA3 -> POUND SIGN
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\xa5'     #  0xA5 -> YEN SIGN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\xaa'     #  0xAA -> FEMININE ORDINAL INDICATOR
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\xaf'     #  0xAF -> MACRON
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xb8'     #  0xB8 -> CEDILLA
    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
    '\xba'     #  0xBA -> MASCULINE ORDINAL INDICATOR
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
    '\xbf'     #  0xBF -> INVERTED QUESTION MARK
    '\xc0'     #  0xC0 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\xc3'     #  0xC3 -> LATIN CAPITAL LETTER A WITH TILDE
    '\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc6'     #  0xC6 -> LATIN CAPITAL LETTER AE
    '\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xc8'     #  0xC8 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'     #  0xCA -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\xcc'     #  0xCC -> LATIN CAPITAL LETTER I WITH GRAVE
    '\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'     #  0xCF -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\xd0'     #  0xD0 -> LATIN CAPITAL LETTER ETH
    '\xd1'     #  0xD1 -> LATIN CAPITAL LETTER N WITH TILDE
    '\xd2'     #  0xD2 -> LATIN CAPITAL LETTER O WITH GRAVE
    '\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\xd5'     #  0xD5 -> LATIN CAPITAL LETTER O WITH TILDE
    '\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
    '\xd8'     #  0xD8 -> LATIN CAPITAL LETTER O WITH STROKE
    '\xd9'     #  0xD9 -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE
    '\xdb'     #  0xDB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    '\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\xdd'     #  0xDD -> LATIN CAPITAL LETTER Y WITH ACUTE
    '\xde'     #  0xDE -> LATIN CAPITAL LETTER THORN
    '\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S
    '\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\xe3'     #  0xE3 -> LATIN SMALL LETTER A WITH TILDE
    '\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe6'     #  0xE6 -> LATIN SMALL LETTER AE
    '\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE
    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xec'     #  0xEC -> LATIN SMALL LETTER I WITH GRAVE
    '\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS
    '\xf0'     #  0xF0 -> LATIN SMALL LETTER ETH
    '\xf1'     #  0xF1 -> LATIN SMALL LETTER N WITH TILDE
    '\xf2'     #  0xF2 -> LATIN SMALL LETTER O WITH GRAVE
    '\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE
    '\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\xf5'     #  0xF5 -> LATIN SMALL LETTER O WITH TILDE
    '\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf7'     #  0xF7 -> DIVISION SIGN
    '\xf8'     #  0xF8 -> LATIN SMALL LETTER O WITH STROKE
    '\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE
    '\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\xfd'     #  0xFD -> LATIN SMALL LETTER Y WITH ACUTE
    '\xfe'     #  0xFE -> LATIN SMALL LETTER THORN
    '\xff'     #  0xFF -> LATIN SMALL LETTER Y WITH DIAERESIS
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """ Python Character Mapping Codec cp1253 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1253.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1253',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\ufffe'   #  0x88 -> UNDEFINED
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\ufffe'   #  0x8A -> UNDEFINED
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\ufffe'   #  0x8C -> UNDEFINED
    '\ufffe'   #  0x8D -> UNDEFINED
    '\ufffe'   #  0x8E -> UNDEFINED
    '\ufffe'   #  0x8F -> UNDEFINED
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\ufffe'   #  0x98 -> UNDEFINED
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\ufffe'   #  0x9A -> UNDEFINED
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\ufffe'   #  0x9C -> UNDEFINED
    '\ufffe'   #  0x9D -> UNDEFINED
    '\ufffe'   #  0x9E -> UNDEFINED
    '\ufffe'   #  0x9F -> UNDEFINED
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\u0385'   #  0xA1 -> GREEK DIALYTIKA TONOS
    '\u0386'   #  0xA2 -> GREEK CAPITAL LETTER ALPHA WITH TONOS
    '\xa3'     #  0xA3 -> POUND SIGN
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\xa5'     #  0xA5 -> YEN SIGN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\ufffe'   #  0xAA -> UNDEFINED
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\u2015'   #  0xAF -> HORIZONTAL BAR
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\u0384'   #  0xB4 -> GREEK TONOS
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\u0388'   #  0xB8 -> GREEK CAPITAL LETTER EPSILON WITH TONOS
    '\u0389'   #  0xB9 -> GREEK CAPITAL LETTER ETA WITH TONOS
    '\u038a'   #  0xBA -> GREEK CAPITAL LETTER IOTA WITH TONOS
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\u038c'   #  0xBC -> GREEK CAPITAL LETTER OMICRON WITH TONOS
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\u038e'   #  0xBE -> GREEK CAPITAL LETTER UPSILON WITH TONOS
    '\u038f'   #  0xBF -> GREEK CAPITAL LETTER OMEGA WITH TONOS
    '\u0390'   #  0xC0 -> GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
    '\u0391'   #  0xC1 -> GREEK CAPITAL LETTER ALPHA
    '\u0392'   #  0xC2 -> GREEK CAPITAL LETTER BETA
    '\u0393'   #  0xC3 -> GREEK CAPITAL LETTER GAMMA
    '\u0394'   #  0xC4 -> GREEK CAPITAL LETTER DELTA
    '\u0395'   #  0xC5 -> GREEK CAPITAL LETTER EPSILON
    '\u0396'   #  0xC6 -> GREEK CAPITAL LETTER ZETA
    '\u0397'   #  0xC7 -> GREEK CAPITAL LETTER ETA
    '\u0398'   #  0xC8 -> GREEK CAPITAL LETTER THETA
    '\u0399'   #  0xC9 -> GREEK CAPITAL LETTER IOTA
    '\u039a'   #  0xCA -> GREEK CAPITAL LETTER KAPPA
    '\u039b'   #  0xCB -> GREEK CAPITAL LETTER LAMDA
    '\u039c'   #  0xCC -> GREEK CAPITAL LETTER MU
    '\u039d'   #  0xCD -> GREEK CAPITAL LETTER NU
    '\u039e'   #  0xCE -> GREEK CAPITAL LETTER XI
    '\u039f'   #  0xCF -> GREEK CAPITAL LETTER OMICRON
    '\u03a0'   #  0xD0 -> GREEK CAPITAL LETTER PI
    '\u03a1'   #  0xD1 -> GREEK CAPITAL LETTER RHO
    '\ufffe'   #  0xD2 -> UNDEFINED
    '\u03a3'   #  0xD3 -> GREEK CAPITAL LETTER SIGMA
    '\u03a4'   #  0xD4 -> GREEK CAPITAL LETTER TAU
    '\u03a5'   #  0xD5 -> GREEK CAPITAL LETTER UPSILON
    '\u03a6'   #  0xD6 -> GREEK CAPITAL LETTER PHI
    '\u03a7'   #  0xD7 -> GREEK CAPITAL LETTER CHI
    '\u03a8'   #  0xD8 -> GREEK CAPITAL LETTER PSI
    '\u03a9'   #  0xD9 -> GREEK CAPITAL LETTER OMEGA
    '\u03aa'   #  0xDA -> GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
    '\u03ab'   #  0xDB -> GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
    '\u03ac'   #  0xDC -> GREEK SMALL LETTER ALPHA WITH TONOS
    '\u03ad'   #  0xDD -> GREEK SMALL LETTER EPSILON WITH TONOS
    '\u03ae'   #  0xDE -> GREEK SMALL LETTER ETA WITH TONOS
    '\u03af'   #  0xDF -> GREEK SMALL LETTER IOTA WITH TONOS
    '\u03b0'   #  0xE0 -> GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
    '\u03b1'   #  0xE1 -> GREEK SMALL LETTER ALPHA
    '\u03b2'   #  0xE2 -> GREEK SMALL LETTER BETA
    '\u03b3'   #  0xE3 -> GREEK SMALL LETTER GAMMA
    '\u03b4'   #  0xE4 -> GREEK SMALL LETTER DELTA
    '\u03b5'   #  0xE5 -> GREEK SMALL LETTER EPSILON
    '\u03b6'   #  0xE6 -> GREEK SMALL LETTER ZETA
    '\u03b7'   #  0xE7 -> GREEK SMALL LETTER ETA
    '\u03b8'   #  0xE8 -> GREEK SMALL LETTER THETA
    '\u03b9'   #  0xE9 -> GREEK SMALL LETTER IOTA
    '\u03ba'   #  0xEA -> GREEK SMALL LETTER KAPPA
    '\u03bb'   #  0xEB -> GREEK SMALL LETTER LAMDA
    '\u03bc'   #  0xEC -> GREEK SMALL LETTER MU
    '\u03bd'   #  0xED -> GREEK SMALL LETTER NU
    '\u03be'   #  0xEE -> GREEK SMALL LETTER XI
    '\u03bf'   #  0xEF -> GREEK SMALL LETTER OMICRON
    '\u03c0'   #  0xF0 -> GREEK SMALL LETTER PI
    '\u03c1'   #  0xF1 -> GREEK SMALL LETTER RHO
    '\u03c2'   #  0xF2 -> GREEK SMALL LETTER FINAL SIGMA
    '\u03c3'   #  0xF3 -> GREEK SMALL LETTER SIGMA
    '\u03c4'   #  0xF4 -> GREEK SMALL LETTER TAU
    '\u03c5'   #  0xF5 -> GREEK SMALL LETTER UPSILON
    '\u03c6'   #  0xF6 -> GREEK SMALL LETTER PHI
    '\u03c7'   #  0xF7 -> GREEK SMALL LETTER CHI
    '\u03c8'   #  0xF8 -> GREEK SMALL LETTER PSI
    '\u03c9'   #  0xF9 -> GREEK SMALL LETTER OMEGA
    '\u03ca'   #  0xFA -> GREEK SMALL LETTER IOTA WITH DIALYTIKA
    '\u03cb'   #  0xFB -> GREEK SMALL LETTER UPSILON WITH DIALYTIKA
    '\u03cc'   #  0xFC -> GREEK SMALL LETTER OMICRON WITH TONOS
    '\u03cd'   #  0xFD -> GREEK SMALL LETTER UPSILON WITH TONOS
    '\u03ce'   #  0xFE -> GREEK SMALL LETTER OMEGA WITH TONOS
    '\ufffe'   #  0xFF -> UNDEFINED
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          """ Python Character Mapping Codec cp1254 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1254.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1254',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\u0160'   #  0x8A -> LATIN CAPITAL LETTER S WITH CARON
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE
    '\ufffe'   #  0x8D -> UNDEFINED
    '\ufffe'   #  0x8E -> UNDEFINED
    '\ufffe'   #  0x8F -> UNDEFINED
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\u02dc'   #  0x98 -> SMALL TILDE
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\u0161'   #  0x9A -> LATIN SMALL LETTER S WITH CARON
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE
    '\ufffe'   #  0x9D -> UNDEFINED
    '\ufffe'   #  0x9E -> UNDEFINED
    '\u0178'   #  0x9F -> LATIN CAPITAL LETTER Y WITH DIAERESIS
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK
    '\xa2'     #  0xA2 -> CENT SIGN
    '\xa3'     #  0xA3 -> POUND SIGN
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\xa5'     #  0xA5 -> YEN SIGN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\xaa'     #  0xAA -> FEMININE ORDINAL INDICATOR
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\xaf'     #  0xAF -> MACRON
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xb8'     #  0xB8 -> CEDILLA
    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
    '\xba'     #  0xBA -> MASCULINE ORDINAL INDICATOR
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
    '\xbf'     #  0xBF -> INVERTED QUESTION MARK
    '\xc0'     #  0xC0 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\xc3'     #  0xC3 -> LATIN CAPITAL LETTER A WITH TILDE
    '\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc6'     #  0xC6 -> LATIN CAPITAL LETTER AE
    '\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xc8'     #  0xC8 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'     #  0xCA -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\xcc'     #  0xCC -> LATIN CAPITAL LETTER I WITH GRAVE
    '\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'     #  0xCF -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\u011e'   #  0xD0 -> LATIN CAPITAL LETTER G WITH BREVE
    '\xd1'     #  0xD1 -> LATIN CAPITAL LETTER N WITH TILDE
    '\xd2'     #  0xD2 -> LATIN CAPITAL LETTER O WITH GRAVE
    '\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\xd5'     #  0xD5 -> LATIN CAPITAL LETTER O WITH TILDE
    '\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
    '\xd8'     #  0xD8 -> LATIN CAPITAL LETTER O WITH STROKE
    '\xd9'     #  0xD9 -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE
    '\xdb'     #  0xDB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    '\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\u0130'   #  0xDD -> LATIN CAPITAL LETTER I WITH DOT ABOVE
    '\u015e'   #  0xDE -> LATIN CAPITAL LETTER S WITH CEDILLA
    '\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S
    '\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\xe3'     #  0xE3 -> LATIN SMALL LETTER A WITH TILDE
    '\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe6'     #  0xE6 -> LATIN SMALL LETTER AE
    '\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE
    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xec'     #  0xEC -> LATIN SMALL LETTER I WITH GRAVE
    '\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS
    '\u011f'   #  0xF0 -> LATIN SMALL LETTER G WITH BREVE
    '\xf1'     #  0xF1 -> LATIN SMALL LETTER N WITH TILDE
    '\xf2'     #  0xF2 -> LATIN SMALL LETTER O WITH GRAVE
    '\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE
    '\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\xf5'     #  0xF5 -> LATIN SMALL LETTER O WITH TILDE
    '\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf7'     #  0xF7 -> DIVISION SIGN
    '\xf8'     #  0xF8 -> LATIN SMALL LETTER O WITH STROKE
    '\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE
    '\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\u0131'   #  0xFD -> LATIN SMALL LETTER DOTLESS I
    '\u015f'   #  0xFE -> LATIN SMALL LETTER S WITH CEDILLA
    '\xff'     #  0xFF -> LATIN SMALL LETTER Y WITH DIAERESIS
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """ Python Character Mapping Codec cp1255 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1255.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1255',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\ufffe'   #  0x8A -> UNDEFINED
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\ufffe'   #  0x8C -> UNDEFINED
    '\ufffe'   #  0x8D -> UNDEFINED
    '\ufffe'   #  0x8E -> UNDEFINED
    '\ufffe'   #  0x8F -> UNDEFINED
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\u02dc'   #  0x98 -> SMALL TILDE
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\ufffe'   #  0x9A -> UNDEFINED
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\ufffe'   #  0x9C -> UNDEFINED
    '\ufffe'   #  0x9D -> UNDEFINED
    '\ufffe'   #  0x9E -> UNDEFINED
    '\ufffe'   #  0x9F -> UNDEFINED
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK
    '\xa2'     #  0xA2 -> CENT SIGN
    '\xa3'     #  0xA3 -> POUND SIGN
    '\u20aa'   #  0xA4 -> NEW SHEQEL SIGN
    '\xa5'     #  0xA5 -> YEN SIGN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\xd7'     #  0xAA -> MULTIPLICATION SIGN
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\xaf'     #  0xAF -> MACRON
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xb8'     #  0xB8 -> CEDILLA
    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
    '\xf7'     #  0xBA -> DIVISION SIGN
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
    '\xbf'     #  0xBF -> INVERTED QUESTION MARK
    '\u05b0'   #  0xC0 -> HEBREW POINT SHEVA
    '\u05b1'   #  0xC1 -> HEBREW POINT HATAF SEGOL
    '\u05b2'   #  0xC2 -> HEBREW POINT HATAF PATAH
    '\u05b3'   #  0xC3 -> HEBREW POINT HATAF QAMATS
    '\u05b4'   #  0xC4 -> HEBREW POINT HIRIQ
    '\u05b5'   #  0xC5 -> HEBREW POINT TSERE
    '\u05b6'   #  0xC6 -> HEBREW POINT SEGOL
    '\u05b7'   #  0xC7 -> HEBREW POINT PATAH
    '\u05b8'   #  0xC8 -> HEBREW POINT QAMATS
    '\u05b9'   #  0xC9 -> HEBREW POINT HOLAM
    '\ufffe'   #  0xCA -> UNDEFINED
    '\u05bb'   #  0xCB -> HEBREW POINT QUBUTS
    '\u05bc'   #  0xCC -> HEBREW POINT DAGESH OR MAPIQ
    '\u05bd'   #  0xCD -> HEBREW POINT METEG
    '\u05be'   #  0xCE -> HEBREW PUNCTUATION MAQAF
    '\u05bf'   #  0xCF -> HEBREW POINT RAFE
    '\u05c0'   #  0xD0 -> HEBREW PUNCTUATION PASEQ
    '\u05c1'   #  0xD1 -> HEBREW POINT SHIN DOT
    '\u05c2'   #  0xD2 -> HEBREW POINT SIN DOT
    '\u05c3'   #  0xD3 -> HEBREW PUNCTUATION SOF PASUQ
    '\u05f0'   #  0xD4 -> HEBREW LIGATURE YIDDISH DOUBLE VAV
    '\u05f1'   #  0xD5 -> HEBREW LIGATURE YIDDISH VAV YOD
    '\u05f2'   #  0xD6 -> HEBREW LIGATURE YIDDISH DOUBLE YOD
    '\u05f3'   #  0xD7 -> HEBREW PUNCTUATION GERESH
    '\u05f4'   #  0xD8 -> HEBREW PUNCTUATION GERSHAYIM
    '\ufffe'   #  0xD9 -> UNDEFINED
    '\ufffe'   #  0xDA -> UNDEFINED
    '\ufffe'   #  0xDB -> UNDEFINED
    '\ufffe'   #  0xDC -> UNDEFINED
    '\ufffe'   #  0xDD -> UNDEFINED
    '\ufffe'   #  0xDE -> UNDEFINED
    '\ufffe'   #  0xDF -> UNDEFINED
    '\u05d0'   #  0xE0 -> HEBREW LETTER ALEF
    '\u05d1'   #  0xE1 -> HEBREW LETTER BET
    '\u05d2'   #  0xE2 -> HEBREW LETTER GIMEL
    '\u05d3'   #  0xE3 -> HEBREW LETTER DALET
    '\u05d4'   #  0xE4 -> HEBREW LETTER HE
    '\u05d5'   #  0xE5 -> HEBREW LETTER VAV
    '\u05d6'   #  0xE6 -> HEBREW LETTER ZAYIN
    '\u05d7'   #  0xE7 -> HEBREW LETTER HET
    '\u05d8'   #  0xE8 -> HEBREW LETTER TET
    '\u05d9'   #  0xE9 -> HEBREW LETTER YOD
    '\u05da'   #  0xEA -> HEBREW LETTER FINAL KAF
    '\u05db'   #  0xEB -> HEBREW LETTER KAF
    '\u05dc'   #  0xEC -> HEBREW LETTER LAMED
    '\u05dd'   #  0xED -> HEBREW LETTER FINAL MEM
    '\u05de'   #  0xEE -> HEBREW LETTER MEM
    '\u05df'   #  0xEF -> HEBREW LETTER FINAL NUN
    '\u05e0'   #  0xF0 -> HEBREW LETTER NUN
    '\u05e1'   #  0xF1 -> HEBREW LETTER SAMEKH
    '\u05e2'   #  0xF2 -> HEBREW LETTER AYIN
    '\u05e3'   #  0xF3 -> HEBREW LETTER FINAL PE
    '\u05e4'   #  0xF4 -> HEBREW LETTER PE
    '\u05e5'   #  0xF5 -> HEBREW LETTER FINAL TSADI
    '\u05e6'   #  0xF6 -> HEBREW LETTER TSADI
    '\u05e7'   #  0xF7 -> HEBREW LETTER QOF
    '\u05e8'   #  0xF8 -> HEBREW LETTER RESH
    '\u05e9'   #  0xF9 -> HEBREW LETTER SHIN
    '\u05ea'   #  0xFA -> HEBREW LETTER TAV
    '\ufffe'   #  0xFB -> UNDEFINED
    '\ufffe'   #  0xFC -> UNDEFINED
    '\u200e'   #  0xFD -> LEFT-TO-RIGHT MARK
    '\u200f'   #  0xFE -> RIGHT-TO-LEFT MARK
    '\ufffe'   #  0xFF -> UNDEFINED
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              """ Python Character Mapping Codec cp1256 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1256.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1256',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\u067e'   #  0x81 -> ARABIC LETTER PEH
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\u0679'   #  0x8A -> ARABIC LETTER TTEH
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE
    '\u0686'   #  0x8D -> ARABIC LETTER TCHEH
    '\u0698'   #  0x8E -> ARABIC LETTER JEH
    '\u0688'   #  0x8F -> ARABIC LETTER DDAL
    '\u06af'   #  0x90 -> ARABIC LETTER GAF
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\u06a9'   #  0x98 -> ARABIC LETTER KEHEH
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\u0691'   #  0x9A -> ARABIC LETTER RREH
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE
    '\u200c'   #  0x9D -> ZERO WIDTH NON-JOINER
    '\u200d'   #  0x9E -> ZERO WIDTH JOINER
    '\u06ba'   #  0x9F -> ARABIC LETTER NOON GHUNNA
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\u060c'   #  0xA1 -> ARABIC COMMA
    '\xa2'     #  0xA2 -> CENT SIGN
    '\xa3'     #  0xA3 -> POUND SIGN
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\xa5'     #  0xA5 -> YEN SIGN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\u06be'   #  0xAA -> ARABIC LETTER HEH DOACHASHMEE
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\xaf'     #  0xAF -> MACRON
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xb8'     #  0xB8 -> CEDILLA
    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
    '\u061b'   #  0xBA -> ARABIC SEMICOLON
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
    '\u061f'   #  0xBF -> ARABIC QUESTION MARK
    '\u06c1'   #  0xC0 -> ARABIC LETTER HEH GOAL
    '\u0621'   #  0xC1 -> ARABIC LETTER HAMZA
    '\u0622'   #  0xC2 -> ARABIC LETTER ALEF WITH MADDA ABOVE
    '\u0623'   #  0xC3 -> ARABIC LETTER ALEF WITH HAMZA ABOVE
    '\u0624'   #  0xC4 -> ARABIC LETTER WAW WITH HAMZA ABOVE
    '\u0625'   #  0xC5 -> ARABIC LETTER ALEF WITH HAMZA BELOW
    '\u0626'   #  0xC6 -> ARABIC LETTER YEH WITH HAMZA ABOVE
    '\u0627'   #  0xC7 -> ARABIC LETTER ALEF
    '\u0628'   #  0xC8 -> ARABIC LETTER BEH
    '\u0629'   #  0xC9 -> ARABIC LETTER TEH MARBUTA
    '\u062a'   #  0xCA -> ARABIC LETTER TEH
    '\u062b'   #  0xCB -> ARABIC LETTER THEH
    '\u062c'   #  0xCC -> ARABIC LETTER JEEM
    '\u062d'   #  0xCD -> ARABIC LETTER HAH
    '\u062e'   #  0xCE -> ARABIC LETTER KHAH
    '\u062f'   #  0xCF -> ARABIC LETTER DAL
    '\u0630'   #  0xD0 -> ARABIC LETTER THAL
    '\u0631'   #  0xD1 -> ARABIC LETTER REH
    '\u0632'   #  0xD2 -> ARABIC LETTER ZAIN
    '\u0633'   #  0xD3 -> ARABIC LETTER SEEN
    '\u0634'   #  0xD4 -> ARABIC LETTER SHEEN
    '\u0635'   #  0xD5 -> ARABIC LETTER SAD
    '\u0636'   #  0xD6 -> ARABIC LETTER DAD
    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
    '\u0637'   #  0xD8 -> ARABIC LETTER TAH
    '\u0638'   #  0xD9 -> ARABIC LETTER ZAH
    '\u0639'   #  0xDA -> ARABIC LETTER AIN
    '\u063a'   #  0xDB -> ARABIC LETTER GHAIN
    '\u0640'   #  0xDC -> ARABIC TATWEEL
    '\u0641'   #  0xDD -> ARABIC LETTER FEH
    '\u0642'   #  0xDE -> ARABIC LETTER QAF
    '\u0643'   #  0xDF -> ARABIC LETTER KAF
    '\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE
    '\u0644'   #  0xE1 -> ARABIC LETTER LAM
    '\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\u0645'   #  0xE3 -> ARABIC LETTER MEEM
    '\u0646'   #  0xE4 -> ARABIC LETTER NOON
    '\u0647'   #  0xE5 -> ARABIC LETTER HEH
    '\u0648'   #  0xE6 -> ARABIC LETTER WAW
    '\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE
    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS
    '\u0649'   #  0xEC -> ARABIC LETTER ALEF MAKSURA
    '\u064a'   #  0xED -> ARABIC LETTER YEH
    '\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS
    '\u064b'   #  0xF0 -> ARABIC FATHATAN
    '\u064c'   #  0xF1 -> ARABIC DAMMATAN
    '\u064d'   #  0xF2 -> ARABIC KASRATAN
    '\u064e'   #  0xF3 -> ARABIC FATHA
    '\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\u064f'   #  0xF5 -> ARABIC DAMMA
    '\u0650'   #  0xF6 -> ARABIC KASRA
    '\xf7'     #  0xF7 -> DIVISION SIGN
    '\u0651'   #  0xF8 -> ARABIC SHADDA
    '\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE
    '\u0652'   #  0xFA -> ARABIC SUKUN
    '\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\u200e'   #  0xFD -> LEFT-TO-RIGHT MARK
    '\u200f'   #  0xFE -> RIGHT-TO-LEFT MARK
    '\u06d2'   #  0xFF -> ARABIC LETTER YEH BARREE
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """ Python Character Mapping Codec cp1257 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1257.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1257',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\ufffe'   #  0x83 -> UNDEFINED
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\ufffe'   #  0x88 -> UNDEFINED
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\ufffe'   #  0x8A -> UNDEFINED
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\ufffe'   #  0x8C -> UNDEFINED
    '\xa8'     #  0x8D -> DIAERESIS
    '\u02c7'   #  0x8E -> CARON
    '\xb8'     #  0x8F -> CEDILLA
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\ufffe'   #  0x98 -> UNDEFINED
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\ufffe'   #  0x9A -> UNDEFINED
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\ufffe'   #  0x9C -> UNDEFINED
    '\xaf'     #  0x9D -> MACRON
    '\u02db'   #  0x9E -> OGONEK
    '\ufffe'   #  0x9F -> UNDEFINED
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\ufffe'   #  0xA1 -> UNDEFINED
    '\xa2'     #  0xA2 -> CENT SIGN
    '\xa3'     #  0xA3 -> POUND SIGN
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\ufffe'   #  0xA5 -> UNDEFINED
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xd8'     #  0xA8 -> LATIN CAPITAL LETTER O WITH STROKE
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\u0156'   #  0xAA -> LATIN CAPITAL LETTER R WITH CEDILLA
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\xc6'     #  0xAF -> LATIN CAPITAL LETTER AE
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xf8'     #  0xB8 -> LATIN SMALL LETTER O WITH STROKE
    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
    '\u0157'   #  0xBA -> LATIN SMALL LETTER R WITH CEDILLA
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
    '\xe6'     #  0xBF -> LATIN SMALL LETTER AE
    '\u0104'   #  0xC0 -> LATIN CAPITAL LETTER A WITH OGONEK
    '\u012e'   #  0xC1 -> LATIN CAPITAL LETTER I WITH OGONEK
    '\u0100'   #  0xC2 -> LATIN CAPITAL LETTER A WITH MACRON
    '\u0106'   #  0xC3 -> LATIN CAPITAL LETTER C WITH ACUTE
    '\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\u0118'   #  0xC6 -> LATIN CAPITAL LETTER E WITH OGONEK
    '\u0112'   #  0xC7 -> LATIN CAPITAL LETTER E WITH MACRON
    '\u010c'   #  0xC8 -> LATIN CAPITAL LETTER C WITH CARON
    '\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\u0179'   #  0xCA -> LATIN CAPITAL LETTER Z WITH ACUTE
    '\u0116'   #  0xCB -> LATIN CAPITAL LETTER E WITH DOT ABOVE
    '\u0122'   #  0xCC -> LATIN CAPITAL LETTER G WITH CEDILLA
    '\u0136'   #  0xCD -> LATIN CAPITAL LETTER K WITH CEDILLA
    '\u012a'   #  0xCE -> LATIN CAPITAL LETTER I WITH MACRON
    '\u013b'   #  0xCF -> LATIN CAPITAL LETTER L WITH CEDILLA
    '\u0160'   #  0xD0 -> LATIN CAPITAL LETTER S WITH CARON
    '\u0143'   #  0xD1 -> LATIN CAPITAL LETTER N WITH ACUTE
    '\u0145'   #  0xD2 -> LATIN CAPITAL LETTER N WITH CEDILLA
    '\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE
    '\u014c'   #  0xD4 -> LATIN CAPITAL LETTER O WITH MACRON
    '\xd5'     #  0xD5 -> LATIN CAPITAL LETTER O WITH TILDE
    '\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
    '\u0172'   #  0xD8 -> LATIN CAPITAL LETTER U WITH OGONEK
    '\u0141'   #  0xD9 -> LATIN CAPITAL LETTER L WITH STROKE
    '\u015a'   #  0xDA -> LATIN CAPITAL LETTER S WITH ACUTE
    '\u016a'   #  0xDB -> LATIN CAPITAL LETTER U WITH MACRON
    '\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\u017b'   #  0xDD -> LATIN CAPITAL LETTER Z WITH DOT ABOVE
    '\u017d'   #  0xDE -> LATIN CAPITAL LETTER Z WITH CARON
    '\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S
    '\u0105'   #  0xE0 -> LATIN SMALL LETTER A WITH OGONEK
    '\u012f'   #  0xE1 -> LATIN SMALL LETTER I WITH OGONEK
    '\u0101'   #  0xE2 -> LATIN SMALL LETTER A WITH MACRON
    '\u0107'   #  0xE3 -> LATIN SMALL LETTER C WITH ACUTE
    '\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\u0119'   #  0xE6 -> LATIN SMALL LETTER E WITH OGONEK
    '\u0113'   #  0xE7 -> LATIN SMALL LETTER E WITH MACRON
    '\u010d'   #  0xE8 -> LATIN SMALL LETTER C WITH CARON
    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
    '\u017a'   #  0xEA -> LATIN SMALL LETTER Z WITH ACUTE
    '\u0117'   #  0xEB -> LATIN SMALL LETTER E WITH DOT ABOVE
    '\u0123'   #  0xEC -> LATIN SMALL LETTER G WITH CEDILLA
    '\u0137'   #  0xED -> LATIN SMALL LETTER K WITH CEDILLA
    '\u012b'   #  0xEE -> LATIN SMALL LETTER I WITH MACRON
    '\u013c'   #  0xEF -> LATIN SMALL LETTER L WITH CEDILLA
    '\u0161'   #  0xF0 -> LATIN SMALL LETTER S WITH CARON
    '\u0144'   #  0xF1 -> LATIN SMALL LETTER N WITH ACUTE
    '\u0146'   #  0xF2 -> LATIN SMALL LETTER N WITH CEDILLA
    '\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE
    '\u014d'   #  0xF4 -> LATIN SMALL LETTER O WITH MACRON
    '\xf5'     #  0xF5 -> LATIN SMALL LETTER O WITH TILDE
    '\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf7'     #  0xF7 -> DIVISION SIGN
    '\u0173'   #  0xF8 -> LATIN SMALL LETTER U WITH OGONEK
    '\u0142'   #  0xF9 -> LATIN SMALL LETTER L WITH STROKE
    '\u015b'   #  0xFA -> LATIN SMALL LETTER S WITH ACUTE
    '\u016b'   #  0xFB -> LATIN SMALL LETTER U WITH MACRON
    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\u017c'   #  0xFD -> LATIN SMALL LETTER Z WITH DOT ABOVE
    '\u017e'   #  0xFE -> LATIN SMALL LETTER Z WITH CARON
    '\u02d9'   #  0xFF -> DOT ABOVE
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """ Python Character Mapping Codec cp1258 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1258.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp1258',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'     #  0x00 -> NULL
    '\x01'     #  0x01 -> START OF HEADING
    '\x02'     #  0x02 -> START OF TEXT
    '\x03'     #  0x03 -> END OF TEXT
    '\x04'     #  0x04 -> END OF TRANSMISSION
    '\x05'     #  0x05 -> ENQUIRY
    '\x06'     #  0x06 -> ACKNOWLEDGE
    '\x07'     #  0x07 -> BELL
    '\x08'     #  0x08 -> BACKSPACE
    '\t'       #  0x09 -> HORIZONTAL TABULATION
    '\n'       #  0x0A -> LINE FEED
    '\x0b'     #  0x0B -> VERTICAL TABULATION
    '\x0c'     #  0x0C -> FORM FEED
    '\r'       #  0x0D -> CARRIAGE RETURN
    '\x0e'     #  0x0E -> SHIFT OUT
    '\x0f'     #  0x0F -> SHIFT IN
    '\x10'     #  0x10 -> DATA LINK ESCAPE
    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x18 -> CANCEL
    '\x19'     #  0x19 -> END OF MEDIUM
    '\x1a'     #  0x1A -> SUBSTITUTE
    '\x1b'     #  0x1B -> ESCAPE
    '\x1c'     #  0x1C -> FILE SEPARATOR
    '\x1d'     #  0x1D -> GROUP SEPARATOR
    '\x1e'     #  0x1E -> RECORD SEPARATOR
    '\x1f'     #  0x1F -> UNIT SEPARATOR
    ' '        #  0x20 -> SPACE
    '!'        #  0x21 -> EXCLAMATION MARK
    '"'        #  0x22 -> QUOTATION MARK
    '#'        #  0x23 -> NUMBER SIGN
    '$'        #  0x24 -> DOLLAR SIGN
    '%'        #  0x25 -> PERCENT SIGN
    '&'        #  0x26 -> AMPERSAND
    "'"        #  0x27 -> APOSTROPHE
    '('        #  0x28 -> LEFT PARENTHESIS
    ')'        #  0x29 -> RIGHT PARENTHESIS
    '*'        #  0x2A -> ASTERISK
    '+'        #  0x2B -> PLUS SIGN
    ','        #  0x2C -> COMMA
    '-'        #  0x2D -> HYPHEN-MINUS
    '.'        #  0x2E -> FULL STOP
    '/'        #  0x2F -> SOLIDUS
    '0'        #  0x30 -> DIGIT ZERO
    '1'        #  0x31 -> DIGIT ONE
    '2'        #  0x32 -> DIGIT TWO
    '3'        #  0x33 -> DIGIT THREE
    '4'        #  0x34 -> DIGIT FOUR
    '5'        #  0x35 -> DIGIT FIVE
    '6'        #  0x36 -> DIGIT SIX
    '7'        #  0x37 -> DIGIT SEVEN
    '8'        #  0x38 -> DIGIT EIGHT
    '9'        #  0x39 -> DIGIT NINE
    ':'        #  0x3A -> COLON
    ';'        #  0x3B -> SEMICOLON
    '<'        #  0x3C -> LESS-THAN SIGN
    '='        #  0x3D -> EQUALS SIGN
    '>'        #  0x3E -> GREATER-THAN SIGN
    '?'        #  0x3F -> QUESTION MARK
    '@'        #  0x40 -> COMMERCIAL AT
    'A'        #  0x41 -> LATIN CAPITAL LETTER A
    'B'        #  0x42 -> LATIN CAPITAL LETTER B
    'C'        #  0x43 -> LATIN CAPITAL LETTER C
    'D'        #  0x44 -> LATIN CAPITAL LETTER D
    'E'        #  0x45 -> LATIN CAPITAL LETTER E
    'F'        #  0x46 -> LATIN CAPITAL LETTER F
    'G'        #  0x47 -> LATIN CAPITAL LETTER G
    'H'        #  0x48 -> LATIN CAPITAL LETTER H
    'I'        #  0x49 -> LATIN CAPITAL LETTER I
    'J'        #  0x4A -> LATIN CAPITAL LETTER J
    'K'        #  0x4B -> LATIN CAPITAL LETTER K
    'L'        #  0x4C -> LATIN CAPITAL LETTER L
    'M'        #  0x4D -> LATIN CAPITAL LETTER M
    'N'        #  0x4E -> LATIN CAPITAL LETTER N
    'O'        #  0x4F -> LATIN CAPITAL LETTER O
    'P'        #  0x50 -> LATIN CAPITAL LETTER P
    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
    'R'        #  0x52 -> LATIN CAPITAL LETTER R
    'S'        #  0x53 -> LATIN CAPITAL LETTER S
    'T'        #  0x54 -> LATIN CAPITAL LETTER T
    'U'        #  0x55 -> LATIN CAPITAL LETTER U
    'V'        #  0x56 -> LATIN CAPITAL LETTER V
    'W'        #  0x57 -> LATIN CAPITAL LETTER W
    'X'        #  0x58 -> LATIN CAPITAL LETTER X
    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
    '['        #  0x5B -> LEFT SQUARE BRACKET
    '\\'       #  0x5C -> REVERSE SOLIDUS
    ']'        #  0x5D -> RIGHT SQUARE BRACKET
    '^'        #  0x5E -> CIRCUMFLEX ACCENT
    '_'        #  0x5F -> LOW LINE
    '`'        #  0x60 -> GRAVE ACCENT
    'a'        #  0x61 -> LATIN SMALL LETTER A
    'b'        #  0x62 -> LATIN SMALL LETTER B
    'c'        #  0x63 -> LATIN SMALL LETTER C
    'd'        #  0x64 -> LATIN SMALL LETTER D
    'e'        #  0x65 -> LATIN SMALL LETTER E
    'f'        #  0x66 -> LATIN SMALL LETTER F
    'g'        #  0x67 -> LATIN SMALL LETTER G
    'h'        #  0x68 -> LATIN SMALL LETTER H
    'i'        #  0x69 -> LATIN SMALL LETTER I
    'j'        #  0x6A -> LATIN SMALL LETTER J
    'k'        #  0x6B -> LATIN SMALL LETTER K
    'l'        #  0x6C -> LATIN SMALL LETTER L
    'm'        #  0x6D -> LATIN SMALL LETTER M
    'n'        #  0x6E -> LATIN SMALL LETTER N
    'o'        #  0x6F -> LATIN SMALL LETTER O
    'p'        #  0x70 -> LATIN SMALL LETTER P
    'q'        #  0x71 -> LATIN SMALL LETTER Q
    'r'        #  0x72 -> LATIN SMALL LETTER R
    's'        #  0x73 -> LATIN SMALL LETTER S
    't'        #  0x74 -> LATIN SMALL LETTER T
    'u'        #  0x75 -> LATIN SMALL LETTER U
    'v'        #  0x76 -> LATIN SMALL LETTER V
    'w'        #  0x77 -> LATIN SMALL LETTER W
    'x'        #  0x78 -> LATIN SMALL LETTER X
    'y'        #  0x79 -> LATIN SMALL LETTER Y
    'z'        #  0x7A -> LATIN SMALL LETTER Z
    '{'        #  0x7B -> LEFT CURLY BRACKET
    '|'        #  0x7C -> VERTICAL LINE
    '}'        #  0x7D -> RIGHT CURLY BRACKET
    '~'        #  0x7E -> TILDE
    '\x7f'     #  0x7F -> DELETE
    '\u20ac'   #  0x80 -> EURO SIGN
    '\ufffe'   #  0x81 -> UNDEFINED
    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
    '\u2020'   #  0x86 -> DAGGER
    '\u2021'   #  0x87 -> DOUBLE DAGGER
    '\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT
    '\u2030'   #  0x89 -> PER MILLE SIGN
    '\ufffe'   #  0x8A -> UNDEFINED
    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    '\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE
    '\ufffe'   #  0x8D -> UNDEFINED
    '\ufffe'   #  0x8E -> UNDEFINED
    '\ufffe'   #  0x8F -> UNDEFINED
    '\ufffe'   #  0x90 -> UNDEFINED
    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
    '\u2022'   #  0x95 -> BULLET
    '\u2013'   #  0x96 -> EN DASH
    '\u2014'   #  0x97 -> EM DASH
    '\u02dc'   #  0x98 -> SMALL TILDE
    '\u2122'   #  0x99 -> TRADE MARK SIGN
    '\ufffe'   #  0x9A -> UNDEFINED
    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    '\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE
    '\ufffe'   #  0x9D -> UNDEFINED
    '\ufffe'   #  0x9E -> UNDEFINED
    '\u0178'   #  0x9F -> LATIN CAPITAL LETTER Y WITH DIAERESIS
    '\xa0'     #  0xA0 -> NO-BREAK SPACE
    '\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK
    '\xa2'     #  0xA2 -> CENT SIGN
    '\xa3'     #  0xA3 -> POUND SIGN
    '\xa4'     #  0xA4 -> CURRENCY SIGN
    '\xa5'     #  0xA5 -> YEN SIGN
    '\xa6'     #  0xA6 -> BROKEN BAR
    '\xa7'     #  0xA7 -> SECTION SIGN
    '\xa8'     #  0xA8 -> DIAERESIS
    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
    '\xaa'     #  0xAA -> FEMININE ORDINAL INDICATOR
    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xac'     #  0xAC -> NOT SIGN
    '\xad'     #  0xAD -> SOFT HYPHEN
    '\xae'     #  0xAE -> REGISTERED SIGN
    '\xaf'     #  0xAF -> MACRON
    '\xb0'     #  0xB0 -> DEGREE SIGN
    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
    '\xb4'     #  0xB4 -> ACUTE ACCENT
    '\xb5'     #  0xB5 -> MICRO SIGN
    '\xb6'     #  0xB6 -> PILCROW SIGN
    '\xb7'     #  0xB7 -> MIDDLE DOT
    '\xb8'     #  0xB8 -> CEDILLA
    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
    '\xba'     #  0xBA -> MASCULINE ORDINAL INDICATOR
    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
    '\xbf'     #  0xBF -> INVERTED QUESTION MARK
    '\xc0'     #  0xC0 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '\u0102'   #  0xC3 -> LATIN CAPITAL LETTER A WITH BREVE
    '\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc6'     #  0xC6 -> LATIN CAPITAL LETTER AE
    '\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xc8'     #  0xC8 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'     #  0xCA -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\u0300'   #  0xCC -> COMBINING GRAVE ACCENT
    '\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'     #  0xCF -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\u0110'   #  0xD0 -> LATIN CAPITAL LETTER D WITH STROKE
    '\xd1'     #  0xD1 -> LATIN CAPITAL LETTER N WITH TILDE
    '\u0309'   #  0xD2 -> COMBINING HOOK ABOVE
    '\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\u01a0'   #  0xD5 -> LATIN CAPITAL LETTER O WITH HORN
    '\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
    '\xd8'     #  0xD8 -> LATIN CAPITAL LETTER O WITH STROKE
    '\xd9'     #  0xD9 -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE
    '\xdb'     #  0xDB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    '\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\u01af'   #  0xDD -> LATIN CAPITAL LETTER U WITH HORN
    '\u0303'   #  0xDE -> COMBINING TILDE
    '\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S
    '\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\u0103'   #  0xE3 -> LATIN SMALL LETTER A WITH BREVE
    '\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe6'     #  0xE6 -> LATIN SMALL LETTER AE
    '\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE
    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS
    '\u0301'   #  0xEC -> COMBINING ACUTE ACCENT
    '\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS
    '\u0111'   #  0xF0 -> LATIN SMALL LETTER D WITH STROKE
    '\xf1'     #  0xF1 -> LATIN SMALL LETTER N WITH TILDE
    '\u0323'   #  0xF2 -> COMBINING DOT BELOW
    '\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE
    '\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\u01a1'   #  0xF5 -> LATIN SMALL LETTER O WITH HORN
    '\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf7'     #  0xF7 -> DIVISION SIGN
    '\xf8'     #  0xF8 -> LATIN SMALL LETTER O WITH STROKE
    '\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE
    '\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
    '\u01b0'   #  0xFD -> LATIN SMALL LETTER U WITH HORN
    '\u20ab'   #  0xFE -> DONG SIGN
    '\xff'     #  0xFF -> LATIN SMALL LETTER Y WITH DIAERESIS
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """ Python Character Mapping Codec cp273 generated from 'python-mappings/CP273.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_table)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_table)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp273',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )


### Decoding Table

decoding_table = (
    '\x00'      #  0x00 -> NULL (NUL)
    '\x01'      #  0x01 -> START OF HEADING (SOH)
    '\x02'      #  0x02 -> START OF TEXT (STX)
    '\x03'      #  0x03 -> END OF TEXT (ETX)
    '\x9c'      #  0x04 -> STRING TERMINATOR (ST)
    '\t'        #  0x05 -> CHARACTER TABULATION (HT)
    '\x86'      #  0x06 -> START OF SELECTED AREA (SSA)
    '\x7f'      #  0x07 -> DELETE (DEL)
    '\x97'      #  0x08 -> END OF GUARDED AREA (EPA)
    '\x8d'      #  0x09 -> REVERSE LINE FEED (RI)
    '\x8e'      #  0x0A -> SINGLE-SHIFT TWO (SS2)
    '\x0b'      #  0x0B -> LINE TABULATION (VT)
    '\x0c'      #  0x0C -> FORM FEED (FF)
    '\r'        #  0x0D -> CARRIAGE RETURN (CR)
    '\x0e'      #  0x0E -> SHIFT OUT (SO)
    '\x0f'      #  0x0F -> SHIFT IN (SI)
    '\x10'      #  0x10 -> DATALINK ESCAPE (DLE)
    '\x11'      #  0x11 -> DEVICE CONTROL ONE (DC1)
    '\x12'      #  0x12 -> DEVICE CONTROL TWO (DC2)
    '\x13'      #  0x13 -> DEVICE CONTROL THREE (DC3)
    '\x9d'      #  0x14 -> OPERATING SYSTEM COMMAND (OSC)
    '\x85'      #  0x15 -> NEXT LINE (NEL)
    '\x08'      #  0x16 -> BACKSPACE (BS)
    '\x87'      #  0x17 -> END OF SELECTED AREA (ESA)
    '\x18'      #  0x18 -> CANCEL (CAN)
    '\x19'      #  0x19 -> END OF MEDIUM (EM)
    '\x92'      #  0x1A -> PRIVATE USE TWO (PU2)
    '\x8f'      #  0x1B -> SINGLE-SHIFT THREE (SS3)
    '\x1c'      #  0x1C -> FILE SEPARATOR (IS4)
    '\x1d'      #  0x1D -> GROUP SEPARATOR (IS3)
    '\x1e'      #  0x1E -> RECORD SEPARATOR (IS2)
    '\x1f'      #  0x1F -> UNIT SEPARATOR (IS1)
    '\x80'      #  0x20 -> PADDING CHARACTER (PAD)
    '\x81'      #  0x21 -> HIGH OCTET PRESET (HOP)
    '\x82'      #  0x22 -> BREAK PERMITTED HERE (BPH)
    '\x83'      #  0x23 -> NO BREAK HERE (NBH)
    '\x84'      #  0x24 -> INDEX (IND)
    '\n'        #  0x25 -> LINE FEED (LF)
    '\x17'      #  0x26 -> END OF TRANSMISSION BLOCK (ETB)
    '\x1b'      #  0x27 -> ESCAPE (ESC)
    '\x88'      #  0x28 -> CHARACTER TABULATION SET (HTS)
    '\x89'      #  0x29 -> CHARACTER TABULATION WITH JUSTIFICATION (HTJ)
    '\x8a'      #  0x2A -> LINE TABULATION SET (VTS)
    '\x8b'      #  0x2B -> PARTIAL LINE FORWARD (PLD)
    '\x8c'      #  0x2C -> PARTIAL LINE BACKWARD (PLU)
    '\x05'      #  0x2D -> ENQUIRY (ENQ)
    '\x06'      #  0x2E -> ACKNOWLEDGE (ACK)
    '\x07'      #  0x2F -> BELL (BEL)
    '\x90'      #  0x30 -> DEVICE CONTROL STRING (DCS)
    '\x91'      #  0x31 -> PRIVATE USE ONE (PU1)
    '\x16'      #  0x32 -> SYNCHRONOUS IDLE (SYN)
    '\x93'      #  0x33 -> SET TRANSMIT STATE (STS)
    '\x94'      #  0x34 -> CANCEL CHARACTER (CCH)
    '\x95'      #  0x35 -> MESSAGE WAITING (MW)
    '\x96'      #  0x36 -> START OF GUARDED AREA (SPA)
    '\x04'      #  0x37 -> END OF TRANSMISSION (EOT)
    '\x98'      #  0x38 -> START OF STRING (SOS)
    '\x99'      #  0x39 -> SINGLE GRAPHIC CHARACTER INTRODUCER (SGCI)
    '\x9a'      #  0x3A -> SINGLE CHARACTER INTRODUCER (SCI)
    '\x9b'      #  0x3B -> CONTROL SEQUENCE INTRODUCER (CSI)
    '\x14'      #  0x3C -> DEVICE CONTROL FOUR (DC4)
    '\x15'      #  0x3D -> NEGATIVE ACKNOWLEDGE (NAK)
    '\x9e'      #  0x3E -> PRIVACY MESSAGE (PM)
    '\x1a'      #  0x3F -> SUBSTITUTE (SUB)
    ' '         #  0x40 -> SPACE
    '\xa0'      #  0x41 -> NO-BREAK SPACE
    '\xe2'      #  0x42 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '{'         #  0x43 -> LEFT CURLY BRACKET
    '\xe0'      #  0x44 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe1'      #  0x45 -> LATIN SMALL LETTER A WITH ACUTE
    '\xe3'      #  0x46 -> LATIN SMALL LETTER A WITH TILDE
    '\xe5'      #  0x47 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe7'      #  0x48 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xf1'      #  0x49 -> LATIN SMALL LETTER N WITH TILDE
    '\xc4'      #  0x4A -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '.'         #  0x4B -> FULL STOP
    '<'         #  0x4C -> LESS-THAN SIGN
    '('         #  0x4D -> LEFT PARENTHESIS
    '+'         #  0x4E -> PLUS SIGN
    '!'         #  0x4F -> EXCLAMATION MARK
    '&'         #  0x50 -> AMPERSAND
    '\xe9'      #  0x51 -> LATIN SMALL LETTER E WITH ACUTE
    '\xea'      #  0x52 -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'      #  0x53 -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xe8'      #  0x54 -> LATIN SMALL LETTER E WITH GRAVE
    '\xed'      #  0x55 -> LATIN SMALL LETTER I WITH ACUTE
    '\xee'      #  0x56 -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xef'      #  0x57 -> LATIN SMALL LETTER I WITH DIAERESIS
    '\xec'      #  0x58 -> LATIN SMALL LETTER I WITH GRAVE
    '~'         #  0x59 -> TILDE
    '\xdc'      #  0x5A -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '$'         #  0x5B -> DOLLAR SIGN
    '*'         #  0x5C -> ASTERISK
    ')'         #  0x5D -> RIGHT PARENTHESIS
    ';'         #  0x5E -> SEMICOLON
    '^'         #  0x5F -> CIRCUMFLEX ACCENT
    '-'         #  0x60 -> HYPHEN-MINUS
    '/'         #  0x61 -> SOLIDUS
    '\xc2'      #  0x62 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
    '['         #  0x63 -> LEFT SQUARE BRACKET
    '\xc0'      #  0x64 -> LATIN CAPITAL LETTER A WITH GRAVE
    '\xc1'      #  0x65 -> LATIN CAPITAL LETTER A WITH ACUTE
    '\xc3'      #  0x66 -> LATIN CAPITAL LETTER A WITH TILDE
    '\xc5'      #  0x67 -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc7'      #  0x68 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xd1'      #  0x69 -> LATIN CAPITAL LETTER N WITH TILDE
    '\xf6'      #  0x6A -> LATIN SMALL LETTER O WITH DIAERESIS
    ','         #  0x6B -> COMMA
    '%'         #  0x6C -> PERCENT SIGN
    '_'         #  0x6D -> LOW LINE
    '>'         #  0x6E -> GREATER-THAN SIGN
    '?'         #  0x6F -> QUESTION MARK
    '\xf8'      #  0x70 -> LATIN SMALL LETTER O WITH STROKE
    '\xc9'      #  0x71 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xca'      #  0x72 -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
    '\xcb'      #  0x73 -> LATIN CAPITAL LETTER E WITH DIAERESIS
    '\xc8'      #  0x74 -> LATIN CAPITAL LETTER E WITH GRAVE
    '\xcd'      #  0x75 -> LATIN CAPITAL LETTER I WITH ACUTE
    '\xce'      #  0x76 -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
    '\xcf'      #  0x77 -> LATIN CAPITAL LETTER I WITH DIAERESIS
    '\xcc'      #  0x78 -> LATIN CAPITAL LETTER I WITH GRAVE
    '`'         #  0x79 -> GRAVE ACCENT
    ':'         #  0x7A -> COLON
    '#'         #  0x7B -> NUMBER SIGN
    '\xa7'      #  0x7C -> SECTION SIGN
    "'"         #  0x7D -> APOSTROPHE
    '='         #  0x7E -> EQUALS SIGN
    '"'         #  0x7F -> QUOTATION MARK
    '\xd8'      #  0x80 -> LATIN CAPITAL LETTER O WITH STROKE
    'a'         #  0x81 -> LATIN SMALL LETTER A
    'b'         #  0x82 -> LATIN SMALL LETTER B
    'c'         #  0x83 -> LATIN SMALL LETTER C
    'd'         #  0x84 -> LATIN SMALL LETTER D
    'e'         #  0x85 -> LATIN SMALL LETTER E
    'f'         #  0x86 -> LATIN SMALL LETTER F
    'g'         #  0x87 -> LATIN SMALL LETTER G
    'h'         #  0x88 -> LATIN SMALL LETTER H
    'i'         #  0x89 -> LATIN SMALL LETTER I
    '\xab'      #  0x8A -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xbb'      #  0x8B -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    '\xf0'      #  0x8C -> LATIN SMALL LETTER ETH (Icelandic)
    '\xfd'      #  0x8D -> LATIN SMALL LETTER Y WITH ACUTE
    '\xfe'      #  0x8E -> LATIN SMALL LETTER THORN (Icelandic)
    '\xb1'      #  0x8F -> PLUS-MINUS SIGN
    '\xb0'      #  0x90 -> DEGREE SIGN
    'j'         #  0x91 -> LATIN SMALL LETTER J
    'k'         #  0x92 -> LATIN SMALL LETTER K
    'l'         #  0x93 -> LATIN SMALL LETTER L
    'm'         #  0x94 -> LATIN SMALL LETTER M
    'n'         #  0x95 -> LATIN SMALL LETTER N
    'o'         #  0x96 -> LATIN SMALL LETTER O
    'p'         #  0x97 -> LATIN SMALL LETTER P
    'q'         #  0x98 -> LATIN SMALL LETTER Q
    'r'         #  0x99 -> LATIN SMALL LETTER R
    '\xaa'      #  0x9A -> FEMININE ORDINAL INDICATOR
    '\xba'      #  0x9B -> MASCULINE ORDINAL INDICATOR
    '\xe6'      #  0x9C -> LATIN SMALL LETTER AE
    '\xb8'      #  0x9D -> CEDILLA
    '\xc6'      #  0x9E -> LATIN CAPITAL LETTER AE
    '\xa4'      #  0x9F -> CURRENCY SIGN
    '\xb5'      #  0xA0 -> MICRO SIGN
    '\xdf'      #  0xA1 -> LATIN SMALL LETTER SHARP S (German)
    's'         #  0xA2 -> LATIN SMALL LETTER S
    't'         #  0xA3 -> LATIN SMALL LETTER T
    'u'         #  0xA4 -> LATIN SMALL LETTER U
    'v'         #  0xA5 -> LATIN SMALL LETTER V
    'w'         #  0xA6 -> LATIN SMALL LETTER W
    'x'         #  0xA7 -> LATIN SMALL LETTER X
    'y'         #  0xA8 -> LATIN SMALL LETTER Y
    'z'         #  0xA9 -> LATIN SMALL LETTER Z
    '\xa1'      #  0xAA -> INVERTED EXCLAMATION MARK
    '\xbf'      #  0xAB -> INVERTED QUESTION MARK
    '\xd0'      #  0xAC -> LATIN CAPITAL LETTER ETH (Icelandic)
    '\xdd'      #  0xAD -> LATIN CAPITAL LETTER Y WITH ACUTE
    '\xde'      #  0xAE -> LATIN CAPITAL LETTER THORN (Icelandic)
    '\xae'      #  0xAF -> REGISTERED SIGN
    '\xa2'      #  0xB0 -> CENT SIGN
    '\xa3'      #  0xB1 -> POUND SIGN
    '\xa5'      #  0xB2 -> YEN SIGN
    '\xb7'      #  0xB3 -> MIDDLE DOT
    '\xa9'      #  0xB4 -> COPYRIGHT SIGN
    '@'         #  0xB5 -> COMMERCIAL AT
    '\xb6'      #  0xB6 -> PILCROW SIGN
    '\xbc'      #  0xB7 -> VULGAR FRACTION ONE QUARTER
    '\xbd'      #  0xB8 -> VULGAR FRACTION ONE HALF
    '\xbe'      #  0xB9 -> VULGAR FRACTION THREE QUARTERS
    '\xac'      #  0xBA -> NOT SIGN
    '|'         #  0xBB -> VERTICAL LINE
    '\u203e'    #  0xBC -> OVERLINE
    '\xa8'      #  0xBD -> DIAERESIS
    '\xb4'      #  0xBE -> ACUTE ACCENT
    '\xd7'      #  0xBF -> MULTIPLICATION SIGN
    '\xe4'      #  0xC0 -> LATIN SMALL LETTER A WITH DIAERESIS
    'A'         #  0xC1 -> LATIN CAPITAL LETTER A
    'B'         #  0xC2 -> LATIN CAPITAL LETTER B
    'C'         #  0xC3 -> LATIN CAPITAL LETTER C
    'D'         #  0xC4 -> LATIN CAPITAL LETTER D
    'E'         #  0xC5 -> LATIN CAPITAL LETTER E
    'F'         #  0xC6 -> LATIN CAPITAL LETTER F
    'G'         #  0xC7 -> LATIN CAPITAL LETTER G
    'H'         #  0xC8 -> LATIN CAPITAL LETTER H
    'I'         #  0xC9 -> LATIN CAPITAL LETTER I
    '\xad'      #  0xCA -> SOFT HYPHEN
    '\xf4'      #  0xCB -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\xa6'      #  0xCC -> BROKEN BAR
    '\xf2'      #  0xCD -> LATIN SMALL LETTER O WITH GRAVE
    '\xf3'      #  0xCE -> LATIN SMALL LETTER O WITH ACUTE
    '\xf5'      #  0xCF -> LATIN SMALL LETTER O WITH TILDE
    '\xfc'      #  0xD0 -> LATIN SMALL LETTER U WITH DIAERESIS
    'J'         #  0xD1 -> LATIN CAPITAL LETTER J
    'K'         #  0xD2 -> LATIN CAPITAL LETTER K
    'L'         #  0xD3 -> LATIN CAPITAL LETTER L
    'M'         #  0xD4 -> LATIN CAPITAL LETTER M
    'N'         #  0xD5 -> LATIN CAPITAL LETTER N
    'O'         #  0xD6 -> LATIN CAPITAL LETTER O
    'P'         #  0xD7 -> LATIN CAPITAL LETTER P
    'Q'         #  0xD8 -> LATIN CAPITAL LETTER Q
    'R'         #  0xD9 -> LATIN CAPITAL LETTER R
    '\xb9'      #  0xDA -> SUPERSCRIPT ONE
    '\xfb'      #  0xDB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '}'         #  0xDC -> RIGHT CURLY BRACKET
    '\xf9'      #  0xDD -> LATIN SMALL LETTER U WITH GRAVE
    '\xfa'      #  0xDE -> LATIN SMALL LETTER U WITH ACUTE
    '\xff'      #  0xDF -> LATIN SMALL LETTER Y WITH DIAERESIS
    '\xd6'      #  0xE0 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xf7'      #  0xE1 -> DIVISION SIGN
    'S'         #  0xE2 -> LATIN CAPITAL LETTER S
    'T'         #  0xE3 -> LATIN CAPITAL LETTER T
    'U'         #  0xE4 -> LATIN CAPITAL LETTER U
    'V'         #  0xE5 -> LATIN CAPITAL LETTER V
    'W'         #  0xE6 -> LATIN CAPITAL LETTER W
    'X'         #  0xE7 -> LATIN CAPITAL LETTER X
    'Y'         #  0xE8 -> LATIN CAPITAL LETTER Y
    'Z'         #  0xE9 -> LATIN CAPITAL LETTER Z
    '\xb2'      #  0xEA -> SUPERSCRIPT TWO
    '\xd4'      #  0xEB -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    '\\'        #  0xEC -> REVERSE SOLIDUS
    '\xd2'      #  0xED -> LATIN CAPITAL LETTER O WITH GRAVE
    '\xd3'      #  0xEE -> LATIN CAPITAL LETTER O WITH ACUTE
    '\xd5'      #  0xEF -> LATIN CAPITAL LETTER O WITH TILDE
    '0'         #  0xF0 -> DIGIT ZERO
    '1'         #  0xF1 -> DIGIT ONE
    '2'         #  0xF2 -> DIGIT TWO
    '3'         #  0xF3 -> DIGIT THREE
    '4'         #  0xF4 -> DIGIT FOUR
    '5'         #  0xF5 -> DIGIT FIVE
    '6'         #  0xF6 -> DIGIT SIX
    '7'         #  0xF7 -> DIGIT SEVEN
    '8'         #  0xF8 -> DIGIT EIGHT
    '9'         #  0xF9 -> DIGIT NINE
    '\xb3'      #  0xFA -> SUPERSCRIPT THREE
    '\xdb'      #  0xFB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    ']'         #  0xFC -> RIGHT SQUARE BRACKET
    '\xd9'      #  0xFD -> LATIN CAPITAL LETTER U WITH GRAVE
    '\xda'      #  0xFE -> LATIN CAPITAL LETTER U WITH ACUTE
    '\x9f'      #  0xFF -> APPLICATION PROGRAM COMMAND (APC)
)

### Encoding table
encoding_table=codecs.charmap_build(decoding_table)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """ Python Character Mapping Codec cp437 generated from 'VENDORS/MICSFT/PC/CP437.TXT' with gencodec.py.

"""#"

import codecs

### Codec APIs

class Codec(codecs.Codec):

    def encode(self,input,errors='strict'):
        return codecs.charmap_encode(input,errors,encoding_map)

    def decode(self,input,errors='strict'):
        return codecs.charmap_decode(input,errors,decoding_table)

class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        return codecs.charmap_encode(input,self.errors,encoding_map)[0]

class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        return codecs.charmap_decode(input,self.errors,decoding_table)[0]

class StreamWriter(Codec,codecs.StreamWriter):
    pass

class StreamReader(Codec,codecs.StreamReader):
    pass

### encodings module API

def getregentry():
    return codecs.CodecInfo(
        name='cp437',
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamreader=StreamReader,
        streamwriter=StreamWriter,
    )

### Decoding Map

decoding_map = codecs.make_identity_dict(range(256))
decoding_map.update({
    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA
    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS
    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE
    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX
    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS
    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE
    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE
    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA
    0x0088: 0x00ea,     #  LATIN SMALL LETTER E WITH CIRCUMFLEX
    0x0089: 0x00eb,     #  LATIN SMALL LETTER E WITH DIAERESIS
    0x008a: 0x00e8,     #  LATIN SMALL LETTER E WITH GRAVE
    0x008b: 0x00ef,     #  LATIN SMALL LETTER I WITH DIAERESIS
    0x008c: 0x00ee,     #  LATIN SMALL LETTER I WITH CIRCUMFLEX
    0x008d: 0x00ec,     #  LATIN SMALL LETTER I WITH GRAVE
    0x008e: 0x00c4,     #  LATIN CAPITAL LETTER A WITH DIAERESIS
    0x008f: 0x00c5,     #  LATIN CAPITAL LETTER A WITH RING ABOVE
    0x0090: 0x00c9,     #  LATIN CAPITAL LETTER E WITH ACUTE
    0x0091: 0x00e6,     #  LATIN SMALL LIGATURE AE
    0x0092: 0x00c6,     #  LATIN CAPITAL LIGATURE AE
    0x0093: 0x00f4,     #  LATIN SMALL LETTER O WITH CIRCUMFLEX
    0x0094: 0x00f6,     #  LATIN SMALL LETTER O WITH DIAERESIS
    0x0095: 0x00f2,     #  LATIN SMALL LETTER O WITH GRAVE
    0x0096: 0x00fb,     #  LATIN SMALL LETTER U WITH CIRCUMFLEX
    0x0097: 0x00f9,     #  LATIN SMALL LETTER U WITH GRAVE
    0x0098: 0x00ff,     #  LATIN SMALL LETTER Y WITH DIAERESIS
    0x0099: 0x00d6,     #  LATIN CAPITAL LETTER O WITH DIAERESIS
    0x009a: 0x00dc,     #  LATIN CAPITAL LETTER U WITH DIAERESIS
    0x009b: 0x00a2,     #  CENT SIGN
    0x009c: 0x00a3,     #  POUND SIGN
    0x009d: 0x00a5,     #  YEN SIGN
    0x009e: 0x20a7,     #  PESETA SIGN
    0x009f: 0x0192,     #  LATIN SMALL LETTER F WITH HOOK
    0x00a0: 0x00e1,     #  LATIN SMALL LETTER A WITH ACUTE
    0x00a1: 0x00ed,     #  LATIN SMALL LETTER I WITH ACUTE
    0x00a2: 0x00f3,     #  LATIN SMALL LETTER O WITH ACUTE
    0x00a3: 0x00fa,     #  LATIN SMALL LETTER U WITH ACUTE
    0x00a4: 0x00f1,     #  LATIN SMALL LETTER N WITH TILDE
    0x00a5: 0x00d1,     #  LATIN CAPITAL LETTER N WITH TILDE
    0x00a6: 0x00aa,     #  FEMININE ORDINAL INDICATOR
    0x00a7: 0x00ba,     #  MASCULINE ORDINAL INDICATOR
    0x00a8: 0x00bf,     #  INVERTED QUESTION MARK
    0x00a9: 0x2310,     #  REVERSED NOT SIGN
    0x00aa: 0x00ac,     #  NOT SIGN
    0x00ab: 0x00bd,     #  VULGAR FRACTION ONE HALF
    0x00ac: 0x00bc,     #  VULGAR FRACTION ONE QUARTER
    0x00ad: 0x00a1,     #  INVERTED EXCLAMATION MARK
    0x00ae: 0x00ab,     #  LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x00af: 0x00bb,     #  RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x00b0: 0x2591,     #  LIGHT SHADE
    0x00b1: 0x2592,     #  MEDIUM SHADE
    0x00b2: 0x2593,     #  DARK SHADE
    0x00b3: 0x2502,     #  BOX DRAWINGS LIGHT VERTICAL
    0x00b4: 0x2524,     #  BOX DRAWINGS LIGHT VERTICAL AND LEFT
    0x00b5: 0x2561,     #  BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
    0x00b6: 0x2562,     #  BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
    0x00b7: 0x2556,     #  BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
    0x00b8: 0x2555,     #  BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
    0x00b9: 0x2563,     #  BOX DRAWINGS DOUBLE VERTICAL AND LEFT
    0x00ba: 0x2551,     #  BOX DRAWINGS DOUBLE VERTICAL
    0x00bb: 0x2557,     #  BOX DRAWINGS DOUBLE DOWN AND LEFT
    0x00bc: 0x255d,     #  BOX DRAWINGS DOUBLE UP AND LEFT
    0x00bd: 0x255c,     #  BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
    0x00be: 0x255b,     #  BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
    0x00bf: 0x2510,     #  BOX DRAWINGS LIGHT DOWN AND LEFT
    0x00c0: 0x2514,     #  BOX DRAWINGS LIGHT UP AND RIGHT
    0x00c1: 0x2534,     #  BOX DRAWINGS LIGHT UP AND HORIZONTAL
    0x00c2: 0x252c,     #  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
    0x00c3: 0x251c,     #  BOX DRAWINGS LIGHT VERTICAL AND RIGHT
    0x00c4: 0x2500,     #  BOX DRAWINGS LIGHT HORIZONTAL
    0x00c5: 0x253c,     #  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
    0x00c6: 0x255e,     #  BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
    0x00c7: 0x255f,     #  BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
    0x00c8: 0x255a,     #  BOX DRAWINGS DOUBLE UP AND RIGHT
    0x00c9: 0x2554,     #  BOX DRAWINGS DOUBLE DOWN AND RIGHT
    0x00ca: 0x2569,     #  BOX DRAWINGS DOUBLE UP AND HORIZONTAL
    0x00cb: 0x2566,     #  BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
    0x00cc: 0x2560,     #  BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
    0x00cd: 0x2550,     #  BOX DRAWINGS DOUBLE HORIZONTAL
    0x00ce: 0x256c,     #  BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
    0x00cf: 0x2567,     #  BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
    0x00d0: 0x2568,     #  BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
    0x00d1: 0x2564,     #  BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
    0x00d2: 0x2565,     #  BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
    0x00d3: 0x2559,     #  BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
    0x00d4: 0x2558,     #  BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
    0x00d5: 0x2552,     #  BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
    0x00d6: 0x2553,     #  BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
    0x00d7: 0x256b,     #  BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
    0x00d8: 0x256a,     #  BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
    0x00d9: 0x2518,     #  BOX DRAWINGS LIGHT UP AND LEFT
    0x00da: 0x250c,     #  BOX DRAWINGS LIGHT DOWN AND RIGHT
    0x00db: 0x2588,     #  FULL BLOCK
    0x00dc: 0x2584,     #  LOWER HALF BLOCK
    0x00dd: 0x258c,     #  LEFT HALF BLOCK
    0x00de: 0x2590,     #  RIGHT HALF BLOCK
    0x00df: 0x2580,     #  UPPER HALF BLOCK
    0x00e0: 0x03b1,     #  GREEK SMALL LETTER ALPHA
    0x00e1: 0x00df,     #  LATIN SMALL LETTER SHARP S
    0x00e2: 0x0393,     #  GREEK CAPITAL LETTER GAMMA
    0x00e3: 0x03c0,     #  GREEK SMALL LETTER PI
    0x00e4: 0x03a3,     #  GREEK CAPITAL LETTER SIGMA
    0x00e5: 0x03c3,     #  GREEK SMALL LETTER SIGMA
    0x00e6: 0x00b5,     #  MICRO SIGN
    0x00e7: 0x03c4,     #  GREEK SMALL LETTER TAU
    0x00e8: 0x03a6,     #  GREEK CAPITAL LETTER PHI
    0x00e9: 0x0398,     #  GREEK CAPITAL LETTER THETA
    0x00ea: 0x03a9,     #  GREEK CAPITAL LETTER OMEGA
    0x00eb: 0x03b4,     #  GREEK SMALL LETTER DELTA
    0x00ec: 0x221e,     #  INFINITY
    0x00ed: 0x03c6,     #  GREEK SMALL LETTER PHI
    0x00ee: 0x03b5,     #  GREEK SMALL LETTER EPSILON
    0x00ef: 0x2229,     #  INTERSECTION
    0x00f0: 0x2261,     #  IDENTICAL TO
    0x00f1: 0x00b1,     #  PLUS-MINUS SIGN
    0x00f2: 0x2265,     #  GREATER-THAN OR EQUAL TO
    0x00f3: 0x2264,     #  LESS-THAN OR EQUAL TO
    0x00f4: 0x2320,     #  TOP HALF INTEGRAL
    0x00f5: 0x2321,     #  BOTTOM HALF INTEGRAL
    0x00f6: 0x00f7,     #  DIVISION SIGN
    0x00f7: 0x2248,     #  ALMOST EQUAL TO
    0x00f8: 0x00b0,     #  DEGREE SIGN
    0x00f9: 0x2219,     #  BULLET OPERATOR
    0x00fa: 0x00b7,     #  MIDDLE DOT
    0x00fb: 0x221a,     #  SQUARE ROOT
    0x00fc: 0x207f,     #  SUPERSCRIPT LATIN SMALL LETTER N
    0x00fd: 0x00b2,     #  SUPERSCRIPT TWO
    0x00fe: 0x25a0,     #  BLACK SQUARE
    0x00ff: 0x00a0,     #  NO-BREAK SPACE
})

### Decoding Table

decoding_table = (
    '\x00'     #  0x0000 -> NULL
    '\x01'     #  0x0001 -> START OF HEADING
    '\x02'     #  0x0002 -> START OF TEXT
    '\x03'     #  0x0003 -> END OF TEXT
    '\x04'     #  0x0004 -> END OF TRANSMISSION
    '\x05'     #  0x0005 -> ENQUIRY
    '\x06'     #  0x0006 -> ACKNOWLEDGE
    '\x07'     #  0x0007 -> BELL
    '\x08'     #  0x0008 -> BACKSPACE
    '\t'       #  0x0009 -> HORIZONTAL TABULATION
    '\n'       #  0x000a -> LINE FEED
    '\x0b'     #  0x000b -> VERTICAL TABULATION
    '\x0c'     #  0x000c -> FORM FEED
    '\r'       #  0x000d -> CARRIAGE RETURN
    '\x0e'     #  0x000e -> SHIFT OUT
    '\x0f'     #  0x000f -> SHIFT IN
    '\x10'     #  0x0010 -> DATA LINK ESCAPE
    '\x11'     #  0x0011 -> DEVICE CONTROL ONE
    '\x12'     #  0x0012 -> DEVICE CONTROL TWO
    '\x13'     #  0x0013 -> DEVICE CONTROL THREE
    '\x14'     #  0x0014 -> DEVICE CONTROL FOUR
    '\x15'     #  0x0015 -> NEGATIVE ACKNOWLEDGE
    '\x16'     #  0x0016 -> SYNCHRONOUS IDLE
    '\x17'     #  0x0017 -> END OF TRANSMISSION BLOCK
    '\x18'     #  0x0018 -> CANCEL
    '\x19'     #  0x0019 -> END OF MEDIUM
    '\x1a'     #  0x001a -> SUBSTITUTE
    '\x1b'     #  0x001b -> ESCAPE
    '\x1c'     #  0x001c -> FILE SEPARATOR
    '\x1d'     #  0x001d -> GROUP SEPARATOR
    '\x1e'     #  0x001e -> RECORD SEPARATOR
    '\x1f'     #  0x001f -> UNIT SEPARATOR
    ' '        #  0x0020 -> SPACE
    '!'        #  0x0021 -> EXCLAMATION MARK
    '"'        #  0x0022 -> QUOTATION MARK
    '#'        #  0x0023 -> NUMBER SIGN
    '$'        #  0x0024 -> DOLLAR SIGN
    '%'        #  0x0025 -> PERCENT SIGN
    '&'        #  0x0026 -> AMPERSAND
    "'"        #  0x0027 -> APOSTROPHE
    '('        #  0x0028 -> LEFT PARENTHESIS
    ')'        #  0x0029 -> RIGHT PARENTHESIS
    '*'        #  0x002a -> ASTERISK
    '+'        #  0x002b -> PLUS SIGN
    ','        #  0x002c -> COMMA
    '-'        #  0x002d -> HYPHEN-MINUS
    '.'        #  0x002e -> FULL STOP
    '/'        #  0x002f -> SOLIDUS
    '0'        #  0x0030 -> DIGIT ZERO
    '1'        #  0x0031 -> DIGIT ONE
    '2'        #  0x0032 -> DIGIT TWO
    '3'        #  0x0033 -> DIGIT THREE
    '4'        #  0x0034 -> DIGIT FOUR
    '5'        #  0x0035 -> DIGIT FIVE
    '6'        #  0x0036 -> DIGIT SIX
    '7'        #  0x0037 -> DIGIT SEVEN
    '8'        #  0x0038 -> DIGIT EIGHT
    '9'        #  0x0039 -> DIGIT NINE
    ':'        #  0x003a -> COLON
    ';'        #  0x003b -> SEMICOLON
    '<'        #  0x003c -> LESS-THAN SIGN
    '='        #  0x003d -> EQUALS SIGN
    '>'        #  0x003e -> GREATER-THAN SIGN
    '?'        #  0x003f -> QUESTION MARK
    '@'        #  0x0040 -> COMMERCIAL AT
    'A'        #  0x0041 -> LATIN CAPITAL LETTER A
    'B'        #  0x0042 -> LATIN CAPITAL LETTER B
    'C'        #  0x0043 -> LATIN CAPITAL LETTER C
    'D'        #  0x0044 -> LATIN CAPITAL LETTER D
    'E'        #  0x0045 -> LATIN CAPITAL LETTER E
    'F'        #  0x0046 -> LATIN CAPITAL LETTER F
    'G'        #  0x0047 -> LATIN CAPITAL LETTER G
    'H'        #  0x0048 -> LATIN CAPITAL LETTER H
    'I'        #  0x0049 -> LATIN CAPITAL LETTER I
    'J'        #  0x004a -> LATIN CAPITAL LETTER J
    'K'        #  0x004b -> LATIN CAPITAL LETTER K
    'L'        #  0x004c -> LATIN CAPITAL LETTER L
    'M'        #  0x004d -> LATIN CAPITAL LETTER M
    'N'        #  0x004e -> LATIN CAPITAL LETTER N
    'O'        #  0x004f -> LATIN CAPITAL LETTER O
    'P'        #  0x0050 -> LATIN CAPITAL LETTER P
    'Q'        #  0x0051 -> LATIN CAPITAL LETTER Q
    'R'        #  0x0052 -> LATIN CAPITAL LETTER R
    'S'        #  0x0053 -> LATIN CAPITAL LETTER S
    'T'        #  0x0054 -> LATIN CAPITAL LETTER T
    'U'        #  0x0055 -> LATIN CAPITAL LETTER U
    'V'        #  0x0056 -> LATIN CAPITAL LETTER V
    'W'        #  0x0057 -> LATIN CAPITAL LETTER W
    'X'        #  0x0058 -> LATIN CAPITAL LETTER X
    'Y'        #  0x0059 -> LATIN CAPITAL LETTER Y
    'Z'        #  0x005a -> LATIN CAPITAL LETTER Z
    '['        #  0x005b -> LEFT SQUARE BRACKET
    '\\'       #  0x005c -> REVERSE SOLIDUS
    ']'        #  0x005d -> RIGHT SQUARE BRACKET
    '^'        #  0x005e -> CIRCUMFLEX ACCENT
    '_'        #  0x005f -> LOW LINE
    '`'        #  0x0060 -> GRAVE ACCENT
    'a'        #  0x0061 -> LATIN SMALL LETTER A
    'b'        #  0x0062 -> LATIN SMALL LETTER B
    'c'        #  0x0063 -> LATIN SMALL LETTER C
    'd'        #  0x0064 -> LATIN SMALL LETTER D
    'e'        #  0x0065 -> LATIN SMALL LETTER E
    'f'        #  0x0066 -> LATIN SMALL LETTER F
    'g'        #  0x0067 -> LATIN SMALL LETTER G
    'h'        #  0x0068 -> LATIN SMALL LETTER H
    'i'        #  0x0069 -> LATIN SMALL LETTER I
    'j'        #  0x006a -> LATIN SMALL LETTER J
    'k'        #  0x006b -> LATIN SMALL LETTER K
    'l'        #  0x006c -> LATIN SMALL LETTER L
    'm'        #  0x006d -> LATIN SMALL LETTER M
    'n'        #  0x006e -> LATIN SMALL LETTER N
    'o'        #  0x006f -> LATIN SMALL LETTER O
    'p'        #  0x0070 -> LATIN SMALL LETTER P
    'q'        #  0x0071 -> LATIN SMALL LETTER Q
    'r'        #  0x0072 -> LATIN SMALL LETTER R
    's'        #  0x0073 -> LATIN SMALL LETTER S
    't'        #  0x0074 -> LATIN SMALL LETTER T
    'u'        #  0x0075 -> LATIN SMALL LETTER U
    'v'        #  0x0076 -> LATIN SMALL LETTER V
    'w'        #  0x0077 -> LATIN SMALL LETTER W
    'x'        #  0x0078 -> LATIN SMALL LETTER X
    'y'        #  0x0079 -> LATIN SMALL LETTER Y
    'z'        #  0x007a -> LATIN SMALL LETTER Z
    '{'        #  0x007b -> LEFT CURLY BRACKET
    '|'        #  0x007c -> VERTICAL LINE
    '}'        #  0x007d -> RIGHT CURLY BRACKET
    '~'        #  0x007e -> TILDE
    '\x7f'     #  0x007f -> DELETE
    '\xc7'     #  0x0080 -> LATIN CAPITAL LETTER C WITH CEDILLA
    '\xfc'     #  0x0081 -> LATIN SMALL LETTER U WITH DIAERESIS
    '\xe9'     #  0x0082 -> LATIN SMALL LETTER E WITH ACUTE
    '\xe2'     #  0x0083 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
    '\xe4'     #  0x0084 -> LATIN SMALL LETTER A WITH DIAERESIS
    '\xe0'     #  0x0085 -> LATIN SMALL LETTER A WITH GRAVE
    '\xe5'     #  0x0086 -> LATIN SMALL LETTER A WITH RING ABOVE
    '\xe7'     #  0x0087 -> LATIN SMALL LETTER C WITH CEDILLA
    '\xea'     #  0x0088 -> LATIN SMALL LETTER E WITH CIRCUMFLEX
    '\xeb'     #  0x0089 -> LATIN SMALL LETTER E WITH DIAERESIS
    '\xe8'     #  0x008a -> LATIN SMALL LETTER E WITH GRAVE
    '\xef'     #  0x008b -> LATIN SMALL LETTER I WITH DIAERESIS
    '\xee'     #  0x008c -> LATIN SMALL LETTER I WITH CIRCUMFLEX
    '\xec'     #  0x008d -> LATIN SMALL LETTER I WITH GRAVE
    '\xc4'     #  0x008e -> LATIN CAPITAL LETTER A WITH DIAERESIS
    '\xc5'     #  0x008f -> LATIN CAPITAL LETTER A WITH RING ABOVE
    '\xc9'     #  0x0090 -> LATIN CAPITAL LETTER E WITH ACUTE
    '\xe6'     #  0x0091 -> LATIN SMALL LIGATURE AE
    '\xc6'     #  0x0092 -> LATIN CAPITAL LIGATURE AE
    '\xf4'     #  0x0093 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
    '\xf6'     #  0x0094 -> LATIN SMALL LETTER O WITH DIAERESIS
    '\xf2'     #  0x0095 -> LATIN SMALL LETTER O WITH GRAVE
    '\xfb'     #  0x0096 -> LATIN SMALL LETTER U WITH CIRCUMFLEX
    '\xf9'     #  0x0097 -> LATIN SMALL LETTER U WITH GRAVE
    '\xff'     #  0x0098 -> LATIN SMALL LETTER Y WITH DIAERESIS
    '\xd6'     #  0x0099 -> LATIN CAPITAL LETTER O WITH DIAERESIS
    '\xdc'     #  0x009a -> LATIN CAPITAL LETTER U WITH DIAERESIS
    '\xa2'     #  0x009b -> CENT SIGN
    '\xa3'     #  0x009c -> POUND SIGN
    '\xa5'     #  0x009d -> YEN SIGN
    '\u20a7'   #  0x009e -> PESETA SIGN
    '\u0192'   #  0x009f -> LATIN SMALL LETTER F WITH HOOK
    '\xe1'     #  0x00a0 -> LATIN SMALL LETTER A WITH ACUTE
    '\xed'     #  0x00a1 -> LATIN SMALL LETTER I WITH ACUTE
    '\xf3'     #  0x00a2 -> LATIN SMALL LETTER O WITH ACUTE
    '