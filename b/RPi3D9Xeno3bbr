26b\u0338',
    'NotGreaterLess;': '\u2279',
    'NotGreaterSlantEqual;': '\u2a7e\u0338',
    'NotGreaterTilde;': '\u2275',
    'NotHumpDownHump;': '\u224e\u0338',
    'NotHumpEqual;': '\u224f\u0338',
    'notin;': '\u2209',
    'notindot;': '\u22f5\u0338',
    'notinE;': '\u22f9\u0338',
    'notinva;': '\u2209',
    'notinvb;': '\u22f7',
    'notinvc;': '\u22f6',
    'NotLeftTriangle;': '\u22ea',
    'NotLeftTriangleBar;': '\u29cf\u0338',
    'NotLeftTriangleEqual;': '\u22ec',
    'NotLess;': '\u226e',
    'NotLessEqual;': '\u2270',
    'NotLessGreater;': '\u2278',
    'NotLessLess;': '\u226a\u0338',
    'NotLessSlantEqual;': '\u2a7d\u0338',
    'NotLessTilde;': '\u2274',
    'NotNestedGreaterGreater;': '\u2aa2\u0338',
    'NotNestedLessLess;': '\u2aa1\u0338',
    'notni;': '\u220c',
    'notniva;': '\u220c',
    'notnivb;': '\u22fe',
    'notnivc;': '\u22fd',
    'NotPrecedes;': '\u2280',
    'NotPrecedesEqual;': '\u2aaf\u0338',
    'NotPrecedesSlantEqual;': '\u22e0',
    'NotReverseElement;': '\u220c',
    'NotRightTriangle;': '\u22eb',
    'NotRightTriangleBar;': '\u29d0\u0338',
    'NotRightTriangleEqual;': '\u22ed',
    'NotSquareSubset;': '\u228f\u0338',
    'NotSquareSubsetEqual;': '\u22e2',
    'NotSquareSuperset;': '\u2290\u0338',
    'NotSquareSupersetEqual;': '\u22e3',
    'NotSubset;': '\u2282\u20d2',
    'NotSubsetEqual;': '\u2288',
    'NotSucceeds;': '\u2281',
    'NotSucceedsEqual;': '\u2ab0\u0338',
    'NotSucceedsSlantEqual;': '\u22e1',
    'NotSucceedsTilde;': '\u227f\u0338',
    'NotSuperset;': '\u2283\u20d2',
    'NotSupersetEqual;': '\u2289',
    'NotTilde;': '\u2241',
    'NotTildeEqual;': '\u2244',
    'NotTildeFullEqual;': '\u2247',
    'NotTildeTilde;': '\u2249',
    'NotVerticalBar;': '\u2224',
    'npar;': '\u2226',
    'nparallel;': '\u2226',
    'nparsl;': '\u2afd\u20e5',
    'npart;': '\u2202\u0338',
    'npolint;': '\u2a14',
    'npr;': '\u2280',
    'nprcue;': '\u22e0',
    'npre;': '\u2aaf\u0338',
    'nprec;': '\u2280',
    'npreceq;': '\u2aaf\u0338',
    'nrArr;': '\u21cf',
    'nrarr;': '\u219b',
    'nrarrc;': '\u2933\u0338',
    'nrarrw;': '\u219d\u0338',
    'nRightarrow;': '\u21cf',
    'nrightarrow;': '\u219b',
    'nrtri;': '\u22eb',
    'nrtrie;': '\u22ed',
    'nsc;': '\u2281',
    'nsccue;': '\u22e1',
    'nsce;': '\u2ab0\u0338',
    'Nscr;': '\U0001d4a9',
    'nscr;': '\U0001d4c3',
    'nshortmid;': '\u2224',
    'nshortparallel;': '\u2226',
    'nsim;': '\u2241',
    'nsime;': '\u2244',
    'nsimeq;': '\u2244',
    'nsmid;': '\u2224',
    'nspar;': '\u2226',
    'nsqsube;': '\u22e2',
    'nsqsupe;': '\u22e3',
    'nsub;': '\u2284',
    'nsubE;': '\u2ac5\u0338',
    'nsube;': '\u2288',
    'nsubset;': '\u2282\u20d2',
    'nsubseteq;': '\u2288',
    'nsubseteqq;': '\u2ac5\u0338',
    'nsucc;': '\u2281',
    'nsucceq;': '\u2ab0\u0338',
    'nsup;': '\u2285',
    'nsupE;': '\u2ac6\u0338',
    'nsupe;': '\u2289',
    'nsupset;': '\u2283\u20d2',
    'nsupseteq;': '\u2289',
    'nsupseteqq;': '\u2ac6\u0338',
    'ntgl;': '\u2279',
    'Ntilde': '\xd1',
    'ntilde': '\xf1',
    'Ntilde;': '\xd1',
    'ntilde;': '\xf1',
    'ntlg;': '\u2278',
    'ntriangleleft;': '\u22ea',
    'ntrianglelefteq;': '\u22ec',
    'ntriangleright;': '\u22eb',
    'ntrianglerighteq;': '\u22ed',
    'Nu;': '\u039d',
    'nu;': '\u03bd',
    'num;': '#',
    'numero;': '\u2116',
    'numsp;': '\u2007',
    'nvap;': '\u224d\u20d2',
    'nVDash;': '\u22af',
    'nVdash;': '\u22ae',
    'nvDash;': '\u22ad',
    'nvdash;': '\u22ac',
    'nvge;': '\u2265\u20d2',
    'nvgt;': '>\u20d2',
    'nvHarr;': '\u2904',
    'nvinfin;': '\u29de',
    'nvlArr;': '\u2902',
    'nvle;': '\u2264\u20d2',
    'nvlt;': '<\u20d2',
    'nvltrie;': '\u22b4\u20d2',
    'nvrArr;': '\u2903',
    'nvrtrie;': '\u22b5\u20d2',
    'nvsim;': '\u223c\u20d2',
    'nwarhk;': '\u2923',
    'nwArr;': '\u21d6',
    'nwarr;': '\u2196',
    'nwarrow;': '\u2196',
    'nwnear;': '\u2927',
    'Oacute': '\xd3',
    'oacute': '\xf3',
    'Oacute;': '\xd3',
    'oacute;': '\xf3',
    'oast;': '\u229b',
    'ocir;': '\u229a',
    'Ocirc': '\xd4',
    'ocirc': '\xf4',
    'Ocirc;': '\xd4',
    'ocirc;': '\xf4',
    'Ocy;': '\u041e',
    'ocy;': '\u043e',
    'odash;': '\u229d',
    'Odblac;': '\u0150',
    'odblac;': '\u0151',
    'odiv;': '\u2a38',
    'odot;': '\u2299',
    'odsold;': '\u29bc',
    'OElig;': '\u0152',
    'oelig;': '\u0153',
    'ofcir;': '\u29bf',
    'Ofr;': '\U0001d512',
    'ofr;': '\U0001d52c',
    'ogon;': '\u02db',
    'Ograve': '\xd2',
    'ograve': '\xf2',
    'Ograve;': '\xd2',
    'ograve;': '\xf2',
    'ogt;': '\u29c1',
    'ohbar;': '\u29b5',
    'ohm;': '\u03a9',
    'oint;': '\u222e',
    'olarr;': '\u21ba',
    'olcir;': '\u29be',
    'olcross;': '\u29bb',
    'oline;': '\u203e',
    'olt;': '\u29c0',
    'Omacr;': '\u014c',
    'omacr;': '\u014d',
    'Omega;': '\u03a9',
    'omega;': '\u03c9',
    'Omicron;': '\u039f',
    'omicron;': '\u03bf',
    'omid;': '\u29b6',
    'ominus;': '\u2296',
    'Oopf;': '\U0001d546',
    'oopf;': '\U0001d560',
    'opar;': '\u29b7',
    'OpenCurlyDoubleQuote;': '\u201c',
    'OpenCurlyQuote;': '\u2018',
    'operp;': '\u29b9',
    'oplus;': '\u2295',
    'Or;': '\u2a54',
    'or;': '\u2228',
    'orarr;': '\u21bb',
    'ord;': '\u2a5d',
    'order;': '\u2134',
    'orderof;': '\u2134',
    'ordf': '\xaa',
    'ordf;': '\xaa',
    'ordm': '\xba',
    'ordm;': '\xba',
    'origof;': '\u22b6',
    'oror;': '\u2a56',
    'orslope;': '\u2a57',
    'orv;': '\u2a5b',
    'oS;': '\u24c8',
    'Oscr;': '\U0001d4aa',
    'oscr;': '\u2134',
    'Oslash': '\xd8',
    'oslash': '\xf8',
    'Oslash;': '\xd8',
    'oslash;': '\xf8',
    'osol;': '\u2298',
    'Otilde': '\xd5',
    'otilde': '\xf5',
    'Otilde;': '\xd5',
    'otilde;': '\xf5',
    'Otimes;': '\u2a37',
    'otimes;': '\u2297',
    'otimesas;': '\u2a36',
    'Ouml': '\xd6',
    'ouml': '\xf6',
    'Ouml;': '\xd6',
    'ouml;': '\xf6',
    'ovbar;': '\u233d',
    'OverBar;': '\u203e',
    'OverBrace;': '\u23de',
    'OverBracket;': '\u23b4',
    'OverParenthesis;': '\u23dc',
    'par;': '\u2225',
    'para': '\xb6',
    'para;': '\xb6',
    'parallel;': '\u2225',
    'parsim;': '\u2af3',
    'parsl;': '\u2afd',
    'part;': '\u2202',
    'PartialD;': '\u2202',
    'Pcy;': '\u041f',
    'pcy;': '\u043f',
    'percnt;': '%',
    'period;': '.',
    'permil;': '\u2030',
    'perp;': '\u22a5',
    'pertenk;': '\u2031',
    'Pfr;': '\U0001d513',
    'pfr;': '\U0001d52d',
    'Phi;': '\u03a6',
    'phi;': '\u03c6',
    'phiv;': '\u03d5',
    'phmmat;': '\u2133',
    'phone;': '\u260e',
    'Pi;': '\u03a0',
    'pi;': '\u03c0',
    'pitchfork;': '\u22d4',
    'piv;': '\u03d6',
    'planck;': '\u210f',
    'planckh;': '\u210e',
    'plankv;': '\u210f',
    'plus;': '+',
    'plusacir;': '\u2a23',
    'plusb;': '\u229e',
    'pluscir;': '\u2a22',
    'plusdo;': '\u2214',
    'plusdu;': '\u2a25',
    'pluse;': '\u2a72',
    'PlusMinus;': '\xb1',
    'plusmn': '\xb1',
    'plusmn;': '\xb1',
    'plussim;': '\u2a26',
    'plustwo;': '\u2a27',
    'pm;': '\xb1',
    'Poincareplane;': '\u210c',
    'pointint;': '\u2a15',
    'Popf;': '\u2119',
    'popf;': '\U0001d561',
    'pound': '\xa3',
    'pound;': '\xa3',
    'Pr;': '\u2abb',
    'pr;': '\u227a',
    'prap;': '\u2ab7',
    'prcue;': '\u227c',
    'prE;': '\u2ab3',
    'pre;': '\u2aaf',
    'prec;': '\u227a',
    'precapprox;': '\u2ab7',
    'preccurlyeq;': '\u227c',
    'Precedes;': '\u227a',
    'PrecedesEqual;': '\u2aaf',
    'PrecedesSlantEqual;': '\u227c',
    'PrecedesTilde;': '\u227e',
    'preceq;': '\u2aaf',
    'precnapprox;': '\u2ab9',
    'precneqq;': '\u2ab5',
    'precnsim;': '\u22e8',
    'precsim;': '\u227e',
    'Prime;': '\u2033',
    'prime;': '\u2032',
    'primes;': '\u2119',
    'prnap;': '\u2ab9',
    'prnE;': '\u2ab5',
    'prnsim;': '\u22e8',
    'prod;': '\u220f',
    'Product;': '\u220f',
    'profalar;': '\u232e',
    'profline;': '\u2312',
    'profsurf;': '\u2313',
    'prop;': '\u221d',
    'Proportion;': '\u2237',
    'Proportional;': '\u221d',
    'propto;': '\u221d',
    'prsim;': '\u227e',
    'prurel;': '\u22b0',
    'Pscr;': '\U0001d4ab',
    'pscr;': '\U0001d4c5',
    'Psi;': '\u03a8',
    'psi;': '\u03c8',
    'puncsp;': '\u2008',
    'Qfr;': '\U0001d514',
    'qfr;': '\U0001d52e',
    'qint;': '\u2a0c',
    'Qopf;': '\u211a',
    'qopf;': '\U0001d562',
    'qprime;': '\u2057',
    'Qscr;': '\U0001d4ac',
    'qscr;': '\U0001d4c6',
    'quaternions;': '\u210d',
    'quatint;': '\u2a16',
    'quest;': '?',
    'questeq;': '\u225f',
    'QUOT': '"',
    'quot': '"',
    'QUOT;': '"',
    'quot;': '"',
    'rAarr;': '\u21db',
    'race;': '\u223d\u0331',
    'Racute;': '\u0154',
    'racute;': '\u0155',
    'radic;': '\u221a',
    'raemptyv;': '\u29b3',
    'Rang;': '\u27eb',
    'rang;': '\u27e9',
    'rangd;': '\u2992',
    'range;': '\u29a5',
    'rangle;': '\u27e9',
    'raquo': '\xbb',
    'raquo;': '\xbb',
    'Rarr;': '\u21a0',
    'rArr;': '\u21d2',
    'rarr;': '\u2192',
    'rarrap;': '\u2975',
    'rarrb;': '\u21e5',
    'rarrbfs;': '\u2920',
    'rarrc;': '\u2933',
    'rarrfs;': '\u291e',
    'rarrhk;': '\u21aa',
    'rarrlp;': '\u21ac',
    'rarrpl;': '\u2945',
    'rarrsim;': '\u2974',
    'Rarrtl;': '\u2916',
    'rarrtl;': '\u21a3',
    'rarrw;': '\u219d',
    'rAtail;': '\u291c',
    'ratail;': '\u291a',
    'ratio;': '\u2236',
    'rationals;': '\u211a',
    'RBarr;': '\u2910',
    'rBarr;': '\u290f',
    'rbarr;': '\u290d',
    'rbbrk;': '\u2773',
    'rbrace;': '}',
    'rbrack;': ']',
    'rbrke;': '\u298c',
    'rbrksld;': '\u298e',
    'rbrkslu;': '\u2990',
    'Rcaron;': '\u0158',
    'rcaron;': '\u0159',
    'Rcedil;': '\u0156',
    'rcedil;': '\u0157',
    'rceil;': '\u2309',
    'rcub;': '}',
    'Rcy;': '\u0420',
    'rcy;': '\u0440',
    'rdca;': '\u2937',
    'rdldhar;': '\u2969',
    'rdquo;': '\u201d',
    'rdquor;': '\u201d',
    'rdsh;': '\u21b3',
    'Re;': '\u211c',
    'real;': '\u211c',
    'realine;': '\u211b',
    'realpart;': '\u211c',
    'reals;': '\u211d',
    'rect;': '\u25ad',
    'REG': '\xae',
    'reg': '\xae',
    'REG;': '\xae',
    'reg;': '\xae',
    'ReverseElement;': '\u220b',
    'ReverseEquilibrium;': '\u21cb',
    'ReverseUpEquilibrium;': '\u296f',
    'rfisht;': '\u297d',
    'rfloor;': '\u230b',
    'Rfr;': '\u211c',
    'rfr;': '\U0001d52f',
    'rHar;': '\u2964',
    'rhard;': '\u21c1',
    'rharu;': '\u21c0',
    'rharul;': '\u296c',
    'Rho;': '\u03a1',
    'rho;': '\u03c1',
    'rhov;': '\u03f1',
    'RightAngleBracket;': '\u27e9',
    'RightArrow;': '\u2192',
    'Rightarrow;': '\u21d2',
    'rightarrow;': '\u2192',
    'RightArrowBar;': '\u21e5',
    'RightArrowLeftArrow;': '\u21c4',
    'rightarrowtail;': '\u21a3',
    'RightCeiling;': '\u2309',
    'RightDoubleBracket;': '\u27e7',
    'RightDownTeeVector;': '\u295d',
    'RightDownVector;': '\u21c2',
    'RightDownVectorBar;': '\u2955',
    'RightFloor;': '\u230b',
    'rightharpoondown;': '\u21c1',
    'rightharpoonup;': '\u21c0',
    'rightleftarrows;': '\u21c4',
    'rightleftharpoons;': '\u21cc',
    'rightrightarrows;': '\u21c9',
    'rightsquigarrow;': '\u219d',
    'RightTee;': '\u22a2',
    'RightTeeArrow;': '\u21a6',
    'RightTeeVector;': '\u295b',
    'rightthreetimes;': '\u22cc',
    'RightTriangle;': '\u22b3',
    'RightTriangleBar;': '\u29d0',
    'RightTriangleEqual;': '\u22b5',
    'RightUpDownVector;': '\u294f',
    'RightUpTeeVector;': '\u295c',
    'RightUpVector;': '\u21be',
    'RightUpVectorBar;': '\u2954',
    'RightVector;': '\u21c0',
    'RightVectorBar;': '\u2953',
    'ring;': '\u02da',
    'risingdotseq;': '\u2253',
    'rlarr;': '\u21c4',
    'rlhar;': '\u21cc',
    'rlm;': '\u200f',
    'rmoust;': '\u23b1',
    'rmoustache;': '\u23b1',
    'rnmid;': '\u2aee',
    'roang;': '\u27ed',
    'roarr;': '\u21fe',
    'robrk;': '\u27e7',
    'ropar;': '\u2986',
    'Ropf;': '\u211d',
    'ropf;': '\U0001d563',
    'roplus;': '\u2a2e',
    'rotimes;': '\u2a35',
    'RoundImplies;': '\u2970',
    'rpar;': ')',
    'rpargt;': '\u2994',
    'rppolint;': '\u2a12',
    'rrarr;': '\u21c9',
    'Rrightarrow;': '\u21db',
    'rsaquo;': '\u203a',
    'Rscr;': '\u211b',
    'rscr;': '\U0001d4c7',
    'Rsh;': '\u21b1',
    'rsh;': '\u21b1',
    'rsqb;': ']',
    'rsquo;': '\u2019',
    'rsquor;': '\u2019',
    'rthree;': '\u22cc',
    'rtimes;': '\u22ca',
    'rtri;': '\u25b9',
    'rtrie;': '\u22b5',
    'rtrif;': '\u25b8',
    'rtriltri;': '\u29ce',
    'RuleDelayed;': '\u29f4',
    'ruluhar;': '\u2968',
    'rx;': '\u211e',
    'Sacute;': '\u015a',
    'sacute;': '\u015b',
    'sbquo;': '\u201a',
    'Sc;': '\u2abc',
    'sc;': '\u227b',
    'scap;': '\u2ab8',
    'Scaron;': '\u0160',
    'scaron;': '\u0161',
    'sccue;': '\u227d',
    'scE;': '\u2ab4',
    'sce;': '\u2ab0',
    'Scedil;': '\u015e',
    'scedil;': '\u015f',
    'Scirc;': '\u015c',
    'scirc;': '\u015d',
    'scnap;': '\u2aba',
    'scnE;': '\u2ab6',
    'scnsim;': '\u22e9',
    'scpolint;': '\u2a13',
    'scsim;': '\u227f',
    'Scy;': '\u0421',
    'scy;': '\u0441',
    'sdot;': '\u22c5',
    'sdotb;': '\u22a1',
    'sdote;': '\u2a66',
    'searhk;': '\u2925',
    'seArr;': '\u21d8',
    'searr;': '\u2198',
    'searrow;': '\u2198',
    'sect': '\xa7',
    'sect;': '\xa7',
    'semi;': ';',
    'seswar;': '\u2929',
    'setminus;': '\u2216',
    'setmn;': '\u2216',
    'sext;': '\u2736',
    'Sfr;': '\U0001d516',
    'sfr;': '\U0001d530',
    'sfrown;': '\u2322',
    'sharp;': '\u266f',
    'SHCHcy;': '\u0429',
    'shchcy;': '\u0449',
    'SHcy;': '\u0428',
    'shcy;': '\u0448',
    'ShortDownArrow;': '\u2193',
    'ShortLeftArrow;': '\u2190',
    'shortmid;': '\u2223',
    'shortparallel;': '\u2225',
    'ShortRightArrow;': '\u2192',
    'ShortUpArrow;': '\u2191',
    'shy': '\xad',
    'shy;': '\xad',
    'Sigma;': '\u03a3',
    'sigma;': '\u03c3',
    'sigmaf;': '\u03c2',
    'sigmav;': '\u03c2',
    'sim;': '\u223c',
    'simdot;': '\u2a6a',
    'sime;': '\u2243',
    'simeq;': '\u2243',
    'simg;': '\u2a9e',
    'simgE;': '\u2aa0',
    'siml;': '\u2a9d',
    'simlE;': '\u2a9f',
    'simne;': '\u2246',
    'simplus;': '\u2a24',
    'simrarr;': '\u2972',
    'slarr;': '\u2190',
    'SmallCircle;': '\u2218',
    'smallsetminus;': '\u2216',
    'smashp;': '\u2a33',
    'smeparsl;': '\u29e4',
    'smid;': '\u2223',
    'smile;': '\u2323',
    'smt;': '\u2aaa',
    'smte;': '\u2aac',
    'smtes;': '\u2aac\ufe00',
    'SOFTcy;': '\u042c',
    'softcy;': '\u044c',
    'sol;': '/',
    'solb;': '\u29c4',
    'solbar;': '\u233f',
    'Sopf;': '\U0001d54a',
    'sopf;': '\U0001d564',
    'spades;': '\u2660',
    'spadesuit;': '\u2660',
    'spar;': '\u2225',
    'sqcap;': '\u2293',
    'sqcaps;': '\u2293\ufe00',
    'sqcup;': '\u2294',
    'sqcups;': '\u2294\ufe00',
    'Sqrt;': '\u221a',
    'sqsub;': '\u228f',
    'sqsube;': '\u2291',
    'sqsubset;': '\u228f',
    'sqsubseteq;': '\u2291',
    'sqsup;': '\u2290',
    'sqsupe;': '\u2292',
    'sqsupset;': '\u2290',
    'sqsupseteq;': '\u2292',
    'squ;': '\u25a1',
    'Square;': '\u25a1',
    'square;': '\u25a1',
    'SquareIntersection;': '\u2293',
    'SquareSubset;': '\u228f',
    'SquareSubsetEqual;': '\u2291',
    'SquareSuperset;': '\u2290',
    'SquareSupersetEqual;': '\u2292',
    'SquareUnion;': '\u2294',
    'squarf;': '\u25aa',
    'squf;': '\u25aa',
    'srarr;': '\u2192',
    'Sscr;': '\U0001d4ae',
    'sscr;': '\U0001d4c8',
    'ssetmn;': '\u2216',
    'ssmile;': '\u2323',
    'sstarf;': '\u22c6',
    'Star;': '\u22c6',
    'star;': '\u2606',
    'starf;': '\u2605',
    'straightepsilon;': '\u03f5',
    'straightphi;': '\u03d5',
    'strns;': '\xaf',
    'Sub;': '\u22d0',
    'sub;': '\u2282',
    'subdot;': '\u2abd',
    'subE;': '\u2ac5',
    'sube;': '\u2286',
    'subedot;': '\u2ac3',
    'submult;': '\u2ac1',
    'subnE;': '\u2acb',
    'subne;': '\u228a',
    'subplus;': '\u2abf',
    'subrarr;': '\u2979',
    'Subset;': '\u22d0',
    'subset;': '\u2282',
    'subseteq;': '\u2286',
    'subseteqq;': '\u2ac5',
    'SubsetEqual;': '\u2286',
    'subsetneq;': '\u228a',
    'subsetneqq;': '\u2acb',
    'subsim;': '\u2ac7',
    'subsub;': '\u2ad5',
    'subsup;': '\u2ad3',
    'succ;': '\u227b',
    'succapprox;': '\u2ab8',
    'succcurlyeq;': '\u227d',
    'Succeeds;': '\u227b',
    'SucceedsEqual;': '\u2ab0',
    'SucceedsSlantEqual;': '\u227d',
    'SucceedsTilde;': '\u227f',
    'succeq;': '\u2ab0',
    'succnapprox;': '\u2aba',
    'succneqq;': '\u2ab6',
    'succnsim;': '\u22e9',
    'succsim;': '\u227f',
    'SuchThat;': '\u220b',
    'Sum;': '\u2211',
    'sum;': '\u2211',
    'sung;': '\u266a',
    'sup1': '\xb9',
    'sup1;': '\xb9',
    'sup2': '\xb2',
    'sup2;': '\xb2',
    'sup3': '\xb3',
    'sup3;': '\xb3',
    'Sup;': '\u22d1',
    'sup;': '\u2283',
    'supdot;': '\u2abe',
    'supdsub;': '\u2ad8',
    'supE;': '\u2ac6',
    'supe;': '\u2287',
    'supedot;': '\u2ac4',
    'Superset;': '\u2283',
    'SupersetEqual;': '\u2287',
    'suphsol;': '\u27c9',
    'suphsub;': '\u2ad7',
    'suplarr;': '\u297b',
    'supmult;': '\u2ac2',
    'supnE;': '\u2acc',
    'supne;': '\u228b',
    'supplus;': '\u2ac0',
    'Supset;': '\u22d1',
    'supset;': '\u2283',
    'supseteq;': '\u2287',
    'supseteqq;': '\u2ac6',
    'supsetneq;': '\u228b',
    'supsetneqq;': '\u2acc',
    'supsim;': '\u2ac8',
    'supsub;': '\u2ad4',
    'supsup;': '\u2ad6',
    'swarhk;': '\u2926',
    'swArr;': '\u21d9',
    'swarr;': '\u2199',
    'swarrow;': '\u2199',
    'swnwar;': '\u292a',
    'szlig': '\xdf',
    'szlig;': '\xdf',
    'Tab;': '\t',
    'target;': '\u2316',
    'Tau;': '\u03a4',
    'tau;': '\u03c4',
    'tbrk;': '\u23b4',
    'Tcaron;': '\u0164',
    'tcaron;': '\u0165',
    'Tcedil;': '\u0162',
    'tcedil;': '\u0163',
    'Tcy;': '\u0422',
    'tcy;': '\u0442',
    'tdot;': '\u20db',
    'telrec;': '\u2315',
    'Tfr;': '\U0001d517',
    'tfr;': '\U0001d531',
    'there4;': '\u2234',
    'Therefore;': '\u2234',
    'therefore;': '\u2234',
    'Theta;': '\u0398',
    'theta;': '\u03b8',
    'thetasym;': '\u03d1',
    'thetav;': '\u03d1',
    'thickapprox;': '\u2248',
    'thicksim;': '\u223c',
    'ThickSpace;': '\u205f\u200a',
    'thinsp;': '\u2009',
    'ThinSpace;': '\u2009',
    'thkap;': '\u2248',
    'thksim;': '\u223c',
    'THORN': '\xde',
    'thorn': '\xfe',
    'THORN;': '\xde',
    'thorn;': '\xfe',
    'Tilde;': '\u223c',
    'tilde;': '\u02dc',
    'TildeEqual;': '\u2243',
    'TildeFullEqual;': '\u2245',
    'TildeTilde;': '\u2248',
    'times': '\xd7',
    'times;': '\xd7',
    'timesb;': '\u22a0',
    'timesbar;': '\u2a31',
    'timesd;': '\u2a30',
    'tint;': '\u222d',
    'toea;': '\u2928',
    'top;': '\u22a4',
    'topbot;': '\u2336',
    'topcir;': '\u2af1',
    'Topf;': '\U0001d54b',
    'topf;': '\U0001d565',
    'topfork;': '\u2ada',
    'tosa;': '\u2929',
    'tprime;': '\u2034',
    'TRADE;': '\u2122',
    'trade;': '\u2122',
    'triangle;': '\u25b5',
    'triangledown;': '\u25bf',
    'triangleleft;': '\u25c3',
    'trianglelefteq;': '\u22b4',
    'triangleq;': '\u225c',
    'triangleright;': '\u25b9',
    'trianglerighteq;': '\u22b5',
    'tridot;': '\u25ec',
    'trie;': '\u225c',
    'triminus;': '\u2a3a',
    'TripleDot;': '\u20db',
    'triplus;': '\u2a39',
    'trisb;': '\u29cd',
    'tritime;': '\u2a3b',
    'trpezium;': '\u23e2',
    'Tscr;': '\U0001d4af',
    'tscr;': '\U0001d4c9',
    'TScy;': '\u0426',
    'tscy;': '\u0446',
    'TSHcy;': '\u040b',
    'tshcy;': '\u045b',
    'Tstrok;': '\u0166',
    'tstrok;': '\u0167',
    'twixt;': '\u226c',
    'twoheadleftarrow;': '\u219e',
    'twoheadrightarrow;': '\u21a0',
    'Uacute': '\xda',
    'uacute': '\xfa',
    'Uacute;': '\xda',
    'uacute;': '\xfa',
    'Uarr;': '\u219f',
    'uArr;': '\u21d1',
    'uarr;': '\u2191',
    'Uarrocir;': '\u2949',
    'Ubrcy;': '\u040e',
    'ubrcy;': '\u045e',
    'Ubreve;': '\u016c',
    'ubreve;': '\u016d',
    'Ucirc': '\xdb',
    'ucirc': '\xfb',
    'Ucirc;': '\xdb',
    'ucirc;': '\xfb',
    'Ucy;': '\u0423',
    'ucy;': '\u0443',
    'udarr;': '\u21c5',
    'Udblac;': '\u0170',
    'udblac;': '\u0171',
    'udhar;': '\u296e',
    'ufisht;': '\u297e',
    'Ufr;': '\U0001d518',
    'ufr;': '\U0001d532',
    'Ugrave': '\xd9',
    'ugrave': '\xf9',
    'Ugrave;': '\xd9',
    'ugrave;': '\xf9',
    'uHar;': '\u2963',
    'uharl;': '\u21bf',
    'uharr;': '\u21be',
    'uhblk;': '\u2580',
    'ulcorn;': '\u231c',
    'ulcorner;': '\u231c',
    'ulcrop;': '\u230f',
    'ultri;': '\u25f8',
    'Umacr;': '\u016a',
    'umacr;': '\u016b',
    'uml': '\xa8',
    'uml;': '\xa8',
    'UnderBar;': '_',
    'UnderBrace;': '\u23df',
    'UnderBracket;': '\u23b5',
    'UnderParenthesis;': '\u23dd',
    'Union;': '\u22c3',
    'UnionPlus;': '\u228e',
    'Uogon;': '\u0172',
    'uogon;': '\u0173',
    'Uopf;': '\U0001d54c',
    'uopf;': '\U0001d566',
    'UpArrow;': '\u2191',
    'Uparrow;': '\u21d1',
    'uparrow;': '\u2191',
    'UpArrowBar;': '\u2912',
    'UpArrowDownArrow;': '\u21c5',
    'UpDownArrow;': '\u2195',
    'Updownarrow;': '\u21d5',
    'updownarrow;': '\u2195',
    'UpEquilibrium;': '\u296e',
    'upharpoonleft;': '\u21bf',
    'upharpoonright;': '\u21be',
    'uplus;': '\u228e',
    'UpperLeftArrow;': '\u2196',
    'UpperRightArrow;': '\u2197',
    'Upsi;': '\u03d2',
    'upsi;': '\u03c5',
    'upsih;': '\u03d2',
    'Upsilon;': '\u03a5',
    'upsilon;': '\u03c5',
    'UpTee;': '\u22a5',
    'UpTeeArrow;': '\u21a5',
    'upuparrows;': '\u21c8',
    'urcorn;': '\u231d',
    'urcorner;': '\u231d',
    'urcrop;': '\u230e',
    'Uring;': '\u016e',
    'uring;': '\u016f',
    'urtri;': '\u25f9',
    'Uscr;': '\U0001d4b0',
    'uscr;': '\U0001d4ca',
    'utdot;': '\u22f0',
    'Utilde;': '\u0168',
    'utilde;': '\u0169',
    'utri;': '\u25b5',
    'utrif;': '\u25b4',
    'uuarr;': '\u21c8',
    'Uuml': '\xdc',
    'uuml': '\xfc',
    'Uuml;': '\xdc',
    'uuml;': '\xfc',
    'uwangle;': '\u29a7',
    'vangrt;': '\u299c',
    'varepsilon;': '\u03f5',
    'varkappa;': '\u03f0',
    'varnothing;': '\u2205',
    'varphi;': '\u03d5',
    'varpi;': '\u03d6',
    'varpropto;': '\u221d',
    'vArr;': '\u21d5',
    'varr;': '\u2195',
    'varrho;': '\u03f1',
    'varsigma;': '\u03c2',
    'varsubsetneq;': '\u228a\ufe00',
    'varsubsetneqq;': '\u2acb\ufe00',
    'varsupsetneq;': '\u228b\ufe00',
    'varsupsetneqq;': '\u2acc\ufe00',
    'vartheta;': '\u03d1',
    'vartriangleleft;': '\u22b2',
    'vartriangleright;': '\u22b3',
    'Vbar;': '\u2aeb',
    'vBar;': '\u2ae8',
    'vBarv;': '\u2ae9',
    'Vcy;': '\u0412',
    'vcy;': '\u0432',
    'VDash;': '\u22ab',
    'Vdash;': '\u22a9',
    'vDash;': '\u22a8',
    'vdash;': '\u22a2',
    'Vdashl;': '\u2ae6',
    'Vee;': '\u22c1',
    'vee;': '\u2228',
    'veebar;': '\u22bb',
    'veeeq;': '\u225a',
    'vellip;': '\u22ee',
    'Verbar;': '\u2016',
    'verbar;': '|',
    'Vert;': '\u2016',
    'vert;': '|',
    'VerticalBar;': '\u2223',
    'VerticalLine;': '|',
    'VerticalSeparator;': '\u2758',
    'VerticalTilde;': '\u2240',
    'VeryThinSpace;': '\u200a',
    'Vfr;': '\U0001d519',
    'vfr;': '\U0001d533',
    'vltri;': '\u22b2',
    'vnsub;': '\u2282\u20d2',
    'vnsup;': '\u2283\u20d2',
    'Vopf;': '\U0001d54d',
    'vopf;': '\U0001d567',
    'vprop;': '\u221d',
    'vrtri;': '\u22b3',
    'Vscr;': '\U0001d4b1',
    'vscr;': '\U0001d4cb',
    'vsubnE;': '\u2acb\ufe00',
    'vsubne;': '\u228a\ufe00',
    'vsupnE;': '\u2acc\ufe00',
    'vsupne;': '\u228b\ufe00',
    'Vvdash;': '\u22aa',
    'vzigzag;': '\u299a',
    'Wcirc;': '\u0174',
    'wcirc;': '\u0175',
    'wedbar;': '\u2a5f',
    'Wedge;': '\u22c0',
    'wedge;': '\u2227',
    'wedgeq;': '\u2259',
    'weierp;': '\u2118',
    'Wfr;': '\U0001d51a',
    'wfr;': '\U0001d534',
    'Wopf;': '\U0001d54e',
    'wopf;': '\U0001d568',
    'wp;': '\u2118',
    'wr;': '\u2240',
    'wreath;': '\u2240',
    'Wscr;': '\U0001d4b2',
    'wscr;': '\U0001d4cc',
    'xcap;': '\u22c2',
    'xcirc;': '\u25ef',
    'xcup;': '\u22c3',
    'xdtri;': '\u25bd',
    'Xfr;': '\U0001d51b',
    'xfr;': '\U0001d535',
    'xhArr;': '\u27fa',
    'xharr;': '\u27f7',
    'Xi;': '\u039e',
    'xi;': '\u03be',
    'xlArr;': '\u27f8',
    'xlarr;': '\u27f5',
    'xmap;': '\u27fc',
    'xnis;': '\u22fb',
    'xodot;': '\u2a00',
    'Xopf;': '\U0001d54f',
    'xopf;': '\U0001d569',
    'xoplus;': '\u2a01',
    'xotime;': '\u2a02',
    'xrArr;': '\u27f9',
    'xrarr;': '\u27f6',
    'Xscr;': '\U0001d4b3',
    'xscr;': '\U0001d4cd',
    'xsqcup;': '\u2a06',
    'xuplus;': '\u2a04',
    'xutri;': '\u25b3',
    'xvee;': '\u22c1',
    'xwedge;': '\u22c0',
    'Yacute': '\xdd',
    'yacute': '\xfd',
    'Yacute;': '\xdd',
    'yacute;': '\xfd',
    'YAcy;': '\u042f',
    'yacy;': '\u044f',
    'Ycirc;': '\u0176',
    'ycirc;': '\u0177',
    'Ycy;': '\u042b',
    'ycy;': '\u044b',
    'yen': '\xa5',
    'yen;': '\xa5',
    'Yfr;': '\U0001d51c',
    'yfr;': '\U0001d536',
    'YIcy;': '\u0407',
    'yicy;': '\u0457',
    'Yopf;': '\U0001d550',
    'yopf;': '\U0001d56a',
    'Yscr;': '\U0001d4b4',
    'yscr;': '\U0001d4ce',
    'YUcy;': '\u042e',
    'yucy;': '\u044e',
    'yuml': '\xff',
    'Yuml;': '\u0178',
    'yuml;': '\xff',
    'Zacute;': '\u0179',
    'zacute;': '\u017a',
    'Zcaron;': '\u017d',
    'zcaron;': '\u017e',
    'Zcy;': '\u0417',
    'zcy;': '\u0437',
    'Zdot;': '\u017b',
    'zdot;': '\u017c',
    'zeetrf;': '\u2128',
    'ZeroWidthSpace;': '\u200b',
    'Zeta;': '\u0396',
    'zeta;': '\u03b6',
    'Zfr;': '\u2128',
    'zfr;': '\U0001d537',
    'ZHcy;': '\u0416',
    'zhcy;': '\u0436',
    'zigrarr;': '\u21dd',
    'Zopf;': '\u2124',
    'zopf;': '\U0001d56b',
    'Zscr;': '\U0001d4b5',
    'zscr;': '\U0001d4cf',
    'zwj;': '\u200d',
    'zwnj;': '\u200c',
}

# maps the Unicode code point to the HTML entity name
codepoint2name = {}

# maps the HTML entity name to the character
# (or a character reference if the character is outside the Latin-1 range)
entitydefs = {}

for (name, codepoint) in name2codepoint.items():
    codepoint2name[codepoint] = name
    entitydefs[name] = chr(codepoint)

del name, codepoint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """A parser for HTML and XHTML."""

# This file is based on sgmllib.py, but the API is slightly different.

# XXX There should be a way to distinguish between PCDATA (parsed
# character data -- the normal case), RCDATA (replaceable character
# data -- only char and entity references and end tags are special)
# and CDATA (character data -- only end tags are special).


import re
import warnings
import _markupbase

from html import unescape


__all__ = ['HTMLParser']

# Regular expressions used for parsing

interesting_normal = re.compile('[&<]')
incomplete = re.compile('&[a-zA-Z#]')

entityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')
charref = re.compile('&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]')

starttagopen = re.compile('<[a-zA-Z]')
piclose = re.compile('>')
commentclose = re.compile(r'--\s*>')
# Note:
#  1) if you change tagfind/attrfind remember to update locatestarttagend too;
#  2) if you change tagfind/attrfind and/or locatestarttagend the parser will
#     explode, so don't do it.
# see http://www.w3.org/TR/html5/tokenization.html#tag-open-state
# and http://www.w3.org/TR/html5/tokenization.html#tag-name-state
tagfind_tolerant = re.compile('([a-zA-Z][^\t\n\r\f />\x00]*)(?:\s|/(?!>))*')
attrfind_tolerant = re.compile(
    r'((?<=[\'"\s/])[^\s/>][^\s/=>]*)(\s*=+\s*'
    r'(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?(?:\s|/(?!>))*')
locatestarttagend_tolerant = re.compile(r"""
  <[a-zA-Z][^\t\n\r\f />\x00]*       # tag name
  (?:[\s/]*                          # optional whitespace before attribute name
    (?:(?<=['"\s/])[^\s/>][^\s/=>]*  # attribute name
      (?:\s*=+\s*                    # value indicator
        (?:'[^']*'                   # LITA-enclosed value
          |"[^"]*"                   # LIT-enclosed value
          |(?!['"])[^>\s]*           # bare value
         )
         (?:\s*,)*                   # possibly followed by a comma
       )?(?:\s|/(?!>))*
     )*
   )?
  \s*                                # trailing whitespace
""", re.VERBOSE)
endendtag = re.compile('>')
# the HTML 5 spec, section 8.1.2.2, doesn't allow spaces between
# </ and the tag name, so maybe this should be fixed
endtagfind = re.compile('</\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\s*>')



class HTMLParser(_markupbase.ParserBase):
    """Find tags and other markup and call handler functions.

    Usage:
        p = HTMLParser()
        p.feed(data)
        ...
        p.close()

    Start tags are handled by calling self.handle_starttag() or
    self.handle_startendtag(); end tags by self.handle_endtag().  The
    data between tags is passed from the parser to the derived class
    by calling self.handle_data() with the data as argument (the data
    may be split up in arbitrary chunks).  If convert_charrefs is
    True the character references are converted automatically to the
    corresponding Unicode character (and self.handle_data() is no
    longer split in chunks), otherwise they are passed by calling
    self.handle_entityref() or self.handle_charref() with the string
    containing respectively the named or numeric reference as the
    argument.
    """

    CDATA_CONTENT_ELEMENTS = ("script", "style")

    def __init__(self, *, convert_charrefs=True):
        """Initialize and reset this instance.

        If convert_charrefs is True (the default), all character references
        are automatically converted to the corresponding Unicode characters.
        """
        self.convert_charrefs = convert_charrefs
        self.reset()

    def reset(self):
        """Reset this instance.  Loses all unprocessed data."""
        self.rawdata = ''
        self.lasttag = '???'
        self.interesting = interesting_normal
        self.cdata_elem = None
        _markupbase.ParserBase.reset(self)

    def feed(self, data):
        r"""Feed data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '\n').
        """
        self.rawdata = self.rawdata + data
        self.goahead(0)

    def close(self):
        """Handle any buffered data."""
        self.goahead(1)

    __starttag_text = None

    def get_starttag_text(self):
        """Return full source of start tag: '<...>'."""
        return self.__starttag_text

    def set_cdata_mode(self, elem):
        self.cdata_elem = elem.lower()
        self.interesting = re.compile(r'</\s*%s\s*>' % self.cdata_elem, re.I)

    def clear_cdata_mode(self):
        self.interesting = interesting_normal
        self.cdata_elem = None

    # Internal -- handle data as far as reasonable.  May leave state
    # and data to be processed by a subsequent call.  If 'end' is
    # true, force handling all data as if followed by EOF marker.
    def goahead(self, end):
        rawdata = self.rawdata
        i = 0
        n = len(rawdata)
        while i < n:
            if self.convert_charrefs and not self.cdata_elem:
                j = rawdata.find('<', i)
                if j < 0:
                    # if we can't find the next <, either we are at the end
                    # or there's more text incoming.  If the latter is True,
                    # we can't pass the text to handle_data in case we have
                    # a charref cut in half at end.  Try to determine if
                    # this is the case before proceeding by looking for an
                    # & near the end and see if it's followed by a space or ;.
                    amppos = rawdata.rfind('&', max(i, n-34))
                    if (amppos >= 0 and
                        not re.compile(r'[\s;]').search(rawdata, amppos)):
                        break  # wait till we get all the text
                    j = n
            else:
                match = self.interesting.search(rawdata, i)  # < or &
                if match:
                    j = match.start()
                else:
                    if self.cdata_elem:
                        break
                    j = n
            if i < j:
                if self.convert_charrefs and not self.cdata_elem:
                    self.handle_data(unescape(rawdata[i:j]))
                else:
                    self.handle_data(rawdata[i:j])
            i = self.updatepos(i, j)
            if i == n: break
            startswith = rawdata.startswith
            if startswith('<', i):
                if starttagopen.match(rawdata, i): # < + letter
                    k = self.parse_starttag(i)
                elif startswith("</", i):
                    k = self.parse_endtag(i)
                elif startswith("<!--", i):
                    k = self.parse_comment(i)
                elif startswith("<?", i):
                    k = self.parse_pi(i)
                elif startswith("<!", i):
                    k = self.parse_html_declaration(i)
                elif (i + 1) < n:
                    self.handle_data("<")
                    k = i + 1
                else:
                    break
                if k < 0:
                    if not end:
                        break
                    k = rawdata.find('>', i + 1)
                    if k < 0:
                        k = rawdata.find('<', i + 1)
                        if k < 0:
                            k = i + 1
                    else:
                        k += 1
                    if self.convert_charrefs and not self.cdata_elem:
                        self.handle_data(unescape(rawdata[i:k]))
                    else:
                        self.handle_data(rawdata[i:k])
                i = self.updatepos(i, k)
            elif startswith("&#", i):
                match = charref.match(rawdata, i)
                if match:
                    name = match.group()[2:-1]
                    self.handle_charref(name)
                    k = match.end()
                    if not startswith(';', k-1):
                        k = k - 1
                    i = self.updatepos(i, k)
                    continue
                else:
                    if ";" in rawdata[i:]:  # bail by consuming &#
                        self.handle_data(rawdata[i:i+2])
                        i = self.updatepos(i, i+2)
                    break
            elif startswith('&', i):
                match = entityref.match(rawdata, i)
                if match:
                    name = match.group(1)
                    self.handle_entityref(name)
                    k = match.end()
                    if not startswith(';', k-1):
                        k = k - 1
                    i = self.updatepos(i, k)
                    continue
                match = incomplete.match(rawdata, i)
                if match:
                    # match.group() will contain at least 2 chars
                    if end and match.group() == rawdata[i:]:
                        k = match.end()
                        if k <= i:
                            k = n
                        i = self.updatepos(i, i + 1)
                    # incomplete
                    break
                elif (i + 1) < n:
                    # not the end of the buffer, and can't be confused
                    # with some other construct
                    self.handle_data("&")
                    i = self.updatepos(i, i + 1)
                else:
                    break
            else:
                assert 0, "interesting.search() lied"
        # end while
        if end and i < n and not self.cdata_elem:
            if self.convert_charrefs and not self.cdata_elem:
                self.handle_data(unescape(rawdata[i:n]))
            else:
                self.handle_data(rawdata[i:n])
            i = self.updatepos(i, n)
        self.rawdata = rawdata[i:]

    # Internal -- parse html declarations, return length or -1 if not terminated
    # See w3.org/TR/html5/tokenization.html#markup-declaration-open-state
    # See also parse_declaration in _markupbase
    def parse_html_declaration(self, i):
        rawdata = self.rawdata
        assert rawdata[i:i+2] == '<!', ('unexpected call to '
                                        'parse_html_declaration()')
        if rawdata[i:i+4] == '<!--':
            # this case is actually already handled in goahead()
            return self.parse_comment(i)
        elif rawdata[i:i+3] == '<![':
            return self.parse_marked_section(i)
        elif rawdata[i:i+9].lower() == '<!doctype':
            # find the closing >
            gtpos = rawdata.find('>', i+9)
            if gtpos == -1:
                return -1
            self.handle_decl(rawdata[i+2:gtpos])
            return gtpos+1
        else:
            return self.parse_bogus_comment(i)

    # Internal -- parse bogus comment, return length or -1 if not terminated
    # see http://www.w3.org/TR/html5/tokenization.html#bogus-comment-state
    def parse_bogus_comment(self, i, report=1):
        rawdata = self.rawdata
        assert rawdata[i:i+2] in ('<!', '</'), ('unexpected call to '
                                                'parse_comment()')
        pos = rawdata.find('>', i+2)
        if pos == -1:
            return -1
        if report:
            self.handle_comment(rawdata[i+2:pos])
        return pos + 1

    # Internal -- parse processing instr, return end or -1 if not terminated
    def parse_pi(self, i):
        rawdata = self.rawdata
        assert rawdata[i:i+2] == '<?', 'unexpected call to parse_pi()'
        match = piclose.search(rawdata, i+2) # >
        if not match:
            return -1
        j = match.start()
        self.handle_pi(rawdata[i+2: j])
        j = match.end()
        return j

    # Internal -- handle starttag, return end or -1 if not terminated
    def parse_starttag(self, i):
        self.__starttag_text = None
        endpos = self.check_for_whole_start_tag(i)
        if endpos < 0:
            return endpos
        rawdata = self.rawdata
        self.__starttag_text = rawdata[i:endpos]

        # Now parse the data between i+1 and j into a tag and attrs
        attrs = []
        match = tagfind_tolerant.match(rawdata, i+1)
        assert match, 'unexpected call to parse_starttag()'
        k = match.end()
        self.lasttag = tag = match.group(1).lower()
        while k < endpos:
            m = attrfind_tolerant.match(rawdata, k)
            if not m:
                break
            attrname, rest, attrvalue = m.group(1, 2, 3)
            if not rest:
                attrvalue = None
            elif attrvalue[:1] == '\'' == attrvalue[-1:] or \
                 attrvalue[:1] == '"' == attrvalue[-1:]:
                attrvalue = attrvalue[1:-1]
            if attrvalue:
                attrvalue = unescape(attrvalue)
            attrs.append((attrname.lower(), attrvalue))
            k = m.end()

        end = rawdata[k:endpos].strip()
        if end not in (">", "/>"):
            lineno, offset = self.getpos()
            if "\n" in self.__starttag_text:
                lineno = lineno + self.__starttag_text.count("\n")
                offset = len(self.__starttag_text) \
                         - self.__starttag_text.rfind("\n")
            else:
                offset = offset + len(self.__starttag_text)
            self.handle_data(rawdata[i:endpos])
            return endpos
        if end.endswith('/>'):
            # XHTML-style empty tag: <span attr="value" />
            self.handle_startendtag(tag, attrs)
        else:
            self.handle_starttag(tag, attrs)
            if tag in self.CDATA_CONTENT_ELEMENTS:
                self.set_cdata_mode(tag)
        return endpos

    # Internal -- check to see if we have a complete starttag; return end
    # or -1 if incomplete.
    def check_for_whole_start_tag(self, i):
        rawdata = self.rawdata
        m = locatestarttagend_tolerant.match(rawdata, i)
        if m:
            j = m.end()
            next = rawdata[j:j+1]
            if next == ">":
                return j + 1
            if next == "/":
                if rawdata.startswith("/>", j):
                    return j + 2
                if rawdata.startswith("/", j):
                    # buffer boundary
                    return -1
                # else bogus input
                if j > i:
                    return j
                else:
                    return i + 1
            if next == "":
                # end of input
                return -1
            if next in ("abcdefghijklmnopqrstuvwxyz=/"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
                # end of input in or before attribute value, or we have the
                # '/' from a '/>' ending
                return -1
            if j > i:
                return j
            else:
                return i + 1
        raise AssertionError("we should not get here!")

    # Internal -- parse endtag, return end or -1 if incomplete
    def parse_endtag(self, i):
        rawdata = self.rawdata
        assert rawdata[i:i+2] == "</", "unexpected call to parse_endtag"
        match = endendtag.search(rawdata, i+1) # >
        if not match:
            return -1
        gtpos = match.end()
        match = endtagfind.match(rawdata, i) # </ + tag + >
        if not match:
            if self.cdata_elem is not None:
                self.handle_data(rawdata[i:gtpos])
                return gtpos
            # find the name: w3.org/TR/html5/tokenization.html#tag-name-state
            namematch = tagfind_tolerant.match(rawdata, i+2)
            if not namematch:
                # w3.org/TR/html5/tokenization.html#end-tag-open-state
                if rawdata[i:i+3] == '</>':
                    return i+3
                else:
                    return self.parse_bogus_comment(i)
            tagname = namematch.group(1).lower()
            # consume and ignore other stuff between the name and the >
            # Note: this is not 100% correct, since we might have things like
            # </tag attr=">">, but looking for > after tha name should cover
            # most of the cases and is much simpler
            gtpos = rawdata.find('>', namematch.end())
            self.handle_endtag(tagname)
            return gtpos+1

        elem = match.group(1).lower() # script or style
        if self.cdata_elem is not None:
            if elem != self.cdata_elem:
                self.handle_data(rawdata[i:gtpos])
                return gtpos

        self.handle_endtag(elem.lower())
        self.clear_cdata_mode()
        return gtpos

    # Overridable -- finish processing of start+end tag: <tag.../>
    def handle_startendtag(self, tag, attrs):
        self.handle_starttag(tag, attrs)
        self.handle_endtag(tag)

    # Overridable -- handle start tag
    def handle_starttag(self, tag, attrs):
        pass

    # Overridable -- handle end tag
    def handle_endtag(self, tag):
        pass

    # Overridable -- handle character reference
    def handle_charref(self, name):
        pass

    # Overridable -- handle entity reference
    def handle_entityref(self, name):
        pass

    # Overridable -- handle data
    def handle_data(self, data):
        pass

    # Overridable -- handle comment
    def handle_comment(self, data):
        pass

    # Overridable -- handle declaration
    def handle_decl(self, decl):
        pass

    # Overridable -- handle processing instruction
    def handle_pi(self, data):
        pass

    def unknown_decl(self, data):
        pass

    # Internal -- helper to remove special character quoting
    def unescape(self, s):
        warnings.warn('The unescape method is deprecated and will be removed '
                      'in 3.5, use html.unescape() instead.',
                      DeprecationWarning, stacklevel=2)
        return unescape(s)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
ì≠[î  „            ~   @   s∫  d  Z  d d l Z d d l m Z d d g Z d d d Ñ Z d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF dG dH dI dJ i" Z dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db dc dd de d d d d d d d d d d d d! d# d% d' d) d+ d- d/ d1 d3 d5 d7 d9 d; d= d? dA dC dE dG dI df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d dÄ dÅ dÇ dÉ dÑ dÖ dÜ dá dà dâ dä dã då dç dé dè dê dë dí dì dî dï dñ dó dò dô dö dõ dú dù dû dü d† d° d¢ d£ d§ d• d¶ dß d® h~ Z	 d© d™ Ñ  Z
 e j d´ É Z d¨ d Ñ  Z d S)≠z*
General functions for HTML manipulation.
È    N)⁄html5⁄escape⁄unescapeTc             C   sd   |  j  d d É }  |  j  d d É }  |  j  d d É }  | r` |  j  d d É }  |  j  d	 d
 É }  |  S)zı
    Replace special characters "&", "<" and ">" to HTML-safe sequences.
    If the optional flag quote is true (the default), the quotation mark
    characters, both double quote (") and single quote (') characters are also
    translated.
    ˙&z&amp;˙<z&lt;˙>z&gt;˙"z&quot;˙'z&#x27;)⁄replace)⁄sZquote© r   ˙#/usr/lib/python3.5/html/__init__.pyr      s    u   ÔøΩÈ   ˙ÈÄ   u   ‚Ç¨ÈÅ   ı   ¬ÅÈÇ   u   ‚ÄöÈÉ   u   ∆íÈÑ   u   ‚ÄûÈÖ   u   ‚Ä¶ÈÜ   u   ‚Ä†Èá   u   ‚Ä°Èà   u   ÀÜÈâ   u   ‚Ä∞Èä   u   ≈†Èã   u   ‚ÄπÈå   u   ≈íÈç   ı   ¬çÈé   u   ≈ΩÈè   ı   ¬èÈê   ı   ¬êÈë   u   ‚ÄòÈí   u   ‚ÄôÈì   u   ‚ÄúÈî   u   ‚ÄùÈï   u   ‚Ä¢Èñ   u   ‚ÄìÈó   u   ‚ÄîÈò   u   ÀúÈô   u   ‚Ñ¢Èö   u   ≈°Èõ   u   ‚Ä∫Èú   u   ≈ìÈù   ı   ¬ùÈû   u   ≈æÈü   u   ≈∏È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   È   i–˝  i—˝  i“˝  i”˝  i‘˝  i’˝  i÷˝  i◊˝  iÿ˝  iŸ˝  i⁄˝  i€˝  i‹˝  i›˝  iﬁ˝  iﬂ˝  i‡˝  i·˝  i‚˝  i„˝  i‰˝  iÂ˝  iÊ˝  iÁ˝  iË˝  iÈ˝  iÍ˝  iÎ˝  iÏ˝  iÌ˝  iÓ˝  iÔ˝  È   i˛ˇ  iˇˇ  i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ	 iˇˇ	 i˛ˇ
 iˇˇ
 i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ i˛ˇ iˇˇ c             C   sJ  |  j  d É }  |  d d k rÕ |  d d k rT t |  d d  Ö j d É d É } n t |  d d  Ö j d É É } | t k rá t | Sd | k oû d	 k n sØ | d
 k r≥ d S| t k r√ d St | É S|  t k r· t |  Sxb t t |  É d d d É D]< } |  d  | Ö t k r˛ t |  d  | Ö |  | d  Ö Sq˛ Wd |  Sd  S)Nr5   r   ˙#ZxXr6   ˙;r?   i ÿ  iˇﬂ  iˇˇ u   ÔøΩ⁄ r   Èˇˇˇˇ)	⁄group⁄int⁄rstrip⁄_invalid_charrefs⁄_invalid_codepoints⁄chr⁄_html5⁄range⁄len)r   Znum⁄xr   r   r   ⁄_replace_charref[   s$    %(
#$r_   z7&(#[0-9]+;?|#[xX][0-9a-fA-F]+;?|[^\t\n\f <&#;]{1,32};?)c             C   s    d |  k r |  St  j t |  É S)a^  
    Convert all named and numeric character references (e.g. &gt;, &#62;,
    &x3e;) in the string s to the corresponding unicode characters.
    This function uses the rules defined by the HTML 5 standard
    for both valid and invalid character references, and the list of
    HTML 5 named character references defined in html.entities.html5.
    r   )⁄_charref⁄subr_   )r   r   r   r   r   z   s    )⁄__doc__⁄reZ_reZhtml.entitiesr   r[   ⁄__all__r   rX   rY   r_   ⁄compiler`   r   r   r   r   r   ⁄<module>   sp   $$$                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
ì≠[3& „            n  @   s£:  d  Z  d d d d g Z d d d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF dG dH dI dJ dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d dÄ dÅ dÇ dÉ dÑ dÖ dÜ dá dà dâ dä dã då dç dé dè dê dë dí dì dî dï dñ dó dò dô dö dõ dú dù dû dü d† d° d¢ d£ d§ d• d¶ dß d® d© d™ d´ d¨ d≠ dÆ dØ d∞ d± d≤ d≥ d¥ dµ d∂ d∑ d∏ dπ d∫ dª dº dΩ dæ dø d¿ d¡ d¬ d√ dƒ d≈ d∆ d« d» d… d  dÀ dÃ dÕ dŒ dœ d– d— d“ d” d‘ d’ d÷ d◊ dÿ dŸ d⁄ d€ d‹ d› dﬁ dﬂ d‡ d· d‚ d„ d‰ dÂ dÊ dÁ dË dÈ dÍ dÎ dÏ dÌ dÓ dÔ d dÒ dÚ dÛ dÙ dı dˆ d˜ d¯ d˘ d˙ d˚ d¸ d˝ d˛ dˇ d ddddddddd	d
dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~ddÄdÅdÇdÉdÑdÖdÜdádàdâdädãdådçdédèdêdëdídìdîdïdñdódòdôdödõdúdùdûdüd†d°d¢d£d§d•d¶dßd®d©d™d´d¨d≠dÆdØd∞d±d≤d≥d¥dµd∂d∑d∏dπd∫dªdºdΩdædød¿d¡d¬d√dƒd≈d∆d«d»d…d dÀdÃdÕdŒdœd–d—d“d”d‘d’d÷d◊dÿdŸd⁄d€d‹d›dﬁdﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdÍdÎdÏdÌdÓdÔddÒdÚdÛdÙdıdˆd˜d¯d˘d˙d˚d¸i¸ Z d d˝d{ d˛dˇd˝d d˛ddddddddd	d
d	 dd} dddddd dddddddd ddÅ dddddddddddd ddÉ d d!dd"d d#d$d%d$d&d'd(d)d*d+d,d-d.d/d0d1dâ d1d2d1d3d1d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdAdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwddxdldydrd d`dè dzd{d`d|dzd}d~ddÄdÅdÇdÉdÑdÖdldÜdád dàdì dâdädàdãdâd dådï dçdédådèdçdêdëdídìdîdïdñdódòdôdödõdúdùdûdüd†d°d¢d£d§d•d¶dßd®dßd©d™d´d¨d≠dïdÆdØd∞d±d≤d≥d¥dµd∂dµd∑dµd∏dπd∫dódªdºdΩdºdædød¿d¡d¬d√dƒd≈d∆d«d»d…d dÀdÃdÕdŒdœd–d—d“d”d‘d’d÷d◊dÿdŸd⁄d€d‹d›dﬁdﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdÍdÎdÏdÌdÓdÔddÒdÚdÛdÙdıdˆd˜d¯d˘d˙d˚d¸d˝d˛dˇd ddddddddd	d
d	dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedôdfdgdhdgdõ didjdidkdºdldmdndodpdõdqdùdrdsdtdudvdwdxdydzdyd{d|d}d~ddÄdÅd|dÇdÄdÉdÑdÖdÜdádàdâdädãdådçdédèdêdëdídìdîdïdñdódòdôdödõdúdùdûdüd†d°d¢d£d§d d•d° d¶dßd•d®d¶d©d™d´d¨d≠dÆdØd∞d±d≤d≥d¥dµd∂d£ d∑d∏d∑dπd∑d∫dªd• dºdΩdºdædød¿død¡dûd¬d√dƒd≈d∆d«d»d…d d…dÀdÃdÕdŒdœd–d—d“d”d‘d’d÷d◊dÿdŸd⁄d€d‹d›dﬁdﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdÍdÎdÏdÌd‘dÓdÔddÒdÚdÛdÙdıdˆd˜d¯d˘d˙d˚d¸d˚d˝d˛dˇd ddddÇddÇddddd	d
dddd
ddddddddddddddddddddd dd!d"dØ d"d#d"d$d"d%d&d'dëd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdádOdPdQdRdSdTdUdVdWdXdYdZd[d\d]dAd^dCd_d`dadbdµ dcdddcdedEdfdZdgd`dhdbdidıdjdkdldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~ddÄdÅdÇdÉdÑdÖdÜdádàdâdädãdådñdçdédèdodêdëdídìdîdïdΩ dñdódñdòdôdödõdúdùdûdüd†d°d¢d£d§d•d¶dßd®d©d™d´d¨dd≠dÆdØdÉd∞d±d≤d≥d¥dµd∂dµd∑dµd∏dπd∫dπdªdºdΩdédædød¿d¡d¬d√d√ d√dƒd√d≈d∆d«d∆d»d…d dÀdÃdÕdŒdœd–d—d“d”d‘d’d÷dºd◊dÆdÿdŸd⁄d€d‹d›dﬁd€dﬂd‡d·d‚d„d‰dÂd•dÊddÁdºdËdwdÈdÍdÎdÏdÌd}dÓdÔddÒdÚdÛdÙdıdˆd˜d¯d˘d˙d˚d¸d˝d˛dydˇdwd dyddddddddëdd©d	d´d
dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4dÌd5dd6d7d8d9d:d;d<d=d>d?d! d@d≈ dAdBd@dCdAdDdEdFdGdHdIdJdKd# dLd« dMdNdLdOdMdPdQdRdSdTdUdVdïdWdXdYd›dZd[d\d]d^d_d`dadbdcddded% dfd… dgdhdfdidgdjdkdldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~ddÄddÅdÇdÉddÑdÖdÜdádàdâdädãdådçdédèdêdëdídìdîdïdñdódòdôdödõdúdùdûdüd†d°d¢d£d§d°d•d¶dßdKd®dQd©d™d´dkd¨dwd≠dÆdØd∞d±d™d≤d≥d¥dµd∂dd∑d∏dπd∫dªdºdΩdædød¿d¡d¬d√d€dƒd≈d∆d™d«d»d…d d dÀd◊ dÃdÕdÀdŒdÃd+ dœdŸ d–d—dœd“d–d”d‘d’d÷d◊dÿdŸdÿd⁄d¿d€d]d‹d]d›d_dﬁdﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdÍdÎdÏdÌdÓdÔddÒdÚdÈdÛdÙdıdˆd˜d¯d˘d˙d˚d¸d˝d˛dˇd dddddddddd	d
dd„ ddddddÂ ddddddddddddddÁ dddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d	d/d0d1d2d3d4d5d6d7d8d9død:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdQdWdOdXdYdZdYd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodldpdqdrdsdtdudvdwdxdydzd{d|d}d~ddÄddÅdÇdÉdÑdÖdÑdÜdÇdádàdâdädãdådçd±dédQdèdUdêdOdëdídìdwdîdYdïdñdódòdôdödõdñdúdùdûdüd†d°dÔ d°d¢d°d£dnd§d°d•d¶dßd®d©d™d´d¨d≠dÆdØd;d∞d±d≤d™d≥dUd¥dSdµdwd∂dñd∑d∏dπd∏d∫dúdªdºdΩddædød¿d¡d¬d√dƒdÏd≈d∆d«d»d…d dÀdÃdÕdŒdœd–d—d“d”d‘d’d‘d÷d◊dÿdŸd⁄d€d‹d›dﬁdødﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdÍdÎdÏdÌdÓdÔddÒd"dÚdødÛdÙdıdŒdˆd˜d¯d˘d˙d|d˚dÄd¸d˝d˛d{d/ dˇd˘ d ddˇdd ddd1 dd˚ dddddd	d
ddddddddd˝ dddddÏddddd3 ddˇ dddddddd d!d"d#d$d%d&d'd(d)d*d+d,dd-d.d/d0d1dd2dd3d4d5dd6d7d8d9d:d;d<dıd=dqd>d?d@dAdBdCdDd7dEdFdGdHdIdJdKdLdMdHdNdJdOdÀdPdQdRdSdTddUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdSd	dhdidhdjd4dkdldmdqdndodpdqdrdsdtdudvdqdwdVdxdydzd{d|d}d~dd7 dÄddÅdÇdÄdÉdÅdÑdÖdÜdádàdâdädãdådçdédèdêdëdídìdîdïdñdódòdôdödõdúdùdûdüd†d°d¢d£d§d•d¶dßd®d©d™d´d¨d≠dÆdØd∞d±d≤d≥d¥dµd∂d∑d∏dπd∫dªdºdΩdædød¿d¡d¬d√dƒd≈d∆d«d»d…d dÀdÃdÕdŒdœd–d—d“d”d‘d’d÷d◊dÿdŸd⁄d◊d€d‹d›dœddﬁdﬂdﬁd‡d·d‚dÍd„d‰dÂdÊdÁdËdÈdÍdÎdËdÏdÌdÓdÔddÒdÚdÛdÙdıdˆd˜d¯d˘d˙d˚d¸d˝d˛dˇd ddddddddd	d
ddddddddddddddddddddddd d!d≥d"d#d$d%d&d'd(d)d*d+d,d◊d-d‰d.dÍd/d‰d0dÊd1d2d3dÛd4dd5d6d7d8d9d©d:d;d<d=d>dd?d@dAdBdCd∆dDdÏdEd∆dFd2dGdHdId dJdKdLddMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dad@dbdcdddedfdgdhd+did)djdkdldkdmdndodpdqdrdsdtdudvdwdxdyd‹dzd{d|dgd}ded~dgdd)dÄdÅdÇdÅdÉdÑdÖdÜdádkdàdÜdâdädãd=dådçdédèdêdÅdëdídìdîdïddñd@dódòdôdödõdúdùdûdüd†d°d¢d£dBd§dÕd•d«d¶dßd®d©d™d´d¨d≠dÆdØd∞dØd±d≤d≥d≤d¥dµd∂d∑d∏d∑dπdµd∫dªdºdΩdædød¿d6d¡d¬d√dÔdƒd¬d≈d∆d«dÒd»d∆d…d dÀdÃdÕdÛdŒdÃdœdÌd–d—d“d”d‘d’d÷d◊dÿdŸd⁄d€d‹d›dﬁdﬂd‡d·d‚d„d‰dÂdÊdÂdÁdÁdËdÈdÍdÎdÏd2dÌddÓdHdÔddÒdÚdÛdÙdıdˆd˜dœd¯d˘d˙d˚d¸d˚d˝dÜd˛dˇd 	d	d	dd	d	d	d	d	d	d		d
	d	d	d-d	d	d	d	d¢d	d	d	d	d	d	d	d{d	dRd	d	d	d	d	d	d	d	d	dXd	dÔd 	d!	d"	d#	d$	d%	d&	d'	d(	d'	d/d)	d*	d)	d+	d,	d-	d.	d/	d.	d0	d1	d2	d3	d4	d3	d5	dd6	dNd7	d8	d9	d:	d;	d<	d=	d>	d?	d@	dA	dB	dC	dD	dE	dFdF	dG	dH	dI	dJ	dK	dL	dM	dN	dO	d3dP	dQ	dP	dR	dS	dT	dÑdU	dV	d5dødW	dødX	dY	dZ	d4d[	d‡d\	d]	d^	d_	d`	da	db	d◊dc	d_	dd	de	df	dg	dh	di	dj	d_	dk	dI	dl	dm	dn	ddo	dp	dq	dr	ds	dt	du	dt	dv	dôdw	dx	dy	dz	d{	d|	d}	d~	d	dÄ	dÅ	dÇ	dÉ	dÑ	dÖ	d~	dÜ	dá	dà	dá	dâ	dä	d=dã	då	dã	dç	dé	dè	dê	dë	dí	dì	dî	dï	dñ	dó	dò	dô	dö	dõ	dú	dù	dû	dü	d†	d°	d¢	d£	d§	d•	d¶	dß	d®	d©	d™	d´	d¨	d≠	dÆ	dØ	dÆ	d∞	d±	d≤	d≥	d¥	d≥	dµ	d≥	d∂	d≥	d∑	d∏	dπ	d∫	dª	dº	dΩ	dndæ	d¢dø	d¿	d¡	d¬	d√	d¬	dƒ	d≈	d∆	d«	d»	d…	d 	dÀ	dÃ	dÀ	dÕ	d…	dŒ	dœ	d–	dœ	d—	d“	d”	d‘	d’	d÷	d◊	dÿ	dŸ	dÿ	d⁄	d€	d‹	d›	dﬁ	dﬂ	d‡	d·	d‚	d„	d‰	dÂ	dÊ	dÁ	dË	d„	dÈ	dÍ	dÎ	dÏ	dÌ	dÓ	dÔ	d	dÒ	dÚ	dÛ	dÙ	dı	dˆ	d˜	dÓ	d¯	d	d˘	d›	d˙	dﬂ	d˚	dˆ	d¸	dÙ	d˝	d˛	dˇ	d˛	d 
d
d
d
d
d
d
d
d
d
d	
d

d
d
d
d
d
d
d
d
d
dã	d
dä	d
d
dEd
d
d
d
d
d
d∏	d
d
d
d
d 
d!
d"
d®	d#
dº	d$
d¬	d%
dÿ	d&
dÀ	d'
d…	d(
d€	d)
d*
d+
dœ	d,
d‘	d-
dé	d.
dê	d/
d!
d0
d1
d2
d3
d4
d!
d5
d6
d7
d8
d9
d

d:
d;
d<
d
d=
d
d>
dˆ	d?
d@
dA
d
dB
d˛	dC
d
dD
dE
dF
dG
dH
dI
dJ
dI
dK
dL
dM
dN
dO
dP
dQ
dR
dS
dT
dU
dI
dV
dW
dX
dY
dZ
d[
d\
d]
d^
d_
d`
da
db
dc
dd
de
df
dg
dh
di
dj
dk
dl
dm
dn
do
dp
dq
dr
ds
dt
du
dv
dw
dx
dú	dy
d~	dz
d
d{
d
d|
d
d}
d~
d
dÄ
dÅ
dÇ
dÉ
dP
dÑ
dT
dÖ
dR
dÜ
dP
dá
dR
dà
dâ
dä
dã
då
dç
dé
dè
dê
dâ
dë
dã
dí
dW
dì
d[
dî
di
dï
dm
dñ
dk
dó
dò
dô
dö
dõ
d
dú
d
dù
du
dû
dw
dü
dw
d†
d
d°
d
d¢
d_
d£
dc
d§
d•
d¶
dß
d®
dg
d©
de
d™
dg
d´
dß
d¨
di
d≠
dk
dÆ
dØ
d∞
d±
d≤
ds
d≥
dq
d¥
ds
dµ
d±
d∂
d*
d? d∑
dKd∏
dπ
d∑
d∫
d∏
dª
d@
dº
d

dΩ
d
dæ
dW
dø
d[
d¿
d¡
d¬
d√
dƒ
d≈
d∆
d«
d»
d…
d 
dÀ
dÃ
dÕ
dŒ
dœ
d–
d—
d“
d”
d‘
d’
d÷
d◊
dÿ
dŸ
d⁄
d€
d‹
d›
dﬁ
dﬂ
d‡
d·
d‚
d„
d‰
dÂ
dÊ
dÁ
dË
dÈ
dÍ
dÎ
dÏ
dÌ
dÓ
dÔ
d
dÔ
dÒ
dÚ
dE dÛ
dOdÙ
dı
dÛ
dˆ
dÙ
d˜
d⁄d¯
d‹dG d˘
dQd˙
d˚
d˘
d¸
d˙
d˝
d˛
dˇ
d ddﬁdddddddd‡d	d
dddddddddddddI ddUddddddddddd d!dd"d÷d#d$d%d&d'd(d)d*d+d,d-d.d/d d0d1d2d3d4d5d6d7d8dÊd9d:d;d<d=d>d?d d@d	dAdBdCdËdDdEdFdGdHdÿdIdJdKdLdMdLdadNdOdNdcdPdQdPdRdSdTdUdVdWdXdYdZd‰d[d\d]dLdO d^ded_d`d^dad_dbdcdQ dddgdedfdddgdedhdidjdÍdkdldS dmdkdndodmdpdndqdrdsd(dtdudvdwdxdydzd˝dmd{d|d{d}d˝d~ddÄdÅdÇdÉdÑdÉdÖdÜdádàdâdädãdådçdédèd	dêdëdídìdîdïdñdódòdôdödõdúdI	dùdûdüd†d°d¢d£dd§d•d¶dŒdßd®d©dŒd™d´d¨d≠dÆd6dØd∞d±d‚d≤d≥d¥dµd∂d∑d{d∑d∏d∑dπd∫dªdºdΩd∑dæd€død¿d¡d¬d√dƒd}d≈d∆d≈d«d»d…d dÀdÃdÕdŒdœd–d—d“d”d d‘dÃd’dŒd÷d d◊d“dÿdŒdŸd⁄d€d“d‹d›dﬁdﬂd‡d·d‚d⁄d„d‰dÂdÊdÁd¬dËd›dÈdﬂdÍd·dÎdÏdÌdÏdÓdÔddÒdÚdÛdÙdıdˆd˛d˜dıd¯dıd˘d⁄d˙d˚d¸d˝d˛dˇd ddddddddd	d
d!ddddddddddddÏdddddd≥dddáddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d.dèd4d5d4d6d7d8dıd9d:d;d<d=d>d?d@dAdBdCdDdEdÍdFd—dGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWddXddYdÅdZdÂd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqd^drdsdtdudvdwdxdydzd˜d{d˜d|d}d~ddÄddÅdÇdÉddÑdÖdÜdádàd‚dôd‚dâd‚däd‚dãd„	dådHdçd7dédèdêdëdíddìdîdïdñdóddòdôdödõdúdùdûdüd†d°d¢d.d£d:d§dıd•d:d¶d>dßd®d©dNd™dpd´d¨d≠dÆdØd´d∞d±d≤dëd≥dd¥dôdµd®d∂dµd∑d∏dπdPd∫dªdºd3	dΩdædød¿d¡d¬d√dƒd≈d∆d«d»d…d dÀdÃdÕdŒdœdôd–d—d“d”d‘dæd’d®d÷dµd◊dÿdŸd⁄d€d⁄d‹d›dﬁdﬂd‡d·d‚d¨d„d‰dÂdÖdÊdÁdËdÈdÍdÎdÏdÌdÓdÔddÒdÚdÛdÙd∏dıd dˆd˜d¯dÇd˘d˙d˚d¸d˝d¸d˛d`dˇd˘d d˘dd¿dddddd∆ddÒdd	d
ddddddddddd	dddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d‰d>d?d@d‡dAdBdCd„dDd„d´dEdFdEdGdHdIdJdKdüdLdüdMdNdOdPdQdRdSd-dTdUdVdWdXdYdZd[d\d]d^dyd_d‰d`dS	dad˝dbd:dcddd≠dedfdedgdhdidjdkdldmdldndodpdqdrdsdtdsdudvdwdxdydzd{d|d}d~ddÄdÅdÇdÉd‰dÑddÖdüdÜdádàdâdädS	dãdådçdédèdêdëdídìdîdïdñdódòdôdödõdúdùdûdüd†d°d¢d£d¢d§d˝d•d¶dßd®d©d™d´d¨d≠d(dÆdØd∞d±d≤dØd≥d±d¥dµd∂d∑d∏dµdπd∑d∫dªdºdªdΩdªdæd¶dødØd¿d±d¡dµd¬d∑d√d™dƒdÈd≈dÈd∆d:d«d»d…d dÀdüdÃdådÕdŒdœdŒd–d—d“dŸd”d¶d‘dõd’d)	d÷d◊dÿdŸd⁄d€d‹d›dﬁdﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdÍdÎdÏd◊dÌdŸdÓdﬂdÔd›ddﬂdÒdÁdÚdÂdÛdÙdıdˆd˜d¯d˘dd˙dd˚d d¸dd˝d$d˛d dˇd6d d$dd.dd0dd2dd6dd„	ddddd	d
dødddd¡dddd√dddddddddddddddddddd dd!d"d#d$d%d&d'd(d)d*d+d,d-d.d/dd0dd1dd2dd3d,d4d*d5d6d7d8d9d:d;d‚d<d=d>d·d?d·d@dAd«dBdCdBdDdEdFdGdHdIdJdKdLdwdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdbdddbdedfdgdhdidjdkdjdldldmdodndodpdqdrdqdsdldtdodc dud”dvdwdudxdvdydodzd≥d{dsd|dd}dld◊d~dd~dÄd8dÅdÇdÉdÑdÖd#dÜd∫	dáddàdâdädãdådçdédèdêdëdídJdìdîdïdñdódñdòdôdöd3dõd	dúdXdùdûdüdd†d∆d°d¢d£dûd§d•d¶dZdßd®d©d™d´d¨d≠dÆdØd∞d±d≤d≥d¥dµd∂d∑d∏dπd∫dªdºdΩdædød≈d¿d·d¡d7di d¬d›d√dƒd¬d≈d√d∆d«d»d˘d…ddd dÀdÃdÕdŒdœd–d—d“d”dk d‘d·d’d÷d‘d◊d’dÿdŸd⁄d€d‹d›dﬁdﬂd‡d·d‚d„d‰dÂdÊdÁdËdÈdm dÍd„dÎdÏdÍdÌdÎdÓdÔdd^dÒdÃdÚdÛdÙdıdˆdıd˜d¯d˘d˙d˚d¸d˝d˛dÂdºdˇdºd dﬂdddd™ddddœddd	d
ddddddddddd˘ddddddd›dddd˚dddd„dd^ddÃddddÔ
d dÆ	d!d"d#d$d%d"d&d'd(d$d)d	d*d8	d+d,d-d.d/d.d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdôdCdÎdDd,dq dEdÎdFdGdEdHdFdIdJdKdLdMd¶dNdßdOddPdõdQd•dRdıdSd˚dTddUd°dVdldWdXdYdZd[d\d]d^d_djd`dTdad¬dbdcdddedfdgdhdidjdkdldmdndodpd˜dqdªdrdsdtd·dudGdvdwdxdydzd{d|d}d~ddÄd}dÅddÇdS	dÉddÑdÖdÜdádàdºdâdädãdådçdTdéde
dèdq
dêdëdídìdîdıdïd¬dñdódòdôdödZdõdXdúd^dùd\dûdüd†d°d¢d£d§d•d¶dßd®d„d©d7d™d´d¨d≠dÆdØd∞d±d≤d≥d¥dµd∂d≠d∑dád∏dádπd∫dªdºdΩdÀdædÕdødœd¿d€d¡d¬d√dƒd≈dÒd∆d∆d«d»d…d dÀdÔdÃd¬dÕd dŒdœd–d—d—d“d”d‘d’d”d÷d’d◊dÛdÿdÃdŸd⁄d€d‹d›d◊dﬁdﬂdﬂd›d‡d·d·d„du d‚dÒd„d‰d‚dÂd„dÊdÁdËdÈdÍdÎdÏdÌdÓdÔddÒdÛdÚdÛdÚdÙdıdˆd˜d¯d˘d˙d˚d¸d˝d˛dˇd ddddddddıdd	d
dddddddddddddddddddddd≥	dd d!d"d#dd$d%d&d'd(d)d*d+d,dLd-d.d/d0d1d2d3d4d5d6i∑Z i  Z i  Z x4 e j É  D]& \ Z Z e e e <e	 e É e e <qo:W[ [ d7S(8  z!HTML character entity references.⁄html5⁄name2codepoint⁄codepoint2name⁄
entitydefsZAEligÈ∆   ZAacuteÈ¡   ZAcircÈ¬   ZAgraveÈ¿   ZAlphaië  ZAringÈ≈   ZAtildeÈ√   ZAumlÈƒ   ZBetaií  ZCcedilÈ«   ZChiiß  ZDaggeri!   ZDeltaiî  ZETHÈ–   ZEacuteÈ…   ZEcircÈ    ZEgraveÈ»   ZEpsiloniï  ZEtaió  ZEumlÈÀ   ZGammaiì  ZIacuteÈÕ   ZIcircÈŒ   ZIgraveÈÃ   ZIotaiô  ZIumlÈœ   ZKappaiö  ZLambdaiõ  ZMuiú  ZNtildeÈ—   ZNuiù  ZOEligiR  ZOacuteÈ”   ZOcircÈ‘   ZOgraveÈ“   ZOmegai©  ZOmicroniü  ZOslashÈÿ   ZOtildeÈ’   ZOumlÈ÷   ZPhii¶  ZPii†  ZPrimei3   ZPsii®  ZRhoi°  ZScaroni`  ZSigmai£  ZTHORNÈﬁ   ZTaui§  ZThetaiò  ZUacuteÈ⁄   ZUcircÈ€   ZUgraveÈŸ   ZUpsiloni•  ZUumlÈ‹   ZXiiû  ZYacuteÈ›   ZYumlix  ZZetaiñ  ZaacuteÈ·   ZacircÈ‚   ZacuteÈ¥   ZaeligÈÊ   ZagraveÈ‡   Zalefsymi5!  Zalphai±  ZampÈ&   ⁄andi'"  Zangi "  ZaringÈÂ   ZasympiH"  ZatildeÈ„   ZaumlÈ‰   Zbdquoi   Zbetai≤  ZbrvbarÈ¶   Zbulli"   Zcapi)"  ZccedilÈÁ   ZcedilÈ∏   ZcentÈ¢   Zchii«  Zcirci∆  Zclubsic&  ZcongiE"  ⁄copyÈ©   Zcrarriµ!  Zcupi*"  ZcurrenÈ§   ZdArri”!  Zdaggeri    Zdarriì!  ZdegÈ∞   Zdeltai¥  Zdiamsif&  ZdivideÈ˜   ZeacuteÈÈ   ZecircÈÍ   ZegraveÈË   ⁄emptyi"  Zemspi   Zenspi   ⁄epsiloniµ  Zequivia"  Zetai∑  ZethÈ   ZeumlÈÎ   Zeuroi¨   Zexisti"  Zfnofií  Zforalli "  Zfrac12ÈΩ   Zfrac14Èº   Zfrac34Èæ   ZfrasliD   Zgammai≥  ⁄geie"  ⁄gtÈ>   ZhArri‘!  Zharriî!  Zheartsie&  Zhellipi&   ZiacuteÈÌ   ZicircÈÓ   ZiexclÈ°   ZigraveÈÏ   Zimagei!  Zinfini"  ⁄inti+"  Ziotaiπ  ZiquestÈø   Zisini"  ZiumlÈÔ   Zkappai∫  ZlArri–!  ⁄lambdaiª  Zlangi)#  ZlaquoÈ´   Zlarriê!  Zlceili#  Zldquoi   ⁄leid"  Zlfloori
#  Zlowasti"  Zlozi %  Zlrmi   Zlsaquoi9   Zlsquoi   ⁄ltÈ<   ZmacrÈØ   Zmdashi   ⁄microÈµ   ZmiddotÈ∑   Zminusi"  Zmuiº  Znablai"  ZnbspÈ†   Zndashi   ⁄nei`"  Znii"  ⁄notÈ¨   Znotini	"  ZnsubiÑ"  ZntildeÈÒ   ZnuiΩ  ZoacuteÈÛ   ZocircÈÙ   ZoeligiS  ZograveÈÚ   Zolinei>   Zomegai…  Zomicroniø  Zoplusiï"  ⁄ori("  ZordfÈ™   ZordmÈ∫   ZoslashÈ¯   ZotildeÈı   Zotimesió"  ZoumlÈˆ   ZparaÈ∂   ⁄parti"  Zpermili0   Zperpi•"  Zphii∆  Zpii¿  Zpivi÷  ZplusmnÈ±   ZpoundÈ£   Zprimei2   Zprodi"  Zpropi"  Zpsii»  ZquotÈ"   ZrArri“!  Zradici"  Zrangi*#  ZraquoÈª   Zrarrií!  Zrceili	#  Zrdquoi   ⁄reali!  ZregÈÆ   Zrfloori#  Zrhoi¡  Zrlmi   Zrsaquoi:   Zrsquoi   Zsbquoi   Zscaronia  Zsdoti≈"  ZsectÈß   ZshyÈ≠   Zsigmai√  Zsigmafi¬  Zsimi<"  Zspadesi`&  ⁄subiÇ"  ZsubeiÜ"  ⁄sumi"  ZsupiÉ"  Zsup1Èπ   Zsup2È≤   Zsup3È≥   Zsupeiá"  ZszligÈﬂ   Ztauiƒ  Zthere4i4"  Zthetai∏  Zthetasymi—  Zthinspi	   ZthornÈ˛   ⁄tildei‹  ⁄timesÈ◊   Ztradei"!  ZuArri—!  ZuacuteÈ˙   Zuarrië!  ZucircÈ˚   ZugraveÈ˘   ZumlÈ®   Zupsihi“  Zupsiloni≈  ZuumlÈ¸   Zweierpi!  Zxiiæ  ZyacuteÈ˝   ZyenÈ•   ZyumlÈˇ   Zzetai∂  Zzwji   Zzwnji   ı   √Åı   √°zAacute;zaacute;zAbreve;u   ƒÇzabreve;u   ƒÉzac;u   ‚àæzacd;u   ‚àøzacE;u   ‚àæÃ≥ı   √Çı   √¢zAcirc;zacirc;ı   ¬¥zacute;zAcy;u   –êzacy;u   –∞ı   √Üı   √¶zAElig;zaelig;zaf;u   ‚Å°zAfr;u   ùîÑzafr;u   ùîûı   √Äı   √†zAgrave;zagrave;zalefsym;u   ‚Ñµzaleph;zAlpha;u   Œëzalpha;u   Œ±zAmacr;u   ƒÄzamacr;u   ƒÅzamalg;u   ‚®øZAMP˙&zAMP;zamp;zAnd;u   ‚©ìzand;u   ‚àßzandand;u   ‚©ïzandd;u   ‚©úz	andslope;u   ‚©òzandv;u   ‚©özang;u   ‚à†zange;u   ‚¶§zangle;zangmsd;u   ‚à°z	angmsdaa;u   ‚¶®z	angmsdab;u   ‚¶©z	angmsdac;u   ‚¶™z	angmsdad;u   ‚¶´z	angmsdae;u   ‚¶¨z	angmsdaf;u   ‚¶≠z	angmsdag;u   ‚¶Æz	angmsdah;u   ‚¶Øzangrt;u   ‚àüzangrtvb;u   ‚äæz	angrtvbd;u   ‚¶ùzangsph;u   ‚à¢zangst;ı   √Özangzarr;u   ‚çºzAogon;u   ƒÑzaogon;u   ƒÖzAopf;u   ùî∏zaopf;u   ùïízap;u   ‚âàzapacir;u   ‚©ØzapE;u   ‚©∞zape;u   ‚âäzapid;u   ‚âãzapos;˙'zApplyFunction;zapprox;z	approxeq;ı   √•zAring;zaring;zAscr;u   ùíúzascr;u   ùí∂zAssign;u   ‚âîzast;⁄*zasymp;zasympeq;u   ‚âçı   √Éı   √£zAtilde;zatilde;ı   √Ñı   √§zAuml;zauml;z	awconint;u   ‚à≥zawint;u   ‚®ëz	backcong;u   ‚âåzbackepsilon;u   œ∂z
backprime;u   ‚Äµzbacksim;u   ‚àΩz
backsimeq;u   ‚ãçz
Backslash;u   ‚àñzBarv;u   ‚´ßzbarvee;u   ‚äΩzBarwed;u   ‚åÜzbarwed;u   ‚åÖz	barwedge;zbbrk;u   ‚éµz	bbrktbrk;u   ‚é∂zbcong;zBcy;u   –ëzbcy;u   –±zbdquo;u   ‚Äûzbecaus;u   ‚àµzBecause;zbecause;zbemptyv;u   ‚¶∞zbepsi;zbernou;u   ‚Ñ¨zBernoullis;zBeta;u   Œízbeta;u   Œ≤zbeth;u   ‚Ñ∂zbetween;u   ‚â¨zBfr;u   ùîÖzbfr;u   ùîüzbigcap;u   ‚ãÇzbigcirc;u   ‚óØzbigcup;u   ‚ãÉzbigodot;u   ‚®Äz	bigoplus;u   ‚®Åz
bigotimes;u   ‚®Çz	bigsqcup;u   ‚®Üzbigstar;u   ‚òÖzbigtriangledown;u   ‚ñΩzbigtriangleup;u   ‚ñ≥z	biguplus;u   ‚®Ñzbigvee;u   ‚ãÅz	bigwedge;u   ‚ãÄzbkarow;u   ‚§çzblacklozenge;u   ‚ß´zblacksquare;u   ‚ñ™zblacktriangle;u   ‚ñ¥zblacktriangledown;u   ‚ñæzblacktriangleleft;u   ‚óÇzblacktriangleright;u   ‚ñ∏zblank;u   ‚ê£zblk12;u   ‚ñízblk14;u   ‚ñëzblk34;u   ‚ñìzblock;u   ‚ñàzbne;u   =‚É•zbnequiv;u   ‚â°‚É•zbNot;u   ‚´≠zbnot;u   ‚åêzBopf;u   ùîπzbopf;u   ùïìzbot;u   ‚ä•zbottom;zbowtie;u   ‚ãàzboxbox;u   ‚ßâzboxDL;u   ‚ïózboxDl;u   ‚ïñzboxdL;u   ‚ïïzboxdl;u   ‚îêzboxDR;u   ‚ïîzboxDr;u   ‚ïìzboxdR;u   ‚ïízboxdr;u   ‚îåzboxH;u   ‚ïêzboxh;u   ‚îÄzboxHD;u   ‚ï¶zboxHd;u   ‚ï§zboxhD;u   ‚ï•zboxhd;u   ‚î¨zboxHU;u   ‚ï©zboxHu;u   ‚ïßzboxhU;u   ‚ï®zboxhu;u   ‚î¥z	boxminus;u   ‚äüzboxplus;u   ‚äûz	boxtimes;u   ‚ä†zboxUL;u   ‚ïùzboxUl;u   ‚ïúzboxuL;u   ‚ïõzboxul;u   ‚îòzboxUR;u   ‚ïözboxUr;u   ‚ïôzboxuR;u   ‚ïòzboxur;u   ‚îîzboxV;u   ‚ïëzboxv;u   ‚îÇzboxVH;u   ‚ï¨zboxVh;u   ‚ï´zboxvH;u   ‚ï™zboxvh;u   ‚îºzboxVL;u   ‚ï£zboxVl;u   ‚ï¢zboxvL;u   ‚ï°zboxvl;u   ‚î§zboxVR;u   ‚ï†zboxVr;u   ‚ïüzboxvR;u   ‚ïûzboxvr;u   ‚îúzbprime;zBreve;u   Àòzbreve;ı   ¬¶zbrvbar;zBscr;zbscr;u   ùí∑zbsemi;u   ‚Åèzbsim;zbsime;zbsol;˙\zbsolb;u   ‚ßÖz	bsolhsub;u   ‚üàzbull;u   ‚Ä¢zbullet;zbump;u   ‚âézbumpE;u   ‚™Æzbumpe;u   ‚âèzBumpeq;zbumpeq;zCacute;u   ƒÜzcacute;u   ƒázCap;u   ‚ãízcap;u   ‚à©zcapand;u   ‚©Ñz	capbrcup;u   ‚©âzcapcap;u   ‚©ãzcapcup;u   ‚©ázcapdot;u   ‚©ÄzCapitalDifferentialD;u   ‚ÖÖzcaps;u   ‚à©Ô∏Äzcaret;u   ‚ÅÅzcaron;u   ÀázCayleys;u   ‚Ñ≠zccaps;u   ‚©çzCcaron;u   ƒåzccaron;u   ƒçı   √áı   √ßzCcedil;zccedil;zCcirc;u   ƒàzccirc;u   ƒâzCconint;u   ‚à∞zccups;u   ‚©åzccupssm;u   ‚©êzCdot;u   ƒäzcdot;u   ƒãı   ¬∏zcedil;zCedilla;zcemptyv;u   ‚¶≤ı   ¬¢zcent;z
CenterDot;ı   ¬∑z
centerdot;zCfr;zcfr;u   ùî†zCHcy;u   –ßzchcy;u   —ázcheck;u   ‚úìz
checkmark;zChi;u   Œßzchi;u   œázcir;u   ‚óãzcirc;u   ÀÜzcirceq;u   ‚âózcirclearrowleft;u   ‚Ü∫zcirclearrowright;u   ‚Üªzcircledast;u   ‚äõzcircledcirc;u   ‚äözcircleddash;u   ‚äùz
CircleDot;u   ‚äôz	circledR;ı   ¬Æz	circledS;u   ‚ìàzCircleMinus;u   ‚äñzCirclePlus;u   ‚äïzCircleTimes;u   ‚äózcirE;u   ‚ßÉzcire;z	cirfnint;u   ‚®êzcirmid;u   ‚´Øzcirscir;u   ‚ßÇzClockwiseContourIntegral;u   ‚à≤zCloseCurlyDoubleQuote;u   ‚ÄùzCloseCurlyQuote;u   ‚Äôzclubs;u   ‚ô£z	clubsuit;zColon;u   ‚à∑zcolon;˙:zColone;u   ‚©¥zcolone;zcoloneq;zcomma;˙,zcommat;˙@zcomp;u   ‚àÅzcompfn;u   ‚àòzcomplement;z
complexes;u   ‚ÑÇzcong;u   ‚âÖzcongdot;u   ‚©≠z
Congruent;u   ‚â°zConint;u   ‚àØzconint;u   ‚àÆzContourIntegral;zCopf;zcopf;u   ùïîzcoprod;u   ‚àêz
Coproduct;ZCOPYı   ¬©zCOPY;zcopy;zcopysr;u   ‚Ñóz CounterClockwiseContourIntegral;zcrarr;u   ‚ÜµzCross;u   ‚®Øzcross;u   ‚úózCscr;u   ùíûzcscr;u   ùí∏zcsub;u   ‚´èzcsube;u   ‚´ëzcsup;u   ‚´êzcsupe;u   ‚´ízctdot;u   ‚ãØzcudarrl;u   ‚§∏zcudarrr;u   ‚§µzcuepr;u   ‚ãûzcuesc;u   ‚ãüzcularr;u   ‚Ü∂zcularrp;u   ‚§ΩzCup;u   ‚ãìzcup;u   ‚à™z	cupbrcap;u   ‚©àzCupCap;zcupcap;u   ‚©Üzcupcup;u   ‚©äzcupdot;u   ‚äçzcupor;u   ‚©Özcups;u   ‚à™Ô∏Äzcurarr;u   ‚Ü∑zcurarrm;u   ‚§ºzcurlyeqprec;zcurlyeqsucc;z	curlyvee;u   ‚ãézcurlywedge;u   ‚ãèı   ¬§zcurren;zcurvearrowleft;zcurvearrowright;zcuvee;zcuwed;z	cwconint;zcwint;u   ‚à±zcylcty;u   ‚å≠zDagger;u   ‚Ä°zdagger;u   ‚Ä†zdaleth;u   ‚Ñ∏zDarr;u   ‚Ü°zdArr;u   ‚áìzdarr;u   ‚Üìzdash;u   ‚ÄêzDashv;u   ‚´§zdashv;u   ‚ä£zdbkarow;u   ‚§èzdblac;u   ÀùzDcaron;u   ƒézdcaron;u   ƒèzDcy;u   –îzdcy;u   –¥zDD;zdd;u   ‚ÖÜzddagger;zddarr;u   ‚áäz	DDotrahd;u   ‚§ëzddotseq;u   ‚©∑ı   ¬∞zdeg;zDel;u   ‚àázDelta;u   Œîzdelta;u   Œ¥zdemptyv;u   ‚¶±zdfisht;u   ‚•øzDfr;u   ùîázdfr;u   ùî°zdHar;u   ‚••zdharl;u   ‚áÉzdharr;u   ‚áÇzDiacriticalAcute;zDiacriticalDot;u   ÀôzDiacriticalDoubleAcute;zDiacriticalGrave;˙`zDiacriticalTilde;u   Àúzdiam;u   ‚ãÑzDiamond;zdiamond;zdiamondsuit;u   ‚ô¶zdiams;zdie;ı   ¬®zDifferentialD;zdigamma;u   œùzdisin;u   ‚ã≤zdiv;ı   √∑zdivide;zdivideontimes;u   ‚ãázdivonx;zDJcy;u   –Çzdjcy;u   —ízdlcorn;u   ‚åûzdlcrop;u   ‚åçzdollar;˙$zDopf;u   ùîªzdopf;u   ùïïzDot;zdot;zDotDot;u   ‚Éúzdoteq;u   ‚âêz	doteqdot;u   ‚âëz	DotEqual;z	dotminus;u   ‚à∏zdotplus;u   ‚àîz
dotsquare;u   ‚ä°zdoublebarwedge;zDoubleContourIntegral;z
DoubleDot;zDoubleDownArrow;zDoubleLeftArrow;u   ‚áêzDoubleLeftRightArrow;u   ‚áîzDoubleLeftTee;zDoubleLongLeftArrow;u   ‚ü∏zDoubleLongLeftRightArrow;u   ‚ü∫zDoubleLongRightArrow;u   ‚üπzDoubleRightArrow;u   ‚áízDoubleRightTee;u   ‚ä®zDoubleUpArrow;u   ‚áëzDoubleUpDownArrow;u   ‚áïzDoubleVerticalBar;u   ‚à•z
DownArrow;z
Downarrow;z
downarrow;zDownArrowBar;u   ‚§ìzDownArrowUpArrow;u   ‚áµz
DownBreve;u   Ãëzdowndownarrows;zdownharpoonleft;zdownharpoonright;zDownLeftRightVector;u   ‚•êzDownLeftTeeVector;u   ‚•ûzDownLeftVector;u   ‚ÜΩzDownLeftVectorBar;u   ‚•ñzDownRightTeeVector;u   ‚•üzDownRightVector;u   ‚áÅzDownRightVectorBar;u   ‚•ózDownTee;u   ‚ä§zDownTeeArrow;u   ‚Üßz	drbkarow;u   ‚§êzdrcorn;u   ‚åüzdrcrop;u   ‚ååzDscr;u   ùíüzdscr;u   ùíπzDScy;u   –Özdscy;u   —ïzdsol;u   ‚ß∂zDstrok;u   ƒêzdstrok;u   ƒëzdtdot;u   ‚ã±zdtri;u   ‚ñøzdtrif;zduarr;zduhar;u   ‚•Øzdwangle;u   ‚¶¶zDZcy;u   –èzdzcy;u   —üz	dzigrarr;u   ‚üøı   √âı   √©zEacute;zeacute;zeaster;u   ‚©ÆzEcaron;u   ƒözecaron;u   ƒõzecir;u   ‚âñı   √äı   √™zEcirc;zecirc;zecolon;u   ‚âïzEcy;u   –≠zecy;u   —çzeDDot;zEdot;u   ƒñzeDot;zedot;u   ƒózee;u   ‚ÖázefDot;u   ‚âízEfr;u   ùîàzefr;u   ùî¢zeg;u   ‚™öı   √àı   √®zEgrave;zegrave;zegs;u   ‚™ñzegsdot;u   ‚™òzel;u   ‚™ôzElement;u   ‚ààz	elinters;u   ‚èßzell;u   ‚Ñìzels;u   ‚™ïzelsdot;u   ‚™ózEmacr;u   ƒízemacr;u   ƒìzempty;u   ‚àÖz	emptyset;zEmptySmallSquare;u   ‚óªzemptyv;zEmptyVerySmallSquare;u   ‚ñ´zemsp13;u   ‚ÄÑzemsp14;u   ‚ÄÖzemsp;u   ‚ÄÉzENG;u   ≈äzeng;u   ≈ãzensp;u   ‚ÄÇzEogon;u   ƒòzeogon;u   ƒôzEopf;u   ùîºzeopf;u   ùïñzepar;u   ‚ãïzeparsl;u   ‚ß£zeplus;u   ‚©±zepsi;u   ŒµzEpsilon;u   Œïzepsilon;zepsiv;u   œµzeqcirc;zeqcolon;zeqsim;u   ‚âÇzeqslantgtr;zeqslantless;zEqual;u   ‚©µzequals;˙=zEqualTilde;zequest;u   ‚âüzEquilibrium;u   ‚áåzequiv;zequivDD;u   ‚©∏z	eqvparsl;u   ‚ß•zerarr;u   ‚•±zerDot;u   ‚âìzEscr;u   ‚Ñ∞zescr;u   ‚ÑØzesdot;zEsim;u   ‚©≥zesim;zEta;u   Œózeta;u   Œ∑ı   √êı   √∞zETH;zeth;ı   √ãı   √´zEuml;zeuml;zeuro;u   ‚Ç¨zexcl;˙!zexist;u   ‚àÉzExists;zexpectation;zExponentialE;zexponentiale;zfallingdotseq;zFcy;u   –§zfcy;u   —Ñzfemale;u   ‚ôÄzffilig;u   Ô¨Ézfflig;u   Ô¨Äzffllig;u   Ô¨ÑzFfr;u   ùîâzffr;u   ùî£zfilig;u   Ô¨ÅzFilledSmallSquare;u   ‚óºzFilledVerySmallSquare;zfjlig;Zfjzflat;u   ‚ô≠zfllig;u   Ô¨Çzfltns;u   ‚ñ±zfnof;u   ∆ízFopf;u   ùîΩzfopf;u   ùïózForAll;u   ‚àÄzforall;zfork;u   ‚ãîzforkv;u   ‚´ôzFouriertrf;u   ‚Ñ±z	fpartint;u   ‚®çı   ¬Ωzfrac12;zfrac13;u   ‚Öìı   ¬ºzfrac14;zfrac15;u   ‚Öïzfrac16;u   ‚Öôzfrac18;u   ‚Öõzfrac23;u   ‚Öîzfrac25;u   ‚Öñı   ¬æzfrac34;zfrac35;u   ‚Öózfrac38;u   ‚Öúzfrac45;u   ‚Öòzfrac56;u   ‚Öözfrac58;u   ‚Öùzfrac78;u   ‚Öûzfrasl;u   ‚ÅÑzfrown;u   ‚å¢zFscr;zfscr;u   ùíªzgacute;u   «µzGamma;u   Œìzgamma;u   Œ≥zGammad;u   œúzgammad;zgap;u   ‚™ÜzGbreve;u   ƒûzgbreve;u   ƒüzGcedil;u   ƒ¢zGcirc;u   ƒúzgcirc;u   ƒùzGcy;u   –ìzgcy;u   –≥zGdot;u   ƒ†zgdot;u   ƒ°zgE;u   ‚âßzge;u   ‚â•zgEl;u   ‚™åzgel;u   ‚ãõzgeq;zgeqq;z	geqslant;u   ‚©æzges;zgescc;u   ‚™©zgesdot;u   ‚™Äzgesdoto;u   ‚™Çz	gesdotol;u   ‚™Ñzgesl;u   ‚ãõÔ∏Äzgesles;u   ‚™îzGfr;u   ùîäzgfr;u   ùî§zGg;u   ‚ãôzgg;u   ‚â´zggg;zgimel;u   ‚Ñ∑zGJcy;u   –Ézgjcy;u   —ìzgl;u   ‚â∑zgla;u   ‚™•zglE;u   ‚™ízglj;u   ‚™§zgnap;u   ‚™äz	gnapprox;zgnE;u   ‚â©zgne;u   ‚™àzgneq;zgneqq;zgnsim;u   ‚ãßzGopf;u   ùîæzgopf;u   ùïòzgrave;zGreaterEqual;zGreaterEqualLess;zGreaterFullEqual;zGreaterGreater;u   ‚™¢zGreaterLess;zGreaterSlantEqual;zGreaterTilde;u   ‚â≥zGscr;u   ùí¢zgscr;u   ‚Ñäzgsim;zgsime;u   ‚™ézgsiml;u   ‚™êZGT˙>zGT;zGt;zgt;zgtcc;u   ‚™ßzgtcir;u   ‚©∫zgtdot;u   ‚ãózgtlPar;u   ‚¶ïzgtquest;u   ‚©ºz
gtrapprox;zgtrarr;u   ‚•∏zgtrdot;z
gtreqless;zgtreqqless;zgtrless;zgtrsim;z
gvertneqq;u   ‚â©Ô∏ÄzgvnE;zHacek;zhairsp;u   ‚Ääzhalf;zhamilt;u   ‚ÑãzHARDcy;u   –™zhardcy;u   —äzhArr;zharr;u   ‚Üîzharrcir;u   ‚•àzharrw;u   ‚Ü≠zHat;˙^zhbar;u   ‚ÑèzHcirc;u   ƒ§zhcirc;u   ƒ•zhearts;u   ‚ô•z
heartsuit;zhellip;u   ‚Ä¶zhercon;u   ‚äπzHfr;u   ‚Ñåzhfr;u   ùî•zHilbertSpace;z	hksearow;u   ‚§•z	hkswarow;u   ‚§¶zhoarr;u   ‚áøzhomtht;u   ‚àªzhookleftarrow;u   ‚Ü©zhookrightarrow;u   ‚Ü™zHopf;u   ‚Ñçzhopf;u   ùïôzhorbar;u   ‚ÄïzHorizontalLine;zHscr;zhscr;u   ùíΩzhslash;zHstrok;u   ƒ¶zhstrok;u   ƒßzHumpDownHump;z
HumpEqual;zhybull;u   ‚ÅÉzhyphen;ı   √çı   √≠zIacute;ziacute;zic;u   ‚Å£ı   √éı   √ÆzIcirc;zicirc;zIcy;u   –òzicy;u   –∏zIdot;u   ƒ∞zIEcy;u   –ïziecy;u   –µı   ¬°ziexcl;ziff;zIfr;u   ‚Ñëzifr;u   ùî¶ı   √åı   √¨zIgrave;zigrave;zii;u   ‚Öàziiiint;u   ‚®åziiint;u   ‚à≠ziinfin;u   ‚ßúziiota;u   ‚Ñ©zIJlig;u   ƒ≤zijlig;u   ƒ≥zIm;zImacr;u   ƒ™zimacr;u   ƒ´zimage;zImaginaryI;z	imagline;u   ‚Ñêz	imagpart;zimath;u   ƒ±zimof;u   ‚ä∑zimped;u   ∆µzImplies;zin;zincare;u   ‚ÑÖzinfin;u   ‚àûz	infintie;u   ‚ßùzinodot;zInt;u   ‚à¨zint;u   ‚à´zintcal;u   ‚ä∫z	integers;u   ‚Ñ§z	Integral;z	intercal;zIntersection;z	intlarhk;u   ‚®ózintprod;u   ‚®ºzInvisibleComma;zInvisibleTimes;u   ‚Å¢zIOcy;u   –Åziocy;u   —ëzIogon;u   ƒÆziogon;u   ƒØzIopf;u   ùïÄziopf;u   ùïözIota;u   Œôziota;u   Œπziprod;ı   ¬øziquest;zIscr;ziscr;u   ùíæzisin;zisindot;u   ‚ãµzisinE;u   ‚ãπzisins;u   ‚ã¥zisinsv;u   ‚ã≥zisinv;zit;zItilde;u   ƒ®zitilde;u   ƒ©zIukcy;u   –Üziukcy;u   —ñı   √èı   √ØzIuml;ziuml;zJcirc;u   ƒ¥zjcirc;u   ƒµzJcy;u   –ôzjcy;u   –πzJfr;u   ùîçzjfr;u   ùîßzjmath;u   »∑zJopf;u   ùïÅzjopf;u   ùïõzJscr;u   ùí•zjscr;u   ùíøzJsercy;u   –àzjsercy;u   —òzJukcy;u   –Ñzjukcy;u   —îzKappa;u   Œözkappa;u   Œ∫zkappav;u   œ∞zKcedil;u   ƒ∂zkcedil;u   ƒ∑zKcy;u   –özkcy;u   –∫zKfr;u   ùîézkfr;u   ùî®zkgreen;u   ƒ∏zKHcy;u   –•zkhcy;u   —ÖzKJcy;u   –åzkjcy;u   —úzKopf;u   ùïÇzkopf;u   ùïúzKscr;u   ùí¶zkscr;u   ùìÄzlAarr;u   ‚áözLacute;u   ƒπzlacute;u   ƒ∫z	laemptyv;u   ‚¶¥zlagran;u   ‚ÑízLambda;u   Œõzlambda;u   ŒªzLang;u   ‚ü™zlang;u   ‚ü®zlangd;u   ‚¶ëzlangle;zlap;u   ‚™ÖzLaplacetrf;ı   ¬´zlaquo;zLarr;u   ‚ÜûzlArr;zlarr;u   ‚Üêzlarrb;u   ‚á§zlarrbfs;u   ‚§üzlarrfs;u   ‚§ùzlarrhk;zlarrlp;u   ‚Ü´zlarrpl;u   ‚§πzlarrsim;u   ‚•≥zlarrtl;u   ‚Ü¢zlat;u   ‚™´zlAtail;u   ‚§õzlatail;u   ‚§ôzlate;u   ‚™≠zlates;u   ‚™≠Ô∏ÄzlBarr;u   ‚§ézlbarr;u   ‚§åzlbbrk;u   ‚ù≤zlbrace;˙{zlbrack;˙[zlbrke;u   ‚¶ãzlbrksld;u   ‚¶èzlbrkslu;u   ‚¶çzLcaron;u   ƒΩzlcaron;u   ƒæzLcedil;u   ƒªzlcedil;u   ƒºzlceil;u   ‚åàzlcub;zLcy;u   –õzlcy;u   –ªzldca;u   ‚§∂zldquo;u   ‚Äúzldquor;zldrdhar;u   ‚•ßz	ldrushar;u   ‚•ãzldsh;u   ‚Ü≤zlE;u   ‚â¶zle;u   ‚â§zLeftAngleBracket;z
LeftArrow;z
Leftarrow;z
leftarrow;zLeftArrowBar;zLeftArrowRightArrow;u   ‚áÜzleftarrowtail;zLeftCeiling;zLeftDoubleBracket;u   ‚ü¶zLeftDownTeeVector;u   ‚•°zLeftDownVector;zLeftDownVectorBar;u   ‚•ôz
LeftFloor;u   ‚åäzleftharpoondown;zleftharpoonup;u   ‚Üºzleftleftarrows;u   ‚áázLeftRightArrow;zLeftrightarrow;zleftrightarrow;zleftrightarrows;zleftrightharpoons;u   ‚áãzleftrightsquigarrow;zLeftRightVector;u   ‚•ézLeftTee;zLeftTeeArrow;u   ‚Ü§zLeftTeeVector;u   ‚•özleftthreetimes;u   ‚ããzLeftTriangle;u   ‚ä≤zLeftTriangleBar;u   ‚ßèzLeftTriangleEqual;u   ‚ä¥zLeftUpDownVector;u   ‚•ëzLeftUpTeeVector;u   ‚•†zLeftUpVector;u   ‚ÜøzLeftUpVectorBar;u   ‚•òzLeftVector;zLeftVectorBar;u   ‚•ízlEg;u   ‚™ãzleg;u   ‚ãözleq;zleqq;z	leqslant;u   ‚©Ωzles;zlescc;u   ‚™®zlesdot;u   ‚©øzlesdoto;u   ‚™Åz	lesdotor;u   ‚™Ézlesg;u   ‚ãöÔ∏Äzlesges;u   ‚™ìzlessapprox;zlessdot;u   ‚ãñz
lesseqgtr;zlesseqqgtr;zLessEqualGreater;zLessFullEqual;zLessGreater;u   ‚â∂zlessgtr;z	LessLess;u   ‚™°zlesssim;u   ‚â≤zLessSlantEqual;z
LessTilde;zlfisht;u   ‚•ºzlfloor;zLfr;u   ùîèzlfr;u   ùî©zlg;zlgE;u   ‚™ëzlHar;u   ‚•¢zlhard;zlharu;zlharul;u   ‚•™zlhblk;u   ‚ñÑzLJcy;u   –âzljcy;u   —ôzLl;u   ‚ãòzll;u   ‚â™zllarr;z	llcorner;zLleftarrow;zllhard;u   ‚•´zlltri;u   ‚ó∫zLmidot;u   ƒøzlmidot;u   ≈Äzlmoust;u   ‚é∞zlmoustache;zlnap;u   ‚™âz	lnapprox;zlnE;u   ‚â®zlne;u   ‚™ázlneq;zlneqq;zlnsim;u   ‚ã¶zloang;u   ‚ü¨zloarr;u   ‚áΩzlobrk;zLongLeftArrow;u   ‚üµzLongleftarrow;zlongleftarrow;zLongLeftRightArrow;u   ‚ü∑zLongleftrightarrow;zlongleftrightarrow;zlongmapsto;u   ‚üºzLongRightArrow;u   ‚ü∂zLongrightarrow;zlongrightarrow;zlooparrowleft;zlooparrowright;u   ‚Ü¨zlopar;u   ‚¶ÖzLopf;u   ùïÉzlopf;u   ùïùzloplus;u   ‚®≠zlotimes;u   ‚®¥zlowast;u   ‚àózlowbar;⁄_zLowerLeftArrow;u   ‚ÜôzLowerRightArrow;u   ‚Üòzloz;u   ‚óäzlozenge;zlozf;zlpar;˙(zlparlt;u   ‚¶ìzlrarr;z	lrcorner;zlrhar;zlrhard;u   ‚•≠zlrm;u   ‚Äézlrtri;u   ‚äøzlsaquo;u   ‚ÄπzLscr;zlscr;u   ùìÅzLsh;u   ‚Ü∞zlsh;zlsim;zlsime;u   ‚™çzlsimg;u   ‚™èzlsqb;zlsquo;u   ‚Äòzlsquor;u   ‚ÄözLstrok;u   ≈Åzlstrok;u   ≈ÇZLT˙<zLT;zLt;zlt;zltcc;u   ‚™¶zltcir;u   ‚©πzltdot;zlthree;zltimes;u   ‚ãâzltlarr;u   ‚•∂zltquest;u   ‚©ªzltri;u   ‚óÉzltrie;zltrif;zltrPar;u   ‚¶ñz	lurdshar;u   ‚•äzluruhar;u   ‚•¶z
lvertneqq;u   ‚â®Ô∏ÄzlvnE;ı   ¬Øzmacr;zmale;u   ‚ôÇzmalt;u   ‚ú†zmaltese;zMap;u   ‚§Özmap;u   ‚Ü¶zmapsto;zmapstodown;zmapstoleft;z	mapstoup;u   ‚Ü•zmarker;u   ‚ñÆzmcomma;u   ‚®©zMcy;u   –úzmcy;u   –ºzmdash;u   ‚ÄîzmDDot;u   ‚à∫zmeasuredangle;zMediumSpace;u   ‚Åüz
Mellintrf;u   ‚Ñ≥zMfr;u   ùîêzmfr;u   ùî™zmho;u   ‚Ñßı   ¬µzmicro;zmid;u   ‚à£zmidast;zmidcir;u   ‚´∞zmiddot;zminus;u   ‚àízminusb;zminusd;zminusdu;u   ‚®™z
MinusPlus;u   ‚àìzmlcp;u   ‚´õzmldr;zmnplus;zmodels;u   ‚äßzMopf;u   ùïÑzmopf;u   ùïûzmp;zMscr;zmscr;u   ùìÇzmstpos;zMu;u   Œúzmu;u   Œºz	multimap;u   ‚ä∏zmumap;znabla;zNacute;u   ≈Éznacute;u   ≈Ñznang;u   ‚à†‚Éíznap;u   ‚ââznapE;u   ‚©∞Ã∏znapid;u   ‚âãÃ∏znapos;u   ≈âznapprox;znatur;u   ‚ôÆznatural;z	naturals;u   ‚Ñïı   ¬†znbsp;znbump;u   ‚âéÃ∏znbumpe;u   ‚âèÃ∏zncap;u   ‚©ÉzNcaron;u   ≈ázncaron;u   ≈àzNcedil;u   ≈Özncedil;u   ≈Üzncong;u   ‚âáz	ncongdot;u   ‚©≠Ã∏zncup;u   ‚©ÇzNcy;u   –ùzncy;u   –Ωzndash;u   ‚Äìzne;u   ‚â†znearhk;u   ‚§§zneArr;u   ‚áóznearr;u   ‚Üóznearrow;znedot;u   ‚âêÃ∏zNegativeMediumSpace;u   ‚ÄãzNegativeThickSpace;zNegativeThinSpace;zNegativeVeryThinSpace;znequiv;u   ‚â¢znesear;u   ‚§®znesim;u   ‚âÇÃ∏zNestedGreaterGreater;zNestedLessLess;zNewLine;⁄
znexist;u   ‚àÑznexists;zNfr;u   ùîëznfr;u   ùî´zngE;u   ‚âßÃ∏znge;u   ‚â±zngeq;zngeqq;z
ngeqslant;u   ‚©æÃ∏znges;znGg;u   ‚ãôÃ∏zngsim;u   ‚âµznGt;u   ‚â´‚Éízngt;u   ‚âØzngtr;znGtv;u   ‚â´Ã∏znhArr;u   ‚áéznharr;u   ‚ÜÆznhpar;u   ‚´≤zni;u   ‚àãznis;u   ‚ãºznisd;u   ‚ã∫zniv;zNJcy;u   –äznjcy;u   —öznlArr;u   ‚áçznlarr;u   ‚Üöznldr;u   ‚Ä•znlE;u   ‚â¶Ã∏znle;u   ‚â∞znLeftarrow;znleftarrow;znLeftrightarrow;znleftrightarrow;znleq;znleqq;z
nleqslant;u   ‚©ΩÃ∏znles;znless;u   ‚âÆznLl;u   ‚ãòÃ∏znlsim;u   ‚â¥znLt;u   ‚â™‚Éíznlt;znltri;u   ‚ã™znltrie;u   ‚ã¨znLtv;u   ‚â™Ã∏znmid;u   ‚à§zNoBreak;u   ‚Å†zNonBreakingSpace;zNopf;znopf;u   ùïüı   ¬¨zNot;u   ‚´¨znot;zNotCongruent;z
NotCupCap;u   ‚â≠zNotDoubleVerticalBar;u   ‚à¶zNotElement;u   ‚àâz	NotEqual;zNotEqualTilde;z
NotExists;zNotGreater;zNotGreaterEqual;zNotGreaterFullEqual;zNotGreaterGreater;zNotGreaterLess;u   ‚âπzNotGreaterSlantEqual;zNotGreaterTilde;zNotHumpDownHump;zNotHumpEqual;znotin;z	notindot;u   ‚ãµÃ∏znotinE;u   ‚ãπÃ∏znotinva;znotinvb;u   ‚ã∑znotinvc;u   ‚ã∂zNotLeftTriangle;zNotLeftTriangleBar;u   ‚ßèÃ∏zNotLeftTriangleEqual;zNotLess;zNotLessEqual;zNotLessGreater;u   ‚â∏zNotLessLess;zNotLessSlantEqual;zNotLessTilde;zNotNestedGreaterGreater;u   ‚™¢Ã∏zNotNestedLessLess;u   ‚™°Ã∏znotni;u   ‚àåznotniva;znotnivb;u   ‚ãæznotnivc;u   ‚ãΩzNotPrecedes;u   ‚äÄzNotPrecedesEqual;u   ‚™ØÃ∏zNotPrecedesSlantEqual;u   ‚ã†zNotReverseElement;zNotRightTriangle;u   ‚ã´zNotRightTriangleBar;u   ‚ßêÃ∏zNotRightTriangleEqual;u   ‚ã≠zNotSquareSubset;u   ‚äèÃ∏zNotSquareSubsetEqual;u   ‚ã¢zNotSquareSuperset;u   ‚äêÃ∏zNotSquareSupersetEqual;u   ‚ã£z
NotSubset;u   ‚äÇ‚ÉízNotSubsetEqual;u   ‚äàzNotSucceeds;u   ‚äÅzNotSucceedsEqual;u   ‚™∞Ã∏zNotSucceedsSlantEqual;u   ‚ã°zNotSucceedsTilde;u   ‚âøÃ∏zNotSuperset;u   ‚äÉ‚ÉízNotSupersetEqual;u   ‚äâz	NotTilde;u   ‚âÅzNotTildeEqual;u   ‚âÑzNotTildeFullEqual;zNotTildeTilde;zNotVerticalBar;znpar;z
nparallel;znparsl;u   ‚´Ω‚É•znpart;u   ‚àÇÃ∏znpolint;u   ‚®îznpr;znprcue;znpre;znprec;znpreceq;znrArr;u   ‚áèznrarr;u   ‚Üõznrarrc;u   ‚§≥Ã∏znrarrw;u   ‚ÜùÃ∏znRightarrow;znrightarrow;znrtri;znrtrie;znsc;znsccue;znsce;zNscr;u   ùí©znscr;u   ùìÉz
nshortmid;znshortparallel;znsim;znsime;znsimeq;znsmid;znspar;znsqsube;znsqsupe;znsub;u   ‚äÑznsubE;u   ‚´ÖÃ∏znsube;znsubset;z
nsubseteq;znsubseteqq;znsucc;znsucceq;znsup;u   ‚äÖznsupE;u   ‚´ÜÃ∏znsupe;znsupset;z
nsupseteq;znsupseteqq;zntgl;ı   √ëı   √±zNtilde;zntilde;zntlg;zntriangleleft;zntrianglelefteq;zntriangleright;zntrianglerighteq;zNu;u   Œùznu;u   ŒΩznum;˙#znumero;u   ‚Ññznumsp;u   ‚Äáznvap;u   ‚âç‚ÉíznVDash;u   ‚äØznVdash;u   ‚äÆznvDash;u   ‚ä≠znvdash;u   ‚ä¨znvge;u   ‚â•‚Éíznvgt;u   >‚ÉíznvHarr;u   ‚§Ñznvinfin;u   ‚ßûznvlArr;u   ‚§Çznvle;u   ‚â§‚Éíznvlt;u   <‚Éíznvltrie;u   ‚ä¥‚ÉíznvrArr;u   ‚§Éznvrtrie;u   ‚äµ‚Éíznvsim;u   ‚àº‚Éíznwarhk;u   ‚§£znwArr;u   ‚áñznwarr;u   ‚Üñznwarrow;znwnear;u   ‚§ßı   √ìı   √≥zOacute;zoacute;zoast;zocir;ı   √îı   √¥zOcirc;zocirc;zOcy;u   –ûzocy;u   –æzodash;zOdblac;u   ≈êzodblac;u   ≈ëzodiv;u   ‚®∏zodot;zodsold;u   ‚¶ºzOElig;u   ≈ízoelig;u   ≈ìzofcir;u   ‚¶øzOfr;u   ùîízofr;u   ùî¨zogon;u   Àõı   √íı   √≤zOgrave;zograve;zogt;u   ‚ßÅzohbar;u   ‚¶µzohm;u   Œ©zoint;zolarr;zolcir;u   ‚¶æzolcross;u   ‚¶ªzoline;u   ‚Äæzolt;u   ‚ßÄzOmacr;u   ≈åzomacr;u   ≈çzOmega;zomega;u   œâzOmicron;u   Œüzomicron;u   Œøzomid;u   ‚¶∂zominus;zOopf;u   ùïÜzoopf;u   ùï†zopar;u   ‚¶∑zOpenCurlyDoubleQuote;zOpenCurlyQuote;zoperp;u   ‚¶πzoplus;zOr;u   ‚©îzor;u   ‚à®zorarr;zord;u   ‚©ùzorder;u   ‚Ñ¥zorderof;ı   ¬™zordf;ı   ¬∫zordm;zorigof;u   ‚ä∂zoror;u   ‚©ñzorslope;u   ‚©ózorv;u   ‚©õzoS;zOscr;u   ùí™zoscr;ı   √òı   √∏zOslash;zoslash;zosol;u   ‚äòı   √ïı   √µzOtilde;zotilde;zOtimes;u   ‚®∑zotimes;z	otimesas;u   ‚®∂ı   √ñı   √∂zOuml;zouml;zovbar;u   ‚åΩzOverBar;z
OverBrace;u   ‚èûzOverBracket;u   ‚é¥zOverParenthesis;u   ‚èúzpar;ı   ¬∂zpara;z	parallel;zparsim;u   ‚´≥zparsl;u   ‚´Ωzpart;u   ‚àÇz	PartialD;zPcy;u   –üzpcy;u   –øzpercnt;˙%zperiod;⁄.zpermil;u   ‚Ä∞zperp;zpertenk;u   ‚Ä±zPfr;u   ùîìzpfr;u   ùî≠zPhi;u   Œ¶zphi;u   œÜzphiv;u   œïzphmmat;zphone;u   ‚òézPi;u   Œ†zpi;u   œÄz
pitchfork;zpiv;u   œñzplanck;zplanckh;u   ‚Ñézplankv;zplus;˙+z	plusacir;u   ‚®£zplusb;zpluscir;u   ‚®¢zplusdo;zplusdu;u   ‚®•zpluse;u   ‚©≤z
PlusMinus;ı   ¬±zplusmn;zplussim;u   ‚®¶zplustwo;u   ‚®ßzpm;zPoincareplane;z	pointint;u   ‚®ïzPopf;u   ‚Ñôzpopf;u   ùï°ı   ¬£zpound;zPr;u   ‚™ªzpr;u   ‚â∫zprap;u   ‚™∑zprcue;u   ‚âºzprE;u   ‚™≥zpre;u   ‚™Øzprec;zprecapprox;zpreccurlyeq;z	Precedes;zPrecedesEqual;zPrecedesSlantEqual;zPrecedesTilde;u   ‚âæzpreceq;zprecnapprox;u   ‚™πz	precneqq;u   ‚™µz	precnsim;u   ‚ã®zprecsim;zPrime;u   ‚Ä≥zprime;u   ‚Ä≤zprimes;zprnap;zprnE;zprnsim;zprod;u   ‚àèzProduct;z	profalar;u   ‚åÆz	profline;u   ‚åíz	profsurf;u   ‚åìzprop;u   ‚àùzProportion;zProportional;zpropto;zprsim;zprurel;u   ‚ä∞zPscr;u   ùí´zpscr;u   ùìÖzPsi;u   Œ®zpsi;u   œàzpuncsp;u   ‚ÄàzQfr;u   ùîîzqfr;u   ùîÆzqint;zQopf;u   ‚Ñözqopf;u   ùï¢zqprime;u   ‚ÅózQscr;u   ùí¨zqscr;u   ùìÜzquaternions;zquatint;u   ‚®ñzquest;˙?zquesteq;ZQUOT˙"zQUOT;zquot;zrAarr;u   ‚áõzrace;u   ‚àΩÃ±zRacute;u   ≈îzracute;u   ≈ïzradic;u   ‚àöz	raemptyv;u   ‚¶≥zRang;u   ‚ü´zrang;u   ‚ü©zrangd;u   ‚¶ízrange;u   ‚¶•zrangle;ı   ¬ªzraquo;zRarr;u   ‚Ü†zrArr;zrarr;u   ‚Üízrarrap;u   ‚•µzrarrb;u   ‚á•zrarrbfs;u   ‚§†zrarrc;u   ‚§≥zrarrfs;u   ‚§ûzrarrhk;zrarrlp;zrarrpl;u   ‚•Özrarrsim;u   ‚•¥zRarrtl;u   ‚§ñzrarrtl;u   ‚Ü£zrarrw;u   ‚ÜùzrAtail;u   ‚§úzratail;u   ‚§özratio;u   ‚à∂z
rationals;zRBarr;zrBarr;zrbarr;zrbbrk;u   ‚ù≥zrbrace;˙}zrbrack;˙]zrbrke;u   ‚¶åzrbrksld;u   ‚¶ézrbrkslu;u   ‚¶êzRcaron;u   ≈òzrcaron;u   ≈ôzRcedil;u   ≈ñzrcedil;u   ≈ózrceil;u   ‚åâzrcub;zRcy;u   –†zrcy;u   —Äzrdca;u   ‚§∑zrdldhar;u   ‚•©zrdquo;zrdquor;zrdsh;u   ‚Ü≥zRe;u   ‚Ñúzreal;zrealine;u   ‚Ñõz	realpart;zreals;u   ‚Ñùzrect;u   ‚ñ≠ZREGzREG;zreg;zReverseElement;zReverseEquilibrium;zReverseUpEquilibrium;zrfisht;u   ‚•Ωzrfloor;u   ‚åãzRfr;zrfr;u   ùîØzrHar;u   ‚•§zrhard;zrharu;u   ‚áÄzrharul;u   ‚•¨zRho;u   Œ°zrho;u   œÅzrhov;u   œ±zRightAngleBracket;zRightArrow;zRightarrow;zrightarrow;zRightArrowBar;zRightArrowLeftArrow;u   ‚áÑzrightarrowtail;zRightCeiling;zRightDoubleBracket;u   ‚üßzRightDownTeeVector;u   ‚•ùzRightDownVector;zRightDownVectorBar;u   ‚•ïzRightFloor;zrightharpoondown;zrightharpoonup;zrightleftarrows;zrightleftharpoons;zrightrightarrows;u   ‚áâzrightsquigarrow;z	RightTee;u   ‚ä¢zRightTeeArrow;zRightTeeVector;u   ‚•õzrightthreetimes;u   ‚ãåzRightTriangle;u   ‚ä≥zRightTriangleBar;u   ‚ßêzRightTriangleEqual;u   ‚äµzRightUpDownVector;u   ‚•èzRightUpTeeVector;u   ‚•úzRightUpVector;u   ‚ÜæzRightUpVectorBar;u   ‚•îzRightVector;zRightVectorBar;u   ‚•ìzring;u   Àözrisingdotseq;zrlarr;zrlhar;zrlm;u   ‚Äèzrmoust;u   ‚é±zrmoustache;zrnmid;u   ‚´Æzroang;u   ‚ü≠zroarr;u   ‚áæzrobrk;zropar;u   ‚¶ÜzRopf;zropf;u   ùï£zroplus;u   ‚®Æzrotimes;u   ‚®µzRoundImplies;u   ‚•∞zrpar;˙)zrpargt;u   ‚¶îz	rppolint;u   ‚®ízrrarr;zRrightarrow;zrsaquo;u   ‚Ä∫zRscr;zrscr;u   ùìázRsh;u   ‚Ü±zrsh;zrsqb;zrsquo;zrsquor;zrthree;zrtimes;u   ‚ãäzrtri;u   ‚ñπzrtrie;zrtrif;z	rtriltri;u   ‚ßézRuleDelayed;u   ‚ß¥zruluhar;u   ‚•®zrx;u   ‚ÑûzSacute;u   ≈özsacute;u   ≈õzsbquo;zSc;u   ‚™ºzsc;u   ‚âªzscap;u   ‚™∏zScaron;u   ≈†zscaron;u   ≈°zsccue;u   ‚âΩzscE;u   ‚™¥zsce;u   ‚™∞zScedil;u   ≈ûzscedil;u   ≈üzScirc;u   ≈úzscirc;u   ≈ùzscnap;u   ‚™∫zscnE;u   ‚™∂zscnsim;u   ‚ã©z	scpolint;u   ‚®ìzscsim;u   ‚âøzScy;u   –°zscy;u   —Åzsdot;u   ‚ãÖzsdotb;zsdote;u   ‚©¶zsearhk;zseArr;u   ‚áòzsearr;zsearrow;ı   ¬ßzsect;zsemi;˙;zseswar;u   ‚§©z	setminus;zsetmn;zsext;u   ‚ú∂zSfr;u   ùîñzsfr;u   ùî∞zsfrown;zsharp;u   ‚ôØzSHCHcy;u   –©zshchcy;u   —âzSHcy;u   –®zshcy;u   —àzShortDownArrow;zShortLeftArrow;z	shortmid;zshortparallel;zShortRightArrow;zShortUpArrow;u   ‚Üëı   ¬≠zshy;zSigma;u   Œ£zsigma;u   œÉzsigmaf;u   œÇzsigmav;zsim;u   ‚àºzsimdot;u   ‚©™zsime;u   ‚âÉzsimeq;zsimg;u   ‚™ûzsimgE;u   ‚™†zsiml;u   ‚™ùzsimlE;u   ‚™üzsimne;u   ‚âÜzsimplus;u   ‚®§zsimrarr;u   ‚•≤zslarr;zSmallCircle;zsmallsetminus;zsmashp;u   ‚®≥z	smeparsl;u   ‚ß§zsmid;zsmile;u   ‚å£zsmt;u   ‚™™zsmte;u   ‚™¨zsmtes;u   ‚™¨Ô∏ÄzSOFTcy;u   –¨zsoftcy;u   —åzsol;˙/zsolb;u   ‚ßÑzsolbar;u   ‚åøzSopf;u   ùïäzsopf;u   ùï§zspades;u   ‚ô†z
spadesuit;zspar;zsqcap;u   ‚äìzsqcaps;u   ‚äìÔ∏Äzsqcup;u   ‚äîzsqcups;u   ‚äîÔ∏ÄzSqrt;zsqsub;u   ‚äèzsqsube;u   ‚äëz	sqsubset;zsqsubseteq;zsqsup;u   ‚äêzsqsupe;u   ‚äíz	sqsupset;zsqsupseteq;zsqu;u   ‚ñ°zSquare;zsquare;zSquareIntersection;zSquareSubset;zSquareSubsetEqual;zSquareSuperset;zSquareSupersetEqual;zSquareUnion;zsquarf;zsquf;zsrarr;zSscr;u   ùíÆzsscr;u   ùìàzssetmn;zssmile;zsstarf;u   ‚ãÜzStar;zstar;u   ‚òÜzstarf;zstraightepsilon;zstraightphi;zstrns;zSub;u   ‚ãêzsub;u   ‚äÇzsubdot;u   ‚™ΩzsubE;u   ‚´Özsube;u   ‚äÜzsubedot;u   ‚´Ézsubmult;u   ‚´ÅzsubnE;u   ‚´ãzsubne;u   ‚ääzsubplus;u   ‚™øzsubrarr;u   ‚•πzSubset;zsubset;z	subseteq;z
subseteqq;zSubsetEqual;z
subsetneq;zsubsetneqq;zsubsim;u   ‚´ázsubsub;u   ‚´ïzsubsup;u   ‚´ìzsucc;zsuccapprox;zsucccurlyeq;z	Succeeds;zSucceedsEqual;zSucceedsSlantEqual;zSucceedsTilde;zsucceq;zsuccnapprox;z	succneqq;z	succnsim;zsuccsim;z	SuchThat;zSum;u   ‚àëzsum;zsung;u   ‚ô™ı   ¬πzsup1;ı   ¬≤zsup2;ı   ¬≥zsup3;zSup;u   ‚ãëzsup;u   ‚äÉzsupdot;u   ‚™æzsupdsub;u   ‚´òzsupE;u   ‚´Üzsupe;u   ‚äázsupedot;u   ‚´Ñz	Superset;zSupersetEqual;zsuphsol;u   ‚üâzsuphsub;u   ‚´ózsuplarr;u   ‚•ªzsupmult;u   ‚´ÇzsupnE;u   ‚´åzsupne;u   ‚äãzsupplus;u   ‚´ÄzSupset;zsupset;z	supseteq;z
supseteqq;z
supsetneq;zsupsetneqq;zsupsim;u   ‚´àzsupsub;u   ‚´îzsupsup;u   ‚´ñzswarhk;zswArr;u   ‚áôzswarr;zswarrow;zswnwar;u   ‚§™ı   √üzszlig;zTab;˙	ztarget;u   ‚åñzTau;u   Œ§ztau;u   œÑztbrk;zTcaron;u   ≈§ztcaron;u   ≈•zTcedil;u   ≈¢ztcedil;u   ≈£zTcy;u   –¢ztcy;u   —Çztdot;u   ‚Éõztelrec;u   ‚åïzTfr;u   ùîóztfr;u   ùî±zthere4;u   ‚à¥z
Therefore;z
therefore;zTheta;u   Œòztheta;u   Œ∏z	thetasym;u   œëzthetav;zthickapprox;z	thicksim;zThickSpace;u   ‚Åü‚Ääzthinsp;u   ‚Äâz
ThinSpace;zthkap;zthksim;ı   √ûı   √æzTHORN;zthorn;zTilde;ztilde;zTildeEqual;zTildeFullEqual;zTildeTilde;ı   √óztimes;ztimesb;z	timesbar;u   ‚®±ztimesd;u   ‚®∞ztint;ztoea;ztop;ztopbot;u   ‚å∂ztopcir;u   ‚´±zTopf;u   ùïãztopf;u   ùï•ztopfork;u   ‚´öztosa;ztprime;u   ‚Ä¥zTRADE;u   ‚Ñ¢ztrade;z	triangle;u   ‚ñµztriangledown;ztriangleleft;ztrianglelefteq;z
triangleq;u   ‚âúztriangleright;ztrianglerighteq;ztridot;u   ‚ó¨ztrie;z	triminus;u   ‚®∫z
TripleDot;ztriplus;u   ‚®πztrisb;u   ‚ßçztritime;u   ‚®ªz	trpezium;u   ‚è¢zTscr;u   ùíØztscr;u   ùìâzTScy;u   –¶ztscy;u   —ÜzTSHcy;u   –ãztshcy;u   —õzTstrok;u   ≈¶ztstrok;u   ≈ßztwixt;ztwoheadleftarrow;ztwoheadrightarrow;ı   √öı   √∫zUacute;zuacute;zUarr;u   ‚ÜüzuArr;zuarr;z	Uarrocir;u   ‚•âzUbrcy;u   –ézubrcy;u   —ûzUbreve;u   ≈¨zubreve;u   ≈≠ı   √õı   √ªzUcirc;zucirc;zUcy;u   –£zucy;u   —Ézudarr;u   ‚áÖzUdblac;u   ≈∞zudblac;u   ≈±zudhar;u   ‚•Æzufisht;u   ‚•æzUfr;u   ùîòzufr;u   ùî≤ı   √ôı   √πzUgrave;zugrave;zuHar;u   ‚•£zuharl;zuharr;zuhblk;u   ‚ñÄzulcorn;u   ‚åúz	ulcorner;zulcrop;u   ‚åèzultri;u   ‚ó∏zUmacr;u   ≈™zumacr;u   ≈´zuml;z	UnderBar;zUnderBrace;u   ‚èüzUnderBracket;zUnderParenthesis;u   ‚èùzUnion;z
UnionPlus;u   ‚äézUogon;u   ≈≤zuogon;u   ≈≥zUopf;u   ùïåzuopf;u   ùï¶zUpArrow;zUparrow;zuparrow;zUpArrowBar;u   ‚§ízUpArrowDownArrow;zUpDownArrow;u   ‚ÜïzUpdownarrow;zupdownarrow;zUpEquilibrium;zupharpoonleft;zupharpoonright;zuplus;zUpperLeftArrow;zUpperRightArrow;zUpsi;u   œízupsi;u   œÖzupsih;zUpsilon;u   Œ•zupsilon;zUpTee;zUpTeeArrow;zupuparrows;u   ‚áàzurcorn;u   ‚åùz	urcorner;zurcrop;u   ‚åézUring;u   ≈Æzuring;u   ≈Øzurtri;u   ‚óπzUscr;u   ùí∞zuscr;u   ùìäzutdot;u   ‚ã∞zUtilde;u   ≈®zutilde;u   ≈©zutri;zutrif;zuuarr;ı   √úı   √ºzUuml;zuuml;zuwangle;u   ‚¶ßzvangrt;u   ‚¶úzvarepsilon;z	varkappa;zvarnothing;zvarphi;zvarpi;z
varpropto;zvArr;zvarr;zvarrho;z	varsigma;zvarsubsetneq;u   ‚ääÔ∏Äzvarsubsetneqq;u   ‚´ãÔ∏Äzvarsupsetneq;u   ‚äãÔ∏Äzvarsupsetneqq;u   ‚´åÔ∏Äz	vartheta;zvartriangleleft;zvartriangleright;zVbar;u   ‚´´zvBar;u   ‚´®zvBarv;u   ‚´©zVcy;u   –ízvcy;u   –≤zVDash;u   ‚ä´zVdash;u   ‚ä©zvDash;zvdash;zVdashl;u   ‚´¶zVee;zvee;zveebar;u   ‚äªzveeeq;u   ‚âözvellip;u   ‚ãÆzVerbar;u   ‚Äñzverbar;˙|zVert;zvert;zVerticalBar;zVerticalLine;zVerticalSeparator;u   ‚ùòzVerticalTilde;u   ‚âÄzVeryThinSpace;zVfr;u   ùîôzvfr;u   ùî≥zvltri;zvnsub;zvnsup;zVopf;u   ùïçzvopf;u   ùïßzvprop;zvrtri;zVscr;u   ùí±zvscr;u   ùìãzvsubnE;zvsubne;zvsupnE;zvsupne;zVvdash;u   ‚ä™zvzigzag;u   ‚¶özWcirc;u   ≈¥zwcirc;u   ≈µzwedbar;u   ‚©üzWedge;zwedge;zwedgeq;u   ‚âôzweierp;u   ‚ÑòzWfr;u   ùîözwfr;u   ùî¥zWopf;u   ùïézwopf;u   ùï®zwp;zwr;zwreath;zWscr;u   ùí≤zwscr;u   ùìåzxcap;zxcirc;zxcup;zxdtri;zXfr;u   ùîõzxfr;u   ùîµzxhArr;zxharr;zXi;u   Œûzxi;u   ŒæzxlArr;zxlarr;zxmap;zxnis;u   ‚ãªzxodot;zXopf;u   ùïèzxopf;u   ùï©zxoplus;zxotime;zxrArr;zxrarr;zXscr;u   ùí≥zxscr;u   ùìçzxsqcup;zxuplus;zxutri;zxvee;zxwedge;ı   √ùı   √ΩzYacute;zyacute;zYAcy;u   –Øzyacy;u   —èzYcirc;u   ≈∂zycirc;u   ≈∑zYcy;u   –´zycy;u   —ãı   ¬•zyen;zYfr;u   ùîúzyfr;u   ùî∂zYIcy;u   –ázyicy;u   —ózYopf;u   ùïêzyopf;u   ùï™zYscr;u   ùí¥zyscr;u   ùìézYUcy;u   –Æzyucy;u   —éı   √øzYuml;u   ≈∏zyuml;zZacute;u   ≈πzzacute;u   ≈∫zZcaron;u   ≈Ωzzcaron;u   ≈æzZcy;u   –ózzcy;u   –∑zZdot;u   ≈ªzzdot;u   ≈ºzzeetrf;u   ‚Ñ®zZeroWidthSpace;zZeta;u   Œñzzeta;u   Œ∂zZfr;zzfr;u   ùî∑zZHcy;u   –ñzzhcy;u   –∂zzigrarr;u   ‚áùzZopf;zzopf;u   ùï´zZscr;u   ùíµzzscr;u   ùìèzzwj;u   ‚Äçzzwnj;u   ‚ÄåN)
⁄__doc__⁄__all__r   r   r   r   ⁄items⁄nameZ	codepoint⁄chr© r  r  ˙#/usr/lib/python3.5/html/entities.py⁄<module>   st  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
ì≠[?E  „               @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z d g Z e j d É Z e j d É Z	 e j d É Z
 e j d É Z e j d	 É Z e j d
 É Z e j d É Z e j d É Z e j d É Z e j d e j É Z e j d
 É Z e j d É Z Gd d Ñ  d e j É Z d S)zA parser for HTML and XHTML.È    N)⁄unescape⁄
HTMLParserz[&<]z
&[a-zA-Z#]z%&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]z)&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]z	<[a-zA-Z]˙>z--\s*>z$([a-zA-Z][^	
 /> ]*)(?:\s|/(?!>))*z]((?<=[\'"\s/])[^\s/>][^\s/=>]*)(\s*=+\s*(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?(?:\s|/(?!>))*aF  
  <[a-zA-Z][^\t\n\r\f />\x00]*       # tag name
  (?:[\s/]*                          # optional whitespace before attribute name
    (?:(?<=['"\s/])[^\s/>][^\s/=>]*  # attribute name
      (?:\s*=+\s*                    # value indicator
        (?:'[^']*'                   # LITA-enclosed value
          |"[^"]*"                   # LIT-enclosed value
          |(?!['"])[^>\s]*           # bare value
         )
         (?:\s*,)*                   # possibly followed by a comma
       )?(?:\s|/(?!>))*
     )*
   )?
  \s*                                # trailing whitespace
z#</\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\s*>c               @   sW  e  Z d  Z d Z d: Z d d d d Ñ Z d d	 Ñ  Z d
 d Ñ  Z d d Ñ  Z d Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z d$ d% Ñ  Z d& d' Ñ  Z d( d) Ñ  Z d* d+ Ñ  Z d, d- Ñ  Z d. d/ Ñ  Z d0 d1 Ñ  Z d2 d3 Ñ  Z d4 d5 Ñ  Z d6 d7 Ñ  Z d8 d9 Ñ  Z d S);r   aE  Find tags and other markup and call handler functions.

    Usage:
        p = HTMLParser()
        p.feed(data)
        ...
        p.close()

    Start tags are handled by calling self.handle_starttag() or
    self.handle_startendtag(); end tags by self.handle_endtag().  The
    data between tags is passed from the parser to the derived class
    by calling self.handle_data() with the data as argument (the data
    may be split up in arbitrary chunks).  If convert_charrefs is
    True the character references are converted automatically to the
    corresponding Unicode character (and self.handle_data() is no
    longer split in chunks), otherwise they are passed by calling
    self.handle_entityref() or self.handle_charref() with the string
    containing respectively the named or numeric reference as the
    argument.
    ⁄script⁄style⁄convert_charrefsTc            C   s   | |  _  |  j É  d S)z∆Initialize and reset this instance.

        If convert_charrefs is True (the default), all character references
        are automatically converted to the corresponding Unicode characters.
        N)r   ⁄reset)⁄selfr   © r
   ˙!/usr/lib/python3.5/html/parser.py⁄__init__W   s    	zHTMLParser.__init__c             C   s8   d |  _  d |  _ t |  _ d |  _ t j j |  É d S)z1Reset this instance.  Loses all unprocessed data.⁄ z???N)⁄rawdata⁄lasttag⁄interesting_normal⁄interesting⁄
cdata_elem⁄_markupbase⁄
ParserBaser   )r	   r
   r
   r   r   `   s
    				zHTMLParser.resetc             C   s!   |  j  | |  _  |  j d É d S)zëFeed data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '\n').
        r   N)r   ⁄goahead)r	   ⁄datar
   r
   r   ⁄feedh   s    zHTMLParser.feedc             C   s   |  j  d É d S)zHandle any buffered data.È   N)r   )r	   r
   r
   r   ⁄closeq   s    zHTMLParser.closeNc             C   s   |  j  S)z)Return full source of start tag: '<...>'.)⁄_HTMLParser__starttag_text)r	   r
   r
   r   ⁄get_starttag_textw   s    zHTMLParser.get_starttag_textc             C   s2   | j  É  |  _ t j d |  j t j É |  _ d  S)Nz</\s*%s\s*>)⁄lowerr   ⁄re⁄compile⁄Ir   )r	   ⁄elemr
   r
   r   ⁄set_cdata_mode{   s    zHTMLParser.set_cdata_modec             C   s   t  |  _ d  |  _ d  S)N)r   r   r   )r	   r
   r
   r   ⁄clear_cdata_mode   s    	zHTMLParser.clear_cdata_modec             C   sª  |  j  } d } t | É } x| | k  r+|  j r¨ |  j r¨ | j d | É } | d k  rÊ | j d t | | d É É } | d k r£ t j d É j	 | | É r£ P| } n: |  j
 j	 | | É } | r÷ | j É  } n |  j r‡ P| } | | k  r<|  j r%|  j r%|  j t | | | Ö É É n |  j | | | Ö É |  j | | É } | | k r[P| j } | d | É rt j | | É ró|  j | É }	 nØ | d | É r∏|  j | É }	 né | d | É rŸ|  j | É }	 nm | d | É r˙|  j | É }	 nL | d	 | É r|  j | É }	 n+ | d
 | k  rE|  j d É | d
 }	 n P|	 d k  r˛| sYP| j d | d
 É }	 |	 d k  r™| j d | d
 É }	 |	 d k  r¥| d
 }	 n
 |	 d
 7}	 |  j rÁ|  j rÁ|  j t | | |	 Ö É É n |  j | | |	 Ö É |  j | |	 É } q | d | É rÈt j | | É } | rû| j É  d d Ö }
 |  j |
 É | j É  }	 | d |	 d
 É sÜ|	 d
 }	 |  j | |	 É } q q(d | | d  Ö k rÂ|  j | | | d Ö É |  j | | d É } Pq | d | É rt j | | É } | rj| j d
 É }
 |  j |
 É | j É  }	 | d |	 d
 É sU|	 d
 }	 |  j | |	 É } q t j | | É } | r‹| rÿ| j É  | | d  Ö k rÿ| j É  }	 |	 | k r¬| }	 |  j | | d
 É } Pq(| d
 | k  r|  j d É |  j | | d
 É } q(Pq d s t d É Ç q W| r§| | k  r§|  j r§|  j r{|  j r{|  j t | | | Ö É É n |  j | | | Ö É |  j | | É } | | d  Ö |  _  d  S)Nr   ˙<˙&È"   z[\s;]z</z<!--z<?z<!r   r   z&#È   ˙;zinteresting.search() liedÈˇˇˇˇ)r   ⁄lenr   r   ⁄find⁄rfind⁄maxr   r   ⁄searchr   ⁄start⁄handle_datar   Z	updatepos⁄
startswith⁄starttagopen⁄match⁄parse_starttag⁄parse_endtag⁄parse_comment⁄parse_pi⁄parse_html_declaration⁄charref⁄group⁄handle_charref⁄end⁄	entityref⁄handle_entityref⁄
incomplete⁄AssertionError)r	   r;   r   ⁄i⁄n⁄jZampposr2   r0   ⁄k⁄namer
   r
   r   r   Ü   s¬    			  	
 

" zHTMLParser.goaheadc             C   s˜   |  j  } | | | d Ö d k s/ t d É Ç | | | d Ö d k rV |  j | É S| | | d Ö d k r} |  j | É S| | | d Ö j É  d	 k rÊ | j d
 | d É } | d k r√ d S|  j | | d | Ö É | d S|  j | É Sd  S)Nr&   z<!z+unexpected call to parse_html_declaration()È   z<!--È   z<![È	   z	<!doctyper   r   r(   r(   )r   r?   r5   Zparse_marked_sectionr   r*   ⁄handle_decl⁄parse_bogus_comment)r	   r@   r   ⁄gtposr
   r
   r   r7      s    	& z!HTMLParser.parse_html_declarationr   c             C   s~   |  j  } | | | d Ö d k s/ t d É Ç | j d | d É } | d k rU d	 S| rv |  j | | d | Ö É | d S)
Nr&   ˙<!˙</z"unexpected call to parse_comment()r   r   )rK   rL   r(   r(   )r   r?   r*   ⁄handle_comment)r	   r@   Zreportr   ⁄posr
   r
   r   rI     s    	&zHTMLParser.parse_bogus_commentc             C   sÜ   |  j  } | | | d Ö d k s/ t d É Ç t j | | d É } | sO d S| j É  } |  j | | d | Ö É | j É  } | S)Nr&   z<?zunexpected call to parse_pi()r   r(   )r   r?   ⁄picloser-   r.   ⁄	handle_pir;   )r	   r@   r   r2   rB   r
   r
   r   r6   !  s    	&zHTMLParser.parse_pic             C   sï  d  |  _  |  j | É } | d k  r( | S|  j } | | | Ö |  _  g  } t j | | d É } | sr t d É Ç | j É  } | j d É j É  |  _	 } x˝ | | k  rôt
 j | | É } | s¬ P| j d d d É \ }	 }
 } |
 sÔ d  } np | d  d Ö d k o| d d  Ö k n sO| d  d Ö d k oJ| d d  Ö k n r_| d d Ö } | rqt | É } | j |	 j É  | f É | j É  } qù W| | | Ö j É  } | d k rC|  j É  \ } } d
 |  j  k r| |  j  j d
 É } t |  j  É |  j  j d
 É } n | t |  j  É } |  j | | | Ö É | S| j d	 É re|  j | | É n, |  j | | É | |  j k rë|  j | É | S)Nr   r   z#unexpected call to parse_starttag()r&   rF   ˙'˙"r   ˙/>⁄
r(   r(   r(   )r   rS   )r   ⁄check_for_whole_start_tagr   ⁄tagfind_tolerantr2   r?   r;   r9   r   r   ⁄attrfind_tolerantr   ⁄append⁄stripZgetpos⁄countr)   r+   r/   ⁄endswith⁄handle_startendtag⁄handle_starttag⁄CDATA_CONTENT_ELEMENTSr!   )r	   r@   ⁄endposr   ⁄attrsr2   rC   ⁄tag⁄mZattrname⁄restZ	attrvaluer;   ⁄lineno⁄offsetr
   r
   r   r3   -  sR    			00zHTMLParser.parse_starttagc             C   sÒ   |  j  } t j | | É } | r· | j É  } | | | d Ö } | d k rU | d S| d k r© | j d | É r{ | d S| j d | É rë d	 S| | k r° | S| d S| d k rπ d
 S| d k r… d S| | k rŸ | S| d St d É Ç d  S)Nr   r   ˙/z/>r&   r   z6abcdefghijklmnopqrstuvwxyz=/ABCDEFGHIJKLMNOPQRSTUVWXYZzwe should not get here!r(   r(   r(   )r   ⁄locatestarttagend_tolerantr2   r;   r0   r?   )r	   r@   r   rb   rB   ⁄nextr
   r
   r   rU   `  s.    	z$HTMLParser.check_for_whole_start_tagc             C   sô  |  j  } | | | d Ö d k s/ t d É Ç t j | | d É } | sO d S| j É  } t j | | É } | s*|  j d  k	 rù |  j | | | Ö É | St	 j | | d É } | sË | | | d Ö d k r€ | d S|  j
 | É S| j d É j É  } | j d | j É  É } |  j | É | d S| j d É j É  } |  j d  k	 rx| |  j k rx|  j | | | Ö É | S|  j | j É  É |  j É  | S)	Nr&   z</zunexpected call to parse_endtagr   rF   z</>r   r(   )r   r?   ⁄	endendtagr-   r;   ⁄
endtagfindr2   r   r/   rV   rI   r9   r   r*   ⁄handle_endtagr"   )r	   r@   r   r2   rJ   Z	namematchZtagnamer    r
   r
   r   r4   Ç  s8    	&
zHTMLParser.parse_endtagc             C   s!   |  j  | | É |  j | É d  S)N)r]   rk   )r	   ra   r`   r
   r
   r   r\   ™  s    zHTMLParser.handle_startendtagc             C   s   d  S)Nr
   )r	   ra   r`   r
   r
   r   r]   Ø  s    zHTMLParser.handle_starttagc             C   s   d  S)Nr
   )r	   ra   r
   r
   r   rk   ≥  s    zHTMLParser.handle_endtagc             C   s   d  S)Nr
   )r	   rD   r
   r
   r   r:   ∑  s    zHTMLParser.handle_charrefc             C   s   d  S)Nr
   )r	   rD   r
   r
   r   r=   ª  s    zHTMLParser.handle_entityrefc             C   s   d  S)Nr
   )r	   r   r
   r
   r   r/   ø  s    zHTMLParser.handle_datac             C   s   d  S)Nr
   )r	   r   r
   r
   r   rM   √  s    zHTMLParser.handle_commentc             C   s   d  S)Nr
   )r	   Zdeclr
   r
   r   rH   «  s    zHTMLParser.handle_declc             C   s   d  S)Nr
   )r	   r   r
   r
   r   rP   À  s    zHTMLParser.handle_pic             C   s   d  S)Nr
   )r	   r   r
   r
   r   ⁄unknown_declŒ  s    zHTMLParser.unknown_declc             C   s    t  j d t d d Ét | É S)NzZThe unescape method is deprecated and will be removed in 3.5, use html.unescape() instead.⁄
stacklevelr&   )⁄warnings⁄warn⁄DeprecationWarningr   )r	   ⁄sr
   r
   r   r   “  s    	zHTMLParser.unescape)r   r   )⁄__name__⁄
__module__⁄__qualname__⁄__doc__r^   r   r   r   r   r   r   r!   r"   r   r7   rI   r6   r3   rU   r4   r\   r]   rk   r:   r=   r/   rM   rH   rP   rl   r   r
   r
   r
   r   r   ?   s8   		z3"()ru   r   rn   r   Zhtmlr   ⁄__all__r   r   r>   r<   r8   r1   rO   ZcommentcloserV   rW   ⁄VERBOSErg   ri   rj   r   r   r
   r
   r
   r   ⁄<module>   s(   
		                                                                         from enum import IntEnum

__all__ = ['HTTPStatus']

class HTTPStatus(IntEnum):
    """HTTP status codes and reason phrases

    Status codes from the following RFCs are all observed:

        * RFC 7231: Hypertext Transfer Protocol (HTTP/1.1), obsoletes 2616
        * RFC 6585: Additional HTTP Status Codes
        * RFC 3229: Delta encoding in HTTP
        * RFC 4918: HTTP Extensions for WebDAV, obsoletes 2518
        * RFC 5842: Binding Extensions to WebDAV
        * RFC 7238: Permanent Redirect
        * RFC 2295: Transparent Content Negotiation in HTTP
        * RFC 2774: An HTTP Extension Framework
    """
    def __new__(cls, value, phrase, description=''):
        obj = int.__new__(cls, value)
        obj._value_ = value

        obj.phrase = phrase
        obj.description = description
        return obj

    # informational
    CONTINUE = 100, 'Continue', 'Request received, please continue'
    SWITCHING_PROTOCOLS = (101, 'Switching Protocols',
            'Switching to new protocol; obey Upgrade header')
    PROCESSING = 102, 'Processing'

    # success
    OK = 200, 'OK', 'Request fulfilled, document follows'
    CREATED = 201, 'Created', 'Document created, URL follows'
    ACCEPTED = (202, 'Accepted',
        'Request accepted, processing continues off-line')
    NON_AUTHORITATIVE_INFORMATION = (203,
        'Non-Authoritative Information', 'Request fulfilled from cache')
    NO_CONTENT = 204, 'No Content', 'Request fulfilled, nothing follows'
    RESET_CONTENT = 205, 'Reset Content', 'Clear input form for further input'
    PARTIAL_CONTENT = 206, 'Partial Content', 'Partial content follows'
    MULTI_STATUS = 207, 'Multi-Status'
    ALREADY_REPORTED = 208, 'Already Reported'
    IM_USED = 226, 'IM Used'

    # redirection
    MULTIPLE_CHOICES = (300, 'Multiple Choices',
        'Object has several resources -- see URI list')
    MOVED_PERMANENTLY = (301, 'Moved Permanently',
        'Object moved permanently -- see URI list')
    FOUND = 302, 'Found', 'Object moved temporarily -- see URI list'
    SEE_OTHER = 303, 'See Other', 'Object moved -- see Method and URL list'
    NOT_MODIFIED = (304, 'Not Modified',
        'Document has not changed since given time')
    USE_PROXY = (305, 'Use Proxy',
        'You must use proxy specified in Location to access this resource')
    TEMPORARY_REDIRECT = (307, 'Temporary Redirect',
        'Object moved temporarily -- see URI list')
    PERMANENT_REDIRECT = (308, 'Permanent Redirect',
        'Object moved temporarily -- see URI list')

    # client error
    BAD_REQUEST = (400, 'Bad Request',
        'Bad request syntax or unsupported method')
    UNAUTHORIZED = (401, 'Unauthorized',
        'No permission -- see authorization schemes')
    PAYMENT_REQUIRED = (402, 'Payment Required',
        'No payment -- see charging schemes')
    FORBIDDEN = (403, 'Forbidden',
        'Request forbidden -- authorization will not help')
    NOT_FOUND = (404, 'Not Found',
        'Nothing matches the given URI')
    METHOD_NOT_ALLOWED = (405, 'Method Not Allowed',
        'Specified method is invalid for this resource')
    NOT_ACCEPTABLE = (406, 'Not Acceptable',
        'URI not available in preferred format')
    PROXY_AUTHENTICATION_REQUIRED = (407,
        'Proxy Authentication Required',
        'You must authenticate with this proxy before proceeding')
    REQUEST_TIMEOUT = (408, 'Request Timeout',
        'Request timed out; try again later')
    CONFLICT = 409, 'Conflict', 'Request conflict'
    GONE = (410, 'Gone',
        'URI no longer exists and has been permanently removed')
    LENGTH_REQUIRED = (411, 'Length Required',
        'Client must specify Content-Length')
    PRECONDITION_FAILED = (412, 'Precondition Failed',
        'Precondition in headers is false')
    REQUEST_ENTITY_TOO_LARGE = (413, 'Request Entity Too Large',
        'Entity is too large')
    REQUEST_URI_TOO_LONG = (414, 'Request-URI Too Long',
        'URI is too long')
    UNSUPPORTED_MEDIA_TYPE = (415, 'Unsupported Media Type',
        'Entity body in unsupported format')
    REQUESTED_RANGE_NOT_SATISFIABLE = (416,
        'Requested Range Not Satisfiable',
        'Cannot satisfy request range')
    EXPECTATION_FAILED = (417, 'Expectation Failed',
        'Expect condition could not be satisfied')
    UNPROCESSABLE_ENTITY = 422, 'Unprocessable Entity'
    LOCKED = 423, 'Locked'
    FAILED_DEPENDENCY = 424, 'Failed Dependency'
    UPGRADE_REQUIRED = 426, 'Upgrade Required'
    PRECONDITION_REQUIRED = (428, 'Precondition Required',
        'The origin server requires the request to be conditional')
    TOO_MANY_REQUESTS = (429, 'Too Many Requests',
        'The user has sent too many requests in '
        'a given amount of time ("rate limiting")')
    REQUEST_HEADER_FIELDS_TOO_LARGE = (431,
        'Request Header Fields Too Large',
        'The server is unwilling to process the request because its header '
        'fields are too large')

    # server errors
    INTERNAL_SERVER_ERROR = (500, 'Internal Server Error',
        'Server got itself in trouble')
    NOT_IMPLEMENTED = (501, 'Not Implemented',
        'Server does not support this operation')
    BAD_GATEWAY = (502, 'Bad Gateway',
        'Invalid responses from another server/proxy')
    SERVICE_UNAVAILABLE = (503, 'Service Unavailable',
        'The server cannot process the request due to a high load')
    GATEWAY_TIMEOUT = (504, 'Gateway Timeout',
        'The gateway server did not receive a timely response')
    HTTP_VERSION_NOT_SUPPORTED = (505, 'HTTP Version Not Supported',
        'Cannot fulfill request')
    VARIANT_ALSO_NEGOTIATES = 506, 'Variant Also Negotiates'
    INSUFFICIENT_STORAGE = 507, 'Insufficient Storage'
    LOOP_DETECTED = 508, 'Loop Detected'
    NOT_EXTENDED = 510, 'Not Extended'
    NETWORK_AUTHENTICATION_REQUIRED = (511,
        'Network Authentication Required',
        'The client needs to authenticate to gain network access')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """HTTP/1.1 client library

<intro stuff goes here>
<other stuff, too>

HTTPConnection goes through a number of "states", which define when a client
may legally make another request or fetch the response for a particular
request. This diagram details these state transitions:

    (null)
      |
      | HTTPConnection()
      v
    Idle
      |
      | putrequest()
      v
    Request-started
      |
      | ( putheader() )*  endheaders()
      v
    Request-sent
      |\_____________________________
      |                              | getresponse() raises
      | response = getresponse()     | ConnectionError
      v                              v
    Unread-response                Idle
    [Response-headers-read]
      |\____________________
      |                     |
      | response.read()     | putrequest()
      v                     v
    Idle                  Req-started-unread-response
                     ______/|
                   /        |
   response.read() |        | ( putheader() )*  endheaders()
                   v        v
       Request-started    Req-sent-unread-response
                            |
                            | response.read()
                            v
                          Request-sent

This diagram presents the following rules:
  -- a second request may not be started until {response-headers-read}
  -- a response [object] cannot be retrieved until {request-sent}
  -- there is no differentiation between an unread response body and a
     partially read response body

Note: this enforcement is applied by the HTTPConnection class. The
      HTTPResponse class does not enforce this state machine, which
      implies sophisticated clients may accelerate the request/response
      pipeline. Caution should be taken, though: accelerating the states
      beyond the above pattern may imply knowledge of the server's
      connection-close behavior for certain requests. For example, it
      is impossible to tell whether the server will close the connection
      UNTIL the response headers have been read; this means that further
      requests cannot be placed into the pipeline until it is known that
      the server will NOT be closing the connection.

Logical State                  __state            __response
-------------                  -------            ----------
Idle                           _CS_IDLE           None
Request-started                _CS_REQ_STARTED    None
Request-sent                   _CS_REQ_SENT       None
Unread-response                _CS_IDLE           <response_class>
Req-started-unread-response    _CS_REQ_STARTED    <response_class>
Req-sent-unread-response       _CS_REQ_SENT       <response_class>
"""

import email.parser
import email.message
import http
import io
import os
import re
import socket
import collections
from urllib.parse import urlsplit

# HTTPMessage, parse_headers(), and the HTTP status code constants are
# intentionally omitted for simplicity
__all__ = ["HTTPResponse", "HTTPConnection",
           "HTTPException", "NotConnected", "UnknownProtocol",
           "UnknownTransferEncoding", "UnimplementedFileMode",
           "IncompleteRead", "InvalidURL", "ImproperConnectionState",
           "CannotSendRequest", "CannotSendHeader", "ResponseNotReady",
           "BadStatusLine", "LineTooLong", "RemoteDisconnected", "error",
           "responses"]

HTTP_PORT = 80
HTTPS_PORT = 443

_UNKNOWN = 'UNKNOWN'

# connection states
_CS_IDLE = 'Idle'
_CS_REQ_STARTED = 'Request-started'
_CS_REQ_SENT = 'Request-sent'


# hack to maintain backwards compatibility
globals().update(http.HTTPStatus.__members__)

# another hack to maintain backwards compatibility
# Mapping status codes to official W3C names
responses = {v: v.phrase for v in http.HTTPStatus.__members__.values()}

# maximal amount of data to read at one time in _safe_read
MAXAMOUNT = 1048576

# maximal line length when calling readline().
_MAXLINE = 65536
_MAXHEADERS = 100

# Header name/value ABNF (http://tools.ietf.org/html/rfc7230#section-3.2)
#
# VCHAR          = %x21-7E
# obs-text       = %x80-FF
# header-field   = field-name ":" OWS field-value OWS
# field-name     = token
# field-value    = *( field-content / obs-fold )
# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
# field-vchar    = VCHAR / obs-text
#
# obs-fold       = CRLF 1*( SP / HTAB )
#                ; obsolete line folding
#                ; see Section 3.2.4

# token          = 1*tchar
#
# tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
#                / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
#                / DIGIT / ALPHA
#                ; any VCHAR, except delimiters
#
# VCHAR defined in http://tools.ietf.org/html/rfc5234#appendix-B.1

# the patterns for both name and value are more lenient than RFC
# definitions to allow for backwards compatibility
_is_legal_header_name = re.compile(rb'[^:\s][^:\r\n]*').fullmatch
_is_illegal_header_value = re.compile(rb'\n(?![ \t])|\r(?![ \t\n])').search

# We always set the Content-Length header for these methods because some
# servers will otherwise respond with a 411
_METHODS_EXPECTING_BODY = {'PATCH', 'POST', 'PUT'}


def _encode(data, name='data'):
    """Call data.encode("latin-1") but show a better error message."""
    try:
        return data.encode("latin-1")
    except UnicodeEncodeError as err:
        raise UnicodeEncodeError(
            err.encoding,
            err.object,
            err.start,
            err.end,
            "%s (%.20r) is not valid Latin-1. Use %s.encode('utf-8') "
            "if you want to send it encoded in UTF-8." %
            (name.title(), data[err.start:err.end], name)) from None


class HTTPMessage(email.message.Message):
    # XXX The only usage of this method is in
    # http.server.CGIHTTPRequestHandler.  Maybe move the code there so
    # that it doesn't need to be part of the public API.  The API has
    # never been defined so this could cause backwards compatibility
    # issues.

    def getallmatchingheaders(self, name):
        """Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.

        """
        name = name.lower() + ':'
        n = len(name)
        lst = []
        hit = 0
        for line in self.keys():
            if line[:n].lower() == name:
                hit = 1
            elif not line[:1].isspace():
                hit = 0
            if hit:
                lst.append(line)
        return lst

def parse_headers(fp, _class=HTTPMessage):
    """Parses only RFC2822 headers from a file pointer.

    email Parser wants to see strings rather than bytes.
    But a TextIOWrapper around self.rfile would buffer too many bytes
    from the stream, bytes which we later need to read as bytes.
    So we read the correct bytes here, as bytes, for email Parser
    to parse.

    """
    headers = []
    while True:
        line = fp.readline(_MAXLINE + 1)
        if len(line) > _MAXLINE:
            raise LineTooLong("header line")
        headers.append(line)
        if len(headers) > _MAXHEADERS:
            raise HTTPException("got more than %d headers" % _MAXHEADERS)
        if line in (b'\r\n', b'\n', b''):
            break
    hstring = b''.join(headers).decode('iso-8859-1')
    return email.parser.Parser(_class=_class).parsestr(hstring)


class HTTPResponse(io.BufferedIOBase):

    # See RFC 2616 sec 19.6 and RFC 1945 sec 6 for details.

    # The bytes from the socket object are iso-8859-1 strings.
    # See RFC 2616 sec 2.2 which notes an exception for MIME-encoded
    # text following RFC 2047.  The basic status line parsing only
    # accepts iso-8859-1.

    def __init__(self, sock, debuglevel=0, method=None, url=None):
        # If the response includes a content-length header, we need to
        # make sure that the client doesn't read more than the
        # specified number of bytes.  If it does, it will block until
        # the server times out and closes the connection.  This will
        # happen if a self.fp.read() is done (without a size) whether
        # self.fp is buffered or not.  So, no self.fp.read() by
        # clients unless they know what they are doing.
        self.fp = sock.makefile("rb")
        self.debuglevel = debuglevel
        self._method = method

        # The HTTPResponse object is returned via urllib.  The clients
        # of http and urllib expect different attributes for the
        # headers.  headers is used here and supports urllib.  msg is
        # provided as a backwards compatibility layer for http
        # clients.

        self.headers = self.msg = None

        # from the Status-Line of the response
        self.version = _UNKNOWN # HTTP-Version
        self.status = _UNKNOWN  # Status-Code
        self.reason = _UNKNOWN  # Reason-Phrase

        self.chunked = _UNKNOWN         # is "chunked" being used?
        self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
        self.length = _UNKNOWN          # number of bytes left in response
        self.will_close = _UNKNOWN      # conn will close at end of response

    def _read_status(self):
        line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
        if len(line) > _MAXLINE:
            raise LineTooLong("status line")
        if self.debuglevel > 0:
            print("reply:", repr(line))
        if not line:
            # Presumably, the server closed the connection before
            # sending a valid response.
            raise RemoteDisconnected("Remote end closed connection without"
                                     " response")
        try:
            version, status, reason = line.split(None, 2)
        except ValueError:
            try:
                version, status = line.split(None, 1)
                reason = ""
            except ValueError:
                # empty version will cause next test to fail.
                version = ""
        if not version.startswith("HTTP/"):
            self._close_conn()
            raise BadStatusLine(line)

        # The status code is a three-digit number
        try:
            status = int(status)
            if status < 100 or status > 999:
                raise BadStatusLine(line)
        except ValueError:
            raise BadStatusLine(line)
        return version, status, reason

    def begin(self):
        if self.headers is not None:
            # we've already started reading the response
            return

        # read until we get a non-100 response
        while True:
            version, status, reason = self._read_status()
            if status != CONTINUE:
                break
            # skip the header from the 100 response
            while True:
                skip = self.fp.readline(_MAXLINE + 1)
                if len(skip) > _MAXLINE:
                    raise LineTooLong("header line")
                skip = skip.strip()
                if not skip:
                    break
                if self.debuglevel > 0:
                    print("header:", skip)

        self.code = self.status = status
        self.reason = reason.strip()
        if version in ("HTTP/1.0", "HTTP/0.9"):
            # Some servers might still return "0.9", treat it as 1.0 anyway
            self.version = 10
        elif version.startswith("HTTP/1."):
            self.version = 11   # use HTTP/1.1 code for HTTP/1.x where x>=1
        else:
            raise UnknownProtocol(version)

        self.headers = self.msg = parse_headers(self.fp)

        if self.debuglevel > 0:
            for hdr in self.headers:
                print("header:", hdr, end=" ")

        # are we using the chunked-style of transfer encoding?
        tr_enc = self.headers.get("transfer-encoding")
        if tr_enc and tr_enc.lower() == "chunked":
            self.chunked = True
            self.chunk_left = None
        else:
            self.chunked = False

        # will the connection close at the end of the response?
        self.will_close = self._check_close()

        # do we have a Content-Length?
        # NOTE: RFC 2616, S4.4, #3 says we ignore this if tr_enc is "chunked"
        self.length = None
        length = self.headers.get("content-length")

         # are we using the chunked-style of transfer encoding?
        tr_enc = self.headers.get("transfer-encoding")
        if length and not self.chunked:
            try:
                self.length = int(length)
            except ValueError:
                self.length = None
            else:
                if self.length < 0:  # ignore nonsensical negative lengths
                    self.length = None
        else:
            self.length = None

        # does the body have a fixed length? (of zero)
        if (status == NO_CONTENT or status == NOT_MODIFIED or
            100 <= status < 200 or      # 1xx codes
            self._method == "HEAD"):
            self.length = 0

        # if the connection remains open, and we aren't using chunked, and
        # a content-length was not provided, then assume that the connection
        # WILL close.
        if (not self.will_close and
            not self.chunked and
            self.length is None):
            self.will_close = True

    def _check_close(self):
        conn = self.headers.get("connection")
        if self.version == 11:
            # An HTTP/1.1 proxy is assumed to stay open unless
            # explicitly closed.
            conn = self.headers.get("connection")
            if conn and "close" in conn.lower():
                return True
            return False

        # Some HTTP/1.0 implementations have support for persistent
        # connections, using rules different than HTTP/1.1.

        # For older HTTP, Keep-Alive indicates persistent connection.
        if self.headers.get("keep-alive"):
            return False

        # At least Akamai returns a "Connection: Keep-Alive" header,
        # which was supposed to be sent by the client.
        if conn and "keep-alive" in conn.lower():
            return False

        # Proxy-Connection is a netscape hack.
        pconn = self.headers.get("proxy-connection")
        if pconn and "keep-alive" in pconn.lower():
            return False

        # otherwise, assume it will close
        return True

    def _close_conn(self):
        fp = self.fp
        self.fp = None
        fp.close()

    def close(self):
        try:
            super().close() # set "closed" flag
        finally:
            if self.fp:
                self._close_conn()

    # These implementations are for the benefit of io.BufferedReader.

    # XXX This class should probably be revised to act more like
    # the "raw stream" that BufferedReader expects.

    def flush(self):
        super().flush()
        if self.fp:
            self.fp.flush()

    def readable(self):
        return True

    # End of "raw stream" methods

    def isclosed(self):
        """True if the connection is closed."""
        # NOTE: it is possible that we will not ever call self.close(). This
        #       case occurs when will_close is TRUE, length is None, and we
        #       read up to the last byte, but NOT past it.
        #
        # IMPLIES: if will_close is FALSE, then self.close() will ALWAYS be
        #          called, meaning self.isclosed() is meaningful.
        return self.fp is None

    def read(self, amt=None):
        if self.fp is None:
            return b""

        if self._method == "HEAD":
            self._close_conn()
            return b""

        if amt is not None:
            # Amount is given, implement using readinto
            b = bytearray(amt)
            n = self.readinto(b)
            return memoryview(b)[:n].tobytes()
        else:
            # Amount is not given (unbounded read) so we must check self.length
            # and self.chunked

            if self.chunked:
                return self._readall_chunked()

            if self.length is None:
                s = self.fp.read()
            else:
                try:
                    s = self._safe_read(self.length)
                except IncompleteRead:
                    self._close_conn()
                    raise
                self.length = 0
            self._close_conn()        # we read everything
            return s

    def readinto(self, b):
        if self.fp is None:
            return 0

        if self._method == "HEAD":
            self._close_conn()
            return 0

        if self.chunked:
            return self._readinto_chunked(b)

        if self.length is not None:
            if len(b) > self.length:
                # clip the read to the "end of response"
                b = memoryview(b)[0:self.length]

        # we do not use _safe_read() here because this may be a .will_close
        # connection, and the user is reading more bytes than will be provided
        # (for example, reading in 1k chunks)
        n = self.fp.readinto(b)
        if not n and b:
            # Ideally, we would raise IncompleteRead if the content-length
            # wasn't satisfied, but it might break compatibility.
            self._close_conn()
        elif self.length is not None:
            self.length -= n
            if not self.length:
                self._close_conn()
        return n

    def _read_next_chunk_size(self):
        # Read the next chunk size from the file
        line = self.fp.readline(_MAXLINE + 1)
        if len(line) > _MAXLINE:
            raise LineTooLong("chunk size")
        i = line.find(b";")
        if i >= 0:
            line = line[:i] # strip chunk-extensions
        try:
            return int(line, 16)
        except ValueError:
            # close the connection as protocol synchronisation is
            # probably lost
            self._close_conn()
            raise

    def _read_and_discard_trailer(self):
        # read and discard trailer up to the CRLF terminator
        ### note: we shouldn't have any trailers!
        while True:
            line = self.fp.readline(_MAXLINE + 1)
            if len(line) > _MAXLINE:
                raise LineTooLong("trailer line")
            if not line:
                # a vanishingly small number of sites EOF without
                # sending the trailer
                break
            if line in (b'\r\n', b'\n', b''):
                break

    def _get_chunk_left(self):
        # return self.chunk_left, reading a new chunk if necessary.
        # chunk_left == 0: at the end of the current chunk, need to close it
        # chunk_left == None: No current chunk, should read next.
        # This function returns non-zero or None if the last chunk has
        # been read.
        chunk_left = self.chunk_left
        if not chunk_left: # Can be 0 or None
            if chunk_left is not None:
                # We are at the end of chunk. dicard chunk end
                self._safe_read(2)  # toss the CRLF at the end of the chunk
            try:
                chunk_left = self._read_next_chunk_size()
            except ValueError:
                raise IncompleteRead(b'')
            if chunk_left == 0:
                # last chunk: 1*("0") [ chunk-extension ] CRLF
                self._read_and_discard_trailer()
                # we read everything; close the "file"
                self._close_conn()
                chunk_left = None
            self.chunk_left = chunk_left
        return chunk_left

    def _readall_chunked(self):
        assert self.chunked != _UNKNOWN
        value = []
        try:
            while True:
                chunk_left = self._get_chunk_left()
                if chunk_left is None:
                    break
                value.append(self._safe_read(chunk_left))
                self.chunk_left = 0
            return b''.join(value)
        except IncompleteRead:
            raise IncompleteRead(b''.join(value))

    def _readinto_chunked(self, b):
        assert self.chunked != _UNKNOWN
        total_bytes = 0
        mvb = memoryview(b)
        try:
            while True:
                chunk_left = self._get_chunk_left()
                if chunk_left is None:
                    return total_bytes

                if len(mvb) <= chunk_left:
                    n = self._safe_readinto(mvb)
                    self.chunk_left = chunk_left - n
                    return total_bytes + n

                temp_mvb = mvb[:chunk_left]
                n = self._safe_readinto(temp_mvb)
                mvb = mvb[n:]
                total_bytes += n
                self.chunk_left = 0

        except IncompleteRead:
            raise IncompleteRead(bytes(b[0:total_bytes]))

    def _safe_read(self, amt):
        """Read the number of bytes requested, compensating for partial reads.

        Normally, we have a blocking socket, but a read() can be interrupted
        by a signal (resulting in a partial read).

        Note that we cannot distinguish between EOF and an interrupt when zero
        bytes have been read. IncompleteRead() will be raised in this
        situation.

        This function should be used when <amt> bytes "should" be present for
        reading. If the bytes are truly not available (due to EOF), then the
        IncompleteRead exception can be used to detect the problem.
        """
        s = []
        while amt > 0:
            chunk = self.fp.read(min(amt, MAXAMOUNT))
            if not chunk:
                raise IncompleteRead(b''.join(s), amt)
            s.append(chunk)
            amt -= len(chunk)
        return b"".join(s)

    def _safe_readinto(self, b):
        """Same as _safe_read, but for reading into a buffer."""
        total_bytes = 0
        mvb = memoryview(b)
        while total_bytes < len(b):
            if MAXAMOUNT < len(mvb):
                temp_mvb = mvb[0:MAXAMOUNT]
                n = self.fp.readinto(temp_mvb)
            else:
                n = self.fp.readinto(mvb)
            if not n:
                raise IncompleteRead(bytes(mvb[0:total_bytes]), len(b))
            mvb = mvb[n:]
            total_bytes += n
        return total_bytes

    def read1(self, n=-1):
        """Read with at most one underlying system call.  If at least one
        byte is buffered, return that instead.
        """
        if self.fp is None or self._method == "HEAD":
            return b""
        if self.chunked:
            return self._read1_chunked(n)
        if self.length is not None and (n < 0 or n > self.length):
            n = self.length
        try:
            result = self.fp.read1(n)
        except ValueError:
            if n >= 0:
                raise
            # some implementations, like BufferedReader, don't support -1
            # Read an arbitrarily selected largeish chunk.
            result = self.fp.read1(16*1024)
        if not result and n:
            self._close_conn()
        elif self.length is not None:
            self.length -= len(result)
        return result

    def peek(self, n=-1):
        # Having this enables IOBase.readline() to read more than one
        # byte at a time
        if self.fp is None or self._method == "HEAD":
            return b""
        if self.chunked:
            return self._peek_chunked(n)
        return self.fp.peek(n)

    def readline(self, limit=-1):
        if self.fp is None or self._method == "HEAD":
            return b""
        if self.chunked:
            # Fallback to IOBase readline which uses peek() and read()
            return super().readline(limit)
        if self.length is not None and (limit < 0 or limit > self.length):
            limit = self.length
        result = self.fp.readline(limit)
        if not result and limit:
            self._close_conn()
        elif self.length is not None:
            self.length -= len(result)
        return result

    def _read1_chunked(self, n):
        # Strictly speaking, _get_chunk_left() may cause more than one read,
        # but that is ok, since that is to satisfy the chunked protocol.
        chunk_left = self._get_chunk_left()
        if chunk_left is None or n == 0:
            return b''
        if not (0 <= n <= chunk_left):
            n = chunk_left # if n is negative or larger than chunk_left
        read = self.fp.read1(n)
        self.chunk_left -= len(read)
        if not read:
            raise IncompleteRead(b"")
        return read

    def _peek_chunked(self, n):
        # Strictly speaking, _get_chunk_left() may cause more than one read,
        # but that is ok, since that is to satisfy the chunked protocol.
        try:
            chunk_left = self._get_chunk_left()
        except IncompleteRead:
            return b'' # peek doesn't worry about protocol
        if chunk_left is None:
            return b'' # eof
        # peek is allowed to return more than requested.  Just request the
        # entire chunk, and truncate what we get.
        return self.fp.peek(chunk_left)[:chunk_left]

    def fileno(self):
        return self.fp.fileno()

    def getheader(self, name, default=None):
        if self.headers is None:
            raise ResponseNotReady()
        headers = self.headers.get_all(name) or default
        if isinstance(headers, str) or not hasattr(headers, '__iter__'):
            return headers
        else:
            return ', '.join(headers)

    def getheaders(self):
        """Return list of (header, value) tuples."""
        if self.headers is None:
            raise ResponseNotReady()
        return list(self.headers.items())

    # We override IOBase.__iter__ so that it doesn't check for closed-ness

    def __iter__(self):
        return self

    # For compatibility with old-style urllib responses.

    def info(self):
        return self.headers

    def geturl(self):
        return self.url

    def getcode(self):
        return self.status

class HTTPConnection:

    _http_vsn = 11
    _http_vsn_str = 'HTTP/1.1'

    response_class = HTTPResponse
    default_port = HTTP_PORT
    auto_open = 1
    debuglevel = 0

    def __init__(self, host, port=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
                 source_address=None):
        self.timeout = timeout
        self.source_address = source_address
        self.sock = None
        self._buffer = []
        self.__response = None
        self.__state = _CS_IDLE
        self._method = None
        self._tunnel_host = None
        self._tunnel_port = None
        self._tunnel_headers = {}

        (self.host, self.port) = self._get_hostport(host, port)

        # This is stored as an instance variable to allow unit
        # tests to replace it with a suitable mockup
        self._create_connection = socket.create_connection

    def set_tunnel(self, host, port=None, headers=None):
        """Set up host and port for HTTP CONNECT tunnelling.

        In a connection that uses HTTP CONNECT tunneling, the host passed to the
        constructor is used as a proxy server that relays all communication to
        the endpoint passed to `set_tunnel`. This done by sending an HTTP
        CONNECT request to the proxy server when the connection is established.

        This method must be called before the HTML connection has been
        established.

        The headers argument should be a mapping of extra HTTP headers to send
        with the CONNECT request.
        """

        if self.sock:
            raise RuntimeError("Can't set up tunnel for established connection")

        self._tunnel_host, self._tunnel_port = self._get_hostport(host, port)
        if headers:
            self._tunnel_headers = headers
        else:
            self._tunnel_headers.clear()

    def _get_hostport(self, host, port):
        if port is None:
            i = host.rfind(':')
            j = host.rfind(']')         # ipv6 addresses have [...]
            if i > j:
                try:
                    port = int(host[i+1:])
                except ValueError:
                    if host[i+1:] == "": # http://foo.com:/ == http://foo.com/
                        port = self.default_port
                    else:
                        raise InvalidURL("nonnumeric port: '%s'" % host[i+1:])
                host = host[:i]
            else:
                port = self.default_port
            if host and host[0] == '[' and host[-1] == ']':
                host = host[1:-1]

        return (host, port)

    def set_debuglevel(self, level):
        self.debuglevel = level

    def _tunnel(self):
        connect_str = "CONNECT %s:%d HTTP/1.0\r\n" % (self._tunnel_host,
            self._tunnel_port)
        connect_bytes = connect_str.encode("ascii")
        self.send(connect_bytes)
        for header, value in self._tunnel_headers.items():
            header_str = "%s: %s\r\n" % (header, value)
            header_bytes = header_str.encode("latin-1")
            self.send(header_bytes)
        self.send(b'\r\n')

        response = self.response_class(self.sock, method=self._method)
        (version, code, message) = response._read_status()

        if code != http.HTTPStatus.OK:
            self.close()
            raise OSError("Tunnel connection failed: %d %s" % (code,
                                                               message.strip()))
        while True:
            line = response.fp.readline(_MAXLINE + 1)
            if len(line) > _MAXLINE:
                raise LineTooLong("header line")
            if not line:
                # for sites which EOF without sending a trailer
                break
            if line in (b'\r\n', b'\n', b''):
                break

            if self.debuglevel > 0:
                print('header:', line.decode())

    def connect(self):
        """Connect to the host and port specified in __init__."""
        self.sock = self._create_connection(
            (self.host,self.port), self.timeout, self.source_address)
        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

        if self._tunnel_host:
            self._tunnel()

    def close(self):
        """Close the connection to the HTTP server."""
        self.__state = _CS_IDLE
        try:
            sock = self.sock
            if sock:
                self.sock = None
                sock.close()   # close it manually... there may be other refs
        finally:
            response = self.__response
            if response:
                self.__response = None
                response.close()

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """

        if self.sock is None:
            if self.auto_open:
                self.connect()
            else:
                raise NotConnected()

        if self.debuglevel > 0:
            print("send:", repr(data))
        blocksize = 8192
        if hasattr(data, "read") :
            if self.debuglevel > 0:
                print("sendIng a read()able")
            encode = False
            try:
                mode = data.mode
            except AttributeError:
                # io.BytesIO and other file-like objects don't have a `mode`
                # attribute.
                pass
            else:
                if "b" not in mode:
                    encode = True
                    if self.debuglevel > 0:
                        print("encoding file using iso-8859-1")
            while 1:
                datablock = data.read(blocksize)
                if not datablock:
                    break
                if encode:
                    datablock = datablock.encode("iso-8859-1")
                self.sock.sendall(datablock)
            return
        try:
            self.sock.sendall(data)
        except TypeError:
            if isinstance(data, collections.Iterable):
                for d in data:
                    self.sock.sendall(d)
            else:
                raise TypeError("data should be a bytes-like object "
                                "or an iterable, got %r" % type(data))

    def _output(self, s):
        """Add a line of output to the current request buffer.

        Assumes that the line does *not* end with \\r\\n.
        """
        self._buffer.append(s)

    def _send_output(self, message_body=None):
        """Send the currently buffered request and clear the buffer.

        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]

        self.send(msg)
        if message_body is not None:
            self.send(message_body)

    def putrequest(self, method, url, skip_host=False,
                   skip_accept_encoding=False):
        """Send a request to the server.

        `method' specifies an HTTP request method, e.g. 'GET'.
        `url' specifies the object being requested, e.g. '/index.html'.
        `skip_host' if True does not add automatically a 'Host:' header
        `skip_accept_encoding' if True does not add automatically an
           'Accept-Encoding:' header
        """

        # if a prior response has been completed, then forget about it.
        if self.__response and self.__response.isclosed():
            self.__response = None


        # in certain cases, we cannot issue another request on this connection.
        # this occurs when:
        #   1) we are in the process of sending a request.   (_CS_REQ_STARTED)
        #   2) a response to a previous request has signalled that it is going
        #      to close the connection upon completion.
        #   3) the headers for the previous response have not been read, thus
        #      we cannot determine whether point (2) is true.   (_CS_REQ_SENT)
        #
        # if there is no prior response, then we can request at will.
        #
        # if point (2) is true, then we will have passed the socket to the
        # response (effectively meaning, "there is no prior response"), and
        # will open a new one when a new request is made.
        #
        # Note: if a prior response exists, then we *can* start a new request.
        #       We are not allowed to begin fetching the response to this new
        #       request, however, until that prior response is complete.
        #
        if self.__state == _CS_IDLE:
            self.__state = _CS_REQ_STARTED
        else:
            raise CannotSendRequest(self.__state)

        # Save the method we use, we need it later in the response phase
        self._method = method
        if not url:
            url = '/'
        request = '%s %s %s' % (method, url, self._http_vsn_str)

        # Non-ASCII characters should have been eliminated earlier
        self._output(request.encode('ascii'))

        if self._http_vsn == 11:
            # Issue some standard headers for better HTTP/1.1 compliance

            if not skip_host:
                # this header is issued *only* for HTTP/1.1
                # connections. more specifically, this means it is
                # only issued when the client uses the new
                # HTTPConnection() class. backwards-compat clients
                # will be using HTTP/1.0 and those clients may be
                # issuing this header themselves. we should NOT issue
                # it twice; some web servers (such as Apache) barf
                # when they see two Host: headers

                # If we need a non-standard port,include it in the
                # header.  If the request is going through a proxy,
                # but the host of the actual URL, not the host of the
                # proxy.

                netloc = ''
                if url.startswith('http'):
                    nil, netloc, nil, nil, nil = urlsplit(url)

                if netloc:
                    try:
                        netloc_enc = netloc.encode("ascii")
                    except UnicodeEncodeError:
                        netloc_enc = netloc.encode("idna")
                    self.putheader('Host', netloc_enc)
                else:
                    if self._tunnel_host:
                        host = self._tunnel_host
                        port = self._tunnel_port
                    else:
                        host = self.host
                        port = self.port

                    try:
                        host_enc = host.encode("ascii")
                    except UnicodeEncodeError:
                        host_enc = host.encode("idna")

                    # As per RFC 273, IPv6 address should be wrapped with []
                    # when used as Host header

                    if host.find(':') >= 0:
                        host_enc = b'[' + host_enc + b']'

                    if port == self.default_port:
                        self.putheader('Host', host_enc)
                    else:
                        host_enc = host_enc.decode("ascii")
                        self.putheader('Host', "%s:%s" % (host_enc, port))

            # note: we are assuming that clients will not attempt to set these
            #       headers since *this* library must deal with the
            #       consequences. this also means that when the supporting
            #       libraries are updated to recognize other forms, then this
            #       code should be changed (removed or updated).

            # we only want a Content-Encoding of "identity" since we don't
            # support encodings such as x-gzip or x-deflate.
            if not skip_accept_encoding:
                self.putheader('Accept-Encoding', 'identity')

            # we can accept "chunked" Transfer-Encodings, but no others
            # NOTE: no TE header implies *only* "chunked"
            #self.putheader('TE', 'chunked')

            # if TE is supplied in the header, then it must appear in a
            # Connection header.
            #self.putheader('Connection', 'TE')

        else:
            # For HTTP/1.0, the server will assume "not chunked"
            pass

    def putheader(self, header, *values):
        """Send a request header line to the server.

        For example: h.putheader('Accept', 'text/html')
        """
        if self.__state != _CS_REQ_STARTED:
            raise CannotSendHeader()

        if hasattr(header, 'encode'):
            header = header.encode('ascii')

        if not _is_legal_header_name(header):
            raise ValueError('Invalid header name %r' % (header,))

        values = list(values)
        for i, one_value in enumerate(values):
            if hasattr(one_value, 'encode'):
                values[i] = one_value.encode('latin-1')
            elif isinstance(one_value, int):
                values[i] = str(one_value).encode('ascii')

            if _is_illegal_header_value(values[i]):
                raise ValueError('Invalid header value %r' % (values[i],))

        value = b'\r\n\t'.join(values)
        header = header + b': ' + value
        self._output(header)

    def endheaders(self, message_body=None):
        """Indicate that the last header line has been sent to the server.

        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
        self._send_output(message_body)

    def request(self, method, url, body=None, headers={}):
        """Send a complete request to the server."""
        self._send_request(method, url, body, headers)

    def _set_content_length(self, body, method):
        # Set the content-length based on the body. If the body is "empty", we
        # set Content-Length: 0 for methods that expect a body (RFC 7230,
        # Section 3.3.2). If the body is set for other methods, we set the
        # header provided we can figure out what the length is.
        thelen = None
        method_expects_body = method.upper() in _METHODS_EXPECTING_BODY
        if body is None and method_expects_body:
            thelen = '0'
        elif body is not None:
            try:
                thelen = str(len(body))
            except TypeError:
                # If this is a file-like object, try to
                # fstat its file descriptor
                try:
                    thelen = str(os.fstat(body.fileno()).st_size)
                except (AttributeError, OSError):
                    # Don't send a length if this failed
                    if self.debuglevel > 0: print("Cannot stat!!")

        if thelen is not None:
            self.putheader('Content-Length', thelen)

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1

        self.putrequest(method, url, **skips)

        if 'content-length' not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
        self.endheaders(body)

    def getresponse(self):
        """Get the response from the server.

        If the HTTPConnection is in the correct state, returns an
        instance of HTTPResponse or of whatever object is returned by
        the response_class variable.

        If a request has not been sent or if a previous response has
        not be handled, ResponseNotReady is raised.  If the HTTP
        response indicates that the connection should be closed, then
        it will be closed before the response is returned.  When the
        connection is closed, the underlying socket is closed.
        """

        # if a prior response has been completed, then forget about it.
        if self.__response and self.__response.isclosed():
            self.__response = None

        # if a prior response exists, then it must be completed (otherwise, we
        # cannot read this response's header to determine the connection-close
        # behavior)
        #
        # note: if a prior response existed, but was connection-close, then the
        # socket and response were made independent of this HTTPConnection
        # object since a new request requires that we open a whole new
        # connection
        #
        # this means the prior response had one of two states:
        #   1) will_close: this connection was reset and the prior socket and
        #                  response operate independently
        #   2) persistent: the response was retained and we await its
        #                  isclosed() status to become true.
        #
        if self.__state != _CS_REQ_SENT or self.__response:
            raise ResponseNotReady(self.__state)

        if self.debuglevel > 0:
            response = self.response_class(self.sock, self.debuglevel,
                                           method=self._method)
        else:
            response = self.response_class(self.sock, method=self._method)

        try:
            try:
                response.begin()
            except ConnectionError:
                self.close()
                raise
            assert response.will_close != _UNKNOWN
            self.__state = _CS_IDLE

            if response.will_close:
                # this effectively passes the connection to the response
                self.close()
            else:
                # remember this, so we can tell when it is complete
                self.__response = response

            return response
        except:
            response.close()
            raise

try:
    import ssl
except ImportError:
    pass
else:
    class HTTPSConnection(HTTPConnection):
        "This class allows communication via SSL."

        default_port = HTTPS_PORT

        # XXX Should key_file and cert_file be deprecated in favour of context?

        def __init__(self, host, port=None, key_file=None, cert_file=None,
                     timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
                     source_address=None, *, context=None,
                     check_hostname=None):
            super(HTTPSConnection, self).__init__(host, port, timeout,
                                                  source_address)
            self.key_file = key_file
            self.cert_file = cert_file
            if context is None:
                context = ssl._create_default_https_context()
            will_verify = context.verify_mode != ssl.CERT_NONE
            if check_hostname is None:
                check_hostname = context.check_hostname
            if check_hostname and not will_verify:
                raise ValueError("check_hostname needs a SSL context with "
                                 "either CERT_OPTIONAL or CERT_REQUIRED")
            if key_file or cert_file:
                context.load_cert_chain(cert_file, key_file)
            self._context = context
            self._check_hostname = check_hostname

        def connect(self):
            "Connect to a host on a given (SSL) port."

            super().connect()

            if self._tunnel_host:
                server_hostname = self._tunnel_host
            else:
                server_hostname = self.host

            self.sock = self._context.wrap_socket(self.sock,
                                                  server_hostname=server_hostname)
            if not self._context.check_hostname and self._check_hostname:
                try:
                    ssl.match_hostname(self.sock.getpeercert(), server_hostname)
                except Exception:
                    self.sock.shutdown(socket.SHUT_RDWR)
                    self.sock.close()
                    raise

    __all__.append("HTTPSConnection")

class HTTPException(Exception):
    # Subclasses that define an __init__ must call Exception.__init__
    # or define self.args.  Otherwise, str() will fail.
    pass

class NotConnected(HTTPException):
    pass

class InvalidURL(HTTPException):
    pass

class UnknownProtocol(HTTPException):
    def __init__(self, version):
        self.args = version,
        self.version = version

class UnknownTransferEncoding(HTTPException):
    pass

class UnimplementedFileMode(HTTPException):
    pass

class IncompleteRead(HTTPException):
    def __init__(self, partial, expected=None):
        self.args = partial,
        self.partial = partial
        self.expected = expected
    def __repr__(self):
        if self.expected is not None:
            e = ', %i more expected' % self.expected
        else:
            e = ''
        return '%s(%i bytes read%s)' % (self.__class__.__name__,
                                        len(self.partial), e)
    def __str__(self):
        return repr(self)

class ImproperConnectionState(HTTPException):
    pass

class CannotSendRequest(ImproperConnectionState):
    pass

class CannotSendHeader(ImproperConnectionState):
    pass

class ResponseNotReady(ImproperConnectionState):
    pass

class BadStatusLine(HTTPException):
    def __init__(self, line):
        if not line:
            line = repr(line)
        self.args = line,
        self.line = line

class LineTooLong(HTTPException):
    def __init__(self, line_type):
        HTTPException.__init__(self, "got more than %d bytes when reading %s"
                                     % (_MAXLINE, line_type))

class RemoteDisconnected(ConnectionResetError, BadStatusLine):
    def __init__(self, *pos, **kw):
        BadStatusLine.__init__(self, "")
        ConnectionResetError.__init__(self, *pos, **kw)

# for backwards compatibility
error = HTTPException
                                                                                                                                                                                                                                                                                                                                                                                                                           r"""HTTP cookie handling for web clients.

This module has (now fairly distant) origins in Gisle Aas' Perl module
HTTP::Cookies, from the libwww-perl library.

Docstrings, comments and debug strings in this code refer to the
attributes of the HTTP cookie system as cookie-attributes, to distinguish
them clearly from Python attributes.

Class diagram (note that BSDDBCookieJar and the MSIE* classes are not
distributed with the Python standard library, but are available from
http://wwwsearch.sf.net/):

                        CookieJar____
                        /     \      \
            FileCookieJar      \      \
             /    |   \         \      \
 MozillaCookieJar | LWPCookieJar \      \
                  |               |      \
                  |   ---MSIEBase |       \
                  |  /      |     |        \
                  | /   MSIEDBCookieJar BSDDBCookieJar
                  |/
               MSIECookieJar

"""

__all__ = ['Cookie', 'CookieJar', 'CookiePolicy', 'DefaultCookiePolicy',
           'FileCookieJar', 'LWPCookieJar', 'LoadError', 'MozillaCookieJar']

import copy
import datetime
import re
import time
import urllib.parse, urllib.request
try:
    import threading as _threading
except ImportError:
    import dummy_threading as _threading
import http.client  # only for the default HTTP port
from calendar import timegm

debug = False   # set to True to enable debugging via the logging module
logger = None

def _debug(*args):
    if not debug:
        return
    global logger
    if not logger:
        import logging
        logger = logging.getLogger("http.cookiejar")
    return logger.debug(*args)


DEFAULT_HTTP_PORT = str(http.client.HTTP_PORT)
MISSING_FILENAME_TEXT = ("a filename was not supplied (nor was the CookieJar "
                         "instance initialised with one)")

def _warn_unhandled_exception():
    # There are a few catch-all except: statements in this module, for
    # catching input that's bad in unexpected ways.  Warn if any
    # exceptions are caught there.
    import io, warnings, traceback
    f = io.StringIO()
    traceback.print_exc(None, f)
    msg = f.getvalue()
    warnings.warn("http.cookiejar bug!\n%s" % msg, stacklevel=2)


# Date/time conversion
# -----------------------------------------------------------------------------

EPOCH_YEAR = 1970
def _timegm(tt):
    year, month, mday, hour, min, sec = tt[:6]
    if ((year >= EPOCH_YEAR) and (1 <= month <= 12) and (1 <= mday <= 31) and
        (0 <= hour <= 24) and (0 <= min <= 59) and (0 <= sec <= 61)):
        return timegm(tt)
    else:
        return None

DAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
MONTHS_LOWER = []
for month in MONTHS: MONTHS_LOWER.append(month.lower())

def time2isoz(t=None):
    """Return a string representing time in seconds since epoch, t.

    If the function is called without an argument, it will use the current
    time.

    The format of the returned string is like "YYYY-MM-DD hh:mm:ssZ",
    representing Universal Time (UTC, aka GMT).  An example of this format is:

    1994-11-24 08:49:37Z

    """
    if t is None:
        dt = datetime.datetime.utcnow()
    else:
        dt = datetime.datetime.utcfromtimestamp(t)
    return "%04d-%02d-%02d %02d:%02d:%02dZ" % (
        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)

def time2netscape(t=None):
    """Return a string representing time in seconds since epoch, t.

    If the function is called without an argument, it will use the current
    time.

    The format of the returned string is like this:

    Wed, DD-Mon-YYYY HH:MM:SS GMT

    """
    if t is None:
        dt = datetime.datetime.utcnow()
    else:
        dt = datetime.datetime.utcfromtimestamp(t)
    return "%s, %02d-%s-%04d %02d:%02d:%02d GMT" % (
        DAYS[dt.weekday()], dt.day, MONTHS[dt.month-1],
        dt.year, dt.hour, dt.minute, dt.second)


UTC_ZONES = {"GMT": None, "UTC": None, "UT": None, "Z": None}

TIMEZONE_RE = re.compile(r"^([-+])?(\d\d?):?(\d\d)?$", re.ASCII)
def offset_from_tz_string(tz):
    offset = None
    if tz in UTC_ZONES:
        offset = 0
    else:
        m = TIMEZONE_RE.search(tz)
        if m:
            offset = 3600 * int(m.group(2))
            if m.group(3):
                offset = offset + 60 * int(m.group(3))
            if m.group(1) == '-':
                offset = -offset
    return offset

def _str2time(day, mon, yr, hr, min, sec, tz):
    yr = int(yr)
    if yr > datetime.MAXYEAR:
        return None

    # translate month name to number
    # month numbers start with 1 (January)
    try:
        mon = MONTHS_LOWER.index(mon.lower())+1
    except ValueError:
        # maybe it's already a number
        try:
            imon = int(mon)
        except ValueError:
            return None
        if 1 <= imon <= 12:
            mon = imon
        else:
            return None

    # make sure clock elements are defined
    if hr is None: hr = 0
    if min is None: min = 0
    if sec is None: sec = 0

    day = int(day)
    hr = int(hr)
    min = int(min)
    sec = int(sec)

    if yr < 1000:
        # find "obvious" year
        cur_yr = time.localtime(time.time())[0]
        m = cur_yr % 100
        tmp = yr
        yr = yr + cur_yr - m
        m = m - tmp
        if abs(m) > 50:
            if m > 0: yr = yr + 100
            else: yr = yr - 100

    # convert UTC time tuple to seconds since epoch (not timezone-adjusted)
    t = _timegm((yr, mon, day, hr, min, sec, tz))

    if t is not None:
        # adjust time using timezone string, to get absolute time since epoch
        if tz is None:
            tz = "UTC"
        tz = tz.upper()
        offset = offset_from_tz_string(tz)
        if offset is None:
            return None
        t = t - offset

    return t

STRICT_DATE_RE = re.compile(
    r"^[SMTWF][a-z][a-z], (\d\d) ([JFMASOND][a-z][a-z]) "
    "(\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$", re.ASCII)
WEEKDAY_RE = re.compile(
    r"^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*", re.I | re.ASCII)
LOOSE_HTTP_DATE_RE = re.compile(
    r"""^
    (\d\d?)            # day
       (?:\s+|[-\/])
    (\w+)              # month
        (?:\s+|[-\/])
    (\d+)              # year
    (?:
          (?:\s+|:)    # separator before clock
       (\d\d?):(\d\d)  # hour:min
       (?::(\d\d))?    # optional seconds
    )?                 # optional clock
       \s*
    ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
       \s*
    (?:\(\w+\))?       # ASCII representation of timezone in parens.
       \s*$""", re.X | re.ASCII)
def http2time(text):
    """Returns time in seconds since epoch of time represented by a string.

    Return value is an integer.

    None is returned if the format of str is unrecognized, the time is outside
    the representable range, or the timezone string is not recognized.  If the
    string contains no timezone, UTC is assumed.

    The timezone in the string may be numerical (like "-0800" or "+0100") or a
    string timezone (like "UTC", "GMT", "BST" or "EST").  Currently, only the
    timezone strings equivalent to UTC (zero offset) are known to the function.

    The function loosely parses the following formats:

    Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format
    Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format
    Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format
    09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)
    08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)
    08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)

    The parser ignores leading and trailing whitespace.  The time may be
    absent.

    If the year is given with only 2 digits, the function will select the
    century that makes the year closest to the current date.

    """
    # fast exit for strictly conforming string
    m = STRICT_DATE_RE.search(text)
    if m:
        g = m.groups()
        mon = MONTHS_LOWER.index(g[1].lower()) + 1
        tt = (int(g[2]), mon, int(g[0]),
              int(g[3]), int(g[4]), float(g[5]))
        return _timegm(tt)

    # No, we need some messy parsing...

    # clean up
    text = text.lstrip()
    text = WEEKDAY_RE.sub("", text, 1)  # Useless weekday

    # tz is time zone specifier string
    day, mon, yr, hr, min, sec, tz = [None]*7

    # loose regexp parse
    m = LOOSE_HTTP_DATE_RE.search(text)
    if m is not None:
        day, mon, yr, hr, min, sec, tz = m.groups()
    else:
        return None  # bad format

    return _str2time(day, mon, yr, hr, min, sec, tz)

ISO_DATE_RE = re.compile(
    """^
    (\d{4})              # year
       [-\/]?
    (\d\d?)              # numerical month
       [-\/]?
    (\d\d?)              # day
   (?:
         (?:\s+|[-:Tt])  # separator before clock
      (\d\d?):?(\d\d)    # hour:min
      (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
   )?                    # optional clock
      \s*
   ([-+]?\d\d?:?(:?\d\d)?
    |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
      \s*$""", re.X | re. ASCII)
def iso2time(text):
    """
    As for http2time, but parses the ISO 8601 formats:

    1994-02-03 14:15:29 -0100    -- ISO 8601 format
    1994-02-03 14:15:29          -- zone is optional
    1994-02-03                   -- only date
    1994-02-03T14:15:29          -- Use T as separator
    19940203T141529Z             -- ISO 8601 compact format
    19940203                     -- only date

    """
    # clean up
    text = text.lstrip()

    # tz is time zone specifier string
    day, mon, yr, hr, min, sec, tz = [None]*7

    # loose regexp parse
    m = ISO_DATE_RE.search(text)
    if m is not None:
        # XXX there's an extra bit of the timezone I'm ignoring here: is
        #   this the right thing to do?
        yr, mon, day, hr, min, sec, tz, _ = m.groups()
    else:
        return None  # bad format

    return _str2time(day, mon, yr, hr, min, sec, tz)


# Header parsing
# -----------------------------------------------------------------------------

def unmatched(match):
    """Return unmatched part of re.Match object."""
    start, end = match.span(0)
    return match.string[:start]+match.string[end:]

HEADER_TOKEN_RE =        re.compile(r"^\s*([^=\s;,]+)")
HEADER_QUOTED_VALUE_RE = re.compile(r"^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"")
HEADER_VALUE_RE =        re.compile(r"^\s*=\s*([^\s;,]*)")
HEADER_ESCAPE_RE = re.compile(r"\\(.)")
def split_header_words(header_values):
    r"""Parse header values into a list of lists containing key,value pairs.

    The function knows how to deal with ",", ";" and "=" as well as quoted
    values after "=".  A list of space separated tokens are parsed as if they
    were separated by ";".

    If the header_values passed as argument contains multiple values, then they
    are treated as if they were a single value separated by comma ",".

    This means that this function is useful for parsing header fields that
    follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
    the requirement for tokens).

      headers           = #header
      header            = (token | parameter) *( [";"] (token | parameter))

      token             = 1*<any CHAR except CTLs or separators>
      separators        = "(" | ")" | "<" | ">" | "@"
                        | "," | ";" | ":" | "\" | <">
                        | "/" | "[" | "]" | "?" | "="
                        | "{" | "}" | SP | HT

      quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
      qdtext            = <any TEXT except <">>
      quoted-pair       = "\" CHAR

      parameter         = attribute "=" value
      attribute         = token
      value             = token | quoted-string

    Each header is represented by a list of key/value pairs.  The value for a
    simple token (not part of a parameter) is None.  Syntactically incorrect
    headers will not necessarily be parsed as you would want.

    This is easier to describe with some examples:

    >>> split_header_words(['foo="bar"; port="80,81"; discard, bar=baz'])
    [[('foo', 'bar'), ('port', '80,81'), ('discard', None)], [('bar', 'baz')]]
    >>> split_header_words(['text/html; charset="iso-8859-1"'])
    [[('text/html', None), ('charset', 'iso-8859-1')]]
    >>> split_header_words([r'Basic realm="\"foo\bar\""'])
    [[('Basic', None), ('realm', '"foobar"')]]

    """
    assert not isinstance(header_values, str)
    result = []
    for text in header_values:
        orig_text = text
        pairs = []
        while text:
            m = HEADER_TOKEN_RE.search(text)
            if m:
                text = unmatched(m)
                name = m.group(1)
                m = HEADER_QUOTED_VALUE_RE.search(text)
                if m:  # quoted value
                    text = unmatched(m)
                    value = m.group(1)
                    value = HEADER_ESCAPE_RE.sub(r"\1", value)
                else:
                    m = HEADER_VALUE_RE.search(text)
                    if m:  # unquoted value
                        text = unmatched(m)
                        value = m.group(1)
                        value = value.rstrip()
                    else:
                        # no value, a lone token
                        value = None
                pairs.append((name, value))
            elif text.lstrip().startswith(","):
                # concatenated headers, as per RFC 2616 section 4.2
                text = text.lstrip()[1:]
                if pairs: result.append(pairs)
                pairs = []
            else:
                # skip junk
                non_junk, nr_junk_chars = re.subn("^[=\s;]*", "", text)
                assert nr_junk_chars > 0, (
                    "split_header_words bug: '%s', '%s', %s" %
                    (orig_text, text, pairs))
                text = non_junk
        if pairs: result.append(pairs)
    return result

HEADER_JOIN_ESCAPE_RE = re.compile(r"([\"\\])")
def join_header_words(lists):
    """Do the inverse (almost) of the conversion done by split_header_words.

    Takes a list of lists of (key, value) pairs and produces a single header
    value.  Attribute values are quoted if needed.

    >>> join_header_words([[("text/plain", None), ("charset", "iso-8859-1")]])
    'text/plain; charset="iso-8859-1"'
    >>> join_header_words([[("text/plain", None)], [("charset", "iso-8859-1")]])
    'text/plain, charset="iso-8859-1"'

    """
    headers = []
    for pairs in lists:
        attr = []
        for k, v in pairs:
            if v is not None:
                if not re.search(r"^\w+$", v):
                    v = HEADER_JOIN_ESCAPE_RE.sub(r"\\\1", v)  # escape " and \
                    v = '"%s"' % v
                k = "%s=%s" % (k, v)
            attr.append(k)
        if attr: headers.append("; ".join(attr))
    return ", ".join(headers)

def strip_quotes(text):
    if text.startswith('"'):
        text = text[1:]
    if text.endswith('"'):
        text = text[:-1]
    return text

def parse_ns_headers(ns_headers):
    """Ad-hoc parser for Netscape protocol cookie-attributes.

    The old Netscape cookie format for Set-Cookie can for instance contain
    an unquoted "," in the expires field, so we have to use this ad-hoc
    parser instead of split_header_words.

    XXX This may not make the best possible effort to parse all the crap
    that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient
    parser is probably better, so could do worse than following that if
    this ever gives any trouble.

    Currently, this is also used for parsing RFC 2109 cookies.

    """
    known_attrs = ("expires", "domain", "path", "secure",
                   # RFC 2109 attrs (may turn up in Netscape cookies, too)
                   "version", "port", "max-age")

    result = []
    for ns_header in ns_headers:
        pairs = []
        version_set = False

        # XXX: The following does not strictly adhere to RFCs in that empty
        # names and values are legal (the former will only appear once and will
        # be overwritten if multiple occurrences are present). This is
        # mostly to deal with backwards compatibility.
        for ii, param in enumerate(ns_header.split(';')):
            param = param.strip()

            key, sep, val = param.partition('=')
            key = key.strip()

            if not key:
                if ii == 0:
                    break
                else:
                    continue

            # allow for a distinction between present and empty and missing
            # altogether
            val = val.strip() if sep else None

            if ii != 0:
                lc = key.lower()
                if lc in known_attrs:
                    key = lc

                if key == "version":
                    # This is an RFC 2109 cookie.
                    if val is not None:
                        val = strip_quotes(val)
                    version_set = True
                elif key == "expires":
                    # convert expires date to seconds since epoch
                    if val is not None:
                        val = http2time(strip_quotes(val))  # None if invalid
            pairs.append((key, val))

        if pairs:
            if not version_set:
                pairs.append(("version", "0"))
            result.append(pairs)

    return result


IPV4_RE = re.compile(r"\.\d+$", re.ASCII)
def is_HDN(text):
    """Return True if text is a host domain name."""
    # XXX
    # This may well be wrong.  Which RFC is HDN defined in, if any (for
    #  the purposes of RFC 2965)?
    # For the current implementation, what about IPv6?  Remember to look
    #  at other uses of IPV4_RE also, if change this.
    if IPV4_RE.search(text):
        return False
    if text == "":
        return False
    if text[0] == "." or text[-1] == ".":
        return False
    return True

def domain_match(A, B):
    """Return True if domain A domain-matches domain B, according to RFC 2965.

    A and B may be host domain names or IP addresses.

    RFC 2965, section 1:

    Host names can be specified either as an IP address or a HDN string.
    Sometimes we compare one host name with another.  (Such comparisons SHALL
    be case-insensitive.)  Host A's name domain-matches host B's if

         *  their host name strings string-compare equal; or

         * A is a HDN string and has the form NB, where N is a non-empty
            name string, B has the form .B', and B' is a HDN string.  (So,
            x.y.com domain-matches .Y.com but not Y.com.)

    Note that domain-match is not a commutative operation: a.b.c.com
    domain-matches .c.com, but not the reverse.

    """
    # Note that, if A or B are IP addresses, the only relevant part of the
    # definition of the domain-match algorithm is the direct string-compare.
    A = A.lower()
    B = B.lower()
    if A == B:
        return True
    if not is_HDN(A):
        return False
    i = A.rfind(B)
    if i == -1 or i == 0:
        # A does not have form NB, or N is the empty string
        return False
    if not B.startswith("."):
        return False
    if not is_HDN(B[1:]):
        return False
    return True

def liberal_is_HDN(text):
    """Return True if text is a sort-of-like a host domain name.

    For accepting/blocking domains.

    """
    if IPV4_RE.search(text):
        return False
    return True

def user_domain_match(A, B):
    """For blocking/accepting domains.

    A and B may be host domain names or IP addresses.

    """
    A = A.lower()
    B = B.lower()
    if not (liberal_is_HDN(A) and liberal_is_HDN(B)):
        if A == B:
            # equal IP addresses
            return True
        return False
    initial_dot = B.startswith(".")
    if initial_dot and A.endswith(B):
        return True
    if not initial_dot and A == B:
        return True
    return False

cut_port_re = re.compile(r":\d+$", re.ASCII)
def request_host(request):
    """Return request-host, as defined by RFC 2965.

    Variation from RFC: returned value is lowercased, for convenient
    comparison.

    """
    url = request.get_full_url()
    host = urllib.parse.urlparse(url)[1]
    if host == "":
        host = request.get_header("Host", "")

    # remove port, if present
    host = cut_port_re.sub("", host, 1)
    return host.lower()

def eff_request_host(request):
    """Return a tuple (request-host, effective request-host name).

    As defined by RFC 2965, except both are lowercased.

    """
    erhn = req_host = request_host(request)
    if req_host.find(".") == -1 and not IPV4_RE.search(req_host):
        erhn = req_host + ".local"
    return req_host, erhn

def request_path(request):
    """Path component of request-URI, as defined by RFC 2965."""
    url = request.get_full_url()
    parts = urllib.parse.urlsplit(url)
    path = escape_path(parts.path)
    if not path.startswith("/"):
        # fix bad RFC 2396 absoluteURI
        path = "/" + path
    return path

def request_port(request):
    host = request.host
    i = host.find(':')
    if i >= 0:
        port = host[i+1:]
        try:
            int(port)
        except ValueError:
            _debug("nonnumeric port: '%s'", port)
            return None
    else:
        port = DEFAULT_HTTP_PORT
    return port

# Characters in addition to A-Z, a-z, 0-9, '_', '.', and '-' that don't
# need to be escaped to form a valid HTTP URL (RFCs 2396 and 1738).
HTTP_PATH_SAFE = "%/;:@&=+$,!~*'()"
ESCAPED_CHAR_RE = re.compile(r"%([0-9a-fA-F][0-9a-fA-F])")
def uppercase_escaped_char(match):
    return "%%%s" % match.group(1).upper()
def escape_path(path):
    """Escape any invalid characters in HTTP URL, and uppercase all escapes."""
    # There's no knowing what character encoding was used to create URLs
    # containing %-escapes, but since we have to pick one to escape invalid
    # path characters, we pick UTF-8, as recommended in the HTML 4.0
    # specification:
    # http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1
    # And here, kind of: draft-fielding-uri-rfc2396bis-03
    # (And in draft IRI specification: draft-duerst-iri-05)
    # (And here, for new URI schemes: RFC 2718)
    path = urllib.parse.quote(path, HTTP_PATH_SAFE)
    path = ESCAPED_CHAR_RE.sub(uppercase_escaped_char, path)
    return path

def reach(h):
    """Return reach of host h, as defined by RFC 2965, section 1.

    The reach R of a host name H is defined as follows:

       *  If

          -  H is the host domain name of a host; and,

          -  H has the form A.B; and

          -  A has no embedded (that is, interior) dots; and

          -  B has at least one embedded dot, or B is the string "local".
             then the reach of H is .B.

       *  Otherwise, the reach of H is H.

    >>> reach("www.acme.com")
    '.acme.com'
    >>> reach("acme.com")
    'acme.com'
    >>> reach("acme.local")
    '.local'

    """
    i = h.find(".")
    if i >= 0:
        #a = h[:i]  # this line is only here to show what a is
        b = h[i+1:]
        i = b.find(".")
        if is_HDN(h) and (i >= 0 or b == "local"):
            return "."+b
    return h

def is_third_party(request):
    """

    RFC 2965, section 3.3.6:

        An unverifiable transaction is to a third-party host if its request-
        host U does not domain-match the reach R of the request-host O in the
        origin transaction.

    """
    req_host = request_host(request)
    if not domain_match(req_host, reach(request.origin_req_host)):
        return True
    else:
        return False


class Cookie:
    """HTTP Cookie.

    This class represents both Netscape and RFC 2965 cookies.

    This is deliberately a very simple class.  It just holds attributes.  It's
    possible to construct Cookie instances that don't comply with the cookie
    standards.  CookieJar.make_cookies is the factory function for Cookie
    objects -- it deals with cookie parsing, supplying defaults, and
    normalising to the representation used in this class.  CookiePolicy is
    responsible for checking them to see whether they should be accepted from
    and returned to the server.

    Note that the port may be present in the headers, but unspecified ("Port"
    rather than"Port=80", for example); if this is the case, port is None.

    """

    def __init__(self, version, name, value,
                 port, port_specified,
                 domain, domain_specified, domain_initial_dot,
                 path, path_specified,
                 secure,
                 expires,
                 discard,
                 comment,
                 comment_url,
                 rest,
                 rfc2109=False,
                 ):

        if version is not None: version = int(version)
        if expires is not None: expires = int(float(expires))
        if port is None and port_specified is True:
            raise ValueError("if port is None, port_specified must be false")

        self.version = version
        self.name = name
        self.value = value
        self.port = port
        self.port_specified = port_specified
        # normalise case, as per RFC 2965 section 3.3.3
        self.domain = domain.lower()
        self.domain_specified = domain_specified
        # Sigh.  We need to know whether the domain given in the
        # cookie-attribute had an initial dot, in order to follow RFC 2965
        # (as clarified in draft errata).  Needed for the returned $Domain
        # value.
        self.domain_initial_dot = domain_initial_dot
        self.path = path
        self.path_specified = path_specified
        self.secure = secure
        self.expires = expires
        self.discard = discard
        self.comment = comment
        self.comment_url = comment_url
        self.rfc2109 = rfc2109

        self._rest = copy.copy(rest)

    def has_nonstandard_attr(self, name):
        return name in self._rest
    def get_nonstandard_attr(self, name, default=None):
        return self._rest.get(name, default)
    def set_nonstandard_attr(self, name, value):
        self._rest[name] = value

    def is_expired(self, now=None):
        if now is None: now = time.time()
        if (self.expires is not None) and (self.expires <= now):
            return True
        return False

    def __str__(self):
        if self.port is None: p = ""
        else: p = ":"+self.port
        limit = self.domain + p + self.path
        if self.value is not None:
            namevalue = "%s=%s" % (self.name, self.value)
        else:
            namevalue = self.name
        return "<Cookie %s for %s>" % (namevalue, limit)

    def __repr__(self):
        args = []
        for name in ("version", "name", "value",
                     "port", "port_specified",
                     "domain", "domain_specified", "domain_initial_dot",
                     "path", "path_specified",
                     "secure", "expires", "discard", "comment", "comment_url",
                     ):
            attr = getattr(self, name)
            args.append("%s=%s" % (name, repr(attr)))
        args.append("rest=%s" % repr(self._rest))
        args.append("rfc2109=%s" % repr(self.rfc2109))
        return "%s(%s)" % (self.__class__.__name__, ", ".join(args))


class CookiePolicy:
    """Defines which cookies get accepted from and returned to server.

    May also modify cookies, though this is probably a bad idea.

    The subclass DefaultCookiePolicy defines the standard rules for Netscape
    and RFC 2965 cookies -- override that if you want a customized policy.

    """
    def set_ok(self, cookie, request):
        """Return true if (and only if) cookie should be accepted from server.

        Currently, pre-expired cookies never get this far -- the CookieJar
        class deletes such cookies itself.

        """
        raise NotImplementedError()

    def return_ok(self, cookie, request):
        """Return true if (and only if) cookie should be returned to server."""
        raise NotImplementedError()

    def domain_return_ok(self, domain, request):
        """Return false if cookies should not be returned, given cookie domain.
        """
        return True

    def path_return_ok(self, path, request):
        """Return false if cookies should not be returned, given cookie path.
        """
        return True


class DefaultCookiePolicy(CookiePolicy):
    """Implements the standard rules for accepting and returning cookies."""

    DomainStrictNoDots = 1
    DomainStrictNonDomain = 2
    DomainRFC2965Match = 4

    DomainLiberal = 0
    DomainStrict = DomainStrictNoDots|DomainStrictNonDomain

    def __init__(self,
                 blocked_domains=None, allowed_domains=None,
                 netscape=True, rfc2965=False,
                 rfc2109_as_netscape=None,
                 hide_cookie2=False,
                 strict_domain=False,
                 strict_rfc2965_unverifiable=True,
                 strict_ns_unverifiable=False,
                 strict_ns_domain=DomainLiberal,
                 strict_ns_set_initial_dollar=False,
                 strict_ns_set_path=False,
                 ):
        """Constructor arguments should be passed as keyword arguments only."""
        self.netscape = netscape
        self.rfc2965 = rfc2965
        self.rfc2109_as_netscape = rfc2109_as_netscape
        self.hide_cookie2 = hide_cookie2
        self.strict_domain = strict_domain
        self.strict_rfc2965_unverifiable = strict_rfc2965_unverifiable
        self.strict_ns_unverifiable = strict_ns_unverifiable
        self.strict_ns_domain = strict_ns_domain
        self.strict_ns_set_initial_dollar = strict_ns_set_initial_dollar
        self.strict_ns_set_path = strict_ns_set_path

        if blocked_domains is not None:
            self._blocked_domains = tuple(blocked_domains)
        else:
            self._blocked_domains = ()

        if allowed_domains is not None:
            allowed_domains = tuple(allowed_domains)
        self._allowed_domains = allowed_domains

    def blocked_domains(self):
        """Return the sequence of blocked domains (as a tuple)."""
        return self._blocked_domains
    def set_blocked_domains(self, blocked_domains):
        """Set the sequence of blocked domains."""
        self._blocked_domains = tuple(blocked_domains)

    def is_blocked(self, domain):
        for blocked_domain in self._blocked_domains:
            if user_domain_match(domain, blocked_domain):
                return True
        return False

    def allowed_domains(self):
        """Return None, or the sequence of allowed domains (as a tuple)."""
        return self._allowed_domains
    def set_allowed_domains(self, allowed_domains):
        """Set the sequence of allowed domains, or None."""
        if allowed_domains is not None:
            allowed_domains = tuple(allowed_domains)
        self._allowed_domains = allowed_domains

    def is_not_allowed(self, domain):
        if self._allowed_domains is None:
            return False
        for allowed_domain in self._allowed_domains:
            if user_domain_match(domain, allowed_domain):
                return False
        return True

    def set_ok(self, cookie, request):
        """
        If you override .set_ok(), be sure to call this method.  If it returns
        false, so should your subclass (assuming your subclass wants to be more
        strict about which cookies to accept).

        """
        _debug(" - checking cookie %s=%s", cookie.name, cookie.value)

        assert cookie.name is not None

        for n in "version", "verifiability", "name", "path", "domain", "port":
            fn_name = "set_ok_"+n
            fn = getattr(self, fn_name)
            if not fn(cookie, request):
                return False

        return True

    def set_ok_version(self, cookie, request):
        if cookie.version is None:
            # Version is always set to 0 by parse_ns_headers if it's a Netscape
            # cookie, so this must be an invalid RFC 2965 cookie.
            _debug("   Set-Cookie2 without version attribute (%s=%s)",
                   cookie.name, cookie.value)
            return False
        if cookie.version > 0 and not self.rfc2965:
            _debug("   RFC 2965 cookies are switched off")
            return False
        elif cookie.version == 0 and not self.netscape:
            _debug("   Netscape cookies are switched off")
            return False
        return True

    def set_ok_verifiability(self, cookie, request):
        if request.unverifiable and is_third_party(request):
            if cookie.version > 0 and self.strict_rfc2965_unverifiable:
                _debug("   third-party RFC 2965 cookie during "
                             "unverifiable transaction")
                return False
            elif cookie.version == 0 and self.strict_ns_unverifiable:
                _debug("   third-party Netscape cookie during "
                             "unverifiable transaction")
                return False
        return True

    def set_ok_name(self, cookie, request):
        # Try and stop servers setting V0 cookies designed to hack other
        # servers that know both V0 and V1 protocols.
        if (cookie.version == 0 and self.strict_ns_set_initial_dollar and
            cookie.name.startswith("$")):
            _debug("   illegal name (starts with '$'): '%s'", cookie.name)
            return False
        return True

    def set_ok_path(self, cookie, request):
        if cookie.path_specified:
            req_path = request_path(request)
            if ((cookie.version > 0 or
                 (cookie.version == 0 and self.strict_ns_set_path)) and
                not req_path.startswith(cookie.path)):
                _debug("   path attribute %s is not a prefix of request "
                       "path %s", cookie.path, req_path)
                return False
        return True

    def set_ok_domain(self, cookie, request):
        if self.is_blocked(cookie.domain):
            _debug("   domain %s is in user block-list", cookie.domain)
            return False
        if self.is_not_allowed(cookie.domain):
            _debug("   domain %s is not in user allow-list", cookie.domain)
            return False
        if cookie.domain_specified:
            req_host, erhn = eff_request_host(request)
            domain = cookie.domain
            if self.strict_domain and (domain.count(".") >= 2):
                # XXX This should probably be compared with the Konqueror
                # (kcookiejar.cpp) and Mozilla implementations, but it's a
                # losing battle.
                i = domain.rfind(".")
                j = domain.rfind(".", 0, i)
                if j == 0:  # domain like .foo.bar
                    tld = domain[i+1:]
                    sld = domain[j+1:i]
                    if sld.lower() in ("co", "ac", "com", "edu", "org", "net",
                       "gov", "mil", "int", "aero", "biz", "cat", "coop",
                       "info", "jobs", "mobi", "museum", "name", "pro",
                       "travel", "eu") and len(tld) == 2:
                        # domain like .co.uk
                        _debug("   country-code second level domain %s", domain)
                        return False
            if domain.startswith("."):
                undotted_domain = domain[1:]
            else:
                undotted_domain = domain
            embedded_dots = (undotted_domain.find(".") >= 0)
            if not embedded_dots and domain != ".local":
                _debug("   non-local domain %s contains no embedded dot",
                       domain)
                return False
            if cookie.version == 0:
                if (not erhn.endswith(domain) and
                    (not erhn.startswith(".") and
                     not ("."+erhn).endswith(domain))):
                    _debug("   effective request-host %s (even with added "
                           "initial dot) does not end with %s",
                           erhn, domain)
                    return False
            if (cookie.version > 0 or
                (self.strict_ns_domain & self.DomainRFC2965Match)):
                if not domain_match(erhn, domain):
                    _debug("   effective request-host %s does not domain-match "
                           "%s", erhn, domain)
                    return False
            if (cookie.version > 0 or
                (self.strict_ns_domain & self.DomainStrictNoDots)):
                host_prefix = req_host[:-len(domain)]
                if (host_prefix.find(".") >= 0 and
                    not IPV4_RE.search(req_host)):
                    _debug("   host prefix %s for domain %s contains a dot",
                           host_prefix, domain)
                    return False
        return True

    def set_ok_port(self, cookie, request):
        if cookie.port_specified:
            req_port = request_port(request)
            if req_port is None:
                req_port = "80"
            else:
                req_port = str(req_port)
            for p in cookie.port.split(","):
                try:
                    int(p)
                except ValueError:
                    _debug("   bad port %s (not numeric)", p)
                    return False
                if p == req_port:
                    break
            else:
                _debug("   request port (%s) not found in %s",
                       req_port, cookie.port)
                return False
        return True

    def return_ok(self, cookie, request):
        """
        If you override .return_ok(), be sure to call this method.  If it
        returns false, so should your subclass (assuming your subclass wants to
        be more strict about which cookies to return).

        """
        # Path has already been checked by .path_return_ok(), and domain
        # blocking done by .domain_return_ok().
        _debug(" - checking cookie %s=%s", cookie.name, cookie.value)

        for n in "version", "verifiability", "secure", "expires", "port", "domain":
            fn_name = "return_ok_"+n
            fn = getattr(self, fn_name)
            if not fn(cookie, request):
                return False
        return True

    def return_ok_version(self, cookie, request):
        if cookie.version > 0 and not self.rfc2965:
            _debug("   RFC 2965 cookies are switched off")
            return False
        elif cookie.version == 0 and not self.netscape:
            _debug("   Netscape cookies are switched off")
            return False
        return True

    def return_ok_verifiability(self, cookie, request):
        if request.unverifiable and is_third_party(request):
            if cookie.version > 0 and self.strict_rfc2965_unverifiable:
                _debug("   third-party RFC 2965 cookie during unverifiable "
                       "transaction")
                return False
            elif cookie.version == 0 and self.strict_ns_unverifiable:
                _debug("   third-party Netscape cookie during unverifiable "
                       "transaction")
                return False
        return True

    def return_ok_secure(self, cookie, request):
        if cookie.secure and request.type != "https":
            _debug("   secure cookie with non-secure request")
            return False
        return True

    def return_ok_expires(self, cookie, request):
        if cookie.is_expired(self._now):
            _debug("   cookie expired")
            return False
        return True

    def return_ok_port(self, cookie, request):
        if cookie.port:
            req_port = request_port(request)
            if req_port is None:
                req_port = "80"
            for p in cookie.port.split(","):
                if p == req_port:
                    break
            else:
                _debug("   request port %s does not match cookie port %s",
                       req_port, cookie.port)
                return False
        return True

    def return_ok_domain(self, cookie, request):
        req_host, erhn = eff_request_host(request)
        domain = cookie.domain

        # strict check of non-domain cookies: Mozilla does this, MSIE5 doesn't
        if (cookie.version == 0 and
            (self.strict_ns_domain & self.DomainStrictNonDomain) and
            not cookie.domain_specified and domain != erhn):
            _debug("   cookie with unspecified domain does not string-compare "
                   "equal to request domain")
            return False

        if cookie.version > 0 and not domain_match(erhn, domain):
            _debug("   effective request-host name %s does not domain-match "
                   "RFC 2965 cookie domain %s", erhn, domain)
            return False
        if cookie.version == 0 and not ("."+erhn).endswith(domain):
            _debug("   request-host %s does not match Netscape cookie domain "
                   "%s", req_host, domain)
            return False
        return True

    def domain_return_ok(self, domain, request):
        # Liberal check of.  This is here as an optimization to avoid
        # having to load lots of MSIE cookie files unless necessary.
        req_host, erhn = eff_request_host(request)
        if not req_host.startswith("."):
            req_host = "."+req_host
        if not erhn.startswith("."):
            erhn = "."+erhn
        if not (req_host.endswith(domain) or erhn.endswith(domain)):
            #_debug("   request domain %s does not match cookie domain %s",
            #       req_host, domain)
            return False

        if self.is_blocked(domain):
            _debug("   domain %s is in user block-list", domain)
            return False
        if self.is_not_allowed(domain):
            _debug("   domain %s is not in user allow-list", domain)
            return False

        return True

    def path_return_ok(self, path, request):
        _debug("- checking cookie path=%s", path)
        req_path = request_path(request)
        if not req_path.startswith(path):
            _debug("  %s does not path-match %s", req_path, path)
            return False
        return True


def vals_sorted_by_key(adict):
    keys = sorted(adict.keys())
    return map(adict.get, keys)

def deepvalues(mapping):
    """Iterates over nested mapping, depth-first, in sorted order by key."""
    values = vals_sorted_by_key(mapping)
    for obj in values:
        mapping = False
        try:
            obj.items
        except AttributeError:
            pass
        else:
            mapping = True
            yield from deepvalues(obj)
        if not mapping:
            yield obj


# Used as second parameter to dict.get() method, to distinguish absent
# dict key from one with a None value.
class Absent: pass

class CookieJar:
    """Collection of HTTP cookies.

    You may not need to know about this class: try
    urllib.request.build_opener(HTTPCookieProcessor).open(url).
    """

    non_word_re = re.compile(r"\W")
    quote_re = re.compile(r"([\"\\])")
    strict_domain_re = re.compile(r"\.?[^.]*")
    domain_re = re.compile(r"[^.]*")
    dots_re = re.compile(r"^\.+")

    magic_re = re.compile(r"^\#LWP-Cookies-(\d+\.\d+)", re.ASCII)

    def __init__(self, policy=None):
        if policy is None:
            policy = DefaultCookiePolicy()
        self._policy = policy

        self._cookies_lock = _threading.RLock()
        self._cookies = {}

    def set_policy(self, policy):
        self._policy = policy

    def _cookies_for_domain(self, domain, request):
        cookies = []
        if not self._policy.domain_return_ok(domain, request):
            return []
        _debug("Checking %s for cookies to return", domain)
        cookies_by_path = self._cookies[domain]
        for path in cookies_by_path.keys():
            if not self._policy.path_return_ok(path, request):
                continue
            cookies_by_name = cookies_by_path[path]
            for cookie in cookies_by_name.values():
                if not self._policy.return_ok(cookie, request):
                    _debug("   not returning cookie")
                    continue
                _debug("   it's a match")
                cookies.append(cookie)
        return cookies

    def _cookies_for_request(self, request):
        """Return a list of cookies to be returned to server."""
        cookies = []
        for domain in self._cookies.keys():
            cookies.extend(self._cookies_for_domain(domain, request))
        return cookies

    def _cookie_attrs(self, cookies):
        """Return a list of cookie-attributes to be returned to server.

        like ['foo="bar"; $Path="/"', ...]

        The $Version attribute is also added when appropriate (currently only
        once per request).

        """
        # add cookies in order of most specific (ie. longest) path first
        cookies.sort(key=lambda a: len(a.path), reverse=True)

        version_set = False

        attrs = []
        for cookie in cookies:
            # set version of Cookie header
            # XXX
            # What should it be if multiple matching Set-Cookie headers have
            #  different versions themselves?
            # Answer: there is no answer; was supposed to be settled by
            #  RFC 2965 errata, but that may never appear...
            version = cookie.version
            if not version_set:
                version_set = True
                if version > 0:
                    attrs.append("$Version=%s" % version)

            # quote cookie value if necessary
            # (not for Netscape protocol, which already has any quotes
            #  intact, due to the poorly-specified Netscape Cookie: syntax)
            if ((cookie.value is not None) and
                self.non_word_re.search(cookie.value) and version > 0):
                value = self.quote_re.sub(r"\\\1", cookie.value)
            else:
                value = cookie.value

            # add cookie-attributes to be returned in Cookie header
            if cookie.value is None:
                attrs.append(cookie.name)
            else:
                attrs.append("%s=%s" % (cookie.name, value))
            if version > 0:
                if cookie.path_specified:
                    attrs.append('$Path="%s"' % cookie.path)
                if cookie.domain.startswith("."):
                    domain = cookie.domain
                    if (not cookie.domain_initial_dot and
                        domain.startswith(".")):
                        domain = domain[1:]
                    attrs.append('$Domain="%s"' % domain)
                if cookie.port is not None:
                    p = "$Port"
                    if cookie.port_specified:
                        p = p + ('="%s"' % cookie.port)
                    attrs.append(p)

        return attrs

    def add_cookie_header(self, request):
        """Add correct Cookie: header to request (urllib.request.Request object).

        The Cookie2 header is also added unless policy.hide_cookie2 is true.

        """
        _debug("add_cookie_header")
        self._cookies_lock.acquire()
        try:

            self._policy._now = self._now = int(time.time())

            cookies = self._cookies_for_request(request)

            attrs = self._cookie_attrs(cookies)
            if attrs:
                if not request.has_header("Cookie"):
                    request.add_unredirected_header(
                        "Cookie", "; ".join(attrs))

            # if necessary, advertise that we know RFC 2965
            if (self._policy.rfc2965 and not self._policy.hide_cookie2 and
                not request.has_header("Cookie2")):
                for cookie in cookies:
                    if cookie.version != 1:
                        request.add_unredirected_header("Cookie2", '$Version="1"')
                        break

        finally:
            self._cookies_lock.release()

        self.clear_expired_cookies()

    def _normalized_cookie_tuples(self, attrs_set):
        """Return list of tuples containing normalised cookie information.

        attrs_set is the list of lists of key,value pairs extracted from
        the Set-Cookie or Set-Cookie2 headers.

        Tuples are name, value, standard, rest, where name and value are the
        cookie name and value, standard is a dictionary containing the standard
        cookie-attributes (discard, secure, version, expires or max-age,
        domain, path and port) and rest is a dictionary containing the rest of
        the cookie-attributes.

        """
        cookie_tuples = []

        boolean_attrs = "discard", "secure"
        value_attrs = ("version",
                       "expires", "max-age",
                       "domain", "path", "port",
                       "comment", "commenturl")

        for cookie_attrs in attrs_set:
            name, value = cookie_attrs[0]

            # Build dictionary of standard cookie-attributes (standard) and
            # dictionary of other cookie-attributes (rest).

            # Note: expiry time is normalised to seconds since epoch.  V0
            # cookies should have the Expires cookie-attribute, and V1 cookies
            # should have Max-Age, but since V1 includes RFC 2109 cookies (and
            # since V0 cookies may be a mish-mash of Netscape and RFC 2109), we
            # accept either (but prefer Max-Age).
            max_age_set = False

            bad_cookie = False

            standard = {}
            rest = {}
            for k, v in cookie_attrs[1:]:
                lc = k.lower()
                # don't lose case distinction for unknown fields
                if lc in value_attrs or lc in boolean_attrs:
                    k = lc
                if k in boolean_attrs and v is None:
                    # boolean cookie-attribute is present, but has no value
                    # (like "discard", rather than "port=80")
                    v = True
                if k in standard:
                    # only first value is significant
                    continue
                if k == "domain":
                    if v is None:
                        _debug("   missing value for domain attribute")
                        bad_cookie = True
                        break
                    # RFC 2965 section 3.3.3
                    v = v.lower()
                if k == "expires":
                    if max_age_set:
                        # Prefer max-age to expires (like Mozilla)
                        continue
                    if v is None:
                        _debug("   missing or invalid value for expires "
                              "attribute: treating as session cookie")
                        continue
                if k == "max-age":
                    max_age_set = True
                    try:
                        v = int(v)
                    except ValueError:
                        _debug("   missing or invalid (non-numeric) value for "
                              "max-age attribute")
                        bad_cookie = True
                        break
                    # convert RFC 2965 Max-Age to seconds since epoch
                    # XXX Strictly you're supposed to follow RFC 2616
                    #   age-calculation rules.  Remember that zero Max-Age
                    #   is a request to discard (old and new) cookie, though.
                    k = "expires"
                    v = self._now + v
                if (k in value_attrs) or (k in boolean_attrs):
                    if (v is None and
                        k not in ("port", "comment", "commenturl")):
                        _debug("   missing value for %s attribute" % k)
                        bad_cookie = True
                        break
                    standard[k] = v
                else:
                    rest[k] = v

            if bad_cookie:
                continue

            cookie_tuples.append((name, value, standard, rest))

        return cookie_tuples

    def _cookie_from_cookie_tuple(self, tup, request):
        # standard is dict of standard cookie-attributes, rest is dict of the
        # rest of them
        name, value, standard, rest = tup

        domain = standard.get("domain", Absent)
        path = standard.get("path", Absent)
        port = standard.get("port", Absent)
        expires = standard.get("expires", Absent)

        # set the easy defaults
        version = standard.get("version", None)
        if version is not None:
            try:
                version = int(version)
            except ValueError:
                return None  # invalid version, ignore cookie
        secure = standard.get("secure", False)
        # (discard is also set if expires is Absent)
        discard = standard.get("discard", False)
        comment = standard.get("comment", None)
        comment_url = standard.get("commenturl", None)

        # set default path
        if path is not Absent and path != "":
            path_specified = True
            path = escape_path(path)
        else:
            path_specified = False
            path = request_path(request)
            i = path.rfind("/")
            if i != -1:
                if version == 0:
                    # Netscape spec parts company from reality here
                    path = path[:i]
                else:
                    path = path[:i+1]
            if len(path) == 0: path = "/"

        # set default domain
        domain_specified = domain is not Absent
        # but first we have to remember whether it starts with a dot
        domain_initial_dot = False
        if domain_specified:
            domain_initial_dot = bool(domain.startswith("."))
        if domain is Absent:
            req_host, erhn = eff_request_host(request)
            domain = erhn
        elif not domain.startswith("."):
            domain = "."+domain

        # set default port
        port_specified = False
        if port is not Absent:
            if port is None:
                # Port attr present, but has no value: default to request port.
                # Cookie should then only be sent back on that port.
                port = request_port(request)
            else:
                port_specified = True
                port = re.sub(r"\s+", "", port)
        else:
            # No port attr present.  Cookie can be sent back on any port.
            port = None

        # set default expires and discard
        if expires is Absent:
            expires = None
            discard = True
        elif expires <= self._now:
            # Expiry date in past is request to delete cookie.  This can't be
            # in DefaultCookiePolicy, because can't delete cookies there.
            try:
                self.clear(domain, path, name)
            except KeyError:
                pass
            _debug("Expiring cookie, domain='%s', path='%s', name='%s'",
                   domain, path, name)
            return None

        return Cookie(version,
                      name, value,
                      port, port_specified,
                      domain, domain_specified, domain_initial_dot,
                      path, path_specified,
                      secure,
                      expires,
                      discard,
                      comment,
                      comment_url,
                      rest)

    def _cookies_from_attrs_set(self, attrs_set, request):
        cookie_tuples = self._normalized_cookie_tuples(attrs_set)

        cookies = []
        for tup in cookie_tuples:
            cookie = self._cookie_from_cookie_tuple(tup, request)
            if cookie: cookies.append(cookie)
        return cookies

    def _process_rfc2109_cookies(self, cookies):
        rfc2109_as_ns = getattr(self._policy, 'rfc2109_as_netscape', None)
        if rfc2109_as_ns is None:
            rfc2109_as_ns = not self._policy.rfc2965
        for cookie in cookies:
            if cookie.version == 1:
                cookie.rfc2109 = True
                if rfc2109_as_ns:
                    # treat 2109 cookies as Netscape cookies rather than
                    # as RFC2965 cookies
                    cookie.version = 0

    def make_cookies(self, response, request):
        """Return sequence of Cookie objects extracted from response object."""
        # get cookie-attributes for RFC 2965 and Netscape protocols
        headers = response.info()
        rfc2965_hdrs = headers.get_all("Set-Cookie2", [])
        ns_hdrs = headers.get_all("Set-Cookie", [])

        rfc2965 = self._policy.rfc2965
        netscape = self._policy.netscape

        if ((not rfc2965_hdrs and not ns_hdrs) or
            (not ns_hdrs and not rfc2965) or
            (not rfc2965_hdrs and not netscape) or
            (not netscape and not rfc2965)):
            return []  # no relevant cookie headers: quick exit

        try:
            cookies = self._cookies_from_attrs_set(
                split_header_words(rfc2965_hdrs), request)
        except Exception:
            _warn_unhandled_exception()
            cookies = []

        if ns_hdrs and netscape:
            try:
                # RFC 2109 and Netscape cookies
                ns_cookies = self._cookies_from_attrs_set(
                    parse_ns_headers(ns_hdrs), request)
            except Exception:
                _warn_unhandled_exception()
                ns_cookies = []
            self._process_rfc2109_cookies(ns_cookies)

            # Look for Netscape cookies (from Set-Cookie headers) that match
            # corresponding RFC 2965 cookies (from Set-Cookie2 headers).
            # For each match, keep the RFC 2965 cookie and ignore the Netscape
            # cookie (RFC 2965 section 9.1).  Actually, RFC 2109 cookies are
            # bundled in with the Netscape cookies for this purpose, which is
            # reasonable behaviour.
            if rfc2965:
                lookup = {}
                for cookie in cookies:
                    lookup[(cookie.domain, cookie.path, cookie.name)] = None

                def no_matching_rfc2965(ns_cookie, lookup=lookup):
                    key = ns_cookie.domain, ns_cookie.path, ns_cookie.name
                    return key not in lookup
                ns_cookies = filter(no_matching_rfc2965, ns_cookies)

            if ns_cookies:
                cookies.extend(ns_cookies)

        return cookies

    def set_cookie_if_ok(self, cookie, request):
        """Set a cookie if policy says it's OK to do so."""
        self._cookies_lock.acquire()
        try:
            self._policy._now = self._now = int(time.time())

            if self._policy.set_ok(cookie, request):
                self.set_cookie(cookie)


        finally:
            self._cookies_lock.release()

    def set_cookie(self, cookie):
        """Set a cookie, without checking whether or not it should be set."""
        c = self._cookies
        self._cookies_lock.acquire()
        try:
            if cookie.domain not in c: c[cookie.domain] = {}
            c2 = c[cookie.domain]
            if cookie.path not in c2: c2[cookie.path] = {}
            c3 = c2[cookie.path]
            c3[cookie.name] = cookie
        finally:
            self._cookies_lock.release()

    def extract_cookies(self, response, request):
        """Extract cookies from response, where allowable given the request."""
        _debug("extract_cookies: %s", response.info())
        self._cookies_lock.acquire()
        try:
            self._policy._now = self._now = int(time.time())

            for cookie in self.make_cookies(response, request):
                if self._policy.set_ok(cookie, request):
                    _debug(" setting cookie: %s", cookie)
                    self.set_cookie(cookie)
        finally:
            self._cookies_lock.release()

    def clear(self, domain=None, path=None, name=None):
        """Clear some cookies.

        Invoking this method without arguments will clear all cookies.  If
        given a single argument, only cookies belonging to that domain will be
        removed.  If given two arguments, cookies belonging to the specified
        path within that domain are removed.  If given three arguments, then
        the cookie with the specified name, path and domain is removed.

        Raises KeyError if no matching cookie exists.

        """
        if name is not None:
            if (domain is None) or (path is None):
                raise ValueError(
                    "domain and path must be given to remove a cookie by name")
            del self._cookies[domain][path][name]
        elif path is not None:
            if domain is None:
                raise ValueError(
                    "domain must be given to remove cookies by path")
            del self._cookies[domain][path]
        elif domain is not None:
            del self._cookies[domain]
        else:
            self._cookies = {}

    def clear_session_cookies(self):
        """Discard all session cookies.

        Note that the .save() method won't save session cookies anyway, unless
        you ask otherwise by passing a true ignore_discard argument.

        """
        self._cookies_lock.acquire()
        try:
            for cookie in self:
                if cookie.discard:
                    self.clear(cookie.domain, cookie.path, cookie.name)
        finally:
            self._cookies_lock.release()

    def clear_expired_cookies(self):
        """Discard all expired cookies.

        You probably don't need to call this method: expired cookies are never
        sent back to the server (provided you're using DefaultCookiePolicy),
        this method is called by CookieJar itself every so often, and the
        .save() method won't save expired cookies anyway (unless you ask
        otherwise by passing a true ignore_expires argument).

        """
        self._cookies_lock.acquire()
        try:
            now = time.time()
            for cookie in self:
                if cookie.is_expired(now):
                    self.clear(cookie.domain, cookie.path, cookie.name)
        finally:
            self._cookies_lock.release()

    def __iter__(self):
        return deepvalues(self._cookies)

    def __len__(self):
        """Return number of contained cookies."""
        i = 0
        for cookie in self: i = i + 1
        return i

    def __repr__(self):
        r = []
        for cookie in self: r.append(repr(cookie))
        return "<%s[%s]>" % (self.__class__.__name__, ", ".join(r))

    def __str__(self):
        r = []
        for cookie in self: r.append(str(cookie))
        return "<%s[%s]>" % (self.__class__.__name__, ", ".join(r))


# derives from OSError for backwards-compatibility with Python 2.4.0
class LoadError(OSError): pass

class FileCookieJar(CookieJar):
    """CookieJar that can be loaded from and saved to a file."""

    def __init__(self, filename=None, delayload=False, policy=None):
        """
        Cookies are NOT loaded from the named file until either the .load() or
        .revert() method is called.

        """
        CookieJar.__init__(self, policy)
        if filename is not None:
            try:
                filename+""
            except:
                raise ValueError("filename must be string-like")
        self.filename = filename
        self.delayload = bool(delayload)

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        """Save cookies to a file."""
        raise NotImplementedError()

    def load(self, filename=None, ignore_discard=False, ignore_expires=False):
        """Load cookies from a file."""
        if filename is None:
            if self.filename is not None: filename = self.filename
            else: raise ValueError(MISSING_FILENAME_TEXT)

        with open(filename) as f:
            self._really_load(f, filename, ignore_discard, ignore_expires)

    def revert(self, filename=None,
               ignore_discard=False, ignore_expires=False):
        """Clear all cookies and reload cookies from a saved file.

        Raises LoadError (or OSError) if reversion is not successful; the
        object's state will not be altered if this happens.

        """
        if filename is None:
            if self.filename is not None: filename = self.filename
            else: raise ValueError(MISSING_FILENAME_TEXT)

        self._cookies_lock.acquire()
        try:

            old_state = copy.deepcopy(self._cookies)
            self._cookies = {}
            try:
                self.load(filename, ignore_discard, ignore_expires)
            except OSError:
                self._cookies = old_state
                raise

        finally:
            self._cookies_lock.release()


def lwp_cookie_str(cookie):
    """Return string representation of Cookie in the LWP cookie file format.

    Actually, the format is extended a bit -- see module docstring.

    """
    h = [(cookie.name, cookie.value),
         ("path", cookie.path),
         ("domain", cookie.domain)]
    if cookie.port is not None: h.append(("port", cookie.port))
    if cookie.path_specified: h.append(("path_spec", None))
    if cookie.port_specified: h.append(("port_spec", None))
    if cookie.domain_initial_dot: h.append(("domain_dot", None))
    if cookie.secure: h.append(("secure", None))
    if cookie.expires: h.append(("expires",
                               time2isoz(float(cookie.expires))))
    if cookie.discard: h.append(("discard", None))
    if cookie.comment: h.append(("comment", cookie.comment))
    if cookie.comment_url: h.append(("commenturl", cookie.comment_url))

    keys = sorted(cookie._rest.keys())
    for k in keys:
        h.append((k, str(cookie._rest[k])))

    h.append(("version", str(cookie.version)))

    return join_header_words([h])

class LWPCookieJar(FileCookieJar):
    """
    The LWPCookieJar saves a sequence of "Set-Cookie3" lines.
    "Set-Cookie3" is the format used by the libwww-perl library, not known
    to be compatible with any browser, but which is easy to read and
    doesn't lose information about RFC 2965 cookies.

    Additional methods

    as_lwp_str(ignore_discard=True, ignore_expired=True)

    """

    def as_lwp_str(self, ignore_discard=True, ignore_expires=True):
        """Return cookies as a string of "\\n"-separated "Set-Cookie3" headers.

        ignore_discard and ignore_expires: see docstring for FileCookieJar.save

        """
        now = time.time()
        r = []
        for cookie in self:
            if not ignore_discard and cookie.discard:
                continue
            if not ignore_expires and cookie.is_expired(now):
                continue
            r.append("Set-Cookie3: %s" % lwp_cookie_str(cookie))
        return "\n".join(r+[""])

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None: filename = self.filename
            else: raise ValueError(MISSING_FILENAME_TEXT)

        with open(filename, "w") as f:
            # There really isn't an LWP Cookies 2.0 format, but this indicates
            # that there is extra information in here (domain_dot and
            # port_spec) while still being compatible with libwww-perl, I hope.
            f.write("#LWP-Cookies-2.0\n")
            f.write(self.as_lwp_str(ignore_discard, ignore_expires))

    def _really_load(self, f, filename, ignore_discard, ignore_expires):
        magic = f.readline()
        if not self.magic_re.search(magic):
            msg = ("%r does not look like a Set-Cookie3 (LWP) format "
                   "file" % filename)
            raise LoadError(msg)

        now = time.time()

        header = "Set-Cookie3:"
        boolean_attrs = ("port_spec", "path_spec", "domain_dot",
                         "secure", "discard")
        value_attrs = ("version",
                       "port", "path", "domain",
                       "expires",
                       "comment", "commenturl")

        try:
            while 1:
                line = f.readline()
                if line == "": break
                if not line.startswith(header):
                    continue
                line = line[len(header):].strip()

                for data in split_header_words([line]):
                    name, value = data[0]
                    standard = {}
                    rest = {}
                    for k in boolean_attrs:
                        standard[k] = False
                    for k, v in data[1:]:
                        if k is not None:
                            lc = k.lower()
                        else:
                            lc = None
                        # don't lose case distinction for unknown fields
                        if (lc in value_attrs) or (lc in boolean_attrs):
                            k = lc
                        if k in boolean_attrs:
                            if v is None: v = True
                            standard[k] = v
                        elif k in value_attrs:
                            standard[k] = v
                        else:
                            rest[k] = v

                    h = standard.get
                    expires = h("expires")
                    discard = h("discard")
                    if expires is not None:
                        expires = iso2time(expires)
                    if expires is None:
                        discard = True
                    domain = h("domain")
                    domain_specified = domain.startswith(".")
                    c = Cookie(h("version"), name, value,
                               h("port"), h("port_spec"),
                               domain, domain_specified, h("domain_dot"),
                               h("path"), h("path_spec"),
                               h("secure"),
                               expires,
                               discard,
                               h("comment"),
                               h("commenturl"),
                               rest)
                    if not ignore_discard and c.discard:
                        continue
                    if not ignore_expires and c.is_expired(now):
                        continue
                    self.set_cookie(c)
        except OSError:
            raise
        except Exception:
            _warn_unhandled_exception()
            raise LoadError("invalid Set-Cookie3 format file %r: %r" %
                            (filename, line))


class MozillaCookieJar(FileCookieJar):
    """

    WARNING: you may want to backup your browser's cookies file if you use
    this class to save cookies.  I *think* it works, but there have been
    bugs in the past!

    This class differs from CookieJar only in the format it uses to save and
    load cookies to and from a file.  This class uses the Mozilla/Netscape
    `cookies.txt' format.  lynx uses this file format, too.

    Don't expect cookies saved while the browser is running to be noticed by
    the browser (in fact, Mozilla on unix will overwrite your saved cookies if
    you change them on disk while it's running; on Windows, you probably can't
    save at all while the browser is running).

    Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
    Netscape cookies on saving.

    In particular, the cookie version and port number information is lost,
    together with information about whether or not Path, Port and Discard were
    specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
    domain as set in the HTTP header started with a dot (yes, I'm aware some
    domains in Netscape files start with a dot and some don't -- trust me, you
    really don't want to know any more about this).

    Note that though Mozilla and Netscape use the same format, they use
    slightly different headers.  The class saves cookies using the Netscape
    header by default (Mozilla can cope with that).

    """
    magic_re = re.compile("#( Netscape)? HTTP Cookie File")
    header = """\
# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

"""

    def _really_load(self, f, filename, ignore_discard, ignore_expires):
        now = time.time()

        magic = f.readline()
        if not self.magic_re.search(magic):
            raise LoadError(
                "%r does not look like a Netscape format cookies file" %
                filename)

        try:
            while 1:
                line = f.readline()
                if line == "": break

                # last field may be absent, so keep any trailing tab
                if line.endswith("\n"): line = line[:-1]

                # skip comments and blank lines XXX what is $ for?
                if (line.strip().startswith(("#", "$")) or
                    line.strip() == ""):
                    continue

                domain, domain_specified, path, secure, expires, name, value = \
                        line.split("\t")
                secure = (secure == "TRUE")
                domain_specified = (domain_specified == "TRUE")
                if name == "":
                    # cookies.txt regards 'Set-Cookie: foo' as a cookie
                    # with no name, whereas http.cookiejar regards it as a
                    # cookie with no value.
                    name = value
                    value = None

                initial_dot = domain.startswith(".")
                assert domain_specified == initial_dot

                discard = False
                if expires == "":
                    expires = None
                    discard = True

                # assume path_specified is false
                c = Cookie(0, name, value,
                           None, False,
                           domain, domain_specified, initial_dot,
                           path, False,
                           secure,
                           expires,
                           discard,
                           None,
                           None,
                           {})
                if not ignore_discard and c.discard:
                    continue
                if not ignore_expires and c.is_expired(now):
                    continue
                self.set_cookie(c)

        except OSError:
            raise
        except Exception:
            _warn_unhandled_exception()
            raise LoadError("invalid Netscape format cookies file %r: %r" %
                            (filename, line))

    def save(self, filename=None, ignore_discard=False, ignore_expires=False):
        if filename is None:
            if self.filename is not None: filename = self.filename
            else: raise ValueError(MISSING_FILENAME_TEXT)

        with open(filename, "w") as f:
            f.write(self.header)
            now = time.time()
            for cookie in self:
                if not ignore_discard and cookie.discard:
                    continue
                if not ignore_expires and cookie.is_expired(now):
                    continue
                if cookie.secure: secure = "TRUE"
                else: secure = "FALSE"
                if cookie.domain.startswith("."): initial_dot = "TRUE"
                else: initial_dot = "FALSE"
                if cookie.expires is not None:
                    expires = str(cookie.expires)
                else:
                    expires = ""
                if cookie.value is None:
                    # cookies.txt regards 'Set-Cookie: foo' as a cookie
                    # with no name, whereas http.cookiejar regards it as a
                    # cookie with no value.
                    name = ""
                    value = cookie.name
                else:
                    name = cookie.name
                    value = cookie.value
                f.write(
                    "\t".join([cookie.domain, initial_dot, cookie.path,
                               secure, expires, name, value])+
                    "\n")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ####
# Copyright 2000 by Timothy O'Malley <timo@alum.mit.edu>
#
#                All Rights Reserved
#
# Permission to use, copy, modify, and distribute this software
# and its documentation for any purpose and without fee is hereby
# granted, provided that the above copyright notice appear in all
# copies and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Timothy O'Malley  not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
# SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR
# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
####
#
# Id: Cookie.py,v 2.29 2000/08/23 05:28:49 timo Exp
#   by Timothy O'Malley <timo@alum.mit.edu>
#
#  Cookie.py is a Python module for the handling of HTTP
#  cookies as a Python dictionary.  See RFC 2109 for more
#  information on cookies.
#
#  The original idea to treat Cookies as a dictionary came from
#  Dave Mitchell (davem@magnet.com) in 1995, when he released the
#  first version of nscookie.py.
#
####

r"""
Here's a sample session to show how to use this module.
At the moment, this is the only documentation.

The Basics
----------

Importing is easy...

   >>> from http import cookies

Most of the time you start by creating a cookie.

   >>> C = cookies.SimpleCookie()

Once you've created your Cookie, you can add values just as if it were
a dictionary.

   >>> C = cookies.SimpleCookie()
   >>> C["fig"] = "newton"
   >>> C["sugar"] = "wafer"
   >>> C.output()
   'Set-Cookie: fig=newton\r\nSet-Cookie: sugar=wafer'

Notice that the printable representation of a Cookie is the
appropriate format for a Set-Cookie: header.  This is the
default behavior.  You can change the header and printed
attributes by using the .output() function

   >>> C = cookies.SimpleCookie()
   >>> C["rocky"] = "road"
   >>> C["rocky"]["path"] = "/cookie"
   >>> print(C.output(header="Cookie:"))
   Cookie: rocky=road; Path=/cookie
   >>> print(C.output(attrs=[], header="Cookie:"))
   Cookie: rocky=road

The load() method of a Cookie extracts cookies from a string.  In a
CGI script, you would use this method to extract the cookies from the
HTTP_COOKIE environment variable.

   >>> C = cookies.SimpleCookie()
   >>> C.load("chips=ahoy; vienna=finger")
   >>> C.output()
   'Set-Cookie: chips=ahoy\r\nSet-Cookie: vienna=finger'

The load() method is darn-tootin smart about identifying cookies
within a string.  Escaped quotation marks, nested semicolons, and other
such trickeries do not confuse it.

   >>> C = cookies.SimpleCookie()
   >>> C.load('keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";')
   >>> print(C)
   Set-Cookie: keebler="E=everybody; L=\"Loves\"; fudge=\012;"

Each element of the Cookie also supports all of the RFC 2109
Cookie attributes.  Here's an example which sets the Path
attribute.

   >>> C = cookies.SimpleCookie()
   >>> C["oreo"] = "doublestuff"
   >>> C["oreo"]["path"] = "/"
   >>> print(C)
   Set-Cookie: oreo=doublestuff; Path=/

Each dictionary element has a 'value' attribute, which gives you
back the value associated with the key.

   >>> C = cookies.SimpleCookie()
   >>> C["twix"] = "none for you"
   >>> C["twix"].value
   'none for you'

The SimpleCookie expects that all values should be standard strings.
Just to be sure, SimpleCookie invokes the str() builtin to convert
the value to a string, when the values are set dictionary-style.

   >>> C = cookies.SimpleCookie()
   >>> C["number"] = 7
   >>> C["string"] = "seven"
   >>> C["number"].value
   '7'
   >>> C["string"].value
   'seven'
   >>> C.output()
   'Set-Cookie: number=7\r\nSet-Cookie: string=seven'

Finis.
"""

#
# Import our required modules
#
import re
import string

__all__ = ["CookieError", "BaseCookie", "SimpleCookie"]

_nulljoin = ''.join
_semispacejoin = '; '.join
_spacejoin = ' '.join

def _warn_deprecated_setter(setter):
    import warnings
    msg = ('The .%s setter is deprecated. The attribute will be read-only in '
           'future releases. Please use the set() method instead.' % setter)
    warnings.warn(msg, DeprecationWarning, stacklevel=3)

#
# Define an exception visible to External modules
#
class CookieError(Exception):
    pass


# These quoting routines conform to the RFC2109 specification, which in
# turn references the character definitions from RFC2068.  They provide
# a two-way quoting algorithm.  Any non-text character is translated
# into a 4 character sequence: a forward-slash followed by the
# three-digit octal equivalent of the character.  Any '\' or '"' is
# quoted with a preceding '\' slash.
# Because of the way browsers really handle cookies (as opposed to what
# the RFC says) we also encode "," and ";".
#
# These are taken from RFC2068 and RFC2109.
#       _LegalChars       is the list of chars which don't require "'s
#       _Translator       hash-table for fast quoting
#
_LegalChars = string.ascii_letters + string.digits + "!#$%&'*+-.^_`|~:"
_UnescapedChars = _LegalChars + ' ()/<=>?@[]{}'

_Translator = {n: '\\%03o' % n
               for n in set(range(256)) - set(map(ord, _UnescapedChars))}
_Translator.update({
    ord('"'): '\\"',
    ord('\\'): '\\\\',
})

_is_legal_key = re.compile('[%s]+' % re.escape(_LegalChars)).fullmatch

def _quote(str):
    r"""Quote a string for use in a cookie header.

    If the string does not need to be double-quoted, then just return the
    string.  Otherwise, surround the string in doublequotes and quote
    (with a \) special characters.
    """
    if str is None or _is_legal_key(str):
        return str
    else:
        return '"' + str.translate(_Translator) + '"'


_OctalPatt = re.compile(r"\\[0-3][0-7][0-7]")
_QuotePatt = re.compile(r"[\\].")

def _unquote(str):
    # If there aren't any doublequotes,
    # then there can't be any special characters.  See RFC 2109.
    if str is None or len(str) < 2:
        return str
    if str[0] != '"' or str[-1] != '"':
        return str

    # We have to assume that we must decode this string.
    # Down to work.

    # Remove the "s
    str = str[1:-1]

    # Check for special sequences.  Examples:
    #    \012 --> \n
    #    \"   --> "
    #
    i = 0
    n = len(str)
    res = []
    while 0 <= i < n:
        o_match = _OctalPatt.search(str, i)
        q_match = _QuotePatt.search(str, i)
        if not o_match and not q_match:              # Neither matched
            res.append(str[i:])
            break
        # else:
        j = k = -1
        if o_match:
            j = o_match.start(0)
        if q_match:
            k = q_match.start(0)
        if q_match and (not o_match or k < j):     # QuotePatt matched
            res.append(str[i:k])
            res.append(str[k+1])
            i = k + 2
        else:                                      # OctalPatt matched
            res.append(str[i:j])
            res.append(chr(int(str[j+1:j+4], 8)))
            i = j + 4
    return _nulljoin(res)

# The _getdate() routine is used to set the expiration time in the cookie's HTTP
# header.  By default, _getdate() returns the current time in the appropriate
# "expires" format for a Set-Cookie header.  The one optional argument is an
# offset from now, in seconds.  For example, an offset of -3600 means "one hour
# ago".  The offset may be a floating point number.
#

_weekdayname = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

_monthname = [None,
              'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

def _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):
    from time import gmtime, time
    now = time()
    year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)
    return "%s, %02d %3s %4d %02d:%02d:%02d GMT" % \
           (weekdayname[wd], day, monthname[month], year, hh, mm, ss)


class Morsel(dict):
    """A class to hold ONE (key, value) pair.

    In a cookie, each such pair may have several attributes, so this class is
    used to keep the attributes associated with the appropriate key,value pair.
    This class also includes a coded_value attribute, which is used to hold
    the network representation of the value.  This is most useful when Python
    objects are pickled for network transit.
    """
    # RFC 2109 lists these attributes as reserved:
    #   path       comment         domain
    #   max-age    secure      version
    #
    # For historical reasons, these attributes are also reserved:
    #   expires
    #
    # This is an extension from Microsoft:
    #   httponly
    #
    # This dictionary provides a mapping from the lowercase
    # variant on the left to the appropriate traditional
    # formatting on the right.
    _reserved = {
        "expires"  : "expires",
        "path"     : "Path",
        "comment"  : "Comment",
        "domain"   : "Domain",
        "max-age"  : "Max-Age",
        "secure"   : "Secure",
        "httponly" : "HttpOnly",
        "version"  : "Version",
    }

    _flags = {'secure', 'httponly'}

    def __init__(self):
        # Set defaults
        self._key = self._value = self._coded_value = None

        # Set default attributes
        for key in self._reserved:
            dict.__setitem__(self, key, "")

    @property
    def key(self):
        return self._key

    @key.setter
    def key(self, key):
        _warn_deprecated_setter('key')
        self._key = key

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        _warn_deprecated_setter('value')
        self._value = value

    @property
    def coded_value(self):
        return self._coded_value

    @coded_value.setter
    def coded_value(self, coded_value):
        _warn_deprecated_setter('coded_value')
        self._coded_value = coded_value

    def __setitem__(self, K, V):
        K = K.lower()
        if not K in self._reserved:
            raise CookieError("Invalid attribute %r" % (K,))
        dict.__setitem__(self, K, V)

    def setdefault(self, key, val=None):
        key = key.lower()
        if key not in self._reserved:
            raise CookieError("Invalid attribute %r" % (key,))
        return dict.setdefault(self, key, val)

    def __eq__(self, morsel):
        if not isinstance(morsel, Morsel):
            return NotImplemented
        return (dict.__eq__(self, morsel) and
                self._value == morsel._value and
                self._key == morsel._key and
                self._coded_value == morsel._coded_value)

    __ne__ = object.__ne__

    def copy(self):
        morsel = Morsel()
        dict.update(morsel, self)
        morsel.__dict__.update(self.__dict__)
        return morsel

    def update(self, values):
        data = {}
        for key, val in dict(values).items():
            key = key.lower()
            if key not in self._reserved:
                raise CookieError("Invalid attribute %r" % (key,))
            data[key] = val
        dict.update(self, data)

    def isReservedKey(self, K):
        return K.lower() in self._reserved

    def set(self, key, val, coded_val, LegalChars=_LegalChars):
        if LegalChars != _LegalChars:
            import warnings
            warnings.warn(
                'LegalChars parameter is deprecated, ignored and will '
                'be removed in future versions.', DeprecationWarning,
                stacklevel=2)

        if key.lower() in self._reserved:
            raise CookieError('Attempt to set a reserved key %r' % (key,))
        if not _is_legal_key(key):
            raise CookieError('Illegal key %r' % (key,))

        # It's a good key, so save it.
        self._key = key
        self._value = val
        self._coded_value = coded_val

    def __getstate__(self):
        return {
            'key': self._key,
            'value': self._value,
            'coded_value': self._coded_value,
        }

    def __setstate__(self, state):
        self._key = state['key']
        self._value = state['value']
        self._coded_value = state['coded_value']

    def output(self, attrs=None, header="Set-Cookie:"):
        return "%s %s" % (header, self.OutputString(attrs))

    __str__ = output

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, self.OutputString())

    def js_output(self, attrs=None):
        # Print javascript
        return """
        <script type="text/javascript">
        <!-- begin hiding
        document.cookie = \"%s\";
        // end hiding -->
        </script>
        """ % (self.OutputString(attrs).replace('"', r'\"'))

    def OutputString(self, attrs=None):
        # Build up our result
        #
        result = []
        append = result.append

        # First, the key=value pair
        append("%s=%s" % (self.key, self.coded_value))

        # Now add any defined attributes
        if attrs is None:
            attrs = self._reserved
        items = sorted(self.items())
        for key, value in items:
            if value == "":
                continue
            if key not in attrs:
                continue
            if key == "expires" and isinstance(value, int):
                append("%s=%s" % (self._reserved[key], _getdate(value)))
            elif key == "max-age" and isinstance(value, int):
                append("%s=%d" % (self._reserved[key], value))
            elif key in self._flags:
                if value:
                    append(str(self._reserved[key]))
            else:
                append("%s=%s" % (self._reserved[key], value))

        # Return the result
        return _semispacejoin(result)


#
# Pattern for finding cookie
#
# This used to be strict parsing based on the RFC2109 and RFC2068
# specifications.  I have since discovered that MSIE 3.0x doesn't
# follow the character rules outlined in those specs.  As a
# result, the parsing rules here are less strict.
#

_LegalKeyChars  = r"\w\d!#%&'~_`><@,:/\$\*\+\-\.\^\|\)\(\?\}\{\="
_LegalValueChars = _LegalKeyChars + '\[\]'
_CookiePattern = re.compile(r"""
    (?x)                           # This is a verbose pattern
    \s*                            # Optional whitespace at start of cookie
    (?P<key>                       # Start of group 'key'
    [""" + _LegalKeyChars + r"""]+?   # Any word of at least one letter
    )                              # End of group 'key'
    (                              # Optional group: there may not be a value.
    \s*=\s*                          # Equal Sign
    (?P<val>                         # Start of group 'val'
    "(?:[^\\"]|\\.)*"                  # Any doublequoted string
    |                                  # or
    \w{3},\s[\w\d\s-]{9,11}\s[\d:]{8}\sGMT  # Special case for "expires" attr
    |                                  # or
    [""" + _LegalValueChars + r"""]*      # Any word or empty string
    )                                # End of group 'val'
    )?                             # End of optional value group
    \s*                            # Any number of spaces.
    (\s+|;|$)                      # Ending either at space, semicolon, or EOS.
    """, re.ASCII)                 # May be removed if safe.


# At long last, here is the cookie class.  Using this class is almost just like
# using a dictionary.  See this module's docstring for example usage.
#
class BaseCookie(dict):
    """A container class for a set of Morsels."""

    def value_decode(self, val):
        """real_value, coded_value = value_decode(STRING)
        Called prior to setting a cookie's value from the network
        representation.  The VALUE is the value read from HTTP
        header.
        Override this function to modify the behavior of cookies.
        """
        return val, val

    def value_encode(self, val):
        """real_value, coded_value = value_encode(VALUE)
        Called prior to setting a cookie's value from the dictionary
        representation.  The VALUE is the value being assigned.
        Override this function to modify the behavior of cookies.
        """
        strval = str(val)
        return strval, strval

    def __init__(self, input=None):
        if input:
            self.load(input)

    def __set(self, key, real_value, coded_value):
        """Private method for setting a cookie's value"""
        M = self.get(key, Morsel())
        M.set(key, real_value, coded_value)
        dict.__setitem__(self, key, M)

    def __setitem__(self, key, value):
        """Dictionary style assignment."""
        if isinstance(value, Morsel):
            # allow assignment of constructed Morsels (e.g. for pickling)
            dict.__setitem__(self, key, value)
        else:
            rval, cval = self.value_encode(value)
            self.__set(key, rval, cval)

    def output(self, attrs=None, header="Set-Cookie:", sep="\015\012"):
        """Return a string suitable for HTTP."""
        result = []
        items = sorted(self.items())
        for key, value in items:
            result.append(value.output(attrs, header))
        return sep.join(result)

    __str__ = output

    def __repr__(self):
        l = []
        items = sorted(self.items())
        for key, value in items:
            l.append('%s=%s' % (key, repr(value.value)))
        return '<%s: %s>' % (self.__class__.__name__, _spacejoin(l))

    def js_output(self, attrs=None):
        """Return a string suitable for JavaScript."""
        result = []
        items = sorted(self.items())
        for key, value in items:
            result.append(value.js_output(attrs))
        return _nulljoin(result)

    def load(self, rawdata):
        """Load cookies from a string (presumably HTTP_COOKIE) or
        from a dictionary.  Loading cookies from a dictionary 'd'
        is equivalent to calling:
            map(Cookie.__setitem__, d.keys(), d.values())
        """
        if isinstance(rawdata, str):
            self.__parse_string(rawdata)
        else:
            # self.update() wouldn't call our custom __setitem__
            for key, value in rawdata.items():
                self[key] = value
        return

    def __parse_string(self, str, patt=_CookiePattern):
        i = 0                 # Our starting point
        n = len(str)          # Length of string
        parsed_items = []     # Parsed (type, key, value) triples
        morsel_seen = False   # A key=value pair was previously encountered

        TYPE_ATTRIBUTE = 1
        TYPE_KEYVALUE = 2

        # We first parse the whole cookie string and reject it if it's
        # syntactically invalid (this helps avoid some classes of injection
        # attacks).
        while 0 <= i < n:
            # Start looking for a cookie
            match = patt.match(str, i)
            if not match:
                # No more cookies
                break

            key, value = match.group("key"), match.group("val")
            i = match.end(0)

            if key[0] == "$":
                if not morsel_seen:
                    # We ignore attributes which pertain to the cookie
                    # mechanism as a whole, such as "$Version".
                    # See RFC 2965. (Does anyone care?)
                    continue
                parsed_items.append((TYPE_ATTRIBUTE, key[1:], value))
            elif key.lower() in Morsel._reserved:
                if not morsel_seen:
                    # Invalid cookie string
                    return
                if value is None:
                    if key.lower() in Morsel._flags:
                        parsed_items.append((TYPE_ATTRIBUTE, key, True))
                    else:
                        # Invalid cookie string
                        return
                else:
                    parsed_items.append((TYPE_ATTRIBUTE, key, _unquote(value)))
            elif value is not None:
                parsed_items.append((TYPE_KEYVALUE, key, self.value_decode(value)))
                morsel_seen = True
            else:
                # Invalid cookie string
                return

        # The cookie string is valid, apply it.
        M = None         # current morsel
        for tp, key, value in parsed_items:
            if tp == TYPE_ATTRIBUTE:
                assert M is not None
                M[key] = value
            else:
                assert tp == TYPE_KEYVALUE
                rval, cval = value
                self.__set(key, rval, cval)
                M = self[key]


class SimpleCookie(BaseCookie):
    """
    SimpleCookie supports strings as cookie values.  When setting
    the value using the dictionary assignment notation, SimpleCookie
    calls the builtin str() to convert the value to a string.  Values
    received from HTTP are kept as strings.
    """
    def value_decode(self, val):
        return _unquote(val), val

    def value_encode(self, val):
        strval = str(val)
        return strval, _quote(strval)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """HTTP server classes.

Note: BaseHTTPRequestHandler doesn't implement any HTTP request; see
SimpleHTTPRequestHandler for simple implementations of GET, HEAD and POST,
and CGIHTTPRequestHandler for CGI scripts.

It does, however, optionally implement HTTP/1.1 persistent connections,
as of version 0.3.

Notes on CGIHTTPRequestHandler
------------------------------

This class implements GET and POST requests to cgi-bin scripts.

If the os.fork() function is not present (e.g. on Windows),
subprocess.Popen() is used as a fallback, with slightly altered semantics.

In all cases, the implementation is intentionally naive -- all
requests are executed synchronously.

SECURITY WARNING: DON'T USE THIS CODE UNLESS YOU ARE INSIDE A FIREWALL
-- it may execute arbitrary Python code or external programs.

Note that status code 200 is sent prior to execution of a CGI script, so
scripts cannot send other status codes such as 302 (redirect).

XXX To do:

- log requests even later (to capture byte count)
- log user-agent header and other interesting goodies
- send error log to separate file
"""


# See also:
#
# HTTP Working Group                                        T. Berners-Lee
# INTERNET-DRAFT                                            R. T. Fielding
# <draft-ietf-http-v10-spec-00.txt>                     H. Frystyk Nielsen
# Expires September 8, 1995                                  March 8, 1995
#
# URL: http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-v10-spec-00.txt
#
# and
#
# Network Working Group                                      R. Fielding
# Request for Comments: 2616                                       et al
# Obsoletes: 2068                                              June 1999
# Category: Standards Track
#
# URL: http://www.faqs.org/rfcs/rfc2616.html

# Log files
# ---------
#
# Here's a quote from the NCSA httpd docs about log file format.
#
# | The logfile format is as follows. Each line consists of:
# |
# | host rfc931 authuser [DD/Mon/YYYY:hh:mm:ss] "request" ddd bbbb
# |
# |        host: Either the DNS name or the IP number of the remote client
# |        rfc931: Any information returned by identd for this person,
# |                - otherwise.
# |        authuser: If user sent a userid for authentication, the user name,
# |                  - otherwise.
# |        DD: Day
# |        Mon: Month (calendar name)
# |        YYYY: Year
# |        hh: hour (24-hour format, the machine's timezone)
# |        mm: minutes
# |        ss: seconds
# |        request: The first line of the HTTP request as sent by the client.
# |        ddd: the status code returned by the server, - if not available.
# |        bbbb: the total number of bytes sent,
# |              *not including the HTTP/1.0 header*, - if not available
# |
# | You can determine the name of the file accessed through request.
#
# (Actually, the latter is only true if you know the server configuration
# at the time the request was made!)

__version__ = "0.6"

__all__ = [
    "HTTPServer", "BaseHTTPRequestHandler",
    "SimpleHTTPRequestHandler", "CGIHTTPRequestHandler",
]

import html
import http.client
import io
import mimetypes
import os
import posixpath
import select
import shutil
import socket # For gethostbyaddr()
import socketserver
import sys
import time
import urllib.parse
import copy
import argparse

from http import HTTPStatus


# Default error message template
DEFAULT_ERROR_MESSAGE = """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
        <title>Error response</title>
    </head>
    <body>
        <h1>Error response</h1>
        <p>Error code: %(code)d</p>
        <p>Message: %(message)s.</p>
        <p>Error code explanation: %(code)s - %(explain)s.</p>
    </body>
</html>
"""

DEFAULT_ERROR_CONTENT_TYPE = "text/html;charset=utf-8"

def _quote_html(html):
    return html.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

class HTTPServer(socketserver.TCPServer):

    allow_reuse_address = 1    # Seems to make sense in testing environment

    def server_bind(self):
        """Override server_bind to store the server name."""
        socketserver.TCPServer.server_bind(self)
        host, port = self.socket.getsockname()[:2]
        self.server_name = socket.getfqdn(host)
        self.server_port = port


class BaseHTTPRequestHandler(socketserver.StreamRequestHandler):

    """HTTP request handler base class.

    The following explanation of HTTP serves to guide you through the
    code as well as to expose any misunderstandings I may have about
    HTTP (so you don't need to read the code to figure out I'm wrong
    :-).

    HTTP (HyperText Transfer Protocol) is an extensible protocol on
    top of a reliable stream transport (e.g. TCP/IP).  The protocol
    recognizes three parts to a request:

    1. One line identifying the request type and path
    2. An optional set of RFC-822-style headers
    3. An optional data part

    The headers and data are separated by a blank line.

    The first line of the request has the form

    <command> <path> <version>

    where <command> is a (case-sensitive) keyword such as GET or POST,
    <path> is a string containing path information for the request,
    and <version> should be the string "HTTP/1.0" or "HTTP/1.1".
    <path> is encoded using the URL encoding scheme (using %xx to signify
    the ASCII character with hex code xx).

    The specification specifies that lines are separated by CRLF but
    for compatibility with the widest range of clients recommends
    servers also handle LF.  Similarly, whitespace in the request line
    is treated sensibly (allowing multiple spaces between components
    and allowing trailing whitespace).

    Similarly, for output, lines ought to be separated by CRLF pairs
    but most clients grok LF characters just fine.

    If the first line of the request has the form

    <command> <path>

    (i.e. <version> is left out) then this is assumed to be an HTTP
    0.9 request; this form has no optional headers and data part and
    the reply consists of just the data.

    The reply form of the HTTP 1.x protocol again has three parts:

    1. One line giving the response code
    2. An optional set of RFC-822-style headers
    3. The data

    Again, the headers and data are separated by a blank line.

    The response code line has the form

    <version> <responsecode> <responsestring>

    where <version> is the protocol version ("HTTP/1.0" or "HTTP/1.1"),
    <responsecode> is a 3-digit response code indicating success or
    failure of the request, and <responsestring> is an optional
    human-readable string explaining what the response code means.

    This server parses the request and the headers, and then calls a
    function specific to the request type (<command>).  Specifically,
    a request SPAM will be handled by a method do_SPAM().  If no
    such method exists the server sends an error response to the
    client.  If it exists, it is called with no arguments:

    do_SPAM()

    Note that the request name is case sensitive (i.e. SPAM and spam
    are different requests).

    The various request details are stored in instance variables:

    - client_address is the client IP address in the form (host,
    port);

    - command, path and version are the broken-down request line;

    - headers is an instance of email.message.Message (or a derived
    class) containing the header information;

    - rfile is a file object open for reading positioned at the
    start of the optional input data part;

    - wfile is a file object open for writing.

    IT IS IMPORTANT TO ADHERE TO THE PROTOCOL FOR WRITING!

    The first thing to be written must be the response line.  Then
    follow 0 or more header lines, then a blank line, and then the
    actual data (if any).  The meaning of the header lines depends on
    the command executed by the server; in most cases, when data is
    returned, there should be at least one header line of the form

    Content-type: <type>/<subtype>

    where <type> and <subtype> should be registered MIME types,
    e.g. "text/html" or "text/plain".

    """

    # The Python system version, truncated to its first component.
    sys_version = "Python/" + sys.version.split()[0]

    # The server software version.  You may want to override this.
    # The format is multiple whitespace-separated strings,
    # where each string is of the form name[/version].
    server_version = "BaseHTTP/" + __version__

    error_message_format = DEFAULT_ERROR_MESSAGE
    error_content_type = DEFAULT_ERROR_CONTENT_TYPE

    # The default request version.  This only affects responses up until
    # the point where the request line is parsed, so it mainly decides what
    # the client gets back when sending a malformed request line.
    # Most web servers default to HTTP 0.9, i.e. don't send a status line.
    default_request_version = "HTTP/0.9"

    def parse_request(self):
        """Parse a request (internal).

        The request should be stored in self.raw_requestline; the results
        are in self.command, self.path, self.request_version and
        self.headers.

        Return True for success, False for failure; on failure, an
        error is sent back.

        """
        self.command = None  # set in case of error on the first line
        self.request_version = version = self.default_request_version
        self.close_connection = True
        requestline = str(self.raw_requestline, 'iso-8859-1')
        requestline = requestline.rstrip('\r\n')
        self.requestline = requestline
        words = requestline.split()
        if len(words) == 3:
            command, path, version = words
            if version[:5] != 'HTTP/':
                self.send_error(
                    HTTPStatus.BAD_REQUEST,
                    "Bad request version (%r)" % version)
                return False
            try:
                base_version_number = version.split('/', 1)[1]
                version_number = base_version_number.split(".")
                # RFC 2145 section 3.1 says there can be only one "." and
                #   - major and minor numbers MUST be treated as
                #      separate integers;
                #   - HTTP/2.4 is a lower version than HTTP/2.13, which in
                #      turn is lower than HTTP/12.3;
                #   - Leading zeros MUST be ignored by recipients.
                if len(version_number) != 2:
                    raise ValueError
                version_number = int(version_number[0]), int(version_number[1])
            except (ValueError, IndexError):
                self.send_error(
                    HTTPStatus.BAD_REQUEST,
                    "Bad request version (%r)" % version)
                return False
            if version_number >= (1, 1) and self.protocol_version >= "HTTP/1.1":
                self.close_connection = False
            if version_number >= (2, 0):
                self.send_error(
                    HTTPStatus.HTTP_VERSION_NOT_SUPPORTED,
                    "Invalid HTTP Version (%s)" % base_version_number)
                return False
        elif len(words) == 2:
            command, path = words
            self.close_connection = True
            if command != 'GET':
                self.send_error(
                    HTTPStatus.BAD_REQUEST,
                    "Bad HTTP/0.9 request type (%r)" % command)
                return False
        elif not words:
            return False
        else:
            self.send_error(
                HTTPStatus.BAD_REQUEST,
                "Bad request syntax (%r)" % requestline)
            return False
        self.command, self.path, self.request_version = command, path, version

        # Examine the headers and look for a Connection directive.
        try:
            self.headers = http.client.parse_headers(self.rfile,
                                                     _class=self.MessageClass)
        except http.client.LineTooLong:
            self.send_error(
                HTTPStatus.BAD_REQUEST,
                "Line too long")
            return False
        except http.client.HTTPException as err:
            self.send_error(
                HTTPStatus.REQUEST_HEADER_FIELDS_TOO_LARGE,
                "Too many headers",
                str(err)
            )
            return False

        conntype = self.headers.get('Connection', "")
        if conntype.lower() == 'close':
            self.close_connection = True
        elif (conntype.lower() == 'keep-alive' and
              self.protocol_version >= "HTTP/1.1"):
            self.close_connection = False
        # Examine the headers and look for an Expect directive
        expect = self.headers.get('Expect', "")
        if (expect.lower() == "100-continue" and
                self.protocol_version >= "HTTP/1.1" and
                self.request_version >= "HTTP/1.1"):
            if not self.handle_expect_100():
                return False
        return True

    def handle_expect_100(self):
        """Decide what to do with an "Expect: 100-continue" header.

        If the client is expecting a 100 Continue response, we must
        respond with either a 100 Continue or a final response before
        waiting for the request body. The default is to always respond
        with a 100 Continue. You can behave differently (for example,
        reject unauthorized requests) by overriding this method.

        This method should either return True (possibly after sending
        a 100 Continue response) or send an error response and return
        False.

        """
        self.send_response_only(HTTPStatus.CONTINUE)
        self.end_headers()
        return True

    def handle_one_request(self):
        """Handle a single HTTP request.

        You normally don't need to override this method; see the class
        __doc__ string for information on how to handle specific HTTP
        commands such as GET and POST.

        """
        try:
            self.raw_requestline = self.rfile.readline(65537)
            if len(self.raw_requestline) > 65536:
                self.requestline = ''
                self.request_version = ''
                self.command = ''
                self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)
                return
            if not self.raw_requestline:
                self.close_connection = True
                return
            if not self.parse_request():
                # An error code has been sent, just exit
                return
            mname = 'do_' + self.command
            if not hasattr(self, mname):
                self.send_error(
                    HTTPStatus.NOT_IMPLEMENTED,
                    "Unsupported method (%r)" % self.command)
                return
            method = getattr(self, mname)
            method()
            self.wfile.flush() #actually send the response if not already done.
        except socket.timeout as e:
            #a read or a write timed out.  Discard this connection
            self.log_error("Request timed out: %r", e)
            self.close_connection = True
            return

    def handle(self):
        """Handle multiple requests if necessary."""
        self.close_connection = True

        self.handle_one_request()
        while not self.close_connection:
            self.handle_one_request()

    def send_error(self, code, message=None, explain=None):
        """Send and log an error reply.

        Arguments are
        * code:    an HTTP error code
                   3 digits
        * message: a simple optional 1 line reason phrase.
                   *( HTAB / SP / VCHAR / %x80-FF )
                   defaults to short entry matching the response code
        * explain: a detailed message defaults to the long entry
                   matching the response code.

        This sends an error response (so it must be called before any
        output has been generated), logs the error, and finally sends
        a piece of HTML explaining the error to the user.

        """

        try:
            shortmsg, longmsg = self.responses[code]
        except KeyError:
            shortmsg, longmsg = '???', '???'
        if message is None:
            message = shortmsg
        if explain is None:
            explain = longmsg
        self.log_error("code %d, message %s", code, message)
        self.send_response(code, message)
        self.send_header('Connection', 'close')

        # Message body is omitted for cases described in:
        #  - RFC7230: 3.3. 1xx, 204(No Content), 304(Not Modified)
        #  - RFC7231: 6.3.6. 205(Reset Content)
        body = None
        if (code >= 200 and
            code not in (HTTPStatus.NO_CONTENT,
                         HTTPStatus.RESET_CONTENT,
                         HTTPStatus.NOT_MODIFIED)):
            # HTML encode to prevent Cross Site Scripting attacks
            # (see bug #1100201)
            content = (self.error_message_format % {
                'code': code,
                'message': _quote_html(message),
                'explain': _quote_html(explain)
            })
            body = content.encode('UTF-8', 'replace')
            self.send_header("Content-Type", self.error_content_type)
            self.send_header('Content-Length', int(len(body)))
        self.end_headers()

        if self.command != 'HEAD' and body:
            self.wfile.write(body)

    def send_response(self, code, message=None):
        """Add the response header to the headers buffer and log the
        response code.

        Also send two standard headers with the server software
        version and the current date.

        """
        self.log_request(code)
        self.send_response_only(code, message)
        self.send_header('Server', self.version_string())
        self.send_header('Date', self.date_time_string())

    def send_response_only(self, code, message=None):
        """Send the response header only."""
        if message is None:
            if code in self.responses:
                message = self.responses[code][0]
            else:
                message = ''
        if self.request_version != 'HTTP/0.9':
            if not hasattr(self, '_headers_buffer'):
                self._headers_buffer = []
            self._headers_buffer.append(("%s %d %s\r\n" %
                    (self.protocol_version, code, message)).encode(
                        'latin-1', 'strict'))

    def send_header(self, keyword, value):
        """Send a MIME header to the headers buffer."""
        if self.request_version != 'HTTP/0.9':
            if not hasattr(self, '_headers_buffer'):
                self._headers_buffer = []
            self._headers_buffer.append(
                ("%s: %s\r\n" % (keyword, value)).encode('latin-1', 'strict'))

        if keyword.lower() == 'connection':
            if value.lower() == 'close':
                self.close_connection = True
            elif value.lower() == 'keep-alive':
                self.close_connection = False

    def end_headers(self):
        """Send the blank line ending the MIME headers."""
        if self.request_version != 'HTTP/0.9':
            self._headers_buffer.append(b"\r\n")
            self.flush_headers()

    def flush_headers(self):
        if hasattr(self, '_headers_buffer'):
            self.wfile.write(b"".join(self._headers_buffer))
            self._headers_buffer = []

    def log_request(self, code='-', size='-'):
        """Log an accepted request.

        This is called by send_response().

        """
        if isinstance(code, HTTPStatus):
            code = code.value
        self.log_message('"%s" %s %s',
                         self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        """Log an error.

        This is called when a request cannot be fulfilled.  By
        default it passes the message on to log_message().

        Arguments are the same as for log_message().

        XXX This should go to the separate error log.

        """

        self.log_message(format, *args)

    def log_message(self, format, *args):
        """Log an arbitrary message.

        This is used by all other logging functions.  Override
        it if you have specific logging wishes.

        The first argument, FORMAT, is a format string for the
        message to be logged.  If the format string contains
        any % escapes requiring parameters, they should be
        specified as subsequent arguments (it's just like
        printf!).

        The client ip and current date/time are prefixed to
        every message.

        """

        sys.stderr.write("%s - - [%s] %s\n" %
                         (self.address_string(),
                          self.log_date_time_string(),
                          format%args))

    def version_string(self):
        """Return the server software version string."""
        return self.server_version + ' ' + self.sys_version

    def date_time_string(self, timestamp=None):
        """Return the current date and time formatted for a message header."""
        if timestamp is None:
            timestamp = time.time()
        year, month, day, hh, mm, ss, wd, y, z = time.gmtime(timestamp)
        s = "%s, %02d %3s %4d %02d:%02d:%02d GMT" % (
                self.weekdayname[wd],
                day, self.monthname[month], year,
                hh, mm, ss)
        return s

    def log_date_time_string(self):
        """Return the current time formatted for logging."""
        now = time.time()
        year, month, day, hh, mm, ss, x, y, z = time.localtime(now)
        s = "%02d/%3s/%04d %02d:%02d:%02d" % (
                day, self.monthname[month], year, hh, mm, ss)
        return s

    weekdayname = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

    monthname = [None,
                 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

    def address_string(self):
        """Return the client address."""

        return self.client_address[0]

    # Essentially static class variables

    # The version of the HTTP protocol we support.
    # Set this to HTTP/1.1 to enable automatic keepalive
    protocol_version = "HTTP/1.0"

    # MessageClass used to parse headers
    MessageClass = http.client.HTTPMessage

    # hack to maintain backwards compatibility
    responses = {
        v: (v.phrase, v.description)
        for v in HTTPStatus.__members__.values()
    }


class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):

    """Simple HTTP request handler with GET and HEAD commands.

    This serves files from the current directory and any of its
    subdirectories.  The MIME type for files is determined by
    calling the .guess_type() method.

    The GET and HEAD requests are identical except that the HEAD
    request omits the actual contents of the file.

    """

    server_version = "SimpleHTTP/" + __version__

    def do_GET(self):
        """Serve a GET request."""
        f = self.send_head()
        if f:
            try:
                self.copyfile(f, self.wfile)
            finally:
                f.close()

    def do_HEAD(self):
        """Serve a HEAD request."""
        f = self.send_head()
        if f:
            f.close()

    def send_head(self):
        """Common code for GET and HEAD commands.

        This sends the response code and MIME headers.

        Return value is either a file object (which has to be copied
        to the outputfile by the caller unless the command was HEAD,
        and must be closed by the caller under all circumstances), or
        None, in which case the caller has nothing further to do.

        """
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            parts = urllib.parse.urlsplit(self.path)
            if not parts.path.endswith('/'):
                # redirect browser - doing basically what apache does
                self.send_response(HTTPStatus.MOVED_PERMANENTLY)
                new_parts = (parts[0], parts[1], parts[2] + '/',
                             parts[3], parts[4])
                new_url = urllib.parse.urlunsplit(new_parts)
                self.send_header("Location", new_url)
                self.end_headers()
                return None
            for index in "index.html", "index.htm":
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)
        ctype = self.guess_type(path)
        try:
            f = open(path, 'rb')
        except OSError:
            self.send_error(HTTPStatus.NOT_FOUND, "File not found")
            return None
        try:
            self.send_response(HTTPStatus.OK)
            self.send_header("Content-type", ctype)
            fs = os.fstat(f.fileno())
            self.send_header("Content-Length", str(fs[6]))
            self.send_header("Last-Modified", self.date_time_string(fs.st_mtime))
            self.end_headers()
            return f
        except:
            f.close()
            raise

    def list_directory(self, path):
        """Helper to produce a directory listing (absent index.html).

        Return value is either a file object, or None (indicating an
        error).  In either case, the headers are sent, making the
        interface the same as for send_head().

        """
        try:
            list = os.listdir(path)
        except OSError:
            self.send_error(
                HTTPStatus.NOT_FOUND,
                "No permission to list directory")
            return None
        list.sort(key=lambda a: a.lower())
        r = []
        try:
            displaypath = urllib.parse.unquote(self.path,
                                               errors='surrogatepass')
        except UnicodeDecodeError:
            displaypath = urllib.parse.unquote(path)
        displaypath = html.escape(displaypath)
        enc = sys.getfilesystemencoding()
        title = 'Directory listing for %s' % displaypath
        r.append('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '
                 '"http://www.w3.org/TR/html4/strict.dtd">')
        r.append('<html>\n<head>')
        r.append('<meta http-equiv="Content-Type" '
                 'content="text/html; charset=%s">' % enc)
        r.append('<title>%s</title>\n</head>' % title)
        r.append('<body>\n<h1>%s</h1>' % title)
        r.append('<hr>\n<ul>')
        for name in list:
            fullname = os.path.join(path, name)
            displayname = linkname = name
            # Append / for directories or @ for symbolic links
            if os.path.isdir(fullname):
                displayname = name + "/"
                linkname = name + "/"
            if os.path.islink(fullname):
                displayname = name + "@"
                # Note: a link to a directory displays with @ and links with /
            r.append('<li><a href="%s">%s</a></li>'
                    % (urllib.parse.quote(linkname,
                                          errors='surrogatepass'),
                       html.escape(displayname)))
        r.append('</ul>\n<hr>\n</body>\n</html>\n')
        encoded = '\n'.join(r).encode(enc, 'surrogateescape')
        f = io.BytesIO()
        f.write(encoded)
        f.seek(0)
        self.send_response(HTTPStatus.OK)
        self.send_header("Content-type", "text/html; charset=%s" % enc)
        self.send_header("Content-Length", str(len(encoded)))
        self.end_headers()
        return f

    def translate_path(self, path):
        """Translate a /-separated PATH to the local filename syntax.

        Components that mean special things to the local file system
        (e.g. drive or directory names) are ignored.  (XXX They should
        probably be diagnosed.)

        """
        # abandon query parameters
        path = path.split('?',1)[0]
        path = path.split('#',1)[0]
        # Don't forget explicit trailing slash when normalizing. Issue17324
        trailing_slash = path.rstrip().endswith('/')
        try:
            path = urllib.parse.unquote(path, errors='surrogatepass')
        except UnicodeDecodeError:
            path = urllib.parse.unquote(path)
        path = posixpath.normpath(path)
        words = path.split('/')
        words = filter(None, words)
        path = os.getcwd()
        for word in words:
            if os.path.dirname(word) or word in (os.curdir, os.pardir):
                # Ignore components that are not a simple file/directory name
                continue
            path = os.path.join(path, word)
        if trailing_slash:
            path += '/'
        return path

    def copyfile(self, source, outputfile):
        """Copy all data between two file objects.

        The SOURCE argument is a file object open for reading
        (or anything with a read() method) and the DESTINATION
        argument is a file object open for writing (or
        anything with a write() method).

        The only reason for overriding this would be to change
        the block size or perhaps to replace newlines by CRLF
        -- note however that this the default server uses this
        to copy binary data as well.

        """
        shutil.copyfileobj(source, outputfile)

    def guess_type(self, path):
        """Guess the type of a file.

        Argument is a PATH (a filename).

        Return value is a string of the form type/subtype,
        usable for a MIME Content-type header.

        The default implementation looks the file's extension
        up in the table self.extensions_map, using application/octet-stream
        as a default; however it would be permissible (if
        slow) to look inside the data to make a better guess.

        """

        base, ext = posixpath.splitext(path)
        if ext in self.extensions_map:
            return self.extensions_map[ext]
        ext = ext.lower()
        if ext in self.extensions_map:
            return self.extensions_map[ext]
        else:
            return self.extensions_map['']

    if not mimetypes.inited:
        mimetypes.init() # try to read system mime.types
    extensions_map = mimetypes.types_map.copy()
    extensions_map.update({
        '': 'application/octet-stream', # Default
        '.py': 'text/plain',
        '.c': 'text/plain',
        '.h': 'text/plain',
        })


# Utilities for CGIHTTPRequestHandler

def _url_collapse_path(path):
    """
    Given a URL path, remove extra '/'s and '.' path elements and collapse
    any '..' references and returns a collapsed path.

    Implements something akin to RFC-2396 5.2 step 6 to parse relative paths.
    The utility of this function is limited to is_cgi method and helps
    preventing some security attacks.

    Returns: The reconstituted URL, which will always start with a '/'.

    Raises: IndexError if too many '..' occur within the path.

    """
    # Query component should not be involved.
    path, _, query = path.partition('?')
    path = urllib.parse.unquote(path)

    # Similar to os.path.split(os.path.normpath(path)) but specific to URL
    # path semantics rather than local operating system semantics.
    path_parts = path.split('/')
    head_parts = []
    for part in path_parts[:-1]:
        if part == '..':
            head_parts.pop() # IndexError if more '..' than prior parts
        elif part and part != '.':
            head_parts.append( part )
    if path_parts:
        tail_part = path_parts.pop()
        if tail_part:
            if tail_part == '..':
                head_parts.pop()
                tail_part = ''
            elif tail_part == '.':
                tail_part = ''
    else:
        tail_part = ''

    if query:
        tail_part = '?'.join((tail_part, query))

    splitpath = ('/' + '/'.join(head_parts), tail_part)
    collapsed_path = "/".join(splitpath)

    return collapsed_path



nobody = None

def nobody_uid():
    """Internal routine to get nobody's uid"""
    global nobody
    if nobody:
        return nobody
    try:
        import pwd
    except ImportError:
        return -1
    try:
        nobody = pwd.getpwnam('nobody')[2]
    except KeyError:
        nobody = 1 + max(x[2] for x in pwd.getpwall())
    return nobody


def executable(path):
    """Test for executable file."""
    return os.access(path, os.X_OK)


class CGIHTTPRequestHandler(SimpleHTTPRequestHandler):

    """Complete HTTP server with GET, HEAD and POST commands.

    GET and HEAD also support running CGI scripts.

    The POST command is *only* implemented for CGI scripts.

    """

    # Determine platform specifics
    have_fork = hasattr(os, 'fork')

    # Make rfile unbuffered -- we need to read one line and then pass
    # the rest to a subprocess, so we can't use buffered input.
    rbufsize = 0

    def do_POST(self):
        """Serve a POST request.

        This is only implemented for CGI scripts.

        """

        if self.is_cgi():
            self.run_cgi()
        else:
            self.send_error(
                HTTPStatus.NOT_IMPLEMENTED,
                "Can only POST to CGI scripts")

    def send_head(self):
        """Version of send_head that support CGI scripts"""
        if self.is_cgi():
            return self.run_cgi()
        else:
            return SimpleHTTPRequestHandler.send_head(self)

    def is_cgi(self):
        """Test whether self.path corresponds to a CGI script.

        Returns True and updates the cgi_info attribute to the tuple
        (dir, rest) if self.path requires running a CGI script.
        Returns False otherwise.

        If any exception is raised, the caller should assume that
        self.path was rejected as invalid and act accordingly.

        The default implementation tests whether the normalized url
        path begins with one of the strings in self.cgi_directories
        (and the next character is a '/' or the end of the string).

        """
        collapsed_path = _url_collapse_path(self.path)
        dir_sep = collapsed_path.find('/', 1)
        head, tail = collapsed_path[:dir_sep], collapsed_path[dir_sep+1:]
        if head in self.cgi_directories:
            self.cgi_info = head, tail
            return True
        return False


    cgi_directories = ['/cgi-bin', '/htbin']

    def is_executable(self, path):
        """Test whether argument path is an executable file."""
        return executable(path)

    def is_python(self, path):
        """Test whether argument path is a Python script."""
        head, tail = os.path.splitext(path)
        return tail.lower() in (".py", ".pyw")

    def run_cgi(self):
        """Execute a CGI script."""
        dir, rest = self.cgi_info
        path = dir + '/' + rest
        i = path.find('/', len(dir)+1)
        while i >= 0:
            nextdir = path[:i]
            nextrest = path[i+1:]

            scriptdir = self.translate_path(nextdir)
            if os.path.isdir(scriptdir):
                dir, rest = nextdir, nextrest
                i = path.find('/', len(dir)+1)
            else:
                break

        # find an explicit query string, if present.
        rest, _, query = rest.partition('?')

        # dissect the part after the directory name into a script name &
        # a possible additional path, to be stored in PATH_INFO.
        i = rest.find('/')
        if i >= 0:
            script, rest = rest[:i], rest[i:]
        else:
            script, rest = rest, ''

        scriptname = dir + '/' + script
        scriptfile = self.translate_path(scriptname)
        if not os.path.exists(scriptfile):
            self.send_error(
                HTTPStatus.NOT_FOUND,
                "No such CGI script (%r)" % scriptname)
            return
        if not os.path.isfile(scriptfile):
            self.send_error(
                HTTPStatus.FORBIDDEN,
                "CGI script is not a plain file (%r)" % scriptname)
            return
        ispy = self.is_python(scriptname)
        if self.have_fork or not ispy:
            if not self.is_executable(scriptfile):
                self.send_error(
                    HTTPStatus.FORBIDDEN,
                    "CGI script is not executable (%r)" % scriptname)
                return

        # Reference: http://hoohoo.ncsa.uiuc.edu/cgi/env.html
        # XXX Much of the following could be prepared ahead of time!
        env = copy.deepcopy(os.environ)
        env['SERVER_SOFTWARE'] = self.version_string()
        env['SERVER_NAME'] = self.server.server_name
        env['GATEWAY_INTERFACE'] = 'CGI/1.1'
        env['SERVER_PROTOCOL'] = self.protocol_version
        env['SERVER_PORT'] = str(self.server.server_port)
        env['REQUEST_METHOD'] = self.command
        uqrest = urllib.parse.unquote(rest)
        env['PATH_INFO'] = uqrest
        env['PATH_TRANSLATED'] = self.translate_path(uqrest)
        env['SCRIPT_NAME'] = scriptname
        if query:
            env['QUERY_STRING'] = query
        env['REMOTE_ADDR'] = self.client_address[0]
        authorization = self.headers.get("authorization")
        if authorization:
            authorization = authorization.split()
            if len(authorization) == 2:
                import base64, binascii
                env['AUTH_TYPE'] = authorization[0]
                if authorization[0].lower() == "basic":
                    try:
                        authorization = authorization[1].encode('ascii')
                        authorization = base64.decodebytes(authorization).\
                                        decode('ascii')
                    except (binascii.Error, UnicodeError):
                        pass
                    else:
                        authorization = authorization.split(':')
                        if len(authorization) == 2:
                            env['REMOTE_USER'] = authorization[0]
        # XXX REMOTE_IDENT
        if self.headers.get('content-type') is None:
            env['CONTENT_TYPE'] = self.headers.get_content_type()
        else:
            env['CONTENT_TYPE'] = self.headers['content-type']
        length = self.headers.get('content-length')
        if length:
            env['CONTENT_LENGTH'] = length
        referer = self.headers.get('referer')
        if referer:
            env['HTTP_REFERER'] = referer
        accept = []
        for line in self.headers.getallmatchingheaders('accept'):
            if line[:1] in "\t\n\r ":
                accept.append(line.strip())
            else:
                accept = accept + line[7:].split(',')
        env['HTTP_ACCEPT'] = ','.join(accept)
        ua = self.headers.get('user-agent')
        if ua:
            env['HTTP_USER_AGENT'] = ua
        co = filter(None, self.headers.get_all('cookie', []))
        cookie_str = ', '.join(co)
        if cookie_str:
            env['HTTP_COOKIE'] = cookie_str
        # XXX Other HTTP_* headers
        # Since we're setting the env in the parent, provide empty
        # values to override previously set values
        for k in ('QUERY_STRING', 'REMOTE_HOST', 'CONTENT_LENGTH',
                  'HTTP_USER_AGENT', 'HTTP_COOKIE', 'HTTP_REFERER'):
            env.setdefault(k, "")

        self.send_response(HTTPStatus.OK, "Script output follows")
        self.flush_headers()

        decoded_query = query.replace('+', ' ')

        if self.have_fork:
            # Unix -- fork as we should
            args = [script]
            if '=' not in decoded_query:
                args.append(decoded_query)
            nobody = nobody_uid()
            self.wfile.flush() # Always flush before forking
            pid = os.fork()
            if pid != 0:
                # Parent
                pid, sts = os.waitpid(pid, 0)
                # throw away additional data [see bug #427345]
                while select.select([self.rfile], [], [], 0)[0]:
                    if not self.rfile.read(1):
                        break
                if sts:
                    self.log_error("CGI script exit status %#x", sts)
                return
            # Child
            try:
                try:
                    os.setuid(nobody)
                except OSError:
                    pass
                os.dup2(self.rfile.fileno(), 0)
                os.dup2(self.wfile.fileno(), 1)
                os.execve(scriptfile, args, env)
            except:
                self.server.handle_error(self.request, self.client_address)
                os._exit(127)

        else:
            # Non-Unix -- use subprocess
            import subprocess
            cmdline = [scriptfile]
            if self.is_python(scriptfile):
                interp = sys.executable
                if interp.lower().endswith("w.exe"):
                    # On Windows, use python.exe, not pythonw.exe
                    interp = interp[:-5] + interp[-4:]
                cmdline = [interp, '-u'] + cmdline
            if '=' not in query:
                cmdline.append(query)
            self.log_message("command: %s", subprocess.list2cmdline(cmdline))
            try:
                nbytes = int(length)
            except (TypeError, ValueError):
                nbytes = 0
            p = subprocess.Popen(cmdline,
                                 stdin=subprocess.PIPE,
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE,
                                 env = env
                                 )
            if self.command.lower() == "post" and nbytes > 0:
                data = self.rfile.read(nbytes)
            else:
                data = None
            # throw away additional data [see bug #427345]
            while select.select([self.rfile._sock], [], [], 0)[0]:
                if not self.rfile._sock.recv(1):
                    break
            stdout, stderr = p.communicate(data)
            self.wfile.write(stdout)
            if stderr:
                self.log_error('%s', stderr)
            p.stderr.close()
            p.stdout.close()
            status = p.returncode
            if status:
                self.log_error("CGI script exit status %#x", status)
            else:
                self.log_message("CGI script exited OK")


def test(HandlerClass=BaseHTTPRequestHandler,
         ServerClass=HTTPServer, protocol="HTTP/1.0", port=8000, bind=""):
    """Test the HTTP request handler class.

    This runs an HTTP server on port 8000 (or the port argument).

    """
    server_address = (bind, port)

    HandlerClass.protocol_version = protocol
    httpd = ServerClass(server_address, HandlerClass)

    sa = httpd.socket.getsockname()
    print("Serving HTTP on", sa[0], "port", sa[1], "...")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nKeyboard interrupt received, exiting.")
        httpd.server_close()
        sys.exit(0)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--cgi', action='store_true',
                       help='Run as CGI Server')
    parser.add_argument('--bind', '-b', default='', metavar='ADDRESS',
                        help='Specify alternate bind address '
                             '[default: all interfaces]')
    parser.add_argument('port', action='store',
                        default=8000, type=int,
                        nargs='?',
                        help='Specify alternate port [default: 8000]')
    args = parser.parse_args()
    if args.cgi:
        handler_class = CGIHTTPRequestHandler
    else:
        handler_class = SimpleHTTPRequestHandler
    test(HandlerClass=handler_class, port=args.port, bind=args.bind)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
ì≠[A  „               @   s3   d  d l  m Z d g Z Gd d Ñ  d e É Z d S)È    )⁄IntEnum⁄
HTTPStatusc               @   s{  e  Z d  Z d Z d d d Ñ Z d£ Z d§ Z d• Z d¶ Z dß Z	 d® Z
 d© Z d™ Z d´ Z d¨ Z d≠ Z dÆ Z dØ Z d∞ Z d± Z d≤ Z d≥ Z d¥ Z dµ Z d∂ Z d∑ Z d∏ Z dπ Z d∫ Z dª Z dº Z dΩ Z dæ Z  dø Z! d¿ Z" d¡ Z# d¬ Z$ d√ Z% dƒ Z& d≈ Z' d∆ Z( d« Z) d» Z* d… Z+ d  Z, dÀ Z- dÃ Z. dÕ Z/ dŒ Z0 dœ Z1 d– Z2 d— Z3 d“ Z4 d” Z5 d‘ Z6 d’ Z7 d÷ Z8 d◊ Z9 dÿ Z: dŸ Z; d⁄ Z< d€ Z= d¢ S)‹r   a  HTTP status codes and reason phrases

    Status codes from the following RFCs are all observed:

        * RFC 7231: Hypertext Transfer Protocol (HTTP/1.1), obsoletes 2616
        * RFC 6585: Additional HTTP Status Codes
        * RFC 3229: Delta encoding in HTTP
        * RFC 4918: HTTP Extensions for WebDAV, obsoletes 2518
        * RFC 5842: Binding Extensions to WebDAV
        * RFC 7238: Permanent Redirect
        * RFC 2295: Transparent Content Negotiation in HTTP
        * RFC 2774: An HTTP Extension Framework
    ⁄ c             C   s1   t  j |  | É } | | _ | | _ | | _ | S)N)⁄int⁄__new__Z_value_⁄phrase⁄description)⁄cls⁄valuer   r   ⁄obj© r   ˙#/usr/lib/python3.5/http/__init__.pyr      s
    			zHTTPStatus.__new__Èd   ⁄Continue˙!Request received, please continueÈe   ˙Switching Protocols˙.Switching to new protocol; obey Upgrade headerÈf   ⁄
ProcessingÈ»   ⁄OK˙#Request fulfilled, document followsÈ…   ⁄Created˙Document created, URL followsÈ    ⁄Accepted˙/Request accepted, processing continues off-lineÈÀ   ˙Non-Authoritative Information˙Request fulfilled from cacheÈÃ   ˙
No Content˙"Request fulfilled, nothing followsÈÕ   ˙Reset Content˙"Clear input form for further inputÈŒ   ˙Partial Content˙Partial content followsÈœ   ˙Multi-StatusÈ–   ˙Already ReportedÈ‚   ˙IM UsedÈ,  ˙Multiple Choices˙,Object has several resources -- see URI listÈ-  ˙Moved Permanently˙(Object moved permanently -- see URI listÈ.  ⁄Found˙(Object moved temporarily -- see URI listÈ/  ˙	See Other˙'Object moved -- see Method and URL listÈ0  ˙Not Modified˙)Document has not changed since given timeÈ1  ˙	Use Proxy˙@You must use proxy specified in Location to access this resourceÈ3  ˙Temporary RedirectÈ4  ˙Permanent RedirectÈê  ˙Bad Request˙(Bad request syntax or unsupported methodÈë  ⁄Unauthorized˙*No permission -- see authorization schemesÈí  ˙Payment Required˙"No payment -- see charging schemesÈì  ⁄	Forbidden˙0Request forbidden -- authorization will not helpÈî  ˙	Not Found˙Nothing matches the given URIÈï  ˙Method Not Allowed˙-Specified method is invalid for this resourceÈñ  ˙Not Acceptable˙%URI not available in preferred formatÈó  ˙Proxy Authentication Required˙7You must authenticate with this proxy before proceedingÈò  ˙Request Timeout˙"Request timed out; try again laterÈô  ⁄Conflict˙Request conflictÈö  ⁄Gone˙5URI no longer exists and has been permanently removedÈõ  ˙Length Required˙"Client must specify Content-LengthÈú  ˙Precondition Failed˙ Precondition in headers is falseÈù  ˙Request Entity Too Large˙Entity is too largeÈû  ˙Request-URI Too Long˙URI is too longÈü  ˙Unsupported Media Type˙!Entity body in unsupported formatÈ†  ˙Requested Range Not Satisfiable˙Cannot satisfy request rangeÈ°  ˙Expectation Failed˙'Expect condition could not be satisfiedÈ¶  ˙Unprocessable EntityÈß  ⁄LockedÈ®  ˙Failed DependencyÈ™  ˙Upgrade RequiredÈ¨  ˙Precondition Required˙8The origin server requires the request to be conditionalÈ≠  ˙Too Many Requests˙OThe user has sent too many requests in a given amount of time ("rate limiting")ÈØ  ˙Request Header Fields Too Large˙VThe server is unwilling to process the request because its header fields are too largeÈÙ  ˙Internal Server Error˙Server got itself in troubleÈı  ˙Not Implemented˙&Server does not support this operationÈˆ  ˙Bad Gateway˙+Invalid responses from another server/proxyÈ˜  ˙Service Unavailable˙8The server cannot process the request due to a high loadÈ¯  ˙Gateway Timeout˙4The gateway server did not receive a timely responseÈ˘  ˙HTTP Version Not Supported˙Cannot fulfill requestÈ˙  ˙Variant Also NegotiatesÈ˚  ˙Insufficient StorageÈ¸  ˙Loop DetectedÈ˛  ˙Not ExtendedÈˇ  ˙Network Authentication Required˙7The client needs to authenticate to gain network accessN)r   r   r   )r   r   r   )r   r   )r   r   r   )r   r   r   )r   r   r   )r   r    r!   )r"   r#   r$   )r%   r&   r'   )r(   r)   r*   )r+   r,   )r-   r.   )r/   r0   )r1   r2   r3   )r4   r5   r6   )r7   r8   r9   )r:   r;   r<   )r=   r>   r?   )r@   rA   rB   )rC   rD   r9   )rE   rF   r9   )rG   rH   rI   )rJ   rK   rL   )rM   rN   rO   )rP   rQ   rR   )rS   rT   rU   )rV   rW   rX   )rY   rZ   r[   )r\   r]   r^   )r_   r`   ra   )rb   rc   rd   )re   rf   rg   )rh   ri   rj   )rk   rl   rm   )rn   ro   rp   )rq   rr   rs   )rt   ru   rv   )rw   rx   ry   )rz   r{   r|   )r}   r~   )r   rÄ   )rÅ   rÇ   )rÉ   rÑ   )rÖ   rÜ   rá   )rà   râ   rä   )rã   rå   rç   )ré   rè   rê   )rë   rí   rì   )rî   rï   rñ   )ró   rò   rô   )rö   rõ   rú   )rù   rû   rü   )r†   r°   )r¢   r£   )r§   r•   )r¶   rß   )r®   r©   r™   )>⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   ZCONTINUEZSWITCHING_PROTOCOLSZ
PROCESSINGr   ZCREATEDZACCEPTEDZNON_AUTHORITATIVE_INFORMATIONZ
NO_CONTENTZRESET_CONTENTZPARTIAL_CONTENTZMULTI_STATUSZALREADY_REPORTEDZIM_USEDZMULTIPLE_CHOICESZMOVED_PERMANENTLYZFOUNDZ	SEE_OTHERZNOT_MODIFIEDZ	USE_PROXYZTEMPORARY_REDIRECTZPERMANENT_REDIRECTZBAD_REQUESTZUNAUTHORIZEDZPAYMENT_REQUIREDZ	FORBIDDENZ	NOT_FOUNDZMETHOD_NOT_ALLOWEDZNOT_ACCEPTABLEZPROXY_AUTHENTICATION_REQUIREDZREQUEST_TIMEOUTZCONFLICTZGONEZLENGTH_REQUIREDZPRECONDITION_FAILEDZREQUEST_ENTITY_TOO_LARGEZREQUEST_URI_TOO_LONGZUNSUPPORTED_MEDIA_TYPEZREQUESTED_RANGE_NOT_SATISFIABLEZEXPECTATION_FAILEDZUNPROCESSABLE_ENTITYZLOCKEDZFAILED_DEPENDENCYZUPGRADE_REQUIREDZPRECONDITION_REQUIREDZTOO_MANY_REQUESTSZREQUEST_HEADER_FIELDS_TOO_LARGEZINTERNAL_SERVER_ERRORZNOT_IMPLEMENTEDZBAD_GATEWAYZSERVICE_UNAVAILABLEZGATEWAY_TIMEOUTZHTTP_VERSION_NOT_SUPPORTEDZVARIANT_ALSO_NEGOTIATESZINSUFFICIENT_STORAGEZLOOP_DETECTEDZNOT_EXTENDEDZNETWORK_AUTHENTICATION_REQUIREDr   r   r   r   r      s∆   	                                        N)Zenumr   ⁄__all__r   r   r   r   r   ⁄<module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
ì≠[eæ  „               @   s?  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 m Z d d d d d d	 d
 d d d d d d d d d d d g Z d Z d Z d Z d Z d Z d Z e É  j e j j É d d Ñ  e j j j É  DÉ Z d Z d Z d  Z e j d! É j Z e j d" É j Z  d# d$ d% h Z! d& d' d( Ñ Z" Gd) d* Ñ  d* e j# j$ É Z% e% d+ d, Ñ Z& Gd- d Ñ  d e j' É Z( Gd. d Ñ  d É Z) y d d l* Z* Wn e+ k
 r⁄Yn$ XGd/ d0 Ñ  d0 e) É Z, e j- d0 É Gd1 d Ñ  d e. É Z/ Gd2 d Ñ  d e/ É Z0 Gd3 d Ñ  d e/ É Z1 Gd4 d Ñ  d e/ É Z2 Gd5 d	 Ñ  d	 e/ É Z3 Gd6 d
 Ñ  d
 e/ É Z4 Gd7 d Ñ  d e/ É Z5 Gd8 d Ñ  d e/ É Z6 Gd9 d Ñ  d e6 É Z7 Gd: d Ñ  d e6 É Z8 Gd; d Ñ  d e6 É Z9 Gd< d Ñ  d e/ É Z: Gd= d Ñ  d e/ É Z; Gd> d Ñ  d e< e: É Z= e/ Z> d S)?a¢
  HTTP/1.1 client library

<intro stuff goes here>
<other stuff, too>

HTTPConnection goes through a number of "states", which define when a client
may legally make another request or fetch the response for a particular
request. This diagram details these state transitions:

    (null)
      |
      | HTTPConnection()
      v
    Idle
      |
      | putrequest()
      v
    Request-started
      |
      | ( putheader() )*  endheaders()
      v
    Request-sent
      |\_____________________________
      |                              | getresponse() raises
      | response = getresponse()     | ConnectionError
      v                              v
    Unread-response                Idle
    [Response-headers-read]
      |\____________________
      |                     |
      | response.read()     | putrequest()
      v                     v
    Idle                  Req-started-unread-response
                     ______/|
                   /        |
   response.read() |        | ( putheader() )*  endheaders()
                   v        v
       Request-started    Req-sent-unread-response
                            |
                            | response.read()
                            v
                          Request-sent

This diagram presents the following rules:
  -- a second request may not be started until {response-headers-read}
  -- a response [object] cannot be retrieved until {request-sent}
  -- there is no differentiation between an unread response body and a
     partially read response body

Note: this enforcement is applied by the HTTPConnection class. The
      HTTPResponse class does not enforce this state machine, which
      implies sophisticated clients may accelerate the request/response
      pipeline. Caution should be taken, though: accelerating the states
      beyond the above pattern may imply knowledge of the server's
      connection-close behavior for certain requests. For example, it
      is impossible to tell whether the server will close the connection
      UNTIL the response headers have been read; this means that further
      requests cannot be placed into the pipeline until it is known that
      the server will NOT be closing the connection.

Logical State                  __state            __response
-------------                  -------            ----------
Idle                           _CS_IDLE           None
Request-started                _CS_REQ_STARTED    None
Request-sent                   _CS_REQ_SENT       None
Unread-response                _CS_IDLE           <response_class>
Req-started-unread-response    _CS_REQ_STARTED    <response_class>
Req-sent-unread-response       _CS_REQ_SENT       <response_class>
È    N)⁄urlsplit⁄HTTPResponse⁄HTTPConnection⁄HTTPException⁄NotConnected⁄UnknownProtocol⁄UnknownTransferEncoding⁄UnimplementedFileMode⁄IncompleteRead⁄
InvalidURL⁄ImproperConnectionState⁄CannotSendRequest⁄CannotSendHeader⁄ResponseNotReady⁄BadStatusLine⁄LineTooLong⁄RemoteDisconnected⁄error⁄	responsesÈP   iª  ZUNKNOWNZIdlezRequest-startedzRequest-sentc             C   s   i  |  ] } | j  | ì q S© )⁄phrase)⁄.0⁄vr   r   ˙!/usr/lib/python3.5/http/client.py˙
<dictcomp>k   s   	 r   i   i   Èd   s   [^:\s][^:\r\n]*s   \n(?![ \t])|\r(?![ \t\n])ZPATCHZPOSTZPUT⁄datac             C   sá   y |  j  d É SWno t k
 rÇ } zO t | j | j | j | j d | j É  |  | j | j Ö | f É d Ç WYd d } ~ Xn Xd S)z<Call data.encode("latin-1") but show a better error message.zlatin-1z`%s (%.20r) is not valid Latin-1. Use %s.encode('utf-8') if you want to send it encoded in UTF-8.N)⁄encode⁄UnicodeEncodeError⁄encoding⁄object⁄start⁄end⁄title)r   ⁄name⁄errr   r   r   ⁄_encodeï   s    r'   c               @   s   e  Z d  Z d d Ñ  Z d S)⁄HTTPMessagec             C   só   | j  É  d } t | É } g  } d } xh |  j É  D]Z } | d | Ö j  É  | k r` d } n | d d Ö j É  s| d } | r5 | j | É q5 W| S)a∫  Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.

        ˙:r   NÈ   )⁄lower⁄len⁄keys⁄isspace⁄append)⁄selfr%   ⁄nZlstZhit⁄liner   r   r   ⁄getallmatchingheaders´   s    
	z!HTTPMessage.getallmatchingheadersN)⁄__name__⁄
__module__⁄__qualname__r3   r   r   r   r   r(   §   s   r(   c             C   sÆ   g  } xq |  j  t d É } t | É t k r: t d É Ç | j | É t | É t k ri t d t É Ç | d	 k r	 Pq	 Wd j | É j d É } t	 j
 j d | É j | É S)
aG  Parses only RFC2822 headers from a file pointer.

    email Parser wants to see strings rather than bytes.
    But a TextIOWrapper around self.rfile would buffer too many bytes
    from the stream, bytes which we later need to read as bytes.
    So we read the correct bytes here, as bytes, for email Parser
    to parse.

    r*   zheader linezgot more than %d headersÛ   
Û   
Û    z
iso-8859-1⁄_class)r7   r8   r9   )⁄readline⁄_MAXLINEr,   r   r/   ⁄_MAXHEADERSr   ⁄join⁄decode⁄email⁄parserZParserZparsestr)⁄fpr:   ⁄headersr2   Zhstringr   r   r   ⁄parse_headers¬   s    
rD   c                   s¢  e  Z d  Z d d d d d Ñ Z d d Ñ  Z d d Ñ  Z d	 d
 Ñ  Z d d Ñ  Z á  f d d Ü  Z á  f d d Ü  Z	 d d Ñ  Z
 d d Ñ  Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d  Ñ  Z d! d" Ñ  Z d# d$ Ñ  Z d% d& Ñ  Z d@ d( d) Ñ Z dA d* d+ Ñ Z dB á  f d, d- Ü Z d. d/ Ñ  Z d0 d1 Ñ  Z d2 d3 Ñ  Z d d4 d5 Ñ Z d6 d7 Ñ  Z d8 d9 Ñ  Z d: d; Ñ  Z d< d= Ñ  Z d> d? Ñ  Z  á  S)Cr   r   Nc             C   sw   | j  d É |  _ | |  _ | |  _ d  |  _ |  _ t |  _ t |  _ t |  _	 t |  _
 t |  _ t |  _ t |  _ d  S)N⁄rb)ZmakefilerB   ⁄
debuglevel⁄_methodrC   ⁄msg⁄_UNKNOWN⁄version⁄status⁄reason⁄chunked⁄
chunk_left⁄length⁄
will_close)r0   ⁄sockrF   ⁄method⁄urlr   r   r   ⁄__init__„   s    								zHTTPResponse.__init__c             C   si  t  |  j j t d É d É } t | É t k r= t d É Ç |  j d k r_ t d t | É É | sq t	 d É Ç y | j
 d  d É \ } } } WnO t k
 r· y" | j
 d  d É \ } } d } Wn t k
 r‹ d } Yn XYn X| j d	 É s|  j É  t | É Ç y4 t | É } | d
 k  s.| d k r:t | É Ç Wn t k
 r[t | É Ç Yn X| | | f S)Nr*   z
iso-8859-1zstatus liner   zreply:z-Remote end closed connection without responseÈ   ⁄ zHTTP/r   iÁ  )⁄strrB   r;   r<   r,   r   rF   ⁄print⁄reprr   ⁄split⁄
ValueError⁄
startswith⁄_close_connr   ⁄int)r0   r2   rJ   rK   rL   r   r   r   ⁄_read_status  s2    

zHTTPResponse._read_statusc             C   s∏  |  j  d  k	 r d  Sxê |  j É  \ } } } | t k r8 Pxg |  j j t d É } t | É t k ro t d É Ç | j É  } | sÇ P|  j	 d k r; t
 d | É q; Wq W| |  _ |  _ | j É  |  _ | d k r› d |  _ n' | j d É r¯ d	 |  _ n t | É Ç t |  j É |  _  |  _ |  j	 d k rSx$ |  j  D] } t
 d | d
 d Éq6W|  j  j d É } | rí| j É  d k ríd |  _ d  |  _ n	 d |  _ |  j É  |  _ d  |  _ |  j  j d É } |  j  j d É } | r3|  j r3y t | É |  _ Wn t k
 rd  |  _ Yq<X|  j d k  r<d  |  _ n	 d  |  _ | t k s| t k sd | k okd k  n s|  j d k ràd |  _ |  j r¥|  j r¥|  j d  k r¥d |  _ d  S)Nr*   zheader liner   zheader:˙HTTP/1.0˙HTTP/0.9È
   zHTTP/1.È   r#   ˙ ztransfer-encodingrM   TFzcontent-lengthr   È»   ⁄HEAD)r`   ra   )rC   r_   ZCONTINUErB   r;   r<   r,   r   ⁄striprF   rX   ⁄coderK   rL   rJ   r\   r   rD   rH   ⁄getr+   rM   rN   ⁄_check_closerP   rO   r^   r[   Z
NO_CONTENTZNOT_MODIFIEDrG   )r0   rJ   rK   rL   ⁄skip⁄hdrZtr_encrO   r   r   r   ⁄begin"  sf    					

zHTTPResponse.beginc             C   s∑   |  j  j d É } |  j d k rS |  j  j d É } | rO d | j É  k rO d Sd S|  j  j d É ri d S| rÖ d | j É  k rÖ d S|  j  j d É } | r≥ d | j É  k r≥ d Sd S)NZ
connectionrc   ⁄closeTFz
keep-alivezproxy-connection)rC   ri   rJ   r+   )r0   ZconnZpconnr   r   r   rj   r  s    zHTTPResponse._check_closec             C   s    |  j  } d  |  _  | j É  d  S)N)rB   rn   )r0   rB   r   r   r   r]   ê  s    		zHTTPResponse._close_connc          
      s,   z t  É  j É  Wd  |  j r' |  j É  Xd  S)N)⁄superrn   rB   r]   )r0   )⁄	__class__r   r   rn   ï  s    	zHTTPResponse.closec                s'   t  É  j É  |  j r# |  j j É  d  S)N)ro   ⁄flushrB   )r0   )rp   r   r   rq   °  s    	zHTTPResponse.flushc             C   s   d S)NTr   )r0   r   r   r   ⁄readable¶  s    zHTTPResponse.readablec             C   s   |  j  d k S)z!True if the connection is closed.N)rB   )r0   r   r   r   ⁄isclosed´  s    zHTTPResponse.isclosedc             C   s¯   |  j  d  k r d S|  j d k r0 |  j É  d S| d  k	 rq t | É } |  j | É } t | É d  | Ö j É  S|  j rÑ |  j É  S|  j	 d  k r• |  j  j
 É  } nA y |  j |  j	 É } Wn t k
 r‹ |  j É  Ç  Yn Xd |  _	 |  j É  | Sd  S)Nr9   rf   r   )rB   rG   r]   ⁄	bytearray⁄readinto⁄
memoryview⁄tobytesrM   ⁄_readall_chunkedrO   ⁄read⁄
_safe_readr
   )r0   ⁄amt⁄br1   ⁄sr   r   r   ry   µ  s*    
	

	
zHTTPResponse.readc             C   s‰   |  j  d  k r d S|  j d k r0 |  j É  d S|  j rF |  j | É S|  j d  k	 rÉ t | É |  j k rÉ t | É d |  j Ö } |  j  j | É } | rØ | rØ |  j É  n1 |  j d  k	 r‡ |  j | 8_ |  j s‡ |  j É  | S)Nr   rf   )	rB   rG   r]   rM   ⁄_readinto_chunkedrO   r,   rv   ru   )r0   r|   r1   r   r   r   ru   ’  s$    
		
zHTTPResponse.readintoc             C   sñ   |  j  j t d É } t | É t k r4 t d É Ç | j d É } | d k r_ | d  | Ö } y t | d É SWn t k
 rë |  j É  Ç  Yn Xd  S)Nr*   z
chunk sizeÛ   ;r   È   )	rB   r;   r<   r,   r   ⁄findr^   r[   r]   )r0   r2   ⁄ir   r   r   ⁄_read_next_chunk_sizeÛ  s    
z"HTTPResponse._read_next_chunk_sizec             C   sS   xL |  j  j t d É } t | É t k r7 t d É Ç | s> P| d k r Pq Wd  S)Nr*   ztrailer lineÛ   
Û   
r9   )rÑ   rÖ   r9   )rB   r;   r<   r,   r   )r0   r2   r   r   r   ⁄_read_and_discard_trailer  s    z&HTTPResponse._read_and_discard_trailerc             C   så   |  j  } | sà | d  k	 r( |  j d É y |  j É  } Wn t k
 rX t d É Ç Yn X| d k r |  j É  |  j É  d  } | |  _  | S)NrU   r9   r   )rN   rz   rÉ   r[   r
   rÜ   r]   )r0   rN   r   r   r   ⁄_get_chunk_left  s    	

	zHTTPResponse._get_chunk_leftc             C   sô   |  j  t k s t Ç g  } yP x< |  j É  } | d  k r: P| j |  j | É É d |  _ q! Wd j | É SWn' t k
 rî t d j | É É Ç Yn Xd  S)Nr   r9   )	rM   rI   ⁄AssertionErrorrá   r/   rz   rN   r>   r
   )r0   ⁄valuerN   r   r   r   rx   )  s    zHTTPResponse._readall_chunkedc             C   s˚   |  j  t k s t Ç d } t | É } yü xò |  j É  } | d  k rI | St | É | k r |  j | É } | | |  _ | | S| d  | Ö } |  j | É } | | d  Ö } | | 7} d |  _ q- WWn. t k
 rˆ t t	 | d | Ö É É Ç Yn Xd  S)Nr   )
rM   rI   rà   rv   rá   r,   ⁄_safe_readintorN   r
   ⁄bytes)r0   r|   ⁄total_bytes⁄mvbrN   r1   ⁄temp_mvbr   r   r   r~   7  s&    
zHTTPResponse._readinto_chunkedc             C   s|   g  } xf | d k rn |  j  j t | t É É } | sN t d j | É | É Ç | j | É | t | É 8} q	 Wd j | É S)aV  Read the number of bytes requested, compensating for partial reads.

        Normally, we have a blocking socket, but a read() can be interrupted
        by a signal (resulting in a partial read).

        Note that we cannot distinguish between EOF and an interrupt when zero
        bytes have been read. IncompleteRead() will be raised in this
        situation.

        This function should be used when <amt> bytes "should" be present for
        reading. If the bytes are truly not available (due to EOF), then the
        IncompleteRead exception can be used to detect the problem.
        r   r9   )rB   ry   ⁄min⁄	MAXAMOUNTr
   r>   r/   r,   )r0   r{   r}   ⁄chunkr   r   r   rz   O  s    zHTTPResponse._safe_readc             C   sΩ   d } t  | É } x§ | t | É k  r∏ t t | É k  r^ | d t Ö } |  j j | É } n |  j j | É } | sõ t t | d | Ö É t | É É Ç | | d Ö } | | 7} q W| S)z2Same as _safe_read, but for reading into a buffer.r   N)rv   r,   rê   rB   ru   r
   rã   )r0   r|   rå   rç   ré   r1   r   r   r   rä   f  s    %zHTTPResponse._safe_readintor*   c             C   s˘   |  j  d k s |  j d k r" d S|  j r8 |  j | É S|  j d k	 rk | d k  sb | |  j k rk |  j } y |  j  j | É } Wn3 t k
 r∂ | d k r† Ç  |  j  j d É } Yn X| r— | r— |  j É  n$ |  j d k	 rı |  j t | É 8_ | S)zvRead with at most one underlying system call.  If at least one
        byte is buffered, return that instead.
        Nrf   r9   r   rÄ   i   i @  )	rB   rG   rM   ⁄_read1_chunkedrO   ⁄read1r[   r]   r,   )r0   r1   ⁄resultr   r   r   rì   v  s"    	*	zHTTPResponse.read1c             C   sH   |  j  d  k s |  j d k r" d S|  j r8 |  j | É S|  j  j | É S)Nrf   r9   )rB   rG   rM   ⁄_peek_chunked⁄peek)r0   r1   r   r   r   rñ   é  s
    	zHTTPResponse.peekc                s¬   |  j  d  k s |  j d k r" d S|  j r; t É  j | É S|  j d  k	 rn | d k  se | |  j k rn |  j } |  j  j | É } | rö | rö |  j É  n$ |  j d  k	 ræ |  j t | É 8_ | S)Nrf   r9   r   )rB   rG   rM   ro   r;   rO   r]   r,   )r0   ⁄limitrî   )rp   r   r   r;   ó  s    	*	zHTTPResponse.readlinec             C   sá   |  j  É  } | d  k s$ | d k r( d Sd | k o? | k n sJ | } |  j j | É } |  j t | É 8_ | sÉ t d É Ç | S)Nr   r9   )rá   rB   rì   rN   r,   r
   )r0   r1   rN   ry   r   r   r   rí   ¶  s    zHTTPResponse._read1_chunkedc             C   sS   y |  j  É  } Wn t k
 r( d SYn X| d  k r9 d S|  j j | É d  | Ö S)Nr9   )rá   r
   rB   rñ   )r0   r1   rN   r   r   r   rï   ¥  s    	zHTTPResponse._peek_chunkedc             C   s   |  j  j É  S)N)rB   ⁄fileno)r0   r   r   r   rò   ¡  s    zHTTPResponse.filenoc             C   sd   |  j  d  k r t É  Ç |  j  j | É p- | } t | t É sO t | d É rS | Sd j | É Sd  S)N⁄__iter__z, )rC   r   Zget_all⁄
isinstancerW   ⁄hasattrr>   )r0   r%   ⁄defaultrC   r   r   r   ⁄	getheaderƒ  s    	zHTTPResponse.getheaderc             C   s+   |  j  d k r t É  Ç t |  j  j É  É S)z&Return list of (header, value) tuples.N)rC   r   ⁄list⁄items)r0   r   r   r   ⁄
getheadersÕ  s    	zHTTPResponse.getheadersc             C   s   |  S)Nr   )r0   r   r   r   rô   ’  s    zHTTPResponse.__iter__c             C   s   |  j  S)N)rC   )r0   r   r   r   ⁄info⁄  s    zHTTPResponse.infoc             C   s   |  j  S)N)rS   )r0   r   r   r   ⁄geturl›  s    zHTTPResponse.geturlc             C   s   |  j  S)N)rK   )r0   r   r   r   ⁄getcode‡  s    zHTTPResponse.getcodeÈˇˇˇˇr§   r§   )!r4   r5   r6   rT   r_   rm   rj   r]   rn   rq   rr   rs   ry   ru   rÉ   rÜ   rá   rx   r~   rz   rä   rì   rñ   r;   rí   rï   rò   rù   r†   rô   r°   r¢   r£   r   r   )rp   r   r   ⁄   s<   	!P
 		c               @   s$  e  Z d  Z d Z d Z e Z e Z d Z	 d Z
 d e j d d d Ñ Z d d d d	 Ñ Z d
 d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d Ñ Z d d d d Ñ Z d d Ñ  Z d d d  Ñ Z d i  d! d" Ñ Z d# d$ Ñ  Z d% d& Ñ  Z d' d( Ñ  Z d S))r   rc   zHTTP/1.1r*   r   Nc             C   sà   | |  _  | |  _ d  |  _ g  |  _ d  |  _ t |  _ d  |  _ d  |  _ d  |  _	 i  |  _
 |  j | | É \ |  _ |  _ t j |  _ d  S)N)⁄timeout⁄source_addressrQ   ⁄_buffer⁄_HTTPConnection__response⁄_CS_IDLE⁄_HTTPConnection__staterG   ⁄_tunnel_host⁄_tunnel_port⁄_tunnel_headers⁄_get_hostport⁄host⁄port⁄socketZcreate_connection⁄_create_connection)r0   rØ   r∞   r•   r¶   r   r   r   rT   Ì  s    										zHTTPConnection.__init__c             C   sV   |  j  r t d É Ç |  j | | É \ |  _ |  _ | rE | |  _ n |  j j É  d S)aD  Set up host and port for HTTP CONNECT tunnelling.

        In a connection that uses HTTP CONNECT tunneling, the host passed to the
        constructor is used as a proxy server that relays all communication to
        the endpoint passed to `set_tunnel`. This done by sending an HTTP
        CONNECT request to the proxy server when the connection is established.

        This method must be called before the HTML connection has been
        established.

        The headers argument should be a mapping of extra HTTP headers to send
        with the CONNECT request.
        z.Can't set up tunnel for established connectionN)rQ   ⁄RuntimeErrorrÆ   r´   r¨   r≠   ⁄clear)r0   rØ   r∞   rC   r   r   r   ⁄
set_tunnel   s    	zHTTPConnection.set_tunnelc             C   s	  | d  k rˇ | j  d É } | j  d É } | | k r¿ y t | | d d  Ö É } WnV t k
 r¨ | | d d  Ö d k rä |  j } n t d | | d d  Ö É Ç Yn X| d  | Ö } n	 |  j } | rˇ | d d k rˇ | d d k rˇ | d d	 Ö } | | f S)
Nr)   ˙]r*   rV   znonnumeric port: '%s'r   ˙[r§   r§   )⁄rfindr^   r[   ⁄default_portr   )r0   rØ   r∞   rÇ   ⁄jr   r   r   rÆ     s    #	&zHTTPConnection._get_hostportc             C   s   | |  _  d  S)N)rF   )r0   ⁄levelr   r   r   ⁄set_debuglevel,  s    zHTTPConnection.set_debuglevelc             C   sh  d |  j  |  j f } | j d É } |  j | É xI |  j j É  D]8 \ } } d | | f } | j d É } |  j | É qB W|  j d É |  j |  j d |  j É} | j	 É  \ } }	 }
 |	 t
 j j k rÛ |  j É  t d |	 |
 j É  f É Ç xn | j j t d É } t | É t k r*t d	 É Ç | s1P| d k r>P|  j d k rˆ t d | j É  É qˆ Wd  S)NzCONNECT %s:%d HTTP/1.0
⁄asciiz%s: %s
zlatin-1Û   
rR   zTunnel connection failed: %d %sr*   zheader lineÛ   
r9   r   zheader:)ræ   rø   r9   )r´   r¨   r   ⁄sendr≠   rü   ⁄response_classrQ   rG   r_   ⁄http⁄
HTTPStatusZOKrn   ⁄OSErrorrg   rB   r;   r<   r,   r   rF   rX   r?   )r0   Zconnect_strZconnect_bytes⁄headerrâ   Z
header_strZheader_bytes⁄responserJ   rh   ⁄messager2   r   r   r   ⁄_tunnel/  s2    	
	zHTTPConnection._tunnelc             C   s]   |  j  |  j |  j f |  j |  j É |  _ |  j j t j t j	 d É |  j
 rY |  j É  d S)z3Connect to the host and port specified in __init__.r*   N)r≤   rØ   r∞   r•   r¶   rQ   Z
setsockoptr±   ZIPPROTO_TCPZTCP_NODELAYr´   r»   )r0   r   r   r   ⁄connectN  s
    $	zHTTPConnection.connectc             C   sY   t  |  _ z& |  j } | r. d |  _ | j É  Wd |  j } | rT d |  _ | j É  Xd S)z(Close the connection to the HTTP server.N)r©   r™   rQ   rn   r®   )r0   rQ   r∆   r   r   r   rn   W  s    					zHTTPConnection.closec             C   sê  |  j  d k r. |  j r% |  j É  n	 t É  Ç |  j d k rP t d t | É É d } t | d É r|  j d k r~ t d É d } y | j } Wn t	 k
 r• Yn, Xd | k r— d	 } |  j d k r— t d
 É x? | j
 | É } | sÍ P| rˇ | j d É } |  j  j | É q‘ Wd Sy |  j  j | É Wn^ t k
 rãt | t j É rqx7 | D] } |  j  j | É qTWn t d t | É É Ç Yn Xd S)zøSend `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        Nr   zsend:i    ry   zsendIng a read()ableFr|   Tzencoding file using iso-8859-1z
iso-8859-1z9data should be a bytes-like object or an iterable, got %r)rQ   ⁄	auto_openr…   r   rF   rX   rY   rõ   ⁄mode⁄AttributeErrorry   r   Zsendall⁄	TypeErrorrö   ⁄collections⁄Iterable⁄type)r0   r   Z	blocksizer   rÀ   Z	datablock⁄dr   r   r   r¿   e  sF    		

zHTTPConnection.sendc             C   s   |  j  j | É d S)zuAdd a line of output to the current request buffer.

        Assumes that the line does *not* end with \r\n.
        N)rß   r/   )r0   r}   r   r   r   ⁄_outputï  s    zHTTPConnection._outputc             C   s\   |  j  j d É d j |  j  É } |  j  d d Ö =|  j | É | d k	 rX |  j | É d S)z∏Send the currently buffered request and clear the buffer.

        Appends an extra \r\n to the buffer.
        A message_body may be specified, to be appended to the request.
        r9   s   
N)r9   r9   )rß   ⁄extendr>   r¿   )r0   ⁄message_bodyrH   r   r   r   ⁄_send_outputú  s    zHTTPConnection._send_outputFc             C   s  |  j  r! |  j  j É  r! d |  _  |  j t k r< t |  _ n t |  j É Ç | |  _ | s` d } d | | |  j f } |  j | j	 d É É |  j
 d k r| sˆd } | j d É r— t | É \ } } } } } | r!y | j	 d É } Wn! t k
 r| j	 d É } Yn X|  j d	 | É n’ |  j r?|  j }	 |  j }
 n |  j }	 |  j }
 y |	 j	 d É } Wn! t k
 rá|	 j	 d É } Yn X|	 j d
 É d k r´d | d } |
 |  j k rÕ|  j d	 | É n) | j d É } |  j d	 d | |
 f É | s|  j d d É n  d S)a`  Send a request to the server.

        `method' specifies an HTTP request method, e.g. 'GET'.
        `url' specifies the object being requested, e.g. '/index.html'.
        `skip_host' if True does not add automatically a 'Host:' header
        `skip_accept_encoding' if True does not add automatically an
           'Accept-Encoding:' header
        N˙/z%s %s %srΩ   rc   rV   r¬   ZidnaZHostr)   r   Û   [Û   ]z%s:%szAccept-EncodingZidentity)r®   rs   r™   r©   ⁄_CS_REQ_STARTEDr   rG   ⁄_http_vsn_strr“   r   ⁄	_http_vsnr\   r   r   ⁄	putheaderr´   r¨   rØ   r∞   rÅ   rπ   r?   )r0   rR   rS   ⁄	skip_host⁄skip_accept_encoding⁄requestZnetlocZnilZ
netloc_encrØ   r∞   Zhost_encr   r   r   ⁄
putrequest™  sN    						
zHTTPConnection.putrequestc             G   s   |  j  t k r t É  Ç t | d É r6 | j d É } t | É sU t d | f É Ç t | É } xé t | É D]Ä \ } } t | d É rü | j d É | | <n( t	 | t
 É r« t | É j d É | | <t | | É rn t d | | f É Ç qn Wd j | É } | d | } |  j | É d S)	zkSend a request header line to the server.

        For example: h.putheader('Accept', 'text/html')
        r   rΩ   zInvalid header name %rzlatin-1zInvalid header value %rs   
	s   : N)r™   rŸ   r   rõ   r   ⁄_is_legal_header_namer[   rû   ⁄	enumeraterö   r^   rW   ⁄_is_illegal_header_valuer>   r“   )r0   r≈   ⁄valuesrÇ   Z	one_valuerâ   r   r   r   r‹   &  s"    	zHTTPConnection.putheaderc             C   s5   |  j  t k r t |  _  n	 t É  Ç |  j | É d S)aâ  Indicate that the last header line has been sent to the server.

        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        N)r™   rŸ   ⁄_CS_REQ_SENTr   r’   )r0   r‘   r   r   r   ⁄
endheadersB  s    		zHTTPConnection.endheadersc             C   s   |  j  | | | | É d S)z&Send a complete request to the server.N)⁄_send_request)r0   rR   rS   ⁄bodyrC   r   r   r   rﬂ   Q  s    zHTTPConnection.requestc             C   s‡   d  } | j  É  t k } | d  k r3 | r3 d } nç | d  k	 r¿ y t t | É É } Wnh t k
 rø y" t t j | j É  É j É } Wn1 t	 t
 f k
 r∫ |  j d k r∂ t d É Yn XYn X| d  k	 r‹ |  j d | É d  S)N⁄0r   zCannot stat!!zContent-Length)⁄upper⁄_METHODS_EXPECTING_BODYrW   r,   rÕ   ⁄os⁄fstatrò   ⁄st_sizerÃ   rƒ   rF   rX   r‹   )r0   rË   rR   ZthelenZmethod_expects_bodyr   r   r   ⁄_set_content_lengthU  s    	" z"HTTPConnection._set_content_lengthc       	      C   sŸ   t  j d d Ñ  | DÉ É } i  } d | k r8 d | d <d | k rN d | d <|  j | | | ç d | k r} |  j | | É x* | j É  D] \ } } |  j | | É qä Wt | t É r» t | d	 É } |  j	 | É d  S)
Nc             S   s   g  |  ] } | j  É  ë q Sr   )r+   )r   ⁄kr   r   r   ˙
<listcomp>o  s   	 z0HTTPConnection._send_request.<locals>.<listcomp>rØ   r*   r›   zaccept-encodingrﬁ   zcontent-lengthrË   )
⁄dict⁄fromkeysr‡   rÔ   rü   r‹   rö   rW   r'   rÊ   )	r0   rR   rS   rË   rC   Zheader_namesZskipsrl   râ   r   r   r   rÁ   m  s    

zHTTPConnection._send_requestc             C   s'  |  j  r! |  j  j É  r! d |  _  |  j t k s9 |  j  rH t |  j É Ç |  j d k r{ |  j |  j |  j d |  j É} n |  j |  j d |  j É} yu y | j	 É  Wn t
 k
 r» |  j É  Ç  Yn X| j t k sﬁ t Ç t |  _ | j r˝ |  j É  n	 | |  _  | SWn | j É  Ç  Yn Xd S)a)  Get the response from the server.

        If the HTTPConnection is in the correct state, returns an
        instance of HTTPResponse or of whatever object is returned by
        the response_class variable.

        If a request has not been sent or if a previous response has
        not be handled, ResponseNotReady is raised.  If the HTTP
        response indicates that the connection should be closed, then
        it will be closed before the response is returned.  When the
        connection is closed, the underlying socket is closed.
        Nr   rR   )r®   rs   r™   rÂ   r   rF   r¡   rQ   rG   rm   ⁄ConnectionErrorrn   rP   rI   rà   r©   )r0   r∆   r   r   r   ⁄getresponseÇ  s.    	
			
zHTTPConnection.getresponse)r4   r5   r6   r€   r⁄   r   r¡   ⁄	HTTP_PORTrπ   r    rF   r±   ⁄_GLOBAL_DEFAULT_TIMEOUTrT   rµ   rÆ   rº   r»   r…   rn   r¿   r“   r’   r‡   r‹   rÊ   rﬂ   rÔ   rÁ   rı   r   r   r   r   r   „  s2   		0{c                   s^   e  Z d  Z d Z e Z d d d e j d d d d d á  f d d ÜZ á  f d d Ü  Z	 á  S)	⁄HTTPSConnectionz(This class allows communication via SSL.N⁄context⁄check_hostnamec      
         sª   t  t |  É j | | | | É | |  _ | |  _ | d  k rI t j É  } | j t j k }	 | d  k rp | j	 } | râ |	 râ t
 d É Ç | sï | r• | j | | É | |  _ | |  _ d  S)NzMcheck_hostname needs a SSL context with either CERT_OPTIONAL or CERT_REQUIRED)ro   r¯   rT   ⁄key_file⁄	cert_file⁄sslZ_create_default_https_contextZverify_modeZ	CERT_NONEr˙   r[   Zload_cert_chain⁄_context⁄_check_hostname)
r0   rØ   r∞   r˚   r¸   r•   r¶   r˘   r˙   Zwill_verify)rp   r   r   rT   Õ  s    				zHTTPSConnection.__init__c                s∏   t  É  j É  |  j r" |  j } n	 |  j } |  j j |  j d | É|  _ |  j j r¥ |  j r¥ y t	 j
 |  j j É  | É Wn5 t k
 r≥ |  j j t j É |  j j É  Ç  Yn Xd S)z(Connect to a host on a given (SSL) port.⁄server_hostnameN)ro   r…   r´   rØ   r˛   Zwrap_socketrQ   r˙   rˇ   r˝   Zmatch_hostnameZgetpeercert⁄	ExceptionZshutdownr±   Z	SHUT_RDWRrn   )r0   r   )rp   r   r   r…   ‚  s    		zHTTPSConnection.connect)
r4   r5   r6   ⁄__doc__⁄
HTTPS_PORTrπ   r±   r˜   rT   r…   r   r   )rp   r   r¯   ∆  s   	r¯   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r   ¯  s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r   ˝  s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r      s   c               @   s   e  Z d  Z d d Ñ  Z d S)r   c             C   s   | f |  _  | |  _ d  S)N)⁄argsrJ   )r0   rJ   r   r   r   rT     s    zUnknownProtocol.__init__N)r4   r5   r6   rT   r   r   r   r   r     s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r     s   c               @   s   e  Z d  Z d S)r	   N)r4   r5   r6   r   r   r   r   r	     s   c               @   s7   e  Z d  Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d S)r
   Nc             C   s"   | f |  _  | |  _ | |  _ d  S)N)r  ⁄partial⁄expected)r0   r  r  r   r   r   rT     s    	zIncompleteRead.__init__c             C   sE   |  j  d  k	 r d |  j  } n d } d |  j j t |  j É | f S)Nz, %i more expectedrV   z%s(%i bytes read%s))r  rp   r4   r,   r  )r0   ⁄er   r   r   ⁄__repr__  s
    zIncompleteRead.__repr__c             C   s
   t  |  É S)N)rY   )r0   r   r   r   ⁄__str__  s    zIncompleteRead.__str__)r4   r5   r6   rT   r  r	  r   r   r   r   r
     s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r     s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r      s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r   #  s   c               @   s   e  Z d  Z d S)r   N)r4   r5   r6   r   r   r   r   r   &  s   c               @   s   e  Z d  Z d d Ñ  Z d S)r   c             C   s+   | s t  | É } | f |  _ | |  _ d  S)N)rY   r  r2   )r0   r2   r   r   r   rT   *  s    zBadStatusLine.__init__N)r4   r5   r6   rT   r   r   r   r   r   )  s   c               @   s   e  Z d  Z d d Ñ  Z d S)r   c             C   s   t  j |  d t | f É d  S)Nz&got more than %d bytes when reading %s)r   rT   r<   )r0   Z	line_typer   r   r   rT   1  s    zLineTooLong.__init__N)r4   r5   r6   rT   r   r   r   r   r   0  s   c               @   s   e  Z d  Z d d Ñ  Z d S)r   c             O   s'   t  j |  d É t j |  | | é d  S)NrV   )r   rT   ⁄ConnectionResetError)r0   ⁄pos⁄kwr   r   r   rT   6  s    zRemoteDisconnected.__init__N)r4   r5   r6   rT   r   r   r   r   r   5  s   )?r  Zemail.parserr@   Zemail.messager¬   ⁄iorÏ   ⁄rer±   rŒ   Zurllib.parser   ⁄__all__rˆ   r  rI   r©   rŸ   rÂ   ⁄globals⁄updater√   Z__members__r‰   r   rê   r<   r=   ⁄compile⁄	fullmatchr·   ⁄searchr„   rÎ   r'   r«   ZMessager(   rD   ⁄BufferedIOBaser   r   r˝   ⁄ImportErrorr¯   r/   r  r   r   r   r   r   r	   r
   r   r   r   r   r   r   r
  r   r   r   r   r   r   ⁄<module>E   sv   				ˇ ˇ ˇ ﬂ0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
ì≠[]* „               @   sò  d  Z  d d d d d d d d g Z d	 d
 l Z d	 d
 l Z d	 d
 l Z d	 d
 l Z d	 d
 l Z d	 d
 l Z y d	 d
 l	 Z
 Wn e k
 rú d	 d
 l Z
 Yn Xd	 d
 l Z d	 d l m Z d Z d
 a d d Ñ  Z e e j j É Z d Z d d Ñ  Z d Z d d Ñ  Z d d d d d d d g Z d d d d d  d! d" d# d$ d% d& d' g Z g  Z x! e D] Z e j  e j! É  É qYWd
 d( d) Ñ Z" d
 d* d+ Ñ Z# d, d
 d- d
 d. d
 d/ d
 i Z$ e j% d0 e j& É Z' d1 d2 Ñ  Z( d3 d4 Ñ  Z) e j% d5 e j& É Z* e j% d6 e j+ e j& BÉ Z, e j% d7 e j- e j& BÉ Z. d8 d9 Ñ  Z/ e j% d: e j- e j& BÉ Z0 d; d< Ñ  Z1 d= d> Ñ  Z2 e j% d? É Z3 e j% d@ É Z4 e j% dA É Z5 e j% dB É Z6 dC dD Ñ  Z7 e j% dE É Z8 dF dG Ñ  Z9 dH dI Ñ  Z: dJ dK Ñ  Z; e j% dL e j& É Z< dM dN Ñ  Z= dO dP Ñ  Z> dQ dR Ñ  Z? dS dT Ñ  Z@ e j% dU e j& É ZA dV dW Ñ  ZB dX dY Ñ  ZC dZ d[ Ñ  ZD d\ d] Ñ  ZE d^ ZF e j% d_ É ZG d` da Ñ  ZH db dc Ñ  ZI dd de Ñ  ZJ df dg Ñ  ZK Gdh d Ñ  d É ZL Gdi d Ñ  d É ZM Gdj d Ñ  d eM É ZN dk dl Ñ  ZO dm dn Ñ  ZP Gdo dp Ñ  dp É ZQ Gdq d Ñ  d É ZR Gdr d Ñ  d eS É ZT Gds d Ñ  d eR É ZU dt du Ñ  ZV Gdv d Ñ  d eU É ZW Gdw d Ñ  d eU É ZX d
 S)xa™  HTTP cookie handling for web clients.

This module has (now fairly distant) origins in Gisle Aas' Perl module
HTTP::Cookies, from the libwww-perl library.

Docstrings, comments and debug strings in this code refer to the
attributes of the HTTP cookie system as cookie-attributes, to distinguish
them clearly from Python attributes.

Class diagram (note that BSDDBCookieJar and the MSIE* classes are not
distributed with the Python standard library, but are available from
http://wwwsearch.sf.net/):

                        CookieJar____
                        /     \      \
            FileCookieJar      \      \
             /    |   \         \      \
 MozillaCookieJar | LWPCookieJar \      \
                  |               |      \
                  |   ---MSIEBase |       \
                  |  /      |     |        \
                  | /   MSIEDBCookieJar BSDDBCookieJar
                  |/
               MSIECookieJar

⁄Cookie⁄	CookieJar⁄CookiePolicy⁄DefaultCookiePolicy⁄FileCookieJar⁄LWPCookieJar⁄	LoadError⁄MozillaCookieJarÈ    N)⁄timegmFc              G   s8   t  s
 d  St s+ d d  l } | j d É a t j  |  å  S)Nr	   zhttp.cookiejar)⁄debug⁄logger⁄loggingZ	getLogger)⁄argsr   © r   ˙$/usr/lib/python3.5/http/cookiejar.py⁄_debug.   s    r   zQa filename was not supplied (nor was the CookieJar instance initialised with one)c              C   sg   d d  l  }  d d  l } d d  l } |  j É  } | j d  | É | j É  } | j d | d d Éd  S)Nr	   zhttp.cookiejar bug!
%s⁄
stacklevelÈ   )⁄io⁄warnings⁄	traceback⁄StringIO⁄	print_exc⁄getvalue⁄warn)r   r   r   ⁄f⁄msgr   r   r   ⁄_warn_unhandled_exception<   s
    $r   i≤  c             C   sÃ   |  d  d Ö \ } } } } } } | t  k rƒ d | k oE d k n rƒ d | k oa d k n rƒ d | k o} d k n rƒ d | k oô d k n rƒ d | k oµ d k n rƒ t |  É Sd  Sd  S)	NÈ   È   È   È   r	   È   È;   È=   )⁄
EPOCH_YEARr
   )⁄tt⁄year⁄monthZmday⁄hour⁄min⁄secr   r   r   ⁄_timegmK   s
    "DT
r,   ZMonZTueZWedZThuZFriZSatZSunZJanZFebZMarZAprZMayZJunZJulZAugZSepZOctZNovZDecc             C   s\   |  d k r t  j  j É  } n t  j  j |  É } d | j | j | j | j | j | j f S)aH  Return a string representing time in seconds since epoch, t.

    If the function is called without an argument, it will use the current
    time.

    The format of the returned string is like "YYYY-MM-DD hh:mm:ssZ",
    representing Universal Time (UTC, aka GMT).  An example of this format is:

    1994-11-24 08:49:37Z

    Nz%04d-%02d-%02d %02d:%02d:%02dZ)	⁄datetime⁄utcnow⁄utcfromtimestampr'   r(   ⁄dayr)   ⁄minute⁄second)⁄t⁄dtr   r   r   ⁄	time2isozY   s
    r5   c             C   sq   |  d k r t  j  j É  } n t  j  j |  É } d t | j É  | j t | j d | j | j	 | j
 | j f S)zReturn a string representing time in seconds since epoch, t.

    If the function is called without an argument, it will use the current
    time.

    The format of the returned string is like this:

    Wed, DD-Mon-YYYY HH:MM:SS GMT

    Nz#%s, %02d-%s-%04d %02d:%02d:%02d GMTr   )r-   r.   r/   ⁄DAYSZweekdayr0   ⁄MONTHSr(   r'   r)   r1   r2   )r3   r4   r   r   r   ⁄time2netscapel   s    !r8   ZGMT⁄UTCZUT⁄Zz^([-+])?(\d\d?):?(\d\d)?$c             C   sï   d  } |  t  k r d } nv t j |  É } | rë d t | j d É É } | j d É ru | d t | j d É É } | j d É d k rë | } | S)Nr	   i  r   È   È<   r   ˙-)⁄	UTC_ZONES⁄TIMEZONE_RE⁄search⁄int⁄group)⁄tz⁄offset⁄mr   r   r   ⁄offset_from_tz_stringÉ   s    	rF   c             C   s   t  | É } | t j k r d  Sy t j | j É  É d } Wnd t k
 r¢ y t  | É } Wn t k
 rt d  SYn Xd | k oå d k n rö | } n d  SYn X| d  k rµ d } | d  k r« d } | d  k rŸ d } t  |  É }  t  | É } t  | É } t  | É } | d k  rãt j t j É  É d } | d }	 | }
 | | |	 } |	 |
 }	 t	 |	 É d k rã|	 d k rÅ| d } n
 | d } t
 | | |  | | | | f É } | d  k	 r¸| d  k r d } | j É  } t | É } | d  k rÚd  S| | } | S)Nr   r    r	   iË  Èd   È2   r9   )rA   r-   ZMAXYEAR⁄MONTHS_LOWER⁄index⁄lower⁄
ValueError⁄timeZ	localtime⁄absr,   ⁄upperrF   )r0   ⁄mon⁄yr⁄hrr*   r+   rC   ZimonZcur_yrrE   Ztmpr3   rD   r   r   r   ⁄	_str2timeë   sV    			   

 
!
rS   zV^[SMTWF][a-z][a-z], (\d\d) ([JFMASOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$z+^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*a“  ^
    (\d\d?)            # day
       (?:\s+|[-\/])
    (\w+)              # month
        (?:\s+|[-\/])
    (\d+)              # year
    (?:
          (?:\s+|:)    # separator before clock
       (\d\d?):(\d\d)  # hour:min
       (?::(\d\d))?    # optional seconds
    )?                 # optional clock
       \s*
    ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
       \s*
    (?:\(\w+\))?       # ASCII representation of timezone in parens.
       \s*$c             C   s4  t  j |  É } | rí | j É  } t j | d j É  É d } t | d É | t | d É t | d É t | d É t | d É f } t | É S|  j	 É  }  t
 j d |  d É }  d g d	 \ } } } } } }	 }
 t j |  É } | d k	 r| j É  \ } } } } } }	 }
 n d St | | | | | |	 |
 É S)
a’  Returns time in seconds since epoch of time represented by a string.

    Return value is an integer.

    None is returned if the format of str is unrecognized, the time is outside
    the representable range, or the timezone string is not recognized.  If the
    string contains no timezone, UTC is assumed.

    The timezone in the string may be numerical (like "-0800" or "+0100") or a
    string timezone (like "UTC", "GMT", "BST" or "EST").  Currently, only the
    timezone strings equivalent to UTC (zero offset) are known to the function.

    The function loosely parses the following formats:

    Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format
    Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format
    Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format
    09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)
    08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)
    08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)

    The parser ignores leading and trailing whitespace.  The time may be
    absent.

    If the year is given with only 2 digits, the function will select the
    century that makes the year closest to the current date.

    r   r   r	   r;   È   È   ⁄ NÈ   )⁄STRICT_DATE_REr@   ⁄groupsrI   rJ   rK   rA   ⁄floatr,   ⁄lstrip⁄
WEEKDAY_RE⁄sub⁄LOOSE_HTTP_DATE_RErS   )⁄textrE   ⁄grP   r&   r0   rQ   rR   r*   r+   rC   r   r   r   ⁄	http2timeﬂ   s    -
"$ra   a∆  ^
    (\d{4})              # year
       [-\/]?
    (\d\d?)              # numerical month
       [-\/]?
    (\d\d?)              # day
   (?:
         (?:\s+|[-:Tt])  # separator before clock
      (\d\d?):?(\d\d)    # hour:min
      (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
   )?                    # optional clock
      \s*
   ([-+]?\d\d?:?(:?\d\d)?
    |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
      \s*$c       
      C   sê   |  j  É  }  d g d \ } } } } } } } t j |  É } | d k	 rp | j É  \ } } } } } } } }	 n d St | | | | | | | É S)av  
    As for http2time, but parses the ISO 8601 formats:

    1994-02-03 14:15:29 -0100    -- ISO 8601 format
    1994-02-03 14:15:29          -- zone is optional
    1994-02-03                   -- only date
    1994-02-03T14:15:29          -- Use T as separator
    19940203T141529Z             -- ISO 8601 compact format
    19940203                     -- only date

    NrW   )r[   ⁄ISO_DATE_REr@   rY   rS   )
r_   r0   rP   rQ   rR   r*   r+   rC   rE   ⁄_r   r   r   ⁄iso2time'  s    "'rd   c             C   s7   |  j  d É \ } } |  j d | Ö |  j | d Ö S)z)Return unmatched part of re.Match object.r	   N)⁄span⁄string)⁄match⁄start⁄endr   r   r   ⁄	unmatchedH  s    rj   z^\s*([^=\s;,]+)z&^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"z^\s*=\s*([^\s;,]*)z\\(.)c       
      C   s∫  t  |  t É s t Ç g  } xó|  D]è} | } g  } xg| rût j | É } | rt | É } | j d É } t j | É } | r≥ t | É } | j d É } t j	 d | É } nE t
 j | É } | rÚ t | É } | j d É } | j É  } n d } | j | | f É q8 | j É  j d É rU| j É  d d Ö } | rL| j | É g  } q8 t j d d | É \ } }	 |	 d k sït d | | | f É Ç | } q8 W| r# | j | É q# W| S)	am  Parse header values into a list of lists containing key,value pairs.

    The function knows how to deal with ",", ";" and "=" as well as quoted
    values after "=".  A list of space separated tokens are parsed as if they
    were separated by ";".

    If the header_values passed as argument contains multiple values, then they
    are treated as if they were a single value separated by comma ",".

    This means that this function is useful for parsing header fields that
    follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
    the requirement for tokens).

      headers           = #header
      header            = (token | parameter) *( [";"] (token | parameter))

      token             = 1*<any CHAR except CTLs or separators>
      separators        = "(" | ")" | "<" | ">" | "@"
                        | "," | ";" | ":" | "\" | <">
                        | "/" | "[" | "]" | "?" | "="
                        | "{" | "}" | SP | HT

      quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
      qdtext            = <any TEXT except <">>
      quoted-pair       = "\" CHAR

      parameter         = attribute "=" value
      attribute         = token
      value             = token | quoted-string

    Each header is represented by a list of key/value pairs.  The value for a
    simple token (not part of a parameter) is None.  Syntactically incorrect
    headers will not necessarily be parsed as you would want.

    This is easier to describe with some examples:

    >>> split_header_words(['foo="bar"; port="80,81"; discard, bar=baz'])
    [[('foo', 'bar'), ('port', '80,81'), ('discard', None)], [('bar', 'baz')]]
    >>> split_header_words(['text/html; charset="iso-8859-1"'])
    [[('text/html', None), ('charset', 'iso-8859-1')]]
    >>> split_header_words([r'Basic realm="\"foo\bar\""'])
    [[('Basic', None), ('realm', '"foobar"')]]

    r   z\1N˙,z^[=\s;]*rV   r	   z&split_header_words bug: '%s', '%s', %s)⁄
isinstance⁄str⁄AssertionError⁄HEADER_TOKEN_REr@   rj   rB   ⁄HEADER_QUOTED_VALUE_RE⁄HEADER_ESCAPE_REr]   ⁄HEADER_VALUE_RE⁄rstrip⁄appendr[   ⁄
startswith⁄re⁄subn)
Zheader_values⁄resultr_   Z	orig_text⁄pairsrE   ⁄name⁄valueZnon_junkZnr_junk_charsr   r   r   ⁄split_header_wordsQ  sF    -	 	
 r|   z([\"\\])c             C   s¥   g  } xû |  D]ñ } g  } xk | D]c \ } } | d k	 rv t  j d | É sf t j d | É } d | } d | | f } | j | É q  W| r | j d j | É É q Wd j | É S)aª  Do the inverse (almost) of the conversion done by split_header_words.

    Takes a list of lists of (key, value) pairs and produces a single header
    value.  Attribute values are quoted if needed.

    >>> join_header_words([[("text/plain", None), ("charset", "iso-8859-1")]])
    'text/plain; charset="iso-8859-1"'
    >>> join_header_words([[("text/plain", None)], [("charset", "iso-8859-1")]])
    'text/plain, charset="iso-8859-1"'

    Nz^\w+$z\\\1z"%s"z%s=%sz; z, )rv   r@   ⁄HEADER_JOIN_ESCAPE_REr]   rt   ⁄join)Zlists⁄headersry   ⁄attr⁄k⁄vr   r   r   ⁄join_header_wordsß  s    
 rÉ   c             C   sB   |  j  d É r |  d d  Ö }  |  j d É r> |  d  d Ö }  |  S)N˙"r   Èˇˇˇˇ)ru   ⁄endswith)r_   r   r   r   ⁄strip_quotes¿  s
    rá   c             C   sn  d } g  } x[|  D]S} g  } d } xt  | j d	 É É D]\ } } | j É  } | j d
 É \ } }	 }
 | j É  } | sê | d k r; Pn q; |	 r¢ |
 j É  n d }
 | d k r)| j É  } | | k r“ | } | d k rˇ |
 d k	 rˆ t |
 É }
 d } n* | d k r)|
 d k	 r)t t |
 É É }
 | j | |
 f É q; W| r | sY| j d É | j | É q W| S)a5  Ad-hoc parser for Netscape protocol cookie-attributes.

    The old Netscape cookie format for Set-Cookie can for instance contain
    an unquoted "," in the expires field, so we have to use this ad-hoc
    parser instead of split_header_words.

    XXX This may not make the best possible effort to parse all the crap
    that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient
    parser is probably better, so could do worse than following that if
    this ever gives any trouble.

    Currently, this is also used for parsing RFC 2109 cookies.

    ⁄expires⁄domain⁄path⁄secure⁄version⁄port˙max-ageF˙;˙=r	   NT⁄0)rà   râ   rä   rã   rå   rç   ré   )rå   rë   )⁄	enumerate⁄split⁄strip⁄	partitionrK   rá   ra   rt   )Z
ns_headersZknown_attrsrx   Z	ns_headerry   ⁄version_setZiiZparam⁄key⁄sep⁄val⁄lcr   r   r   ⁄parse_ns_headers«  s@     "	rõ   z\.\d+$c             C   sK   t  j |  É r d S|  d k r# d S|  d d k sC |  d d k rG d Sd S)z*Return True if text is a host domain name.FrV   r	   ⁄.r   TrÖ   )⁄IPV4_REr@   )r_   r   r   r   ⁄is_HDN  s     rû   c             C   sî   |  j  É  }  | j  É  } |  | k r( d St |  É s8 d S|  j | É } | d k s_ | d k rc d S| j d É sv d St | d d Ö É sê d Sd S)a˝  Return True if domain A domain-matches domain B, according to RFC 2965.

    A and B may be host domain names or IP addresses.

    RFC 2965, section 1:

    Host names can be specified either as an IP address or a HDN string.
    Sometimes we compare one host name with another.  (Such comparisons SHALL
    be case-insensitive.)  Host A's name domain-matches host B's if

         *  their host name strings string-compare equal; or

         * A is a HDN string and has the form NB, where N is a non-empty
            name string, B has the form .B', and B' is a HDN string.  (So,
            x.y.com domain-matches .Y.com but not Y.com.)

    Note that domain-match is not a commutative operation: a.b.c.com
    domain-matches .c.com, but not the reverse.

    TFr   r	   rú   NrÖ   )rK   rû   ⁄rfindru   )⁄A⁄B⁄ir   r   r   ⁄domain_match  s    r£   c             C   s   t  j |  É r d Sd S)zdReturn True if text is a sort-of-like a host domain name.

    For accepting/blocking domains.

    FT)rù   r@   )r_   r   r   r   ⁄liberal_is_HDNB  s    r§   c             C   sá   |  j  É  }  | j  É  } t |  É o- t | É sD |  | k r@ d Sd S| j d É } | rl |  j | É rl d S| rÉ |  | k rÉ d Sd S)z\For blocking/accepting domains.

    A and B may be host domain names or IP addresses.

    TFrú   )rK   r§   ru   rÜ   )r†   r°   ⁄initial_dotr   r   r   ⁄user_domain_matchL  s    r¶   z:\d+$c             C   s_   |  j  É  } t j j | É d } | d k r@ |  j d d É } t j d | d É } | j É  S)zàReturn request-host, as defined by RFC 2965.

    Variation from RFC: returned value is lowercased, for convenient
    comparison.

    r   rV   ZHost)⁄get_full_url⁄urllib⁄parseZurlparseZ
get_header⁄cut_port_rer]   rK   )⁄request⁄url⁄hostr   r   r   ⁄request_hosta  s    rÆ   c             C   sI   t  |  É } } | j d É d k r? t j | É r? | d } | | f S)zzReturn a tuple (request-host, effective request-host name).

    As defined by RFC 2965, except both are lowercased.

    rú   r   z.localrÖ   )rÆ   ⁄findrù   r@   )r´   ⁄erhn⁄req_hostr   r   r   ⁄eff_request_hostq  s    %
r≤   c             C   sJ   |  j  É  } t j j | É } t | j É } | j d É sF d | } | S)z6Path component of request-URI, as defined by RFC 2965.˙/)rß   r®   r©   Zurlsplit⁄escape_pathrä   ru   )r´   r¨   ⁄partsrä   r   r   r   ⁄request_path|  s    
r∂   c             C   sy   |  j  } | j d É } | d k ro | | d d  Ö } y t | É Wqu t k
 rk t d | É d  SYqu Xn t } | S)N˙:r	   r   znonnumeric port: '%s')r≠   rØ   rA   rL   r   ⁄DEFAULT_HTTP_PORT)r´   r≠   r¢   rç   r   r   r   ⁄request_portÜ  s    	rπ   z%/;:@&=+$,!~*'()z%([0-9a-fA-F][0-9a-fA-F])c             C   s   d |  j  d É j É  S)Nz%%%sr   )rB   rO   )rg   r   r   r   ⁄uppercase_escaped_charò  s    r∫   c             C   s+   t  j j |  t É }  t j t |  É }  |  S)zEEscape any invalid characters in HTTP URL, and uppercase all escapes.)r®   r©   Zquote⁄HTTP_PATH_SAFE⁄ESCAPED_CHAR_REr]   r∫   )rä   r   r   r   r¥   ö  s    
r¥   c             C   sn   |  j  d É } | d k rj |  | d d Ö } | j  d É } t |  É rj | d k sb | d k rj d | S|  S)aB  Return reach of host h, as defined by RFC 2965, section 1.

    The reach R of a host name H is defined as follows:

       *  If

          -  H is the host domain name of a host; and,

          -  H has the form A.B; and

          -  A has no embedded (that is, interior) dots; and

          -  B has at least one embedded dot, or B is the string "local".
             then the reach of H is .B.

       *  Otherwise, the reach of H is H.

    >>> reach("www.acme.com")
    '.acme.com'
    >>> reach("acme.com")
    'acme.com'
    >>> reach("acme.local")
    '.local'

    rú   r	   r   NZlocal)rØ   rû   )⁄hr¢   ⁄br   r   r   ⁄reach®  s    $rø   c             C   s0   t  |  É } t | t |  j É É s( d Sd Sd S)z‹

    RFC 2965, section 3.3.6:

        An unverifiable transaction is to a third-party host if its request-
        host U does not domain-match the reach R of the request-host O in the
        origin transaction.

    TFN)rÆ   r£   rø   Zorigin_req_host)r´   r±   r   r   r   ⁄is_third_partyÀ  s    
r¿   c               @   ss   e  Z d  Z d Z d d d Ñ Z d d Ñ  Z d d d	 Ñ Z d
 d Ñ  Z d d d Ñ Z d d Ñ  Z	 d d Ñ  Z
 d S)r   a–  HTTP Cookie.

    This class represents both Netscape and RFC 2965 cookies.

    This is deliberately a very simple class.  It just holds attributes.  It's
    possible to construct Cookie instances that don't comply with the cookie
    standards.  CookieJar.make_cookies is the factory function for Cookie
    objects -- it deals with cookie parsing, supplying defaults, and
    normalising to the representation used in this class.  CookiePolicy is
    responsible for checking them to see whether they should be accepted from
    and returned to the server.

    Note that the port may be present in the headers, but unspecified ("Port"
    rather than"Port=80", for example); if this is the case, port is None.

    Fc             C   s  | d  k	 r t  | É } | d  k	 r6 t  t | É É } | d  k rZ | d k rZ t d É Ç | |  _ | |  _ | |  _ | |  _ | |  _ | j É  |  _	 | |  _
 | |  _ |	 |  _ |
 |  _ | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ t j | É |  _ d  S)NTz-if port is None, port_specified must be false)rA   rZ   rL   rå   rz   r{   rç   ⁄port_specifiedrK   râ   ⁄domain_specified⁄domain_initial_doträ   ⁄path_specifiedrã   rà   ⁄discard⁄comment⁄comment_url⁄rfc2109⁄copy⁄_rest)⁄selfrå   rz   r{   rç   r¡   râ   r¬   r√   rä   rƒ   rã   rà   r≈   r∆   r«   ⁄restr»   r   r   r   ⁄__init__Ó  s.      															zCookie.__init__c             C   s   | |  j  k S)N)r    )rÀ   rz   r   r   r   ⁄has_nonstandard_attr  s    zCookie.has_nonstandard_attrNc             C   s   |  j  j | | É S)N)r    ⁄get)rÀ   rz   ⁄defaultr   r   r   ⁄get_nonstandard_attr  s    zCookie.get_nonstandard_attrc             C   s   | |  j  | <d  S)N)r    )rÀ   rz   r{   r   r   r   ⁄set_nonstandard_attr  s    zCookie.set_nonstandard_attrc             C   s>   | d  k r t  j  É  } |  j d  k	 r: |  j | k r: d Sd S)NTF)rM   rà   )rÀ   ⁄nowr   r   r   ⁄
is_expired  s
     zCookie.is_expiredc             C   sx   |  j  d  k r d } n d |  j  } |  j | |  j } |  j d  k	 ra d |  j |  j f } n	 |  j } d | | f S)NrV   r∑   z%s=%sz<Cookie %s for %s>)rç   râ   rä   r{   rz   )rÀ   ⁄p⁄limitZ	namevaluer   r   r   ⁄__str__%  s     		zCookie.__str__c             C   sî   g  } x: d D]2 } t  |  | É } | j d | t | É f É q W| j d t |  j É É | j d t |  j É É d |  j j d j | É f S)Nrå   rz   r{   rç   r¡   râ   r¬   r√   rä   rƒ   rã   rà   r≈   r∆   r«   z%s=%szrest=%sz
rfc2109=%sz%s(%s)z, )rå   rz   r{   rç   r¡   râ   r¬   r√   rä   rƒ   rã   rà   r≈   r∆   r«   )⁄getattrrt   ⁄reprr    r»   ⁄	__class__⁄__name__r~   )rÀ   r   rz   rÄ   r   r   r   ⁄__repr__/  s       
!zCookie.__repr__)r€   ⁄
__module__⁄__qualname__⁄__doc__rÕ   rŒ   r—   r“   r‘   r◊   r‹   r   r   r   r   r   ‹  s    
c               @   sF   e  Z d  Z d Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d	 Ñ  Z d
 S)r   a   Defines which cookies get accepted from and returned to server.

    May also modify cookies, though this is probably a bad idea.

    The subclass DefaultCookiePolicy defines the standard rules for Netscape
    and RFC 2965 cookies -- override that if you want a customized policy.

    c             C   s   t  É  Ç d S)zƒReturn true if (and only if) cookie should be accepted from server.

        Currently, pre-expired cookies never get this far -- the CookieJar
        class deletes such cookies itself.

        N)⁄NotImplementedError)rÀ   ⁄cookier´   r   r   r   ⁄set_okG  s    zCookiePolicy.set_okc             C   s   t  É  Ç d S)zAReturn true if (and only if) cookie should be returned to server.N)r‡   )rÀ   r·   r´   r   r   r   ⁄	return_okP  s    zCookiePolicy.return_okc             C   s   d S)zMReturn false if cookies should not be returned, given cookie domain.
        Tr   )rÀ   râ   r´   r   r   r   ⁄domain_return_okT  s    zCookiePolicy.domain_return_okc             C   s   d S)zKReturn false if cookies should not be returned, given cookie path.
        Tr   )rÀ   rä   r´   r   r   r   ⁄path_return_okY  s    zCookiePolicy.path_return_okN)r€   r›   rﬁ   rﬂ   r‚   r„   r‰   rÂ   r   r   r   r   r   >  s
   	c               @   sp  e  Z d  Z d Z d Z d Z d Z d Z e e BZ d d d d d d d d d e d d d	 d
 Ñ Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d  Ñ  Z d! d" Ñ  Z d# d$ Ñ  Z d% d& Ñ  Z d' d( Ñ  Z d) d* Ñ  Z d+ d, Ñ  Z d- d. Ñ  Z d/ d0 Ñ  Z d1 d2 Ñ  Z d3 d4 Ñ  Z d5 d6 Ñ  Z d S)7r   zBImplements the standard rules for accepting and returning cookies.r   r   rT   r	   NTFc             C   s¶   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ |	 |  _ |
 |  _ | |  _ | |  _	 | d k	 rx t
 | É |  _ n	 f  |  _ | d k	 rô t
 | É } | |  _ d S)zAConstructor arguments should be passed as keyword arguments only.N)⁄netscape⁄rfc2965⁄rfc2109_as_netscape⁄hide_cookie2⁄strict_domain⁄strict_rfc2965_unverifiable⁄strict_ns_unverifiable⁄strict_ns_domain⁄strict_ns_set_initial_dollar⁄strict_ns_set_path⁄tuple⁄_blocked_domains⁄_allowed_domains)rÀ   ⁄blocked_domains⁄allowed_domainsrÊ   rÁ   rË   rÈ   rÍ   rÎ   rÏ   rÌ   rÓ   rÔ   r   r   r   rÕ   i  s     											zDefaultCookiePolicy.__init__c             C   s   |  j  S)z4Return the sequence of blocked domains (as a tuple).)rÒ   )rÀ   r   r   r   rÛ   ä  s    z#DefaultCookiePolicy.blocked_domainsc             C   s   t  | É |  _ d S)z$Set the sequence of blocked domains.N)r   rÒ   )rÀ   rÛ   r   r   r   ⁄set_blocked_domainsç  s    z'DefaultCookiePolicy.set_blocked_domainsc             C   s+   x$ |  j  D] } t | | É r
 d Sq
 Wd S)NTF)rÒ   r¶   )rÀ   râ   Zblocked_domainr   r   r   ⁄
is_blockedë  s    zDefaultCookiePolicy.is_blockedc             C   s   |  j  S)z=Return None, or the sequence of allowed domains (as a tuple).)rÚ   )rÀ   r   r   r   rÙ   ó  s    z#DefaultCookiePolicy.allowed_domainsc             C   s%   | d k	 r t  | É } | |  _ d S)z-Set the sequence of allowed domains, or None.N)r   rÚ   )rÀ   rÙ   r   r   r   ⁄set_allowed_domainsö  s    z'DefaultCookiePolicy.set_allowed_domainsc             C   s>   |  j  d  k r d Sx$ |  j  D] } t | | É r d Sq Wd S)NFT)rÚ   r¶   )rÀ   râ   Zallowed_domainr   r   r   ⁄is_not_allowed†  s    z"DefaultCookiePolicy.is_not_allowedc             C   sl   t  d | j | j É | j d k	 s+ t Ç x: d D]2 } d	 | } t |  | É } | | | É s2 d
 Sq2 Wd S)zÿ
        If you override .set_ok(), be sure to call this method.  If it returns
        false, so should your subclass (assuming your subclass wants to be more
        strict about which cookies to accept).

        z - checking cookie %s=%sNrå   ⁄verifiabilityrz   rä   râ   rç   Zset_ok_FT)rå   r˘   rz   rä   râ   rç   )r   rz   r{   rn   rÿ   )rÀ   r·   r´   ⁄n⁄fn_name⁄fnr   r   r   r‚   ®  s    
zDefaultCookiePolicy.set_okc             C   s{   | j  d  k r) t d | j | j É d S| j  d k rP |  j rP t d É d S| j  d k rw |  j rw t d É d Sd S)Nz0   Set-Cookie2 without version attribute (%s=%s)Fr	   z$   RFC 2965 cookies are switched offz$   Netscape cookies are switched offT)rå   r   rz   r{   rÁ   rÊ   )rÀ   r·   r´   r   r   r   ⁄set_ok_versionª  s    

z"DefaultCookiePolicy.set_ok_versionc             C   se   | j  ra t | É ra | j d k r; |  j r; t d É d S| j d k ra |  j ra t d É d Sd S)Nr	   z>   third-party RFC 2965 cookie during unverifiable transactionFz>   third-party Netscape cookie during unverifiable transactionT)⁄unverifiabler¿   rå   rÎ   r   rÏ   )rÀ   r·   r´   r   r   r   ⁄set_ok_verifiability   s    

z(DefaultCookiePolicy.set_ok_verifiabilityc             C   sB   | j  d k r> |  j r> | j j d É r> t d | j É d Sd S)Nr	   ˙$z'   illegal name (starts with '$'): '%s'FT)rå   rÓ   rz   ru   r   )rÀ   r·   r´   r   r   r   ⁄set_ok_name÷  s
    zDefaultCookiePolicy.set_ok_namec             C   sj   | j  rf t | É } | j d k s< | j d k rf |  j rf | j | j É rf t d | j | É d Sd S)Nr	   z7   path attribute %s is not a prefix of request path %sFT)rƒ   r∂   rå   rÔ   ru   rä   r   )rÀ   r·   r´   ⁄req_pathr   r   r   ⁄set_ok_pathﬂ  s    	zDefaultCookiePolicy.set_ok_pathc             C   sà  |  j  | j É r& t d | j É d S|  j | j É rL t d | j É d S| j rÑt | É \ } } | j } |  j r| j d É d k r| j d É } | j d d | É } | d k r| | d d  Ö } | | d | Ö }	 |	 j	 É  d$ k rt
 | É d k rt d | É d S| j d É r=| d d  Ö }
 n | }
 |
 j d É d k } | r|| d k r|t d | É d S| j d k r”| j | É r”| j d É r”d | j | É r”t d  | | É d S| j d k sÚ|  j |  j @rt | | É st d! | | É d S| j d k s4|  j |  j @rÑ| d  t
 | É Ö } | j d É d k rÑt j | É rÑt d" | | É d Sd# S)%Nz"   domain %s is in user block-listFz&   domain %s is not in user allow-listrú   r   r	   r   ⁄co⁄ac⁄com⁄edu⁄org⁄net⁄gov⁄milrA   ⁄aero⁄biz⁄cat⁄coop⁄info⁄jobs⁄mobi⁄museumrz   ⁄pro⁄travel⁄euz&   country-code second level domain %sz.localz/   non-local domain %s contains no embedded dotzO   effective request-host %s (even with added initial dot) does not end with %sz5   effective request-host %s does not domain-match %sz.   host prefix %s for domain %s contains a dotT)r  r  r  r  r  r	  r
  r  rA   r  r  r  r  r  r  r  r  rz   r  r  r  )rˆ   râ   r   r¯   r¬   r≤   rÍ   ⁄countrü   rK   ⁄lenru   rØ   rå   rÜ   rÌ   ⁄DomainRFC2965Matchr£   ⁄DomainStrictNoDotsrù   r@   )rÀ   r·   r´   r±   r∞   râ   r¢   ⁄jZtldZsldZundotted_domainZembedded_dotsZhost_prefixr   r   r   ⁄set_ok_domainÍ  sf    			  


z!DefaultCookiePolicy.set_ok_domainc             C   sØ   | j  r´ t | É } | d  k r* d } n t | É } xr | j j d É D]G } y t | É Wn# t k
 rÇ t d | É d SYn X| | k rI PqI Wt d | | j É d Sd S)N⁄80rk   z   bad port %s (not numeric)Fz$   request port (%s) not found in %sT)r¡   rπ   rm   rç   rì   rA   rL   r   )rÀ   r·   r´   ⁄req_portr’   r   r   r   ⁄set_ok_port%  s"    			zDefaultCookiePolicy.set_ok_portc             C   sW   t  d | j | j É x: d D]2 } d | } t |  | É } | | | É s d	 Sq Wd
 S)z€
        If you override .return_ok(), be sure to call this method.  If it
        returns false, so should your subclass (assuming your subclass wants to
        be more strict about which cookies to return).

        z - checking cookie %s=%srå   r˘   rã   rà   rç   râ   Z
return_ok_FT)rå   r˘   rã   rà   rç   râ   )r   rz   r{   rÿ   )rÀ   r·   r´   r˙   r˚   r¸   r   r   r   r„   :  s    	
zDefaultCookiePolicy.return_okc             C   sR   | j  d k r' |  j r' t d É d S| j  d k rN |  j rN t d É d Sd S)Nr	   z$   RFC 2965 cookies are switched offFz$   Netscape cookies are switched offT)rå   rÁ   r   rÊ   )rÀ   r·   r´   r   r   r   ⁄return_ok_versionL  s    

z%DefaultCookiePolicy.return_ok_versionc             C   se   | j  ra t | É ra | j d k r; |  j r; t d É d S| j d k ra |  j ra t d É d Sd S)Nr	   z>   third-party RFC 2965 cookie during unverifiable transactionFz>   third-party Netscape cookie during unverifiable transactionT)r˛   r¿   rå   rÎ   r   rÏ   )rÀ   r·   r´   r   r   r   ⁄return_ok_verifiabilityU  s    

z+DefaultCookiePolicy.return_ok_verifiabilityc             C   s*   | j  r& | j d k r& t d É d Sd S)NZhttpsz(   secure cookie with non-secure requestFT)rã   ⁄typer   )rÀ   r·   r´   r   r   r   ⁄return_ok_securea  s    
z$DefaultCookiePolicy.return_ok_securec             C   s$   | j  |  j É r  t d É d Sd S)Nz   cookie expiredFT)r‘   ⁄_nowr   )rÀ   r·   r´   r   r   r   ⁄return_ok_expiresg  s    
z%DefaultCookiePolicy.return_ok_expiresc             C   sl   | j  rh t | É } | d  k r' d } x> | j  j d É D] } | | k r: Pq: Wt d | | j  É d Sd S)Nr  rk   z0   request port %s does not match cookie port %sFT)rç   rπ   rì   r   )rÀ   r·   r´   r  r’   r   r   r   ⁄return_ok_portm  s    	z"DefaultCookiePolicy.return_ok_portc             C   sÃ   t  | É \ } } | j } | j d k r^ |  j |  j @r^ | j r^ | | k r^ t d É d S| j d k rë t | | É rë t d | | É d S| j d k r» d | j | É r» t d | | É d Sd S)Nr	   zQ   cookie with unspecified domain does not string-compare equal to request domainFzQ   effective request-host name %s does not domain-match RFC 2965 cookie domain %srú   z;   request-host %s does not match Netscape cookie domain %sT)	r≤   râ   rå   rÌ   ⁄DomainStrictNonDomainr¬   r   r£   rÜ   )rÀ   r·   r´   r±   r∞   râ   r   r   r   ⁄return_ok_domain{  s     	

#
z$DefaultCookiePolicy.return_ok_domainc             C   s™   t  | É \ } } | j d É s+ d | } | j d É sD d | } | j | É p_ | j | É sf d S|  j | É rÜ t d | É d S|  j | É r¶ t d | É d Sd S)Nrú   Fz"   domain %s is in user block-listz&   domain %s is not in user allow-listT)r≤   ru   rÜ   rˆ   r   r¯   )rÀ   râ   r´   r±   r∞   r   r   r   r‰   ë  s    

z$DefaultCookiePolicy.domain_return_okc             C   s@   t  d | É t | É } | j | É s< t  d | | É d Sd S)Nz- checking cookie path=%sz  %s does not path-match %sFT)r   r∂   ru   )rÀ   rä   r´   r  r   r   r   rÂ   ß  s    z"DefaultCookiePolicy.path_return_ok) r€   r›   rﬁ   rﬂ   r  r'  r  ZDomainLiberalZDomainStrictrÕ   rÛ   rı   rˆ   rÙ   r˜   r¯   r‚   r˝   rˇ   r  r  r  r  r„   r   r!  r#  r%  r&  r(  r‰   rÂ   r   r   r   r   r   _  sL   
	;	c             C   s"   t  |  j É  É } t |  j | É S)N)⁄sorted⁄keys⁄maprœ   )Zadictr*  r   r   r   ⁄vals_sorted_by_key∞  s    r,  c             c   sg   t  |  É } xT | D]L } d }  y | j Wn t k
 r> Yn Xd }  t | É Ed H|  s | Vq Wd S)zBIterates over nested mapping, depth-first, in sorted order by key.FTN)r,  ⁄items⁄AttributeError⁄
deepvalues)⁄mapping⁄values⁄objr   r   r   r/  ¥  s    r/  c               @   s   e  Z d  Z d S)⁄AbsentN)r€   r›   rﬁ   r   r   r   r   r3  ∆  s    r3  c               @   s~  e  Z d  Z d Z e j d É Z e j d É Z e j d É Z e j d É Z	 e j d É Z
 e j d e j É Z d d	 d
 Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d  Ñ  Z d! d" Ñ  Z d# d$ Ñ  Z d d d d% d& Ñ Z d' d( Ñ  Z d) d* Ñ  Z d+ d, Ñ  Z d- d. Ñ  Z d/ d0 Ñ  Z  d1 d2 Ñ  Z! d S)3r   zîCollection of HTTP cookies.

    You may not need to know about this class: try
    urllib.request.build_opener(HTTPCookieProcessor).open(url).
    z\Wz([\"\\])z\.?[^.]*z[^.]*z^\.+z^\#LWP-Cookies-(\d+\.\d+)Nc             C   s:   | d  k r t  É  } | |  _ t j É  |  _ i  |  _ d  S)N)r   ⁄_policy⁄
_threading⁄RLock⁄_cookies_lock⁄_cookies)rÀ   ⁄policyr   r   r   rÕ   ◊  s
    		zCookieJar.__init__c             C   s   | |  _  d  S)N)r4  )rÀ   r9  r   r   r   ⁄
set_policyﬂ  s    zCookieJar.set_policyc             C   s∆   g  } |  j  j | | É s g  St d | É |  j | } xÜ | j É  D]x } |  j  j | | É sd qF | | } xM | j É  D]? } |  j  j | | É s£ t d É q{ t d É | j | É q{ WqF W| S)Nz!Checking %s for cookies to returnz   not returning cookiez   it's a match)	r4  r‰   r   r8  r*  rÂ   r1  r„   rt   )rÀ   râ   r´   ⁄cookiesZcookies_by_pathrä   Zcookies_by_namer·   r   r   r   ⁄_cookies_for_domain‚  s     


zCookieJar._cookies_for_domainc             C   s=   g  } x0 |  j  j É  D] } | j |  j | | É É q W| S)z2Return a list of cookies to be returned to server.)r8  r*  ⁄extendr<  )rÀ   r´   r;  râ   r   r   r   ⁄_cookies_for_requestÙ  s    zCookieJar._cookies_for_requestc       	      C   sπ  | j  d d d Ñ  d d É d } g  } xä| D]Ç} | j } | sg d } | d k rg | j d | É | j d	 k	 r≤ |  j j | j É r≤ | d k r≤ |  j j d
 | j É } n	 | j } | j d	 k r› | j | j É n | j d | j | f É | d k r/ | j	 r | j d | j
 É | j j d É ru| j } | j rd| j d É rd| d d	 Ö } | j d | É | j d	 k	 r/ d } | j r§| d | j } | j | É q/ W| S)z‹Return a list of cookie-attributes to be returned to server.

        like ['foo="bar"; $Path="/"', ...]

        The $Version attribute is also added when appropriate (currently only
        once per request).

        ró   c             S   s   t  |  j É S)N)r  rä   )⁄ar   r   r   ⁄<lambda>  s    z)CookieJar._cookie_attrs.<locals>.<lambda>⁄reverseTFr	   z$Version=%sNz\\\1z%s=%sz
$Path="%s"rú   r   z$Domain="%s"z$Portz="%s")⁄sortrå   rt   r{   ⁄non_word_rer@   ⁄quote_rer]   rz   rƒ   rä   râ   ru   r√   rç   r¡   )	rÀ   r;  rñ   ⁄attrsr·   rå   r{   râ   r’   r   r   r   ⁄_cookie_attrs˚  s>    
	!			
	zCookieJar._cookie_attrsc          
   C   sˇ   t  d É |  j j É  z… t t j É  É |  j _ |  _ |  j | É } |  j | É } | rÖ | j	 d É sÖ | j
 d d j | É É |  j j rﬂ |  j j rﬂ | j	 d É rﬂ x. | D]& } | j d k rµ | j
 d d É Pqµ WWd |  j j É  X|  j É  d S)zûAdd correct Cookie: header to request (urllib.request.Request object).

        The Cookie2 header is also added unless policy.hide_cookie2 is true.

        ⁄add_cookie_headerr   z; ZCookie2r   z$Version="1"N)r   r7  ⁄acquirerA   rM   r4  r$  r>  rF  Z
has_headerZadd_unredirected_headerr~   rÁ   rÈ   rå   ⁄release⁄clear_expired_cookies)rÀ   r´   r;  rE  r·   r   r   r   rG  6  s$    
	zCookieJar.add_cookie_headerc             C   s  g  } d } d } xÍ| D]‚} | d \ } } d } d }	 i  }
 i  } xè| d d Ö D]}\ } } | j  É  } | | k sà | | k ré | } | | k r¨ | d k r¨ d } | |
 k rª qX | d k r | d k r‰ t d É d }	 P| j  É  } | d k r| rqX | d k rt d É qX | d k ryd } y t | É } Wn# t k
 ret d É d }	 PYn Xd } |  j | } | | k së| | k rÀ| d k ræ| d k ræt d | É d }	 P| |
 | <qX | | | <qX W|	 r‚q | j | | |
 | f É q W| S)a  Return list of tuples containing normalised cookie information.

        attrs_set is the list of lists of key,value pairs extracted from
        the Set-Cookie or Set-Cookie2 headers.

        Tuples are name, value, standard, rest, where name and value are the
        cookie name and value, standard is a dictionary containing the standard
        cookie-attributes (discard, secure, version, expires or max-age,
        domain, path and port) and rest is a dictionary containing the rest of
        the cookie-attributes.

        r≈   rã   rå   rà   ˙max-agerâ   rä   rç   r∆   ⁄
commenturlr	   Fr   NTz%   missing value for domain attributezM   missing or invalid value for expires attribute: treating as session cookiez?   missing or invalid (non-numeric) value for max-age attributez!   missing value for %s attribute)r≈   rã   )rå   rà   rK  râ   rä   rç   r∆   rL  )rç   r∆   rL  )rK   r   rA   rL   r$  rt   )rÀ   ⁄	attrs_set⁄cookie_tuples⁄boolean_attrs⁄value_attrsZcookie_attrsrz   r{   Zmax_age_setZ
bad_cookie⁄standardrÃ   rÅ   rÇ   rö   r   r   r   ⁄_normalized_cookie_tuplesW  sl       



z#CookieJar._normalized_cookie_tuplesc          !   C   s  | \ } } } } | j  d t É } | j  d t É } | j  d t É }	 | j  d t É }
 | j  d d  É } | d  k	 r° y t | É } Wn t k
 r† d  SYn X| j  d d É } | j  d d É } | j  d	 d  É } | j  d
 d  É } | t k	 r| d k rd } t | É } nx d } t | É } | j d É } | d k rv| d k rb| d  | Ö } n | d  | d Ö } t | É d k réd } | t k	 } d } | rªt | j	 d É É } | t k r‚t
 | É \ } } | } n | j	 d É s˚d | } d } |	 t k	 rF|	 d  k r(t | É }	 qLd } t j d d |	 É }	 n d  }	 |
 t k rgd  }
 d } nR |
 |  j k rπy |  j | | | É Wn t k
 r°Yn Xt d | | | É d  St | | | |	 | | | | | | | |
 | | | | É S)Nrâ   rä   rç   rà   rå   rã   Fr≈   r∆   rL  rV   Tr≥   r   r	   rú   z\s+z2Expiring cookie, domain='%s', path='%s', name='%s'rÖ   )rœ   r3  rA   rL   r¥   r∂   rü   r  ⁄boolru   r≤   rπ   rv   r]   r$  ⁄clear⁄KeyErrorr   r   )rÀ   ⁄tupr´   rz   r{   rQ  rÃ   râ   rä   rç   rà   rå   rã   r≈   r∆   r«   rƒ   r¢   r¬   r√   r±   r∞   r¡   r   r   r   ⁄_cookie_from_cookie_tuple∏  sÇ    	 	
		z#CookieJar._cookie_from_cookie_tuplec             C   sO   |  j  | É } g  } x3 | D]+ } |  j | | É } | r | j | É q W| S)N)rR  rW  rt   )rÀ   rM  r´   rN  r;  rV  r·   r   r   r   ⁄_cookies_from_attrs_set  s     z!CookieJar._cookies_from_attrs_setc             C   sj   t  |  j d d  É } | d  k r. |  j j } x5 | D]- } | j d k r5 d | _ | r5 d | _ q5 Wd  S)NrË   r   Tr	   )rÿ   r4  rÁ   rå   r»   )rÀ   r;  Zrfc2109_as_nsr·   r   r   r   ⁄_process_rfc2109_cookies  s    	z"CookieJar._process_rfc2109_cookiesc             C   sá  | j  É  } | j d g  É } | j d g  É } |  j j } |  j j } | rV | sÄ | rd | sÄ | rr | sÄ | rÑ | rÑ g  Sy |  j t | É | É } Wn t k
 r¡ t É  g  } Yn X| rÉ| rÉy |  j t	 | É | É }	 Wn t k
 rt É  g  }	 Yn X|  j
 |	 É | rpi  }
 x* | D]" } d |
 | j | j | j f <q,W|
 d d Ñ } t | |	 É }	 |	 rÉ| j |	 É | S)zAReturn sequence of Cookie objects extracted from response object.zSet-Cookie2z
Set-CookieNc             S   s"   |  j  |  j |  j f } | | k S)N)râ   rä   rz   )Z	ns_cookie⁄lookupró   r   r   r   ⁄no_matching_rfc2965U  s    z3CookieJar.make_cookies.<locals>.no_matching_rfc2965)r  Zget_allr4  rÁ   rÊ   rX  r|   ⁄	Exceptionr   rõ   rY  râ   rä   rz   ⁄filterr=  )rÀ   ⁄responser´   r   Zrfc2965_hdrsZns_hdrsrÁ   rÊ   r;  Z
ns_cookiesrZ  r·   r[  r   r   r   ⁄make_cookies)  sB     zCookieJar.make_cookiesc          
   C   sg   |  j  j É  zE t t j É  É |  j _ |  _ |  j j | | É rQ |  j | É Wd |  j  j É  Xd S)z-Set a cookie if policy says it's OK to do so.N)	r7  rH  rA   rM   r4  r$  r‚   ⁄
set_cookierI  )rÀ   r·   r´   r   r   r   ⁄set_cookie_if_ok_  s    zCookieJar.set_cookie_if_okc          
   C   sé   |  j  } |  j j É  zc | j | k r5 i  | | j <| | j } | j | k r^ i  | | j <| | j } | | | j <Wd |  j j É  Xd S)z?Set a cookie, without checking whether or not it should be set.N)r8  r7  rH  râ   rä   rz   rI  )rÀ   r·   ⁄cZc2Zc3r   r   r   r`  l  s    	  zCookieJar.set_cookiec          
   C   s§   t  d | j É  É |  j j É  zo t t j É  É |  j _ |  _ xI |  j | | É D]5 } |  j j	 | | É rU t  d | É |  j
 | É qU WWd |  j j É  Xd S)zAExtract cookies from response, where allowable given the request.zextract_cookies: %sz setting cookie: %sN)r   r  r7  rH  rA   rM   r4  r$  r_  r‚   r`  rI  )rÀ   r^  r´   r·   r   r   r   ⁄extract_cookiesy  s    zCookieJar.extract_cookiesc             C   s†   | d k	 rE | d k s$ | d k r0 t  d É Ç |  j | | | =nW | d k	 rz | d k ri t  d É Ç |  j | | =n" | d k	 rì |  j | =n	 i  |  _ d S)a—  Clear some cookies.

        Invoking this method without arguments will clear all cookies.  If
        given a single argument, only cookies belonging to that domain will be
        removed.  If given two arguments, cookies belonging to the specified
        path within that domain are removed.  If given three arguments, then
        the cookie with the specified name, path and domain is removed.

        Raises KeyError if no matching cookie exists.

        Nz8domain and path must be given to remove a cookie by namez.domain must be given to remove cookies by path)rL   r8  )rÀ   râ   rä   rz   r   r   r   rT  á  s    		zCookieJar.clearc             C   s\   |  j  j É  z: x3 |  D]+ } | j r |  j | j | j | j É q WWd |  j  j É  Xd S)zªDiscard all session cookies.

        Note that the .save() method won't save session cookies anyway, unless
        you ask otherwise by passing a true ignore_discard argument.

        N)r7  rH  r≈   rT  râ   rä   rz   rI  )rÀ   r·   r   r   r   ⁄clear_session_cookies¢  s    	$zCookieJar.clear_session_cookiesc             C   sn   |  j  j É  zL t j É  } x9 |  D]1 } | j | É r# |  j | j | j | j É q# WWd |  j  j É  Xd S)aî  Discard all expired cookies.

        You probably don't need to call this method: expired cookies are never
        sent back to the server (provided you're using DefaultCookiePolicy),
        this method is called by CookieJar itself every so often, and the
        .save() method won't save expired cookies anyway (unless you ask
        otherwise by passing a true ignore_expires argument).

        N)	r7  rH  rM   r‘   rT  râ   rä   rz   rI  )rÀ   r”   r·   r   r   r   rJ  ±  s    
$zCookieJar.clear_expired_cookiesc             C   s   t  |  j É S)N)r/  r8  )rÀ   r   r   r   ⁄__iter__ƒ  s    zCookieJar.__iter__c             C   s%   d } x |  D] } | d } q W| S)z#Return number of contained cookies.r	   r   r   )rÀ   r¢   r·   r   r   r   ⁄__len__«  s     zCookieJar.__len__c             C   sG   g  } x! |  D] } | j  t | É É q Wd |  j j d j | É f S)Nz<%s[%s]>z, )rt   rŸ   r⁄   r€   r~   )rÀ   ⁄rr·   r   r   r   r‹   Õ  s     zCookieJar.__repr__c             C   sG   g  } x! |  D] } | j  t | É É q Wd |  j j d j | É f S)Nz<%s[%s]>z, )rt   rm   r⁄   r€   r~   )rÀ   rg  r·   r   r   r   r◊   “  s     zCookieJar.__str__)"r€   r›   rﬁ   rﬂ   rv   ⁄compilerC  rD  Zstrict_domain_reZ	domain_reZdots_re⁄ASCII⁄magic_rerÕ   r:  r<  r>  rF  rG  rR  rW  rX  rY  r_  ra  r`  rc  rT  rd  rJ  re  rf  r‹   r◊   r   r   r   r   r   »  s8   ;!a\	6c               @   s   e  Z d  Z d S)r   N)r€   r›   rﬁ   r   r   r   r   r   Ÿ  s    c               @   sj   e  Z d  Z d Z d d d d d Ñ Z d d d d d Ñ Z d d d d d	 Ñ Z d d d d
 d Ñ Z d S)r   z6CookieJar that can be loaded from and saved to a file.NFc          	   C   s[   t  j |  | É | d k	 r? y | d Wn t d É Ç Yn X| |  _ t | É |  _ d S)z}
        Cookies are NOT loaded from the named file until either the .load() or
        .revert() method is called.

        NrV   zfilename must be string-like)r   rÕ   rL   ⁄filenamerS  ⁄	delayload)rÀ   rk  rl  r9  r   r   r   rÕ   ﬁ  s    	zFileCookieJar.__init__c             C   s   t  É  Ç d S)zSave cookies to a file.N)r‡   )rÀ   rk  ⁄ignore_discard⁄ignore_expiresr   r   r   ⁄saveÌ  s    zFileCookieJar.savec             C   sc   | d k r3 |  j  d k	 r' |  j  } n t t É Ç t | É è } |  j | | | | É Wd QRXd S)zLoad cookies from a file.N)rk  rL   ⁄MISSING_FILENAME_TEXT⁄open⁄_really_load)rÀ   rk  rm  rn  r   r   r   r   ⁄loadÒ  s     zFileCookieJar.loadc             C   s¨   | d k r3 |  j  d k	 r' |  j  } n t t É Ç |  j j É  zW t j |  j É } i  |  _ y |  j | | | É Wn t	 k
 rï | |  _ Ç  Yn XWd |  j j
 É  Xd S)z»Clear all cookies and reload cookies from a saved file.

        Raises LoadError (or OSError) if reversion is not successful; the
        object's state will not be altered if this happens.

        N)rk  rL   rp  r7  rH  r…   ⁄deepcopyr8  rs  ⁄OSErrorrI  )rÀ   rk  rm  rn  Z	old_stater   r   r   ⁄revert˙  s     		zFileCookieJar.revert)r€   r›   rﬁ   rﬂ   rÕ   ro  rs  rv  r   r   r   r   r   €  s   	c             C   sò  |  j  |  j f d |  j f d |  j f g } |  j d k	 rR | j d |  j f É |  j rh | j d É |  j r~ | j d É |  j rî | j d É |  j	 r™ | j d É |  j
 r’ | j d	 t t |  j
 É É f É |  j rÎ | j d É |  j r
| j d |  j f É |  j r)| j d |  j f É t |  j j É  É } x. | D]& } | j | t |  j | É f É qEW| j d t |  j É f É t | g É S)zêReturn string representation of Cookie in the LWP cookie file format.

    Actually, the format is extended a bit -- see module docstring.

    rä   râ   Nrç   ⁄	path_spec⁄	port_spec⁄
domain_dotrã   rà   r≈   r∆   rL  rå   )rw  N)rx  N)ry  N)rã   N)r≈   N)rz   r{   rä   râ   rç   rt   rƒ   r¡   r√   rã   rà   r5   rZ   r≈   r∆   r«   r)  r    r*  rm   rå   rÉ   )r·   rΩ   r*  rÅ   r   r   r   ⁄lwp_cookie_str  s6     	 	 	 	 	 		 	 	 $rz  c               @   sI   e  Z d  Z d Z d d d d Ñ Z d d d d d Ñ Z d	 d
 Ñ  Z d S)r   a[  
    The LWPCookieJar saves a sequence of "Set-Cookie3" lines.
    "Set-Cookie3" is the format used by the libwww-perl library, not known
    to be compatible with any browser, but which is easy to read and
    doesn't lose information about RFC 2965 cookies.

    Additional methods

    as_lwp_str(ignore_discard=True, ignore_expired=True)

    Tc             C   sz   t  j  É  } g  } xQ |  D]I } | r2 | j r2 q | rK | j | É rK q | j d t | É É q Wd j | d g É S)zûReturn cookies as a string of "\n"-separated "Set-Cookie3" headers.

        ignore_discard and ignore_expires: see docstring for FileCookieJar.save

        zSet-Cookie3: %s⁄
rV   )rM   r≈   r‘   rt   rz  r~   )rÀ   rm  rn  r”   rg  r·   r   r   r   ⁄
as_lwp_str>  s    zLWPCookieJar.as_lwp_strNFc             C   sv   | d  k r3 |  j  d  k	 r' |  j  } n t t É Ç t | d É è- } | j d É | j |  j | | É É Wd  QRXd  S)N⁄wz#LWP-Cookies-2.0
)rk  rL   rp  rq  ⁄writer|  )rÀ   rk  rm  rn  r   r   r   r   ro  N  s     zLWPCookieJar.savec             C   s˚  | j  É  } |  j j | É s4 d | } t | É Ç t j É  } d } d }	 d }
 y_xX| j  É  } | d k rq P| j | É sÉ qX | t | É d  Ö j É  } x
t | g É D]˘} | d \ } } i  } i  } x |	 D] } d | | <qÿ Wx´ | d d  Ö D]ô \ } } | d  k	 r$| j	 É  } n d  } | |
 k sB| |	 k rH| } | |	 k rs| d  k rfd } | | | <q˝ | |
 k rå| | | <q˝ | | | <q˝ W| j
 } | d É } | d É } | d  k	 r”t | É } | d  k rÂd } | d É } | j d É } t | d É | | | d	 É | d É | | | d É | d
 É | d É | d É | | | d É | d É | É } | rÇ| j rÇqØ | rõ| j | É rõqØ |  j | É qØ WqX WWnC t k
 r»Ç  Yn/ t k
 rˆt É  t d | | f É Ç Yn Xd  S)Nz5%r does not look like a Set-Cookie3 (LWP) format filezSet-Cookie3:rx  rw  ry  rã   r≈   rå   rç   rä   râ   rà   r∆   rL  rV   r	   Fr   Trú   z&invalid Set-Cookie3 format file %r: %r)rx  rw  ry  rã   r≈   )rå   rç   rä   râ   rà   r∆   rL  )⁄readlinerj  r@   r   rM   ru   r  rî   r|   rK   rœ   rd   r   r≈   r‘   r`  ru  r\  r   )rÀ   r   rk  rm  rn  ⁄magicr   r”   ⁄headerrO  rP  ⁄line⁄datarz   r{   rQ  rÃ   rÅ   rÇ   rö   rΩ   rà   r≈   râ   r¬   rb  r   r   r   rr  Z  så          					zLWPCookieJar._really_load)r€   r›   rﬁ   rﬂ   r|  ro  rr  r   r   r   r   r   1  s   c               @   sL   e  Z d  Z d Z e j d É Z d Z d d Ñ  Z d d d d d	 Ñ Z	 d S)
r   aí  

    WARNING: you may want to backup your browser's cookies file if you use
    this class to save cookies.  I *think* it works, but there have been
    bugs in the past!

    This class differs from CookieJar only in the format it uses to save and
    load cookies to and from a file.  This class uses the Mozilla/Netscape
    `cookies.txt' format.  lynx uses this file format, too.

    Don't expect cookies saved while the browser is running to be noticed by
    the browser (in fact, Mozilla on unix will overwrite your saved cookies if
    you change them on disk while it's running; on Windows, you probably can't
    save at all while the browser is running).

    Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
    Netscape cookies on saving.

    In particular, the cookie version and port number information is lost,
    together with information about whether or not Path, Port and Discard were
    specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
    domain as set in the HTTP header started with a dot (yes, I'm aware some
    domains in Netscape files start with a dot and some don't -- trust me, you
    really don't want to know any more about this).

    Note that though Mozilla and Netscape use the same format, they use
    slightly different headers.  The class saves cookies using the Netscape
    header by default (Mozilla can cope with that).

    z#( Netscape)? HTTP Cookie Filezr# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

c             C   sˆ  t  j  É  } | j É  } |  j j | É s: t d | É Ç yrxk| j É  } | d k rY P| j d É rx | d  d Ö } | j É  j d É s@ | j É  d k r¢ q@ | j d É \ } }	 }
 } } } } | d k } |	 d k }	 | d k rˆ | } d  } | j d	 É } |	 | k st	 Ç d
 } | d k r5d  } d } t
 d | | d  d
 | |	 | |
 d
 | | | d  d  i  É } | rÅ| j rÅq@ | rö| j | É röq@ |  j | É q@ WWnC t k
 r√Ç  Yn/ t k
 rÒt É  t d | | f É Ç Yn Xd  S)Nz4%r does not look like a Netscape format cookies filerV   r{  r   ˙#r   ˙	⁄TRUErú   FTr	   z+invalid Netscape format cookies file %r: %rrÖ   )rÑ  r   )rM   r  rj  r@   r   rÜ   rî   ru   rì   rn   r   r≈   r‘   r`  ru  r\  r   )rÀ   r   rk  rm  rn  r”   rÄ  rÇ  râ   r¬   rä   rã   rà   rz   r{   r•   r≈   rb  r   r   r   rr  –  sb    
  $		zMozillaCookieJar._really_loadNFc             C   sq  | d  k r3 |  j  d  k	 r' |  j  } n t t É Ç t | d É è(} | j |  j É t j É  } x|  D]˙ } | rÅ | j rÅ qh | rö | j | É rö qh | j	 r¨ d } n d } | j
 j d É rÕ d } n d } | j d  k	 rÙ t | j É }	 n d }	 | j d  k rd }
 | j } n | j }
 | j } | j d j | j
 | | j | |	 |
 | g É d É qh WWd  QRXd  S)Nr}  rÜ  ZFALSErú   rV   rÖ  r{  )rk  rL   rp  rq  r~  rÅ  rM   r≈   r‘   rã   râ   ru   rà   rm   r{   rz   r~   rä   )rÀ   rk  rm  rn  r   r”   r·   rã   r•   rà   rz   r{   r   r   r   ro    s<     	 	 			zMozillaCookieJar.save)
r€   r›   rﬁ   rﬂ   rv   rh  rj  rÅ  rr  ro  r   r   r   r   r   ©  s
   A)Yrﬂ   ⁄__all__r…   r-   rv   rM   Zurllib.parser®   Zurllib.requestZ	threadingr5  ⁄ImportErrorZdummy_threadingZhttp.clientZhttpZcalendarr
   r   r   r   rm   ZclientZ	HTTP_PORTr∏   rp  r   r%   r,   r6   r7   rI   r(   rt   rK   r5   r8   r>   rh  ri  r?   rF   rS   rX   ⁄Ir\   ⁄Xr^   ra   rb   rd   rj   ro   rp   rr   rq   r|   r}   rÉ   rá   rõ   rù   rû   r£   r§   r¶   r™   rÆ   r≤   r∂   rπ   rª   rº   r∫   r¥   rø   r¿   r   r   r   r,  r/  r3  r   ru  r   r   rz  r   r   r   r   r   r   ⁄<module>   s™   
 88!UD'

#b!ˇ Rˇ ˇ :x                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
ì≠[>S  „               @   s  d  Z  d d l Z d d l Z d d d g Z d j Z d j Z d j Z d	 d
 Ñ  Z Gd d Ñ  d e	 É Z
 e j e j d Z e d Z d d Ñ  e e d É É e e e e É É DÉ Z e j e d É d e d É d i É e j d e j e É É j Z d d Ñ  Z e j d É Z e j d É Z d d Ñ  Z d d d d d  d! d" g Z d d# d$ d% d& d' d( d) d* d+ d, d- d. g Z d e e d/ d0 Ñ Z Gd1 d2 Ñ  d2 e  É Z! d3 Z" e" d4 Z# e j d5 e" d6 e# d7 e j$ É Z% Gd8 d Ñ  d e  É Z& Gd9 d Ñ  d e& É Z' d S):a.
  
Here's a sample session to show how to use this module.
At the moment, this is the only documentation.

The Basics
----------

Importing is easy...

   >>> from http import cookies

Most of the time you start by creating a cookie.

   >>> C = cookies.SimpleCookie()

Once you've created your Cookie, you can add values just as if it were
a dictionary.

   >>> C = cookies.SimpleCookie()
   >>> C["fig"] = "newton"
   >>> C["sugar"] = "wafer"
   >>> C.output()
   'Set-Cookie: fig=newton\r\nSet-Cookie: sugar=wafer'

Notice that the printable representation of a Cookie is the
appropriate format for a Set-Cookie: header.  This is the
default behavior.  You can change the header and printed
attributes by using the .output() function

   >>> C = cookies.SimpleCookie()
   >>> C["rocky"] = "road"
   >>> C["rocky"]["path"] = "/cookie"
   >>> print(C.output(header="Cookie:"))
   Cookie: rocky=road; Path=/cookie
   >>> print(C.output(attrs=[], header="Cookie:"))
   Cookie: rocky=road

The load() method of a Cookie extracts cookies from a string.  In a
CGI script, you would use this method to extract the cookies from the
HTTP_COOKIE environment variable.

   >>> C = cookies.SimpleCookie()
   >>> C.load("chips=ahoy; vienna=finger")
   >>> C.output()
   'Set-Cookie: chips=ahoy\r\nSet-Cookie: vienna=finger'

The load() method is darn-tootin smart about identifying cookies
within a string.  Escaped quotation marks, nested semicolons, and other
such trickeries do not confuse it.

   >>> C = cookies.SimpleCookie()
   >>> C.load('keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";')
   >>> print(C)
   Set-Cookie: keebler="E=everybody; L=\"Loves\"; fudge=\012;"

Each element of the Cookie also supports all of the RFC 2109
Cookie attributes.  Here's an example which sets the Path
attribute.

   >>> C = cookies.SimpleCookie()
   >>> C["oreo"] = "doublestuff"
   >>> C["oreo"]["path"] = "/"
   >>> print(C)
   Set-Cookie: oreo=doublestuff; Path=/

Each dictionary element has a 'value' attribute, which gives you
back the value associated with the key.

   >>> C = cookies.SimpleCookie()
   >>> C["twix"] = "none for you"
   >>> C["twix"].value
   'none for you'

The SimpleCookie expects that all values should be standard strings.
Just to be sure, SimpleCookie invokes the str() builtin to convert
the value to a string, when the values are set dictionary-style.

   >>> C = cookies.SimpleCookie()
   >>> C["number"] = 7
   >>> C["string"] = "seven"
   >>> C["number"].value
   '7'
   >>> C["string"].value
   'seven'
   >>> C.output()
   'Set-Cookie: number=7\r\nSet-Cookie: string=seven'

Finis.
È    N⁄CookieError⁄
BaseCookie⁄SimpleCookie⁄ z; ˙ c             C   s0   d d  l  } d |  } | j | t d d Éd  S)Nr   zvThe .%s setter is deprecated. The attribute will be read-only in future releases. Please use the set() method instead.⁄
stacklevelÈ   )⁄warnings⁄warn⁄DeprecationWarning)⁄setterr	   ⁄msg© r   ˙"/usr/lib/python3.5/http/cookies.py⁄_warn_deprecated_setterç   s    r   c               @   s   e  Z d  Z d S)r   N)⁄__name__⁄
__module__⁄__qualname__r   r   r   r   r   ñ   s   z!#$%&'*+-.^_`|~:z ()/<=>?@[]{}c             C   s   i  |  ] } d  | | ì q S)z\%03or   )⁄.0⁄nr   r   r   ˙
<dictcomp>™   s   	r   È   ˙"z\"˙\z\\z[%s]+c             C   s5   |  d k s t  |  É r |  Sd |  j t É d Sd S)z„Quote a string for use in a cookie header.

    If the string does not need to be double-quoted, then just return the
    string.  Otherwise, surround the string in doublequotes and quote
    (with a \) special characters.
    Nr   )⁄_is_legal_key⁄	translate⁄_Translator)⁄strr   r   r   ⁄_quote≥   s    r   z\\[0-3][0-7][0-7]z[\\].c             C   s∫  |  d  k s t  |  É d k  r" |  S|  d d k sB |  d d k rF |  S|  d d Ö }  d } t  |  É } g  } x?d | k oà | k  n rØt j |  | É } t j |  | É } | r◊ | r◊ | j |  | d  Ö É Pd	 } } | rˆ | j d É } | r| j d É } | r]| s$| | k  r]| j |  | | Ö É | j |  | d É | d } qq | j |  | | Ö É | j t t |  | d | d Ö d É É É | d } qq Wt | É S)
NÈ   r   r   È   È   È   Èˇˇˇˇr#   r#   )	⁄len⁄
_OctalPatt⁄search⁄
_QuotePatt⁄append⁄start⁄chr⁄int⁄	_nulljoin)r   ⁄ir   ZresZo_matchZq_match⁄j⁄kr   r   r   ⁄_unquote√   s6     
.r0   ZMonZTueZWedZThuZFriZSatZSunZJanZFebZMarZAprZMayZJunZJulZAugZSepZOctZNovZDecc          	   C   so   d d l  m } m  } | É  } | | |  É \	 } } } }	 }
 } } } } d | | | | | | |	 |
 | f S)Nr   )⁄gmtime⁄timez#%s, %02d %3s %4d %02d:%02d:%02d GMT)r2   r1   )ZfutureZweekdaynameZ	monthnamer1   r2   ZnowZyearZmonthZdayZhhZmmZssZwd⁄y⁄zr   r   r   ⁄_getdate˚   s
    	+r5   c               @   sñ  e  Z d  Z d Z d d d d d d d d d	 d
 d d d d d d i Z d d h Z d d Ñ  Z e d d Ñ  É Z e j	 d d Ñ  É Z e d d Ñ  É Z
 e
 j	 d d Ñ  É Z
 e d d Ñ  É Z e j	 d d Ñ  É Z d d Ñ  Z d d d  Ñ Z d! d" Ñ  Z e j Z d# d$ Ñ  Z d% d& Ñ  Z d' d( Ñ  Z e d) d* Ñ Z d+ d, Ñ  Z d- d. Ñ  Z d d/ d0 d1 Ñ Z e Z d2 d3 Ñ  Z d d4 d5 Ñ Z d d6 d7 Ñ Z d S)8⁄Morselaë  A class to hold ONE (key, value) pair.

    In a cookie, each such pair may have several attributes, so this class is
    used to keep the attributes associated with the appropriate key,value pair.
    This class also includes a coded_value attribute, which is used to hold
    the network representation of the value.  This is most useful when Python
    objects are pickled for network transit.
    ⁄expires⁄pathZPathZcomment⁄CommentZdomainZDomainzmax-agezMax-AgeZsecureZSecureZhttponlyZHttpOnly⁄versionZVersionc             C   sB   d  |  _  |  _ |  _ x$ |  j D] } t j |  | d É q! Wd  S)Nr   )⁄_key⁄_value⁄_coded_value⁄	_reserved⁄dict⁄__setitem__)⁄self⁄keyr   r   r   ⁄__init__&  s    zMorsel.__init__c             C   s   |  j  S)N)r;   )rA   r   r   r   rB   .  s    z
Morsel.keyc             C   s   t  d É | |  _ d  S)NrB   )r   r;   )rA   rB   r   r   r   rB   2  s    
c             C   s   |  j  S)N)r<   )rA   r   r   r   ⁄value7  s    zMorsel.valuec             C   s   t  d É | |  _ d  S)NrD   )r   r<   )rA   rD   r   r   r   rD   ;  s    
c             C   s   |  j  S)N)r=   )rA   r   r   r   ⁄coded_value@  s    zMorsel.coded_valuec             C   s   t  d É | |  _ d  S)NrE   )r   r=   )rA   rE   r   r   r   rE   D  s    
c             C   sE   | j  É  } | |  j k r. t d | f É Ç t j |  | | É d  S)NzInvalid attribute %r)⁄lowerr>   r   r?   r@   )rA   ⁄K⁄Vr   r   r   r@   I  s    zMorsel.__setitem__Nc             C   sA   | j  É  } | |  j k r. t d | f É Ç t j |  | | É S)NzInvalid attribute %r)rF   r>   r   r?   ⁄
setdefault)rA   rB   ⁄valr   r   r   rI   O  s    zMorsel.setdefaultc             C   sY   t  | t É s t St j |  | É oX |  j | j k oX |  j | j k oX |  j | j k S)N)⁄
isinstancer6   ⁄NotImplementedr?   ⁄__eq__r<   r;   r=   )rA   ⁄morselr   r   r   rM   U  s    zMorsel.__eq__c             C   s0   t  É  } t j | |  É | j j |  j É | S)N)r6   r?   ⁄update⁄__dict__)rA   rN   r   r   r   ⁄copy_  s    	zMorsel.copyc             C   su   i  } xX t  | É j É  D]D \ } } | j É  } | |  j k rS t d | f É Ç | | | <q Wt  j |  | É d  S)NzInvalid attribute %r)r?   ⁄itemsrF   r>   r   rO   )rA   ⁄values⁄datarB   rJ   r   r   r   rO   e  s    zMorsel.updatec             C   s   | j  É  |  j k S)N)rF   r>   )rA   rG   r   r   r   ⁄isReservedKeyn  s    zMorsel.isReservedKeyc             C   sî   | t  k r. d d  l } | j d t d d É| j É  |  j k rV t d | f É Ç t | É su t d | f É Ç | |  _ | |  _	 | |  _
 d  S)Nr   zSLegalChars parameter is deprecated, ignored and will be removed in future versions.r   r   z Attempt to set a reserved key %rzIllegal key %r)⁄_LegalCharsr	   r
   r   rF   r>   r   r   r;   r<   r=   )rA   rB   rJ   Z	coded_valZ
LegalCharsr	   r   r   r   ⁄setq  s    		z
Morsel.setc             C   s   d |  j  d |  j d |  j i S)NrB   rD   rE   )r;   r<   r=   )rA   r   r   r   ⁄__getstate__É  s    		zMorsel.__getstate__c             C   s+   | d |  _  | d |  _ | d |  _ d  S)NrB   rD   rE   )r;   r<   r=   )rA   ⁄stater   r   r   ⁄__setstate__ä  s    zMorsel.__setstate__zSet-Cookie:c             C   s   d | |  j  | É f S)Nz%s %s)⁄OutputString)rA   ⁄attrs⁄headerr   r   r   ⁄outputè  s    zMorsel.outputc             C   s   d |  j  j |  j É  f S)Nz<%s: %s>)⁄	__class__r   r[   )rA   r   r   r   ⁄__repr__î  s    zMorsel.__repr__c             C   s   d |  j  | É j d d É S)Nzó
        <script type="text/javascript">
        <!-- begin hiding
        document.cookie = "%s";
        // end hiding -->
        </script>
        r   z\")r[   ⁄replace)rA   r\   r   r   r   ⁄	js_outputó  s    zMorsel.js_outputc             C   sQ  g  } | j  } | d |  j |  j f É | d  k r> |  j } t |  j É  É } xÙ | D]Ï \ } } | d k rr qW | | k rÅ qW | d k r¿ t | t É r¿ | d |  j | t | É f É qW | d k r˘ t | t É r˘ | d |  j | | f É qW | |  j	 k r(| rC| t
 |  j | É É qW | d |  j | | f É qW Wt | É S)Nz%s=%sr   r7   zmax-agez%s=%d)r(   rB   rE   r>   ⁄sortedrR   rK   r+   r5   ⁄_flagsr   ⁄_semispacejoin)rA   r\   ⁄resultr(   rR   rB   rD   r   r   r   r[   °  s(    		$zMorsel.OutputString)r   r   r   ⁄__doc__r>   rd   rC   ⁄propertyrB   r   rD   rE   r@   rI   rM   ⁄object⁄__ne__rQ   rO   rU   rV   rW   rX   rZ   r^   ⁄__str__r`   rb   r[   r   r   r   r   r6     s@   		
r6   z,\w\d!#%&'~_`><@,:/\$\*\+\-\.\^\|\)\(\?\}\{\=z\[\]zÀ
    (?x)                           # This is a verbose pattern
    \s*                            # Optional whitespace at start of cookie
    (?P<key>                       # Start of group 'key'
    [a	  ]+?   # Any word of at least one letter
    )                              # End of group 'key'
    (                              # Optional group: there may not be a value.
    \s*=\s*                          # Equal Sign
    (?P<val>                         # Start of group 'val'
    "(?:[^\\"]|\\.)*"                  # Any doublequoted string
    |                                  # or
    \w{3},\s[\w\d\s-]{9,11}\s[\d:]{8}\sGMT  # Special case for "expires" attr
    |                                  # or
    [a-  ]*      # Any word or empty string
    )                                # End of group 'val'
    )?                             # End of optional value group
    \s*                            # Any number of spaces.
    (\s+|;|$)                      # Ending either at space, semicolon, or EOS.
    c               @   s¶   e  Z d  Z d Z d d Ñ  Z d d Ñ  Z d d d Ñ Z d	 d
 Ñ  Z d d Ñ  Z d d d d d Ñ Z	 e	 Z
 d d Ñ  Z d d d Ñ Z d d Ñ  Z e d d Ñ Z d S)r   z'A container class for a set of Morsels.c             C   s
   | | f S)a
  real_value, coded_value = value_decode(STRING)
        Called prior to setting a cookie's value from the network
        representation.  The VALUE is the value read from HTTP
        header.
        Override this function to modify the behavior of cookies.
        r   )rA   rJ   r   r   r   ⁄value_decodeÁ  s    zBaseCookie.value_decodec             C   s   t  | É } | | f S)z˝real_value, coded_value = value_encode(VALUE)
        Called prior to setting a cookie's value from the dictionary
        representation.  The VALUE is the value being assigned.
        Override this function to modify the behavior of cookies.
        )r   )rA   rJ   ⁄strvalr   r   r   ⁄value_encode  s    zBaseCookie.value_encodeNc             C   s   | r |  j  | É d  S)N)⁄load)rA   ⁄inputr   r   r   rC   ˘  s    zBaseCookie.__init__c             C   s?   |  j  | t É  É } | j | | | É t j |  | | É d S)z+Private method for setting a cookie's valueN)⁄getr6   rW   r?   r@   )rA   rB   Z
real_valuerE   ⁄Mr   r   r   Z__set˝  s    zBaseCookie.__setc             C   sQ   t  | t É r% t j |  | | É n( |  j | É \ } } |  j | | | É d S)zDictionary style assignment.N)rK   r6   r?   r@   rn   ⁄_BaseCookie__set)rA   rB   rD   ⁄rval⁄cvalr   r   r   r@     s    zBaseCookie.__setitem__zSet-Cookie:z
c             C   sU   g  } t  |  j É  É } x- | D]% \ } } | j | j | | É É q W| j | É S)z"Return a string suitable for HTTP.)rc   rR   r(   r^   ⁄join)rA   r\   r]   ⁄seprf   rR   rB   rD   r   r   r   r^     s
    zBaseCookie.outputc             C   si   g  } t  |  j É  É } x4 | D], \ } } | j d | t | j É f É q Wd |  j j t | É f S)Nz%s=%sz<%s: %s>)rc   rR   r(   ⁄reprrD   r_   r   ⁄
_spacejoin)rA   ⁄lrR   rB   rD   r   r   r   r`     s
    $zBaseCookie.__repr__c             C   sO   g  } t  |  j É  É } x* | D]" \ } } | j | j | É É q Wt | É S)z(Return a string suitable for JavaScript.)rc   rR   r(   rb   r,   )rA   r\   rf   rR   rB   rD   r   r   r   rb     s
    zBaseCookie.js_outputc             C   sJ   t  | t É r |  j | É n' x$ | j É  D] \ } } | |  | <q, Wd S)z›Load cookies from a string (presumably HTTP_COOKIE) or
        from a dictionary.  Loading cookies from a dictionary 'd'
        is equivalent to calling:
            map(Cookie.__setitem__, d.keys(), d.values())
        N)rK   r   ⁄_BaseCookie__parse_stringrR   )rA   ZrawdatarB   rD   r   r   r   ro   %  s
    zBaseCookie.loadc             C   s  d } t  | É } g  } d } d } d } xZd | k oD | k  n rÜ| j | | É }	 |	 sb P|	 j d É |	 j d É }
 } |	 j d É } |
 d d k rÃ | s© q- | j | |
 d d  Ö | f É q- |
 j É  t j k rK| sÎ d  S| d  k r,|
 j É  t j k r%| j | |
 d f É qHd  SqÉ| j | |
 t	 | É f É q- | d  k	 r| j | |
 |  j
 | É f É d } q- d  Sq- Wd  } x} | D]u \ } }
 } | | k rŒ| d  k	 s¡t Ç | | |
 <qî| | k s‡t Ç | \ } } |  j |
 | | É |  |
 } qîWd  S)	Nr   Fr    r   rB   rJ   ˙$T)r$   ⁄match⁄group⁄endr(   rF   r6   r>   rd   r0   rl   ⁄AssertionErrorrs   )rA   r   Zpattr-   r   Zparsed_itemsZmorsel_seenZTYPE_ATTRIBUTEZTYPE_KEYVALUEr}   rB   rD   rr   ⁄tprt   ru   r   r   r   Z__parse_string3  sJ    #	zBaseCookie.__parse_string)r   r   r   rg   rl   rn   rC   rs   r@   r^   rk   r`   rb   ro   ⁄_CookiePatternr{   r   r   r   r   r   ‰  s   			c               @   s.   e  Z d  Z d Z d d Ñ  Z d d Ñ  Z d S)r   z˛
    SimpleCookie supports strings as cookie values.  When setting
    the value using the dictionary assignment notation, SimpleCookie
    calls the builtin str() to convert the value to a string.  Values
    received from HTTP are kept as strings.
    c             C   s   t  | É | f S)N)r0   )rA   rJ   r   r   r   rl   w  s    zSimpleCookie.value_decodec             C   s   t  | É } | t | É f S)N)r   r   )rA   rJ   rm   r   r   r   rn   z  s    zSimpleCookie.value_encodeN)r   r   r   rg   rl   rn   r   r   r   r   r   p  s   )(rg   ⁄re⁄string⁄__all__rv   r,   re   ry   r   ⁄	Exceptionr   Zascii_lettersZdigitsrV   Z_UnescapedCharsrW   ⁄range⁄map⁄ordr   rO   ⁄compile⁄escape⁄	fullmatchr   r   r%   r'   r0   Z_weekdaynameZ
_monthnamer5   r?   r6   Z_LegalKeyCharsZ_LegalValueChars⁄ASCIIrÇ   r   r   r   r   r   r   ⁄<module>   sB   				
	)2«
å                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
ì≠[“´  „               @   sb  d  Z  d Z d d d d g Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d	 Z d
 Z d d Ñ  Z Gd d Ñ  d e j É Z Gd d Ñ  d e j É Z Gd d Ñ  d e É Z d d Ñ  Z d a d d Ñ  Z d d Ñ  Z  Gd d Ñ  d e É Z! e e d d d d d Ñ Z" e# d k r^e j$ É  Z% e% j& d d d d  d! Ée% j& d" d# d$ d d% d& d  d' Ée% j& d( d d) d$ d d* e' d+ d, d  d- Ée% j( É  Z) e) j* r9e! Z+ n e Z+ e" d. e+ d( e) j, d/ e) j- É d S)0a@  HTTP server classes.

Note: BaseHTTPRequestHandler doesn't implement any HTTP request; see
SimpleHTTPRequestHandler for simple implementations of GET, HEAD and POST,
and CGIHTTPRequestHandler for CGI scripts.

It does, however, optionally implement HTTP/1.1 persistent connections,
as of version 0.3.

Notes on CGIHTTPRequestHandler
------------------------------

This class implements GET and POST requests to cgi-bin scripts.

If the os.fork() function is not present (e.g. on Windows),
subprocess.Popen() is used as a fallback, with slightly altered semantics.

In all cases, the implementation is intentionally naive -- all
requests are executed synchronously.

SECURITY WARNING: DON'T USE THIS CODE UNLESS YOU ARE INSIDE A FIREWALL
-- it may execute arbitrary Python code or external programs.

Note that status code 200 is sent prior to execution of a CGI script, so
scripts cannot send other status codes such as 302 (redirect).

XXX To do:

- log requests even later (to capture byte count)
- log user-agent header and other interesting goodies
- send error log to separate file
z0.6⁄
HTTPServer⁄BaseHTTPRequestHandler⁄SimpleHTTPRequestHandler⁄CGIHTTPRequestHandlerÈ    N)⁄
HTTPStatusaπ  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
        <title>Error response</title>
    </head>
    <body>
        <h1>Error response</h1>
        <p>Error code: %(code)d</p>
        <p>Message: %(message)s.</p>
        <p>Error code explanation: %(code)s - %(explain)s.</p>
    </body>
</html>
ztext/html;charset=utf-8c             C   s(   |  j  d d É j  d d É j  d d É S)N˙&z&amp;˙<z&lt;˙>z&gt;)⁄replace)⁄html© r   ˙!/usr/lib/python3.5/http/server.py⁄_quote_htmlÅ   s    r   c               @   s"   e  Z d  Z d Z d d Ñ  Z d S)r   È   c             C   sN   t  j j |  É |  j j É  d d Ö \ } } t j | É |  _ | |  _ d S)z.Override server_bind to store the server name.NÈ   )⁄socketserver⁄	TCPServer⁄server_bind⁄socket⁄getsocknameZgetfqdn⁄server_name⁄server_port)⁄selfZhost⁄portr   r   r   r   à   s    zHTTPServer.server_bindN)⁄__name__⁄
__module__⁄__qualname__Zallow_reuse_addressr   r   r   r   r   r   Ñ   s   c               @   s†  e  Z d  Z d Z d e j j É  d Z d e Z	 e
 Z e Z d Z d d Ñ  Z d d	 Ñ  Z d
 d Ñ  Z d d Ñ  Z d d d d Ñ Z d d d Ñ Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d d Ñ Z d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z d d$ d% Ñ Z d& d' Ñ  Z d( d) d* d+ d, d- d. g Z d d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: g Z  d; d< Ñ  Z! d= Z" e# j$ j% Z& d> d? Ñ  e' j( j) É  DÉ Z* d S)@r   aø  HTTP request handler base class.

    The following explanation of HTTP serves to guide you through the
    code as well as to expose any misunderstandings I may have about
    HTTP (so you don't need to read the code to figure out I'm wrong
    :-).

    HTTP (HyperText Transfer Protocol) is an extensible protocol on
    top of a reliable stream transport (e.g. TCP/IP).  The protocol
    recognizes three parts to a request:

    1. One line identifying the request type and path
    2. An optional set of RFC-822-style headers
    3. An optional data part

    The headers and data are separated by a blank line.

    The first line of the request has the form

    <command> <path> <version>

    where <command> is a (case-sensitive) keyword such as GET or POST,
    <path> is a string containing path information for the request,
    and <version> should be the string "HTTP/1.0" or "HTTP/1.1".
    <path> is encoded using the URL encoding scheme (using %xx to signify
    the ASCII character with hex code xx).

    The specification specifies that lines are separated by CRLF but
    for compatibility with the widest range of clients recommends
    servers also handle LF.  Similarly, whitespace in the request line
    is treated sensibly (allowing multiple spaces between components
    and allowing trailing whitespace).

    Similarly, for output, lines ought to be separated by CRLF pairs
    but most clients grok LF characters just fine.

    If the first line of the request has the form

    <command> <path>

    (i.e. <version> is left out) then this is assumed to be an HTTP
    0.9 request; this form has no optional headers and data part and
    the reply consists of just the data.

    The reply form of the HTTP 1.x protocol again has three parts:

    1. One line giving the response code
    2. An optional set of RFC-822-style headers
    3. The data

    Again, the headers and data are separated by a blank line.

    The response code line has the form

    <version> <responsecode> <responsestring>

    where <version> is the protocol version ("HTTP/1.0" or "HTTP/1.1"),
    <responsecode> is a 3-digit response code indicating success or
    failure of the request, and <responsestring> is an optional
    human-readable string explaining what the response code means.

    This server parses the request and the headers, and then calls a
    function specific to the request type (<command>).  Specifically,
    a request SPAM will be handled by a method do_SPAM().  If no
    such method exists the server sends an error response to the
    client.  If it exists, it is called with no arguments:

    do_SPAM()

    Note that the request name is case sensitive (i.e. SPAM and spam
    are different requests).

    The various request details are stored in instance variables:

    - client_address is the client IP address in the form (host,
    port);

    - command, path and version are the broken-down request line;

    - headers is an instance of email.message.Message (or a derived
    class) containing the header information;

    - rfile is a file object open for reading positioned at the
    start of the optional input data part;

    - wfile is a file object open for writing.

    IT IS IMPORTANT TO ADHERE TO THE PROTOCOL FOR WRITING!

    The first thing to be written must be the response line.  Then
    follow 0 or more header lines, then a blank line, and then the
    actual data (if any).  The meaning of the header lines depends on
    the command executed by the server; in most cases, when data is
    returned, there should be at least one header line of the form

    Content-type: <type>/<subtype>

    where <type> and <subtype> should be registered MIME types,
    e.g. "text/html" or "text/plain".

    zPython/r   z	BaseHTTP/zHTTP/0.9c             C   sy  d |  _  |  j |  _ } d |  _ t |  j d É } | j d É } | |  _ | j É  } t	 | É d k rè| \ } } } | d d Ö d k r™ |  j
 t j d | É d	 Sya | j d
 d É d } | j d É } t	 | É d k rÍ t Ç t | d É t | d É f } Wn3 t t f k
 r@|  j
 t j d | É d	 SYn X| d k re|  j d k red	 |  _ | d k r|  j
 t j d | É d	 Snv t	 | É d k r‡| \ } } d |  _ | d k r|  j
 t j d | É d	 Sn% | sÍd	 S|  j
 t j d | É d	 S| | | |  _  |  _ |  _ y% t j j |  j d |  j É|  _ Wny t j j k
 rx|  j
 t j d É d	 SYnK t j j k
 r¬} z% |  j
 t j d t | É É d	 SWYd d } ~ Xn X|  j j d d É }	 |	 j É  d k rˆd |  _ n* |	 j É  d k r |  j d k r d	 |  _ |  j j d d É }
 |
 j É  d k ru|  j d k ru|  j d k ru|  j É  sud	 Sd S)a'  Parse a request (internal).

        The request should be stored in self.raw_requestline; the results
        are in self.command, self.path, self.request_version and
        self.headers.

        Return True for success, False for failure; on failure, an
        error is sent back.

        NTz
iso-8859-1z
È   È   zHTTP/zBad request version (%r)F˙/r   ⁄.r   r   zHTTP/1.1zInvalid HTTP Version (%s)ZGETzBad HTTP/0.9 request type (%r)zBad request syntax (%r)Z_classzLine too longzToo many headers⁄
Connection⁄ ⁄closez
keep-aliveZExpectz100-continue)r   r   )r   r   )⁄command⁄default_request_version⁄request_version⁄close_connection⁄str⁄raw_requestline⁄rstrip⁄requestline⁄split⁄len⁄
send_errorr   ZBAD_REQUEST⁄
ValueError⁄int⁄
IndexError⁄protocol_versionZHTTP_VERSION_NOT_SUPPORTED⁄path⁄http⁄clientZparse_headers⁄rfile⁄MessageClass⁄headersZLineTooLongZHTTPExceptionZREQUEST_HEADER_FIELDS_TOO_LARGE⁄get⁄lower⁄handle_expect_100)r   ⁄versionr+   ⁄wordsr$   r3   Zbase_version_numberZversion_number⁄errZconntypeZexpectr   r   r   ⁄parse_request	  sî    			$				z$BaseHTTPRequestHandler.parse_requestc             C   s   |  j  t j É |  j É  d S)a7  Decide what to do with an "Expect: 100-continue" header.

        If the client is expecting a 100 Continue response, we must
        respond with either a 100 Continue or a final response before
        waiting for the request body. The default is to always respond
        with a 100 Continue. You can behave differently (for example,
        reject unauthorized requests) by overriding this method.

        This method should either return True (possibly after sending
        a 100 Continue response) or send an error response and return
        False.

        T)⁄send_response_onlyr   ZCONTINUE⁄end_headers)r   r   r   r   r;   k  s    
z(BaseHTTPRequestHandler.handle_expect_100c             C   s,  y‡ |  j  j d É |  _ t |  j É d k r\ d |  _ d |  _ d |  _ |  j t j	 É d S|  j sr d |  _
 d S|  j É  sÇ d Sd |  j } t |  | É sº |  j t j d |  j É d St |  | É } | É  |  j j É  WnE t j k
 r'} z" |  j d | É d |  _
 d SWYd d } ~ Xn Xd S)	z‹Handle a single HTTP request.

        You normally don't need to override this method; see the class
        __doc__ string for information on how to handle specific HTTP
        commands such as GET and POST.

        i  i   r"   NTZdo_zUnsupported method (%r)zRequest timed out: %r)r6   ⁄readliner)   r-   r+   r&   r$   r.   r   ZREQUEST_URI_TOO_LONGr'   r?   ⁄hasattr⁄NOT_IMPLEMENTED⁄getattr⁄wfile⁄flushr   Ztimeout⁄	log_error)r   Zmname⁄method⁄er   r   r   ⁄handle_one_request}  s4    						z)BaseHTTPRequestHandler.handle_one_requestc             C   s1   d |  _  |  j É  x |  j  s, |  j É  q Wd S)z&Handle multiple requests if necessary.TN)r'   rK   )r   r   r   r   ⁄handle¢  s    	
zBaseHTTPRequestHandler.handleNc             C   s^  y |  j  | \ } } Wn t k
 r7 d \ } } Yn X| d k rJ | } | d k r\ | } |  j d | | É |  j | | É |  j d d É d } | d k r+| t j t j t j f k r+|  j	 d | d t
 | É d	 t
 | É i } | j d
 d É } |  j d |  j É |  j d t t | É É É |  j É  |  j d k rZ| rZ|  j j | É d S)ak  Send and log an error reply.

        Arguments are
        * code:    an HTTP error code
                   3 digits
        * message: a simple optional 1 line reason phrase.
                   *( HTAB / SP / VCHAR / %x80-FF )
                   defaults to short entry matching the response code
        * explain: a detailed message defaults to the long entry
                   matching the response code.

        This sends an error response (so it must be called before any
        output has been generated), logs the error, and finally sends
        a piece of HTML explaining the error to the user.

        ˙???Nzcode %d, message %sr!   r#   È»   ⁄code⁄message⁄explainzUTF-8r
   zContent-TypezContent-LengthZHEAD)rM   rM   )⁄	responses⁄KeyErrorrH   ⁄send_response⁄send_headerr   Z
NO_CONTENTZRESET_CONTENTZNOT_MODIFIED⁄error_message_formatr   ⁄encode⁄error_content_typer0   r-   rA   r$   rF   ⁄write)r   rO   rP   rQ   ZshortmsgZlongmsgZbodyZcontentr   r   r   r.   ™  s4    	
z!BaseHTTPRequestHandler.send_errorc             C   sM   |  j  | É |  j | | É |  j d |  j É  É |  j d |  j É  É d S)z¡Add the response header to the headers buffer and log the
        response code.

        Also send two standard headers with the server software
        version and the current date.

        ZServerZDateN)⁄log_requestr@   rU   ⁄version_string⁄date_time_string)r   rO   rP   r   r   r   rT   ﬂ  s    z$BaseHTTPRequestHandler.send_responsec             C   så   | d k r5 | |  j  k r/ |  j  | d } n d } |  j d k rà t |  d É s\ g  |  _ |  j j d |  j | | f j d d É É d S)	zSend the response header only.Nr   r"   zHTTP/0.9⁄_headers_bufferz
%s %d %s
zlatin-1⁄strict)rR   r&   rC   r]   ⁄appendr2   rW   )r   rO   rP   r   r   r   r@   Ï  s    	z)BaseHTTPRequestHandler.send_response_onlyc             C   sú   |  j  d k rM t |  d É s' g  |  _ |  j j d | | f j d d É É | j É  d k rò | j É  d k r} d |  _ n | j É  d	 k rò d
 |  _ d S)z)Send a MIME header to the headers buffer.zHTTP/0.9r]   z%s: %s
zlatin-1r^   Z
connectionr#   Tz
keep-aliveFN)r&   rC   r]   r_   rW   r:   r'   )r   ⁄keyword⁄valuer   r   r   rU   ˙  s    		z"BaseHTTPRequestHandler.send_headerc             C   s-   |  j  d k r) |  j j d É |  j É  d S)z,Send the blank line ending the MIME headers.zHTTP/0.9s   
N)r&   r]   r_   ⁄flush_headers)r   r   r   r   rA     s    z"BaseHTTPRequestHandler.end_headersc             C   s8   t  |  d É r4 |  j j d j |  j É É g  |  _ d  S)Nr]   Û    )rC   rF   rY   ⁄joinr]   )r   r   r   r   rb     s    z$BaseHTTPRequestHandler.flush_headers˙-c             C   sA   t  | t É r | j } |  j d |  j t | É t | É É d S)zNLog an accepted request.

        This is called by send_response().

        z
"%s" %s %sN)⁄
isinstancer   ra   ⁄log_messager+   r(   )r   rO   ⁄sizer   r   r   rZ     s    		z"BaseHTTPRequestHandler.log_requestc             G   s   |  j  | | å d S)zˇLog an error.

        This is called when a request cannot be fulfilled.  By
        default it passes the message on to log_message().

        Arguments are the same as for log_message().

        XXX This should go to the separate error log.

        N)rg   )r   ⁄format⁄argsr   r   r   rH     s    z BaseHTTPRequestHandler.log_errorc             G   s1   t  j j d |  j É  |  j É  | | f É d S)aÎ  Log an arbitrary message.

        This is used by all other logging functions.  Override
        it if you have specific logging wishes.

        The first argument, FORMAT, is a format string for the
        message to be logged.  If the format string contains
        any % escapes requiring parameters, they should be
        specified as subsequent arguments (it's just like
        printf!).

        The client ip and current date/time are prefixed to
        every message.

        z%s - - [%s] %s
N)⁄sys⁄stderrrY   ⁄address_string⁄log_date_time_string)r   ri   rj   r   r   r   rg   ,  s    		z"BaseHTTPRequestHandler.log_messagec             C   s   |  j  d |  j S)z*Return the server software version string.˙ )⁄server_version⁄sys_version)r   r   r   r   r[   B  s    z%BaseHTTPRequestHandler.version_stringc          	   C   ss   | d k r t  j  É  } t  j | É \	 } } } } } } } }	 }
 d |  j | | |  j | | | | | f } | S)z@Return the current date and time formatted for a message header.Nz#%s, %02d %3s %4d %02d:%02d:%02d GMT)⁄timeZgmtime⁄weekdayname⁄	monthname)r   Z	timestamp⁄year⁄month⁄day⁄hh⁄mm⁄ssZwd⁄y⁄z⁄sr   r   r   r\   F  s    *
z'BaseHTTPRequestHandler.date_time_stringc          	   C   s]   t  j  É  } t  j | É \	 } } } } } } } }	 }
 d | |  j | | | | | f } | S)z.Return the current time formatted for logging.z%02d/%3s/%04d %02d:%02d:%02d)rr   Z	localtimert   )r   Znowru   rv   rw   rx   ry   rz   ⁄xr{   r|   r}   r   r   r   rn   Q  s
    * z+BaseHTTPRequestHandler.log_date_time_stringZMonZTueZWedZThuZFriZSatZSunZJanZFebZMarZAprZMayZJunZJulZAugZSepZOctZNovZDecc             C   s   |  j  d S)zReturn the client address.r   )⁄client_address)r   r   r   r   rm   _  s    z%BaseHTTPRequestHandler.address_stringzHTTP/1.0c             C   s%   i  |  ] } | j  | j f | ì q Sr   )⁄phraseZdescription)⁄.0⁄vr   r   r   ˙
<dictcomp>n  s   	z!BaseHTTPRequestHandler.<dictcomp>)+r   r   r   ⁄__doc__rk   r<   r,   rq   ⁄__version__rp   ⁄DEFAULT_ERROR_MESSAGErV   ⁄DEFAULT_ERROR_CONTENT_TYPErX   r%   r?   r;   rK   rL   r.   rT   r@   rU   rA   rb   rZ   rH   rg   r[   r\   rn   rs   rt   rm   r2   r4   r5   ZHTTPMessager7   r   Z__members__⁄valuesrR   r   r   r   r   r   ê   s>   f
b%5		c            	   @   sª   e  Z d  Z d Z d e Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d	 d
 Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z e j sÉ e j É  e j j É  Z e j d d d d d d d d i É d S)r   aW  Simple HTTP request handler with GET and HEAD commands.

    This serves files from the current directory and any of its
    subdirectories.  The MIME type for files is determined by
    calling the .guess_type() method.

    The GET and HEAD requests are identical except that the HEAD
    request omits the actual contents of the file.

    zSimpleHTTP/c          
   C   s;   |  j  É  } | r7 z |  j | |  j É Wd | j É  Xd S)zServe a GET request.N)⁄	send_head⁄copyfilerF   r#   )r   ⁄fr   r   r   ⁄do_GETÉ  s
    zSimpleHTTPRequestHandler.do_GETc             C   s    |  j  É  } | r | j É  d S)zServe a HEAD request.N)râ   r#   )r   rã   r   r   r   ⁄do_HEADå  s    z SimpleHTTPRequestHandler.do_HEADc       	      C   sÒ  |  j  |  j É } d } t j j | É r
t j j |  j É } | j j d É sæ |  j t	 j
 É | d | d | d d | d | d f } t j j | É } |  j d | É |  j É  d SxI d D]4 } t j j | | É } t j j | É r≈ | } Pq≈ W|  j | É S|  j | É } y t | d É } Wn) t k
 rW|  j t	 j d É d SYn Xy} |  j t	 j É |  j d | É t j | j É  É } |  j d t | d É É |  j d |  j | j É É |  j É  | SWn | j É  Ç  Yn Xd S)a{  Common code for GET and HEAD commands.

        This sends the response code and MIME headers.

        Return value is either a file object (which has to be copied
        to the outputfile by the caller unless the command was HEAD,
        and must be closed by the caller under all circumstances), or
        None, in which case the caller has nothing further to do.

        Nr   r   r   r   r   È   ZLocation˙
index.html˙	index.htm⁄rbzFile not foundzContent-typezContent-LengthÈ   zLast-Modified)rè   rê   )⁄translate_pathr3   ⁄os⁄isdir⁄urllib⁄parseZurlsplit⁄endswithrT   r   ZMOVED_PERMANENTLYZ
urlunsplitrU   rA   rd   ⁄exists⁄list_directory⁄
guess_type⁄open⁄OSErrorr.   ⁄	NOT_FOUND⁄OK⁄fstat⁄filenor(   r\   ⁄st_mtimer#   )	r   r3   rã   ⁄partsZ	new_partsZnew_url⁄indexZctypeZfsr   r   r   râ   í  sF    
	

z"SimpleHTTPRequestHandler.send_headc             C   s`  y t  j | É } Wn) t k
 r> |  j t j d É d SYn X| j d d d Ñ  É g  } y t j j	 |  j
 d d É} Wn$ t k
 r† t j j	 | É } Yn Xt j | É } t j É  } d | } | j d	 É | j d
 É | j d | É | j d | É | j d | É | j d É x° | D]ô } t  j
 j | | É } | }	 }
 t  j
 j | É rr| d }	 | d }
 t  j
 j | É ré| d }	 | j d t j j |
 d d Ét j |	 É f É q'W| j d É d j | É j | d É } t j É  } | j | É | j d É |  j t j É |  j d d | É |  j d t t | É É É |  j É  | S)z˚Helper to produce a directory listing (absent index.html).

        Return value is either a file object, or None (indicating an
        error).  In either case, the headers are sent, making the
        interface the same as for send_head().

        zNo permission to list directoryN⁄keyc             S   s
   |  j  É  S)N)r:   )⁄ar   r   r   ⁄<lambda>“  s    z9SimpleHTTPRequestHandler.list_directory.<locals>.<lambda>⁄errors⁄surrogatepasszDirectory listing for %szZ<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">z<html>
<head>z@<meta http-equiv="Content-Type" content="text/html; charset=%s">z<title>%s</title>
</head>z<body>
<h1>%s</h1>z	<hr>
<ul>r   ˙@z<li><a href="%s">%s</a></li>z</ul>
<hr>
</body>
</html>
⁄
⁄surrogateescaper   zContent-typeztext/html; charset=%szContent-Length) rî   ⁄listdirrù   r.   r   rû   ⁄sortrñ   ró   ⁄unquoter3   ⁄UnicodeDecodeErrorr   ⁄escaperk   ⁄getfilesystemencodingr_   rd   rï   ⁄islinkZquoterW   ⁄io⁄BytesIOrY   ⁄seekrT   rü   rU   r(   r-   rA   )r   r3   ⁄list⁄rZdisplaypath⁄enc⁄title⁄name⁄fullnameZdisplaynameZlinknameZencodedrã   r   r   r   rö   √  s\    	
	



	
z'SimpleHTTPRequestHandler.list_directoryc             C   s$  | j  d d É d } | j  d d É d } | j É  j d É } y t j j | d d É} Wn$ t k
 rÉ t j j | É } Yn Xt j | É } | j  d É } t	 d | É } t
 j É  } xP | D]H } t
 j j | É sƒ | t
 j t
 j f k r˜ qƒ t
 j j | | É } qƒ W| r | d 7} | S)	zÒTranslate a /-separated PATH to the local filename syntax.

        Components that mean special things to the local file system
        (e.g. drive or directory names) are ignored.  (XXX They should
        probably be diagnosed.)

        ˙?r   r   ˙#r   r®   r©   N)r,   r*   rò   rñ   ró   rØ   r∞   ⁄	posixpath⁄normpath⁄filterrî   ⁄getcwdr3   ⁄dirname⁄curdir⁄pardirrd   )r   r3   Ztrailing_slashr=   Zwordr   r   r   rì   ˝  s$    	*
z'SimpleHTTPRequestHandler.translate_pathc             C   s   t  j | | É d S)aÒ  Copy all data between two file objects.

        The SOURCE argument is a file object open for reading
        (or anything with a read() method) and the DESTINATION
        argument is a file object open for writing (or
        anything with a write() method).

        The only reason for overriding this would be to change
        the block size or perhaps to replace newlines by CRLF
        -- note however that this the default server uses this
        to copy binary data as well.

        N)⁄shutilZcopyfileobj)r   ⁄sourceZ
outputfiler   r   r   rä     s    z!SimpleHTTPRequestHandler.copyfilec             C   sd   t  j | É \ } } | |  j k r/ |  j | S| j É  } | |  j k rU |  j | S|  j d Sd S)aª  Guess the type of a file.

        Argument is a PATH (a filename).

        Return value is a string of the form type/subtype,
        usable for a MIME Content-type header.

        The default implementation looks the file's extension
        up in the table self.extensions_map, using application/octet-stream
        as a default; however it would be permissible (if
        slow) to look inside the data to make a better guess.

        r"   N)rø   ⁄splitext⁄extensions_mapr:   )r   r3   ⁄baseZextr   r   r   rõ   +  s    z#SimpleHTTPRequestHandler.guess_typer"   zapplication/octet-streamz.pyz
text/plainz.cz.hN)r   r   r   rÑ   rÖ   rp   rå   rç   râ   rö   rì   rä   rõ   ⁄	mimetypesZinitedZinitZ	types_map⁄copyr…   ⁄updater   r   r   r   r   t  s"   
	1:	
c       	      C   s+  |  j  d É \ }  } } t j j |  É }  |  j d É } g  } xP | d d Ö D]> } | d k ro | j É  qP | rP | d k rP | j | É qP W| rﬁ | j É  } | r‰ | d k r… | j É  d } q‰ | d k r‰ d } n d } | rˇ d j | | f É } d d j | É | f } d j | É } | S)	aÃ  
    Given a URL path, remove extra '/'s and '.' path elements and collapse
    any '..' references and returns a collapsed path.

    Implements something akin to RFC-2396 5.2 step 6 to parse relative paths.
    The utility of this function is limited to is_cgi method and helps
    preventing some security attacks.

    Returns: The reconstituted URL, which will always start with a '/'.

    Raises: IndexError if too many '..' occur within the path.

    rΩ   r   Nr   z..r    r"   Èˇˇˇˇ)⁄	partitionrñ   ró   rØ   r,   ⁄popr_   rd   )	r3   ⁄_⁄query⁄
path_partsZ
head_parts⁄partZ	tail_partZ	splitpath⁄collapsed_pathr   r   r   ⁄_url_collapse_pathP  s.    
		r÷   c              C   sÜ   t  r
 t  Sy d d l }  Wn t k
 r2 d SYn Xy |  j d É d a  Wn5 t k
 rÅ d t d d Ñ  |  j É  DÉ É a  Yn Xt  S)	z$Internal routine to get nobody's uidr   Nr   ⁄nobodyr   c             s   s   |  ] } | d  Vq d S)r   Nr   )rÅ   r~   r   r   r   ˙	<genexpr>é  s    znobody_uid.<locals>.<genexpr>rŒ   )r◊   ⁄pwd⁄ImportError⁄getpwnamrS   ⁄maxZgetpwall)rŸ   r   r   r   ⁄
nobody_uidÇ  s    	(r›   c             C   s   t  j |  t  j É S)zTest for executable file.)rî   ⁄access⁄X_OK)r3   r   r   r   ⁄
executableí  s    r‡   c               @   s   e  Z d  Z d Z e e d É Z d Z d d Ñ  Z d d Ñ  Z	 d d	 Ñ  Z
 d
 d g Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)r   z≠Complete HTTP server with GET, HEAD and POST commands.

    GET and HEAD also support running CGI scripts.

    The POST command is *only* implemented for CGI scripts.

    ⁄forkr   c             C   s0   |  j  É  r |  j É  n |  j t j d É d S)zRServe a POST request.

        This is only implemented for CGI scripts.

        zCan only POST to CGI scriptsN)⁄is_cgi⁄run_cgir.   r   rD   )r   r   r   r   ⁄do_POST®  s
    zCGIHTTPRequestHandler.do_POSTc             C   s'   |  j  É  r |  j É  St j |  É Sd S)z-Version of send_head that support CGI scriptsN)r‚   r„   r   râ   )r   r   r   r   râ   ∂  s    
zCGIHTTPRequestHandler.send_headc             C   sl   t  |  j É } | j d d É } | d | Ö | | d d Ö } } | |  j k rh | | f |  _ d Sd S)a3  Test whether self.path corresponds to a CGI script.

        Returns True and updates the cgi_info attribute to the tuple
        (dir, rest) if self.path requires running a CGI script.
        Returns False otherwise.

        If any exception is raised, the caller should assume that
        self.path was rejected as invalid and act accordingly.

        The default implementation tests whether the normalized url
        path begins with one of the strings in self.cgi_directories
        (and the next character is a '/' or the end of the string).

        r   r   NTF)r÷   r3   ⁄find⁄cgi_directories⁄cgi_info)r   r’   Zdir_sep⁄head⁄tailr   r   r   r‚   Ω  s    %zCGIHTTPRequestHandler.is_cgiz/cgi-binz/htbinc             C   s
   t  | É S)z1Test whether argument path is an executable file.)r‡   )r   r3   r   r   r   ⁄is_executable◊  s    z#CGIHTTPRequestHandler.is_executablec             C   s(   t  j j | É \ } } | j É  d k S)z.Test whether argument path is a Python script.˙.py˙.pyw)rÎ   rÏ   )rî   r3   r»   r:   )r   r3   rË   rÈ   r   r   r   ⁄	is_python€  s    zCGIHTTPRequestHandler.is_pythonc       )      C   s∫  |  j  \ } } | d | } | j d t | É d É } xÇ | d k rΩ | d | Ö } | | d d Ö } |  j | É } t j j | É rπ | | } } | j d t | É d É } q< Pq< W| j d É \ } } }	 | j d É } | d k r| d | Ö | | d Ö }
 } n | d }
 } | d |
 } |  j | É } t j j | É sl|  j	 t
 j d | É d St j j | É sô|  j	 t
 j d | É d S|  j | É } |  j s∏| r‚|  j | É s‚|  j	 t
 j d	 | É d St j t j É } |  j É  | d
 <|  j j | d <d | d <|  j | d <t |  j j É | d <|  j | d <t j j | É } | | d <|  j | É | d <| | d <|	 ró|	 | d <|  j d | d <|  j j  d É } | rñ| j! É  } t | É d k rñd d l" } d d l# } | d | d <| d j$ É  d k rñy/ | d j% d É } | j& | É j' d É } Wn | j( t) f k
 rfYn0 X| j! d É } t | É d k rñ| d | d <|  j j  d É d k rƒ|  j j* É  | d <n |  j d | d <|  j j  d É } | r˜| | d  <|  j j  d! É } | r| | d" <g  } xc |  j j+ d# É D]O } | d d Ö d$ k rd| j, | j- É  É q2| | d% d Ö j! d& É } q2Wd& j. | É | d' <|  j j  d( É } | r∫| | d) <t/ d |  j j0 d* g  É É } d+ j. | É } | r˜| | d, <x d@ D] } | j1 | d É q˛W|  j2 t
 j3 d. É |  j4 É  |	 j5 d/ d0 É } |  j r±|
 g } d1 | k rr| j, | É t6 É  } |  j7 j8 É  t j9 É  } | d k rt j: | d É \ } } x9 t; j; |  j< g g  g  d É d rÛ|  j< j= d É sªPqªW| r
|  j> d2 | É d Syo y t j? | É Wn t@ k
 r6Yn Xt jA |  j< jB É  d É t jA |  j7 jB É  d É t jC | | | É Wq∂|  j jD |  jE |  j É t jF d3 É Yq∂Xnd d lG }  | g }! |  j | É r!tH jI }" |" j$ É  jJ d4 É r|" d dA Ö |" dB d Ö }" |" d7 g |! }! d1 |	 k r:|! j, |	 É |  jK d8 |  jL |! É É y tM | É }# Wn tN tO f k
 rÉd }# Yn X|  jP |! d9 |  jQ d: |  jQ d; |  jQ d< | É}$ |  j j$ É  d= k rÍ|# d k rÍ|  j< j= |# É }% n d }% x? t; j; |  j< jR g g  g  d É d r1|  j< jR jS d É sÛPqÛW|$ jT |% É \ }& }' |  j7 jU |& É |' rm|  j> d> |' É |$ jV jW É  |$ jX jW É  |$ jY }( |( r©|  j> d2 |( É n |  jK d? É d S)CzExecute a CGI script.r   r   r   NrΩ   r"   zNo such CGI script (%r)z#CGI script is not a plain file (%r)z!CGI script is not executable (%r)ZSERVER_SOFTWAREZSERVER_NAMEzCGI/1.1ZGATEWAY_INTERFACEZSERVER_PROTOCOLZSERVER_PORTZREQUEST_METHODZ	PATH_INFOZPATH_TRANSLATEDZSCRIPT_NAME⁄QUERY_STRINGZREMOTE_ADDR⁄authorizationr   Z	AUTH_TYPEZbasic⁄ascii˙:ZREMOTE_USERzcontent-typeZCONTENT_TYPEzcontent-length⁄CONTENT_LENGTH⁄referer⁄HTTP_REFERER⁄acceptz	
 È   ˙,ZHTTP_ACCEPTz
user-agent⁄HTTP_USER_AGENTZcookiez, ⁄HTTP_COOKIE⁄REMOTE_HOSTzScript output follows˙+ro   ˙=zCGI script exit status %#xÈ   zw.exer   ré   z-uzcommand: %s⁄stdin⁄stdoutrl   ⁄envZpostz%szCGI script exited OK)rÓ   r˙   rÚ   r¯   r˘   rÙ   È˚ˇˇˇÈ¸ˇˇˇ)ZrÁ   rÂ   r-   rì   rî   r3   rï   rœ   rô   r.   r   rû   ⁄isfileZ	FORBIDDENrÌ   ⁄	have_forkrÍ   rÃ   ⁄deepcopy⁄environr[   Zserverr   r2   r(   r   r$   rñ   ró   rØ   r   r8   r9   r,   ⁄base64⁄binasciir:   rW   Zdecodebytes⁄decode⁄Error⁄UnicodeErrorZget_content_typeZgetallmatchingheadersr_   ⁄striprd   r¡   Zget_all⁄
setdefaultrT   rü   rb   r
   r›   rF   rG   r·   ⁄waitpid⁄selectr6   ⁄readrH   ⁄setuidrù   ⁄dup2r°   ⁄execveZhandle_errorZrequest⁄_exit⁄
subprocessrk   r‡   rò   rg   Zlist2cmdliner0   ⁄	TypeErrorr/   ⁄Popen⁄PIPEZ_sockZrecvZcommunicaterY   rl   r#   rˇ   ⁄
returncode))r   ⁄dir⁄restr3   ⁄iZnextdirZnextrestZ	scriptdirr—   r“   ZscriptZ
scriptnameZ
scriptfileZispyr   ZuqrestrÔ   r  r  ZlengthrÛ   rı   ⁄lineZua⁄coZ
cookie_str⁄kZdecoded_queryrj   r◊   ⁄pid⁄stsr  ZcmdlineZinterp⁄nbytes⁄p⁄datarˇ   rl   Zstatusr   r   r   r„   ‡  s4   $





!



			%						!(	zCGIHTTPRequestHandler.run_cgiN)r   r   r   rÑ   rC   rî   r  Zrbufsizer‰   râ   r‚   rÊ   rÍ   rÌ   r„   r   r   r   r   r   ó  s   zHTTP/1.0i@  r"   c             C   sô   | | f } | |  _  | | |  É } | j j É  } t d | d d | d d É y | j É  Wn3 t k
 rî t d É | j É  t j d É Yn Xd S)zmTest the HTTP request handler class.

    This runs an HTTP server on port 8000 (or the port argument).

    zServing HTTP onr   r   r   z...z&
Keyboard interrupt received, exiting.N)	r2   r   r   ⁄printZserve_forever⁄KeyboardInterruptZserver_closerk   ⁄exit)⁄HandlerClassZServerClassZprotocolr   ⁄bindZserver_addressZhttpdZsar   r   r   ⁄test†  s    	

r*  ⁄__main__z--cgi⁄action⁄
store_true⁄helpzRun as CGI Serverz--bindz-b⁄default⁄metavarZADDRESSz8Specify alternate bind address [default: all interfaces]r   Zstore⁄type⁄nargsrΩ   z&Specify alternate port [default: 8000]r(  r)  ).rÑ   rÖ   ⁄__all__r   Zhttp.clientr4   r¥   rÀ   rî   rø   r  r∆   r   r   rk   rr   Zurllib.parserñ   rÃ   ⁄argparser   rÜ   rá   r   r   r   ZStreamRequestHandlerr   r   r÷   r◊   r›   r‡   r   r*  r   ⁄ArgumentParser⁄parser⁄add_argumentr0   ⁄
parse_argsrj   ZcgiZhandler_classr   r)  r   r   r   r   ⁄<module>    sb   3ˇ Â‹0ˇ 
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """AutoComplete.py - An IDLE extension for automatically completing names.

This extension can complete either attribute names or file names. It can pop
a window with all available names, for the user to select from.
"""
import os
import sys
import string

from idlelib.configHandler import idleConf

# This string includes all chars that may be in an identifier
ID_CHARS = string.ascii_letters + string.digits + "_"

# These constants represent the two different types of completions
COMPLETE_ATTRIBUTES, COMPLETE_FILES = range(1, 2+1)

from idlelib import AutoCompleteWindow
from idlelib.HyperParser import HyperParser

import __main__

SEPS = os.sep
if os.altsep:  # e.g. '/' on Windows...
    SEPS += os.altsep

class AutoComplete:

    menudefs = [
        ('edit', [
            ("Show Completions", "<<force-open-completions>>"),
        ])
    ]

    popupwait = idleConf.GetOption("extensions", "AutoComplete",
                                   "popupwait", type="int", default=0)

    def __init__(self, editwin=None):
        self.editwin = editwin
        if editwin is None:  # subprocess and test
            return
        self.text = editwin.text
        self.autocompletewindow = None

        # id of delayed call, and the index of the text insert when the delayed
        # call was issued. If _delayed_completion_id is None, there is no
        # delayed call.
        self._delayed_completion_id = None
        self._delayed_completion_index = None

    def _make_autocomplete_window(self):
        return AutoCompleteWindow.AutoCompleteWindow(self.text)

    def _remove_autocomplete_window(self, event=None):
        if self.autocompletewindow:
            self.autocompletewindow.hide_window()
            self.autocompletewindow = None

    def force_open_completions_event(self, event):
        """Happens when the user really wants to open a completion list, even
        if a function call is needed.
        """
        self.open_completions(True, False, True)

    def try_open_completions_event(self, event):
        """Happens when it would be nice to open a completion list, but not
        really necessary, for example after a dot, so function
        calls won't be made.
        """
        lastchar = self.text.get("insert-1c")
        if lastchar == ".":
            self._open_completions_later(False, False, False,
                                         COMPLETE_ATTRIBUTES)
        elif lastchar in SEPS:
            self._open_completions_later(False, False, False,
                                         COMPLETE_FILES)

    def autocomplete_event(self, event):
        """Happens when the user wants to complete his word, and if necessary,
        open a completion list after that (if there is more than one
        completion)
        """
        if hasattr(event, "mc_state") and event.mc_state:
            # A modifier was pressed along with the tab, continue as usual.
            return
        if self.autocompletewindow and self.autocompletewindow.is_active():
            self.autocompletewindow.complete()
            return "break"
        else:
            opened = self.open_completions(False, True, True)
            if opened:
                return "break"

    def _open_completions_later(self, *args):
        self._delayed_completion_index = self.text.index("insert")
        if self._delayed_completion_id is not None:
            self.text.after_cancel(self._delayed_completion_id)
        self._delayed_completion_id = \
            self.text.after(self.popupwait, self._delayed_open_completions,
                            *args)

    def _delayed_open_completions(self, *args):
        self._delayed_completion_id = None
        if self.text.index("insert") != self._delayed_completion_index:
            return
        self.open_completions(*args)

    def open_completions(self, evalfuncs, complete, userWantsWin, mode=None):
        """Find the completions and create the AutoCompleteWindow.
        Return True if successful (no syntax error or so found).
        if complete is True, then if there's nothing to complete and no
        start of completion, won't open completions and return False.
        If mode is given, will open a completion list only in this mode.
        """
        # Cancel another delayed call, if it exists.
        if self._delayed_completion_id is not None:
            self.text.after_cancel(self._delayed_completion_id)
            self._delayed_completion_id = None

        hp = HyperParser(self.editwin, "insert")
        curline = self.text.get("insert linestart", "insert")
        i = j = len(curline)
        if hp.is_in_string() and (not mode or mode==COMPLETE_FILES):
            # Find the beginning of the string
            # fetch_completions will look at the file system to determine whether the
            # string value constitutes an actual file name
            # XXX could consider raw strings here and unescape the string value if it's
            # not raw.
            self._remove_autocomplete_window()
            mode = COMPLETE_FILES
            # Find last separator or string start
            while i and curline[i-1] not in "'\"" + SEPS:
                i -= 1
            comp_start = curline[i:j]
            j = i
            # Find string start
            while i and curline[i-1] not in "'\"":
                i -= 1
            comp_what = curline[i:j]
        elif hp.is_in_code() and (not mode or mode==COMPLETE_ATTRIBUTES):
            self._remove_autocomplete_window()
            mode = COMPLETE_ATTRIBUTES
            while i and (curline[i-1] in ID_CHARS or ord(curline[i-1]) > 127):
                i -= 1
            comp_start = curline[i:j]
            if i and curline[i-1] == '.':
                hp.set_index("insert-%dc" % (len(curline)-(i-1)))
                comp_what = hp.get_expression()
                if not comp_what or \
                   (not evalfuncs and comp_what.find('(') != -1):
                    return
            else:
                comp_what = ""
        else:
            return

        if complete and not comp_what and not comp_start:
            return
        comp_lists = self.fetch_completions(comp_what, mode)
        if not comp_lists[0]:
            return
        self.autocompletewindow = self._make_autocomplete_window()
        return not self.autocompletewindow.show_window(
                comp_lists, "insert-%dc" % len(comp_start),
                complete, mode, userWantsWin)

    def fetch_completions(self, what, mode):
        """Return a pair of lists of completions for something. The first list
        is a sublist of the second. Both are sorted.

        If there is a Python subprocess, get the comp. list there.  Otherwise,
        either fetch_completions() is running in the subprocess itself or it
        was called in an IDLE EditorWindow before any script had been run.

        The subprocess environment is that of the most recently run script.  If
        two unrelated modules are being edited some calltips in the current
        module may be inoperative if the module was not the last to run.
        """
        try:
            rpcclt = self.editwin.flist.pyshell.interp.rpcclt
        except:
            rpcclt = None
        if rpcclt:
            return rpcclt.remotecall("exec", "get_the_completion_list",
                                     (what, mode), {})
        else:
            if mode == COMPLETE_ATTRIBUTES:
                if what == "":
                    namespace = __main__.__dict__.copy()
                    namespace.update(__main__.__builtins__.__dict__)
                    bigl = eval("dir()", namespace)
                    bigl.sort()
                    if "__all__" in bigl:
                        smalll = sorted(eval("__all__", namespace))
                    else:
                        smalll = [s for s in bigl if s[:1] != '_']
                else:
                    try:
                        entity = self.get_entity(what)
                        bigl = dir(entity)
                        bigl.sort()
                        if "__all__" in bigl:
                            smalll = sorted(entity.__all__)
                        else:
                            smalll = [s for s in bigl if s[:1] != '_']
                    except:
                        return [], []

            elif mode == COMPLETE_FILES:
                if what == "":
                    what = "."
                try:
                    expandedpath = os.path.expanduser(what)
                    bigl = os.listdir(expandedpath)
                    bigl.sort()
                    smalll = [s for s in bigl if s[:1] != '.']
                except OSError:
                    return [], []

            if not smalll:
                smalll = bigl
            return smalll, bigl

    def get_entity(self, name):
        """Lookup name in a namespace spanning sys.modules and __main.dict__"""
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        return eval(name, namespace)


if __name__ == '__main__':
    from unittest import main
    main('idlelib.idle_test.test_autocomplete', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """
An auto-completion window for IDLE, used by the AutoComplete extension
"""
from tkinter import *
from idlelib.MultiCall import MC_SHIFT
from idlelib.AutoComplete import COMPLETE_FILES, COMPLETE_ATTRIBUTES

HIDE_VIRTUAL_EVENT_NAME = "<<autocompletewindow-hide>>"
HIDE_SEQUENCES = ("<FocusOut>", "<ButtonPress>")
KEYPRESS_VIRTUAL_EVENT_NAME = "<<autocompletewindow-keypress>>"
# We need to bind event beyond <Key> so that the function will be called
# before the default specific IDLE function
KEYPRESS_SEQUENCES = ("<Key>", "<Key-BackSpace>", "<Key-Return>", "<Key-Tab>",
                      "<Key-Up>", "<Key-Down>", "<Key-Home>", "<Key-End>",
                      "<Key-Prior>", "<Key-Next>")
KEYRELEASE_VIRTUAL_EVENT_NAME = "<<autocompletewindow-keyrelease>>"
KEYRELEASE_SEQUENCE = "<KeyRelease>"
LISTUPDATE_SEQUENCE = "<B1-ButtonRelease>"
WINCONFIG_SEQUENCE = "<Configure>"
DOUBLECLICK_SEQUENCE = "<B1-Double-ButtonRelease>"

class AutoCompleteWindow:

    def __init__(self, widget):
        # The widget (Text) on which we place the AutoCompleteWindow
        self.widget = widget
        # The widgets we create
        self.autocompletewindow = self.listbox = self.scrollbar = None
        # The default foreground and background of a selection. Saved because
        # they are changed to the regular colors of list items when the
        # completion start is not a prefix of the selected completion
        self.origselforeground = self.origselbackground = None
        # The list of completions
        self.completions = None
        # A list with more completions, or None
        self.morecompletions = None
        # The completion mode. Either AutoComplete.COMPLETE_ATTRIBUTES or
        # AutoComplete.COMPLETE_FILES
        self.mode = None
        # The current completion start, on the text box (a string)
        self.start = None
        # The index of the start of the completion
        self.startindex = None
        # The last typed start, used so that when the selection changes,
        # the new start will be as close as possible to the last typed one.
        self.lasttypedstart = None
        # Do we have an indication that the user wants the completion window
        # (for example, he clicked the list)
        self.userwantswindow = None
        # event ids
        self.hideid = self.keypressid = self.listupdateid = self.winconfigid \
        = self.keyreleaseid = self.doubleclickid                         = None
        # Flag set if last keypress was a tab
        self.lastkey_was_tab = False

    def _change_start(self, newstart):
        min_len = min(len(self.start), len(newstart))
        i = 0
        while i < min_len and self.start[i] == newstart[i]:
            i += 1
        if i < len(self.start):
            self.widget.delete("%s+%dc" % (self.startindex, i),
                               "%s+%dc" % (self.startindex, len(self.start)))
        if i < len(newstart):
            self.widget.insert("%s+%dc" % (self.startindex, i),
                               newstart[i:])
        self.start = newstart

    def _binary_search(self, s):
        """Find the first index in self.completions where completions[i] is
        greater or equal to s, or the last index if there is no such
        one."""
        i = 0; j = len(self.completions)
        while j > i:
            m = (i + j) // 2
            if self.completions[m] >= s:
                j = m
            else:
                i = m + 1
        return min(i, len(self.completions)-1)

    def _complete_string(self, s):
        """Assuming that s is the prefix of a string in self.completions,
        return the longest string which is a prefix of all the strings which
        s is a prefix of them. If s is not a prefix of a string, return s."""
        first = self._binary_search(s)
        if self.completions[first][:len(s)] != s:
            # There is not even one completion which s is a prefix of.
            return s
        # Find the end of the range of completions where s is a prefix of.
        i = first + 1
        j = len(self.completions)
        while j > i:
            m = (i + j) // 2
            if self.completions[m][:len(s)] != s:
                j = m
            else:
                i = m + 1
        last = i-1

        if first == last: # only one possible completion
            return self.completions[first]

        # We should return the maximum prefix of first and last
        first_comp = self.completions[first]
        last_comp = self.completions[last]
        min_len = min(len(first_comp), len(last_comp))
        i = len(s)
        while i < min_len and first_comp[i] == last_comp[i]:
            i += 1
        return first_comp[:i]

    def _selection_changed(self):
        """Should be called when the selection of the Listbox has changed.
        Updates the Listbox display and calls _change_start."""
        cursel = int(self.listbox.curselection()[0])

        self.listbox.see(cursel)

        lts = self.lasttypedstart
        selstart = self.completions[cursel]
        if self._binary_search(lts) == cursel:
            newstart = lts
        else:
            min_len = min(len(lts), len(selstart))
            i = 0
            while i < min_len and lts[i] == selstart[i]:
                i += 1
            newstart = selstart[:i]
        self._change_start(newstart)

        if self.completions[cursel][:len(self.start)] == self.start:
            # start is a prefix of the selected completion
            self.listbox.configure(selectbackground=self.origselbackground,
                                   selectforeground=self.origselforeground)
        else:
            self.listbox.configure(selectbackground=self.listbox.cget("bg"),
                                   selectforeground=self.listbox.cget("fg"))
            # If there are more completions, show them, and call me again.
            if self.morecompletions:
                self.completions = self.morecompletions
                self.morecompletions = None
                self.listbox.delete(0, END)
                for item in self.completions:
                    self.listbox.insert(END, item)
                self.listbox.select_set(self._binary_search(self.start))
                self._selection_changed()

    def show_window(self, comp_lists, index, complete, mode, userWantsWin):
        """Show the autocomplete list, bind events.
        If complete is True, complete the text, and if there is exactly one
        matching completion, don't open a list."""
        # Handle the start we already have
        self.completions, self.morecompletions = comp_lists
        self.mode = mode
        self.startindex = self.widget.index(index)
        self.start = self.widget.get(self.startindex, "insert")
        if complete:
            completed = self._complete_string(self.start)
            start = self.start
            self._change_start(completed)
            i = self._binary_search(completed)
            if self.completions[i] == completed and \
               (i == len(self.completions)-1 or
                self.completions[i+1][:len(completed)] != completed):
                # There is exactly one matching completion
                return completed == start
        self.userwantswindow = userWantsWin
        self.lasttypedstart = self.start

        # Put widgets in place
        self.autocompletewindow = acw = Toplevel(self.widget)
        # Put it in a position so that it is not seen.
        acw.wm_geometry("+10000+10000")
        # Make it float
        acw.wm_overrideredirect(1)
        try:
            # This command is only needed and available on Tk >= 8.4.0 for OSX
            # Without it, call tips intrude on the typing process by grabbing
            # the focus.
            acw.tk.call("::tk::unsupported::MacWindowStyle", "style", acw._w,
                        "help", "noActivates")
        except TclError:
            pass
        self.scrollbar = scrollbar = Scrollbar(acw, orient=VERTICAL)
        self.listbox = listbox = Listbox(acw, yscrollcommand=scrollbar.set,
                                         exportselection=False, bg="white")
        for item in self.completions:
            listbox.insert(END, item)
        self.origselforeground = listbox.cget("selectforeground")
        self.origselbackground = listbox.cget("selectbackground")
        scrollbar.config(command=listbox.yview)
        scrollbar.pack(side=RIGHT, fill=Y)
        listbox.pack(side=LEFT, fill=BOTH, expand=True)
        acw.lift()  # work around bug in Tk 8.5.18+ (issue #24570)

        # Initialize the listbox selection
        self.listbox.select_set(self._binary_search(self.start))
        self._selection_changed()

        # bind events
        self.hideid = self.widget.bind(HIDE_VIRTUAL_EVENT_NAME,
                                       self.hide_event)
        for seq in HIDE_SEQUENCES:
            self.widget.event_add(HIDE_VIRTUAL_EVENT_NAME, seq)
        self.keypressid = self.widget.bind(KEYPRESS_VIRTUAL_EVENT_NAME,
                                           self.keypress_event)
        for seq in KEYPRESS_SEQUENCES:
            self.widget.event_add(KEYPRESS_VIRTUAL_EVENT_NAME, seq)
        self.keyreleaseid = self.widget.bind(KEYRELEASE_VIRTUAL_EVENT_NAME,
                                             self.keyrelease_event)
        self.widget.event_add(KEYRELEASE_VIRTUAL_EVENT_NAME,KEYRELEASE_SEQUENCE)
        self.listupdateid = listbox.bind(LISTUPDATE_SEQUENCE,
                                         self.listselect_event)
        self.winconfigid = acw.bind(WINCONFIG_SEQUENCE, self.winconfig_event)
        self.doubleclickid = listbox.bind(DOUBLECLICK_SEQUENCE,
                                          self.doubleclick_event)

    def winconfig_event(self, event):
        if not self.is_active():
            return
        # Position the completion list window
        text = self.widget
        text.see(self.startindex)
        x, y, cx, cy = text.bbox(self.startindex)
        acw = self.autocompletewindow
        acw_width, acw_height = acw.winfo_width(), acw.winfo_height()
        text_width, text_height = text.winfo_width(), text.winfo_height()
        new_x = text.winfo_rootx() + min(x, max(0, text_width - acw_width))
        new_y = text.winfo_rooty() + y
        if (text_height - (y + cy) >= acw_height # enough height below
            or y < acw_height): # not enough height above
            # place acw below current line
            new_y += cy
        else:
            # place acw above current line
            new_y -= acw_height
        acw.wm_geometry("+%d+%d" % (new_x, new_y))

    def hide_event(self, event):
        if not self.is_active():
            return
        self.hide_window()

    def listselect_event(self, event):
        if not self.is_active():
            return
        self.userwantswindow = True
        cursel = int(self.listbox.curselection()[0])
        self._change_start(self.completions[cursel])

    def doubleclick_event(self, event):
        # Put the selected completion in the text, and close the list
        cursel = int(self.listbox.curselection()[0])
        self._change_start(self.completions[cursel])
        self.hide_window()

    def keypress_event(self, event):
        if not self.is_active():
            return
        keysym = event.keysym
        if hasattr(event, "mc_state"):
            state = event.mc_state
        else:
            state = 0
        if keysym != "Tab":
            self.lastkey_was_tab = False
        if (len(keysym) == 1 or keysym in ("underscore", "BackSpace")
            or (self.mode == COMPLETE_FILES and keysym in
                ("period", "minus"))) \
           and not (state & ~MC_SHIFT):
            # Normal editing of text
            if len(keysym) == 1:
                self._change_start(self.start + keysym)
            elif keysym == "underscore":
                self._change_start(self.start + '_')
            elif keysym == "period":
                self._change_start(self.start + '.')
            elif keysym == "minus":
                self._change_start(self.start + '-')
            else:
                # keysym == "BackSpace"
                if len(self.start) == 0:
                    self.hide_window()
                    return
                self._change_start(self.start[:-1])
            self.lasttypedstart = self.start
            self.listbox.select_clear(0, int(self.listbox.curselection()[0]))
            self.listbox.select_set(self._binary_search(self.start))
            self._selection_changed()
            return "break"

        elif keysym == "Return":
            self.hide_window()
            return

        elif (self.mode == COMPLETE_ATTRIBUTES and keysym in
              ("period", "space", "parenleft", "parenright", "bracketleft",
               "bracketright")) or \
             (self.mode == COMPLETE_FILES and keysym in
              ("slash", "backslash", "quotedbl", "apostrophe")) \
             and not (state & ~MC_SHIFT):
            # If start is a prefix of the selection, but is not '' when
            # completing file names, put the whole
            # selected completion. Anyway, close the list.
            cursel = int(self.listbox.curselection()[0])
            if self.completions[cursel][:len(self.start)] == self.start \
               and (self.mode == COMPLETE_ATTRIBUTES or self.start):
                self._change_start(self.completions[cursel])
            self.hide_window()
            return

        elif keysym in ("Home", "End", "Prior", "Next", "Up", "Down") and \
             not state:
            # Move the selection in the listbox
            self.userwantswindow = True
            cursel = int(self.listbox.curselection()[0])
            if keysym == "Home":
                newsel = 0
            elif keysym == "End":
                newsel = len(self.completions)-1
            elif keysym in ("Prior", "Next"):
                jump = self.listbox.nearest(self.listbox.winfo_height()) - \
                       self.listbox.nearest(0)
                if keysym == "Prior":
                    newsel = max(0, cursel-jump)
                else:
                    assert keysym == "Next"
                    newsel = min(len(self.completions)-1, cursel+jump)
            elif keysym == "Up":
                newsel = max(0, cursel-1)
            else:
                assert keysym == "Down"
                newsel = min(len(self.completions)-1, cursel+1)
            self.listbox.select_clear(cursel)
            self.listbox.select_set(newsel)
            self._selection_changed()
            self._change_start(self.completions[newsel])
            return "break"

        elif (keysym == "Tab" and not state):
            if self.lastkey_was_tab:
                # two tabs in a row; insert current selection and close acw
                cursel = int(self.listbox.curselection()[0])
                self._change_start(self.completions[cursel])
                self.hide_window()
                return "break"
            else:
                # first tab; let AutoComplete handle the completion
                self.userwantswindow = True
                self.lastkey_was_tab = True
                return

        elif any(s in keysym for s in ("Shift", "Control", "Alt",
                                       "Meta", "Command", "Option")):
            # A modifier key, so ignore
            return

        elif event.char and event.char >= ' ':
            # Regular character with a non-length-1 keycode
            self._change_start(self.start + event.char)
            self.lasttypedstart = self.start
            self.listbox.select_clear(0, int(self.listbox.curselection()[0]))
            self.listbox.select_set(self._binary_search(self.start))
            self._selection_changed()
            return "break"

        else:
            # Unknown event, close the window and let it through.
            self.hide_window()
            return

    def keyrelease_event(self, event):
        if not self.is_active():
            return
        if self.widget.index("insert") != \
           self.widget.index("%s+%dc" % (self.startindex, len(self.start))):
            # If we didn't catch an event which moved the insert, close window
            self.hide_window()

    def is_active(self):
        return self.autocompletewindow is not None

    def complete(self):
        self._change_start(self._complete_string(self.start))
        # The selection doesn't change.

    def hide_window(self):
        if not self.is_active():
            return

        # unbind events
        for seq in HIDE_SEQUENCES:
            self.widget.event_delete(HIDE_VIRTUAL_EVENT_NAME, seq)
        self.widget.unbind(HIDE_VIRTUAL_EVENT_NAME, self.hideid)
        self.hideid = None
        for seq in KEYPRESS_SEQUENCES:
            self.widget.event_delete(KEYPRESS_VIRTUAL_EVENT_NAME, seq)
        self.widget.unbind(KEYPRESS_VIRTUAL_EVENT_NAME, self.keypressid)
        self.keypressid = None
        self.widget.event_delete(KEYRELEASE_VIRTUAL_EVENT_NAME,
                                 KEYRELEASE_SEQUENCE)
        self.widget.unbind(KEYRELEASE_VIRTUAL_EVENT_NAME, self.keyreleaseid)
        self.keyreleaseid = None
        self.listbox.unbind(LISTUPDATE_SEQUENCE, self.listupdateid)
        self.listupdateid = None
        self.autocompletewindow.unbind(WINCONFIG_SEQUENCE, self.winconfigid)
        self.winconfigid = None

        # destroy widgets
        self.scrollbar.destroy()
        self.scrollbar = None
        self.listbox.destroy()
        self.listbox = None
        self.autocompletewindow.destroy()
        self.autocompletewindow = None
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     '''Complete the current word before the cursor with words in the editor.

Each menu selection or shortcut key selection replaces the word with a
different word with the same prefix. The search for matches begins
before the target and moves toward the top of the editor. It then starts
after the cursor and moves down. It then returns to the original word and
the cycle starts again.

Changing the current text line or leaving the cursor in a different
place before requesting the next selection causes AutoExpand to reset
its state.

This is an extension file and there is only one instance of AutoExpand.
'''
import string
import re

###$ event <<expand-word>>
###$ win <Alt-slash>
###$ unix <Alt-slash>

class AutoExpand:

    menudefs = [
        ('edit', [
            ('E_xpand Word', '<<expand-word>>'),
         ]),
    ]

    wordchars = string.ascii_letters + string.digits + "_"

    def __init__(self, editwin):
        self.text = editwin.text
        self.state = None

    def expand_word_event(self, event):
        "Replace the current word with the next expansion."
        curinsert = self.text.index("insert")
        curline = self.text.get("insert linestart", "insert lineend")
        if not self.state:
            words = self.getwords()
            index = 0
        else:
            words, index, insert, line = self.state
            if insert != curinsert or line != curline:
                words = self.getwords()
                index = 0
        if not words:
            self.text.bell()
            return "break"
        word = self.getprevword()
        self.text.delete("insert - %d chars" % len(word), "insert")
        newword = words[index]
        index = (index + 1) % len(words)
        if index == 0:
            self.text.bell()            # Warn we cycled around
        self.text.insert("insert", newword)
        curinsert = self.text.index("insert")
        curline = self.text.get("insert linestart", "insert lineend")
        self.state = words, index, curinsert, curline
        return "break"

    def getwords(self):
        "Return a list of words that match the prefix before the cursor."
        word = self.getprevword()
        if not word:
            return []
        before = self.text.get("1.0", "insert wordstart")
        wbefore = re.findall(r"\b" + word + r"\w+\b", before)
        del before
        after = self.text.get("insert wordend", "end")
        wafter = re.findall(r"\b" + word + r"\w+\b", after)
        del after
        if not wbefore and not wafter:
            return []
        words = []
        dict = {}
        # search backwards through words before
        wbefore.reverse()
        for w in wbefore:
            if dict.get(w):
                continue
            words.append(w)
            dict[w] = w
        # search onwards through words after
        for w in wafter:
            if dict.get(w):
                continue
            words.append(w)
            dict[w] = w
        words.append(word)
        return words

    def getprevword(self):
        "Return the word prefix before the cursor."
        line = self.text.get("insert linestart", "insert")
        i = len(line)
        while i > 0 and line[i-1] in self.wordchars:
            i = i-1
        return line[i:]

if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_autoexpand', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Define the menu contents, hotkeys, and event bindings.

There is additional configuration information in the EditorWindow class (and
subclasses): the menus are created there based on the menu_specs (class)
variable, and menus not created are silently skipped in the code here.  This
makes it possible, for example, to define a Debug menu which is only present in
the PythonShell window, and a Format menu which is only present in the Editor
windows.

"""
from importlib.util import find_spec

from idlelib.configHandler import idleConf

#   Warning: menudefs is altered in macosxSupport.overrideRootMenu()
#   after it is determined that an OS X Aqua Tk is in use,
#   which cannot be done until after Tk() is first called.
#   Do not alter the 'file', 'options', or 'help' cascades here
#   without altering overrideRootMenu() as well.
#       TODO: Make this more robust

menudefs = [
 # underscore prefixes character to underscore
 ('file', [
   ('_New File', '<<open-new-window>>'),
   ('_Open...', '<<open-window-from-file>>'),
   ('Open _Module...', '<<open-module>>'),
   ('Class _Browser', '<<open-class-browser>>'),
   ('_Path Browser', '<<open-path-browser>>'),
   None,
   ('_Save', '<<save-window>>'),
   ('Save _As...', '<<save-window-as-file>>'),
   ('Save Cop_y As...', '<<save-copy-of-window-as-file>>'),
   None,
   ('Prin_t Window', '<<print-window>>'),
   None,
   ('_Close', '<<close-window>>'),
   ('E_xit', '<<close-all-windows>>'),
  ]),
 ('edit', [
   ('_Undo', '<<undo>>'),
   ('_Redo', '<<redo>>'),
   None,
   ('Cu_t', '<<cut>>'),
   ('_Copy', '<<copy>>'),
   ('_Paste', '<<paste>>'),
   ('Select _All', '<<select-all>>'),
   None,
   ('_Find...', '<<find>>'),
   ('Find A_gain', '<<find-again>>'),
   ('Find _Selection', '<<find-selection>>'),
   ('Find in Files...', '<<find-in-files>>'),
   ('R_eplace...', '<<replace>>'),
   ('Go to _Line', '<<goto-line>>'),
  ]),
('format', [
   ('_Indent Region', '<<indent-region>>'),
   ('_Dedent Region', '<<dedent-region>>'),
   ('Comment _Out Region', '<<comment-region>>'),
   ('U_ncomment Region', '<<uncomment-region>>'),
   ('Tabify Region', '<<tabify-region>>'),
   ('Untabify Region', '<<untabify-region>>'),
   ('Toggle Tabs', '<<toggle-tabs>>'),
   ('New Indent Width', '<<change-indentwidth>>'),
   ]),
 ('run', [
   ('Python Shell', '<<open-python-shell>>'),
   ]),
 ('shell', [
   ('_View Last Restart', '<<view-restart>>'),
   ('_Restart Shell', '<<restart-shell>>'),
   None,
   ('_Interrupt Execution', '<<interrupt-execution>>'),
   ]),
 ('debug', [
   ('_Go to File/Line', '<<goto-file-line>>'),
   ('!_Debugger', '<<toggle-debugger>>'),
   ('_Stack Viewer', '<<open-stack-viewer>>'),
   ('!_Auto-open Stack Viewer', '<<toggle-jit-stack-viewer>>'),
   ]),
 ('options', [
   ('Configure _IDLE', '<<open-config-dialog>>'),
   None,
   ]),
 ('help', [
   ('_About IDLE', '<<about-idle>>'),
   None,
   ('_IDLE Help', '<<help>>'),
   ('Python _Docs', '<<python-docs>>'),
   ]),
]

if find_spec('turtledemo'):
    menudefs[-1][1].append(('Turtle Demo', '<<open-turtle-demo>>'))

default_keydefs = idleConf.GetCurrentKeySet()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Guido van Rossum, as well as being the creator of the Python language, is the
original creator of IDLE.  Other contributors prior to Version 0.8 include
Mark Hammond, Jeremy Hylton, Tim Peters, and Moshe Zadka.

IDLE's recent development was carried out in the SF IDLEfork project. The
objective was to develop a version of IDLE which had an execution environment
which could be initialized prior to each run of user code.

The IDLEfork project was initiated by David Scherer, with some help from Peter
Schneider-Kamp and Nicholas Riley.  David wrote the first version of the RPC
code and designed a fast turn-around environment for VPython.  Guido developed
the RPC code and Remote Debugger currently integrated in IDLE.  Bruce Sherwood
contributed considerable time testing and suggesting improvements.

Besides David and Guido, the main developers who were active on IDLEfork
are Stephen M. Gava, who implemented the configuration GUI, the new
configuration system, and the About dialog, and Kurt B. Kaiser, who completed
the integration of the RPC and remote debugger, implemented the threaded
subprocess, and made a number of usability enhancements.

Other contributors include Raymond Hettinger, Tony Lownds (Mac integration),
Neal Norwitz (code check and clean-up), Ronald Oussoren (Mac integration),
Noam Raphael (Code Context, Call Tips, many other patches), and Chui Tey (RPC
integration, debugger integration and persistent breakpoints).

Scott David Daniels, Tal Einat, Hernan Foffani, Christos Georgiou,
Jim Jewett, Martin v. L√∂wis, Jason Orendorff, Guilherme Polo, Josh Robb,
Nigel Rowe, Bruce Sherwood, Jeff Shute, and Weeble have submitted useful
patches.  Thanks, guys!

For additional details refer to NEWS.txt and Changelog.

Please contact the IDLE maintainer (kbk@shore.net) to have yourself included
here if you are one of those we missed!



                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      class Delegator:

    def __init__(self, delegate=None):
        self.delegate = delegate
        self.__cache = set()
        # Cache is used to only remove added attributes
        # when changing the delegate.

    def __getattr__(self, name):
        attr = getattr(self.delegate, name) # May raise AttributeError
        setattr(self, name, attr)
        self.__cache.add(name)
        return attr

    def resetcache(self):
        "Removes added attributes while leaving original attributes."
        # Function is really about resetting delagator dict
        # to original state.  Cache is just a means
        for key in self.__cache:
            try:
                delattr(self, key)
            except AttributeError:
                pass
        self.__cache.clear()

    def setdelegate(self, delegate):
        "Reset attributes and change delegate."
        self.resetcache()
        self.delegate = delegate

if __name__ == '__main__':
    from unittest import main
    main('idlelib.idle_test.test_delegator', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """A CallTip window class for Tkinter/IDLE.

After ToolTip.py, which uses ideas gleaned from PySol
Used by the CallTips IDLE extension.
"""
from tkinter import Toplevel, Label, LEFT, SOLID, TclError

HIDE_VIRTUAL_EVENT_NAME = "<<calltipwindow-hide>>"
HIDE_SEQUENCES = ("<Key-Escape>", "<FocusOut>")
CHECKHIDE_VIRTUAL_EVENT_NAME = "<<calltipwindow-checkhide>>"
CHECKHIDE_SEQUENCES = ("<KeyRelease>", "<ButtonRelease>")
CHECKHIDE_TIME = 100 # milliseconds

MARK_RIGHT = "calltipwindowregion_right"

class CallTip:

    def __init__(self, widget):
        self.widget = widget
        self.tipwindow = self.label = None
        self.parenline = self.parencol = None
        self.lastline = None
        self.hideid = self.checkhideid = None
        self.checkhide_after_id = None

    def position_window(self):
        """Check if needs to reposition the window, and if so - do it."""
        curline = int(self.widget.index("insert").split('.')[0])
        if curline == self.lastline:
            return
        self.lastline = curline
        self.widget.see("insert")
        if curline == self.parenline:
            box = self.widget.bbox("%d.%d" % (self.parenline,
                                              self.parencol))
        else:
            box = self.widget.bbox("%d.0" % curline)
        if not box:
            box = list(self.widget.bbox("insert"))
            # align to left of window
            box[0] = 0
            box[2] = 0
        x = box[0] + self.widget.winfo_rootx() + 2
        y = box[1] + box[3] + self.widget.winfo_rooty()
        self.tipwindow.wm_geometry("+%d+%d" % (x, y))

    def showtip(self, text, parenleft, parenright):
        """Show the calltip, bind events which will close it and reposition it.
        """
        # Only called in CallTips, where lines are truncated
        self.text = text
        if self.tipwindow or not self.text:
            return

        self.widget.mark_set(MARK_RIGHT, parenright)
        self.parenline, self.parencol = map(
            int, self.widget.index(parenleft).split("."))

        self.tipwindow = tw = Toplevel(self.widget)
        self.position_window()
        # remove border on calltip window
        tw.wm_overrideredirect(1)
        try:
            # This command is only needed and available on Tk >= 8.4.0 for OSX
            # Without it, call tips intrude on the typing process by grabbing
            # the focus.
            tw.tk.call("::tk::unsupported::MacWindowStyle", "style", tw._w,
                       "help", "noActivates")
        except TclError:
            pass
        self.label = Label(tw, text=self.text, justify=LEFT,
                           background="#ffffe0", relief=SOLID, borderwidth=1,
                           font = self.widget['font'])
        self.label.pack()
        tw.lift()  # work around bug in Tk 8.5.18+ (issue #24570)

        self.checkhideid = self.widget.bind(CHECKHIDE_VIRTUAL_EVENT_NAME,
                                            self.checkhide_event)
        for seq in CHECKHIDE_SEQUENCES:
            self.widget.event_add(CHECKHIDE_VIRTUAL_EVENT_NAME, seq)
        self.widget.after(CHECKHIDE_TIME, self.checkhide_event)
        self.hideid = self.widget.bind(HIDE_VIRTUAL_EVENT_NAME,
                                       self.hide_event)
        for seq in HIDE_SEQUENCES:
            self.widget.event_add(HIDE_VIRTUAL_EVENT_NAME, seq)

    def checkhide_event(self, event=None):
        if not self.tipwindow:
            # If the event was triggered by the same event that unbinded
            # this function, the function will be called nevertheless,
            # so do nothing in this case.
            return
        curline, curcol = map(int, self.widget.index("insert").split('.'))
        if curline < self.parenline or \
           (curline == self.parenline and curcol <= self.parencol) or \
           self.widget.compare("insert", ">", MARK_RIGHT):
            self.hidetip()
        else:
            self.position_window()
            if self.checkhide_after_id is not None:
                self.widget.after_cancel(self.checkhide_after_id)
            self.checkhide_after_id = \
                self.widget.after(CHECKHIDE_TIME, self.checkhide_event)

    def hide_event(self, event):
        if not self.tipwindow:
            # See the explanation in checkhide_event.
            return
        self.hidetip()

    def hidetip(self):
        if not self.tipwindow:
            return

        for seq in CHECKHIDE_SEQUENCES:
            self.widget.event_delete(CHECKHIDE_VIRTUAL_EVENT_NAME, seq)
        self.widget.unbind(CHECKHIDE_VIRTUAL_EVENT_NAME, self.checkhideid)
        self.checkhideid = None
        for seq in HIDE_SEQUENCES:
            self.widget.event_delete(HIDE_VIRTUAL_EVENT_NAME, seq)
        self.widget.unbind(HIDE_VIRTUAL_EVENT_NAME, self.hideid)
        self.hideid = None

        self.label.destroy()
        self.label = None
        self.tipwindow.destroy()
        self.tipwindow = None

        self.widget.mark_unset(MARK_RIGHT)
        self.parenline = self.parencol = self.lastline = None

    def is_active(self):
        return bool(self.tipwindow)


def _calltip_window(parent):  # htest #
    from tkinter import Toplevel, Text, LEFT, BOTH

    top = Toplevel(parent)
    top.title("Test calltips")
    top.geometry("200x100+%d+%d" % (parent.winfo_rootx() + 200,
                  parent.winfo_rooty() + 150))
    text = Text(top)
    text.pack(side=LEFT, fill=BOTH, expand=1)
    text.insert("insert", "string.split")
    top.update()
    calltip = CallTip(text)

    def calltip_show(event):
        calltip.showtip("(s=Hello world)", "insert", "end")
    def calltip_hide(event):
        calltip.hidetip()
    text.event_add("<<calltip-show>>", "(")
    text.event_add("<<calltip-hide>>", ")")
    text.bind("<<calltip-show>>", calltip_show)
    text.bind("<<calltip-hide>>", calltip_hide)
    text.focus_set()

if __name__=='__main__':
    from idlelib.idle_test.htest import run
    run(_calltip_window)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """CallTips.py - An IDLE Extension to Jog Your Memory

Call Tips are floating windows which display function, class, and method
parameter and docstring information when you type an opening parenthesis, and
which disappear when you type a closing parenthesis.

"""
import __main__
import inspect
import re
import sys
import textwrap
import types

from idlelib import CallTipWindow
from idlelib.HyperParser import HyperParser

class CallTips:

    menudefs = [
        ('edit', [
            ("Show call tip", "<<force-open-calltip>>"),
        ])
    ]

    def __init__(self, editwin=None):
        if editwin is None:  # subprocess and test
            self.editwin = None
        else:
            self.editwin = editwin
            self.text = editwin.text
            self.active_calltip = None
            self._calltip_window = self._make_tk_calltip_window

    def close(self):
        self._calltip_window = None

    def _make_tk_calltip_window(self):
        # See __init__ for usage
        return CallTipWindow.CallTip(self.text)

    def _remove_calltip_window(self, event=None):
        if self.active_calltip:
            self.active_calltip.hidetip()
            self.active_calltip = None

    def force_open_calltip_event(self, event):
        "The user selected the menu entry or hotkey, open the tip."
        self.open_calltip(True)

    def try_open_calltip_event(self, event):
        """Happens when it would be nice to open a CallTip, but not really
        necessary, for example after an opening bracket, so function calls
        won't be made.
        """
        self.open_calltip(False)

    def refresh_calltip_event(self, event):
        if self.active_calltip and self.active_calltip.is_active():
            self.open_calltip(False)

    def open_calltip(self, evalfuncs):
        self._remove_calltip_window()

        hp = HyperParser(self.editwin, "insert")
        sur_paren = hp.get_surrounding_brackets('(')
        if not sur_paren:
            return
        hp.set_index(sur_paren[0])
        expression  = hp.get_expression()
        if not expression:
            return
        if not evalfuncs and (expression.find('(') != -1):
            return
        argspec = self.fetch_tip(expression)
        if not argspec:
            return
        self.active_calltip = self._calltip_window()
        self.active_calltip.showtip(argspec, sur_paren[0], sur_paren[1])

    def fetch_tip(self, expression):
        """Return the argument list and docstring of a function or class.

        If there is a Python subprocess, get the calltip there.  Otherwise,
        either this fetch_tip() is running in the subprocess or it was
        called in an IDLE running without the subprocess.

        The subprocess environment is that of the most recently run script.  If
        two unrelated modules are being edited some calltips in the current
        module may be inoperative if the module was not the last to run.

        To find methods, fetch_tip must be fed a fully qualified name.

        """
        try:
            rpcclt = self.editwin.flist.pyshell.interp.rpcclt
        except AttributeError:
            rpcclt = None
        if rpcclt:
            return rpcclt.remotecall("exec", "get_the_calltip",
                                     (expression,), {})
        else:
            return get_argspec(get_entity(expression))

def get_entity(expression):
    """Return the object corresponding to expression evaluated
    in a namespace spanning sys.modules and __main.dict__.
    """
    if expression:
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        try:
            return eval(expression, namespace)
        except BaseException:
            # An uncaught exception closes idle, and eval can raise any
            # exception, especially if user classes are involved.
            return None

# The following are used in get_argspec and some in tests
_MAX_COLS = 85
_MAX_LINES = 5  # enough for bytes
_INDENT = ' '*4  # for wrapped signatures
_first_param = re.compile('(?<=\()\w*\,?\s*')
_default_callable_argspec = "See source or doc"


def get_argspec(ob):
    '''Return a string describing the signature of a callable object, or ''.

    For Python-coded functions and methods, the first line is introspected.
    Delete 'self' parameter for classes (.__init__) and bound methods.
    The next lines are the first lines of the doc string up to the first
    empty line or _MAX_LINES.    For builtins, this typically includes
    the arguments in addition to the return value.
    '''
    argspec = ""
    try:
        ob_call = ob.__call__
    except BaseException:
        return argspec
    if isinstance(ob, type):
        fob = ob.__init__
    elif isinstance(ob_call, types.MethodType):
        fob = ob_call
    else:
        fob = ob
    if isinstance(fob, (types.FunctionType, types.MethodType)):
        argspec = inspect.formatargspec(*inspect.getfullargspec(fob))
        if (isinstance(ob, (type, types.MethodType)) or
                isinstance(ob_call, types.MethodType)):
            argspec = _first_param.sub("", argspec)

    lines = (textwrap.wrap(argspec, _MAX_COLS, subsequent_indent=_INDENT)
            if len(argspec) > _MAX_COLS else [argspec] if argspec else [])

    if isinstance(ob_call, types.MethodType):
        doc = ob_call.__doc__
    else:
        doc = getattr(ob, "__doc__", "")
    if doc:
        for line in doc.split('\n', _MAX_LINES)[:_MAX_LINES]:
            line = line.strip()
            if not line:
                break
            if len(line) > _MAX_COLS:
                line = line[: _MAX_COLS - 3] + '...'
            lines.append(line)
        argspec = '\n'.join(lines)
    if not argspec:
        argspec = _default_callable_argspec
    return argspec

if __name__ == '__main__':
    from unittest import main
    main('idlelib.idle_test.test_calltips', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Please refer to the IDLEfork and IDLE CVS repositories for
change details subsequent to the 0.8.1 release.


IDLEfork ChangeLog
==================

2001-07-20 11:35  elguavas

	* README.txt, NEWS.txt: bring up to date for 0.8.1 release

2001-07-19 16:40  elguavas

	* IDLEFORK.html: replaced by IDLEFORK-index.html

2001-07-19 16:39  elguavas

	* IDLEFORK-index.html: updated placeholder idlefork homepage

2001-07-19 14:49  elguavas

	* ChangeLog, EditorWindow.py, INSTALLATION, NEWS.txt, README.txt,
	TODO.txt, idlever.py:
	minor tidy-ups ready for 0.8.1 alpha tarball release

2001-07-17 15:12  kbk

	* INSTALLATION, setup.py: INSTALLATION: Remove the coexist.patch
	instructions
	
	**************** setup.py:
	
	Remove the idles script, add some words on IDLE Fork to the
	long_description, and clean up some line spacing.

2001-07-17 15:01  kbk

	* coexist.patch: Put this in the attic, at least for now...

2001-07-17 14:59  kbk

	* PyShell.py, idle, idles: Implement idle command interface as
	suggested by GvR [idle-dev] 16 July **************** PyShell: Added
	functionality:
	
	usage: idle.py [-c command] [-d] [-i] [-r script] [-s] [-t title]
	[arg] ...
	
	idle file(s)	(without options) edit the file(s)
	
	-c cmd	   run the command in a shell -d	 enable the
	debugger -i	    open an interactive shell -i file(s) open a
	shell and also an editor window for each file -r script  run a file
	as a script in a shell -s	  run $IDLESTARTUP or
	$PYTHONSTARTUP before anything else -t title   set title of shell
	window
	
	Remaining arguments are applied to the command (-c) or script (-r).
	
	****************** idles: Removed the idles script, not needed
	
	****************** idle:  Removed the IdleConf references, not
	required anymore

2001-07-16 17:08  kbk

	* INSTALLATION, coexist.patch: Added installation instructions.
	
	Added a patch which modifies idlefork so that it can co-exist with
	"official" IDLE in the site-packages directory. This patch is not
	necessary if only idlefork IDLE is installed. See INSTALLATION for
	further details.

2001-07-16 15:50  kbk

	* idles: Add a script "idles" which opens a Python Shell window.
	
	The default behaviour of idlefork idle is to open an editor window
	instead of a shell. Complex expressions may be run in a fresh
	environment by selecting "run".  There are times, however, when a
	shell is desired.  Though one can be started by "idle -t 'foo'",
	this script is more convenient.  In addition, a shell and an editor
	window can be started in parallel by "idles -e foo.py".

2001-07-16 15:25  kbk

	* PyShell.py: Call out IDLE Fork in startup message.

2001-07-16 14:00  kbk

	* PyShell.py, setup.py: Add a script "idles" which opens a Python
	Shell window.
	
	The default behaviour of idlefork idle is to open an editor window
	instead of a shell. Complex expressions may be run in a fresh
	environment by selecting "run".  There are times, however, when a
	shell is desired.  Though one can be started by "idle -t 'foo'",
	this script is more convenient.  In addition, a shell and an editor
	window can be started in parallel by "idles -e foo.py".

2001-07-15 03:06  kbk

	* pyclbr.py, tabnanny.py: tabnanny and pyclbr are now found in /Lib

2001-07-15 02:29  kbk

	* BrowserControl.py: Remove, was retained for 1.5.2 support

2001-07-14 15:48  kbk

	* setup.py: Installing Idle to site-packages via Distutils does not
	copy the Idle help.txt file.
	
	Ref SF Python Patch 422471

2001-07-14 15:26  kbk

	* keydefs.py: py-cvs-2001_07_13 (Rev 1.3) merge
	
	"Make copy, cut and paste events case insensitive.  Reported by
	Patrick K. O'Brien on idle-dev. (Should other bindings follow
	suit?)" --GvR

2001-07-14 15:21  kbk

	* idle.py: py-cvs-2001_07_13 (Rev 1.4) merge
	
	"Move the action of loading the configuration to the IdleConf
	module rather than the idle.py script.	This has advantages and
	disadvantages; the biggest advantage being that we can more easily
	have an alternative main program."  --GvR

2001-07-14 15:18  kbk

	* extend.txt: py-cvs-2001_07_13 (Rev 1.4) merge
	
	"Quick update to the extension mechanism (extend.py is gone, long
	live config.txt)" --GvR

2001-07-14 15:15  kbk

	* StackViewer.py: py-cvs-2001_07_13 (Rev 1.16) merge
	
	"Refactored, with some future plans in mind. This now uses the new
	gotofileline() method defined in FileList.py"  --GvR

2001-07-14 15:10  kbk

	* PyShell.py: py-cvs-2001_07_13 (Rev 1.34) merge
	
	"Amazing.  A very subtle change in policy in descr-branch actually
	found a bug here.  Here's the deal: Class PyShell derives from
	class OutputWindow.  Method PyShell.close() wants to invoke its
	parent method, but because PyShell long ago was inherited from
	class PyShellEditorWindow, it invokes
	PyShelEditorWindow.close(self).  Now, class PyShellEditorWindow
	itself derives from class OutputWindow, and inherits the close()
	method from there without overriding it.  Under the old rules,
	PyShellEditorWindow.close would return an unbound method restricted
	to the class that defined the implementation of close(), which was
	OutputWindow.close.  Under the new rules, the unbound method is
	restricted to the class whose method was requested, that is
	PyShellEditorWindow, and this was correctly trapped as an error."
	--GvR

2001-07-14 14:59  kbk

	* PyParse.py: py-cvs-2001_07_13 (Rel 1.9) merge
	
	"Taught IDLE's autoident parser that "yield" is a keyword that
	begins a stmt.	Along w/ the preceding change to keyword.py, making
	all this work w/ a future-stmt just looks harder and harder."
	--tim_one
	
	(From Rel 1.8: "Hack to make this still work with Python 1.5.2.
	;-( " --fdrake)

2001-07-14 14:51  kbk

	* IdleConf.py: py-cvs-2001_07_13 (Rel 1.7) merge
	
	"Move the action of loading the configuration to the IdleConf
	module rather than the idle.py script.	This has advantages and
	disadvantages; the biggest advantage being that we can more easily
	have an alternative main program." --GvR

2001-07-14 14:45  kbk

	* FileList.py: py-cvs-2000_07_13 (Rev 1.9) merge
	
	"Delete goodname() method, which is unused. Add gotofileline(), a
	convenience method which I intend to use in a variant. Rename
	test() to _test()."  --GvR
	
	This was an interesting merge. The join completely missed removing
	goodname(), which was adjacent, but outside of, a small conflict.
	I only caught it by comparing the 1.1.3.2/1.1.3.3 diff.  CVS ain't
	infallible.

2001-07-14 13:58  kbk

	* EditorWindow.py: py-cvs-2000_07_13 (Rev 1.38) merge "Remove
	legacy support for the BrowserControl module; the webbrowser module
	has been included since Python 2.0, and that is the preferred
	interface." --fdrake

2001-07-14 13:32  kbk

	* EditorWindow.py, FileList.py, IdleConf.py, PyParse.py,
	PyShell.py, StackViewer.py, extend.txt, idle.py, keydefs.py: Import
	the 2001 July 13 23:59 GMT version of Python CVS IDLE on the
	existing 1.1.3 vendor branch named py-cvs-vendor-branch. Release
	tag is py-cvs-2001_07_13.

2001-07-14 12:02  kbk

	* Icons/python.gif: py-cvs-rel2_1 (Rev 1.2) merge Copied py-cvs rev
	1.2 changed file to idlefork MAIN

2001-07-14 11:58  kbk

	* Icons/minusnode.gif: py-cvs-rel2_1 (Rev 1.2) merge Copied py-cvs
	1.2 changed file to idlefork MAIN

2001-07-14 11:23  kbk

	* ScrolledList.py: py-cvs-rel2_1 (rev 1.5) merge - whitespace
	normalization

2001-07-14 11:20  kbk

	* Separator.py: py-cvs-rel2_1 (Rev 1.3) merge - whitespace
	normalization

2001-07-14 11:16  kbk

	* StackViewer.py: py-cvs-rel2_1 (Rev 1.15) merge - whitespace
	normalization

2001-07-14 11:14  kbk

	* ToolTip.py: py-cvs-rel2_1 (Rev 1.2) merge - whitespace
	normalization

2001-07-14 10:13  kbk

	* PyShell.py: cvs-py-rel2_1 (Rev 1.29 - 1.33) merge
	
	Merged the following py-cvs revs without conflict: 1.29 Reduce
	copyright text output at startup 1.30 Delay setting sys.args until
	Tkinter is fully initialized 1.31 Whitespace normalization 1.32
	Turn syntax warning into error when interactive 1.33 Fix warning
	initialization bug
	
	Note that module is extensively modified wrt py-cvs

2001-07-14 06:33  kbk

	* PyParse.py: py-cvs-rel2_1 (Rev 1.6 - 1.8) merge Fix autoindent
	bug and deflect Unicode from text.get()

2001-07-14 06:00  kbk

	* Percolator.py: py-cvs-rel2_1 (Rev 1.3) "move "from Tkinter import
	*" to module level" --jhylton

2001-07-14 05:57  kbk

	* PathBrowser.py: py-cvs-rel2_1 (Rev 1.6) merge - whitespace
	normalization

2001-07-14 05:49  kbk

	* ParenMatch.py: cvs-py-rel2_1 (Rev 1.5) merge - whitespace
	normalization

2001-07-14 03:57  kbk

	* ObjectBrowser.py: py-cvs-rel2_1 (Rev 1.3) merge "Make the test
	program work outside IDLE."  -- GvR

2001-07-14 03:52  kbk

	* MultiStatusBar.py: py-cvs-rel2_1 (Rev 1.2) merge - whitespace
	normalization

2001-07-14 03:44  kbk

	* MultiScrolledLists.py: py-cvs-rel2_1 (Rev 1.2) merge - whitespace
	normalization

2001-07-14 03:40  kbk

	* IdleHistory.py: py-cvs-rel2_1 (Rev 1.4) merge - whitespace
	normalization

2001-07-14 03:38  kbk

	* IdleConf.py: py-cvs-rel2_1 (Rev 1.6) merge - whitespace
	normalization

2001-07-13 14:18  kbk

	* IOBinding.py: py-cvs-rel2_1 (Rev 1.4) merge - move "import *" to
	module level

2001-07-13 14:12  kbk

	* FormatParagraph.py: py-cvs-rel2_1 (Rev 1.9) merge - whitespace
	normalization

2001-07-13 14:07  kbk

	* FileList.py: py-cvs-rel2_1 (Rev 1.8) merge - whitespace
	normalization

2001-07-13 13:35  kbk

	* EditorWindow.py: py-cvs-rel2_1 (Rev 1.33 - 1.37) merge
	
	VP IDLE version depended on VP's ExecBinding.py and spawn.py to get
	the path to the Windows Doc directory (relative to python.exe).
	Removed this conflicting code in favor of py-cvs updates which on
	Windows use a hard coded path relative to the location of this
	module. py-cvs updates include support for webbrowser.py.  Module
	still has BrowserControl.py for 1.5.2 support.
	
	At this point, the differences wrt py-cvs relate to menu
	functionality.

2001-07-13 11:30  kbk

	* ConfigParser.py: py-cvs-rel2_1 merge - Remove, lives in /Lib

2001-07-13 10:10  kbk

	* Delegator.py: py-cvs-rel2_1 (Rev 1.3) merge - whitespace
	normalization

2001-07-13 10:07  kbk

	* Debugger.py: py-cvs-rel2_1 (Rev 1.15) merge - whitespace
	normalization

2001-07-13 10:04  kbk

	* ColorDelegator.py: py-cvs-rel2_1 (Rev 1.11 and 1.12) merge
	Colorize "as" after "import" / use DEBUG instead of __debug__

2001-07-13 09:54  kbk

	* ClassBrowser.py: py-cvs-rel2_1 (Rev 1.12) merge - whitespace
	normalization

2001-07-13 09:41  kbk

	* BrowserControl.py: py-cvs-rel2_1 (Rev 1.1) merge - New File -
	Force HEAD to trunk with -f Note: browser.py was renamed
	BrowserControl.py 10 May 2000. It provides a collection of classes
	and convenience functions to control external browsers "for 1.5.2
	support". It was removed from py-cvs 18 April 2001.

2001-07-13 09:10  kbk

	* CallTips.py: py-cvs-rel2_1 (Rev 1.8) merge - whitespace
	normalization

2001-07-13 08:26  kbk

	* CallTipWindow.py: py-cvs-rel2_1 (Rev 1.3) merge - whitespace
	normalization

2001-07-13 08:13  kbk

	* AutoExpand.py: py-cvs-rel1_2 (Rev 1.4) merge, "Add Alt-slash to
	Unix keydefs (I somehow need it on RH 6.2).  Get rid of assignment
	to unused self.text.wordlist."	--GvR

2001-07-12 16:54  elguavas

	* ReplaceDialog.py: py-cvs merge, python 1.5.2 compatibility

2001-07-12 16:46  elguavas

	* ScriptBinding.py: py-cvs merge, better error dialog

2001-07-12 16:38  elguavas

	* TODO.txt: py-cvs merge, additions

2001-07-12 15:35  elguavas

	* WindowList.py: py-cvs merge, correct indentation

2001-07-12 15:24  elguavas

	* config.txt: py-cvs merge, correct typo

2001-07-12 15:21  elguavas

	* help.txt: py-cvs merge, update colour changing info

2001-07-12 14:51  elguavas

	* idle.py: py-cvs merge, idle_dir loading changed

2001-07-12 14:44  elguavas

	* idlever.py: py-cvs merge, version update

2001-07-11 12:53  kbk

	* BrowserControl.py: Initial revision

2001-07-11 12:53  kbk

	* AutoExpand.py, BrowserControl.py, CallTipWindow.py, CallTips.py,
	ClassBrowser.py, ColorDelegator.py, Debugger.py, Delegator.py,
	EditorWindow.py, FileList.py, FormatParagraph.py, IOBinding.py,
	IdleConf.py, IdleHistory.py, MultiScrolledLists.py,
	MultiStatusBar.py, ObjectBrowser.py, OutputWindow.py,
	ParenMatch.py, PathBrowser.py, Percolator.py, PyParse.py,
	PyShell.py, RemoteInterp.py, ReplaceDialog.py, ScriptBinding.py,
	ScrolledList.py, Separator.py, StackViewer.py, TODO.txt,
	ToolTip.py, WindowList.py, config.txt, help.txt, idle, idle.bat,
	idle.py, idlever.py, setup.py, Icons/minusnode.gif,
	Icons/python.gif: Import the release 2.1 version of Python CVS IDLE
	on the existing 1.1.3 vendor branch named py-cvs-vendor-branch,
	with release tag py-cvs-rel2_1.

2001-07-11 12:34  kbk

	* AutoExpand.py, AutoIndent.py, Bindings.py, CallTipWindow.py,
	CallTips.py, ChangeLog, ClassBrowser.py, ColorDelegator.py,
	Debugger.py, Delegator.py, EditorWindow.py, FileList.py,
	FormatParagraph.py, FrameViewer.py, GrepDialog.py, IOBinding.py,
	IdleConf.py, IdleHistory.py, MultiScrolledLists.py,
	MultiStatusBar.py, NEWS.txt, ObjectBrowser.py, OldStackViewer.py,
	OutputWindow.py, ParenMatch.py, PathBrowser.py, Percolator.py,
	PyParse.py, PyShell.py, README.txt, RemoteInterp.py,
	ReplaceDialog.py, ScriptBinding.py, ScrolledList.py,
	SearchBinding.py, SearchDialog.py, SearchDialogBase.py,
	SearchEngine.py, Separator.py, StackViewer.py, TODO.txt,
	ToolTip.py, TreeWidget.py, UndoDelegator.py, WidgetRedirector.py,
	WindowList.py, ZoomHeight.py, __init__.py, config-unix.txt,
	config-win.txt, config.txt, eventparse.py, extend.txt, help.txt,
	idle.bat, idle.py, idle.pyw, idlever.py, keydefs.py, pyclbr.py,
	tabnanny.py, testcode.py, Icons/folder.gif, Icons/minusnode.gif,
	Icons/openfolder.gif, Icons/plusnode.gif, Icons/python.gif,
	Icons/tk.gif: Import the 9 March 2000 version of Python CVS IDLE as
	1.1.3 vendor branch named py-cvs-vendor-branch.

2001-07-04 13:43  kbk

	* Icons/: folder.gif, minusnode.gif, openfolder.gif, plusnode.gif,
	python.gif, tk.gif: Null commit with -f option to force an uprev
	and put HEADs firmly on the trunk.

2001-07-04 13:15  kbk

	* AutoExpand.py, AutoIndent.py, Bindings.py, CallTipWindow.py,
	CallTips.py, ChangeLog, ClassBrowser.py, ColorDelegator.py,
	ConfigParser.py, Debugger.py, Delegator.py, EditorWindow.py,
	ExecBinding.py, FileList.py, FormatParagraph.py, FrameViewer.py,
	GrepDialog.py, IDLEFORK.html, IOBinding.py, IdleConf.py,
	IdleHistory.py, MultiScrolledLists.py, MultiStatusBar.py, NEWS.txt,
	ObjectBrowser.py, OldStackViewer.py, OutputWindow.py,
	ParenMatch.py, PathBrowser.py, Percolator.py, PyParse.py,
	PyShell.py, README.txt, Remote.py, RemoteInterp.py,
	ReplaceDialog.py, ScriptBinding.py, ScrolledList.py,
	SearchBinding.py, SearchDialog.py, SearchDialogBase.py,
	SearchEngine.py, Separator.py, StackViewer.py, TODO.txt,
	ToolTip.py, TreeWidget.py, UndoDelegator.py, WidgetRedirector.py,
	WindowList.py, ZoomHeight.py, __init__.py, config-unix.txt,
	config-win.txt, config.txt, eventparse.py, extend.txt, help.txt,
	idle, idle.bat, idle.py, idle.pyw, idlever.py, keydefs.py,
	loader.py, protocol.py, pyclbr.py, setup.py, spawn.py, tabnanny.py,
	testcode.py: Null commit with -f option to force an uprev and put
	HEADs firmly on the trunk.

2001-06-27 10:24  elguavas

	* IDLEFORK.html: updated contact details

2001-06-25 17:23  elguavas

	* idle, RemoteInterp.py, setup.py: Initial revision

2001-06-25 17:23  elguavas

	* idle, RemoteInterp.py, setup.py: import current python cvs idle
	as a vendor branch

2001-06-24 15:10  elguavas

	* IDLEFORK.html: tiny change to test new syncmail setup

2001-06-24 14:41  elguavas

	* IDLEFORK.html: change to new developer contact, also a test
	commit for new syncmail setup

2001-06-23 18:15  elguavas

	* IDLEFORK.html: tiny test update for revitalised idle-fork

2000-09-24 17:29  nriley

	* protocol.py: Fixes for Python 1.6 compatibility - socket bind and
	connect get a tuple instead two arguments.

2000-09-24 17:28  nriley

	* spawn.py: Change for Python 1.6 compatibility - UNIX's 'os'
	module defines 'spawnv' now, so we check for 'fork' first.

2000-08-15 22:51  nowonder

	* IDLEFORK.html:
	corrected email address

2000-08-15 22:47  nowonder

	* IDLEFORK.html:
	added .html file for http://idlefork.sourceforge.net

2000-08-15 11:13  dscherer

	* AutoExpand.py, AutoIndent.py, Bindings.py, CallTipWindow.py,
	CallTips.py, __init__.py, ChangeLog, ClassBrowser.py,
	ColorDelegator.py, ConfigParser.py, Debugger.py, Delegator.py,
	FileList.py, FormatParagraph.py, FrameViewer.py, GrepDialog.py,
	IOBinding.py, IdleConf.py, IdleHistory.py, MultiScrolledLists.py,
	MultiStatusBar.py, NEWS.txt, ObjectBrowser.py, OldStackViewer.py,
	OutputWindow.py, ParenMatch.py, PathBrowser.py, Percolator.py,
	PyParse.py, PyShell.py, README.txt, ReplaceDialog.py,
	ScriptBinding.py, ScrolledList.py, SearchBinding.py,
	SearchDialog.py, SearchDialogBase.py, SearchEngine.py,
	Separator.py, StackViewer.py, TODO.txt, ToolTip.py, TreeWidget.py,
	UndoDelegator.py, WidgetRedirector.py, WindowList.py, help.txt,
	ZoomHeight.py, config-unix.txt, config-win.txt, config.txt,
	eventparse.py, extend.txt, idle.bat, idle.py, idle.pyw, idlever.py,
	keydefs.py, loader.py, pyclbr.py, tabnanny.py, testcode.py,
	EditorWindow.py, ExecBinding.py, Remote.py, protocol.py, spawn.py,
	Icons/folder.gif, Icons/minusnode.gif, Icons/openfolder.gif,
	Icons/plusnode.gif, Icons/python.gif, Icons/tk.gif: Initial
	revision

2000-08-15 11:13  dscherer

	* AutoExpand.py, AutoIndent.py, Bindings.py, CallTipWindow.py,
	CallTips.py, __init__.py, ChangeLog, ClassBrowser.py,
	ColorDelegator.py, ConfigParser.py, Debugger.py, Delegator.py,
	FileList.py, FormatParagraph.py, FrameViewer.py, GrepDialog.py,
	IOBinding.py, IdleConf.py, IdleHistory.py, MultiScrolledLists.py,
	MultiStatusBar.py, NEWS.txt, ObjectBrowser.py, OldStackViewer.py,
	OutputWindow.py, ParenMatch.py, PathBrowser.py, Percolator.py,
	PyParse.py, PyShell.py, README.txt, ReplaceDialog.py,
	ScriptBinding.py, ScrolledList.py, SearchBinding.py,
	SearchDialog.py, SearchDialogBase.py, SearchEngine.py,
	Separator.py, StackViewer.py, TODO.txt, ToolTip.py, TreeWidget.py,
	UndoDelegator.py, WidgetRedirector.py, WindowList.py, help.txt,
	ZoomHeight.py, config-unix.txt, config-win.txt, config.txt,
	eventparse.py, extend.txt, idle.bat, idle.py, idle.pyw, idlever.py,
	keydefs.py, loader.py, pyclbr.py, tabnanny.py, testcode.py,
	EditorWindow.py, ExecBinding.py, Remote.py, protocol.py, spawn.py,
	Icons/folder.gif, Icons/minusnode.gif, Icons/openfolder.gif,
	Icons/plusnode.gif, Icons/python.gif, Icons/tk.gif: Modified IDLE
	from VPython 0.2


original IDLE ChangeLog:
========================

Tue Feb 15 18:08:19 2000  Guido van Rossum  <guido@cnri.reston.va.us>

	* NEWS.txt: Notice status bar and stack viewer.

	* EditorWindow.py: Support for Moshe's status bar.

	* MultiStatusBar.py: Status bar code -- by Moshe Zadka.

	* OldStackViewer.py:
	Adding the old stack viewer implementation back, for the debugger.

	* StackViewer.py: New stack viewer, uses a tree widget.
	(XXX: the debugger doesn't yet use this.)

	* WindowList.py:
	Correct a typo and remove an unqualified except that was hiding the error.

	* ClassBrowser.py: Add an XXX comment about the ClassBrowser AIP.

	* ChangeLog: Updated change log.

	* NEWS.txt: News update.  Probably incomplete; what else is new?

	* README.txt:
	Updated for pending IDLE 0.5 release (still very rough -- just getting
	it out in a more convenient format than CVS).

	* TODO.txt: Tiny addition.

Thu Sep  9 14:16:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: A few new TODO entries.

Thu Aug 26 23:06:22 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* Bindings.py: Add Python Documentation entry to Help menu.

	* EditorWindow.py:
	Find the help.txt file relative to __file__ or ".", not in sys.path.
	(Suggested by Moshe Zadka, but implemented differently.)

	Add <<python-docs>> event which, on Unix, brings up Netscape pointing
	to http://www.python.doc/current/ (a local copy would be nice but its
	location can't be predicted).  Windows solution TBD.

Wed Aug 11 14:55:43 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TreeWidget.py:
	Moshe noticed an inconsistency in his comment, so I'm rephrasing it to
	be clearer.

	* TreeWidget.py:
	Patch inspired by Moshe Zadka to search for the Icons directory in the
	same directory as __file__, rather than searching for it along sys.path.
	This works better when idle is a package.

Thu Jul 15 13:11:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: New wishes.

Sat Jul 10 13:17:35 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* IdlePrefs.py:
	Make the color for stderr red (i.e. the standard warning/danger/stop
	color) rather than green.  Suggested by Sam Schulenburg.

Fri Jun 25 17:26:34 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* PyShell.py: Close debugger when closing.  This may break a cycle.

	* Debugger.py: Break cycle on close.

	* ClassBrowser.py: Destroy the tree when closing.

	* TreeWidget.py: Add destroy() method to recursively destroy a tree.

	* PyShell.py: Extend _close() to break cycles.
	Break some other cycles too (and destroy the root when done).

	* EditorWindow.py:
	Add _close() method that does the actual cleanup (close() asks the
	user what they want first if there's unsaved stuff, and may cancel).
	It closes more than before.

	Add unload_extensions() method to unload all extensions; called from
	_close().  It calls an extension's close() method if it has one.

	* Percolator.py: Add close() method that breaks cycles.

	* WidgetRedirector.py: Add unregister() method.
	Unregister everything at closing.
	Don't call close() in __del__, rely on explicit call to close().

	* IOBinding.py, FormatParagraph.py, CallTips.py:
	Add close() method that breaks a cycle.

Fri Jun 11 15:03:00 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py, EditorWindow.py, FormatParagraph.py:
	Tim Peters smart.patch:

	EditorWindow.py:

	+ Added get_tabwidth & set_tabwidth "virtual text" methods, that get/set the
	widget's view of what a tab means.

	+ Moved TK_TABWIDTH_DEFAULT here from AutoIndent.

	+ Renamed Mark's get_selection_index to get_selection_indices (sorry, Mark,
	but the name was plain wrong <wink>).

	FormatParagraph.py:  renamed use of get_selection_index.

	AutoIndent.py:

	+ Moved TK_TABWIDTH_DEFAULT to EditorWindow.

	+ Rewrote set_indentation_params to use new VTW get/set_tabwidth methods.

	+ Changed smart_backspace_event to delete whitespace back to closest
	preceding virtual tab stop or real character (note that this may require
	inserting characters if backspacing over a tab!).

	+ Nuked almost references to the selection tag, in favor of using
	get_selection_indices.  The sole exception is in set_region, for which no
	"set_selection" abstraction has yet been agreed upon.

	+ Had too much fun using the spiffy new features of the format-paragraph
	cmd.

Thu Jun 10 17:48:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* FormatParagraph.py:
	Code by Mark Hammond to format paragraphs embedded in comments.
	Read the comments (which I reformatted using the new feature :-)
	for some limitations.

	* EditorWindow.py:
	Added abstraction get_selection_index() (Mark Hammond).  Also
	reformatted some comment blocks to show off a cool feature I'm about
	to check in next.

	* ClassBrowser.py:
	Adapt to the new pyclbr's support of listing top-level functions.  If
	this functionality is not present (e.g. when used with a vintage
	Python 1.5.2 installation) top-level functions are not listed.

	(Hmm...  Any distribution of IDLE 0.5 should probably include a copy
	of the new pyclbr.py!)

	* AutoIndent.py:
	Fix off-by-one error in Tim's recent change to comment_region(): the
	list of lines returned by get_region() contains an empty line at the
	end representing the start of the next line, and this shouldn't be
	commented out!

	* CallTips.py:
	Mark Hammond writes: Here is another change that allows it to work for
	class creation - tries to locate an __init__ function.  Also updated
	the test code to reflect your new "***" change.

	* CallTipWindow.py:
	Mark Hammond writes: Tim's suggestion of copying the font for the
	CallTipWindow from the text control makes sense, and actually makes
	the control look better IMO.

Wed Jun  9 20:34:57 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* CallTips.py:
	Append "..." if the appropriate flag (for varargs) in co_flags is set.
	Ditto "***" for kwargs.

Tue Jun  8 13:06:07 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ReplaceDialog.py:
	Hmm...  Tim didn't turn "replace all" into a single undo block.
	I think I like it better if it os, so here.

	* ReplaceDialog.py: Tim Peters: made replacement atomic for undo/redo.

	* AutoIndent.py: Tim Peters:

	+ Set usetabs=1.  Editing pyclbr.py was driving me nuts <0.6 wink>.
	usetabs=1 is the Emacs pymode default too, and thanks to indentwidth !=
	tabwidth magical usetabs disabling, new files are still created with tabs
	turned off.  The only implication is that if you open a file whose first
	indent is a single tab, IDLE will now magically use tabs for that file (and
	set indentwidth to 8).  Note that the whole scheme doesn't work right for
	PythonWin, though, since Windows users typically set tabwidth to 4; Mark
	probably has to hide the IDLE algorithm from them (which he already knows).

	+ Changed comment_region_event to stick "##" in front of every line.  The
	"holes" previously left on blank lines were visually confusing (made it
	needlessly hard to figure out what to uncomment later).

Mon Jun  7 15:38:40 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TreeWidget.py, ObjectBrowser.py:
	Remove unnecessary reference to pyclbr from test() code.

	* PyParse.py: Tim Peters:

	Smarter logic for finding a parse synch point.

	Does a half to a fifth the work in normal cases; don't notice the speedup,
	but makes  more breathing room for other extensions.

	Speeds terrible cases by at least a factor of 10. "Terrible" == e.g. you put
	""" at the start of Tkinter.py, undo it, zoom to the bottom, and start
	typing in code.  Used to take about 8 seconds for ENTER to respond, now some
	large fraction of a second.  The new code gets indented correctly, despite
	that it all remains "string colored" until the colorizer catches up (after
	which, ENTER appears instantaneous again).

Fri Jun  4 19:21:19 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* extend.py: Might as well enable CallTips by default.
	If there are too many complaints I'll remove it again or fix it.

Thu Jun  3 14:32:16 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py, EditorWindow.py, PyParse.py:
	New offerings by Tim Peters; he writes:

	IDLE is now the first Python editor in the Universe not confused by my
	doctest.py <wink>.

	As threatened, this defines IDLE's is_char_in_string function as a
	method of EditorWindow.  You just need to define one similarly in
	whatever it is you pass as editwin to AutoIndent; looking at the
	EditorWindow.py part of the patch should make this clear.

	* GrepDialog.py: Enclose pattern in quotes in status message.

	* CallTips.py:
	Mark Hammond fixed some comments and improved the way the tip text is
	constructed.

Wed Jun  2 18:18:57 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* CallTips.py:
	My fix to Mark's code: restore the universal check on <KeyRelease>.
	Always cancel on <Key-Escape> or <ButtonPress>.

	* CallTips.py:
	A version that Mark Hammond posted to the newsgroup.  Has some newer
	stuff for getting the tip.  Had to fix the Key-( and Key-) events
	for Unix.  Will have to re-apply my patch for catching KeyRelease and
	ButtonRelease events.

	* CallTipWindow.py, CallTips.py:
	Call tips by Mark Hammond (plus tiny fix by me.)

	* IdleHistory.py:
	Changes by Mark Hammond: (1) support optional output_sep argument to
	the constructor so he can eliminate the sys.ps2 that PythonWin leaves
	in the source; (2) remove duplicate history items.

	* AutoIndent.py:
	Changes by Mark Hammond to allow using IDLE extensions in PythonWin as
	well: make three dialog routines instance variables.

	* EditorWindow.py:
	Change by Mark Hammond to allow using IDLE extensions in PythonWin as
	well: make three dialog routines instance variables.

Tue Jun  1 20:06:44 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py: Hah!  A fix of my own to Tim's code!
	Unix bindings for <<toggle-tabs>> and <<change-indentwidth>> were
	missing, and somehow that meant the events were never generated,
	even though they were in the menu.  The new Unix bindings are now
	the same as the Windows bindings (M-t and M-u).

	* AutoIndent.py, PyParse.py, PyShell.py: Tim Peters again:

	The new version (attached) is fast enough all the time in every real module
	I have <whew!>.  You can make it slow by, e.g., creating an open list with
	5,000 90-character identifiers (+ trailing comma) each on its own line, then
	adding an item to the end -- but that still consumes less than a second on
	my P5-166.  Response time in real code appears instantaneous.

	Fixed some bugs.

	New feature:  when hitting ENTER and the cursor is beyond the line's leading
	indentation, whitespace is removed on both sides of the cursor; before
	whitespace was removed only on the left; e.g., assuming the cursor is
	between the comma and the space:

	def something(arg1, arg2):
	                   ^ cursor to the left of here, and hit ENTER
	               arg2):   # new line used to end up here
	              arg2):    # but now lines up the way you expect

	New hack:  AutoIndent has grown a context_use_ps1 Boolean config option,
	defaulting to 0 (false) and set to 1 (only) by PyShell.  Reason:  handling
	the fancy stuff requires looking backward for a parsing synch point; ps1
	lines are the only sensible thing to look for in a shell window, but are a
	bad thing to look for in a file window (ps1 lines show up in my module
	docstrings often).  PythonWin's shell should set this true too.

	Persistent problem:  strings containing def/class can still screw things up
	completely.  No improvement.  Simplest workaround is on the user's head, and
	consists of inserting e.g.

	def _(): pass

	(or any other def/class) after the end of the multiline string that's
	screwing them up.  This is especially irksome because IDLE's syntax coloring
	is *not* confused, so when this happens the colors don't match the
	indentation behavior they see.

	* AutoIndent.py: Tim Peters again:

	[Tim, after adding some bracket smarts to AutoIndent.py]
	> ...
	> What it can't possibly do without reparsing large gobs of text is
	> suggest a reasonable indent level after you've *closed* a bracket
	> left open on some previous line.
	> ...

	The attached can, and actually fast enough to use -- most of the time.  The
	code is tricky beyond belief to achieve that, but it works so far; e.g.,

	        return len(string.expandtabs(str[self.stmt_start :
	                                         ^ indents to caret
	                                         i],
	                                     ^ indents to caret
	                                     self.tabwidth)) + 1
	    ^ indents to caret

	It's about as smart as pymode now, wrt both bracket and backslash
	continuation rules.  It does require reparsing large gobs of text, and if it
	happens to find something that looks like a "def" or "class" or sys.ps1
	buried in a multiline string, but didn't suck up enough preceding text to
	see the start of the string, it's completely hosed.  I can't repair that --
	it's just too slow to reparse from the start of the file all the time.

	AutoIndent has grown a new num_context_lines tuple attribute that controls
	how far to look back, and-- like other params --this could/should be made
	user-overridable at startup and per-file on the fly.

	* PyParse.py: New file by Tim Peters:

	One new file in the attached, PyParse.py.  The LineStudier (whatever it was
	called <wink>) class was removed from AutoIndent; PyParse subsumes its
	functionality.

	* AutoIndent.py: Tim Peters keeps revising this module (more to come):

	Removed "New tabwidth" menu binding.

	Added "a tab means how many spaces?" dialog to block tabify and untabify.  I
	think prompting for this is good now:  they're usually at-most-once-per-file
	commands, and IDLE can't let them change tabwidth from the Tk default
	anymore, so IDLE can no longer presume to have any idea what a tab means.

	Irony:  for the purpose of keeping comments aligned via tabs, Tk's
	non-default approach is much nicer than the Emacs/Notepad/Codewright/vi/etc
	approach.

	* EditorWindow.py:
	1. Catch NameError on import (could be raised by case mismatch on Windows).
	2. No longer need to reset pyclbr cache and show watch cursor when calling
	   ClassBrowser -- the ClassBrowser takes care of pyclbr and the TreeWidget
	   takes care of the watch cursor.
	3. Reset the focus to the current window after error message about class
	   browser on buffer without filename.

	* Icons/minusnode.gif, Icons/plusnode.gif: Missed a few.

	* ClassBrowser.py, PathBrowser.py: Rewritten based on TreeWidget.py

	* ObjectBrowser.py: Object browser, based on TreeWidget.py.

	* TreeWidget.py: Tree widget done right.

	* ToolTip.py: As yet unused code for tool tips.

	* ScriptBinding.py:
	Ensure sys.argv[0] is the script name on Run Script.

	* ZoomHeight.py: Move zoom height functionality to separate function.

	* Icons/folder.gif, Icons/openfolder.gif, Icons/python.gif, Icons/tk.gif:
	A few icons used by ../TreeWidget.py and its callers.

	* AutoIndent.py: New version by Tim Peters improves block opening test.

Fri May 21 04:46:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/History.py, PyShell.py: Rename History to IdleHistory.
	Add isatty() to pseudo files.

	* StackViewer.py: Make initial stack viewer wider

	* TODO.txt: New wishes

	* AutoIndent.py, EditorWindow.py, PyShell.py:
	Much improved autoindent and handling of tabs,
	by Tim Peters.

Mon May  3 15:49:52 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py, EditorWindow.py, FormatParagraph.py, UndoDelegator.py:
	Tim Peters writes:

	I'm still unsure, but couldn't stand the virtual event trickery so tried a
	different sin (adding undo_block_start/stop methods to the Text instance in
	EditorWindow.py).  Like it or not, it's efficient and works <wink>.  Better
	idea?

	Give the attached a whirl.  Even if you hate the implementation, I think
	you'll like the results.  Think I caught all the "block edit" cmds,
	including Format Paragraph, plus subtler ones involving smart indents and
	backspacing.

	* WidgetRedirector.py: Tim Peters writes:

	[W]hile trying to dope out how redirection works, stumbled into two
	possible glitches.  In the first, it doesn't appear to make sense to try to
	rename a command that's already been destroyed; in the second, the name
	"previous" doesn't really bring to mind "ignore the previous value" <wink>.

Fri Apr 30 19:39:25 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* __init__.py: Support for using idle as a package.

	* PathBrowser.py:
	Avoid listing files more than once (e.g. foomodule.so has two hits:
	once for foo + module.so, once for foomodule + .so).

Mon Apr 26 22:20:38 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ChangeLog, ColorDelegator.py, PyShell.py: Tim Peters strikes again:

	Ho ho ho -- that's trickier than it sounded!  The colorizer is working with
	"line.col" strings instead of Text marks, and the absolute coordinates of
	the point of interest can change across the self.update call (voice of
	baffled experience, when two quick backspaces no longer fooled it, but a
	backspace followed by a quick ENTER did <wink>).

	Anyway, the attached appears to do the trick.  CPU usage goes way up when
	typing quickly into a long triple-quoted string, but the latency is fine for
	me (a relatively fast typist on a relatively slow machine).  Most of the
	changes here are left over from reducing the # of vrbl names to help me
	reason about the logic better; I hope the code is a *little* easier to

Fri Apr 23 14:01:25 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py:
	Provide full arguments to __import__ so it works in packagized IDLE.

Thu Apr 22 23:20:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

        * help.txt:
        Bunch of updates necessary due to recent changes; added docs for File
        menu, command line and color preferences.

        * Bindings.py: Remove obsolete 'script' menu.

	* TODO.txt: Several wishes fulfilled.

	* OutputWindow.py:
	Moved classes OnDemandOutputWindow and PseudoFile here,
	from ScriptBinding.py where they are no longer needed.

	* ScriptBinding.py:
	Mostly rewritten.  Instead of the old Run module and Debug module,
	there are two new commands:

	Import module (F5) imports or reloads the module and also adds its
	name to the __main__ namespace.  This gets executed in the PyShell
	window under control of its debug settings.

	Run script (Control-F5) is similar but executes the contents of the
	file directly in the __main__ namespace.

	* PyShell.py: Nits: document use of $IDLESTARTUP; display idle version

	* idlever.py: New version to celebrate new command line

	* OutputWindow.py: Added flush(), for completeness.

	* PyShell.py:
	A lot of changes to make the command line more useful.  You can now do:
	  idle.py -e file ...    -- to edit files
	  idle.py script arg ... -- to run a script
	  idle.py -c cmd arg ... -- to run a command
	Other options, see also the usage message (also new!) for more details:
	  -d       -- enable debugger
	  -s       -- run $IDLESTARTUP or $PYTHONSTARTUP
	  -t title -- set Python Shell window's title
	sys.argv is set accordingly, unless -e is used.
	sys.path is absolutized, and all relevant paths are inserted into it.

	Other changes:
	- the environment in which commands are executed is now the
	  __main__ module
	- explicitly save sys.stdout etc., don't restore from sys.__stdout__
	- new interpreter methods execsource(), execfile(), stuffsource()
	- a few small nits

	* TODO.txt:
	Some more TODO items.  Made up my mind about command line args,
	Run/Import, __main__.

	* ColorDelegator.py:
	Super-elegant patch by Tim Peters that speeds up colorization
	dramatically (up to 15 times he claims).  Works by reading more than
	one line at a time, up to 100-line chunks (starting with one line and
	then doubling up to the limit).  On a typical machine (e.g. Tim's
	P5-166) this doesn't reduce interactive responsiveness in a noticeable
	way.

Wed Apr 21 15:49:34 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ColorDelegator.py:
	Patch by Tim Peters to speed up colorizing of big multiline strings.

Tue Apr 20 17:32:52 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* extend.txt:
	For an event 'foo-bar', the corresponding method must be called
	foo_bar_event().  Therefore, fix the references to zoom_height() in
	the example.

	* IdlePrefs.py: Restored the original IDLE color scheme.

	* PyShell.py, IdlePrefs.py, ColorDelegator.py, EditorWindow.py:
	Color preferences code by Loren Luke (massaged by me somewhat)

	* SearchEngine.py:
	Patch by Mark Favas: it fixes the search engine behaviour where an
	unsuccessful search wraps around and re-searches that part of the file
	between the start of the search and the end of the file - only really
	an issue for very large files, but... (also removes a redundant
	m.span() call).

Mon Apr 19 16:26:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: A few wishes are now fulfilled.

	* AutoIndent.py: Tim Peters implements some of my wishes:

	o Makes the tab key intelligently insert spaces when appropriate
	(see Help list banter twixt David Ascher and me; idea stolen from
	every other editor on earth <wink>).

	o newline_and_indent_event trims trailing whitespace on the old
	line (pymode and Codewright).

	o newline_and_indent_event no longer fooled by trailing whitespace or
	comment after ":" (pymode, PTUI).

	o newline_and_indent_event now reduces the new line's indentation after
	return, break, continue, raise and pass stmts (pymode).

	The last two are easy to fool in the presence of strings &
	continuations, but pymode requires Emacs's high-powered C parsing
	functions to avoid that in finite time.

======================================================================
	Python release 1.5.2c1, IDLE version 0.4
======================================================================

Wed Apr  7 18:41:59 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* README.txt, NEWS.txt: New version.

	* idlever.py: Version bump awaiting impending new release.
	(Not much has changed :-( )

Mon Mar 29 14:52:28 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ScriptBinding.py, PyShell.py:
	At Tim Peters' recommendation, add a dummy flush() method to
	PseudoFile.

Thu Mar 11 23:21:23 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* PathBrowser.py: Don't crash when sys.path contains an empty string.

	* Attic/Outline.py: This file was never supposed to be part of IDLE.

	* PathBrowser.py:
	- Don't crash in the case where a superclass is a string instead of a
	pyclbr.Class object; this can happen when the superclass is
	unrecognizable (to pyclbr), e.g. when module renaming is used.

	- Show a watch cursor when calling pyclbr (since it may take a while
	recursively parsing imported modules!).

Wed Mar 10 05:18:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py, Bindings.py: Add PathBrowser to File module

	* PathBrowser.py: "Path browser" - 4 scrolled lists displaying:
	    directories on sys.path
	    modules in selected directory
	    classes in selected module
	    methods of selected class

	Sinlge clicking in a directory, module or class item updates the next
	column with info about the selected item.  Double clicking in a
	module, class or method item opens the file (and selects the clicked
	item if it is a class or method).

	I guess eventually I should be using a tree widget for this, but the
	ones I've seen don't work well enough, so for now I use the old
	Smalltalk or NeXT style multi-column hierarchical browser.

	* MultiScrolledLists.py:
	New utility: multiple scrolled lists in parallel

	* ScrolledList.py: - White background.
	- Display "(None)" (or text of your choosing) when empty.
	- Don't set the focus.

======================================================================
	Python release 1.5.2b2, IDLE version 0.3
======================================================================
	
Wed Feb 17 22:47:41 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* NEWS.txt: News in 0.3.

	* README.txt, idlever.py: Bump version to 0.3.

	* EditorWindow.py:
	After all, we don't need to call the callbacks ourselves!

	* WindowList.py:
	When deleting, call the callbacks *after* deleting the window from our list!

	* EditorWindow.py:
	Fix up the Windows menu via the new callback mechanism instead of
	depending on menu post commands (which don't work when the menu is
	torn off).

	* WindowList.py:
	Support callbacks to patch up Windows menus everywhere.

	* ChangeLog: Oh, why not.  Checking in the Emacs-generated change log.

Tue Feb 16 22:34:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ScriptBinding.py:
	Only pop up the stack viewer when requested in the Debug menu.

Mon Feb  8 22:27:49 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* WindowList.py: Don't crash if a window no longer exists.

	* TODO.txt: Restructured a bit.

Mon Feb  1 23:06:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* PyShell.py: Add current dir or paths of file args to sys.path.

	* Debugger.py: Add canonic() function -- for brand new bdb.py feature.

	* StackViewer.py: Protect against accessing an empty stack.

Fri Jan 29 20:44:45 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ZoomHeight.py:
	Use only the height to decide whether to zoom in or out.

Thu Jan 28 22:24:30 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py, FileList.py:
	Make sure the Tcl variables are shared between windows.

	* PyShell.py, EditorWindow.py, Bindings.py:
	Move menu/key binding code from Bindings.py to EditorWindow.py,
	with changed APIs -- it makes much more sense there.
	Also add a new feature: if the first character of a menu label is
	a '!', it gets a checkbox.  Checkboxes are bound to Boolean Tcl variables
	that can be accessed through the new getvar/setvar/getrawvar API;
	the variable is named after the event to which the menu is bound.

	* Debugger.py: Add Quit button to the debugger window.

	* SearchDialog.py:
	When find_again() finds exactly the current selection, it's a failure.

	* idle.py, Attic/idle: Rename idle -> idle.py

Mon Jan 18 15:18:57 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py, WindowList.py: Only deiconify when iconic.

	* TODO.txt: Misc

Tue Jan 12 22:14:34 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* testcode.py, Attic/test.py:
	Renamed test.py to testcode.py so one can import Python's
	test package from inside IDLE.  (Suggested by Jack Jansen.)

	* EditorWindow.py, ColorDelegator.py:
	Hack to close a window that is colorizing.

	* Separator.py: Vladimir Marangozov's patch:
	The separator dances too much and seems to jump by arbitrary amounts
	in arbitrary directions when I try to move it for resizing the frames.
	This patch makes it more quiet.

Mon Jan 11 14:52:40 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: Some requests have been fulfilled.

	* EditorWindow.py:
	Set the cursor to a watch when opening the class browser (which may
	take quite a while, browsing multiple files).

	Newer, better center() -- but assumes no wrapping.

	* SearchBinding.py:
	Got rid of debug print statement in goto_line_event().

	* ScriptBinding.py:
	I think I like it better if it prints the traceback even when it displays
	the stack viewer.

	* Debugger.py: Bind ESC to close-window.

	* ClassBrowser.py: Use a HSeparator between the classes and the items.
	Make the list of classes wider by default (40 chars).
	Bind ESC to close-window.

	* Separator.py:
	Separator classes (draggable divider between two panes).

Sat Jan  9 22:01:33 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* WindowList.py:
	Don't traceback when wakeup() is called when the window has been destroyed.
	This can happen when a torn-of Windows menu references closed windows.
	And Tim Peters claims that the Windows menu is his favorite to tear off...

	* EditorWindow.py: Allow tearing off of the Windows menu.

	* StackViewer.py: Close on ESC.

	* help.txt: Updated a bunch of things (it was mostly still 0.1!)

	* extend.py: Added ScriptBinding to standard bindings.

	* ScriptBinding.py:
	This now actually works.  See doc string.  It can run a module (i.e.
	import or reload) or debug it (same with debugger control).  Output
	goes to a fresh output window, only created when needed.

======================================================================
	Python release 1.5.2b1, IDLE version 0.2
======================================================================
	
Fri Jan  8 17:26:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* README.txt, NEWS.txt: What's new in this release.

	* Bindings.py, PyShell.py:
	Paul Prescod's patches to allow the stack viewer to pop up when a
	traceback is printed.

Thu Jan  7 00:12:15 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* FormatParagraph.py:
	Change paragraph width limit to 70 (like Emacs M-Q).

	* README.txt:
	Separating TODO from README.  Slight reformulation of features.  No
	exact release date.

	* TODO.txt: Separating TODO from README.

Mon Jan  4 21:19:09 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* FormatParagraph.py:
	Hm.  There was a boundary condition error at the end of the file too.

	* SearchBinding.py: Hm.  Add Unix binding for replace, too.

	* keydefs.py: Ran eventparse.py again.

	* FormatParagraph.py: Added Unix Meta-q key binding;
	fix find_paragraph when at start of file.

	* AutoExpand.py: Added Meta-/ binding for Unix as alt for Alt-/.

	* SearchBinding.py:
	Add unix binding for grep (otherwise the menu entry doesn't work!)

	* ZoomHeight.py: Adjusted Unix height to work with fvwm96. :=(

	* GrepDialog.py: Need to import sys!

	* help.txt, extend.txt, README.txt: Formatted some paragraphs

	* extend.py, FormatParagraph.py:
	Add new extension to reformat a (text) paragraph.

	* ZoomHeight.py: Typo in Win specific height setting.

Sun Jan  3 00:47:35 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py: Added something like Tim Peters' backspace patch.

	* ZoomHeight.py: Adapted to Unix (i.e., more hardcoded constants).

Sat Jan  2 21:28:54 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* keydefs.py, idlever.py, idle.pyw, idle.bat, help.txt, extend.txt, extend.py, eventparse.py, ZoomHeight.py, WindowList.py, UndoDelegator.py, StackViewer.py, SearchEngine.py, SearchDialogBase.py, SearchDialog.py, ScrolledList.py, SearchBinding.py, ScriptBinding.py, ReplaceDialog.py, Attic/README, README.txt, PyShell.py, Attic/PopupMenu.py, OutputWindow.py, IOBinding.py, Attic/HelpWindow.py, History.py, GrepDialog.py, FileList.py, FrameViewer.py, EditorWindow.py, Debugger.py, Delegator.py, ColorDelegator.py, Bindings.py, ClassBrowser.py, AutoExpand.py, AutoIndent.py:
	Checking in IDLE 0.2.

	Much has changed -- too much, in fact, to write down.
	The big news is that there's a standard way to write IDLE extensions;
	see extend.txt.  Some sample extensions have been provided, and
	some existing code has been converted to extensions.  Probably the
	biggest new user feature is a new search dialog with more options,
	search and replace, and even search in files (grep).

	This is exactly as downloaded from my laptop after returning
	from the holidays -- it hasn't even been tested on Unix yet.

Fri Dec 18 15:52:54 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* FileList.py, ClassBrowser.py:
	Fix the class browser to work even when the file is not on sys.path.

Tue Dec  8 20:39:36 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/turtle.py: Moved to Python 1.5.2/Lib

Fri Nov 27 03:19:20 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* help.txt: Typo

	* EditorWindow.py, FileList.py: Support underlining of menu labels

	* Bindings.py:
	New approach, separate tables for menus (platform-independent) and key
	definitions (platform-specific), and generating accelerator strings
	automatically from the key definitions.

Mon Nov 16 18:37:42 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/README: Clarify portability and main program.

	* Attic/README: Added intro for 0.1 release and append Grail notes.

Mon Oct 26 18:49:00 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/turtle.py: root is now a global called _root

Sat Oct 24 16:38:38 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/turtle.py: Raise the root window on reset().
	Different action on WM_DELETE_WINDOW is more likely to do the right thing,
	allowing us to destroy old windows.

	* Attic/turtle.py:
	Split the goto() function in two: _goto() is the internal one,
	using Canvas coordinates, and goto() uses turtle coordinates
	and accepts variable argument lists.

	* Attic/turtle.py: Cope with destruction of the window

	* Attic/turtle.py: Turtle graphics

	* Debugger.py: Use of Breakpoint class should be bdb.Breakpoint.

Mon Oct 19 03:33:40 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* SearchBinding.py:
	Speed up the search a bit -- don't drag a mark around...

	* PyShell.py:
	Change our special entries from <console#N> to <pyshell#N>.
	Patch linecache.checkcache() to keep our special entries alive.
	Add popup menu to all editor windows to set a breakpoint.

	* Debugger.py:
	Use and pass through the 'force' flag to set_dict() where appropriate.
	Default source and globals checkboxes to false.
	Don't interact in user_return().
	Add primitive set_breakpoint() method.

	* ColorDelegator.py:
	Raise priority of 'sel' tag so its foreground (on Windows) will take
	priority over text colorization (which on Windows is almost the
	same color as the selection background).

	Define a tag and color for breakpoints ("BREAK").

	* Attic/PopupMenu.py: Disable "Open stack viewer" and "help" commands.

	* StackViewer.py:
	Add optional 'force' argument (default 0) to load_dict().
	If set, redo the display even if it's the same dict.

Fri Oct 16 21:10:12 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* StackViewer.py: Do nothing when loading the same dict as before.

	* PyShell.py: Details for debugger interface.

	* Debugger.py:
	Restructured and more consistent.  Save checkboxes across instantiations.

	* EditorWindow.py, Attic/README, Bindings.py:
	Get rid of conflicting ^X binding.  Use ^W.

	* Debugger.py, StackViewer.py:
	Debugger can now show local and global variables.

	* Debugger.py: Oops

	* Debugger.py, PyShell.py: Better debugger support (show stack etc).

	* Attic/PopupMenu.py: Follow renames in StackViewer module

	* StackViewer.py:
	Rename classes to StackViewer (the widget) and StackBrowser (the toplevel).

	* ScrolledList.py: Add close() method

	* EditorWindow.py: Clarify 'Open Module' dialog text

	* StackViewer.py: Restructured into a browser and a widget.

Thu Oct 15 23:27:08 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* ClassBrowser.py, ScrolledList.py:
	Generalized the scrolled list which is the base for the class and
	method browser into a separate class in its own module.

	* Attic/test.py: Cosmetic change

	* Debugger.py: Don't show function name if there is none

Wed Oct 14 03:43:05 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Debugger.py, PyShell.py: Polish the Debugger GUI a bit.
	Closing it now also does the right thing.

Tue Oct 13 23:51:13 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Debugger.py, PyShell.py, Bindings.py:
	Ad primitive debugger interface (so far it will step and show you the
	source, but it doesn't yet show the stack).

	* Attic/README: Misc

	* StackViewer.py: Whoops -- referenced self.top before it was set.

	* help.txt: Added history and completion commands.

	* help.txt: Updated

	* FileList.py: Add class browser functionality.

	* StackViewer.py:
	Add a close() method and bind to WM_DELETE_WINDOW protocol

	* PyShell.py: Clear the linecache before printing a traceback

	* Bindings.py: Added class browser binding.

	* ClassBrowser.py: Much improved, much left to do.

	* PyShell.py: Make the return key do what I mean more often.

	* ClassBrowser.py:
	Adding the beginnings of a Class browser.  Incomplete, yet.

	* EditorWindow.py, Bindings.py:
	Add new command, "Open module".  You select or type a module name,
	and it opens the source.

Mon Oct 12 23:59:27 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* PyShell.py: Subsume functionality from Popup menu in Debug menu.
	Other stuff so the PyShell window can be resurrected from the Windows menu.

	* FileList.py: Get rid of PopUp menu.
	Create a simple Windows menu.  (Imperfect when Untitled windows exist.)
	Add wakeup() method: deiconify, raise, focus.

	* EditorWindow.py: Generalize menu creation.

	* Bindings.py: Add Debug and Help menu items.

	* EditorWindow.py: Added a menu bar to every window.

	* Bindings.py: Add menu configuration to the event configuration.

	* Attic/PopupMenu.py: Pass a root to the help window.

	* SearchBinding.py:
	Add parent argument to 'go to line number' dialog box.

Sat Oct 10 19:15:32 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* StackViewer.py:
	Add a label at the top showing (very basic) help for the stack viewer.
	Add a label at the bottom showing the exception info.

	* Attic/test.py, Attic/idle: Add Unix main script and test program.

	* idle.pyw, help.txt, WidgetRedirector.py, UndoDelegator.py, StackViewer.py, SearchBinding.py, Attic/README, PyShell.py, Attic/PopupMenu.py, Percolator.py, Outline.py, IOBinding.py, History.py, Attic/HelpWindow.py, FrameViewer.py, FileList.py, EditorWindow.py, Delegator.py, ColorDelegator.py, Bindings.py, AutoIndent.py, AutoExpand.py:
	Initial checking of Tk-based Python IDE.
	Features: text editor with syntax coloring and undo;
	subclassed into interactive Python shell which adds history.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Class browser.

XXX TO DO:

- reparse when source changed (maybe just a button would be OK?)
    (or recheck on window popup)
- add popup menu with more options (e.g. doc strings, base classes, imports)
- show function argument list? (have to do pattern matching on source)
- should the classes and methods lists also be in the module's menu bar?
- add base classes to class browser tree
"""

import os
import sys
import pyclbr

from idlelib import PyShell
from idlelib.WindowList import ListedToplevel
from idlelib.TreeWidget import TreeNode, TreeItem, ScrolledCanvas
from idlelib.configHandler import idleConf

file_open = None  # Method...Item and Class...Item use this.
# Normally PyShell.flist.open, but there is no PyShell.flist for htest.

class ClassBrowser:

    def __init__(self, flist, name, path, _htest=False):
        # XXX This API should change, if the file doesn't end in ".py"
        # XXX the code here is bogus!
        """
        _htest - bool, change box when location running htest.
        """
        global file_open
        if not _htest:
            file_open = PyShell.flist.open
        self.name = name
        self.file = os.path.join(path[0], self.name + ".py")
        self._htest = _htest
        self.init(flist)

    def close(self, event=None):
        self.top.destroy()
        self.node.destroy()

    def init(self, flist):
        self.flist = flist
        # reset pyclbr
        pyclbr._modules.clear()
        # create top
        self.top = top = ListedToplevel(flist.root)
        top.protocol("WM_DELETE_WINDOW", self.close)
        top.bind("<Escape>", self.close)
        if self._htest: # place dialog below parent if running htest
            top.geometry("+%d+%d" %
                (flist.root.winfo_rootx(), flist.root.winfo_rooty() + 200))
        self.settitle()
        top.focus_set()
        # create scrolled canvas
        theme = idleConf.CurrentTheme()
        background = idleConf.GetHighlight(theme, 'normal')['background']
        sc = ScrolledCanvas(top, bg=background, highlightthickness=0, takefocus=1)
        sc.frame.pack(expand=1, fill="both")
        item = self.rootnode()
        self.node = node = TreeNode(sc.canvas, None, item)
        node.update()
        node.expand()

    def settitle(self):
        self.top.wm_title("Class Browser - " + self.name)
        self.top.wm_iconname("Class Browser")

    def rootnode(self):
        return ModuleBrowserTreeItem(self.file)

class ModuleBrowserTreeItem(TreeItem):

    def __init__(self, file):
        self.file = file

    def GetText(self):
        return os.path.basename(self.file)

    def GetIconName(self):
        return "python"

    def GetSubList(self):
        sublist = []
        for name in self.listclasses():
            item = ClassBrowserTreeItem(name, self.classes, self.file)
            sublist.append(item)
        return sublist

    def OnDoubleClick(self):
        if os.path.normcase(self.file[-3:]) != ".py":
            return
        if not os.path.exists(self.file):
            return
        PyShell.flist.open(self.file)

    def IsExpandable(self):
        return os.path.normcase(self.file[-3:]) == ".py"

    def listclasses(self):
        dir, file = os.path.split(self.file)
        name, ext = os.path.splitext(file)
        if os.path.normcase(ext) != ".py":
            return []
        try:
            dict = pyclbr.readmodule_ex(name, [dir] + sys.path)
        except ImportError:
            return []
        items = []
        self.classes = {}
        for key, cl in dict.items():
            if cl.module == name:
                s = key
                if hasattr(cl, 'super') and cl.super:
                    supers = []
                    for sup in cl.super:
                        if type(sup) is type(''):
                            sname = sup
                        else:
                            sname = sup.name
                            if sup.module != cl.module:
                                sname = "%s.%s" % (sup.module, sname)
                        supers.append(sname)
                    s = s + "(%s)" % ", ".join(supers)
                items.append((cl.lineno, s))
                self.classes[s] = cl
        items.sort()
        list = []
        for item, s in items:
            list.append(s)
        return list

class ClassBrowserTreeItem(TreeItem):

    def __init__(self, name, classes, file):
        self.name = name
        self.classes = classes
        self.file = file
        try:
            self.cl = self.classes[self.name]
        except (IndexError, KeyError):
            self.cl = None
        self.isfunction = isinstance(self.cl, pyclbr.Function)

    def GetText(self):
        if self.isfunction:
            return "def " + self.name + "(...)"
        else:
            return "class " + self.name

    def GetIconName(self):
        if self.isfunction:
            return "python"
        else:
            return "folder"

    def IsExpandable(self):
        if self.cl:
            try:
                return not not self.cl.methods
            except AttributeError:
                return False

    def GetSubList(self):
        if not self.cl:
            return []
        sublist = []
        for name in self.listmethods():
            item = MethodBrowserTreeItem(name, self.cl, self.file)
            sublist.append(item)
        return sublist

    def OnDoubleClick(self):
        if not os.path.exists(self.file):
            return
        edit = file_open(self.file)
        if hasattr(self.cl, 'lineno'):
            lineno = self.cl.lineno
            edit.gotoline(lineno)

    def listmethods(self):
        if not self.cl:
            return []
        items = []
        for name, lineno in self.cl.methods.items():
            items.append((lineno, name))
        items.sort()
        list = []
        for item, name in items:
            list.append(name)
        return list

class MethodBrowserTreeItem(TreeItem):

    def __init__(self, name, cl, file):
        self.name = name
        self.cl = cl
        self.file = file

    def GetText(self):
        return "def " + self.name + "(...)"

    def GetIconName(self):
        return "python" # XXX

    def IsExpandable(self):
        return 0

    def OnDoubleClick(self):
        if not os.path.exists(self.file):
            return
        edit = file_open(self.file)
        edit.gotoline(self.cl.methods[self.name])

def _class_browser(parent): #Wrapper for htest
    try:
        file = __file__
    except NameError:
        file = sys.argv[0]
        if sys.argv[1:]:
            file = sys.argv[1]
        else:
            file = sys.argv[0]
    dir, file = os.path.split(file)
    name = os.path.splitext(file)[0]
    flist = PyShell.PyShellFileList(parent)
    global file_open
    file_open = flist.open
    ClassBrowser(flist, name, [dir], _htest=True)

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_class_browser)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """CodeContext - Extension to display the block context above the edit window

Once code has scrolled off the top of a window, it can be difficult to
determine which block you are in.  This extension implements a pane at the top
of each IDLE edit window which provides block structure hints.  These hints are
the lines which contain the block opening keywords, e.g. 'if', for the
enclosing block.  The number of hint lines is determined by the numlines
variable in the CodeContext section of config-extensions.def. Lines which do
not open blocks are not shown in the context hints pane.

"""
import tkinter
from tkinter.constants import TOP, LEFT, X, W, SUNKEN
import re
from sys import maxsize as INFINITY
from idlelib.configHandler import idleConf

BLOCKOPENERS = {"class", "def", "elif", "else", "except", "finally", "for",
                    "if", "try", "while", "with"}
UPDATEINTERVAL = 100 # millisec
FONTUPDATEINTERVAL = 1000 # millisec

getspacesfirstword =\
                   lambda s, c=re.compile(r"^(\s*)(\w*)"): c.match(s).groups()

class CodeContext:
    menudefs = [('options', [('!Code Conte_xt', '<<toggle-code-context>>')])]
    context_depth = idleConf.GetOption("extensions", "CodeContext",
                                       "numlines", type="int", default=3)
    bgcolor = idleConf.GetOption("extensions", "CodeContext",
                                 "bgcolor", type="str", default="LightGray")
    fgcolor = idleConf.GetOption("extensions", "CodeContext",
                                 "fgcolor", type="str", default="Black")
    def __init__(self, editwin):
        self.editwin = editwin
        self.text = editwin.text
        self.textfont = self.text["font"]
        self.label = None
        # self.info is a list of (line number, indent level, line text, block
        # keyword) tuples providing the block structure associated with
        # self.topvisible (the linenumber of the line displayed at the top of
        # the edit window). self.info[0] is initialized as a 'dummy' line which
        # starts the toplevel 'block' of the module.
        self.info = [(0, -1, "", False)]
        self.topvisible = 1
        visible = idleConf.GetOption("extensions", "CodeContext",
                                     "visible", type="bool", default=False)
        if visible:
            self.toggle_code_context_event()
            self.editwin.setvar('<<toggle-code-context>>', True)
        # Start two update cycles, one for context lines, one for font changes.
        self.text.after(UPDATEINTERVAL, self.timer_event)
        self.text.after(FONTUPDATEINTERVAL, self.font_timer_event)

    def toggle_code_context_event(self, event=None):
        if not self.label:
            # Calculate the border width and horizontal padding required to
            # align the context with the text in the main Text widget.
            #
            # All values are passed through getint(), since some
            # values may be pixel objects, which can't simply be added to ints.
            widgets = self.editwin.text, self.editwin.text_frame
            # Calculate the required vertical padding
            padx = 0
            for widget in widgets:
                padx += widget.tk.getint(widget.pack_info()['padx'])
                padx += widget.tk.getint(widget.cget('padx'))
            # Calculate the required border width
            border = 0
            for widget in widgets:
                border += widget.tk.getint(widget.cget('border'))
            self.label = tkinter.Label(self.editwin.top,
                                       text="\n" * (self.context_depth - 1),
                                       anchor=W, justify=LEFT,
                                       font=self.textfont,
                                       bg=self.bgcolor, fg=self.fgcolor,
                                       width=1, #don't request more than we get
                                       padx=padx, border=border,
                                       relief=SUNKEN)
            # Pack the label widget before and above the text_frame widget,
            # thus ensuring that it will appear directly above text_frame
            self.label.pack(side=TOP, fill=X, expand=False,
                            before=self.editwin.text_frame)
        else:
            self.label.destroy()
            self.label = None
        idleConf.SetOption("extensions", "CodeContext", "visible",
                           str(self.label is not None))
        idleConf.SaveUserCfgFiles()

    def get_line_info(self, linenum):
        """Get the line indent value, text, and any block start keyword

        If the line does not start a block, the keyword value is False.
        The indentation of empty lines (or comment lines) is INFINITY.

        """
        text = self.text.get("%d.0" % linenum, "%d.end" % linenum)
        spaces, firstword = getspacesfirstword(text)
        opener = firstword in BLOCKOPENERS and firstword
        if len(text) == len(spaces) or text[len(spaces)] == '#':
            indent = INFINITY
        else:
            indent = len(spaces)
        return indent, text, opener

    def get_context(self, new_topvisible, stopline=1, stopindent=0):
        """Get context lines, starting at new_topvisible and working backwards.

        Stop when stopline or stopindent is reached. Return a tuple of context
        data and the indent level at the top of the region inspected.

        """
        assert stopline > 0
        lines = []
        # The indentation level we are currently in:
        lastindent = INFINITY
        # For a line to be interesting, it must begin with a block opening
        # keyword, and have less indentation than lastindent.
        for linenum in range(new_topvisible, stopline-1, -1):
            indent, text, opener = self.get_line_info(linenum)
            if indent < lastindent:
                lastindent = indent
                if opener in ("else", "elif"):
                    # We also show the if statement
                    lastindent += 1
                if opener and linenum < new_topvisible and indent >= stopindent:
                    lines.append((linenum, indent, text, opener))
                if lastindent <= stopindent:
                    break
        lines.reverse()
        return lines, lastindent

    def update_code_context(self):
        """Update context information and lines visible in the context pane.

        """
        new_topvisible = int(self.text.index("@0,0").split('.')[0])
        if self.topvisible == new_topvisible:      # haven't scrolled
            return
        if self.topvisible < new_topvisible:       # scroll down
            lines, lastindent = self.get_context(new_topvisible,
                                                 self.topvisible)
            # retain only context info applicable to the region
            # between topvisible and new_topvisible:
            while self.info[-1][1] >= lastindent:
                del self.info[-1]
        elif self.topvisible > new_topvisible:     # scroll up
            stopindent = self.info[-1][1] + 1
            # retain only context info associated
            # with lines above new_topvisible:
            while self.info[-1][0] >= new_topvisible:
                stopindent = self.info[-1][1]
                del self.info[-1]
            lines, lastindent = self.get_context(new_topvisible,
                                                 self.info[-1][0]+1,
                                                 stopindent)
        self.info.extend(lines)
        self.topvisible = new_topvisible
        # empty lines in context pane:
        context_strings = [""] * max(0, self.context_depth - len(self.info))
        # followed by the context hint lines:
        context_strings += [x[2] for x in self.info[-self.context_depth:]]
        self.label["text"] = '\n'.join(context_strings)

    def timer_event(self):
        if self.label:
            self.update_code_context()
        self.text.after(UPDATEINTERVAL, self.timer_event)

    def font_timer_event(self):
        newtextfont = self.text["font"]
        if self.label and newtextfont != self.textfont:
            self.textfont = newtextfont
            self.label["font"] = self.textfont
        self.text.after(FONTUPDATEINTERVAL, self.font_timer_event)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           import time
import re
import keyword
import builtins
from tkinter import TkVersion
from idlelib.Delegator import Delegator
from idlelib.configHandler import idleConf

DEBUG = False

def any(name, alternates):
    "Return a named group pattern matching list of alternates."
    return "(?P<%s>" % name + "|".join(alternates) + ")"

def make_pat():
    kw = r"\b" + any("KEYWORD", keyword.kwlist) + r"\b"
    builtinlist = [str(name) for name in dir(builtins)
                                        if not name.startswith('_') and \
                                        name not in keyword.kwlist]
    # self.file = open("file") :
    # 1st 'file' colorized normal, 2nd as builtin, 3rd as string
    builtin = r"([^.'\"\\#]\b|^)" + any("BUILTIN", builtinlist) + r"\b"
    comment = any("COMMENT", [r"#[^\n]*"])
    stringprefix = r"(\br|u|ur|R|U|UR|Ur|uR|b|B|br|Br|bR|BR|rb|rB|Rb|RB)?"
    sqstring = stringprefix + r"'[^'\\\n]*(\\.[^'\\\n]*)*'?"
    dqstring = stringprefix + r'"[^"\\\n]*(\\.[^"\\\n]*)*"?'
    sq3string = stringprefix + r"'''[^'\\]*((\\.|'(?!''))[^'\\]*)*(''')?"
    dq3string = stringprefix + r'"""[^"\\]*((\\.|"(?!""))[^"\\]*)*(""")?'
    string = any("STRING", [sq3string, dq3string, sqstring, dqstring])
    return kw + "|" + builtin + "|" + comment + "|" + string +\
           "|" + any("SYNC", [r"\n"])

prog = re.compile(make_pat(), re.S)
idprog = re.compile(r"\s+(\w+)", re.S)

def color_config(text):  # Called from htest, Editor, and Turtle Demo.
    '''Set color opitons of Text widget.

    Should be called whenever ColorDelegator is called.
    '''
    # Not automatic because ColorDelegator does not know 'text'.
    theme = idleConf.CurrentTheme()
    normal_colors = idleConf.GetHighlight(theme, 'normal')
    cursor_color = idleConf.GetHighlight(theme, 'cursor', fgBg='fg')
    select_colors = idleConf.GetHighlight(theme, 'hilite')
    text.config(
        foreground=normal_colors['foreground'],
        background=normal_colors['background'],
        insertbackground=cursor_color,
        selectforeground=select_colors['foreground'],
        selectbackground=select_colors['background'],
        )
    if TkVersion >= 8.5:
        text.config(
            inactiveselectbackground=select_colors['background'])


class ColorDelegator(Delegator):

    def __init__(self):
        Delegator.__init__(self)
        self.prog = prog
        self.idprog = idprog
        self.LoadTagDefs()

    def setdelegate(self, delegate):
        if self.delegate is not None:
            self.unbind("<<toggle-auto-coloring>>")
        Delegator.setdelegate(self, delegate)
        if delegate is not None:
            self.config_colors()
            self.bind("<<toggle-auto-coloring>>", self.toggle_colorize_event)
            self.notify_range("1.0", "end")
        else:
            # No delegate - stop any colorizing
            self.stop_colorizing = True
            self.allow_colorizing = False

    def config_colors(self):
        for tag, cnf in self.tagdefs.items():
            if cnf:
                self.tag_configure(tag, **cnf)
        self.tag_raise('sel')

    def LoadTagDefs(self):
        theme = idleConf.CurrentTheme()
        self.tagdefs = {
            "COMMENT": idleConf.GetHighlight(theme, "comment"),
            "KEYWORD": idleConf.GetHighlight(theme, "keyword"),
            "BUILTIN": idleConf.GetHighlight(theme, "builtin"),
            "STRING": idleConf.GetHighlight(theme, "string"),
            "DEFINITION": idleConf.GetHighlight(theme, "definition"),
            "SYNC": {'background':None,'foreground':None},
            "TODO": {'background':None,'foreground':None},
            "ERROR": idleConf.GetHighlight(theme, "error"),
            # The following is used by ReplaceDialog:
            "hit": idleConf.GetHighlight(theme, "hit"),
            }

        if DEBUG: print('tagdefs',self.tagdefs)

    def insert(self, index, chars, tags=None):
        index = self.index(index)
        self.delegate.insert(index, chars, tags)
        self.notify_range(index, index + "+%dc" % len(chars))

    def delete(self, index1, index2=None):
        index1 = self.index(index1)
        self.delegate.delete(index1, index2)
        self.notify_range(index1)

    after_id = None
    allow_colorizing = True
    colorizing = False

    def notify_range(self, index1, index2=None):
        self.tag_add("TODO", index1, index2)
        if self.after_id:
            if DEBUG: print("colorizing already scheduled")
            return
        if self.colorizing:
            self.stop_colorizing = True
            if DEBUG: print("stop colorizing")
        if self.allow_colorizing:
            if DEBUG: print("schedule colorizing")
            self.after_id = self.after(1, self.recolorize)

    close_when_done = None # Window to be closed when done colorizing

    def close(self, close_when_done=None):
        if self.after_id:
            after_id = self.after_id
            self.after_id = None
            if DEBUG: print("cancel scheduled recolorizer")
            self.after_cancel(after_id)
        self.allow_colorizing = False
        self.stop_colorizing = True
        if close_when_done:
            if not self.colorizing:
                close_when_done.destroy()
            else:
                self.close_when_done = close_when_done

    def toggle_colorize_event(self, event):
        if self.after_id:
            after_id = self.after_id
            self.after_id = None
            if DEBUG: print("cancel scheduled recolorizer")
            self.after_cancel(after_id)
        if self.allow_colorizing and self.colorizing:
            if DEBUG: print("stop colorizing")
            self.stop_colorizing = True
        self.allow_colorizing = not self.allow_colorizing
        if self.allow_colorizing and not self.colorizing:
            self.after_id = self.after(1, self.recolorize)
        if DEBUG:
            print("auto colorizing turned",\
                  self.allow_colorizing and "on" or "off")
        return "break"

    def recolorize(self):
        self.after_id = None
        if not self.delegate:
            if DEBUG: print("no delegate")
            return
        if not self.allow_colorizing:
            if DEBUG: print("auto colorizing is off")
            return
        if self.colorizing:
            if DEBUG: print("already colorizing")
            return
        try:
            self.stop_colorizing = False
            self.colorizing = True
            if DEBUG: print("colorizing...")
            t0 = time.perf_counter()
            self.recolorize_main()
            t1 = time.perf_counter()
            if DEBUG: print("%.3f seconds" % (t1-t0))
        finally:
            self.colorizing = False
        if self.allow_colorizing and self.tag_nextrange("TODO", "1.0"):
            if DEBUG: print("reschedule colorizing")
            self.after_id = self.after(1, self.recolorize)
        if self.close_when_done:
            top = self.close_when_done
            self.close_when_done = None
            top.destroy()

    def recolorize_main(self):
        next = "1.0"
        while True:
            item = self.tag_nextrange("TODO", next)
            if not item:
                break
            head, tail = item
            self.tag_remove("SYNC", head, tail)
            item = self.tag_prevrange("SYNC", head)
            if item:
                head = item[1]
            else:
                head = "1.0"

            chars = ""
            next = head
            lines_to_get = 1
            ok = False
            while not ok:
                mark = next
                next = self.index(mark + "+%d lines linestart" %
                                         lines_to_get)
                lines_to_get = min(lines_to_get * 2, 100)
                ok = "SYNC" in self.tag_names(next + "-1c")
                line = self.get(mark, next)
                ##print head, "get", mark, next, "->", repr(line)
                if not line:
                    return
                for tag in self.tagdefs:
                    self.tag_remove(tag, mark, next)
                chars = chars + line
                m = self.prog.search(chars)
                while m:
                    for key, value in m.groupdict().items():
                        if value:
                            a, b = m.span(key)
                            self.tag_add(key,
                                         head + "+%dc" % a,
                                         head + "+%dc" % b)
                            if value in ("def", "class"):
                                m1 = self.idprog.match(chars, b)
                                if m1:
                                    a, b = m1.span(1)
                                    self.tag_add("DEFINITION",
                                                 head + "+%dc" % a,
                                                 head + "+%dc" % b)
                    m = self.prog.search(chars, m.end())
                if "SYNC" in self.tag_names(next + "-1c"):
                    head = next
                    chars = ""
                else:
                    ok = False
                if not ok:
                    # We're in an inconsistent state, and the call to
                    # update may tell us to stop.  It may also change
                    # the correct value for "next" (since this is a
                    # line.col string, not a true mark).  So leave a
                    # crumb telling the next invocation to resume here
                    # in case update tells us to leave.
                    self.tag_add("TODO", next)
                self.update()
                if self.stop_colorizing:
                    if DEBUG: print("colorizing stopped")
                    return

    def removecolors(self):
        for tag in self.tagdefs:
            self.tag_remove(tag, "1.0", "end")


def _color_delegator(parent):  # htest #
    from tkinter import Toplevel, Text
    from idlelib.Percolator import Percolator

    top = Toplevel(parent)
    top.title("Test ColorDelegator")
    top.geometry("200x100+%d+%d" % (parent.winfo_rootx() + 200,
                  parent.winfo_rooty() + 150))
    source = "if somename: x = 'abc' # comment\nprint\n"
    text = Text(top, background="white")
    text.pack(expand=1, fill="both")
    text.insert("insert", source)
    text.focus_set()

    color_config(text)
    p = Percolator(text)
    d = ColorDelegator()
    p.insertfilter(d)

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_color_delegator)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          import os
import bdb
from tkinter import *
from idlelib.WindowList import ListedToplevel
from idlelib.ScrolledList import ScrolledList
from idlelib import macosxSupport


class Idb(bdb.Bdb):

    def __init__(self, gui):
        self.gui = gui
        bdb.Bdb.__init__(self)

    def user_line(self, frame):
        if self.in_rpc_code(frame):
            self.set_step()
            return
        message = self.__frame2message(frame)
        try:
            self.gui.interaction(message, frame)
        except TclError:  # When closing debugger window with [x] in 3.x
            pass

    def user_exception(self, frame, info):
        if self.in_rpc_code(frame):
            self.set_step()
            return
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame, info)

    def in_rpc_code(self, frame):
        if frame.f_code.co_filename.count('rpc.py'):
            return True
        else:
            prev_frame = frame.f_back
            if prev_frame.f_code.co_filename.count('Debugger.py'):
                # (that test will catch both Debugger.py and RemoteDebugger.py)
                return False
            return self.in_rpc_code(prev_frame)

    def __frame2message(self, frame):
        code = frame.f_code
        filename = code.co_filename
        lineno = frame.f_lineno
        basename = os.path.basename(filename)
        message = "%s:%s" % (basename, lineno)
        if code.co_name != "?":
            message = "%s: %s()" % (message, code.co_name)
        return message


class Debugger:

    vstack = vsource = vlocals = vglobals = None

    def __init__(self, pyshell, idb=None):
        if idb is None:
            idb = Idb(self)
        self.pyshell = pyshell
        self.idb = idb
        self.frame = None
        self.make_gui()
        self.interacting = 0
        self.nesting_level = 0

    def run(self, *args):
        # Deal with the scenario where we've already got a program running
        # in the debugger and we want to start another. If that is the case,
        # our second 'run' was invoked from an event dispatched not from
        # the main event loop, but from the nested event loop in 'interaction'
        # below. So our stack looks something like this:
        #       outer main event loop
        #         run()
        #           <running program with traces>
        #             callback to debugger's interaction()
        #               nested event loop
        #                 run() for second command
        #
        # This kind of nesting of event loops causes all kinds of problems
        # (see e.g. issue #24455) especially when dealing with running as a
        # subprocess, where there's all kinds of extra stuff happening in
        # there - insert a traceback.print_stack() to check it out.
        #
        # By this point, we've already called restart_subprocess() in
        # ScriptBinding. However, we also need to unwind the stack back to
        # that outer event loop.  To accomplish this, we:
        #   - return immediately from the nested run()
        #   - abort_loop ensures the nested event loop will terminate
        #   - the debugger's interaction routine completes normally
        #   - the restart_subprocess() will have taken care of stopping
        #     the running program, which will also let the outer run complete
        #
        # That leaves us back at the outer main event loop, at which point our
        # after event can fire, and we'll come back to this routine with a
        # clean stack.
        if self.nesting_level > 0:
            self.abort_loop()
            self.root.after(100, lambda: self.run(*args))
            return
        try:
            self.interacting = 1
            return self.idb.run(*args)
        finally:
            self.interacting = 0

    def close(self, event=None):
        try:
            self.quit()
        except Exception:
            pass
        if self.interacting:
            self.top.bell()
            return
        if self.stackviewer:
            self.stackviewer.close(); self.stackviewer = None
        # Clean up pyshell if user clicked debugger control close widget.
        # (Causes a harmless extra cycle through close_debugger() if user
        # toggled debugger from pyshell Debug menu)
        self.pyshell.close_debugger()
        # Now close the debugger control window....
        self.top.destroy()

    def make_gui(self):
        pyshell = self.pyshell
        self.flist = pyshell.flist
        self.root = root = pyshell.root
        self.top = top = ListedToplevel(root)
        self.top.wm_title("Debug Control")
        self.top.wm_iconname("Debug")
        top.wm_protocol("WM_DELETE_WINDOW", self.close)
        self.top.bind("<Escape>", self.close)
        #
        self.bframe = bframe = Frame(top)
        self.bframe.pack(anchor="w")
        self.buttons = bl = []
        #
        self.bcont = b = Button(bframe, text="Go", command=self.cont)
        bl.append(b)
        self.bstep = b = Button(bframe, text="Step", command=self.step)
        bl.append(b)
        self.bnext = b = Button(bframe, text="Over", command=self.next)
        bl.append(b)
        self.bret = b = Button(bframe, text="Out", command=self.ret)
        bl.append(b)
        self.bret = b = Button(bframe, text="Quit", command=self.quit)
        bl.append(b)
        #
        for b in bl:
            b.configure(state="disabled")
            b.pack(side="left")
        #
        self.cframe = cframe = Frame(bframe)
        self.cframe.pack(side="left")
        #
        if not self.vstack:
            self.__class__.vstack = BooleanVar(top)
            self.vstack.set(1)
        self.bstack = Checkbutton(cframe,
            text="Stack", command=self.show_stack, variable=self.vstack)
        self.bstack.grid(row=0, column=0)
        if not self.vsource:
            self.__class__.vsource = BooleanVar(top)
        self.bsource = Checkbutton(cframe,
            text="Source", command=self.show_source, variable=self.vsource)
        self.bsource.grid(row=0, column=1)
        if not self.vlocals:
            self.__class__.vlocals = BooleanVar(top)
            self.vlocals.set(1)
        self.blocals = Checkbutton(cframe,
            text="Locals", command=self.show_locals, variable=self.vlocals)
        self.blocals.grid(row=1, column=0)
        if not self.vglobals:
            self.__class__.vglobals = BooleanVar(top)
        self.bglobals = Checkbutton(cframe,
            text="Globals", command=self.show_globals, variable=self.vglobals)
        self.bglobals.grid(row=1, column=1)
        #
        self.status = Label(top, anchor="w")
        self.status.pack(anchor="w")
        self.error = Label(top, anchor="w")
        self.error.pack(anchor="w", fill="x")
        self.errorbg = self.error.cget("background")
        #
        self.fstack = Frame(top, height=1)
        self.fstack.pack(expand=1, fill="both")
        self.flocals = Frame(top)
        self.flocals.pack(expand=1, fill="both")
        self.fglobals = Frame(top, height=1)
        self.fglobals.pack(expand=1, fill="both")
        #
        if self.vstack.get():
            self.show_stack()
        if self.vlocals.get():
            self.show_locals()
        if self.vglobals.get():
            self.show_globals()

    def interaction(self, message, frame, info=None):
        self.frame = frame
        self.status.configure(text=message)
        #
        if info:
            type, value, tb = info
            try:
                m1 = type.__name__
            except AttributeError:
                m1 = "%s" % str(type)
            if value is not None:
                try:
                    m1 = "%s: %s" % (m1, str(value))
                except:
                    pass
            bg = "yellow"
        else:
            m1 = ""
            tb = None
            bg = self.errorbg
        self.error.configure(text=m1, background=bg)
        #
        sv = self.stackviewer
        if sv:
            stack, i = self.idb.get_stack(self.frame, tb)
            sv.load_stack(stack, i)
        #
        self.show_variables(1)
        #
        if self.vsource.get():
            self.sync_source_line()
        #
        for b in self.buttons:
            b.configure(state="normal")
        #
        self.top.wakeup()
        # Nested main loop: Tkinter's main loop is not reentrant, so use
        # Tcl's vwait facility, which reenters the event loop until an
        # event handler sets the variable we're waiting on
        self.nesting_level += 1
        self.root.tk.call('vwait', '::idledebugwait')
        self.nesting_level -= 1
        #
        for b in self.buttons:
            b.configure(state="disabled")
        self.status.configure(text="")
        self.error.configure(text="", background=self.errorbg)
        self.frame = None

    def sync_source_line(self):
        frame = self.frame
        if not frame:
            return
        filename, lineno = self.__frame2fileline(frame)
        if filename[:1] + filename[-1:] != "<>" and os.path.exists(filename):
            self.flist.gotofileline(filename, lineno)

    def __frame2fileline(self, frame):
        code = frame.f_code
        filename = code.co_filename
        lineno = frame.f_lineno
        return filename, lineno

    def cont(self):
        self.idb.set_continue()
        self.abort_loop()

    def step(self):
        self.idb.set_step()
        self.abort_loop()

    def next(self):
        self.idb.set_next(self.frame)
        self.abort_loop()

    def ret(self):
        self.idb.set_return(self.frame)
        self.abort_loop()

    def quit(self):
        self.idb.set_quit()
        self.abort_loop()

    def abort_loop(self):
        self.root.tk.call('set', '::idledebugwait', '1')

    stackviewer = None

    def show_stack(self):
        if not self.stackviewer and self.vstack.get():
            self.stackviewer = sv = StackViewer(self.fstack, self.flist, self)
            if self.frame:
                stack, i = self.idb.get_stack(self.frame, None)
                sv.load_stack(stack, i)
        else:
            sv = self.stackviewer
            if sv and not self.vstack.get():
                self.stackviewer = None
                sv.close()
            self.fstack['height'] = 1

    def show_source(self):
        if self.vsource.get():
            self.sync_source_line()

    def show_frame(self, stackitem):
        self.frame = stackitem[0]  # lineno is stackitem[1]
        self.show_variables()

    localsviewer = None
    globalsviewer = None

    def show_locals(self):
        lv = self.localsviewer
        if self.vlocals.get():
            if not lv:
                self.localsviewer = NamespaceViewer(self.flocals, "Locals")
        else:
            if lv:
                self.localsviewer = None
                lv.close()
                self.flocals['height'] = 1
        self.show_variables()

    def show_globals(self):
        gv = self.globalsviewer
        if self.vglobals.get():
            if not gv:
                self.globalsviewer = NamespaceViewer(self.fglobals, "Globals")
        else:
            if gv:
                self.globalsviewer = None
                gv.close()
                self.fglobals['height'] = 1
        self.show_variables()

    def show_variables(self, force=0):
        lv = self.localsviewer
        gv = self.globalsviewer
        frame = self.frame
        if not frame:
            ldict = gdict = None
        else:
            ldict = frame.f_locals
            gdict = frame.f_globals
            if lv and gv and ldict is gdict:
                ldict = None
        if lv:
            lv.load_dict(ldict, force, self.pyshell.interp.rpcclt)
        if gv:
            gv.load_dict(gdict, force, self.pyshell.interp.rpcclt)

    def set_breakpoint_here(self, filename, lineno):
        self.idb.set_break(filename, lineno)

    def clear_breakpoint_here(self, filename, lineno):
        self.idb.clear_break(filename, lineno)

    def clear_file_breaks(self, filename):
        self.idb.clear_all_file_breaks(filename)

    def load_breakpoints(self):
        "Load PyShellEditorWindow breakpoints into subprocess debugger"
        for editwin in self.pyshell.flist.inversedict:
            filename = editwin.io.filename
            try:
                for lineno in editwin.breakpoints:
                    self.set_breakpoint_here(filename, lineno)
            except AttributeError:
                continue

class StackViewer(ScrolledList):

    def __init__(self, master, flist, gui):
        if macosxSupport.isAquaTk():
            # At least on with the stock AquaTk version on OSX 10.4 you'll
            # get a shaking GUI that eventually kills IDLE if the width
            # argument is specified.
            ScrolledList.__init__(self, master)
        else:
            ScrolledList.__init__(self, master, width=80)
        self.flist = flist
        self.gui = gui
        self.stack = []

    def load_stack(self, stack, index=None):
        self.stack = stack
        self.clear()
        for i in range(len(stack)):
            frame, lineno = stack[i]
            try:
                modname = frame.f_globals["__name__"]
            except:
                modname = "?"
            code = frame.f_code
            filename = code.co_filename
            funcname = code.co_name
            import linecache
            sourceline = linecache.getline(filename, lineno)
            sourceline = sourceline.strip()
            if funcname in ("?", "", None):
                item = "%s, line %d: %s" % (modname, lineno, sourceline)
            else:
                item = "%s.%s(), line %d: %s" % (modname, funcname,
                                                 lineno, sourceline)
            if i == index:
                item = "> " + item
            self.append(item)
        if index is not None:
            self.select(index)

    def popup_event(self, event):
        "override base method"
        if self.stack:
            return ScrolledList.popup_event(self, event)

    def fill_menu(self):
        "override base method"
        menu = self.menu
        menu.add_command(label="Go to source line",
                         command=self.goto_source_line)
        menu.add_command(label="Show stack frame",
                         command=self.show_stack_frame)

    def on_select(self, index):
        "override base method"
        if 0 <= index < len(self.stack):
            self.gui.show_frame(self.stack[index])

    def on_double(self, index):
        "override base method"
        self.show_source(index)

    def goto_source_line(self):
        index = self.listbox.index("active")
        self.show_source(index)

    def show_stack_frame(self):
        index = self.listbox.index("active")
        if 0 <= index < len(self.stack):
            self.gui.show_frame(self.stack[index])

    def show_source(self, index):
        if not (0 <= index < len(self.stack)):
            return
        frame, lineno = self.stack[index]
        code = frame.f_code
        filename = code.co_filename
        if os.path.isfile(filename):
            edit = self.flist.open(filename)
            if edit:
                edit.gotoline(lineno)


class NamespaceViewer:

    def __init__(self, master, title, dict=None):
        width = 0
        height = 40
        if dict:
            height = 20*len(dict) # XXX 20 == observed height of Entry widget
        self.master = master
        self.title = title
        import reprlib
        self.repr = reprlib.Repr()
        self.repr.maxstring = 60
        self.repr.maxother = 60
        self.frame = frame = Frame(master)
        self.frame.pack(expand=1, fill="both")
        self.label = Label(frame, text=title, borderwidth=2, relief="groove")
        self.label.pack(fill="x")
        self.vbar = vbar = Scrollbar(frame, name="vbar")
        vbar.pack(side="right", fill="y")
        self.canvas = canvas = Canvas(frame,
                                      height=min(300, max(40, height)),
                                      scrollregion=(0, 0, width, height))
        canvas.pack(side="left", fill="both", expand=1)
        vbar["command"] = canvas.yview
        canvas["yscrollcommand"] = vbar.set
        self.subframe = subframe = Frame(canvas)
        self.sfid = canvas.create_window(0, 0, window=subframe, anchor="nw")
        self.load_dict(dict)

    dict = -1

    def load_dict(self, dict, force=0, rpc_client=None):
        if dict is self.dict and not force:
            return
        subframe = self.subframe
        frame = self.frame
        for c in list(subframe.children.values()):
            c.destroy()
        self.dict = None
        if not dict:
            l = Label(subframe, text="None")
            l.grid(row=0, column=0)
        else:
            #names = sorted(dict)
            ###
            # Because of (temporary) limitations on the dict_keys type (not yet
            # public or pickleable), have the subprocess to send a list of
            # keys, not a dict_keys object.  sorted() will take a dict_keys
            # (no subprocess) or a list.
            #
            # There is also an obscure bug in sorted(dict) where the
            # interpreter gets into a loop requesting non-existing dict[0],
            # dict[1], dict[2], etc from the RemoteDebugger.DictProxy.
            ###
            keys_list = dict.keys()
            names = sorted(keys_list)
            ###
            row = 0
            for name in names:
                value = dict[name]
                svalue = self.repr.repr(value) # repr(value)
                # Strip extra quotes caused by calling repr on the (already)
                # repr'd value sent across the RPC interface:
                if rpc_client:
                    svalue = svalue[1:-1]
                l = Label(subframe, text=name)
                l.grid(row=row, column=0, sticky="nw")
                l = Entry(subframe, width=0, borderwidth=0)
                l.insert(0, svalue)
                l.grid(row=row, column=1, sticky="nw")
                row = row+1
        self.dict = dict
        # XXX Could we use a <Configure> callback for the following?
        subframe.update_idletasks() # Alas!
        width = subframe.winfo_reqwidth()
        height = subframe.winfo_reqheight()
        canvas = self.canvas
        self.canvas["scrollregion"] = (0, 0, width, height)
        if height > 300:
            canvas["height"] = 300
            frame.pack(expand=1)
        else:
            canvas["height"] = height
            frame.pack(expand=0)

    def close(self):
        self.frame.destroy()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          import os
from tkinter import *
import tkinter.messagebox as tkMessageBox


class FileList:

    # N.B. this import overridden in PyShellFileList.
    from idlelib.EditorWindow import EditorWindow

    def __init__(self, root):
        self.root = root
        self.dict = {}
        self.inversedict = {}
        self.vars = {} # For EditorWindow.getrawvar (shared Tcl variables)

    def open(self, filename, action=None):
        assert filename
        filename = self.canonize(filename)
        if os.path.isdir(filename):
            # This can happen when bad filename is passed on command line:
            tkMessageBox.showerror(
                "File Error",
                "%r is a directory." % (filename,),
                master=self.root)
            return None
        key = os.path.normcase(filename)
        if key in self.dict:
            edit = self.dict[key]
            edit.top.wakeup()
            return edit
        if action:
            # Don't create window, perform 'action', e.g. open in same window
            return action(filename)
        else:
            edit = self.EditorWindow(self, filename, key)
            if edit.good_load:
                return edit
            else:
                edit._close()
                return None

    def gotofileline(self, filename, lineno=None):
        edit = self.open(filename)
        if edit is not None and lineno is not None:
            edit.gotoline(lineno)

    def new(self, filename=None):
        return self.EditorWindow(self, filename)

    def close_all_callback(self, *args, **kwds):
        for edit in list(self.inversedict):
            reply = edit.close()
            if reply == "cancel":
                break
        return "break"

    def unregister_maybe_terminate(self, edit):
        try:
            key = self.inversedict[edit]
        except KeyError:
            print("Don't know this EditorWindow object.  (close)")
            return
        if key:
            del self.dict[key]
        del self.inversedict[edit]
        if not self.inversedict:
            self.root.quit()

    def filename_changed_edit(self, edit):
        edit.saved_change_hook()
        try:
            key = self.inversedict[edit]
        except KeyError:
            print("Don't know this EditorWindow object.  (rename)")
            return
        filename = edit.io.filename
        if not filename:
            if key:
                del self.dict[key]
            self.inversedict[edit] = None
            return
        filename = self.canonize(filename)
        newkey = os.path.normcase(filename)
        if newkey == key:
            return
        if newkey in self.dict:
            conflict = self.dict[newkey]
            self.inversedict[conflict] = None
            tkMessageBox.showerror(
                "Name Conflict",
                "You now have multiple edit windows open for %r" % (filename,),
                master=self.root)
        self.dict[newkey] = edit
        self.inversedict[edit] = newkey
        if key:
            try:
                del self.dict[key]
            except KeyError:
                pass

    def canonize(self, filename):
        if not os.path.isabs(filename):
            try:
                pwd = os.getcwd()
            except OSError:
                pass
            else:
                filename = os.path.join(pwd, filename)
        return os.path.normpath(filename)


def _test():
    from idlelib.EditorWindow import fixwordbreaks
    import sys
    root = Tk()
    fixwordbreaks(root)
    root.withdraw()
    flist = FileList(root)
    if sys.argv[1:]:
        for filename in sys.argv[1:]:
            flist.open(filename)
    else:
        flist.new()
    if flist.inversedict:
        root.mainloop()

if __name__ == '__main__':
    _test()
                                                                                                                                                                                                                                                                                           """Extension to format a paragraph or selection to a max width.

Does basic, standard text formatting, and also understands Python
comment blocks. Thus, for editing Python source code, this
extension is really only suitable for reformatting these comment
blocks or triple-quoted strings.

Known problems with comment reformatting:
* If there is a selection marked, and the first line of the
  selection is not complete, the block will probably not be detected
  as comments, and will have the normal "text formatting" rules
  applied.
* If a comment block has leading whitespace that mixes tabs and
  spaces, they will not be considered part of the same block.
* Fancy comments, like this bulleted list, aren't handled :-)
"""

import re
from idlelib.configHandler import idleConf

class FormatParagraph:

    menudefs = [
        ('format', [   # /s/edit/format   dscherer@cmu.edu
            ('Format Paragraph', '<<format-paragraph>>'),
         ])
    ]

    def __init__(self, editwin):
        self.editwin = editwin

    def close(self):
        self.editwin = None

    def format_paragraph_event(self, event, limit=None):
        """Formats paragraph to a max width specified in idleConf.

        If text is selected, format_paragraph_event will start breaking lines
        at the max width, starting from the beginning selection.

        If no text is selected, format_paragraph_event uses the current
        cursor location to determine the paragraph (lines of text surrounded
        by blank lines) and formats it.

        The length limit parameter is for testing with a known value.
        """
        if limit is None:
            # The default length limit is that defined by pep8
            limit = idleConf.GetOption(
                'extensions', 'FormatParagraph', 'max-width',
                type='int', default=72)
        text = self.editwin.text
        first, last = self.editwin.get_selection_indices()
        if first and last:
            data = text.get(first, last)
            comment_header = get_comment_header(data)
        else:
            first, last, comment_header, data = \
                    find_paragraph(text, text.index("insert"))
        if comment_header:
            newdata = reformat_comment(data, limit, comment_header)
        else:
            newdata = reformat_paragraph(data, limit)
        text.tag_remove("sel", "1.0", "end")

        if newdata != data:
            text.mark_set("insert", first)
            text.undo_block_start()
            text.delete(first, last)
            text.insert(first, newdata)
            text.undo_block_stop()
        else:
            text.mark_set("insert", last)
        text.see("insert")
        return "break"

def find_paragraph(text, mark):
    """Returns the start/stop indices enclosing the paragraph that mark is in.

    Also returns the comment format string, if any, and paragraph of text
    between the start/stop indices.
    """
    lineno, col = map(int, mark.split("."))
    line = text.get("%d.0" % lineno, "%d.end" % lineno)

    # Look for start of next paragraph if the index passed in is a blank line
    while text.compare("%d.0" % lineno, "<", "end") and is_all_white(line):
        lineno = lineno + 1
        line = text.get("%d.0" % lineno, "%d.end" % lineno)
    first_lineno = lineno
    comment_header = get_comment_header(line)
    comment_header_len = len(comment_header)

    # Once start line found, search for end of paragraph (a blank line)
    while get_comment_header(line)==comment_header and \
              not is_all_white(line[comment_header_len:]):
        lineno = lineno + 1
        line = text.get("%d.0" % lineno, "%d.end" % lineno)
    last = "%d.0" % lineno

    # Search back to beginning of paragraph (first blank line before)
    lineno = first_lineno - 1
    line = text.get("%d.0" % lineno, "%d.end" % lineno)
    while lineno > 0 and \
              get_comment_header(line)==comment_header and \
              not is_all_white(line[comment_header_len:]):
        lineno = lineno - 1
        line = text.get("%d.0" % lineno, "%d.end" % lineno)
    first = "%d.0" % (lineno+1)

    return first, last, comment_header, text.get(first, last)

# This should perhaps be replaced with textwrap.wrap
def reformat_paragraph(data, limit):
    """Return data reformatted to specified width (limit)."""
    lines = data.split("\n")
    i = 0
    n = len(lines)
    while i < n and is_all_white(lines[i]):
        i = i+1
    if i >= n:
        return data
    indent1 = get_indent(lines[i])
    if i+1 < n and not is_all_white(lines[i+1]):
        indent2 = get_indent(lines[i+1])
    else:
        indent2 = indent1
    new = lines[:i]
    partial = indent1
    while i < n and not is_all_white(lines[i]):
        # XXX Should take double space after period (etc.) into account
        words = re.split("(\s+)", lines[i])
        for j in range(0, len(words), 2):
            word = words[j]
            if not word:
                continue # Can happen when line ends in whitespace
            if len((partial + word).expandtabs()) > limit and \
                   partial != indent1:
                new.append(partial.rstrip())
                partial = indent2
            partial = partial + word + " "
            if j+1 < len(words) and words[j+1] != " ":
                partial = partial + " "
        i = i+1
    new.append(partial.rstrip())
    # XXX Should reformat remaining paragraphs as well
    new.extend(lines[i:])
    return "\n".join(new)

def reformat_comment(data, limit, comment_header):
    """Return data reformatted to specified width with comment header."""

    # Remove header from the comment lines
    lc = len(comment_header)
    data = "\n".join(line[lc:] for line in data.split("\n"))
    # Reformat to maxformatwidth chars or a 20 char width,
    # whichever is greater.
    format_width = max(limit - len(comment_header), 20)
    newdata = reformat_paragraph(data, format_width)
    # re-split and re-insert the comment header.
    newdata = newdata.split("\n")
    # If the block ends in a \n, we dont want the comment prefix
    # inserted after it. (Im not sure it makes sense to reformat a
    # comment block that is not made of complete lines, but whatever!)
    # Can't think of a clean solution, so we hack away
    block_suffix = ""
    if not newdata[-1]:
        block_suffix = "\n"
        newdata = newdata[:-1]
    return '\n'.join(comment_header+line for line in newdata) + block_suffix

def is_all_white(line):
    """Return True if line is empty or all whitespace."""

    return re.match(r"^\s*$", line) is not None

def get_indent(line):
    """Return the initial space or tab indent of line."""
    return re.match(r"^([ \t]*)", line).group()

def get_comment_header(line):
    """Return string with leading whitespace and '#' from line or ''.

    A null return indicates that the line is not a comment line. A non-
    null return, such as '    #', will be used to find the other lines of
    a comment block with the same  indent.
    """
    m = re.match(r"^([ \t]*#*)", line)
    if m is None: return ""
    return m.group(1)

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_formatparagraph',
            verbosity=2, exit=False)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         import os
import fnmatch
import re  # for htest
import sys
from tkinter import StringVar, BooleanVar, Checkbutton  # for GrepDialog
from tkinter import Tk, Text, Button, SEL, END  # for htest
from idlelib import SearchEngine
from idlelib.SearchDialogBase import SearchDialogBase
# Importing OutputWindow fails due to import loop
# EditorWindow -> GrepDialop -> OutputWindow -> EditorWindow

def grep(text, io=None, flist=None):
    root = text._root()
    engine = SearchEngine.get(root)
    if not hasattr(engine, "_grepdialog"):
        engine._grepdialog = GrepDialog(root, engine, flist)
    dialog = engine._grepdialog
    searchphrase = text.get("sel.first", "sel.last")
    dialog.open(text, searchphrase, io)

class GrepDialog(SearchDialogBase):

    title = "Find in Files Dialog"
    icon = "Grep"
    needwrapbutton = 0

    def __init__(self, root, engine, flist):
        SearchDialogBase.__init__(self, root, engine)
        self.flist = flist
        self.globvar = StringVar(root)
        self.recvar = BooleanVar(root)

    def open(self, text, searchphrase, io=None):
        SearchDialogBase.open(self, text, searchphrase)
        if io:
            path = io.filename or ""
        else:
            path = ""
        dir, base = os.path.split(path)
        head, tail = os.path.splitext(base)
        if not tail:
            tail = ".py"
        self.globvar.set(os.path.join(dir, "*" + tail))

    def create_entries(self):
        SearchDialogBase.create_entries(self)
        self.globent = self.make_entry("In files:", self.globvar)[0]

    def create_other_buttons(self):
        f = self.make_frame()[0]

        btn = Checkbutton(f, anchor="w",
                variable=self.recvar,
                text="Recurse down subdirectories")
        btn.pack(side="top", fill="both")
        btn.select()

    def create_command_buttons(self):
        SearchDialogBase.create_command_buttons(self)
        self.make_button("Search Files", self.default_command, 1)

    def default_command(self, event=None):
        prog = self.engine.getprog()
        if not prog:
            return
        path = self.globvar.get()
        if not path:
            self.top.bell()
            return
        from idlelib.OutputWindow import OutputWindow  # leave here!
        save = sys.stdout
        try:
            sys.stdout = OutputWindow(self.flist)
            self.grep_it(prog, path)
        finally:
            sys.stdout = save

    def grep_it(self, prog, path):
        dir, base = os.path.split(path)
        list = self.findfiles(dir, base, self.recvar.get())
        list.sort()
        self.close()
        pat = self.engine.getpat()
        print("Searching %r in %s ..." % (pat, path))
        hits = 0
        try:
            for fn in list:
                try:
                    with open(fn, errors='replace') as f:
                        for lineno, line in enumerate(f, 1):
                            if line[-1:] == '\n':
                                line = line[:-1]
                            if prog.search(line):
                                sys.stdout.write("%s: %s: %s\n" %
                                                 (fn, lineno, line))
                                hits += 1
                except OSError as msg:
                    print(msg)
            print(("Hits found: %s\n"
                  "(Hint: right-click to open locations.)"
                  % hits) if hits else "No hits.")
        except AttributeError:
            # Tk window has been closed, OutputWindow.text = None,
            # so in OW.write, OW.text.insert fails.
            pass

    def findfiles(self, dir, base, rec):
        try:
            names = os.listdir(dir or os.curdir)
        except OSError as msg:
            print(msg)
            return []
        list = []
        subdirs = []
        for name in names:
            fn = os.path.join(dir, name)
            if os.path.isdir(fn):
                subdirs.append(fn)
            else:
                if fnmatch.fnmatch(name, base):
                    list.append(fn)
        if rec:
            for subdir in subdirs:
                list.extend(self.findfiles(subdir, base, rec))
        return list

    def close(self, event=None):
        if self.top:
            self.top.grab_release()
            self.top.withdraw()


def _grep_dialog(parent):  # htest #
    from idlelib.PyShell import PyShellFileList
    root = Tk()
    root.title("Test GrepDialog")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))

    flist = PyShellFileList(root)
    text = Text(root, height=5)
    text.pack()

    def show_grep_dialog():
        text.tag_add(SEL, "1.0", END)
        grep(text, flist=flist)
        text.tag_remove(SEL, "1.0", END)

    button = Button(root, text="Show GrepDialog", command=show_grep_dialog)
    button.pack()
    root.mainloop()

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_grep', verbosity=2, exit=False)

    from idlelib.idle_test.htest import run
    run(_grep_dialog)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            IDLE History
============

This file contains the release messages for previous IDLE releases.
As you read on you go back to the dark ages of IDLE's history.


What's New in IDLEfork 0.8.1?
=============================

*Release date: 22-Jul-2001*

- New tarball released as a result of the 'revitalisation' of the IDLEfork
  project.

- This release requires python 2.1 or better. Compatibility with earlier
  versions of python (especially ancient ones like 1.5x) is no longer a
  priority in IDLEfork development.

- This release is based on a merging of the earlier IDLE fork work with current
  cvs IDLE (post IDLE version 0.8), with some minor additional coding by Kurt
  B. Kaiser and Stephen M. Gava.

- This release is basically functional but also contains some known breakages,
  particularly with running things from the shell window. Also the debugger is
  not working, but I believe this was the case with the previous IDLE fork
  release (0.7.1) as well.

- This release is being made now to mark the point at which IDLEfork is
  launching into a new stage of development.

- IDLEfork CVS will now be branched to enable further development and
  exploration of the two "execution in a remote process" patches submitted by
  David Scherer (David's is currently in IDLEfork) and GvR, while stabilisation
  and development of less heavyweight improvements (like user customisation)
  can continue on the trunk.


What's New in IDLEfork 0.7.1?
==============================

*Release date: 15-Aug-2000*

- First project tarball released.

- This was the first release of IDLE fork, which at this stage was a
  combination of IDLE 0.5 and the VPython idle fork, with additional changes
  coded by David Scherer, Peter Schneider-Kamp and Nicholas Riley.



IDLEfork 0.7.1 - 29 May 2000
-----------------------------

   David Scherer  <dscherer@cmu.edu>

- This is a modification of the CVS version of IDLE 0.5, updated as of
  2000-03-09.  It is alpha software and might be unstable.  If it breaks, you
  get to keep both pieces.

- If you have problems or suggestions, you should either contact me or post to
  the list at http://www.python.org/mailman/listinfo/idle-dev (making it clear
  that you are using this modified version of IDLE).

- Changes:

  - The ExecBinding module, a replacement for ScriptBinding, executes programs
    in a separate process, piping standard I/O through an RPC mechanism to an
    OnDemandOutputWindow in IDLE.  It supports executing unnamed programs
    (through a temporary file).  It does not yet support debugging.

  - When running programs with ExecBinding, tracebacks will be clipped to
    exclude system modules.  If, however, a system module calls back into the
    user program, that part of the traceback will be shown.

  - The OnDemandOutputWindow class has been improved.  In particular, it now
    supports a readline() function used to implement user input, and a
    scroll_clear() operation which is used to hide the output of a previous run
    by scrolling it out of the window.

  - Startup behavior has been changed.  By default IDLE starts up with just a
    blank editor window, rather than an interactive window.  Opening a file in
    such a blank window replaces the (nonexistent) contents of that window
    instead of creating another window.  Because of the need to have a
    well-known port for the ExecBinding protocol, only one copy of IDLE can be
    running.  Additional invocations use the RPC mechanism to report their
    command line arguments to the copy already running.

  - The menus have been reorganized.  In particular, the excessively large
    'edit' menu has been split up into 'edit', 'format', and 'run'.

  - 'Python Documentation' now works on Windows, if the win32api module is
    present.

  - A few key bindings have been changed: F1 now loads Python Documentation
    instead of the IDLE help; shift-TAB is now a synonym for unindent.

- New modules:

  ExecBinding.py         Executes program through loader
  loader.py              Bootstraps user program
  protocol.py            RPC protocol
  Remote.py              User-process interpreter
  spawn.py               OS-specific code to start programs

- Files modified:

  autoindent.py          ( bindings tweaked )
  bindings.py            ( menus reorganized )
  config.txt             ( execbinding enabled )
  editorwindow.py        ( new menus, fixed 'Python Documentation' )
  filelist.py            ( hook for "open in same window" )
  formatparagraph.py     ( bindings tweaked )
  idle.bat               ( removed absolute pathname )
  idle.pyw               ( weird bug due to import with same name? )
  iobinding.py           ( open in same window, EOL convention )
  keydefs.py             ( bindings tweaked )
  outputwindow.py        ( readline, scroll_clear, etc )
  pyshell.py             ( changed startup behavior )
  readme.txt             ( <Recursion on file with id=1234567> )



IDLE 0.5 - February 2000 - Release Notes
----------------------------------------

This is an early release of IDLE, my own attempt at a Tkinter-based
IDE for Python.

(For a more detailed change log, see the file ChangeLog.)

FEATURES

IDLE has the following features:

- coded in 100% pure Python, using the Tkinter GUI toolkit (i.e. Tcl/Tk)

- cross-platform: works on Windows and Unix (on the Mac, there are
currently problems with Tcl/Tk)

- multi-window text editor with multiple undo, Python colorizing
and many other features, e.g. smart indent and call tips

- Python shell window (a.k.a. interactive interpreter)

- debugger (not complete, but you can set breakpoints, view  and step)

USAGE

The main program is in the file "idle.py"; on Unix, you should be able
to run it by typing "./idle.py" to your shell.  On Windows, you can
run it by double-clicking it; you can use idle.pyw to avoid popping up
a DOS console.  If you want to pass command line arguments on Windows,
use the batch file idle.bat.

Command line arguments: files passed on the command line are executed,
not opened for editing, unless you give the -e command line option.
Try "./idle.py -h" to see other command line options.

IDLE requires Python 1.5.2, so it is currently only usable with a
Python 1.5.2 distribution.  (An older version of IDLE is distributed
with Python 1.5.2; you can drop this version on top of it.)

COPYRIGHT

IDLE is covered by the standard Python copyright notice
(http://www.python.org/doc/Copyright.html).


New in IDLE 0.5 (2/15/2000)
---------------------------

Tons of stuff, much of it contributed by Tim Peters and Mark Hammond:

- Status bar, displaying current line/column (Moshe Zadka).

- Better stack viewer, using tree widget.  (XXX Only used by Stack
Viewer menu, not by the debugger.)

- Format paragraph now recognizes Python block comments and reformats
them correctly (MH)

- New version of pyclbr.py parses top-level functions and understands
much more of Python's syntax; this is reflected in the class and path
browsers (TP)

- Much better auto-indent; knows how to indent the insides of
multi-line statements (TP)

- Call tip window pops up when you type the name of a known function
followed by an open parenthesis.  Hit ESC or click elsewhere in the
window to close the tip window (MH)

- Comment out region now inserts ## to make it stand out more (TP)

- New path and class browsers based on a tree widget that looks
familiar to Windows users

- Reworked script running commands to be more intuitive: I/O now
always goes to the *Python Shell* window, and raw_input() works
correctly.  You use F5 to import/reload a module: this adds the module
name to the __main__ namespace.  You use Control-F5 to run a script:
this runs the script *in* the __main__ namespace.  The latter also
sets sys.argv[] to the script name


New in IDLE 0.4 (4/7/99)
------------------------

Most important change: a new menu entry "File -> Path browser", shows
a 4-column hierarchical browser which lets you browse sys.path,
directories, modules, and classes.  Yes, it's a superset of the Class
browser menu entry.  There's also a new internal module,
MultiScrolledLists.py, which provides the framework for this dialog.


New in IDLE 0.3 (2/17/99)
-------------------------

Most important changes:

- Enabled support for running a module, with or without the debugger.
Output goes to a new window.  Pressing F5 in a module is effectively a
reload of that module; Control-F5 loads it under the debugger.

- Re-enable tearing off the Windows menu, and make a torn-off Windows
menu update itself whenever a window is opened or closed.

- Menu items can now be have a checkbox (when the menu label starts
with "!"); use this for the Debugger and "Auto-open stack viewer"
(was: JIT stack viewer) menu items.

- Added a Quit button to the Debugger API.

- The current directory is explicitly inserted into sys.path.

- Fix the debugger (when using Python 1.5.2b2) to use canonical
filenames for breakpoints, so these actually work.  (There's still a
lot of work to be done to the management of breakpoints in the
debugger though.)

- Closing a window that is still colorizing now actually works.

- Allow dragging of the separator between the two list boxes in the
class browser.

- Bind ESC to "close window" of the debugger, stack viewer and class
browser.  It removes the selection highlighting in regular text
windows.  (These are standard Windows conventions.)


New in IDLE 0.2 (1/8/99)
------------------------

Lots of changes; here are the highlights:

General:

- You can now write and configure your own IDLE extension modules; see
extend.txt.


File menu:

The command to open the Python shell window is now in the File menu.


Edit menu:

New Find dialog with more options; replace dialog; find in files dialog.

Commands to tabify or untabify a region.

Command to format a paragraph.


Debug menu:

JIT (Just-In-Time) stack viewer toggle -- if set, the stack viewer
automaticall pops up when you get a traceback.

Windows menu:

Zoom height -- make the window full height.


Help menu:

The help text now show up in a regular window so you can search and
even edit it if you like.



IDLE 0.1 was distributed with the Python 1.5.2b1 release on 12/22/98.

======================================================================
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "Implement Idle Shell history mechanism with History class"

from idlelib.configHandler import idleConf

class History:
    ''' Implement Idle Shell history mechanism.

    store - Store source statement (called from PyShell.resetoutput).
    fetch - Fetch stored statement matching prefix already entered.
    history_next - Bound to <<history-next>> event (default Alt-N).
    history_prev - Bound to <<history-prev>> event (default Alt-P).
    '''
    def __init__(self, text):
        '''Initialize data attributes and bind event methods.

        .text - Idle wrapper of tk Text widget, with .bell().
        .history - source statements, possibly with multiple lines.
        .prefix - source already entered at prompt; filters history list.
        .pointer - index into history.
        .cyclic - wrap around history list (or not).
        '''
        self.text = text
        self.history = []
        self.prefix = None
        self.pointer = None
        self.cyclic = idleConf.GetOption("main", "History", "cyclic", 1, "bool")
        text.bind("<<history-previous>>", self.history_prev)
        text.bind("<<history-next>>", self.history_next)

    def history_next(self, event):
        "Fetch later statement; start with ealiest if cyclic."
        self.fetch(reverse=False)
        return "break"

    def history_prev(self, event):
        "Fetch earlier statement; start with most recent."
        self.fetch(reverse=True)
        return "break"

    def fetch(self, reverse):
        '''Fetch statememt and replace current line in text widget.

        Set prefix and pointer as needed for successive fetches.
        Reset them to None, None when returning to the start line.
        Sound bell when return to start line or cannot leave a line
        because cyclic is False.
        '''
        nhist = len(self.history)
        pointer = self.pointer
        prefix = self.prefix
        if pointer is not None and prefix is not None:
            if self.text.compare("insert", "!=", "end-1c") or \
                    self.text.get("iomark", "end-1c") != self.history[pointer]:
                pointer = prefix = None
                self.text.mark_set("insert", "end-1c")  # != after cursor move
        if pointer is None or prefix is None:
            prefix = self.text.get("iomark", "end-1c")
            if reverse:
                pointer = nhist  # will be decremented
            else:
                if self.cyclic:
                    pointer = -1  # will be incremented
                else:  # abort history_next
                    self.text.bell()
                    return
        nprefix = len(prefix)
        while 1:
            pointer += -1 if reverse else 1
            if pointer < 0 or pointer >= nhist:
                self.text.bell()
                if not self.cyclic and pointer < 0:  # abort history_prev
                    return
                else:
                    if self.text.get("iomark", "end-1c") != prefix:
                        self.text.delete("iomark", "end-1c")
                        self.text.insert("iomark", prefix)
                    pointer = prefix = None
                break
            item = self.history[pointer]
            if item[:nprefix] == prefix and len(item) > nprefix:
                self.text.delete("iomark", "end-1c")
                self.text.insert("iomark", item)
                break
        self.text.see("insert")
        self.text.tag_remove("sel", "1.0", "end")
        self.pointer = pointer
        self.prefix = prefix

    def store(self, source):
        "Store Shell input statement into history list."
        source = source.strip()
        if len(source) > 2:
            # avoid duplicates
            try:
                self.history.remove(source)
            except ValueError:
                pass
            self.history.append(source)
        self.pointer = None
        self.prefix = None

if __name__ == "__main__":
    from unittest import main
    main('idlelib.idle_test.test_idlehistory', verbosity=2, exit=False)
                                            """Provide advanced parsing abilities for ParenMatch and other extensions.

HyperParser uses PyParser.  PyParser mostly gives information on the
proper indentation of code.  HyperParser gives additional information on
the structure of code.
"""

import string
from keyword import iskeyword
from idlelib import PyParse


# all ASCII chars that may be in an identifier
_ASCII_ID_CHARS = frozenset(string.ascii_letters + string.digits + "_")
# all ASCII chars that may be the first char of an identifier
_ASCII_ID_FIRST_CHARS = frozenset(string.ascii_letters + "_")

# lookup table for whether 7-bit ASCII chars are valid in a Python identifier
_IS_ASCII_ID_CHAR = [(chr(x) in _ASCII_ID_CHARS) for x in range(128)]
# lookup table for whether 7-bit ASCII chars are valid as the first
# char in a Python identifier
_IS_ASCII_ID_FIRST_CHAR = \
    [(chr(x) in _ASCII_ID_FIRST_CHARS) for x in range(128)]


class HyperParser:
    def __init__(self, editwin, index):
        "To initialize, analyze the surroundings of the given index."

        self.editwin = editwin
        self.text = text = editwin.text

        parser = PyParse.Parser(editwin.indentwidth, editwin.tabwidth)

        def index2line(index):
            return int(float(index))
        lno = index2line(text.index(index))

        if not editwin.context_use_ps1:
            for context in editwin.num_context_lines:
                startat = max(lno - context, 1)
                startatindex = repr(startat) + ".0"
                stopatindex = "%d.end" % lno
                # We add the newline because PyParse requires a newline
                # at end. We add a space so that index won't be at end
                # of line, so that its status will be the same as the
                # char before it, if should.
                parser.set_str(text.get(startatindex, stopatindex)+' \n')
                bod = parser.find_good_parse_start(
                          editwin._build_char_in_string_func(startatindex))
                if bod is not None or startat == 1:
                    break
            parser.set_lo(bod or 0)
        else:
            r = text.tag_prevrange("console", index)
            if r:
                startatindex = r[1]
            else:
                startatindex = "1.0"
            stopatindex = "%d.end" % lno
            # We add the newline because PyParse requires it. We add a
            # space so that index won't be at end of line, so that its
            # status will be the same as the char before it, if should.
            parser.set_str(text.get(startatindex, stopatindex)+' \n')
            parser.set_lo(0)

        # We want what the parser has, minus the last newline and space.
        self.rawtext = parser.str[:-2]
        # Parser.str apparently preserves the statement we are in, so
        # that stopatindex can be used to synchronize the string with
        # the text box indices.
        self.stopatindex = stopatindex
        self.bracketing = parser.get_last_stmt_bracketing()
        # find which pairs of bracketing are openers. These always
        # correspond to a character of rawtext.
        self.isopener = [i>0 and self.bracketing[i][1] >
                         self.bracketing[i-1][1]
                         for i in range(len(self.bracketing))]

        self.set_index(index)

    def set_index(self, index):
        """Set the index to which the functions relate.

        The index must be in the same statement.
        """
        indexinrawtext = (len(self.rawtext) -
                          len(self.text.get(index, self.stopatindex)))
        if indexinrawtext < 0:
            raise ValueError("Index %s precedes the analyzed statement"
                             % index)
        self.indexinrawtext = indexinrawtext
        # find the rightmost bracket to which index belongs
        self.indexbracket = 0
        while (self.indexbracket < len(self.bracketing)-1 and
               self.bracketing[self.indexbracket+1][0] < self.indexinrawtext):
            self.indexbracket += 1
        if (self.indexbracket < len(self.bracketing)-1 and
            self.bracketing[self.indexbracket+1][0] == self.indexinrawtext and
           not self.isopener[self.indexbracket+1]):
            self.indexbracket += 1

    def is_in_string(self):
        """Is the index given to the HyperParser in a string?"""
        # The bracket to which we belong should be an opener.
        # If it's an opener, it has to have a character.
        return (self.isopener[self.indexbracket] and
                self.rawtext[self.bracketing[self.indexbracket][0]]
                in ('"', "'"))

    def is_in_code(self):
        """Is the index given to the HyperParser in normal code?"""
        return (not self.isopener[self.indexbracket] or
                self.rawtext[self.bracketing[self.indexbracket][0]]
                not in ('#', '"', "'"))

    def get_surrounding_brackets(self, openers='([{', mustclose=False):
        """Return bracket indexes or None.

        If the index given to the HyperParser is surrounded by a
        bracket defined in openers (or at least has one before it),
        return the indices of the opening bracket and the closing
        bracket (or the end of line, whichever comes first).

        If it is not surrounded by brackets, or the end of line comes
        before the closing bracket and mustclose is True, returns None.
        """

        bracketinglevel = self.bracketing[self.indexbracket][1]
        before = self.indexbracket
        while (not self.isopener[before] or
              self.rawtext[self.bracketing[before][0]] not in openers or
              self.bracketing[before][1] > bracketinglevel):
            before -= 1
            if before < 0:
                return None
            bracketinglevel = min(bracketinglevel, self.bracketing[before][1])
        after = self.indexbracket + 1
        while (after < len(self.bracketing) and
              self.bracketing[after][1] >= bracketinglevel):
            after += 1

        beforeindex = self.text.index("%s-%dc" %
            (self.stopatindex, len(self.rawtext)-self.bracketing[before][0]))
        if (after >= len(self.bracketing) or
           self.bracketing[after][0] > len(self.rawtext)):
            if mustclose:
                return None
            afterindex = self.stopatindex
        else:
            # We are after a real char, so it is a ')' and we give the
            # index before it.
            afterindex = self.text.index(
                "%s-%dc" % (self.stopatindex,
                 len(self.rawtext)-(self.bracketing[after][0]-1)))

        return beforeindex, afterindex

    # the set of built-in identifiers which are also keywords,
    # i.e. keyword.iskeyword() returns True for them
    _ID_KEYWORDS = frozenset({"True", "False", "None"})

    @classmethod
    def _eat_identifier(cls, str, limit, pos):
        """Given a string and pos, return the number of chars in the
        identifier which ends at pos, or 0 if there is no such one.

        This ignores non-identifier eywords are not identifiers.
        """
        is_ascii_id_char = _IS_ASCII_ID_CHAR

        # Start at the end (pos) and work backwards.
        i = pos

        # Go backwards as long as the characters are valid ASCII
        # identifier characters. This is an optimization, since it
        # is faster in the common case where most of the characters
        # are ASCII.
        while i > limit and (
                ord(str[i - 1]) < 128 and
                is_ascii_id_char[ord(str[i - 1])]
        ):
            i -= 1

        # If the above loop ended due to reaching a non-ASCII
        # character, continue going backwards using the most generic
        # test for whether a string contains only valid identifier
        # characters.
        if i > limit and ord(str[i - 1]) >= 128:
            while i - 4 >= limit and ('a' + str[i - 4:pos]).isidentifier():
                i -= 4
            if i - 2 >= limit and ('a' + str[i - 2:pos]).isidentifier():
                i -= 2
            if i - 1 >= limit and ('a' + str[i - 1:pos]).isidentifier():
                i -= 1

            # The identifier candidate starts here. If it isn't a valid
            # identifier, don't eat anything. At this point that is only
            # possible if the first character isn't a valid first
            # character for an identifier.
            if not str[i:pos].isidentifier():
                return 0
        elif i < pos:
            # All characters in str[i:pos] are valid ASCII identifier
            # characters, so it is enough to check that the first is
            # valid as the first character of an identifier.
            if not _IS_ASCII_ID_FIRST_CHAR[ord(str[i])]:
                return 0

        # All keywords are valid identifiers, but should not be
        # considered identifiers here, except for True, False and None.
        if i < pos and (
                iskeyword(str[i:pos]) and
                str[i:pos] not in cls._ID_KEYWORDS
        ):
            return 0

        return pos - i

    # This string includes all chars that may be in a white space
    _whitespace_chars = " \t\n\\"

    def get_expression(self):
        """Return a string with the Python expression which ends at the
        given index, which is empty if there is no real one.
        """
        if not self.is_in_code():
            raise ValueError("get_expression should only be called"
                             "if index is inside a code.")

        rawtext = self.rawtext
        bracketing = self.bracketing

        brck_index = self.indexbracket
        brck_limit = bracketing[brck_index][0]
        pos = self.indexinrawtext

        last_identifier_pos = pos
        postdot_phase = True

        while 1:
            # Eat whitespaces, comments, and if postdot_phase is False - a dot
            while 1:
                if pos>brck_limit and rawtext[pos-1] in self._whitespace_chars:
                    # Eat a whitespace
                    pos -= 1
                elif (not postdot_phase and
                      pos > brck_limit and rawtext[pos-1] == '.'):
                    # Eat a dot
                    pos -= 1
                    postdot_phase = True
                # The next line will fail if we are *inside* a comment,
                # but we shouldn't be.
                elif (pos == brck_limit and brck_index > 0 and
                      rawtext[bracketing[brck_index-1][0]] == '#'):
                    # Eat a comment
                    brck_index -= 2
                    brck_limit = bracketing[brck_index][0]
                    pos = bracketing[brck_index+1][0]
                else:
                    # If we didn't eat anything, quit.
                    break

            if not postdot_phase:
                # We didn't find a dot, so the expression end at the
                # last identifier pos.
                break

            ret = self._eat_identifier(rawtext, brck_limit, pos)
            if ret:
                # There is an identifier to eat
                pos = pos - ret
                last_identifier_pos = pos
                # Now, to continue the search, we must find a dot.
                postdot_phase = False
                # (the loop continues now)

            elif pos == brck_limit:
                # We are at a bracketing limit. If it is a closing
                # bracket, eat the bracket, otherwise, stop the search.
                level = bracketing[brck_index][1]
                while brck_index > 0 and bracketing[brck_index-1][1] > level:
                    brck_index -= 1
                if bracketing[brck_index][0] == brck_limit:
                    # We were not at the end of a closing bracket
                    break
                pos = bracketing[brck_index][0]
                brck_index -= 1
                brck_limit = bracketing[brck_index][0]
                last_identifier_pos = pos
                if rawtext[pos] in "([":
                    # [] and () may be used after an identifier, so we
                    # continue. postdot_phase is True, so we don't allow a dot.
                    pass
                else:
                    # We can't continue after other types of brackets
                    if rawtext[pos] in "'\"":
                        # Scan a string prefix
                        while pos > 0 and rawtext[pos - 1] in "rRbBuU":
                            pos -= 1
                        last_identifier_pos = pos
                    break

            else:
                # We've found an operator or something.
                break

        return rawtext[last_identifier_pos:self.indexinrawtext]


if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_hyperparser', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   import importlib
import importlib.abc
import importlib.util
import os
import platform
import re
import string
import sys
from tkinter import *
import tkinter.simpledialog as tkSimpleDialog
import tkinter.messagebox as tkMessageBox
import traceback
import webbrowser

from idlelib.MultiCall import MultiCallCreator
from idlelib import WindowList
from idlelib import SearchDialog
from idlelib import GrepDialog
from idlelib import ReplaceDialog
from idlelib import PyParse
from idlelib.configHandler import idleConf
from idlelib import aboutDialog, textView, configDialog
from idlelib import macosxSupport
from idlelib import help

# The default tab setting for a Text widget, in average-width characters.
TK_TABWIDTH_DEFAULT = 8

_py_version = ' (%s)' % platform.python_version()

def _sphinx_version():
    "Format sys.version_info to produce the Sphinx version string used to install the chm docs"
    major, minor, micro, level, serial = sys.version_info
    release = '%s%s' % (major, minor)
    release += '%s' % (micro,)
    if level == 'candidate':
        release += 'rc%s' % (serial,)
    elif level != 'final':
        release += '%s%s' % (level[0], serial)
    return release


class HelpDialog(object):

    def __init__(self):
        self.parent = None      # parent of help window
        self.dlg = None         # the help window iteself

    def display(self, parent, near=None):
        """ Display the help dialog.

            parent - parent widget for the help window

            near - a Toplevel widget (e.g. EditorWindow or PyShell)
                   to use as a reference for placing the help window
        """
        import warnings as w
        w.warn("EditorWindow.HelpDialog is no longer used by Idle.\n"
               "It will be removed in 3.6 or later.\n"
               "It has been replaced by private help.HelpWindow\n",
               DeprecationWarning, stacklevel=2)
        if self.dlg is None:
            self.show_dialog(parent)
        if near:
            self.nearwindow(near)

    def show_dialog(self, parent):
        self.parent = parent
        fn=os.path.join(os.path.abspath(os.path.dirname(__file__)),'help.txt')
        self.dlg = dlg = textView.view_file(parent,'Help',fn, modal=False)
        dlg.bind('<Destroy>', self.destroy, '+')

    def nearwindow(self, near):
        # Place the help dialog near the window specified by parent.
        # Note - this may not reposition the window in Metacity
        #  if "/apps/metacity/general/disable_workarounds" is enabled
        dlg = self.dlg
        geom = (near.winfo_rootx() + 10, near.winfo_rooty() + 10)
        dlg.withdraw()
        dlg.geometry("=+%d+%d" % geom)
        dlg.deiconify()
        dlg.lift()

    def destroy(self, ev=None):
        self.dlg = None
        self.parent = None

helpDialog = HelpDialog()  # singleton instance, no longer used


class EditorWindow(object):
    from idlelib.Percolator import Percolator
    from idlelib.ColorDelegator import ColorDelegator, color_config
    from idlelib.UndoDelegator import UndoDelegator
    from idlelib.IOBinding import IOBinding, filesystemencoding, encoding
    from idlelib import Bindings
    from tkinter import Toplevel
    from idlelib.MultiStatusBar import MultiStatusBar

    help_url = None

    def __init__(self, flist=None, filename=None, key=None, root=None):
        if EditorWindow.help_url is None:
            dochome =  os.path.join(sys.base_prefix, 'Doc', 'index.html')
            if sys.platform.count('linux'):
                # look for html docs in a couple of standard places
                pyver = 'python-docs-' + '%s.%s.%s' % sys.version_info[:3]
                if os.path.isdir('/var/www/html/python/'):  # "python2" rpm
                    dochome = '/var/www/html/python/index.html'
                else:
                    basepath = '/usr/share/doc/'  # standard location
                    dochome = os.path.join(basepath, pyver,
                                           'Doc', 'index.html')
            elif sys.platform[:3] == 'win':
                chmfile = os.path.join(sys.base_prefix, 'Doc',
                                       'Python%s.chm' % _sphinx_version())
                if os.path.isfile(chmfile):
                    dochome = chmfile
            elif sys.platform == 'darwin':
                # documentation may be stored inside a python framework
                dochome = os.path.join(sys.base_prefix,
                        'Resources/English.lproj/Documentation/index.html')
            dochome = os.path.normpath(dochome)
            if os.path.isfile(dochome):
                EditorWindow.help_url = dochome
                if sys.platform == 'darwin':
                    # Safari requires real file:-URLs
                    EditorWindow.help_url = 'file://' + EditorWindow.help_url
            else:
                EditorWindow.help_url = "https://docs.python.org/%d.%d/" % sys.version_info[:2]
        self.flist = flist
        root = root or flist.root
        self.root = root
        try:
            sys.ps1
        except AttributeError:
            sys.ps1 = '>>> '
        self.menubar = Menu(root)
        self.top = top = WindowList.ListedToplevel(root, menu=self.menubar)
        if flist:
            self.tkinter_vars = flist.vars
            #self.top.instance_dict makes flist.inversedict available to
            #configDialog.py so it can access all EditorWindow instances
            self.top.instance_dict = flist.inversedict
        else:
            self.tkinter_vars = {}  # keys: Tkinter event names
                                    # values: Tkinter variable instances
            self.top.instance_dict = {}
        self.recent_files_path = os.path.join(idleConf.GetUserCfgDir(),
                'recent-files.lst')
        self.text_frame = text_frame = Frame(top)
        self.vbar = vbar = Scrollbar(text_frame, name='vbar')
        self.width = idleConf.GetOption('main', 'EditorWindow',
                                        'width', type='int')
        text_options = {
                'name': 'text',
                'padx': 5,
                'wrap': 'none',
                'highlightthickness': 0,
                'width': self.width,
                'height': idleConf.GetOption('main', 'EditorWindow',
                                             'height', type='int')}
        if TkVersion >= 8.5:
            # Starting with tk 8.5 we have to set the new tabstyle option
            # to 'wordprocessor' to achieve the same display of tabs as in
            # older tk versions.
            text_options['tabstyle'] = 'wordprocessor'
        self.text = text = MultiCallCreator(Text)(text_frame, **text_options)
        self.top.focused_widget = self.text

        self.createmenubar()
        self.apply_bindings()

        self.top.protocol("WM_DELETE_WINDOW", self.close)
        self.top.bind("<<close-window>>", self.close_event)
        if macosxSupport.isAquaTk():
            # Command-W on editorwindows doesn't work without this.
            text.bind('<<close-window>>', self.close_event)
            # Some OS X systems have only one mouse button, so use
            # control-click for popup context menus there. For two
            # buttons, AquaTk defines <2> as the right button, not <3>.
            text.bind("<Control-Button-1>",self.right_menu_event)
            text.bind("<2>", self.right_menu_event)
        else:
            # Elsewhere, use right-click for popup menus.
            text.bind("<3>",self.right_menu_event)
        text.bind("<<cut>>", self.cut)
        text.bind("<<copy>>", self.copy)
        text.bind("<<paste>>", self.paste)
        text.bind("<<center-insert>>", self.center_insert_event)
        text.bind("<<help>>", self.help_dialog)
        text.bind("<<python-docs>>", self.python_docs)
        text.bind("<<about-idle>>", self.about_dialog)
        text.bind("<<open-config-dialog>>", self.config_dialog)
        text.bind("<<open-module>>", self.open_module)
        text.bind("<<do-nothing>>", lambda event: "break")
        text.bind("<<select-all>>", self.select_all)
        text.bind("<<remove-selection>>", self.remove_selection)
        text.bind("<<find>>", self.find_event)
        text.bind("<<find-again>>", self.find_again_event)
        text.bind("<<find-in-files>>", self.find_in_files_event)
        text.bind("<<find-selection>>", self.find_selection_event)
        text.bind("<<replace>>", self.replace_event)
        text.bind("<<goto-line>>", self.goto_line_event)
        text.bind("<<smart-backspace>>",self.smart_backspace_event)
        text.bind("<<newline-and-indent>>",self.newline_and_indent_event)
        text.bind("<<smart-indent>>",self.smart_indent_event)
        text.bind("<<indent-region>>",self.indent_region_event)
        text.bind("<<dedent-region>>",self.dedent_region_event)
        text.bind("<<comment-region>>",self.comment_region_event)
        text.bind("<<uncomment-region>>",self.uncomment_region_event)
        text.bind("<<tabify-region>>",self.tabify_region_event)
        text.bind("<<untabify-region>>",self.untabify_region_event)
        text.bind("<<toggle-tabs>>",self.toggle_tabs_event)
        text.bind("<<change-indentwidth>>",self.change_indentwidth_event)
        text.bind("<Left>", self.move_at_edge_if_selection(0))
        text.bind("<Right>", self.move_at_edge_if_selection(1))
        text.bind("<<del-word-left>>", self.del_word_left)
        text.bind("<<del-word-right>>", self.del_word_right)
        text.bind("<<beginning-of-line>>", self.home_callback)

        if flist:
            flist.inversedict[self] = key
            if key:
                flist.dict[key] = self
            text.bind("<<open-new-window>>", self.new_callback)
            text.bind("<<close-all-windows>>", self.flist.close_all_callback)
            text.bind("<<open-class-browser>>", self.open_class_browser)
            text.bind("<<open-path-browser>>", self.open_path_browser)
            text.bind("<<open-turtle-demo>>", self.open_turtle_demo)

        self.set_status_bar()
        vbar['command'] = text.yview
        vbar.pack(side=RIGHT, fill=Y)
        text['yscrollcommand'] = vbar.set
        text['font'] = idleConf.GetFont(self.root, 'main', 'EditorWindow')
        text_frame.pack(side=LEFT, fill=BOTH, expand=1)
        text.pack(side=TOP, fill=BOTH, expand=1)
        text.focus_set()

        # usetabs true  -> literal tab characters are used by indent and
        #                  dedent cmds, possibly mixed with spaces if
        #                  indentwidth is not a multiple of tabwidth,
        #                  which will cause Tabnanny to nag!
        #         false -> tab characters are converted to spaces by indent
        #                  and dedent cmds, and ditto TAB keystrokes
        # Although use-spaces=0 can be configured manually in config-main.def,
        # configuration of tabs v. spaces is not supported in the configuration
        # dialog.  IDLE promotes the preferred Python indentation: use spaces!
        usespaces = idleConf.GetOption('main', 'Indent',
                                       'use-spaces', type='bool')
        self.usetabs = not usespaces

        # tabwidth is the display width of a literal tab character.
        # CAUTION:  telling Tk to use anything other than its default
        # tab setting causes it to use an entirely different tabbing algorithm,
        # treating tab stops as fixed distances from the left margin.
        # Nobody expects this, so for now tabwidth should never be changed.
        self.tabwidth = 8    # must remain 8 until Tk is fixed.

        # indentwidth is the number of screen characters per indent level.
        # The recommended Python indentation is four spaces.
        self.indentwidth = self.tabwidth
        self.set_notabs_indentwidth()

        # If context_use_ps1 is true, parsing searches back for a ps1 line;
        # else searches for a popular (if, def, ...) Python stmt.
        self.context_use_ps1 = False

        # When searching backwards for a reliable place to begin parsing,
        # first start num_context_lines[0] lines back, then
        # num_context_lines[1] lines back if that didn't work, and so on.
        # The last value should be huge (larger than the # of lines in a
        # conceivable file).
        # Making the initial values larger slows things down more often.
        self.num_context_lines = 50, 500, 5000000
        self.per = per = self.Percolator(text)
        self.undo = undo = self.UndoDelegator()
        per.insertfilter(undo)
        text.undo_block_start = undo.undo_block_start
        text.undo_block_stop = undo.undo_block_stop
        undo.set_saved_change_hook(self.saved_change_hook)
        # IOBinding implements file I/O and printing functionality
        self.io = io = self.IOBinding(self)
        io.set_filename_change_hook(self.filename_change_hook)
        self.good_load = False
        self.set_indentation_params(False)
        self.color = None # initialized below in self.ResetColorizer
        if filename:
            if os.path.exists(filename) and not os.path.isdir(filename):
                if io.loadfile(filename):
                    self.good_load = True
                    is_py_src = self.ispythonsource(filename)
                    self.set_indentation_params(is_py_src)
            else:
                io.set_filename(filename)
                self.good_load = True

        self.ResetColorizer()
        self.saved_change_hook()
        self.update_recent_files_list()
        self.load_extensions()
        menu = self.menudict.get('windows')
        if menu:
            end = menu.index("end")
            if end is None:
                end = -1
            if end >= 0:
                menu.add_separator()
                end = end + 1
            self.wmenu_end = end
            WindowList.register_callback(self.postwindowsmenu)

        # Some abstractions so IDLE extensions are cross-IDE
        self.askyesno = tkMessageBox.askyesno
        self.askinteger = tkSimpleDialog.askinteger
        self.showerror = tkMessageBox.showerror

    def _filename_to_unicode(self, filename):
        """Return filename as BMP unicode so diplayable in Tk."""
        # Decode bytes to unicode.
        if isinstance(filename, bytes):
            try:
                filename = filename.decode(self.filesystemencoding)
            except UnicodeDecodeError:
                try:
                    filename = filename.decode(self.encoding)
                except UnicodeDecodeError:
                    # byte-to-byte conversion
                    filename = filename.decode('iso8859-1')
        # Replace non-BMP char with diamond questionmark.
        return re.sub('[\U00010000-\U0010FFFF]', '\ufffd', filename)

    def new_callback(self, event):
        dirname, basename = self.io.defaultfilename()
        self.flist.new(dirname)
        return "break"

    def home_callback(self, event):
        if (event.state & 4) != 0 and event.keysym == "Home":
            # state&4==Control. If <Control-Home>, use the Tk binding.
            return
        if self.text.index("iomark") and \
           self.text.compare("iomark", "<=", "insert lineend") and \
           self.text.compare("insert linestart", "<=", "iomark"):
            # In Shell on input line, go to just after prompt
            insertpt = int(self.text.index("iomark").split(".")[1])
        else:
            line = self.text.get("insert linestart", "insert lineend")
            for insertpt in range(len(line)):
                if line[insertpt] not in (' ','\t'):
                    break
            else:
                insertpt=len(line)
        lineat = int(self.text.index("insert").split('.')[1])
        if insertpt == lineat:
            insertpt = 0
        dest = "insert linestart+"+str(insertpt)+"c"
        if (event.state&1) == 0:
            # shift was not pressed
            self.text.tag_remove("sel", "1.0", "end")
        else:
            if not self.text.index("sel.first"):
                # there was no previous selection
                self.text.mark_set("my_anchor", "insert")
            else:
                if self.text.compare(self.text.index("sel.first"), "<",
                                     self.text.index("insert")):
                    self.text.mark_set("my_anchor", "sel.first") # extend back
                else:
                    self.text.mark_set("my_anchor", "sel.last") # extend forward
            first = self.text.index(dest)
            last = self.text.index("my_anchor")
            if self.text.compare(first,">",last):
                first,last = last,first
            self.text.tag_remove("sel", "1.0", "end")
            self.text.tag_add("sel", first, last)
        self.text.mark_set("insert", dest)
        self.text.see("insert")
        return "break"

    def set_status_bar(self):
        self.status_bar = self.MultiStatusBar(self.top)
        sep = Frame(self.top, height=1, borderwidth=1, background='grey75')
        if sys.platform == "darwin":
            # Insert some padding to avoid obscuring some of the statusbar
            # by the resize widget.
            self.status_bar.set_label('_padding1', '    ', side=RIGHT)
        self.status_bar.set_label('column', 'Col: ?', side=RIGHT)
        self.status_bar.set_label('line', 'Ln: ?', side=RIGHT)
        self.status_bar.pack(side=BOTTOM, fill=X)
        sep.pack(side=BOTTOM, fill=X)
        self.text.bind("<<set-line-and-column>>", self.set_line_and_column)
        self.text.event_add("<<set-line-and-column>>",
                            "<KeyRelease>", "<ButtonRelease>")
        self.text.after_idle(self.set_line_and_column)

    def set_line_and_column(self, event=None):
        line, column = self.text.index(INSERT).split('.')
        self.status_bar.set_label('column', 'Col: %s' % column)
        self.status_bar.set_label('line', 'Ln: %s' % line)

    menu_specs = [
        ("file", "_File"),
        ("edit", "_Edit"),
        ("format", "F_ormat"),
        ("run", "_Run"),
        ("options", "_Options"),
        ("windows", "_Window"),
        ("help", "_Help"),
    ]


    def createmenubar(self):
        mbar = self.menubar
        self.menudict = menudict = {}
        for name, label in self.menu_specs:
            underline, label = prepstr(label)
            menudict[name] = menu = Menu(mbar, name=name, tearoff=0)
            mbar.add_cascade(label=label, menu=menu, underline=underline)
        if macosxSupport.isCarbonTk():
            # Insert the application menu
            menudict['application'] = menu = Menu(mbar, name='apple',
                                                  tearoff=0)
            mbar.add_cascade(label='IDLE', menu=menu)
        self.fill_menus()
        self.recent_files_menu = Menu(self.menubar, tearoff=0)
        self.menudict['file'].insert_cascade(3, label='Recent Files',
                                             underline=0,
                                             menu=self.recent_files_menu)
        self.base_helpmenu_length = self.menudict['help'].index(END)
        self.reset_help_menu_entries()

    def postwindowsmenu(self):
        # Only called when Windows menu exists
        menu = self.menudict['windows']
        end = menu.index("end")
        if end is None:
            end = -1
        if end > self.wmenu_end:
            menu.delete(self.wmenu_end+1, end)
        WindowList.add_windows_to_menu(menu)

    rmenu = None

    def right_menu_event(self, event):
        self.text.mark_set("insert", "@%d,%d" % (event.x, event.y))
        if not self.rmenu:
            self.make_rmenu()
        rmenu = self.rmenu
        self.event = event
        iswin = sys.platform[:3] == 'win'
        if iswin:
            self.text.config(cursor="arrow")

        for item in self.rmenu_specs:
            try:
                label, eventname, verify_state = item
            except ValueError: # see issue1207589
                continue

            if verify_state is None:
                continue
            state = getattr(self, verify_state)()
            rmenu.entryconfigure(label, state=state)


        rmenu.tk_popup(event.x_root, event.y_root)
        if iswin:
            self.text.config(cursor="ibeam")

    rmenu_specs = [
        # ("Label", "<<virtual-event>>", "statefuncname"), ...
        ("Close", "<<close-window>>", None), # Example
    ]

    def make_rmenu(self):
        rmenu = Menu(self.text, tearoff=0)
        for item in self.rmenu_specs:
            label, eventname = item[0], item[1]
            if label is not None:
                def command(text=self.text, eventname=eventname):
                    text.event_generate(eventname)
                rmenu.add_command(label=label, command=command)
            else:
                rmenu.add_separator()
        self.rmenu = rmenu

    def rmenu_check_cut(self):
        return self.rmenu_check_copy()

    def rmenu_check_copy(self):
        try:
            indx = self.text.index('sel.first')
        except TclError:
            return 'disabled'
        else:
            return 'normal' if indx else 'disabled'

    def rmenu_check_paste(self):
        try:
            self.text.tk.call('tk::GetSelection', self.text, 'CLIPBOARD')
        except TclError:
            return 'disabled'
        else:
            return 'normal'

    def about_dialog(self, event=None):
        "Handle Help 'About IDLE' event."
        # Synchronize with macosxSupport.overrideRootMenu.about_dialog.
        aboutDialog.AboutDialog(self.top,'About IDLE')

    def config_dialog(self, event=None):
        "Handle Options 'Configure IDLE' event."
        # Synchronize with macosxSupport.overrideRootMenu.config_dialog.
        configDialog.ConfigDialog(self.top,'Settings')

    def help_dialog(self, event=None):
        "Handle Help 'IDLE Help' event."
        # Synchronize with macosxSupport.overrideRootMenu.help_dialog.
        if self.root:
            parent = self.root
        else:
            parent = self.top
        help.show_idlehelp(parent)

    def python_docs(self, event=None):
        if sys.platform[:3] == 'win':
            try:
                os.startfile(self.help_url)
            except OSError as why:
                tkMessageBox.showerror(title='Document Start Failure',
                    message=str(why), parent=self.text)
        else:
            webbrowser.open(self.help_url)
        return "break"

    def cut(self,event):
        self.text.event_generate("<<Cut>>")
        return "break"

    def copy(self,event):
        if not self.text.tag_ranges("sel"):
            # There is no selection, so do nothing and maybe interrupt.
            return
        self.text.event_generate("<<Copy>>")
        return "break"

    def paste(self,event):
        self.text.event_generate("<<Paste>>")
        self.text.see("insert")
        return "break"

    def select_all(self, event=None):
        self.text.tag_add("sel", "1.0", "end-1c")
        self.text.mark_set("insert", "1.0")
        self.text.see("insert")
        return "break"

    def remove_selection(self, event=None):
        self.text.tag_remove("sel", "1.0", "end")
        self.text.see("insert")

    def move_at_edge_if_selection(self, edge_index):
        """Cursor move begins at start or end of selection

        When a left/right cursor key is pressed create and return to Tkinter a
        function which causes a cursor move from the associated edge of the
        selection.

        """
        self_text_index = self.text.index
        self_text_mark_set = self.text.mark_set
        edges_table = ("sel.first+1c", "sel.last-1c")
        def move_at_edge(event):
            if (event.state & 5) == 0: # no shift(==1) or control(==4) pressed
                try:
                    self_text_index("sel.first")
                    self_text_mark_set("insert", edges_table[edge_index])
                except TclError:
                    pass
        return move_at_edge

    def del_word_left(self, event):
        self.text.event_generate('<Meta-Delete>')
        return "break"

    def del_word_right(self, event):
        self.text.event_generate('<Meta-d>')
        return "break"

    def find_event(self, event):
        SearchDialog.find(self.text)
        return "break"

    def find_again_event(self, event):
        SearchDialog.find_again(self.text)
        return "break"

    def find_selection_event(self, event):
        SearchDialog.find_selection(self.text)
        return "break"

    def find_in_files_event(self, event):
        GrepDialog.grep(self.text, self.io, self.flist)
        return "break"

    def replace_event(self, event):
        ReplaceDialog.replace(self.text)
        return "break"

    def goto_line_event(self, event):
        text = self.text
        lineno = tkSimpleDialog.askinteger("Goto",
                "Go to line number:",parent=text)
        if lineno is None:
            return "break"
        if lineno <= 0:
            text.bell()
            return "break"
        text.mark_set("insert", "%d.0" % lineno)
        text.see("insert")

    def open_module(self, event=None):
        # XXX Shouldn't this be in IOBinding?
        try:
            name = self.text.get("sel.first", "sel.last")
        except TclError:
            name = ""
        else:
            name = name.strip()
        name = tkSimpleDialog.askstring("Module",
                 "Enter the name of a Python module\n"
                 "to search on sys.path and open:",
                 parent=self.text, initialvalue=name)
        if name:
            name = name.strip()
        if not name:
            return
        # XXX Ought to insert current file's directory in front of path
        try:
            spec = importlib.util.find_spec(name)
        except (ValueError, ImportError) as msg:
            tkMessageBox.showerror("Import error", str(msg), parent=self.text)
            return
        if spec is None:
            tkMessageBox.showerror("Import error", "module not found",
                                   parent=self.text)
            return
        if not isinstance(spec.loader, importlib.abc.SourceLoader):
            tkMessageBox.showerror("Import error", "not a source-based module",
                                   parent=self.text)
            return
        try:
            file_path = spec.loader.get_filename(name)
        except AttributeError:
            tkMessageBox.showerror("Import error",
                                   "loader does not support get_filename",
                                   parent=self.text)
            return
        if self.flist:
            self.flist.open(file_path)
        else:
            self.io.loadfile(file_path)
        return file_path

    def open_class_browser(self, event=None):
        filename = self.io.filename
        if not (self.__class__.__name__ == 'PyShellEditorWindow'
                and filename):
            filename = self.open_module()
            if filename is None:
                return
        head, tail = os.path.split(filename)
        base, ext = os.path.splitext(tail)
        from idlelib import ClassBrowser
        ClassBrowser.ClassBrowser(self.flist, base, [head])

    def open_path_browser(self, event=None):
        from idlelib import PathBrowser
        PathBrowser.PathBrowser(self.flist)

    def open_turtle_demo(self, event = None):
        import subprocess

        cmd = [sys.executable,
               '-c',
               'from turtledemo.__main__ import main; main()']
        subprocess.Popen(cmd, shell=False)

    def gotoline(self, lineno):
        if lineno is not None and lineno > 0:
            self.text.mark_set("insert", "%d.0" % lineno)
            self.text.tag_remove("sel", "1.0", "end")
            self.text.tag_add("sel", "insert", "insert +1l")
            self.center()

    def ispythonsource(self, filename):
        if not filename or os.path.isdir(filename):
            return True
        base, ext = os.path.splitext(os.path.basename(filename))
        if os.path.normcase(ext) in (".py", ".pyw"):
            return True
        line = self.text.get('1.0', '1.0 lineend')
        return line.startswith('#!') and 'python' in line

    def close_hook(self):
        if self.flist:
            self.flist.unregister_maybe_terminate(self)
            self.flist = None

    def set_close_hook(self, close_hook):
        self.close_hook = close_hook

    def filename_change_hook(self):
        if self.flist:
            self.flist.filename_changed_edit(self)
        self.saved_change_hook()
        self.top.update_windowlist_registry(self)
        self.ResetColorizer()

    def _addcolorizer(self):
        if self.color:
            return
        if self.ispythonsource(self.io.filename):
            self.color = self.ColorDelegator()
        # can add more colorizers here...
        if self.color:
            self.per.removefilter(self.undo)
            self.per.insertfilter(self.color)
            self.per.insertfilter(self.undo)

    def _rmcolorizer(self):
        if not self.color:
            return
        self.color.removecolors()
        self.per.removefilter(self.color)
        self.color = None

    def ResetColorizer(self):
        "Update the color theme"
        # Called from self.filename_change_hook and from configDialog.py
        self._rmcolorizer()
        self._addcolorizer()
        EditorWindow.color_config(self.text)

    IDENTCHARS = string.ascii_letters + string.digits + "_"

    def colorize_syntax_error(self, text, pos):
        text.tag_add("ERROR", pos)
        char = text.get(pos)
        if char and char in self.IDENTCHARS:
            text.tag_add("ERROR", pos + " wordstart", pos)
        if '\n' == text.get(pos):   # error at line end
            text.mark_set("insert", pos)
        else:
            text.mark_set("insert", pos + "+1c")
        text.see(pos)

    def ResetFont(self):
        "Update the text widgets' font if it is changed"
        # Called from configDialog.py

        self.text['font'] = idleConf.GetFont(self.root, 'main','EditorWindow')

    def RemoveKeybindings(self):
        "Remove the keybindings before they are changed."
        # Called from configDialog.py
        self.Bindings.default_keydefs = keydefs = idleConf.GetCurrentKeySet()
        for event, keylist in keydefs.items():
            self.text.event_delete(event, *keylist)
        for extensionName in self.get_standard_extension_names():
            xkeydefs = idleConf.GetExtensionBindings(extensionName)
            if xkeydefs:
                for event, keylist in xkeydefs.items():
                    self.text.event_delete(event, *keylist)

    def ApplyKeybindings(self):
        "Update the keybindings after they are changed"
        # Called from configDialog.py
        self.Bindings.default_keydefs = keydefs = idleConf.GetCurrentKeySet()
        self.apply_bindings()
        for extensionName in self.get_standard_extension_names():
            xkeydefs = idleConf.GetExtensionBindings(extensionName)
            if xkeydefs:
                self.apply_bindings(xkeydefs)
        #update menu accelerators
        menuEventDict = {}
        for menu in self.Bindings.menudefs:
            menuEventDict[menu[0]] = {}
            for item in menu[1]:
                if item:
                    menuEventDict[menu[0]][prepstr(item[0])[1]] = item[1]
        for menubarItem in self.menudict:
            menu = self.menudict[menubarItem]
            end = menu.index(END)
            if end is None:
                # Skip empty menus
                continue
            end += 1
            for index in range(0, end):
                if menu.type(index) == 'command':
                    accel = menu.entrycget(index, 'accelerator')
                    if accel:
                        itemName = menu.entrycget(index, 'label')
                        event = ''
                        if menubarItem in menuEventDict:
                            if itemName in menuEventDict[menubarItem]:
                                event = menuEventDict[menubarItem][itemName]
                        if event:
                            accel = get_accelerator(keydefs, event)
                            menu.entryconfig(index, accelerator=accel)

    def set_notabs_indentwidth(self):
        "Update the indentwidth if changed and not using tabs in this window"
        # Called from configDialog.py
        if not self.usetabs:
            self.indentwidth = idleConf.GetOption('main', 'Indent','num-spaces',
                                                  type='int')

    def reset_help_menu_entries(self):
        "Update the additional help entries on the Help menu"
        help_list = idleConf.GetAllExtraHelpSourcesList()
        helpmenu = self.menudict['help']
        # first delete the extra help entries, if any
        helpmenu_length = helpmenu.index(END)
        if helpmenu_length > self.base_helpmenu_length:
            helpmenu.delete((self.base_helpmenu_length + 1), helpmenu_length)
        # then rebuild them
        if help_list:
            helpmenu.add_separator()
            for entry in help_list:
                cmd = self.__extra_help_callback(entry[1])
                helpmenu.add_command(label=entry[0], command=cmd)
        # and update the menu dictionary
        self.menudict['help'] = helpmenu

    def __extra_help_callback(self, helpfile):
        "Create a callback with the helpfile value frozen at definition time"
        def display_extra_help(helpfile=helpfile):
            if not helpfile.startswith(('www', 'http')):
                helpfile = os.path.normpath(helpfile)
            if sys.platform[:3] == 'win':
                try:
                    os.startfile(helpfile)
                except OSError as why:
                    tkMessageBox.showerror(title='Document Start Failure',
                        message=str(why), parent=self.text)
            else:
                webbrowser.open(helpfile)
        return display_extra_help

    def update_recent_files_list(self, new_file=None):
        "Load and update the recent files list and menus"
        rf_list = []
        if os.path.exists(self.recent_files_path):
            with open(self.recent_files_path, 'r',
                      encoding='utf_8', errors='replace') as rf_list_file:
                rf_list = rf_list_file.readlines()
        if new_file:
            new_file = os.path.abspath(new_file) + '\n'
            if new_file in rf_list:
                rf_list.remove(new_file)  # move to top
            rf_list.insert(0, new_file)
        # clean and save the recent files list
        bad_paths = []
        for path in rf_list:
            if '\0' in path or not os.path.exists(path[0:-1]):
                bad_paths.append(path)
        rf_list = [path for path in rf_list if path not in bad_paths]
        ulchars = "1234567890ABCDEFGHIJK"
        rf_list = rf_list[0:len(ulchars)]
        try:
            with open(self.recent_files_path, 'w',
                        encoding='utf_8', errors='replace') as rf_file:
                rf_file.writelines(rf_list)
        except OSError as err:
            if not getattr(self.root, "recentfilelist_error_displayed", False):
                self.root.recentfilelist_error_displayed = True
                tkMessageBox.showwarning(title='IDLE Warning',
                    message="Cannot update File menu Recent Files list. "
                            "Your operating system says:\n%s\n"
                            "Select OK and IDLE will continue without updating."
                        % self._filename_to_unicode(str(err)),
                    parent=self.text)
        # for each edit window instance, construct the recent files menu
        for instance in self.top.instance_dict:
            menu = instance.recent_files_menu
            menu.delete(0, END)  # clear, and rebuild:
            for i, file_name in enumerate(rf_list):
                file_name = file_name.rstrip()  # zap \n
                # make unicode string to display non-ASCII chars correctly
                ufile_name = self._filename_to_unicode(file_name)
                callback = instance.__recent_file_callback(file_name)
                menu.add_command(label=ulchars[i] + " " + ufile_name,
                                 command=callback,
                                 underline=0)

    def __recent_file_callback(self, file_name):
        def open_recent_file(fn_closure=file_name):
            self.io.open(editFile=fn_closure)
        return open_recent_file

    def saved_change_hook(self):
        short = self.short_title()
        long = self.long_title()
        if short and long:
            title = short + " - " + long + _py_version
        elif short:
            title = short
        elif long:
            title = long
        else:
            title = "Untitled"
        icon = short or long or title
        if not self.get_saved():
            title = "*%s*" % title
            icon = "*%s" % icon
        self.top.wm_title(title)
        self.top.wm_iconname(icon)

    def get_saved(self):
        return self.undo.get_saved()

    def set_saved(self, flag):
        self.undo.set_saved(flag)

    def reset_undo(self):
        self.undo.reset_undo()

    def short_title(self):
        filename = self.io.filename
        if filename:
            filename = os.path.basename(filename)
        else:
            filename = "Untitled"
        # return unicode string to display non-ASCII chars correctly
        return self._filename_to_unicode(filename)

    def long_title(self):
        # return unicode string to display non-ASCII chars correctly
        return self._filename_to_unicode(self.io.filename or "")

    def center_insert_event(self, event):
        self.center()

    def center(self, mark="insert"):
        text = self.text
        top, bot = self.getwindowlines()
        lineno = self.getlineno(mark)
        height = bot - top
        newtop = max(1, lineno - height//2)
        text.yview(float(newtop))

    def getwindowlines(self):
        text = self.text
        top = self.getlineno("@0,0")
        bot = self.getlineno("@0,65535")
        if top == bot and text.winfo_height() == 1:
            # Geometry manager hasn't run yet
            height = int(text['height'])
            bot = top + height - 1
        return top, bot

    def getlineno(self, mark="insert"):
        text = self.text
        return int(float(text.index(mark)))

    def get_geometry(self):
        "Return (width, height, x, y)"
        geom = self.top.wm_geometry()
        m = re.match(r"(\d+)x(\d+)\+(-?\d+)\+(-?\d+)", geom)
        return list(map(int, m.groups()))

    def close_event(self, event):
        self.close()

    def maybesave(self):
        if self.io:
            if not self.get_saved():
                if self.top.state()!='normal':
                    self.top.deiconify()
                self.top.lower()
                self.top.lift()
            return self.io.maybesave()

    def close(self):
        reply = self.maybesave()
        if str(reply) != "cancel":
            self._close()
        return reply

    def _close(self):
        if self.io.filename:
            self.update_recent_files_list(new_file=self.io.filename)
        WindowList.unregister_callback(self.postwindowsmenu)
        self.unload_extensions()
        self.io.close()
        self.io = None
        self.undo = None
        if self.color:
            self.color.close(False)
            self.color = None
        self.text = None
        self.tkinter_vars = None
        self.per.close()
        self.per = None
        self.top.destroy()
        if self.close_hook:
            # unless override: unregister from flist, terminate if last window
            self.close_hook()

    def load_extensions(self):
        self.extensions = {}
        self.load_standard_extensions()

    def unload_extensions(self):
        for ins in list(self.extensions.values()):
            if hasattr(ins, "close"):
                ins.close()
        self.extensions = {}

    def load_standard_extensions(self):
        for name in self.get_standard_extension_names():
            try:
                self.load_extension(name)
            except:
                print("Failed to load extension", repr(name))
                traceback.print_exc()

    def get_standard_extension_names(self):
        return idleConf.GetExtensions(editor_only=True)

    def load_extension(self, name):
        try:
            try:
                mod = importlib.import_module('.' + name, package=__package__)
            except (ImportError, TypeError):
                mod = importlib.import_module(name)
        except ImportError:
            print("\nFailed to import extension: ", name)
            raise
        cls = getattr(mod, name)
        keydefs = idleConf.GetExtensionBindings(name)
        if hasattr(cls, "menudefs"):
            self.fill_menus(cls.menudefs, keydefs)
        ins = cls(self)
        self.extensions[name] = ins
        if keydefs:
            self.apply_bindings(keydefs)
            for vevent in keydefs:
                methodname = vevent.replace("-", "_")
                while methodname[:1] == '<':
                    methodname = methodname[1:]
                while methodname[-1:] == '>':
                    methodname = methodname[:-1]
                methodname = methodname + "_event"
                if hasattr(ins, methodname):
                    self.text.bind(vevent, getattr(ins, methodname))

    def apply_bindings(self, keydefs=None):
        if keydefs is None:
            keydefs = self.Bindings.default_keydefs
        text = self.text
        text.keydefs = keydefs
        for event, keylist in keydefs.items():
            if keylist:
                text.event_add(event, *keylist)

    def fill_menus(self, menudefs=None, keydefs=None):
        """Add appropriate entries to the menus and submenus

        Menus that are absent or None in self.menudict are ignored.
        """
        if menudefs is None:
            menudefs = self.Bindings.menudefs
        if keydefs is None:
            keydefs = self.Bindings.default_keydefs
        menudict = self.menudict
        text = self.text
        for mname, entrylist in menudefs:
            menu = menudict.get(mname)
            if not menu:
                continue
            for entry in entrylist:
                if not entry:
                    menu.add_separator()
                else:
                    label, eventname = entry
                    checkbutton = (label[:1] == '!')
                    if checkbutton:
                        label = label[1:]
                    underline, label = prepstr(label)
                    accelerator = get_accelerator(keydefs, eventname)
                    def command(text=text, eventname=eventname):
                        text.event_generate(eventname)
                    if checkbutton:
                        var = self.get_var_obj(eventname, BooleanVar)
                        menu.add_checkbutton(label=label, underline=underline,
                            command=command, accelerator=accelerator,
                            variable=var)
                    else:
                        menu.add_command(label=label, underline=underline,
                                         command=command,
                                         accelerator=accelerator)

    def getvar(self, name):
        var = self.get_var_obj(name)
        if var:
            value = var.get()
            return value
        else:
            raise NameError(name)

    def setvar(self, name, value, vartype=None):
        var = self.get_var_obj(name, vartype)
        if var:
            var.set(value)
        else:
            raise NameError(name)

    def get_var_obj(self, name, vartype=None):
        var = self.tkinter_vars.get(name)
        if not var and vartype:
            # create a Tkinter variable object with self.text as master:
            self.tkinter_vars[name] = var = vartype(self.text)
        return var

    # Tk implementations of "virtual text methods" -- each platform
    # reusing IDLE's support code needs to define these for its GUI's
    # flavor of widget.

    # Is character at text_index in a Python string?  Return 0 for
    # "guaranteed no", true for anything else.  This info is expensive
    # to compute ab initio, but is probably already known by the
    # platform's colorizer.

    def is_char_in_string(self, text_index):
        if self.color:
            # Return true iff colorizer hasn't (re)gotten this far
            # yet, or the character is tagged as being in a string
            return self.text.tag_prevrange("TODO", text_index) or \
                   "STRING" in self.text.tag_names(text_index)
        else:
            # The colorizer is missing: assume the worst
            return 1

    # If a selection is defined in the text widget, return (start,
    # end) as Tkinter text indices, otherwise return (None, None)
    def get_selection_indices(self):
        try:
            first = self.text.index("sel.first")
            last = self.text.index("sel.last")
            return first, last
        except TclError:
            return None, None

    # Return the text widget's current view of what a tab stop means
    # (equivalent width in spaces).

    def get_tk_tabwidth(self):
        current = self.text['tabs'] or TK_TABWIDTH_DEFAULT
        return int(current)

    # Set the text widget's current view of what a tab stop means.

    def set_tk_tabwidth(self, newtabwidth):
        text = self.text
        if self.get_tk_tabwidth() != newtabwidth:
            # Set text widget tab width
            pixels = text.tk.call("font", "measure", text["font"],
                                  "-displayof", text.master,
                                  "n" * newtabwidth)
            text.configure(tabs=pixels)

### begin autoindent code ###  (configuration was moved to beginning of class)

    def set_indentation_params(self, is_py_src, guess=True):
        if is_py_src and guess:
            i = self.guess_indent()
            if 2 <= i <= 8:
                self.indentwidth = i
            if self.indentwidth != self.tabwidth:
                self.usetabs = False
        self.set_tk_tabwidth(self.tabwidth)

    def smart_backspace_event(self, event):
        text = self.text
        first, last = self.get_selection_indices()
        if first and last:
            text.delete(first, last)
            text.mark_set("insert", first)
            return "break"
        # Delete whitespace left, until hitting a real char or closest
        # preceding virtual tab stop.
        chars = text.get("insert linestart", "insert")
        if chars == '':
            if text.compare("insert", ">", "1.0"):
                # easy: delete preceding newline
                text.delete("insert-1c")
            else:
                text.bell()     # at start of buffer
            return "break"
        if  chars[-1] not in " \t":
            # easy: delete preceding real char
            text.delete("insert-1c")
            return "break"
        # Ick.  It may require *inserting* spaces if we back up over a
        # tab character!  This is written to be clear, not fast.
        tabwidth = self.tabwidth
        have = len(chars.expandtabs(tabwidth))
        assert have > 0
        want = ((have - 1) // self.indentwidth) * self.indentwidth
        # Debug prompt is multilined....
        if self.context_use_ps1:
            last_line_of_prompt = sys.ps1.split('\n')[-1]
        else:
            last_line_of_prompt = ''
        ncharsdeleted = 0
        while 1:
            if chars == last_line_of_prompt:
                break
            chars = chars[:-1]
            ncharsdeleted = ncharsdeleted + 1
            have = len(chars.expandtabs(tabwidth))
            if have <= want or chars[-1] not in " \t":
                break
        text.undo_block_start()
        text.delete("insert-%dc" % ncharsdeleted, "insert")
        if have < want:
            text.insert("insert", ' ' * (want - have))
        text.undo_block_stop()
        return "break"

    def smart_indent_event(self, event):
        # if intraline selection:
        #     delete it
        # elif multiline selection:
        #     do indent-region
        # else:
        #     indent one level
        text = self.text
        first, last = self.get_selection_indices()
        text.undo_block_start()
        try:
            if first and last:
                if index2line(first) != index2line(last):
                    return self.indent_region_event(event)
                text.delete(first, last)
                text.mark_set("insert", first)
            prefix = text.get("insert linestart", "insert")
            raw, effective = classifyws(prefix, self.tabwidth)
            if raw == len(prefix):
                # only whitespace to the left
                self.reindent_to(effective + self.indentwidth)
            else:
                # tab to the next 'stop' within or to right of line's text:
                if self.usetabs:
                    pad = '\t'
                else:
                    effective = len(prefix.expandtabs(self.tabwidth))
                    n = self.indentwidth
                    pad = ' ' * (n - effective % n)
                text.insert("insert", pad)
            text.see("insert")
            return "break"
        finally:
            text.undo_block_stop()

    def newline_and_indent_event(self, event):
        text = self.text
        first, last = self.get_selection_indices()
        text.undo_block_start()
        try:
            if first and last:
                text.delete(first, last)
                text.mark_set("insert", first)
            line = text.get("insert linestart", "insert")
            i, n = 0, len(line)
            while i < n and line[i] in " \t":
                i = i+1
            if i == n:
                # the cursor is in or at leading indentation in a continuation
                # line; just inject an empty line at the start
                text.insert("insert linestart", '\n')
                return "break"
            indent = line[:i]
            # strip whitespace before insert point unless it's in the prompt
            i = 0
            last_line_of_prompt = sys.ps1.split('\n')[-1]
            while line and line[-1] in " \t" and line != last_line_of_prompt:
                line = line[:-1]
                i = i+1
            if i:
                text.delete("insert - %d chars" % i, "insert")
            # strip whitespace after insert point
            while text.get("insert") in " \t":
                text.delete("insert")
            # start new line
            text.insert("insert", '\n')

            # adjust indentation for continuations and block
            # open/close first need to find the last stmt
            lno = index2line(text.index('insert'))
            y = PyParse.Parser(self.indentwidth, self.tabwidth)
            if not self.context_use_ps1:
                for context in self.num_context_lines:
                    startat = max(lno - context, 1)
                    startatindex = repr(startat) + ".0"
                    rawtext = text.get(startatindex, "insert")
                    y.set_str(rawtext)
                    bod = y.find_good_parse_start(
                              self.context_use_ps1,
                              self._build_char_in_string_func(startatindex))
                    if bod is not None or startat == 1:
                        break
                y.set_lo(bod or 0)
            else:
                r = text.tag_prevrange("console", "insert")
                if r:
                    startatindex = r[1]
                else:
                    startatindex = "1.0"
                rawtext = text.get(startatindex, "insert")
                y.set_str(rawtext)
                y.set_lo(0)

            c = y.get_continuation_type()
            if c != PyParse.C_NONE:
                # The current stmt hasn't ended yet.
                if c == PyParse.C_STRING_FIRST_LINE:
                    # after the first line of a string; do not indent at all
                    pass
                elif c == PyParse.C_STRING_NEXT_LINES:
                    # inside a string which started before this line;
                    # just mimic the current indent
                    text.insert("insert", indent)
                elif c == PyParse.C_BRACKET:
                    # line up with the first (if any) element of the
                    # last open bracket structure; else indent one
                    # level beyond the indent of the line with the
                    # last open bracket
                    self.reindent_to(y.compute_bracket_indent())
                elif c == PyParse.C_BACKSLASH:
                    # if more than one line in this stmt already, just
                    # mimic the current indent; else if initial line
                    # has a start on an assignment stmt, indent to
                    # beyond leftmost =; else to beyond first chunk of
                    # non-whitespace on initial line
                    if y.get_num_lines_in_stmt() > 1:
                        text.insert("insert", indent)
                    else:
                        self.reindent_to(y.compute_backslash_indent())
                else:
                    assert 0, "bogus continuation type %r" % (c,)
                return "break"

            # This line starts a brand new stmt; indent relative to
            # indentation of initial line of closest preceding
            # interesting stmt.
            indent = y.get_base_indent_string()
            text.insert("insert", indent)
            if y.is_block_opener():
                self.smart_indent_event(event)
            elif indent and y.is_block_closer():
                self.smart_backspace_event(event)
            return "break"
        finally:
            text.see("insert")
            text.undo_block_stop()

    # Our editwin provides an is_char_in_string function that works
    # with a Tk text index, but PyParse only knows about offsets into
    # a string. This builds a function for PyParse that accepts an
    # offset.

    def _build_char_in_string_func(self, startindex):
        def inner(offset, _startindex=startindex,
                  _icis=self.is_char_in_string):
            return _icis(_startindex + "+%dc" % offset)
        return inner

    def indent_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines)):
            line = lines[pos]
            if line:
                raw, effective = classifyws(line, self.tabwidth)
                effective = effective + self.indentwidth
                lines[pos] = self._make_blanks(effective) + line[raw:]
        self.set_region(head, tail, chars, lines)
        return "break"

    def dedent_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines)):
            line = lines[pos]
            if line:
                raw, effective = classifyws(line, self.tabwidth)
                effective = max(effective - self.indentwidth, 0)
                lines[pos] = self._make_blanks(effective) + line[raw:]
        self.set_region(head, tail, chars, lines)
        return "break"

    def comment_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines) - 1):
            line = lines[pos]
            lines[pos] = '##' + line
        self.set_region(head, tail, chars, lines)

    def uncomment_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines)):
            line = lines[pos]
            if not line:
                continue
            if line[:2] == '##':
                line = line[2:]
            elif line[:1] == '#':
                line = line[1:]
            lines[pos] = line
        self.set_region(head, tail, chars, lines)

    def tabify_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        tabwidth = self._asktabwidth()
        if tabwidth is None: return
        for pos in range(len(lines)):
            line = lines[pos]
            if line:
                raw, effective = classifyws(line, tabwidth)
                ntabs, nspaces = divmod(effective, tabwidth)
                lines[pos] = '\t' * ntabs + ' ' * nspaces + line[raw:]
        self.set_region(head, tail, chars, lines)

    def untabify_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        tabwidth = self._asktabwidth()
        if tabwidth is None: return
        for pos in range(len(lines)):
            lines[pos] = lines[pos].expandtabs(tabwidth)
        self.set_region(head, tail, chars, lines)

    def toggle_tabs_event(self, event):
        if self.askyesno(
              "Toggle tabs",
              "Turn tabs " + ("on", "off")[self.usetabs] +
              "?\nIndent width " +
              ("will be", "remains at")[self.usetabs] + " 8." +
              "\n Note: a tab is always 8 columns",
              parent=self.text):
            self.usetabs = not self.usetabs
            # Try to prevent inconsistent indentation.
            # User must change indent width manually after using tabs.
            self.indentwidth = 8
        return "break"

    # XXX this isn't bound to anything -- see tabwidth comments
##     def change_tabwidth_event(self, event):
##         new = self._asktabwidth()
##         if new != self.tabwidth:
##             self.tabwidth = new
##             self.set_indentation_params(0, guess=0)
##         return "break"

    def change_indentwidth_event(self, event):
        new = self.askinteger(
                  "Indent width",
                  "New indent width (2-16)\n(Always use 8 when using tabs)",
                  parent=self.text,
                  initialvalue=self.indentwidth,
                  minvalue=2,
                  maxvalue=16)
        if new and new != self.indentwidth and not self.usetabs:
            self.indentwidth = new
        return "break"

    def get_region(self):
        text = self.text
        first, last = self.get_selection_indices()
        if first and last:
            head = text.index(first + " linestart")
            tail = text.index(last + "-1c lineend +1c")
        else:
            head = text.index("insert linestart")
            tail = text.index("insert lineend +1c")
        chars = text.get(head, tail)
        lines = chars.split("\n")
        return head, tail, chars, lines

    def set_region(self, head, tail, chars, lines):
        text = self.text
        newchars = "\n".join(lines)
        if newchars == chars:
            text.bell()
            return
        text.tag_remove("sel", "1.0", "end")
        text.mark_set("insert", head)
        text.undo_block_start()
        text.delete(head, tail)
        text.insert(head, newchars)
        text.undo_block_stop()
        text.tag_add("sel", head, "insert")

    # Make string that displays as n leading blanks.

    def _make_blanks(self, n):
        if self.usetabs:
            ntabs, nspaces = divmod(n, self.tabwidth)
            return '\t' * ntabs + ' ' * nspaces
        else:
            return ' ' * n

    # Delete from beginning of line to insert point, then reinsert
    # column logical (meaning use tabs if appropriate) spaces.

    def reindent_to(self, column):
        text = self.text
        text.undo_block_start()
        if text.compare("insert linestart", "!=", "insert"):
            text.delete("insert linestart", "insert")
        if column:
            text.insert("insert", self._make_blanks(column))
        text.undo_block_stop()

    def _asktabwidth(self):
        return self.askinteger(
            "Tab width",
            "Columns per tab? (2-16)",
            parent=self.text,
            initialvalue=self.indentwidth,
            minvalue=2,
            maxvalue=16)

    # Guess indentwidth from text content.
    # Return guessed indentwidth.  This should not be believed unless
    # it's in a reasonable range (e.g., it will be 0 if no indented
    # blocks are found).

    def guess_indent(self):
        opener, indented = IndentSearcher(self.text, self.tabwidth).run()
        if opener and indented:
            raw, indentsmall = classifyws(opener, self.tabwidth)
            raw, indentlarge = classifyws(indented, self.tabwidth)
        else:
            indentsmall = indentlarge = 0
        return indentlarge - indentsmall

# "line.col" -> line, as an int
def index2line(index):
    return int(float(index))

# Look at the leading whitespace in s.
# Return pair (# of leading ws characters,
#              effective # of leading blanks after expanding
#              tabs to width tabwidth)

def classifyws(s, tabwidth):
    raw = effective = 0
    for ch in s:
        if ch == ' ':
            raw = raw + 1
            effective = effective + 1
        elif ch == '\t':
            raw = raw + 1
            effective = (effective // tabwidth + 1) * tabwidth
        else:
            break
    return raw, effective

import tokenize
_tokenize = tokenize
del tokenize

class IndentSearcher(object):

    # .run() chews over the Text widget, looking for a block opener
    # and the stmt following it.  Returns a pair,
    #     (line containing block opener, line containing stmt)
    # Either or both may be None.

    def __init__(self, text, tabwidth):
        self.text = text
        self.tabwidth = tabwidth
        self.i = self.finished = 0
        self.blkopenline = self.indentedline = None

    def readline(self):
        if self.finished:
            return ""
        i = self.i = self.i + 1
        mark = repr(i) + ".0"
        if self.text.compare(mark, ">=", "end"):
            return ""
        return self.text.get(mark, mark + " lineend+1c")

    def tokeneater(self, type, token, start, end, line,
                   INDENT=_tokenize.INDENT,
                   NAME=_tokenize.NAME,
                   OPENERS=('class', 'def', 'for', 'if', 'try', 'while')):
        if self.finished:
            pass
        elif type == NAME and token in OPENERS:
            self.blkopenline = line
        elif type == INDENT and self.blkopenline:
            self.indentedline = line
            self.finished = 1

    def run(self):
        save_tabsize = _tokenize.tabsize
        _tokenize.tabsize = self.tabwidth
        try:
            try:
                tokens = _tokenize.generate_tokens(self.readline)
                for token in tokens:
                    self.tokeneater(*token)
            except (_tokenize.TokenError, SyntaxError):
                # since we cut off the tokenizer early, we can trigger
                # spurious errors
                pass
        finally:
            _tokenize.tabsize = save_tabsize
        return self.blkopenline, self.indentedline

### end autoindent code ###

def prepstr(s):
    # Helper to extract the underscore from a string, e.g.
    # prepstr("Co_py") returns (2, "Copy").
    i = s.find('_')
    if i >= 0:
        s = s[:i] + s[i+1:]
    return i, s


keynames = {
 'bracketleft': '[',
 'bracketright': ']',
 'slash': '/',
}

def get_accelerator(keydefs, eventname):
    keylist = keydefs.get(eventname)
    # issue10940: temporary workaround to prevent hang with OS X Cocoa Tk 8.5
    # if not keylist:
    if (not keylist) or (macosxSupport.isCocoaTk() and eventname in {
                            "<<open-module>>",
                            "<<goto-line>>",
                            "<<change-indentwidth>>"}):
        return ""
    s = keylist[0]
    s = re.sub(r"-[a-z]\b", lambda m: m.group().upper(), s)
    s = re.sub(r"\b\w+\b", lambda m: keynames.get(m.group(), m.group()), s)
    s = re.sub("Key-", "", s)
    s = re.sub("Cancel","Ctrl-Break",s)   # dscherer@cmu.edu
    s = re.sub("Control-", "Ctrl-", s)
    s = re.sub("-", "+", s)
    s = re.sub("><", " ", s)
    s = re.sub("<", "", s)
    s = re.sub(">", "", s)
    return s


def fixwordbreaks(root):
    # Make sure that Tk's double-click and next/previous word
    # operations use our definition of a word (i.e. an identifier)
    tk = root.tk
    tk.call('tcl_wordBreakAfter', 'a b', 0) # make sure word.tcl is loaded
    tk.call('set', 'tcl_wordchars', '[a-zA-Z0-9_]')
    tk.call('set', 'tcl_nonwordchars', '[^a-zA-Z0-9_]')


def _editor_window(parent):  # htest #
    # error if close master window first - timer event, after script
    root = parent
    fixwordbreaks(root)
    if sys.argv[1:]:
        filename = sys.argv[1]
    else:
        filename = None
    macosxSupport.setupApp(root, None)
    edit = EditorWindow(root=root, filename=filename)
    edit.text.bind("<<close-all-windows>>", edit.close_event)
    # Does not stop error, neither does following
    # edit.text.bind("<<close-window>>", edit.close_event)

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_editor_window)
                                                                                         import codecs
from codecs import BOM_UTF8
import os
import re
import shlex
import sys
import tempfile

import tkinter.filedialog as tkFileDialog
import tkinter.messagebox as tkMessageBox
from tkinter.simpledialog import askstring

from idlelib.configHandler import idleConf


# Try setting the locale, so that we can find out
# what encoding to use
try:
    import locale
    locale.setlocale(locale.LC_CTYPE, "")
except (ImportError, locale.Error):
    pass

# Encoding for file names
filesystemencoding = sys.getfilesystemencoding()  ### currently unused

locale_encoding = 'ascii'
if sys.platform == 'win32':
    # On Windows, we could use "mbcs". However, to give the user
    # a portable encoding name, we need to find the code page
    try:
        locale_encoding = locale.getdefaultlocale()[1]
        codecs.lookup(locale_encoding)
    except LookupError:
        pass
else:
    try:
        # Different things can fail here: the locale module may not be
        # loaded, it may not offer nl_langinfo, or CODESET, or the
        # resulting codeset may be unknown to Python. We ignore all
        # these problems, falling back to ASCII
        locale_encoding = locale.nl_langinfo(locale.CODESET)
        if locale_encoding is None or locale_encoding is '':
            # situation occurs on Mac OS X
            locale_encoding = 'ascii'
        codecs.lookup(locale_encoding)
    except (NameError, AttributeError, LookupError):
        # Try getdefaultlocale: it parses environment variables,
        # which may give a clue. Unfortunately, getdefaultlocale has
        # bugs that can cause ValueError.
        try:
            locale_encoding = locale.getdefaultlocale()[1]
            if locale_encoding is None or locale_encoding is '':
                # situation occurs on Mac OS X
                locale_encoding = 'ascii'
            codecs.lookup(locale_encoding)
        except (ValueError, LookupError):
            pass

locale_encoding = locale_encoding.lower()

encoding = locale_encoding  ### KBK 07Sep07  This is used all over IDLE, check!
                            ### 'encoding' is used below in encode(), check!

coding_re = re.compile(r'^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)', re.ASCII)
blank_re = re.compile(r'^[ \t\f]*(?:[#\r\n]|$)', re.ASCII)

def coding_spec(data):
    """Return the encoding declaration according to PEP 263.

    When checking encoded data, only the first two lines should be passed
    in to avoid a UnicodeDecodeError if the rest of the data is not unicode.
    The first two lines would contain the encoding specification.

    Raise a LookupError if the encoding is declared but unknown.
    """
    if isinstance(data, bytes):
        # This encoding might be wrong. However, the coding
        # spec must be ASCII-only, so any non-ASCII characters
        # around here will be ignored. Decoding to Latin-1 should
        # never fail (except for memory outage)
        lines = data.decode('iso-8859-1')
    else:
        lines = data
    # consider only the first two lines
    if '\n' in lines:
        lst = lines.split('\n', 2)[:2]
    elif '\r' in lines:
        lst = lines.split('\r', 2)[:2]
    else:
        lst = [lines]
    for line in lst:
        match = coding_re.match(line)
        if match is not None:
            break
        if not blank_re.match(line):
            return None
    else:
        return None
    name = match.group(1)
    try:
        codecs.lookup(name)
    except LookupError:
        # The standard encoding error does not indicate the encoding
        raise LookupError("Unknown encoding: "+name)
    return name


class IOBinding:

    def __init__(self, editwin):
        self.editwin = editwin
        self.text = editwin.text
        self.__id_open = self.text.bind("<<open-window-from-file>>", self.open)
        self.__id_save = self.text.bind("<<save-window>>", self.save)
        self.__id_saveas = self.text.bind("<<save-window-as-file>>",
                                          self.save_as)
        self.__id_savecopy = self.text.bind("<<save-copy-of-window-as-file>>",
                                            self.save_a_copy)
        self.fileencoding = None
        self.__id_print = self.text.bind("<<print-window>>", self.print_window)

    def close(self):
        # Undo command bindings
        self.text.unbind("<<open-window-from-file>>", self.__id_open)
        self.text.unbind("<<save-window>>", self.__id_save)
        self.text.unbind("<<save-window-as-file>>",self.__id_saveas)
        self.text.unbind("<<save-copy-of-window-as-file>>", self.__id_savecopy)
        self.text.unbind("<<print-window>>", self.__id_print)
        # Break cycles
        self.editwin = None
        self.text = None
        self.filename_change_hook = None

    def get_saved(self):
        return self.editwin.get_saved()

    def set_saved(self, flag):
        self.editwin.set_saved(flag)

    def reset_undo(self):
        self.editwin.reset_undo()

    filename_change_hook = None

    def set_filename_change_hook(self, hook):
        self.filename_change_hook = hook

    filename = None
    dirname = None

    def set_filename(self, filename):
        if filename and os.path.isdir(filename):
            self.filename = None
            self.dirname = filename
        else:
            self.filename = filename
            self.dirname = None
            self.set_saved(1)
            if self.filename_change_hook:
                self.filename_change_hook()

    def open(self, event=None, editFile=None):
        flist = self.editwin.flist
        # Save in case parent window is closed (ie, during askopenfile()).
        if flist:
            if not editFile:
                filename = self.askopenfile()
            else:
                filename=editFile
            if filename:
                # If editFile is valid and already open, flist.open will
                # shift focus to its existing window.
                # If the current window exists and is a fresh unnamed,
                # unmodified editor window (not an interpreter shell),
                # pass self.loadfile to flist.open so it will load the file
                # in the current window (if the file is not already open)
                # instead of a new window.
                if (self.editwin and
                        not getattr(self.editwin, 'interp', None) and
                        not self.filename and
                        self.get_saved()):
                    flist.open(filename, self.loadfile)
                else:
                    flist.open(filename)
            else:
                if self.text:
                    self.text.focus_set()
            return "break"

        # Code for use outside IDLE:
        if self.get_saved():
            reply = self.maybesave()
            if reply == "cancel":
                self.text.focus_set()
                return "break"
        if not editFile:
            filename = self.askopenfile()
        else:
            filename=editFile
        if filename:
            self.loadfile(filename)
        else:
            self.text.focus_set()
        return "break"

    eol = r"(\r\n)|\n|\r"  # \r\n (Windows), \n (UNIX), or \r (Mac)
    eol_re = re.compile(eol)
    eol_convention = os.linesep  # default

    def loadfile(self, filename):
        try:
            # open the file in binary mode so that we can handle
            # end-of-line convention ourselves.
            with open(filename, 'rb') as f:
                two_lines = f.readline() + f.readline()
                f.seek(0)
                bytes = f.read()
        except OSError as msg:
            tkMessageBox.showerror("I/O Error", str(msg), parent=self.text)
            return False
        chars, converted = self._decode(two_lines, bytes)
        if chars is None:
            tkMessageBox.showerror("Decoding Error",
                                   "File %s\nFailed to Decode" % filename,
                                   parent=self.text)
            return False
        # We now convert all end-of-lines to '\n's
        firsteol = self.eol_re.search(chars)
        if firsteol:
            self.eol_convention = firsteol.group(0)
            chars = self.eol_re.sub(r"\n", chars)
        self.text.delete("1.0", "end")
        self.set_filename(None)
        self.text.insert("1.0", chars)
        self.reset_undo()
        self.set_filename(filename)
        if converted:
            # We need to save the conversion results first
            # before being able to execute the code
            self.set_saved(False)
        self.text.mark_set("insert", "1.0")
        self.text.yview("insert")
        self.updaterecentfileslist(filename)
        return True

    def _decode(self, two_lines, bytes):
        "Create a Unicode string."
        chars = None
        # Check presence of a UTF-8 signature first
        if bytes.startswith(BOM_UTF8):
            try:
                chars = bytes[3:].decode("utf-8")
            except UnicodeDecodeError:
                # has UTF-8 signature, but fails to decode...
                return None, False
            else:
                # Indicates that this file originally had a BOM
                self.fileencoding = 'BOM'
                return chars, False
        # Next look for coding specification
        try:
            enc = coding_spec(two_lines)
        except LookupError as name:
            tkMessageBox.showerror(
                title="Error loading the file",
                message="The encoding '%s' is not known to this Python "\
                "installation. The file may not display correctly" % name,
                parent = self.text)
            enc = None
        except UnicodeDecodeError:
            return None, False
        if enc:
            try:
                chars = str(bytes, enc)
                self.fileencoding = enc
                return chars, False
            except UnicodeDecodeError:
                pass
        # Try ascii:
        try:
            chars = str(bytes, 'ascii')
            self.fileencoding = None
            return chars, False
        except UnicodeDecodeError:
            pass
        # Try utf-8:
        try:
            chars = str(bytes, 'utf-8')
            self.fileencoding = 'utf-8'
            return chars, False
        except UnicodeDecodeError:
            pass
        # Finally, try the locale's encoding. This is deprecated;
        # the user should declare a non-ASCII encoding
        try:
            # Wait for the editor window to appear
            self.editwin.text.update()
            enc = askstring(
                "Specify file encoding",
                "The file's encoding is invalid for Python 3.x.\n"
                "IDLE will convert it to UTF-8.\n"
                "What is the current encoding of the file?",
                initialvalue = locale_encoding,
                parent = self.editwin.text)

            if enc:
                chars = str(bytes, enc)
                self.fileencoding = None
            return chars, True
        except (UnicodeDecodeError, LookupError):
            pass
        return None, False  # None on failure

    def maybesave(self):
        if self.get_saved():
            return "yes"
        message = "Do you want to save %s before closing?" % (
            self.filename or "this untitled document")
        confirm = tkMessageBox.askyesnocancel(
                  title="Save On Close",
                  message=message,
                  default=tkMessageBox.YES,
                  parent=self.text)
        if confirm:
            reply = "yes"
            self.save(None)
            if not self.get_saved():
                reply = "cancel"
        elif confirm is None:
            reply = "cancel"
        else:
            reply = "no"
        self.text.focus_set()
        return reply

    def save(self, event):
        if not self.filename:
            self.save_as(event)
        else:
            if self.writefile(self.filename):
                self.set_saved(True)
                try:
                    self.editwin.store_file_breaks()
                except AttributeError:  # may be a PyShell
                    pass
        self.text.focus_set()
        return "break"

    def save_as(self, event):
        filename = self.asksavefile()
        if filename:
            if self.writefile(filename):
                self.set_filename(filename)
                self.set_saved(1)
                try:
                    self.editwin.store_file_breaks()
                except AttributeError:
                    pass
        self.text.focus_set()
        self.updaterecentfileslist(filename)
        return "break"

    def save_a_copy(self, event):
        filename = self.asksavefile()
        if filename:
            self.writefile(filename)
        self.text.focus_set()
        self.updaterecentfileslist(filename)
        return "break"

    def writefile(self, filename):
        self.fixlastline()
        text = self.text.get("1.0", "end-1c")
        if self.eol_convention != "\n":
            text = text.replace("\n", self.eol_convention)
        chars = self.encode(text)
        try:
            with open(filename, "wb") as f:
                f.write(chars)
            return True
        except OSError as msg:
            tkMessageBox.showerror("I/O Error", str(msg),
                                   parent=self.text)
            return False

    def encode(self, chars):
        if isinstance(chars, bytes):
            # This is either plain ASCII, or Tk was returning mixed-encoding
            # text to us. Don't try to guess further.
            return chars
        # Preserve a BOM that might have been present on opening
        if self.fileencoding == 'BOM':
            return BOM_UTF8 + chars.encode("utf-8")
        # See whether there is anything non-ASCII in it.
        # If not, no need to figure out the encoding.
        try:
            return chars.encode('ascii')
        except UnicodeError:
            pass
        # Check if there is an encoding declared
        try:
            # a string, let coding_spec slice it to the first two lines
            enc = coding_spec(chars)
            failed = None
        except LookupError as msg:
            failed = msg
            enc = None
        else:
            if not enc:
                # PEP 3120: default source encoding is UTF-8
                enc = 'utf-8'
        if enc:
            try:
                return chars.encode(enc)
            except UnicodeError:
                failed = "Invalid encoding '%s'" % enc
        tkMessageBox.showerror(
            "I/O Error",
            "%s.\nSaving as UTF-8" % failed,
            parent = self.text)
        # Fallback: save as UTF-8, with BOM - ignoring the incorrect
        # declared encoding
        return BOM_UTF8 + chars.encode("utf-8")

    def fixlastline(self):
        c = self.text.get("end-2c")
        if c != '\n':
            self.text.insert("end-1c", "\n")

    def print_window(self, event):
        confirm = tkMessageBox.askokcancel(
                  title="Print",
                  message="Print to Default Printer",
                  default=tkMessageBox.OK,
                  parent=self.text)
        if not confirm:
            self.text.focus_set()
            return "break"
        tempfilename = None
        saved = self.get_saved()
        if saved:
            filename = self.filename
        # shell undo is reset after every prompt, looks saved, probably isn't
        if not saved or filename is None:
            (tfd, tempfilename) = tempfile.mkstemp(prefix='IDLE_tmp_')
            filename = tempfilename
            os.close(tfd)
            if not self.writefile(tempfilename):
                os.unlink(tempfilename)
                return "break"
        platform = os.name
        printPlatform = True
        if platform == 'posix': #posix platform
            command = idleConf.GetOption('main','General',
                                         'print-command-posix')
            command = command + " 2>&1"
        elif platform == 'nt': #win32 platform
            command = idleConf.GetOption('main','General','print-command-win')
        else: #no printing for this platform
            printPlatform = False
        if printPlatform:  #we can try to print for this platform
            command = command % shlex.quote(filename)
            pipe = os.popen(command, "r")
            # things can get ugly on NT if there is no printer available.
            output = pipe.read().strip()
            status = pipe.close()
            if status:
                output = "Printing failed (exit status 0x%x)\n" % \
                         status + output
            if output:
                output = "Printing command: %s\n" % repr(command) + output
                tkMessageBox.showerror("Print status", output, parent=self.text)
        else:  #no printing for this platform
            message = "Printing is not enabled for this platform: %s" % platform
            tkMessageBox.showinfo("Print status", message, parent=self.text)
        if tempfilename:
            os.unlink(tempfilename)
        return "break"

    opendialog = None
    savedialog = None

    filetypes = [
        ("Python files", "*.py *.pyw", "TEXT"),
        ("Text files", "*.txt", "TEXT"),
        ("All files", "*"),
        ]

    defaultextension = '.py' if sys.platform == 'darwin' else ''

    def askopenfile(self):
        dir, base = self.defaultfilename("open")
        if not self.opendialog:
            self.opendialog = tkFileDialog.Open(parent=self.text,
                                                filetypes=self.filetypes)
        filename = self.opendialog.show(initialdir=dir, initialfile=base)
        return filename

    def defaultfilename(self, mode="open"):
        if self.filename:
            return os.path.split(self.filename)
        elif self.dirname:
            return self.dirname, ""
        else:
            try:
                pwd = os.getcwd()
            except OSError:
                pwd = ""
            return pwd, ""

    def asksavefile(self):
        dir, base = self.defaultfilename("save")
        if not self.savedialog:
            self.savedialog = tkFileDialog.SaveAs(
                    parent=self.text,
                    filetypes=self.filetypes,
                    defaultextension=self.defaultextension)
        filename = self.savedialog.show(initialdir=dir, initialfile=base)
        return filename

    def updaterecentfileslist(self,filename):
        "Update recent file list on all editor windows"
        if self.editwin.flist:
            self.editwin.update_recent_files_list(filename)

def _io_binding(parent):  # htest #
    from tkinter import Toplevel, Text

    root = Toplevel(parent)
    root.title("Test IOBinding")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    class MyEditWin:
        def __init__(self, text):
            self.text = text
            self.flist = None
            self.text.bind("<Control-o>", self.open)
            self.text.bind('<Control-p>', self.print)
            self.text.bind("<Control-s>", self.save)
            self.text.bind("<Alt-s>", self.saveas)
            self.text.bind('<Control-c>', self.savecopy)
        def get_saved(self): return 0
        def set_saved(self, flag): pass
        def reset_undo(self): pass
        def open(self, event):
            self.text.event_generate("<<open-window-from-file>>")
        def print(self, event):
            self.text.event_generate("<<print-window>>")
        def save(self, event):
            self.text.event_generate("<<save-window>>")
        def saveas(self, event):
            self.text.event_generate("<<save-window-as-file>>")
        def savecopy(self, event):
            self.text.event_generate("<<save-copy-of-window-as-file>>")

    text = Text(root)
    text.pack()
    text.focus_set()
    editwin = MyEditWin(text)
    IOBinding(editwin)

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_io_binding)
                                                                                                                                                                                                                                                               """
MultiCall - a class which inherits its methods from a Tkinter widget (Text, for
example), but enables multiple calls of functions per virtual event - all
matching events will be called, not only the most specific one. This is done
by wrapping the event functions - event_add, event_delete and event_info.
MultiCall recognizes only a subset of legal event sequences. Sequences which
are not recognized are treated by the original Tk handling mechanism. A
more-specific event will be called before a less-specific event.

The recognized sequences are complete one-event sequences (no emacs-style
Ctrl-X Ctrl-C, no shortcuts like <3>), for all types of events.
Key/Button Press/Release events can have modifiers.
The recognized modifiers are Shift, Control, Option and Command for Mac, and
Control, Alt, Shift, Meta/M for other platforms.

For all events which were handled by MultiCall, a new member is added to the
event instance passed to the binded functions - mc_type. This is one of the
event type constants defined in this module (such as MC_KEYPRESS).
For Key/Button events (which are handled by MultiCall and may receive
modifiers), another member is added - mc_state. This member gives the state
of the recognized modifiers, as a combination of the modifier constants
also defined in this module (for example, MC_SHIFT).
Using these members is absolutely portable.

The order by which events are called is defined by these rules:
1. A more-specific event will be called before a less-specific event.
2. A recently-binded event will be called before a previously-binded event,
   unless this conflicts with the first rule.
Each function will be called at most once for each event.
"""

import sys
import re
import tkinter

# the event type constants, which define the meaning of mc_type
MC_KEYPRESS=0; MC_KEYRELEASE=1; MC_BUTTONPRESS=2; MC_BUTTONRELEASE=3;
MC_ACTIVATE=4; MC_CIRCULATE=5; MC_COLORMAP=6; MC_CONFIGURE=7;
MC_DEACTIVATE=8; MC_DESTROY=9; MC_ENTER=10; MC_EXPOSE=11; MC_FOCUSIN=12;
MC_FOCUSOUT=13; MC_GRAVITY=14; MC_LEAVE=15; MC_MAP=16; MC_MOTION=17;
MC_MOUSEWHEEL=18; MC_PROPERTY=19; MC_REPARENT=20; MC_UNMAP=21; MC_VISIBILITY=22;
# the modifier state constants, which define the meaning of mc_state
MC_SHIFT = 1<<0; MC_CONTROL = 1<<2; MC_ALT = 1<<3; MC_META = 1<<5
MC_OPTION = 1<<6; MC_COMMAND = 1<<7

# define the list of modifiers, to be used in complex event types.
if sys.platform == "darwin":
    _modifiers = (("Shift",), ("Control",), ("Option",), ("Command",))
    _modifier_masks = (MC_SHIFT, MC_CONTROL, MC_OPTION, MC_COMMAND)
else:
    _modifiers = (("Control",), ("Alt",), ("Shift",), ("Meta", "M"))
    _modifier_masks = (MC_CONTROL, MC_ALT, MC_SHIFT, MC_META)

# a dictionary to map a modifier name into its number
_modifier_names = dict([(name, number)
                         for number in range(len(_modifiers))
                         for name in _modifiers[number]])

# In 3.4, if no shell window is ever open, the underlying Tk widget is
# destroyed before .__del__ methods here are called.  The following
# is used to selectively ignore shutdown exceptions to avoid
# 'Exception ignored' messages.  See http://bugs.python.org/issue20167
APPLICATION_GONE = "application has been destroyed"

# A binder is a class which binds functions to one type of event. It has two
# methods: bind and unbind, which get a function and a parsed sequence, as
# returned by _parse_sequence(). There are two types of binders:
# _SimpleBinder handles event types with no modifiers and no detail.
# No Python functions are called when no events are binded.
# _ComplexBinder handles event types with modifiers and a detail.
# A Python function is called each time an event is generated.

class _SimpleBinder:
    def __init__(self, type, widget, widgetinst):
        self.type = type
        self.sequence = '<'+_types[type][0]+'>'
        self.widget = widget
        self.widgetinst = widgetinst
        self.bindedfuncs = []
        self.handlerid = None

    def bind(self, triplet, func):
        if not self.handlerid:
            def handler(event, l = self.bindedfuncs, mc_type = self.type):
                event.mc_type = mc_type
                wascalled = {}
                for i in range(len(l)-1, -1, -1):
                    func = l[i]
                    if func not in wascalled:
                        wascalled[func] = True
                        r = func(event)
                        if r:
                            return r
            self.handlerid = self.widget.bind(self.widgetinst,
                                              self.sequence, handler)
        self.bindedfuncs.append(func)

    def unbind(self, triplet, func):
        self.bindedfuncs.remove(func)
        if not self.bindedfuncs:
            self.widget.unbind(self.widgetinst, self.sequence, self.handlerid)
            self.handlerid = None

    def __del__(self):
        if self.handlerid:
            try:
                self.widget.unbind(self.widgetinst, self.sequence,
                        self.handlerid)
            except tkinter.TclError as e:
                if not APPLICATION_GONE in e.args[0]:
                    raise

# An int in range(1 << len(_modifiers)) represents a combination of modifiers
# (if the least significant bit is on, _modifiers[0] is on, and so on).
# _state_subsets gives for each combination of modifiers, or *state*,
# a list of the states which are a subset of it. This list is ordered by the
# number of modifiers is the state - the most specific state comes first.
_states = range(1 << len(_modifiers))
_state_names = [''.join(m[0]+'-'
                        for i, m in enumerate(_modifiers)
                        if (1 << i) & s)
                for s in _states]

def expand_substates(states):
    '''For each item of states return a list containing all combinations of
    that item with individual bits reset, sorted by the number of set bits.
    '''
    def nbits(n):
        "number of bits set in n base 2"
        nb = 0
        while n:
            n, rem = divmod(n, 2)
            nb += rem
        return nb
    statelist = []
    for state in states:
        substates = list(set(state & x for x in states))
        substates.sort(key=nbits, reverse=True)
        statelist.append(substates)
    return statelist

_state_subsets = expand_substates(_states)

# _state_codes gives for each state, the portable code to be passed as mc_state
_state_codes = []
for s in _states:
    r = 0
    for i in range(len(_modifiers)):
        if (1 << i) & s:
            r |= _modifier_masks[i]
    _state_codes.append(r)

class _ComplexBinder:
    # This class binds many functions, and only unbinds them when it is deleted.
    # self.handlerids is the list of seqs and ids of binded handler functions.
    # The binded functions sit in a dictionary of lists of lists, which maps
    # a detail (or None) and a state into a list of functions.
    # When a new detail is discovered, handlers for all the possible states
    # are binded.

    def __create_handler(self, lists, mc_type, mc_state):
        def handler(event, lists = lists,
                    mc_type = mc_type, mc_state = mc_state,
                    ishandlerrunning = self.ishandlerrunning,
                    doafterhandler = self.doafterhandler):
            ishandlerrunning[:] = [True]
            event.mc_type = mc_type
            event.mc_state = mc_state
            wascalled = {}
            r = None
            for l in lists:
                for i in range(len(l)-1, -1, -1):
                    func = l[i]
                    if func not in wascalled:
                        wascalled[func] = True
                        r = l[i](event)
                        if r:
                            break
                if r:
                    break
            ishandlerrunning[:] = []
            # Call all functions in doafterhandler and remove them from list
            for f in doafterhandler:
                f()
            doafterhandler[:] = []
            if r:
                return r
        return handler

    def __init__(self, type, widget, widgetinst):
        self.type = type
        self.typename = _types[type][0]
        self.widget = widget
        self.widgetinst = widgetinst
        self.bindedfuncs = {None: [[] for s in _states]}
        self.handlerids = []
        # we don't want to change the lists of functions while a handler is
        # running - it will mess up the loop and anyway, we usually want the
        # change to happen from the next event. So we have a list of functions
        # for the handler to run after it finishes calling the binded functions.
        # It calls them only once.
        # ishandlerrunning is a list. An empty one means no, otherwise - yes.
        # this is done so that it would be mutable.
        self.ishandlerrunning = []
        self.doafterhandler = []
        for s in _states:
            lists = [self.bindedfuncs[None][i] for i in _state_subsets[s]]
            handler = self.__create_handler(lists, type, _state_codes[s])
            seq = '<'+_state_names[s]+self.typename+'>'
            self.handlerids.append((seq, self.widget.bind(self.widgetinst,
                                                          seq, handler)))

    def bind(self, triplet, func):
        if triplet[2] not in self.bindedfuncs:
            self.bindedfuncs[triplet[2]] = [[] for s in _states]
            for s in _states:
                lists = [ self.bindedfuncs[detail][i]
                          for detail in (triplet[2], None)
                          for i in _state_subsets[s]       ]
                handler = self.__create_handler(lists, self.type,
                                                _state_codes[s])
                seq = "<%s%s-%s>"% (_state_names[s], self.typename, triplet[2])
                self.handlerids.append((seq, self.widget.bind(self.widgetinst,
                                                              seq, handler)))
        doit = lambda: self.bindedfuncs[triplet[2]][triplet[0]].append(func)
        if not self.ishandlerrunning:
            doit()
        else:
            self.doafterhandler.append(doit)

    def unbind(self, triplet, func):
        doit = lambda: self.bindedfuncs[triplet[2]][triplet[0]].remove(func)
        if not self.ishandlerrunning:
            doit()
        else:
            self.doafterhandler.append(doit)

    def __del__(self):
        for seq, id in self.handlerids:
            try:
                self.widget.unbind(self.widgetinst, seq, id)
            except tkinter.TclError as e:
                if not APPLICATION_GONE in e.args[0]:
                    raise

# define the list of event types to be handled by MultiEvent. the order is
# compatible with the definition of event type constants.
_types = (
    ("KeyPress", "Key"), ("KeyRelease",), ("ButtonPress", "Button"),
    ("ButtonRelease",), ("Activate",), ("Circulate",), ("Colormap",),
    ("Configure",), ("Deactivate",), ("Destroy",), ("Enter",), ("Expose",),
    ("FocusIn",), ("FocusOut",), ("Gravity",), ("Leave",), ("Map",),
    ("Motion",), ("MouseWheel",), ("Property",), ("Reparent",), ("Unmap",),
    ("Visibility",),
)

# which binder should be used for every event type?
_binder_classes = (_ComplexBinder,) * 4 + (_SimpleBinder,) * (len(_types)-4)

# A dictionary to map a type name into its number
_type_names = dict([(name, number)
                     for number in range(len(_types))
                     for name in _types[number]])

_keysym_re = re.compile(r"^\w+$")
_button_re = re.compile(r"^[1-5]$")
def _parse_sequence(sequence):
    """Get a string which should describe an event sequence. If it is
    successfully parsed as one, return a tuple containing the state (as an int),
    the event type (as an index of _types), and the detail - None if none, or a
    string if there is one. If the parsing is unsuccessful, return None.
    """
    if not sequence or sequence[0] != '<' or sequence[-1] != '>':
        return None
    words = sequence[1:-1].split('-')
    modifiers = 0
    while words and words[0] in _modifier_names:
        modifiers |= 1 << _modifier_names[words[0]]
        del words[0]
    if words and words[0] in _type_names:
        type = _type_names[words[0]]
        del words[0]
    else:
        return None
    if _binder_classes[type] is _SimpleBinder:
        if modifiers or words:
            return None
        else:
            detail = None
    else:
        # _ComplexBinder
        if type in [_type_names[s] for s in ("KeyPress", "KeyRelease")]:
            type_re = _keysym_re
        else:
            type_re = _button_re

        if not words:
            detail = None
        elif len(words) == 1 and type_re.match(words[0]):
            detail = words[0]
        else:
            return None

    return modifiers, type, detail

def _triplet_to_sequence(triplet):
    if triplet[2]:
        return '<'+_state_names[triplet[0]]+_types[triplet[1]][0]+'-'+ \
               triplet[2]+'>'
    else:
        return '<'+_state_names[triplet[0]]+_types[triplet[1]][0]+'>'

_multicall_dict = {}
def MultiCallCreator(widget):
    """Return a MultiCall class which inherits its methods from the
    given widget class (for example, Tkinter.Text). This is used
    instead of a templating mechanism.
    """
    if widget in _multicall_dict:
        return _multicall_dict[widget]

    class MultiCall (widget):
        assert issubclass(widget, tkinter.Misc)

        def __init__(self, *args, **kwargs):
            widget.__init__(self, *args, **kwargs)
            # a dictionary which maps a virtual event to a tuple with:
            #  0. the function binded
            #  1. a list of triplets - the sequences it is binded to
            self.__eventinfo = {}
            self.__binders = [_binder_classes[i](i, widget, self)
                              for i in range(len(_types))]

        def bind(self, sequence=None, func=None, add=None):
            #print("bind(%s, %s, %s)" % (sequence, func, add),
            #      file=sys.__stderr__)
            if type(sequence) is str and len(sequence) > 2 and \
               sequence[:2] == "<<" and sequence[-2:] == ">>":
                if sequence in self.__eventinfo:
                    ei = self.__eventinfo[sequence]
                    if ei[0] is not None:
                        for triplet in ei[1]:
                            self.__binders[triplet[1]].unbind(triplet, ei[0])
                    ei[0] = func
                    if ei[0] is not None:
                        for triplet in ei[1]:
                            self.__binders[triplet[1]].bind(triplet, func)
                else:
                    self.__eventinfo[sequence] = [func, []]
            return widget.bind(self, sequence, func, add)

        def unbind(self, sequence, funcid=None):
            if type(sequence) is str and len(sequence) > 2 and \
               sequence[:2] == "<<" and sequence[-2:] == ">>" and \
               sequence in self.__eventinfo:
                func, triplets = self.__eventinfo[sequence]
                if func is not None:
                    for triplet in triplets:
                        self.__binders[triplet[1]].unbind(triplet, func)
                    self.__eventinfo[sequence][0] = None
            return widget.unbind(self, sequence, funcid)

        def event_add(self, virtual, *sequences):
            #print("event_add(%s, %s)" % (repr(virtual), repr(sequences)),
            #      file=sys.__stderr__)
            if virtual not in self.__eventinfo:
                self.__eventinfo[virtual] = [None, []]

            func, triplets = self.__eventinfo[virtual]
            for seq in sequences:
                triplet = _parse_sequence(seq)
                if triplet is None:
                    #print("Tkinter event_add(%s)" % seq, file=sys.__stderr__)
                    widget.event_add(self, virtual, seq)
                else:
                    if func is not None:
                        self.__binders[triplet[1]].bind(triplet, func)
                    triplets.append(triplet)

        def event_delete(self, virtual, *sequences):
            if virtual not in self.__eventinfo:
                return
            func, triplets = self.__eventinfo[virtual]
            for seq in sequences:
                triplet = _parse_sequence(seq)
                if triplet is None:
                    #print("Tkinter event_delete: %s" % seq, file=sys.__stderr__)
                    widget.event_delete(self, virtual, seq)
                else:
                    if func is not None:
                        self.__binders[triplet[1]].unbind(triplet, func)
                    triplets.remove(triplet)

        def event_info(self, virtual=None):
            if virtual is None or virtual not in self.__eventinfo:
                return widget.event_info(self, virtual)
            else:
                return tuple(map(_triplet_to_sequence,
                                 self.__eventinfo[virtual][1])) + \
                       widget.event_info(self, virtual)

        def __del__(self):
            for virtual in self.__eventinfo:
                func, triplets = self.__eventinfo[virtual]
                if func:
                    for triplet in triplets:
                        try:
                            self.__binders[triplet[1]].unbind(triplet, func)
                        except tkinter.TclError as e:
                            if not APPLICATION_GONE in e.args[0]:
                                raise

    _multicall_dict[widget] = MultiCall
    return MultiCall


def _multi_call(parent):
    root = tkinter.Tk()
    root.title("Test MultiCall")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    text = MultiCallCreator(tkinter.Text)(root)
    text.pack()
    def bindseq(seq, n=[0]):
        def handler(event):
            print(seq)
        text.bind("<<handler%d>>"%n[0], handler)
        text.event_add("<<handler%d>>"%n[0], seq)
        n[0] += 1
    bindseq("<Key>")
    bindseq("<Control-Key>")
    bindseq("<Alt-Key-a>")
    bindseq("<Control-Key-a>")
    bindseq("<Alt-Control-Key-a>")
    bindseq("<Key-b>")
    bindseq("<Control-Button-1>")
    bindseq("<Button-2>")
    bindseq("<Alt-Button-1>")
    bindseq("<FocusOut>")
    bindseq("<Enter>")
    bindseq("<Leave>")
    root.mainloop()

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_multi_call)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from tkinter import *

class MultiStatusBar(Frame):

    def __init__(self, master=None, **kw):
        if master is None:
            master = Tk()
        Frame.__init__(self, master, **kw)
        self.labels = {}

    def set_label(self, name, text='', side=LEFT, width=0):
        if name not in self.labels:
            label = Label(self, borderwidth=0, anchor=W)
            label.pack(side=side, pady=0, padx=4)
            self.labels[name] = label
        else:
            label = self.labels[name]
        if width != 0:
            label.config(width=width)
        label.config(text=text)

def _multistatus_bar(parent):
    root = Tk()
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d" %(x, y + 150))
    root.title("Test multistatus bar")
    frame = Frame(root)
    text = Text(frame)
    text.pack()
    msb = MultiStatusBar(frame)
    msb.set_label("one", "hello")
    msb.set_label("two", "world")
    msb.pack(side=BOTTOM, fill=X)

    def change():
        msb.set_label("one", "foo")
        msb.set_label("two", "bar")

    button = Button(root, text="Update status", command=change)
    button.pack(side=BOTTOM)
    frame.pack()
    frame.mainloop()
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_multistatus_bar)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # XXX TO DO:
# - popup menu
# - support partial or total redisplay
# - more doc strings
# - tooltips

# object browser

# XXX TO DO:
# - for classes/modules, add "open source" to object browser

import re

from idlelib.TreeWidget import TreeItem, TreeNode, ScrolledCanvas

from reprlib import Repr

myrepr = Repr()
myrepr.maxstring = 100
myrepr.maxother = 100

class ObjectTreeItem(TreeItem):
    def __init__(self, labeltext, object, setfunction=None):
        self.labeltext = labeltext
        self.object = object
        self.setfunction = setfunction
    def GetLabelText(self):
        return self.labeltext
    def GetText(self):
        return myrepr.repr(self.object)
    def GetIconName(self):
        if not self.IsExpandable():
            return "python"
    def IsEditable(self):
        return self.setfunction is not None
    def SetText(self, text):
        try:
            value = eval(text)
            self.setfunction(value)
        except:
            pass
        else:
            self.object = value
    def IsExpandable(self):
        return not not dir(self.object)
    def GetSubList(self):
        keys = dir(self.object)
        sublist = []
        for key in keys:
            try:
                value = getattr(self.object, key)
            except AttributeError:
                continue
            item = make_objecttreeitem(
                str(key) + " =",
                value,
                lambda value, key=key, object=self.object:
                    setattr(object, key, value))
            sublist.append(item)
        return sublist

class ClassTreeItem(ObjectTreeItem):
    def IsExpandable(self):
        return True
    def GetSubList(self):
        sublist = ObjectTreeItem.GetSubList(self)
        if len(self.object.__bases__) == 1:
            item = make_objecttreeitem("__bases__[0] =",
                self.object.__bases__[0])
        else:
            item = make_objecttreeitem("__bases__ =", self.object.__bases__)
        sublist.insert(0, item)
        return sublist

class AtomicObjectTreeItem(ObjectTreeItem):
    def IsExpandable(self):
        return 0

class SequenceTreeItem(ObjectTreeItem):
    def IsExpandable(self):
        return len(self.object) > 0
    def keys(self):
        return range(len(self.object))
    def GetSubList(self):
        sublist = []
        for key in self.keys():
            try:
                value = self.object[key]
            except KeyError:
                continue
            def setfunction(value, key=key, object=self.object):
                object[key] = value
            item = make_objecttreeitem("%r:" % (key,), value, setfunction)
            sublist.append(item)
        return sublist

class DictTreeItem(SequenceTreeItem):
    def keys(self):
        keys = list(self.object.keys())
        try:
            keys.sort()
        except:
            pass
        return keys

dispatch = {
    int: AtomicObjectTreeItem,
    float: AtomicObjectTreeItem,
    str: AtomicObjectTreeItem,
    tuple: SequenceTreeItem,
    list: SequenceTreeItem,
    dict: DictTreeItem,
    type: ClassTreeItem,
}

def make_objecttreeitem(labeltext, object, setfunction=None):
    t = type(object)
    if t in dispatch:
        c = dispatch[t]
    else:
        c = ObjectTreeItem
    return c(labeltext, object, setfunction)


def _object_browser(parent):
    import sys
    from tkinter import Tk
    root = Tk()
    root.title("Test ObjectBrowser")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    root.configure(bd=0, bg="yellow")
    root.focus_set()
    sc = ScrolledCanvas(root, bg="white", highlightthickness=0, takefocus=1)
    sc.frame.pack(expand=1, fill="both")
    item = make_objecttreeitem("sys", sys)
    node = TreeNode(sc.canvas, None, item)
    node.update()
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_object_browser)
                                                                                                                         What's New in IDLE 3.5.3?
=========================
*Release date: 2017-01-01?*

- Issue #15308: Add 'interrupt execution' (^C) to Shell menu.
  Patch by Roger Serwy, updated by Bayard Randel.

- Issue #27922: Stop IDLE tests from 'flashing' gui widgets on the screen.

- Add version to title of IDLE help window.

- Issue #25564: In section on IDLE -- console differences, mention that
  using exec means that __builtins__ is defined for each statement.

- Issue #27714: text_textview and test_autocomplete now pass when re-run
  in the same process.  This occurs when test_idle fails when run with the
  -w option but without -jn.  Fix warning from test_config.

- Issue #25507: IDLE no longer runs buggy code because of its tkinter imports.
  Users must include the same imports required to run directly in Python.

- Issue #27452: add line counter and crc to IDLE configHandler test dump.

- Issue #27365: Allow non-ascii chars in IDLE NEWS.txt, for contributor names.

- Issue #27245: IDLE: Cleanly delete custom themes and key bindings.
  Previously, when IDLE was started from a console or by import, a cascade
  of warnings was emitted.  Patch by Serhiy Storchaka.


What's New in IDLE 3.5.2?
=========================
*Release date: 2016-06-26*

- Issue #5124: Paste with text selected now replaces the selection on X11.
  This matches how paste works on Windows, Mac, most modern Linux apps,
  and ttk widgets.  Original patch by Serhiy Storchaka.

- Issue #24759: Make clear in idlelib.idle_test.__init__ that the directory
  is a private implementation of test.test_idle and tool for maintainers.

- Issue #27196: Stop 'ThemeChangef' warnings when running IDLE tests.
  These persisted after other warnings were suppressed in #20567.
  Apply Serhiy Storchaka's update_idletasks solution to four test files.
  Record this additional advice in idle_test/README.txt

- Issue #20567: Revise idle_test/README.txt with advice about avoiding
  tk warning messages from tests.  Apply advice to several IDLE tests.

- Issue #27117: Make colorizer htest and turtledemo work with dark themes.
  Move code for configuring text widget colors to a new function.

- Issue #26673: When tk reports font size as 0, change to size 10.
  Such fonts on Linux prevented the configuration dialog from opening.

- Issue #21939: Add test for IDLE's percolator.
  Original patch by Saimadhav Heblikar.

- Issue #21676: Add test for IDLE's replace dialog.
  Original patch by Saimadhav Heblikar.

- Issue #18410: Add test for IDLE's search dialog.
  Original patch by Westley Mart√≠nez.

- Issue #21703: Add test for undo delegator.
  Original patch by Saimadhav Heblikar .

- Issue #27044: Add ConfigDialog.remove_var_callbacks to stop memory leaks.

- Issue #23977: Add more asserts to test_delegator.

- Issue #20640: Add tests for idlelib.configHelpSourceEdit.
  Patch by Saimadhav Heblikar.

- In the 'IDLE-console differences' section of the IDLE doc, clarify
  how running with IDLE affects sys.modules and the standard streams.

- Issue #25507: fix incorrect change in IOBinding that prevented printing.
  Augment IOBinding htest to include all major IOBinding functions.

- Issue #25905: Revert unwanted conversion of ' to ‚Äô RIGHT SINGLE QUOTATION
  MARK in README.txt and open this and NEWS.txt with 'ascii'.
  Re-encode CREDITS.txt to utf-8 and open it with 'utf-8'.


What's New in IDLE 3.5.1?
=========================
*Release date: 2015-12-06*

- Issue 15348: Stop the debugger engine (normally in a user process)
  before closing the debugger window (running in the IDLE process).
  This prevents the RuntimeErrors that were being caught and ignored.

- Issue #24455: Prevent IDLE from hanging when a) closing the shell while the
  debugger is active (15347); b) closing the debugger with the [X] button
  (15348); and c) activating the debugger when already active (24455).
  The patch by Mark Roseman does this by making two changes.
  1. Suspend and resume the gui.interaction method with the tcl vwait
  mechanism intended for this purpose (instead of root.mainloop & .quit).
  2. In gui.run, allow any existing interaction to terminate first.

- Change 'The program' to 'Your program' in an IDLE 'kill program?' message
  to make it clearer that the program referred to is the currently running
  user program, not IDLE itself.

- Issue #24750: Improve the appearance of the IDLE editor window status bar.
  Patch by Mark Roseman.

- Issue #25313: Change the handling of new built-in text color themes to better
  address the compatibility problem introduced by the addition of IDLE Dark.
  Consistently use the revised idleConf.CurrentTheme everywhere in idlelib.

- Issue #24782: Extension configuration is now a tab in the IDLE Preferences
  dialog rather than a separate dialog.   The former tabs are now a sorted
  list.  Patch by Mark Roseman.

- Issue #22726: Re-activate the config dialog help button with some content
  about the other buttons and the new IDLE Dark theme.

- Issue #24820: IDLE now has an 'IDLE Dark' built-in text color theme.
  It is more or less IDLE Classic inverted, with a cobalt blue background.
  Strings, comments, keywords, ... are still green, red, orange, ... .
  To use it with IDLEs released before November 2015, hit the
  'Save as New Custom Theme' button and enter a new name,
  such as 'Custom Dark'.  The custom theme will work with any IDLE
  release, and can be modified.

- Issue #25224: README.txt is now an idlelib index for IDLE developers and
  curious users.  The previous user content is now in the IDLE doc chapter.
  'IDLE' now means 'Integrated Development and Learning Environment'.

- Issue #24820: Users can now set breakpoint colors in
  Settings -> Custom Highlighting.  Original patch by Mark Roseman.

- Issue #24972: Inactive selection background now matches active selection
  background, as configured by users, on all systems.  Found items are now
  always highlighted on Windows.  Initial patch by Mark Roseman.

- Issue #24570: Idle: make calltip and completion boxes appear on Macs
  affected by a tk regression.  Initial patch by Mark Roseman.

- Issue #24988: Idle ScrolledList context menus (used in debugger)
  now work on Mac Aqua.  Patch by Mark Roseman.

- Issue #24801: Make right-click for context menu work on Mac Aqua.
  Patch by Mark Roseman.

- Issue #25173: Associate tkinter messageboxes with a specific widget.
  For Mac OSX, make them a 'sheet'.  Patch by Mark Roseman.

- Issue #25198: Enhance the initial html viewer now used for Idle Help.
  * Properly indent fixed-pitch text (patch by Mark Roseman).
  * Give code snippet a very Sphinx-like light blueish-gray background.
  * Re-use initial width and height set by users for shell and editor.
  * When the Table of Contents (TOC) menu is used, put the section header
  at the top of the screen.

- Issue #25225: Condense and rewrite Idle doc section on text colors.

- Issue #21995: Explain some differences between IDLE and console Python.

- Issue #22820: Explain need for *print* when running file from Idle editor.

- Issue #25224: Doc: augment Idle feature list and no-subprocess section.

- Issue #25219: Update doc for Idle command line options.
  Some were missing and notes were not correct.

- Issue #24861: Most of idlelib is private and subject to change.
  Use idleib.idle.* to start Idle. See idlelib.__init__.__doc__.

- Issue #25199: Idle: add synchronization comments for future maintainers.

- Issue #16893: Replace help.txt with help.html for Idle doc display.
  The new idlelib/help.html is rstripped Doc/build/html/library/idle.html.
  It looks better than help.txt and will better document Idle as released.
  The tkinter html viewer that works for this file was written by Mark Roseman.
  The now unused EditorWindow.HelpDialog class and helt.txt file are deprecated.

- Issue #24199: Deprecate unused idlelib.idlever with possible removal in 3.6.

- Issue #24790: Remove extraneous code (which also create 2 & 3 conflicts).


What's New in IDLE 3.5.0?
=========================
*Release date: 2015-09-13*

- Issue #23672: Allow Idle to edit and run files with astral chars in name.
  Patch by Mohd Sanad Zaki Rizvi.

- Issue 24745: Idle editor default font. Switch from Courier to
  platform-sensitive TkFixedFont.  This should not affect current customized
  font selections.  If there is a problem, edit $HOME/.idlerc/config-main.cfg
  and remove 'fontxxx' entries from [Editor Window].  Patch by Mark Roseman.

- Issue #21192: Idle editor. When a file is run, put its name in the restart bar.
  Do not print false prompts. Original patch by Adnan Umer.

- Issue #13884: Idle menus. Remove tearoff lines. Patch by Roger Serwy.

- Issue #23184: remove unused names and imports in idlelib.
  Initial patch by Al Sweigart.

- Issue #20577: Configuration of the max line length for the FormatParagraph
  extension has been moved from the General tab of the Idle preferences dialog
  to the FormatParagraph tab of the Config Extensions dialog.
  Patch by Tal Einat.

- Issue #16893: Update Idle doc chapter to match current Idle and add new
  information.

- Issue #3068: Add Idle extension configuration dialog to Options menu.
  Changes are written to HOME/.idlerc/config-extensions.cfg.
  Original patch by Tal Einat.

- Issue #16233: A module browser (File : Class Browser, Alt+C) requires an
  editor window with a filename.  When Class Browser is requested otherwise,
  from a shell, output window, or 'Untitled' editor, Idle no longer displays
  an error box.  It now pops up an  Open Module box (Alt+M). If a valid name
  is entered and a module is opened, a corresponding browser is also opened.

- Issue #4832: Save As to type Python files automatically adds .py to the
  name you enter (even if your system does not display it).  Some systems
  automatically add .txt when type is Text files.

- Issue #21986: Code objects are not normally pickled by the pickle module.
  To match this, they are no longer pickled when running under Idle.

- Issue #23180: Rename IDLE "Windows" menu item to "Window".
  Patch by Al Sweigart.

- Issue #17390: Adjust Editor window title; remove 'Python',
  move version to end.

- Issue #14105: Idle debugger breakpoints no longer disappear
  when inserting or deleting lines.

- Issue #17172: Turtledemo can now be run from Idle.
  Currently, the entry is on the Help menu, but it may move to Run.
  Patch by Ramchandra Apt and Lita Cho.

- Issue #21765: Add support for non-ascii identifiers to HyperParser.

- Issue #21940: Add unittest for WidgetRedirector. Initial patch by Saimadhav
  Heblikar.

- Issue #18592: Add unittest for SearchDialogBase. Patch by Phil Webster.

- Issue #21694: Add unittest for ParenMatch. Patch by Saimadhav Heblikar.

- Issue #21686: add unittest for HyperParser. Original patch by Saimadhav
  Heblikar.

- Issue #12387: Add missing upper(lower)case versions of default Windows key
  bindings for Idle so Caps Lock does not disable them. Patch by Roger Serwy.

- Issue #21695: Closing a Find-in-files output window while the search is
  still in progress no longer closes Idle.

- Issue #18910: Add unittest for textView. Patch by Phil Webster.

- Issue #18292: Add unittest for AutoExpand. Patch by Saihadhav Heblikar.

- Issue #18409: Add unittest for AutoComplete. Patch by Phil Webster.

- Issue #21477: htest.py - Improve framework, complete set of tests.
  Patches by Saimadhav Heblikar

- Issue #18104: Add idlelib/idle_test/htest.py with a few sample tests to begin
  consolidating and improving human-validated tests of Idle. Change other files
  as needed to work with htest.  Running the module as __main__ runs all tests.

- Issue #21139: Change default paragraph width to 72, the PEP 8 recommendation.

- Issue #21284: Paragraph reformat test passes after user changes reformat width.

- Issue #17654: Ensure IDLE menus are customized properly on OS X for
  non-framework builds and for all variants of Tk.


What's New in IDLE 3.4.0?
=========================
*Release date: 2014-03-16*

- Issue #17390: Display Python version on Idle title bar.
  Initial patch by Edmond Burnett.

- Issue #5066: Update IDLE docs. Patch by Todd Rovito.

- Issue #17625: Close the replace dialog after it is used.

- Issue #16226: Fix IDLE Path Browser crash.
  (Patch by Roger Serwy)

- Issue #15853: Prevent IDLE crash on OS X when opening Preferences menu
  with certain versions of Tk 8.5.  Initial patch by Kevin Walzer.


What's New in IDLE 3.3.0?
=========================
*Release date: 2012-09-29*

- Issue #17625: Close the replace dialog after it is used.

- Issue #7163: Propagate return value of sys.stdout.write.

- Issue #15318: Prevent writing to sys.stdin.

- Issue #4832: Modify IDLE to save files with .py extension by
  default on Windows and OS X (Tk 8.5) as it already does with X11 Tk.

- Issue #13532, #15319: Check that arguments to sys.stdout.write are strings.

- Issue # 12510: Attempt to get certain tool tips no longer crashes IDLE.
  Erroneous tool tips have been corrected. Default added for callables.

- Issue #10365: File open dialog now works instead of crashing even when
  parent window is closed while dialog is open.

- Issue 14876: use user-selected font for highlight configuration.

- Issue #14937: Perform auto-completion of filenames in strings even for
  non-ASCII filenames. Likewise for identifiers.

- Issue #8515: Set __file__ when run file in IDLE.
  Initial patch by Bruce Frederiksen.

- IDLE can be launched as `python -m idlelib`

- Issue #14409: IDLE now properly executes commands in the Shell window
  when it cannot read the normal config files on startup and
  has to use the built-in default key bindings.
  There was previously a bug in one of the defaults.

- Issue #3573: IDLE hangs when passing invalid command line args
  (directory(ies) instead of file(s)).

- Issue #14018: Update checks for unstable system Tcl/Tk versions on OS X
  to include versions shipped with OS X 10.7 and 10.8 in addition to 10.6.


What's New in IDLE 3.2.1?
=========================
*Release date: 15-May-11*

- Issue #6378: Further adjust idle.bat to start associated Python

- Issue #11896: Save on Close failed despite selecting "Yes" in dialog.

- Issue #1028: Ctrl-space binding to show completions was causing IDLE to exit.
  Tk < 8.5 was sending invalid Unicode null; replaced with valid null.

- Issue #4676: <Home> toggle failing on Tk 8.5, causing IDLE exits and strange selection
  behavior. Improve selection extension behaviour.

- Issue #3851: <Home> toggle non-functional when NumLock set on Windows.


What's New in IDLE 3.1b1?
=========================
*Release date: 06-May-09*

- Issue #5707: Use of 'filter' in keybindingDialog.py was causing custom key assignment to
  fail.  Patch by Amaury Forgeot d'Arc.

- Issue #4815: Offer conversion to UTF-8 if source files have
  no encoding declaration and are not encoded in UTF-8.

- Issue #4008: Fix problems with non-ASCII source files.

- Issue #4323: Always encode source as UTF-8 without asking
  the user (unless a different encoding is declared); remove
  user configuration of source encoding; all according to
  PEP 3120.

- Issue #2665: On Windows, an IDLE installation upgraded from an old version
  would not start if a custom theme was defined.

------------------------------------------------------------------------
Refer to NEWS2x.txt and HISTORY.txt for information on earlier releases.
------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                What's New in IDLE 2.7? (Merged into 3.1 before 2.7 release.)
=======================
*Release date: XX-XXX-2010*

- idle.py modified and simplified to better support developing experimental
  versions of IDLE which are not installed in the standard location.

- OutputWindow/PyShell right click menu "Go to file/line" wasn't working with
  file paths containing spaces.  Bug 5559.

- Windows: Version string for the .chm help file changed, file not being
  accessed  Patch 5783 Guilherme Polo

- Allow multiple IDLE GUI/subprocess pairs to exist simultaneously. Thanks to
  David Scherer for suggesting the use of an ephemeral port for the GUI.
  Patch 1529142 Weeble.

- Remove port spec from run.py and fix bug where subprocess fails to
  extract port from command line when warnings are present.

- Tk 8.5 Text widget requires 'wordprocessor' tabstyle attr to handle
  mixed space/tab properly. Issue 5129, patch by Guilherme Polo.

- Issue #3549: On MacOS the preferences menu was not present

- IDLE would print a "Unhandled server exception!" message when internal
  debugging is enabled.

- Issue #4455: IDLE failed to display the windows list when two windows have
  the same title.

- Issue #4383: When IDLE cannot make the connection to its subprocess, it would
  fail to properly display the error message.

- help() was not paging to the shell.  Issue1650.

- CodeContext was not importing.

- Corrected two 3.0 compatibility errors reported by Mark Summerfield:
  http://mail.python.org/pipermail/python-3000/2007-December/011491.html

- Shell was not colorizing due to bug introduced at r57998,  Bug 1586.

- Issue #1585: IDLE uses non-existent xrange() function.

- Windows EOL sequence not converted correctly, encoding error.
  Caused file save to fail. Bug 1130.

- IDLE converted to Python 3000 syntax.

- Strings became Unicode.

- CallTips module now uses the inspect module to produce the argspec.

- IDLE modules now use absolute import instead of implied relative import.

- atexit call replaces sys.exitfunc.  The functionality of delete-exitfunc flag
  in config-main.cfg remains unchanged: if set, registered exit functions will
  be cleared before IDLE exits.


What's New in IDLE 2.6
======================
*Release date: 01-Oct-2008*, merged into 3.0 releases detailed above (3.0rc2)

- Issue #2665: On Windows, an IDLE installation upgraded from an old version
  would not start if a custom theme was defined.

- Home / Control-A toggles between left margin and end of leading white
  space.  issue1196903, patch by Jeff Shute.

- Improved AutoCompleteWindow logic.  issue2062, patch by Tal Einat.

- Autocompletion of filenames now support alternate separators, e.g. the
  '/' char on Windows.  issue2061 Patch by Tal Einat.

- Configured selection highlighting colors were ignored; updating highlighting
  in the config dialog would cause non-Python files to be colored as if they
  were Python source; improve use of ColorDelagator.  Patch 1334. Tal Einat.

- ScriptBinding event handlers weren't returning 'break'. Patch 2050, Tal Einat

- There was an error on exit if no sys.exitfunc was defined. Issue 1647.

- Could not open files in .idlerc directory if latter was hidden on Windows.
  Issue 1743, Issue 1862.

- Configure Dialog: improved layout for keybinding.  Patch 1457 Tal Einat.

- tabpage.py updated: tabbedPages.py now supports multiple dynamic rows
  of tabs.  Patch 1612746 Tal Einat.

- Add confirmation dialog before printing.  Patch 1717170 Tal Einat.

- Show paste position if > 80 col.  Patch 1659326 Tal Einat.

- Update cursor color without restarting.  Patch 1725576 Tal Einat.

- Allow keyboard interrupt only when user code is executing in subprocess.
  Patch 1225 Tal Einat (reworked from IDLE-Spoon).

- configDialog cleanup. Patch 1730217 Tal Einat.

- textView cleanup. Patch 1718043 Tal Einat.

- Clean up EditorWindow close.

- Patch 1693258: Fix for duplicate "preferences" menu-OS X. Backport of r56204.

- OSX: Avoid crash for those versions of Tcl/Tk which don't have a console

- Bug in idlelib.MultiCall: Options dialog was crashing IDLE if there was an
  option in config-extensions w/o a value. Patch #1672481, Tal Einat

- Corrected some bugs in AutoComplete.  Also, Page Up/Down in ACW implemented;
  mouse and cursor selection in ACWindow implemented; double Tab inserts
  current selection and closes ACW (similar to double-click and Return); scroll
  wheel now works in ACW.  Added AutoComplete instructions to IDLE Help.

- AutoCompleteWindow moved below input line, will move above if there
  isn't enough space.  Patch 1621265 Tal Einat

- Calltips now 'handle' tuples in the argument list (display '<tuple>' :)
  Suggested solution by Christos Georgiou, Bug 791968.

- Add 'raw' support to configHandler. Patch 1650174 Tal Einat.

- Avoid hang when encountering a duplicate in a completion list. Bug 1571112.

- Patch #1362975: Rework CodeContext indentation algorithm to
  avoid hard-coding pixel widths.

- Bug #813342: Start the IDLE subprocess with -Qnew if the parent
  is started with that option.

- Honor the "Cancel" action in the save dialog (Debian bug #299092)

- Some syntax errors were being caught by tokenize during the tabnanny
  check, resulting in obscure error messages.  Do the syntax check
  first.  Bug 1562716, 1562719

- IDLE's version number takes a big jump to match the version number of
  the Python release of which it's a part.


What's New in IDLE 1.2?
=======================
*Release date: 19-SEP-2006*

- File menu hotkeys: there were three 'p' assignments.  Reassign the
  'Save Copy As' and 'Print' hotkeys to 'y' and 't'.  Change the
  Shell hotkey from 's' to 'l'.

- IDLE honors new quit() and exit() commands from site.py Quitter() object.
  Patch 1540892, Jim Jewett

- The 'with' statement is now a Code Context block opener.
  Patch 1540851, Jim Jewett

- Retrieval of previous shell command was not always preserving indentation
  (since 1.2a1) Patch 1528468 Tal Einat.

- Changing tokenize (39046) to detect dedent broke tabnanny check (since 1.2a1)

- ToggleTab dialog was setting indent to 8 even if cancelled (since 1.2a1).

- When used w/o subprocess, all exceptions were preceded by an error
  message claiming they were IDLE internal errors (since 1.2a1).

- Bug #1525817: Don't truncate short lines in IDLE's tool tips.

- Bug #1517990: IDLE keybindings on MacOS X now work correctly

- Bug #1517996: IDLE now longer shows the default Tk menu when a
  path browser, class browser or debugger is the frontmost window on MacOS X

- EditorWindow.test() was failing.  Bug 1417598

- EditorWindow failed when used stand-alone if sys.ps1 not set.
  Bug 1010370 Dave Florek

- Tooltips failed on new-syle class __init__ args.  Bug 1027566 Loren Guthrie

- Avoid occasional failure to detect closing paren properly.
  Patch 1407280 Tal Einat

- Rebinding Tab key was inserting 'tab' instead of 'Tab'.  Bug 1179168.

- Colorizer now handles #<builtin> correctly, also unicode strings and
  'as' keyword in comment directly following import command. Closes 1325071.
  Patch 1479219 Tal Einat

- Patch #1162825: Support non-ASCII characters in IDLE window titles.

- Source file f.flush() after writing; trying to avoid lossage if user
  kills GUI.

- Options / Keys / Advanced dialog made functional.  Also, allow binding
  of 'movement' keys.

- 'syntax' patch adds improved calltips and a new class attribute listbox.
  MultiCall module allows binding multiple actions to an event.
  Patch 906702 Noam Raphael

- Better indentation after first line of string continuation.
  IDLEfork Patch 681992, Noam Raphael

- Fixed CodeContext alignment problem, following suggestion from Tal Einat.

- Increased performance in CodeContext extension  Patch 936169 Noam Raphael

- Mac line endings were incorrect when pasting code from some browsers
  when using X11 and the Fink distribution.  Python Bug 1263656.

- <Enter> when cursor is on a previous command retrieves that command.  Instead
  of replacing the input line, the previous command is now appended to the
  input line. Indentation is preserved, and undo is enabled.
  Patch 1196917  Jeff Shute

- Clarify "tab/space" Error Dialog and "Tab Width" Dialog associated with
  the Untabify command.

- Corrected "tab/space" Error Dialog to show correct menu for Untabify.
  Patch 1196980 Jeff Shute

- New files are colorized by default, and colorizing is removed when
  saving as non-Python files. Patch 1196895 Jeff Shute
  Closes Python Bugs 775012 and 800432, partial fix IDLEfork 763524

- Improve subprocess link error notification.

- run.py: use Queue's blocking feature instead of sleeping in the main
  loop.  Patch # 1190163 Michiel de Hoon

- Add config-main option to make the 'history' feature non-cyclic.
  Default remains cyclic.  Python Patch 914546 Noam Raphael.

- Removed ability to configure tabs indent from Options dialog.  This 'feature'
  has never worked and no one has complained.  It is still possible to set a
  default tabs (v. spaces) indent 'manually' via config-main.def (or to turn on
  tabs for the current EditorWindow via the Format menu) but IDLE will
  encourage indentation via spaces.

- Enable setting the indentation width using the Options dialog.
  Bug # 783877

- Add keybindings for del-word-left and del-word-right.

- Discourage using an indent width other than 8 when using tabs to indent
  Python code.

- Restore use of EditorWindow.set_indentation_params(), was dead code since
  Autoindent was merged into EditorWindow.  This allows IDLE to conform to the
  indentation width of a loaded file.  (But it still will not switch to tabs
  even if the file uses tabs.)  Any change in indent width is local to that
  window.

- Add Tabnanny check before Run/F5, not just when Checking module.

- If an extension can't be loaded, print warning and skip it instead of
  erroring out.

- Improve error handling when .idlerc can't be created (warn and exit).

- The GUI was hanging if the shell window was closed while a raw_input()
  was pending.  Restored the quit() of the readline() mainloop().
  http://mail.python.org/pipermail/idle-dev/2004-December/002307.html

- The remote procedure call module rpc.py can now access data attributes of
  remote registered objects.  Changes to these attributes are local, however.


What's New in IDLE 1.1?
=======================
*Release date: 30-NOV-2004*

- On OpenBSD, terminating IDLE with ctrl-c from the command line caused a
  stuck subprocess MainThread because only the SocketThread was exiting.

- Saving a Keyset w/o making changes (by using the "Save as New Custom Key Set"
  button) caused IDLE to fail on restart (no new keyset was created in
  config-keys.cfg).  Also true for Theme/highlights.  Python Bug 1064535.

- A change to the linecache.py API caused IDLE to exit when an exception was
  raised while running without the subprocess (-n switch).  Python Bug 1063840.

- When paragraph reformat width was made configurable, a bug was
  introduced that caused reformatting of comment blocks to ignore how
  far the block was indented, effectively adding the indentation width
  to the reformat width.  This has been repaired, and the reformat
  width is again a bound on the total width of reformatted lines.

- Improve keyboard focus binding, especially in Windows menu.  Improve
  window raising, especially in the Windows menu and in the debugger.
  IDLEfork 763524.

- If user passes a non-existent filename on the commandline, just
  open a new file, don't raise a dialog.  IDLEfork 854928.

- EditorWindow.py was not finding the .chm help file on Windows.  Typo
  at Rev 1.54.  Python Bug 990954

- checking sys.platform for substring 'win' was breaking IDLE docs on Mac
  (darwin).  Also, Mac Safari browser requires full file:// URIs.  SF 900580.

- Redirect the warning stream to the shell during the ScriptBinding check of
  user code and format the warning similarly to an exception for both that
  check and for runtime warnings raised in the subprocess.

- CodeContext hint pane visibility state is now persistent across sessions.
  The pane no longer appears in the shell window.  Added capability to limit
  extensions to shell window or editor windows.  Noam Raphael addition
  to Patch 936169.

- Paragraph reformat width is now a configurable parameter in the
  Options GUI.

- New Extension: CodeContext.  Provides block structuring hints for code
  which has scrolled above an edit window. Patch 936169 Noam Raphael.

- If nulls somehow got into the strings in recent-files.lst
  EditorWindow.update_recent_files_list() was failing.  Python Bug 931336.

- If the normal background is changed via Configure/Highlighting, it will
  update immediately, thanks to the previously mentioned patch by Nigel Rowe.

- Add a highlight theme for builtin keywords.  Python Patch 805830 Nigel Rowe
  This also fixed IDLEfork bug [ 693418 ] Normal text background color not
  refreshed and Python bug [897872 ] Unknown color name on HP-UX

- rpc.py:SocketIO - Large modules were generating large pickles when downloaded
  to the execution server.  The return of the OK response from the subprocess
  initialization was interfering and causing the sending socket to be not
  ready.  Add an IO ready test to fix this.  Moved the polling IO ready test
  into pollpacket().

- Fix typo in rpc.py, s/b "pickle.PicklingError" not "pickle.UnpicklingError".

- Added a Tk error dialog to run.py inform the user if the subprocess can't
  connect to the user GUI process.  Added a timeout to the GUI's listening
  socket.  Added Tk error dialogs to PyShell.py to announce a failure to bind
  the port or connect to the subprocess.  Clean up error handling during
  connection initiation phase.  This is an update of Python Patch 778323.

- Print correct exception even if source file changed since shell was
  restarted.  IDLEfork Patch 869012 Noam Raphael

- Keybindings with the Shift modifier now work correctly.  So do bindings which
  use the Space key.  Limit unmodified user keybindings to the function keys.
  Python Bug 775353, IDLEfork Bugs 755647, 761557

- After an exception, run.py was not setting the exception vector. Noam
  Raphael suggested correcting this so pdb's postmortem pm() would work.
  IDLEfork Patch 844675

- IDLE now does not fail to save the file anymore if the Tk buffer is not a
  Unicode string, yet eol_convention is.  Python Bugs 774680, 788378

- IDLE didn't start correctly when Python was installed in "Program Files" on
  W2K and XP.  Python Bugs 780451, 784183

- config-main.def documentation incorrectly referred to idle- instead of
  config-  filenames.  SF 782759  Also added note about .idlerc location.


What's New in IDLE 1.0?
=======================
*Release date: 29-Jul-2003*

- Added a banner to the shell discussing warnings possibly raised by personal
  firewall software.  Added same comment to README.txt.

- Calltip error when docstring was None  Python Bug 775541

- Updated extend.txt, help.txt, and config-extensions.def to correctly
  reflect the current status of the configuration system.  Python Bug 768469

- Fixed: Call Tip Trimming May Loop Forever. Python Patch 769142 (Daniels)

- Replaced apply(f, args, kwds) with f(*args, **kwargs) to improve performance
  Python Patch 768187

- Break or continue statements outside a loop were causing IDLE crash
  Python Bug 767794

- Convert Unicode strings from readline to IOBinding.encoding.  Also set
  sys.std{in|out|err}.encoding, for both the local and the subprocess case.
  SF IDLEfork patch 682347.

- Extend AboutDialog.ViewFile() to support file encodings.  Make the CREDITS
  file Latin-1.

- Updated the About dialog to reflect re-integration into Python.  Provide
  buttons to display Python's NEWS, License, and Credits, plus additional
  buttons for IDLE's README and NEWS.

- TextViewer() now has a third parameter which allows inserting text into the
  viewer instead of reading from a file.

- (Created the .../Lib/idlelib directory in the Python CVS, which is a clone of
  IDLEfork modified to install in the Python environment.  The code in the
  interrupt module has been moved to thread.interrupt_main(). )

- Printing the Shell window was failing if it was not saved first SF 748975

- When using the Search in Files dialog, if the user had a selection
  highlighted in his Editor window, insert it into the dialog search field.

- The Python Shell entry was disappearing from the Windows menu.

- Update the Windows file list when a file name change occurs

- Change to File / Open Module: always pop up the dialog, using the current
  selection as the default value.  This is easier to use habitually.

- Avoided a problem with starting the subprocess when 'localhost' doesn't
  resolve to the user's loopback interface.  SF 747772

- Fixed an issue with highlighted errors never de-colorizing.  SF 747677.  Also
  improved notification of Tabnanny Token Error.

- File / New will by default save in the directory of the Edit window from
  which it was initiated.  SF 748973 Guido van Rossum patch.


What's New in IDLEfork 0.9b1?
=============================
*Release date: 02-Jun-2003*

- The current working directory of the execution environment (and shell
  following completion of execution) is now that of the module being run.

- Added the delete-exitfunc option to config-main.def.  (This option is not
  included in the Options dialog.)  Setting this to True (the default) will
  cause IDLE to not run sys.exitfunc/atexit when the subprocess exits.

- IDLE now preserves the line ending codes when editing a file produced on
  a different platform. SF 661759,  SF 538584

- Reduced default editor font size to 10 point and increased window height
  to provide a better initial impression on Windows.

- Options / Fonts/Tabs / Set Base Editor Font: List box was not highlighting
  the default font when first installed on Windows.  SF 661676

- Added Autosave feature: when user runs code from edit window, if the file
  has been modified IDLE will silently save it if Autosave is enabled.  The
  option is set in the Options dialog, and the default is to prompt the
  user to save the file.   SF 661318 Bruce Sherwood patch.

- Improved the RESTART annotation in the shell window when the user restarts
  the shell while it is generating output.  Also improved annotation when user
  repeatedly hammers the Ctrl-F6 restart.

- Allow IDLE to run when not installed and cwd is not the IDLE directory
  SF Patch 686254 "Run IDLEfork from any directory without set-up" - Raphael

- When a module is run from an EditorWindow: if its directory is not in
  sys.path, prepend it.  This allows the module to import other modules in
  the same directory.  Do the same for a script run from the command line.

- Correctly restart the subprocess if it is running user code and the user
  attempts to run some other module or restarts the shell.  Do the same if
  the link is broken and it is possible to restart the subprocess and re-
  connect to the GUI.   SF RFE 661321.

- Improved exception reporting when running commands or scripts from the
  command line.

- Added a -n command line switch to start IDLE without the subprocess.
  Removed the Shell menu when running in that mode.  Updated help messages.

- Added a comment to the shell startup header to indicate when IDLE is not
  using the subprocess.

- Restore the ability to run without the subprocess.  This can be important for
  some platforms or configurations.  (Running without the subprocess allows the
  debugger to trace through parts of IDLE itself, which may or may not be
  desirable, depending on your point of view.  In addition, the traditional
  reload/import tricks must be use if user source code is changed.)  This is
  helpful for developing IDLE using IDLE, because one instance can be used to
  edit the code and a separate instance run to test changes.  (Multiple
  concurrent IDLE instances with subprocesses is a future feature)

- Improve the error message a user gets when saving a file with non-ASCII
  characters and no source encoding is specified.  Done by adding a dialog
  'EncodingMessage', which contains the line to add in a fixed-font entry
  widget, and which has a button to add that line to the file automatically.
  Also, add a configuration option 'EditorWindow/encoding', which has three
  possible values: none, utf-8, and locale. None is the default: IDLE will show
  this dialog when non-ASCII characters are encountered. utf-8 means that files
  with non-ASCII characters are saved as utf-8-with-bom. locale means that
  files are saved in the locale's encoding; the dialog is only displayed if the
  source contains characters outside the locale's charset.  SF 710733 - Loewis

- Improved I/O response by tweaking the wait parameter in various
  calls to signal.signal().

- Implemented a threaded subprocess which allows interrupting a pass
  loop in user code using the 'interrupt' extension.  User code runs
  in MainThread, while the RPCServer is handled by SockThread.  This is
  necessary because Windows doesn't support signals.

- Implemented the 'interrupt' extension module, which allows a subthread
  to raise a KeyboardInterrupt in the main thread.

- Attempting to save the shell raised an error related to saving
  breakpoints, which are not implemented in the shell

- Provide a correct message when 'exit' or 'quit' are entered at the
  IDLE command prompt  SF 695861

- Eliminate extra blank line in shell output caused by not flushing
  stdout when user code ends with an unterminated print. SF 695861

- Moved responsibility for exception formatting (i.e. pruning IDLE internal
  calls) out of rpc.py into the client and server.

- Exit IDLE cleanly even when doing subprocess I/O

- Handle subprocess interrupt with an RPC message.

- Restart the subprocess if it terminates itself. (VPython programs do that)

- Support subclassing of exceptions, including in the shell, by moving the
  exception formatting to the subprocess.


What's New in IDLEfork 0.9 Alpha 2?
===================================
*Release date: 27-Jan-2003*

- Updated INSTALL.txt to claify use of the python2 rpm.

- Improved formatting in IDLE Help.

- Run menu: Replace "Run Script" with "Run Module".

- Code encountering an unhandled exception under the debugger now shows
  the correct traceback, with IDLE internal levels pruned out.

- If an exception occurs entirely in IDLE, don't prune the IDLE internal
  modules from the traceback displayed.

- Class Browser and Path Browser now use Alt-Key-2 for vertical zoom.

- IDLE icons will now install correctly even when setup.py is run from the
  build directory

- Class Browser now compatible with Python2.3 version of pyclbr.py

- Left cursor move in presence of selected text now moves from left end
  of the selection.

- Add Meta keybindings to "IDLE Classic Windows" to handle reversed
  Alt/Meta on some Linux distros.

- Change default: IDLE now starts with Python Shell.

- Removed the File Path from the Additional Help Sources scrolled list.

- Add capability to access Additional Help Sources on the web if the
  Help File Path begins with //http or www.  (Otherwise local path is
  validated, as before.)

- Additional Help Sources were not being posted on the Help menu in the
  order entered.  Implement sorting the list by [HelpFiles] 'option'
  number.

- Add Browse button to New Help Source dialog.  Arrange to start in
  Python/Doc if platform is Windows, otherwise start in current directory.

- Put the Additional Help Sources directly on the Help menu instead of in
  an Extra Help cascade menu.  Rearrange the Help menu so the Additional
  Help Sources come last.  Update help.txt appropriately.

- Fix Tk root pop-ups in configSectionNameDialog.py  and configDialog.py

- Uniform capitalization in General tab of ConfigDialog, update the doc string.

- Fix bug in ConfigDialog where SaveAllChangedConfig() was unexpectedly
  deleting Additional Help Sources from the user's config file.

- Make configHelpSourceEdit OK button the default and bind <Return>

- Fix Tk root pop-ups in configHelpSourceEdit: error dialogs not attached
  to parents.

- Use os.startfile() to open both Additional Help and Python Help on the
  Windows platform.  The application associated with the file type will act as
  the viewer.  Windows help files (.chm) are now supported via the
  Settings/General/Additional Help facility.

- If Python Help files are installed locally on Linux, use them instead of
  accessing python.org.

- Make the methods for finding the Python help docs more robust, and make
  them work in the installed configuration, also.

- On the Save Before Run dialog, make the OK button the default.  One
  less mouse action!

- Add a method: EditorWindow.get_geometry() for future use in implementing
  window location persistence.

- Removed the "Help/Advice" menu entry.  Thanks, David!  We'll remember!

- Change the "Classic Windows" theme's paste key to be <ctrl-v>.

- Rearrange the Shell menu to put Stack Viewer entries adjacent.

- Add the ability to restart the subprocess interpreter from the shell window;
  add an associated menu entry "Shell/Restart" with binding Control-F6.  Update
  IDLE help.

- Upon a restart, annotate the shell window with a "restart boundary".  Add a
  shell window menu "Shell/View Restart" with binding F6 to jump to the most
  recent restart boundary.

- Add Shell menu to Python Shell; change "Settings" to "Options".

- Remove incorrect comment in setup.py: IDLEfork is now installed as a package.

- Add INSTALL.txt, HISTORY.txt, NEWS.txt to installed configuration.

- In installer text, fix reference to Visual Python, should be VPython.
  Properly credit David Scherer.

- Modified idle, idle.py, idle.pyw to improve exception handling.


What's New in IDLEfork 0.9 Alpha 1?
===================================
*Release date: 31-Dec-2002*

- First release of major new functionality.  For further details refer to
  Idle-dev and/or the Sourceforge CVS.

- Adapted to the Mac platform.

- Overhauled the IDLE startup options and revised the idle -h help message,
  which provides details of command line usage.

- Multiple bug fixes and usability enhancements.

- Introduced the new RPC implementation, which includes a debugger.  The output
  of user code is to the shell, and the shell may be used to inspect the
  environment after the run has finished.  (In version 0.8.1 the shell
  environment was separate from the environment of the user code.)

- Introduced the configuration GUI and a new About dialog.

- Removed David Scherer's Remote Procedure Call code and replaced with Guido
  van Rossum's.  GvR code has support for the IDLE debugger and uses the shell
  to inspect the environment of code Run from an Edit window.  Files removed:
  ExecBinding.py, loader.py, protocol.py, Remote.py, spawn.py

--------------------------------------------------------------------
Refer to HISTORY.txt for additional information on earlier releases.
--------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            import os
import sys
import importlib.machinery

from idlelib.TreeWidget import TreeItem
from idlelib.ClassBrowser import ClassBrowser, ModuleBrowserTreeItem
from idlelib.PyShell import PyShellFileList


class PathBrowser(ClassBrowser):

    def __init__(self, flist, _htest=False):
        """
        _htest - bool, change box location when running htest
        """
        self._htest = _htest
        self.init(flist)

    def settitle(self):
        "Set window titles."
        self.top.wm_title("Path Browser")
        self.top.wm_iconname("Path Browser")

    def rootnode(self):
        return PathBrowserTreeItem()

class PathBrowserTreeItem(TreeItem):

    def GetText(self):
        return "sys.path"

    def GetSubList(self):
        sublist = []
        for dir in sys.path:
            item = DirBrowserTreeItem(dir)
            sublist.append(item)
        return sublist

class DirBrowserTreeItem(TreeItem):

    def __init__(self, dir, packages=[]):
        self.dir = dir
        self.packages = packages

    def GetText(self):
        if not self.packages:
            return self.dir
        else:
            return self.packages[-1] + ": package"

    def GetSubList(self):
        try:
            names = os.listdir(self.dir or os.curdir)
        except OSError:
            return []
        packages = []
        for name in names:
            file = os.path.join(self.dir, name)
            if self.ispackagedir(file):
                nn = os.path.normcase(name)
                packages.append((nn, name, file))
        packages.sort()
        sublist = []
        for nn, name, file in packages:
            item = DirBrowserTreeItem(file, self.packages + [name])
            sublist.append(item)
        for nn, name in self.listmodules(names):
            item = ModuleBrowserTreeItem(os.path.join(self.dir, name))
            sublist.append(item)
        return sublist

    def ispackagedir(self, file):
        " Return true for directories that are packages."
        if not os.path.isdir(file):
            return False
        init = os.path.join(file, "__init__.py")
        return os.path.exists(init)

    def listmodules(self, allnames):
        modules = {}
        suffixes = importlib.machinery.EXTENSION_SUFFIXES[:]
        suffixes += importlib.machinery.SOURCE_SUFFIXES
        suffixes += importlib.machinery.BYTECODE_SUFFIXES
        sorted = []
        for suff in suffixes:
            i = -len(suff)
            for name in allnames[:]:
                normed_name = os.path.normcase(name)
                if normed_name[i:] == suff:
                    mod_name = name[:i]
                    if mod_name not in modules:
                        modules[mod_name] = None
                        sorted.append((normed_name, name))
                        allnames.remove(name)
        sorted.sort()
        return sorted

def _path_browser(parent):  # htest #
    flist = PyShellFileList(parent)
    PathBrowser(flist, _htest=True)
    parent.mainloop()

if __name__ == "__main__":
    from unittest import main
    main('idlelib.idle_test.test_pathbrowser', verbosity=2, exit=False)

    from idlelib.idle_test.htest import run
    run(_path_browser)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from tkinter import *
from idlelib.EditorWindow import EditorWindow
import re
import tkinter.messagebox as tkMessageBox
from idlelib import IOBinding

class OutputWindow(EditorWindow):

    """An editor window that can serve as an output file.

    Also the future base class for the Python shell window.
    This class has no input facilities.
    """

    def __init__(self, *args):
        EditorWindow.__init__(self, *args)
        self.text.bind("<<goto-file-line>>", self.goto_file_line)

    # Customize EditorWindow

    def ispythonsource(self, filename):
        # No colorization needed
        return 0

    def short_title(self):
        return "Output"

    def maybesave(self):
        # Override base class method -- don't ask any questions
        if self.get_saved():
            return "yes"
        else:
            return "no"

    # Act as output file

    def write(self, s, tags=(), mark="insert"):
        if isinstance(s, (bytes, bytes)):
            s = s.decode(IOBinding.encoding, "replace")
        self.text.insert(mark, s, tags)
        self.text.see(mark)
        self.text.update()
        return len(s)

    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def flush(self):
        pass

    # Our own right-button menu

    rmenu_specs = [
        ("Cut", "<<cut>>", "rmenu_check_cut"),
        ("Copy", "<<copy>>", "rmenu_check_copy"),
        ("Paste", "<<paste>>", "rmenu_check_paste"),
        (None, None, None),
        ("Go to file/line", "<<goto-file-line>>", None),
    ]

    file_line_pats = [
        # order of patterns matters
        r'file "([^"]*)", line (\d+)',
        r'([^\s]+)\((\d+)\)',
        r'^(\s*\S.*?):\s*(\d+):',  # Win filename, maybe starting with spaces
        r'([^\s]+):\s*(\d+):',     # filename or path, ltrim
        r'^\s*(\S.*?):\s*(\d+):',  # Win abs path with embedded spaces, ltrim
    ]

    file_line_progs = None

    def goto_file_line(self, event=None):
        if self.file_line_progs is None:
            l = []
            for pat in self.file_line_pats:
                l.append(re.compile(pat, re.IGNORECASE))
            self.file_line_progs = l
        # x, y = self.event.x, self.event.y
        # self.text.mark_set("insert", "@%d,%d" % (x, y))
        line = self.text.get("insert linestart", "insert lineend")
        result = self._file_line_helper(line)
        if not result:
            # Try the previous line.  This is handy e.g. in tracebacks,
            # where you tend to right-click on the displayed source line
            line = self.text.get("insert -1line linestart",
                                 "insert -1line lineend")
            result = self._file_line_helper(line)
            if not result:
                tkMessageBox.showerror(
                    "No special line",
                    "The line you point at doesn't look like "
                    "a valid file name followed by a line number.",
                    parent=self.text)
                return
        filename, lineno = result
        edit = self.flist.open(filename)
        edit.gotoline(lineno)

    def _file_line_helper(self, line):
        for prog in self.file_line_progs:
            match = prog.search(line)
            if match:
                filename, lineno = match.group(1, 2)
                try:
                    f = open(filename, "r")
                    f.close()
                    break
                except OSError:
                    continue
        else:
            return None
        try:
            return filename, int(lineno)
        except TypeError:
            return None

# These classes are currently not used but might come in handy

class OnDemandOutputWindow:

    tagdefs = {
        # XXX Should use IdlePrefs.ColorPrefs
        "stdout":  {"foreground": "blue"},
        "stderr":  {"foreground": "#007700"},
    }

    def __init__(self, flist):
        self.flist = flist
        self.owin = None

    def write(self, s, tags, mark):
        if not self.owin:
            self.setup()
        self.owin.write(s, tags, mark)

    def setup(self):
        self.owin = owin = OutputWindow(self.flist)
        text = owin.text
        for tag, cnf in self.tagdefs.items():
            if cnf:
                text.tag_configure(tag, **cnf)
        text.tag_raise('sel')
        self.write = self.owin.write
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """ParenMatch -- An IDLE extension for parenthesis matching.

When you hit a right paren, the cursor should move briefly to the left
paren.  Paren here is used generically; the matching applies to
parentheses, square brackets, and curly braces.
"""

from idlelib.HyperParser import HyperParser
from idlelib.configHandler import idleConf

_openers = {')':'(',']':'[','}':'{'}
CHECK_DELAY = 100 # milliseconds

class ParenMatch:
    """Highlight matching parentheses

    There are three supported style of paren matching, based loosely
    on the Emacs options.  The style is select based on the
    HILITE_STYLE attribute; it can be changed used the set_style
    method.

    The supported styles are:

    default -- When a right paren is typed, highlight the matching
        left paren for 1/2 sec.

    expression -- When a right paren is typed, highlight the entire
        expression from the left paren to the right paren.

    TODO:
        - extend IDLE with configuration dialog to change options
        - implement rest of Emacs highlight styles (see below)
        - print mismatch warning in IDLE status window

    Note: In Emacs, there are several styles of highlight where the
    matching paren is highlighted whenever the cursor is immediately
    to the right of a right paren.  I don't know how to do that in Tk,
    so I haven't bothered.
    """
    menudefs = [
        ('edit', [
            ("Show surrounding parens", "<<flash-paren>>"),
        ])
    ]
    STYLE = idleConf.GetOption('extensions','ParenMatch','style',
            default='expression')
    FLASH_DELAY = idleConf.GetOption('extensions','ParenMatch','flash-delay',
            type='int',default=500)
    HILITE_CONFIG = idleConf.GetHighlight(idleConf.CurrentTheme(),'hilite')
    BELL = idleConf.GetOption('extensions','ParenMatch','bell',
            type='bool',default=1)

    RESTORE_VIRTUAL_EVENT_NAME = "<<parenmatch-check-restore>>"
    # We want the restore event be called before the usual return and
    # backspace events.
    RESTORE_SEQUENCES = ("<KeyPress>", "<ButtonPress>",
                         "<Key-Return>", "<Key-BackSpace>")

    def __init__(self, editwin):
        self.editwin = editwin
        self.text = editwin.text
        # Bind the check-restore event to the function restore_event,
        # so that we can then use activate_restore (which calls event_add)
        # and deactivate_restore (which calls event_delete).
        editwin.text.bind(self.RESTORE_VIRTUAL_EVENT_NAME,
                          self.restore_event)
        self.counter = 0
        self.is_restore_active = 0
        self.set_style(self.STYLE)

    def activate_restore(self):
        if not self.is_restore_active:
            for seq in self.RESTORE_SEQUENCES:
                self.text.event_add(self.RESTORE_VIRTUAL_EVENT_NAME, seq)
            self.is_restore_active = True

    def deactivate_restore(self):
        if self.is_restore_active:
            for seq in self.RESTORE_SEQUENCES:
                self.text.event_delete(self.RESTORE_VIRTUAL_EVENT_NAME, seq)
            self.is_restore_active = False

    def set_style(self, style):
        self.STYLE = style
        if style == "default":
            self.create_tag = self.create_tag_default
            self.set_timeout = self.set_timeout_last
        elif style == "expression":
            self.create_tag = self.create_tag_expression
            self.set_timeout = self.set_timeout_none

    def flash_paren_event(self, event):
        indices = (HyperParser(self.editwin, "insert")
                   .get_surrounding_brackets())
        if indices is None:
            self.warn_mismatched()
            return
        self.activate_restore()
        self.create_tag(indices)
        self.set_timeout_last()

    def paren_closed_event(self, event):
        # If it was a shortcut and not really a closing paren, quit.
        closer = self.text.get("insert-1c")
        if closer not in _openers:
            return
        hp = HyperParser(self.editwin, "insert-1c")
        if not hp.is_in_code():
            return
        indices = hp.get_surrounding_brackets(_openers[closer], True)
        if indices is None:
            self.warn_mismatched()
            return
        self.activate_restore()
        self.create_tag(indices)
        self.set_timeout()

    def restore_event(self, event=None):
        self.text.tag_delete("paren")
        self.deactivate_restore()
        self.counter += 1   # disable the last timer, if there is one.

    def handle_restore_timer(self, timer_count):
        if timer_count == self.counter:
            self.restore_event()

    def warn_mismatched(self):
        if self.BELL:
            self.text.bell()

    # any one of the create_tag_XXX methods can be used depending on
    # the style

    def create_tag_default(self, indices):
        """Highlight the single paren that matches"""
        self.text.tag_add("paren", indices[0])
        self.text.tag_config("paren", self.HILITE_CONFIG)

    def create_tag_expression(self, indices):
        """Highlight the entire expression"""
        if self.text.get(indices[1]) in (')', ']', '}'):
            rightindex = indices[1]+"+1c"
        else:
            rightindex = indices[1]
        self.text.tag_add("paren", indices[0], rightindex)
        self.text.tag_config("paren", self.HILITE_CONFIG)

    # any one of the set_timeout_XXX methods can be used depending on
    # the style

    def set_timeout_none(self):
        """Highlight will remain until user input turns it off
        or the insert has moved"""
        # After CHECK_DELAY, call a function which disables the "paren" tag
        # if the event is for the most recent timer and the insert has changed,
        # or schedules another call for itself.
        self.counter += 1
        def callme(callme, self=self, c=self.counter,
                   index=self.text.index("insert")):
            if index != self.text.index("insert"):
                self.handle_restore_timer(c)
            else:
                self.editwin.text_frame.after(CHECK_DELAY, callme, callme)
        self.editwin.text_frame.after(CHECK_DELAY, callme, callme)

    def set_timeout_last(self):
        """The last highlight created will be removed after .5 sec"""
        # associate a counter with an event; only disable the "paren"
        # tag if the event is for the most recent timer.
        self.counter += 1
        self.editwin.text_frame.after(
            self.FLASH_DELAY,
            lambda self=self, c=self.counter: self.handle_restore_timer(c))


if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_parenmatch', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from idlelib.WidgetRedirector import WidgetRedirector
from idlelib.Delegator import Delegator


class Percolator:

    def __init__(self, text):
        # XXX would be nice to inherit from Delegator
        self.text = text
        self.redir = WidgetRedirector(text)
        self.top = self.bottom = Delegator(text)
        self.bottom.insert = self.redir.register("insert", self.insert)
        self.bottom.delete = self.redir.register("delete", self.delete)
        self.filters = []

    def close(self):
        while self.top is not self.bottom:
            self.removefilter(self.top)
        self.top = None
        self.bottom.setdelegate(None)
        self.bottom = None
        self.redir.close()
        self.redir = None
        self.text = None

    def insert(self, index, chars, tags=None):
        # Could go away if inheriting from Delegator
        self.top.insert(index, chars, tags)

    def delete(self, index1, index2=None):
        # Could go away if inheriting from Delegator
        self.top.delete(index1, index2)

    def insertfilter(self, filter):
        # Perhaps rename to pushfilter()?
        assert isinstance(filter, Delegator)
        assert filter.delegate is None
        filter.setdelegate(self.top)
        self.top = filter

    def removefilter(self, filter):
        # XXX Perhaps should only support popfilter()?
        assert isinstance(filter, Delegator)
        assert filter.delegate is not None
        f = self.top
        if f is filter:
            self.top = filter.delegate
            filter.setdelegate(None)
        else:
            while f.delegate is not filter:
                assert f is not self.bottom
                f.resetcache()
                f = f.delegate
            f.setdelegate(filter.delegate)
            filter.setdelegate(None)


def _percolator(parent):  # htest #
    import tkinter as tk
    import re

    class Tracer(Delegator):
        def __init__(self, name):
            self.name = name
            Delegator.__init__(self, None)

        def insert(self, *args):
            print(self.name, ": insert", args)
            self.delegate.insert(*args)

        def delete(self, *args):
            print(self.name, ": delete", args)
            self.delegate.delete(*args)

    box = tk.Toplevel(parent)
    box.title("Test Percolator")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    box.geometry("+%d+%d" % (x, y + 150))
    text = tk.Text(box)
    p = Percolator(text)
    pin = p.insertfilter
    pout = p.removefilter
    t1 = Tracer("t1")
    t2 = Tracer("t2")

    def toggle1():
        (pin if var1.get() else pout)(t1)
    def toggle2():
        (pin if var2.get() else pout)(t2)

    text.pack()
    var1 = tk.IntVar()
    cb1 = tk.Checkbutton(box, text="Tracer1", command=toggle1, variable=var1)
    cb1.pack()
    var2 = tk.IntVar()
    cb2 = tk.Checkbutton(box, text="Tracer2", command=toggle2, variable=var2)
    cb2.pack()

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_percolator', verbosity=2,
                  exit=False)

    from idlelib.idle_test.htest import run
    run(_percolator)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     import re
import sys
from collections import Mapping

# Reason last stmt is continued (or C_NONE if it's not).
(C_NONE, C_BACKSLASH, C_STRING_FIRST_LINE,
 C_STRING_NEXT_LINES, C_BRACKET) = range(5)

if 0:   # for throwaway debugging output
    def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")

# Find what looks like the start of a popular stmt.

_synchre = re.compile(r"""
    ^
    [ \t]*
    (?: while
    |   else
    |   def
    |   return
    |   assert
    |   break
    |   class
    |   continue
    |   elif
    |   try
    |   except
    |   raise
    |   import
    |   yield
    )
    \b
""", re.VERBOSE | re.MULTILINE).search

# Match blank line or non-indenting comment line.

_junkre = re.compile(r"""
    [ \t]*
    (?: \# \S .* )?
    \n
""", re.VERBOSE).match

# Match any flavor of string; the terminating quote is optional
# so that we're robust in the face of incomplete program text.

_match_stringre = re.compile(r"""
    \""" [^"\\]* (?:
                     (?: \\. | "(?!"") )
                     [^"\\]*
                 )*
    (?: \""" )?

|   " [^"\\\n]* (?: \\. [^"\\\n]* )* "?

|   ''' [^'\\]* (?:
                   (?: \\. | '(?!'') )
                   [^'\\]*
                )*
    (?: ''' )?

|   ' [^'\\\n]* (?: \\. [^'\\\n]* )* '?
""", re.VERBOSE | re.DOTALL).match

# Match a line that starts with something interesting;
# used to find the first item of a bracket structure.

_itemre = re.compile(r"""
    [ \t]*
    [^\s#\\]    # if we match, m.end()-1 is the interesting char
""", re.VERBOSE).match

# Match start of stmts that should be followed by a dedent.

_closere = re.compile(r"""
    \s*
    (?: return
    |   break
    |   continue
    |   raise
    |   pass
    )
    \b
""", re.VERBOSE).match

# Chew up non-special chars as quickly as possible.  If match is
# successful, m.end() less 1 is the index of the last boring char
# matched.  If match is unsuccessful, the string starts with an
# interesting char.

_chew_ordinaryre = re.compile(r"""
    [^[\](){}#'"\\]+
""", re.VERBOSE).match


class StringTranslatePseudoMapping(Mapping):
    r"""Utility class to be used with str.translate()

    This Mapping class wraps a given dict. When a value for a key is
    requested via __getitem__() or get(), the key is looked up in the
    given dict. If found there, the value from the dict is returned.
    Otherwise, the default value given upon initialization is returned.

    This allows using str.translate() to make some replacements, and to
    replace all characters for which no replacement was specified with
    a given character instead of leaving them as-is.

    For example, to replace everything except whitespace with 'x':

    >>> whitespace_chars = ' \t\n\r'
    >>> preserve_dict = {ord(c): ord(c) for c in whitespace_chars}
    >>> mapping = StringTranslatePseudoMapping(preserve_dict, ord('x'))
    >>> text = "a + b\tc\nd"
    >>> text.translate(mapping)
    'x x x\tx\nx'
    """
    def __init__(self, non_defaults, default_value):
        self._non_defaults = non_defaults
        self._default_value = default_value

        def _get(key, _get=non_defaults.get, _default=default_value):
            return _get(key, _default)
        self._get = _get

    def __getitem__(self, item):
        return self._get(item)

    def __len__(self):
        return len(self._non_defaults)

    def __iter__(self):
        return iter(self._non_defaults)

    def get(self, key, default=None):
        return self._get(key)


class Parser:

    def __init__(self, indentwidth, tabwidth):
        self.indentwidth = indentwidth
        self.tabwidth = tabwidth

    def set_str(self, s):
        assert len(s) == 0 or s[-1] == '\n'
        self.str = s
        self.study_level = 0

    # Return index of a good place to begin parsing, as close to the
    # end of the string as possible.  This will be the start of some
    # popular stmt like "if" or "def".  Return None if none found:
    # the caller should pass more prior context then, if possible, or
    # if not (the entire program text up until the point of interest
    # has already been tried) pass 0 to set_lo.
    #
    # This will be reliable iff given a reliable is_char_in_string
    # function, meaning that when it says "no", it's absolutely
    # guaranteed that the char is not in a string.

    def find_good_parse_start(self, is_char_in_string=None,
                              _synchre=_synchre):
        str, pos = self.str, None

        if not is_char_in_string:
            # no clue -- make the caller pass everything
            return None

        # Peek back from the end for a good place to start,
        # but don't try too often; pos will be left None, or
        # bumped to a legitimate synch point.
        limit = len(str)
        for tries in range(5):
            i = str.rfind(":\n", 0, limit)
            if i < 0:
                break
            i = str.rfind('\n', 0, i) + 1  # start of colon line
            m = _synchre(str, i, limit)
            if m and not is_char_in_string(m.start()):
                pos = m.start()
                break
            limit = i
        if pos is None:
            # Nothing looks like a block-opener, or stuff does
            # but is_char_in_string keeps returning true; most likely
            # we're in or near a giant string, the colorizer hasn't
            # caught up enough to be helpful, or there simply *aren't*
            # any interesting stmts.  In any of these cases we're
            # going to have to parse the whole thing to be sure, so
            # give it one last try from the start, but stop wasting
            # time here regardless of the outcome.
            m = _synchre(str)
            if m and not is_char_in_string(m.start()):
                pos = m.start()
            return pos

        # Peeking back worked; look forward until _synchre no longer
        # matches.
        i = pos + 1
        while 1:
            m = _synchre(str, i)
            if m:
                s, i = m.span()
                if not is_char_in_string(s):
                    pos = s
            else:
                break
        return pos

    # Throw away the start of the string.  Intended to be called with
    # find_good_parse_start's result.

    def set_lo(self, lo):
        assert lo == 0 or self.str[lo-1] == '\n'
        if lo > 0:
            self.str = self.str[lo:]

    # Build a translation table to map uninteresting chars to 'x', open
    # brackets to '(', close brackets to ')' while preserving quotes,
    # backslashes, newlines and hashes. This is to be passed to
    # str.translate() in _study1().
    _tran = {}
    _tran.update((ord(c), ord('(')) for c in "({[")
    _tran.update((ord(c), ord(')')) for c in ")}]")
    _tran.update((ord(c), ord(c)) for c in "\"'\\\n#")
    _tran = StringTranslatePseudoMapping(_tran, default_value=ord('x'))

    # As quickly as humanly possible <wink>, find the line numbers (0-
    # based) of the non-continuation lines.
    # Creates self.{goodlines, continuation}.

    def _study1(self):
        if self.study_level >= 1:
            return
        self.study_level = 1

        # Map all uninteresting characters to "x", all open brackets
        # to "(", all close brackets to ")", then collapse runs of
        # uninteresting characters.  This can cut the number of chars
        # by a factor of 10-40, and so greatly speed the following loop.
        str = self.str
        str = str.translate(self._tran)
        str = str.replace('xxxxxxxx', 'x')
        str = str.replace('xxxx', 'x')
        str = str.replace('xx', 'x')
        str = str.replace('xx', 'x')
        str = str.replace('\nx', '\n')
        # note that replacing x\n with \n would be incorrect, because
        # x may be preceded by a backslash

        # March over the squashed version of the program, accumulating
        # the line numbers of non-continued stmts, and determining
        # whether & why the last stmt is a continuation.
        continuation = C_NONE
        level = lno = 0     # level is nesting level; lno is line number
        self.goodlines = goodlines = [0]
        push_good = goodlines.append
        i, n = 0, len(str)
        while i < n:
            ch = str[i]
            i = i+1

            # cases are checked in decreasing order of frequency
            if ch == 'x':
                continue

            if ch == '\n':
                lno = lno + 1
                if level == 0:
                    push_good(lno)
                    # else we're in an unclosed bracket structure
                continue

            if ch == '(':
                level = level + 1
                continue

            if ch == ')':
                if level:
                    level = level - 1
                    # else the program is invalid, but we can't complain
                continue

            if ch == '"' or ch == "'":
                # consume the string
                quote = ch
                if str[i-1:i+2] == quote * 3:
                    quote = quote * 3
                firstlno = lno
                w = len(quote) - 1
                i = i+w
                while i < n:
                    ch = str[i]
                    i = i+1

                    if ch == 'x':
                        continue

                    if str[i-1:i+w] == quote:
                        i = i+w
                        break

                    if ch == '\n':
                        lno = lno + 1
                        if w == 0:
                            # unterminated single-quoted string
                            if level == 0:
                                push_good(lno)
                            break
                        continue

                    if ch == '\\':
                        assert i < n
                        if str[i] == '\n':
                            lno = lno + 1
                        i = i+1
                        continue

                    # else comment char or paren inside string

                else:
                    # didn't break out of the loop, so we're still
                    # inside a string
                    if (lno - 1) == firstlno:
                        # before the previous \n in str, we were in the first
                        # line of the string
                        continuation = C_STRING_FIRST_LINE
                    else:
                        continuation = C_STRING_NEXT_LINES
                continue    # with outer loop

            if ch == '#':
                # consume the comment
                i = str.find('\n', i)
                assert i >= 0
                continue

            assert ch == '\\'
            assert i < n
            if str[i] == '\n':
                lno = lno + 1
                if i+1 == n:
                    continuation = C_BACKSLASH
            i = i+1

        # The last stmt may be continued for all 3 reasons.
        # String continuation takes precedence over bracket
        # continuation, which beats backslash continuation.
        if (continuation != C_STRING_FIRST_LINE
            and continuation != C_STRING_NEXT_LINES and level > 0):
            continuation = C_BRACKET
        self.continuation = continuation

        # Push the final line number as a sentinel value, regardless of
        # whether it's continued.
        assert (continuation == C_NONE) == (goodlines[-1] == lno)
        if goodlines[-1] != lno:
            push_good(lno)

    def get_continuation_type(self):
        self._study1()
        return self.continuation

    # study1 was sufficient to determine the continuation status,
    # but doing more requires looking at every character.  study2
    # does this for the last interesting statement in the block.
    # Creates:
    #     self.stmt_start, stmt_end
    #         slice indices of last interesting stmt
    #     self.stmt_bracketing
    #         the bracketing structure of the last interesting stmt;
    #         for example, for the statement "say(boo) or die", stmt_bracketing
    #         will be [(0, 0), (3, 1), (8, 0)]. Strings and comments are
    #         treated as brackets, for the matter.
    #     self.lastch
    #         last non-whitespace character before optional trailing
    #         comment
    #     self.lastopenbracketpos
    #         if continuation is C_BRACKET, index of last open bracket

    def _study2(self):
        if self.study_level >= 2:
            return
        self._study1()
        self.study_level = 2

        # Set p and q to slice indices of last interesting stmt.
        str, goodlines = self.str, self.goodlines
        i = len(goodlines) - 1
        p = len(str)    # index of newest line
        while i:
            assert p
            # p is the index of the stmt at line number goodlines[i].
            # Move p back to the stmt at line number goodlines[i-1].
            q = p
            for nothing in range(goodlines[i-1], goodlines[i]):
                # tricky: sets p to 0 if no preceding newline
                p = str.rfind('\n', 0, p-1) + 1
            # The stmt str[p:q] isn't a continuation, but may be blank
            # or a non-indenting comment line.
            if  _junkre(str, p):
                i = i-1
            else:
                break
        if i == 0:
            # nothing but junk!
            assert p == 0
            q = p
        self.stmt_start, self.stmt_end = p, q

        # Analyze this stmt, to find the last open bracket (if any)
        # and last interesting character (if any).
        lastch = ""
        stack = []  # stack of open bracket indices
        push_stack = stack.append
        bracketing = [(p, 0)]
        while p < q:
            # suck up all except ()[]{}'"#\\
            m = _chew_ordinaryre(str, p, q)
            if m:
                # we skipped at least one boring char
                newp = m.end()
                # back up over totally boring whitespace
                i = newp - 1    # index of last boring char
                while i >= p and str[i] in " \t\n":
                    i = i-1
                if i >= p:
                    lastch = str[i]
                p = newp
                if p >= q:
                    break

            ch = str[p]

            if ch in "([{":
                push_stack(p)
                bracketing.append((p, len(stack)))
                lastch = ch
                p = p+1
                continue

            if ch in ")]}":
                if stack:
                    del stack[-1]
                lastch = ch
                p = p+1
                bracketing.append((p, len(stack)))
                continue

            if ch == '"' or ch == "'":
                # consume string
                # Note that study1 did this with a Python loop, but
                # we use a regexp here; the reason is speed in both
                # cases; the string may be huge, but study1 pre-squashed
                # strings to a couple of characters per line.  study1
                # also needed to keep track of newlines, and we don't
                # have to.
                bracketing.append((p, len(stack)+1))
                lastch = ch
                p = _match_stringre(str, p, q).end()
                bracketing.append((p, len(stack)))
                continue

            if ch == '#':
                # consume comment and trailing newline
                bracketing.append((p, len(stack)+1))
                p = str.find('\n', p, q) + 1
                assert p > 0
                bracketing.append((p, len(stack)))
                continue

            assert ch == '\\'
            p = p+1     # beyond backslash
            assert p < q
            if str[p] != '\n':
                # the program is invalid, but can't complain
                lastch = ch + str[p]
            p = p+1     # beyond escaped char

        # end while p < q:

        self.lastch = lastch
        if stack:
            self.lastopenbracketpos = stack[-1]
        self.stmt_bracketing = tuple(bracketing)

    # Assuming continuation is C_BRACKET, return the number
    # of spaces the next line should be indented.

    def compute_bracket_indent(self):
        self._study2()
        assert self.continuation == C_BRACKET
        j = self.lastopenbracketpos
        str = self.str
        n = len(str)
        origi = i = str.rfind('\n', 0, j) + 1
        j = j+1     # one beyond open bracket
        # find first list item; set i to start of its line
        while j < n:
            m = _itemre(str, j)
            if m:
                j = m.end() - 1     # index of first interesting char
                extra = 0
                break
            else:
                # this line is junk; advance to next line
                i = j = str.find('\n', j) + 1
        else:
            # nothing interesting follows the bracket;
            # reproduce the bracket line's indentation + a level
            j = i = origi
            while str[j] in " \t":
                j = j+1
            extra = self.indentwidth
        return len(str[i:j].expandtabs(self.tabwidth)) + extra

    # Return number of physical lines in last stmt (whether or not
    # it's an interesting stmt!  this is intended to be called when
    # continuation is C_BACKSLASH).

    def get_num_lines_in_stmt(self):
        self._study1()
        goodlines = self.goodlines
        return goodlines[-1] - goodlines[-2]

    # Assuming continuation is C_BACKSLASH, return the number of spaces
    # the next line should be indented.  Also assuming the new line is
    # the first one following the initial line of the stmt.

    def compute_backslash_indent(self):
        self._study2()
        assert self.continuation == C_BACKSLASH
        str = self.str
        i = self.stmt_start
        while str[i] in " \t":
            i = i+1
        startpos = i

        # See whether the initial line starts an assignment stmt; i.e.,
        # look for an = operator
        endpos = str.find('\n', startpos) + 1
        found = level = 0
        while i < endpos:
            ch = str[i]
            if ch in "([{":
                level = level + 1
                i = i+1
            elif ch in ")]}":
                if level:
                    level = level - 1
                i = i+1
            elif ch == '"' or ch == "'":
                i = _match_stringre(str, i, endpos).end()
            elif ch == '#':
                break
            elif level == 0 and ch == '=' and \
                   (i == 0 or str[i-1] not in "=<>!") and \
                   str[i+1] != '=':
                found = 1
                break
            else:
                i = i+1

        if found:
            # found a legit =, but it may be the last interesting
            # thing on the line
            i = i+1     # move beyond the =
            found = re.match(r"\s*\\", str[i:endpos]) is None

        if not found:
            # oh well ... settle for moving beyond the first chunk
            # of non-whitespace chars
            i = startpos
            while str[i] not in " \t\n":
                i = i+1

        return len(str[self.stmt_start:i].expandtabs(\
                                     self.tabwidth)) + 1

    # Return the leading whitespace on the initial line of the last
    # interesting stmt.

    def get_base_indent_string(self):
        self._study2()
        i, n = self.stmt_start, self.stmt_end
        j = i
        str = self.str
        while j < n and str[j] in " \t":
            j = j + 1
        return str[i:j]

    # Did the last interesting stmt open a block?

    def is_block_opener(self):
        self._study2()
        return self.lastch == ':'

    # Did the last interesting stmt close a block?

    def is_block_closer(self):
        self._study2()
        return _closere(self.str, self.stmt_start) is not None

    # index of last open bracket ({[, or None if none
    lastopenbracketpos = None

    def get_last_open_bracket_pos(self):
        self._study2()
        return self.lastopenbracketpos

    # the structure of the bracketing of the last interesting statement,
    # in the format defined in _study2, or None if the text didn't contain
    # anything
    stmt_bracketing = None

    def get_last_stmt_bracketing(self):
        self._study2()
        return self.stmt_bracketing
                   #! /usr/bin/python3.5

import getopt
import os
import os.path
import re
import socket
import subprocess
import sys
import threading
import time
import tokenize
import io

import linecache
from code import InteractiveInterpreter
from platform import python_version, system

try:
    from tkinter import *
except ImportError:
    print("** IDLE can't import Tkinter.\n"
          "Your Python may not be configured for Tk. **", file=sys.__stderr__)
    sys.exit(1)
import tkinter.messagebox as tkMessageBox

from idlelib.EditorWindow import EditorWindow, fixwordbreaks
from idlelib.FileList import FileList
from idlelib.ColorDelegator import ColorDelegator
from idlelib.UndoDelegator import UndoDelegator
from idlelib.OutputWindow import OutputWindow
from idlelib.configHandler import idleConf
from idlelib import rpc
from idlelib import Debugger
from idlelib import RemoteDebugger
from idlelib import macosxSupport

HOST = '127.0.0.1' # python execution server on localhost loopback
PORT = 0  # someday pass in host, port for remote debug capability

# Override warnings module to write to warning_stream.  Initialize to send IDLE
# internal warnings to the console.  ScriptBinding.check_syntax() will
# temporarily redirect the stream to the shell window to display warnings when
# checking user's code.
warning_stream = sys.__stderr__  # None, at least on Windows, if no console.
import warnings

def idle_formatwarning(message, category, filename, lineno, line=None):
    """Format warnings the IDLE way."""

    s = "\nWarning (from warnings module):\n"
    s += '  File \"%s\", line %s\n' % (filename, lineno)
    if line is None:
        line = linecache.getline(filename, lineno)
    line = line.strip()
    if line:
        s += "    %s\n" % line
    s += "%s: %s\n" % (category.__name__, message)
    return s

def idle_showwarning(
        message, category, filename, lineno, file=None, line=None):
    """Show Idle-format warning (after replacing warnings.showwarning).

    The differences are the formatter called, the file=None replacement,
    which can be None, the capture of the consequence AttributeError,
    and the output of a hard-coded prompt.
    """
    if file is None:
        file = warning_stream
    try:
        file.write(idle_formatwarning(
                message, category, filename, lineno, line=line))
        file.write(">>> ")
    except (AttributeError, OSError):
        pass  # if file (probably __stderr__) is invalid, skip warning.

_warnings_showwarning = None

def capture_warnings(capture):
    "Replace warning.showwarning with idle_showwarning, or reverse."

    global _warnings_showwarning
    if capture:
        if _warnings_showwarning is None:
            _warnings_showwarning = warnings.showwarning
            warnings.showwarning = idle_showwarning
    else:
        if _warnings_showwarning is not None:
            warnings.showwarning = _warnings_showwarning
            _warnings_showwarning = None

capture_warnings(True)

def extended_linecache_checkcache(filename=None,
                                  orig_checkcache=linecache.checkcache):
    """Extend linecache.checkcache to preserve the <pyshell#...> entries

    Rather than repeating the linecache code, patch it to save the
    <pyshell#...> entries, call the original linecache.checkcache()
    (skipping them), and then restore the saved entries.

    orig_checkcache is bound at definition time to the original
    method, allowing it to be patched.
    """
    cache = linecache.cache
    save = {}
    for key in list(cache):
        if key[:1] + key[-1:] == '<>':
            save[key] = cache.pop(key)
    orig_checkcache(filename)
    cache.update(save)

# Patch linecache.checkcache():
linecache.checkcache = extended_linecache_checkcache


class PyShellEditorWindow(EditorWindow):
    "Regular text edit window in IDLE, supports breakpoints"

    def __init__(self, *args):
        self.breakpoints = []
        EditorWindow.__init__(self, *args)
        self.text.bind("<<set-breakpoint-here>>", self.set_breakpoint_here)
        self.text.bind("<<clear-breakpoint-here>>", self.clear_breakpoint_here)
        self.text.bind("<<open-python-shell>>", self.flist.open_shell)

        self.breakpointPath = os.path.join(idleConf.GetUserCfgDir(),
                                           'breakpoints.lst')
        # whenever a file is changed, restore breakpoints
        def filename_changed_hook(old_hook=self.io.filename_change_hook,
                                  self=self):
            self.restore_file_breaks()
            old_hook()
        self.io.set_filename_change_hook(filename_changed_hook)
        if self.io.filename:
            self.restore_file_breaks()
        self.color_breakpoint_text()

    rmenu_specs = [
        ("Cut", "<<cut>>", "rmenu_check_cut"),
        ("Copy", "<<copy>>", "rmenu_check_copy"),
        ("Paste", "<<paste>>", "rmenu_check_paste"),
        (None, None, None),
        ("Set Breakpoint", "<<set-breakpoint-here>>", None),
        ("Clear Breakpoint", "<<clear-breakpoint-here>>", None)
    ]

    def color_breakpoint_text(self, color=True):
        "Turn colorizing of breakpoint text on or off"
        if self.io is None:
            # possible due to update in restore_file_breaks
            return
        if color:
            theme = idleConf.CurrentTheme()
            cfg = idleConf.GetHighlight(theme, "break")
        else:
            cfg = {'foreground': '', 'background': ''}
        self.text.tag_config('BREAK', cfg)

    def set_breakpoint(self, lineno):
        text = self.text
        filename = self.io.filename
        text.tag_add("BREAK", "%d.0" % lineno, "%d.0" % (lineno+1))
        try:
            self.breakpoints.index(lineno)
        except ValueError:  # only add if missing, i.e. do once
            self.breakpoints.append(lineno)
        try:    # update the subprocess debugger
            debug = self.flist.pyshell.interp.debugger
            debug.set_breakpoint_here(filename, lineno)
        except: # but debugger may not be active right now....
            pass

    def set_breakpoint_here(self, event=None):
        text = self.text
        filename = self.io.filename
        if not filename:
            text.bell()
            return
        lineno = int(float(text.index("insert")))
        self.set_breakpoint(lineno)

    def clear_breakpoint_here(self, event=None):
        text = self.text
        filename = self.io.filename
        if not filename:
            text.bell()
            return
        lineno = int(float(text.index("insert")))
        try:
            self.breakpoints.remove(lineno)
        except:
            pass
        text.tag_remove("BREAK", "insert linestart",\
                        "insert lineend +1char")
        try:
            debug = self.flist.pyshell.interp.debugger
            debug.clear_breakpoint_here(filename, lineno)
        except:
            pass

    def clear_file_breaks(self):
        if self.breakpoints:
            text = self.text
            filename = self.io.filename
            if not filename:
                text.bell()
                return
            self.breakpoints = []
            text.tag_remove("BREAK", "1.0", END)
            try:
                debug = self.flist.pyshell.interp.debugger
                debug.clear_file_breaks(filename)
            except:
                pass

    def store_file_breaks(self):
        "Save breakpoints when file is saved"
        # XXX 13 Dec 2002 KBK Currently the file must be saved before it can
        #     be run.  The breaks are saved at that time.  If we introduce
        #     a temporary file save feature the save breaks functionality
        #     needs to be re-verified, since the breaks at the time the
        #     temp file is created may differ from the breaks at the last
        #     permanent save of the file.  Currently, a break introduced
        #     after a save will be effective, but not persistent.
        #     This is necessary to keep the saved breaks synched with the
        #     saved file.
        #
        #     Breakpoints are set as tagged ranges in the text.
        #     Since a modified file has to be saved before it is
        #     run, and since self.breakpoints (from which the subprocess
        #     debugger is loaded) is updated during the save, the visible
        #     breaks stay synched with the subprocess even if one of these
        #     unexpected breakpoint deletions occurs.
        breaks = self.breakpoints
        filename = self.io.filename
        try:
            with open(self.breakpointPath, "r") as fp:
                lines = fp.readlines()
        except OSError:
            lines = []
        try:
            with open(self.breakpointPath, "w") as new_file:
                for line in lines:
                    if not line.startswith(filename + '='):
                        new_file.write(line)
                self.update_breakpoints()
                breaks = self.breakpoints
                if breaks:
                    new_file.write(filename + '=' + str(breaks) + '\n')
        except OSError as err:
            if not getattr(self.root, "breakpoint_error_displayed", False):
                self.root.breakpoint_error_displayed = True
                tkMessageBox.showerror(title='IDLE Error',
                    message='Unable to update breakpoint list:\n%s'
                        % str(err),
                    parent=self.text)

    def restore_file_breaks(self):
        self.text.update()   # this enables setting "BREAK" tags to be visible
        if self.io is None:
            # can happen if IDLE closes due to the .update() call
            return
        filename = self.io.filename
        if filename is None:
            return
        if os.path.isfile(self.breakpointPath):
            with open(self.breakpointPath, "r") as fp:
                lines = fp.readlines()
            for line in lines:
                if line.startswith(filename + '='):
                    breakpoint_linenumbers = eval(line[len(filename)+1:])
                    for breakpoint_linenumber in breakpoint_linenumbers:
                        self.set_breakpoint(breakpoint_linenumber)

    def update_breakpoints(self):
        "Retrieves all the breakpoints in the current window"
        text = self.text
        ranges = text.tag_ranges("BREAK")
        linenumber_list = self.ranges_to_linenumbers(ranges)
        self.breakpoints = linenumber_list

    def ranges_to_linenumbers(self, ranges):
        lines = []
        for index in range(0, len(ranges), 2):
            lineno = int(float(ranges[index].string))
            end = int(float(ranges[index+1].string))
            while lineno < end:
                lines.append(lineno)
                lineno += 1
        return lines

# XXX 13 Dec 2002 KBK Not used currently
#    def saved_change_hook(self):
#        "Extend base method - clear breaks if module is modified"
#        if not self.get_saved():
#            self.clear_file_breaks()
#        EditorWindow.saved_change_hook(self)

    def _close(self):
        "Extend base method - clear breaks when module is closed"
        self.clear_file_breaks()
        EditorWindow._close(self)


class PyShellFileList(FileList):
    "Extend base class: IDLE supports a shell and breakpoints"

    # override FileList's class variable, instances return PyShellEditorWindow
    # instead of EditorWindow when new edit windows are created.
    EditorWindow = PyShellEditorWindow

    pyshell = None

    def open_shell(self, event=None):
        if self.pyshell:
            self.pyshell.top.wakeup()
        else:
            self.pyshell = PyShell(self)
            if self.pyshell:
                if not self.pyshell.begin():
                    return None
        return self.pyshell


class ModifiedColorDelegator(ColorDelegator):
    "Extend base class: colorizer for the shell window itself"

    def __init__(self):
        ColorDelegator.__init__(self)
        self.LoadTagDefs()

    def recolorize_main(self):
        self.tag_remove("TODO", "1.0", "iomark")
        self.tag_add("SYNC", "1.0", "iomark")
        ColorDelegator.recolorize_main(self)

    def LoadTagDefs(self):
        ColorDelegator.LoadTagDefs(self)
        theme = idleConf.CurrentTheme()
        self.tagdefs.update({
            "stdin": {'background':None,'foreground':None},
            "stdout": idleConf.GetHighlight(theme, "stdout"),
            "stderr": idleConf.GetHighlight(theme, "stderr"),
            "console": idleConf.GetHighlight(theme, "console"),
        })

    def removecolors(self):
        # Don't remove shell color tags before "iomark"
        for tag in self.tagdefs:
            self.tag_remove(tag, "iomark", "end")

class ModifiedUndoDelegator(UndoDelegator):
    "Extend base class: forbid insert/delete before the I/O mark"

    def insert(self, index, chars, tags=None):
        try:
            if self.delegate.compare(index, "<", "iomark"):
                self.delegate.bell()
                return
        except TclError:
            pass
        UndoDelegator.insert(self, index, chars, tags)

    def delete(self, index1, index2=None):
        try:
            if self.delegate.compare(index1, "<", "iomark"):
                self.delegate.bell()
                return
        except TclError:
            pass
        UndoDelegator.delete(self, index1, index2)


class MyRPCClient(rpc.RPCClient):

    def handle_EOF(self):
        "Override the base class - just re-raise EOFError"
        raise EOFError


class ModifiedInterpreter(InteractiveInterpreter):

    def __init__(self, tkconsole):
        self.tkconsole = tkconsole
        locals = sys.modules['__main__'].__dict__
        InteractiveInterpreter.__init__(self, locals=locals)
        self.save_warnings_filters = None
        self.restarting = False
        self.subprocess_arglist = None
        self.port = PORT
        self.original_compiler_flags = self.compile.compiler.flags

    _afterid = None
    rpcclt = None
    rpcsubproc = None

    def spawn_subprocess(self):
        if self.subprocess_arglist is None:
            self.subprocess_arglist = self.build_subprocess_arglist()
        self.rpcsubproc = subprocess.Popen(self.subprocess_arglist)

    def build_subprocess_arglist(self):
        assert (self.port!=0), (
            "Socket should have been assigned a port number.")
        w = ['-W' + s for s in sys.warnoptions]
        # Maybe IDLE is installed and is being accessed via sys.path,
        # or maybe it's not installed and the idle.py script is being
        # run from the IDLE source directory.
        del_exitf = idleConf.GetOption('main', 'General', 'delete-exitfunc',
                                       default=False, type='bool')
        if __name__ == 'idlelib.PyShell':
            command = "__import__('idlelib.run').run.main(%r)" % (del_exitf,)
        else:
            command = "__import__('run').main(%r)" % (del_exitf,)
        return [sys.executable] + w + ["-c", command, str(self.port)]

    def start_subprocess(self):
        addr = (HOST, self.port)
        # GUI makes several attempts to acquire socket, listens for connection
        for i in range(3):
            time.sleep(i)
            try:
                self.rpcclt = MyRPCClient(addr)
                break
            except OSError:
                pass
        else:
            self.display_port_binding_error()
            return None
        # if PORT was 0, system will assign an 'ephemeral' port. Find it out:
        self.port = self.rpcclt.listening_sock.getsockname()[1]
        # if PORT was not 0, probably working with a remote execution server
        if PORT != 0:
            # To allow reconnection within the 2MSL wait (cf. Stevens TCP
            # V1, 18.6),  set SO_REUSEADDR.  Note that this can be problematic
            # on Windows since the implementation allows two active sockets on
            # the same address!
            self.rpcclt.listening_sock.setsockopt(socket.SOL_SOCKET,
                                           socket.SO_REUSEADDR, 1)
        self.spawn_subprocess()
        #time.sleep(20) # test to simulate GUI not accepting connection
        # Accept the connection from the Python execution server
        self.rpcclt.listening_sock.settimeout(10)
        try:
            self.rpcclt.accept()
        except socket.timeout:
            self.display_no_subprocess_error()
            return None
        self.rpcclt.register("console", self.tkconsole)
        self.rpcclt.register("stdin", self.tkconsole.stdin)
        self.rpcclt.register("stdout", self.tkconsole.stdout)
        self.rpcclt.register("stderr", self.tkconsole.stderr)
        self.rpcclt.register("flist", self.tkconsole.flist)
        self.rpcclt.register("linecache", linecache)
        self.rpcclt.register("interp", self)
        self.transfer_path(with_cwd=True)
        self.poll_subprocess()
        return self.rpcclt

    def restart_subprocess(self, with_cwd=False, filename=''):
        if self.restarting:
            return self.rpcclt
        self.restarting = True
        # close only the subprocess debugger
        debug = self.getdebugger()
        if debug:
            try:
                # Only close subprocess debugger, don't unregister gui_adap!
                RemoteDebugger.close_subprocess_debugger(self.rpcclt)
            except:
                pass
        # Kill subprocess, spawn a new one, accept connection.
        self.rpcclt.close()
        self.terminate_subprocess()
        console = self.tkconsole
        was_executing = console.executing
        console.executing = False
        self.spawn_subprocess()
        try:
            self.rpcclt.accept()
        except socket.timeout:
            self.display_no_subprocess_error()
            return None
        self.transfer_path(with_cwd=with_cwd)
        console.stop_readline()
        # annotate restart in shell window and mark it
        console.text.delete("iomark", "end-1c")
        tag = 'RESTART: ' + (filename if filename else 'Shell')
        halfbar = ((int(console.width) -len(tag) - 4) // 2) * '='
        console.write("\n{0} {1} {0}".format(halfbar, tag))
        console.text.mark_set("restart", "end-1c")
        console.text.mark_gravity("restart", "left")
        if not filename:
            console.showprompt()
        # restart subprocess debugger
        if debug:
            # Restarted debugger connects to current instance of debug GUI
            RemoteDebugger.restart_subprocess_debugger(self.rpcclt)
            # reload remote debugger breakpoints for all PyShellEditWindows
            debug.load_breakpoints()
        self.compile.compiler.flags = self.original_compiler_flags
        self.restarting = False
        return self.rpcclt

    def __request_interrupt(self):
        self.rpcclt.remotecall("exec", "interrupt_the_server", (), {})

    def interrupt_subprocess(self):
        threading.Thread(target=self.__request_interrupt).start()

    def kill_subprocess(self):
        if self._afterid is not None:
            self.tkconsole.text.after_cancel(self._afterid)
        try:
            self.rpcclt.listening_sock.close()
        except AttributeError:  # no socket
            pass
        try:
            self.rpcclt.close()
        except AttributeError:  # no socket
            pass
        self.terminate_subprocess()
        self.tkconsole.executing = False
        self.rpcclt = None

    def terminate_subprocess(self):
        "Make sure subprocess is terminated"
        try:
            self.rpcsubproc.kill()
        except OSError:
            # process already terminated
            return
        else:
            try:
                self.rpcsubproc.wait()
            except OSError:
                return

    def transfer_path(self, with_cwd=False):
        if with_cwd:        # Issue 13506
            path = ['']     # include Current Working Directory
            path.extend(sys.path)
        else:
            path = sys.path

        self.runcommand("""if 1:
        import sys as _sys
        _sys.path = %r
        del _sys
        \n""" % (path,))

    active_seq = None

    def poll_subprocess(self):
        clt = self.rpcclt
        if clt is None:
            return
        try:
            response = clt.pollresponse(self.active_seq, wait=0.05)
        except (EOFError, OSError, KeyboardInterrupt):
            # lost connection or subprocess terminated itself, restart
            # [the KBI is from rpc.SocketIO.handle_EOF()]
            if self.tkconsole.closing:
                return
            response = None
            self.restart_subprocess()
        if response:
            self.tkconsole.resetoutput()
            self.active_seq = None
            how, what = response
            console = self.tkconsole.console
            if how == "OK":
                if what is not None:
                    print(repr(what), file=console)
            elif how == "EXCEPTION":
                if self.tkconsole.getvar("<<toggle-jit-stack-viewer>>"):
                    self.remote_stack_viewer()
            elif how == "ERROR":
                errmsg = "PyShell.ModifiedInterpreter: Subprocess ERROR:\n"
                print(errmsg, what, file=sys.__stderr__)
                print(errmsg, what, file=console)
            # we received a response to the currently active seq number:
            try:
                self.tkconsole.endexecuting()
            except AttributeError:  # shell may have closed
                pass
        # Reschedule myself
        if not self.tkconsole.closing:
            self._afterid = self.tkconsole.text.after(
                self.tkconsole.pollinterval, self.poll_subprocess)

    debugger = None

    def setdebugger(self, debugger):
        self.debugger = debugger

    def getdebugger(self):
        return self.debugger

    def open_remote_stack_viewer(self):
        """Initiate the remote stack viewer from a separate thread.

        This method is called from the subprocess, and by returning from this
        method we allow the subprocess to unblock.  After a bit the shell
        requests the subprocess to open the remote stack viewer which returns a
        static object looking at the last exception.  It is queried through
        the RPC mechanism.

        """
        self.tkconsole.text.after(300, self.remote_stack_viewer)
        return

    def remote_stack_viewer(self):
        from idlelib import RemoteObjectBrowser
        oid = self.rpcclt.remotequeue("exec", "stackviewer", ("flist",), {})
        if oid is None:
            self.tkconsole.root.bell()
            return
        item = RemoteObjectBrowser.StubObjectTreeItem(self.rpcclt, oid)
        from idlelib.TreeWidget import ScrolledCanvas, TreeNode
        top = Toplevel(self.tkconsole.root)
        theme = idleConf.CurrentTheme()
        background = idleConf.GetHighlight(theme, 'normal')['background']
        sc = ScrolledCanvas(top, bg=background, highlightthickness=0)
        sc.frame.pack(expand=1, fill="both")
        node = TreeNode(sc.canvas, None, item)
        node.expand()
        # XXX Should GC the remote tree when closing the window

    gid = 0

    def execsource(self, source):
        "Like runsource() but assumes complete exec source"
        filename = self.stuffsource(source)
        self.execfile(filename, source)

    def execfile(self, filename, source=None):
        "Execute an existing file"
        if source is None:
            with tokenize.open(filename) as fp:
                source = fp.read()
        try:
            code = compile(source, filename, "exec")
        except (OverflowError, SyntaxError):
            self.tkconsole.resetoutput()
            print('*** Error in script or command!\n'
                 'Traceback (most recent call last):',
                  file=self.tkconsole.stderr)
            InteractiveInterpreter.showsyntaxerror(self, filename)
            self.tkconsole.showprompt()
        else:
            self.runcode(code)

    def runsource(self, source):
        "Extend base class method: Stuff the source in the line cache first"
        filename = self.stuffsource(source)
        self.more = 0
        self.save_warnings_filters = warnings.filters[:]
        warnings.filterwarnings(action="error", category=SyntaxWarning)
        # at the moment, InteractiveInterpreter expects str
        assert isinstance(source, str)
        #if isinstance(source, str):
        #    from idlelib import IOBinding
        #    try:
        #        source = source.encode(IOBinding.encoding)
        #    except UnicodeError:
        #        self.tkconsole.resetoutput()
        #        self.write("Unsupported characters in input\n")
        #        return
        try:
            # InteractiveInterpreter.runsource() calls its runcode() method,
            # which is overridden (see below)
            return InteractiveInterpreter.runsource(self, source, filename)
        finally:
            if self.save_warnings_filters is not None:
                warnings.filters[:] = self.save_warnings_filters
                self.save_warnings_filters = None

    def stuffsource(self, source):
        "Stuff source in the filename cache"
        filename = "<pyshell#%d>" % self.gid
        self.gid = self.gid + 1
        lines = source.split("\n")
        linecache.cache[filename] = len(source)+1, 0, lines, filename
        return filename

    def prepend_syspath(self, filename):
        "Prepend sys.path with file's directory if not already included"
        self.runcommand("""if 1:
            _filename = %r
            import sys as _sys
            from os.path import dirname as _dirname
            _dir = _dirname(_filename)
            if not _dir in _sys.path:
                _sys.path.insert(0, _dir)
            del _filename, _sys, _dirname, _dir
            \n""" % (filename,))

    def showsyntaxerror(self, filename=None):
        """Override Interactive Interpreter method: Use Colorizing

        Color the offending position instead of printing it and pointing at it
        with a caret.

        """
        tkconsole = self.tkconsole
        text = tkconsole.text
        text.tag_remove("ERROR", "1.0", "end")
        type, value, tb = sys.exc_info()
        msg = getattr(value, 'msg', '') or value or "<no detail available>"
        lineno = getattr(value, 'lineno', '') or 1
        offset = getattr(value, 'offset', '') or 0
        if offset == 0:
            lineno += 1 #mark end of offending line
        if lineno == 1:
            pos = "iomark + %d chars" % (offset-1)
        else:
            pos = "iomark linestart + %d lines + %d chars" % \
                  (lineno-1, offset-1)
        tkconsole.colorize_syntax_error(text, pos)
        tkconsole.resetoutput()
        self.write("SyntaxError: %s\n" % msg)
        tkconsole.showprompt()

    def showtraceback(self):
        "Extend base class method to reset output properly"
        self.tkconsole.resetoutput()
        self.checklinecache()
        InteractiveInterpreter.showtraceback(self)
        if self.tkconsole.getvar("<<toggle-jit-stack-viewer>>"):
            self.tkconsole.open_stack_viewer()

    def checklinecache(self):
        c = linecache.cache
        for key in list(c.keys()):
            if key[:1] + key[-1:] != "<>":
                del c[key]

    def runcommand(self, code):
        "Run the code without invoking the debugger"
        # The code better not raise an exception!
        if self.tkconsole.executing:
            self.display_executing_dialog()
            return 0
        if self.rpcclt:
            self.rpcclt.remotequeue("exec", "runcode", (code,), {})
        else:
            exec(code, self.locals)
        return 1

    def runcode(self, code):
        "Override base class method"
        if self.tkconsole.executing:
            self.interp.restart_subprocess()
        self.checklinecache()
        if self.save_warnings_filters is not None:
            warnings.filters[:] = self.save_warnings_filters
            self.save_warnings_filters = None
        debugger = self.debugger
        try:
            self.tkconsole.beginexecuting()
            if not debugger and self.rpcclt is not None:
                self.active_seq = self.rpcclt.asyncqueue("exec", "runcode",
                                                        (code,), {})
            elif debugger:
                debugger.run(code, self.locals)
            else:
                exec(code, self.locals)
        except SystemExit:
            if not self.tkconsole.closing:
                if tkMessageBox.askyesno(
                    "Exit?",
                    "Do you want to exit altogether?",
                    default="yes",
                    parent=self.tkconsole.text):
                    raise
                else:
                    self.showtraceback()
            else:
                raise
        except:
            if use_subprocess:
                print("IDLE internal error in runcode()",
                      file=self.tkconsole.stderr)
                self.showtraceback()
                self.tkconsole.endexecuting()
            else:
                if self.tkconsole.canceled:
                    self.tkconsole.canceled = False
                    print("KeyboardInterrupt", file=self.tkconsole.stderr)
                else:
                    self.showtraceback()
        finally:
            if not use_subprocess:
                try:
                    self.tkconsole.endexecuting()
                except AttributeError:  # shell may have closed
                    pass

    def write(self, s):
        "Override base class method"
        return self.tkconsole.stderr.write(s)

    def display_port_binding_error(self):
        tkMessageBox.showerror(
            "Port Binding Error",
            "IDLE can't bind to a TCP/IP port, which is necessary to "
            "communicate with its Python execution server.  This might be "
            "because no networking is installed on this computer.  "
            "Run IDLE with the -n command line switch to start without a "
            "subprocess and refer to Help/IDLE Help 'Running without a "
            "subprocess' for further details.",
            parent=self.tkconsole.text)

    def display_no_subprocess_error(self):
        tkMessageBox.showerror(
            "Subprocess Startup Error",
            "IDLE's subprocess didn't make connection.  Either IDLE can't "
            "start a subprocess or personal firewall software is blocking "
            "the connection.",
            parent=self.tkconsole.text)

    def display_executing_dialog(self):
        tkMessageBox.showerror(
            "Already executing",
            "The Python Shell window is already executing a command; "
            "please wait until it is finished.",
            parent=self.tkconsole.text)


class PyShell(OutputWindow):

    shell_title = "Python " + python_version() + " Shell"

    # Override classes
    ColorDelegator = ModifiedColorDelegator
    UndoDelegator = ModifiedUndoDelegator

    # Override menus
    menu_specs = [
        ("file", "_File"),
        ("edit", "_Edit"),
        ("debug", "_Debug"),
        ("options", "_Options"),
        ("windows", "_Window"),
        ("help", "_Help"),
    ]


    # New classes
    from idlelib.IdleHistory import History

    def __init__(self, flist=None):
        if use_subprocess:
            ms = self.menu_specs
            if ms[2][0] != "shell":
                ms.insert(2, ("shell", "She_ll"))
        self.interp = ModifiedInterpreter(self)
        if flist is None:
            root = Tk()
            fixwordbreaks(root)
            root.withdraw()
            flist = PyShellFileList(root)
        #
        OutputWindow.__init__(self, flist, None, None)
        #
##        self.config(usetabs=1, indentwidth=8, context_use_ps1=1)
        self.usetabs = True
        # indentwidth must be 8 when using tabs.  See note in EditorWindow:
        self.indentwidth = 8
        self.context_use_ps1 = True
        #
        text = self.text
        text.configure(wrap="char")
        text.bind("<<newline-and-indent>>", self.enter_callback)
        text.bind("<<plain-newline-and-indent>>", self.linefeed_callback)
        text.bind("<<interrupt-execution>>", self.cancel_callback)
        text.bind("<<end-of-file>>", self.eof_callback)
        text.bind("<<open-stack-viewer>>", self.open_stack_viewer)
        text.bind("<<toggle-debugger>>", self.toggle_debugger)
        text.bind("<<toggle-jit-stack-viewer>>", self.toggle_jit_stack_viewer)
        if use_subprocess:
            text.bind("<<view-restart>>", self.view_restart_mark)
            text.bind("<<restart-shell>>", self.restart_shell)
        #
        self.save_stdout = sys.stdout
        self.save_stderr = sys.stderr
        self.save_stdin = sys.stdin
        from idlelib import IOBinding
        self.stdin = PseudoInputFile(self, "stdin", IOBinding.encoding)
        self.stdout = PseudoOutputFile(self, "stdout", IOBinding.encoding)
        self.stderr = PseudoOutputFile(self, "stderr", IOBinding.encoding)
        self.console = PseudoOutputFile(self, "console", IOBinding.encoding)
        if not use_subprocess:
            sys.stdout = self.stdout
            sys.stderr = self.stderr
            sys.stdin = self.stdin
        try:
            # page help() text to shell.
            import pydoc # import must be done here to capture i/o rebinding.
            # XXX KBK 27Dec07 use a textView someday, but must work w/o subproc
            pydoc.pager = pydoc.plainpager
        except:
            sys.stderr = sys.__stderr__
            raise
        #
        self.history = self.History(self.text)
        #
        self.pollinterval = 50  # millisec

    def get_standard_extension_names(self):
        return idleConf.GetExtensions(shell_only=True)

    reading = False
    executing = False
    canceled = False
    endoffile = False
    closing = False
    _stop_readline_flag = False

    def set_warning_stream(self, stream):
        global warning_stream
        warning_stream = stream

    def get_warning_stream(self):
        return warning_stream

    def toggle_debugger(self, event=None):
        if self.executing:
            tkMessageBox.showerror("Don't debug now",
                "You can only toggle the debugger when idle",
                parent=self.text)
            self.set_debugger_indicator()
            return "break"
        else:
            db = self.interp.getdebugger()
            if db:
                self.close_debugger()
            else:
                self.open_debugger()

    def set_debugger_indicator(self):
        db = self.interp.getdebugger()
        self.setvar("<<toggle-debugger>>", not not db)

    def toggle_jit_stack_viewer(self, event=None):
        pass # All we need is the variable

    def close_debugger(self):
        db = self.interp.getdebugger()
        if db:
            self.interp.setdebugger(None)
            db.close()
            if self.interp.rpcclt:
                RemoteDebugger.close_remote_debugger(self.interp.rpcclt)
            self.resetoutput()
            self.console.write("[DEBUG OFF]\n")
            sys.ps1 = ">>> "
            self.showprompt()
        self.set_debugger_indicator()

    def open_debugger(self):
        if self.interp.rpcclt:
            dbg_gui = RemoteDebugger.start_remote_debugger(self.interp.rpcclt,
                                                           self)
        else:
            dbg_gui = Debugger.Debugger(self)
        self.interp.setdebugger(dbg_gui)
        dbg_gui.load_breakpoints()
        sys.ps1 = "[DEBUG ON]\n>>> "
        self.showprompt()
        self.set_debugger_indicator()

    def beginexecuting(self):
        "Helper for ModifiedInterpreter"
        self.resetoutput()
        self.executing = 1

    def endexecuting(self):
        "Helper for ModifiedInterpreter"
        self.executing = 0
        self.canceled = 0
        self.showprompt()

    def close(self):
        "Extend EditorWindow.close()"
        if self.executing:
            response = tkMessageBox.askokcancel(
                "Kill?",
                "Your program is still running!\n Do you want to kill it?",
                default="ok",
                parent=self.text)
            if response is False:
                return "cancel"
        self.stop_readline()
        self.canceled = True
        self.closing = True
        return EditorWindow.close(self)

    def _close(self):
        "Extend EditorWindow._close(), shut down debugger and execution server"
        self.close_debugger()
        if use_subprocess:
            self.interp.kill_subprocess()
        # Restore std streams
        sys.stdout = self.save_stdout
        sys.stderr = self.save_stderr
        sys.stdin = self.save_stdin
        # Break cycles
        self.interp = None
        self.console = None
        self.flist.pyshell = None
        self.history = None
        EditorWindow._close(self)

    def ispythonsource(self, filename):
        "Override EditorWindow method: never remove the colorizer"
        return True

    def short_title(self):
        return self.shell_title

    COPYRIGHT = \
          'Type "copyright", "credits" or "license()" for more information.'

    def begin(self):
        self.text.mark_set("iomark", "insert")
        self.resetoutput()
        if use_subprocess:
            nosub = ''
            client = self.interp.start_subprocess()
            if not client:
                self.close()
                return False
        else:
            nosub = ("==== No Subprocess ====\n\n" +
                    "WARNING: Running IDLE without a Subprocess is deprecated\n" +
                    "and will be removed in a later version. See Help/IDLE Help\n" +
                    "for details.\n\n")
            sys.displayhook = rpc.displayhook

        self.write("Python %s on %s\n%s\n%s" %
                   (sys.version, sys.platform, self.COPYRIGHT, nosub))
        self.text.focus_force()
        self.showprompt()
        import tkinter
        tkinter._default_root = None # 03Jan04 KBK What's this?
        return True

    def stop_readline(self):
        if not self.reading:  # no nested mainloop to exit.
            return
        self._stop_readline_flag = True
        self.top.quit()

    def readline(self):
        save = self.reading
        try:
            self.reading = 1
            self.top.mainloop()  # nested mainloop()
        finally:
            self.reading = save
        if self._stop_readline_flag:
            self._stop_readline_flag = False
            return ""
        line = self.text.get("iomark", "end-1c")
        if len(line) == 0:  # may be EOF if we quit our mainloop with Ctrl-C
            line = "\n"
        self.resetoutput()
        if self.canceled:
            self.canceled = 0
            if not use_subprocess:
                raise KeyboardInterrupt
        if self.endoffile:
            self.endoffile = 0
            line = ""
        return line

    def isatty(self):
        return True

    def cancel_callback(self, event=None):
        try:
            if self.text.compare("sel.first", "!=", "sel.last"):
                return # Active selection -- always use default binding
        except:
            pass
        if not (self.executing or self.reading):
            self.resetoutput()
            self.interp.write("KeyboardInterrupt\n")
            self.showprompt()
            return "break"
        self.endoffile = 0
        self.canceled = 1
        if (self.executing and self.interp.rpcclt):
            if self.interp.getdebugger():
                self.interp.restart_subprocess()
            else:
                self.interp.interrupt_subprocess()
        if self.reading:
            self.top.quit()  # exit the nested mainloop() in readline()
        return "break"

    def eof_callback(self, event):
        if self.executing and not self.reading:
            return # Let the default binding (delete next char) take over
        if not (self.text.compare("iomark", "==", "insert") and
                self.text.compare("insert", "==", "end-1c")):
            return # Let the default binding (delete next char) take over
        if not self.executing:
            self.resetoutput()
            self.close()
        else:
            self.canceled = 0
            self.endoffile = 1
            self.top.quit()
        return "break"

    def linefeed_callback(self, event):
        # Insert a linefeed without entering anything (still autoindented)
        if self.reading:
            self.text.insert("insert", "\n")
            self.text.see("insert")
        else:
            self.newline_and_indent_event(event)
        return "break"

    def enter_callback(self, event):
        if self.executing and not self.reading:
            return # Let the default binding (insert '\n') take over
        # If some text is selected, recall the selection
        # (but only if this before the I/O mark)
        try:
            sel = self.text.get("sel.first", "sel.last")
            if sel:
                if self.text.compare("sel.last", "<=", "iomark"):
                    self.recall(sel, event)
                    return "break"
        except:
            pass
        # If we're strictly before the line containing iomark, recall
        # the current line, less a leading prompt, less leading or
        # trailing whitespace
        if self.text.compare("insert", "<", "iomark linestart"):
            # Check if there's a relevant stdin range -- if so, use it
            prev = self.text.tag_prevrange("stdin", "insert")
            if prev and self.text.compare("insert", "<", prev[1]):
                self.recall(self.text.get(prev[0], prev[1]), event)
                return "break"
            next = self.text.tag_nextrange("stdin", "insert")
            if next and self.text.compare("insert lineend", ">=", next[0]):
                self.recall(self.text.get(next[0], next[1]), event)
                return "break"
            # No stdin mark -- just get the current line, less any prompt
            indices = self.text.tag_nextrange("console", "insert linestart")
            if indices and \
               self.text.compare(indices[0], "<=", "insert linestart"):
                self.recall(self.text.get(indices[1], "insert lineend"), event)
            else:
                self.recall(self.text.get("insert linestart", "insert lineend"), event)
            return "break"
        # If we're between the beginning of the line and the iomark, i.e.
        # in the prompt area, move to the end of the prompt
        if self.text.compare("insert", "<", "iomark"):
            self.text.mark_set("insert", "iomark")
        # If we're in the current input and there's only whitespace
        # beyond the cursor, erase that whitespace first
        s = self.text.get("insert", "end-1c")
        if s and not s.strip():
            self.text.delete("insert", "end-1c")
        # If we're in the current input before its last line,
        # insert a newline right at the insert point
        if self.text.compare("insert", "<", "end-1c linestart"):
            self.newline_and_indent_event(event)
            return "break"
        # We're in the last line; append a newline and submit it
        self.text.mark_set("insert", "end-1c")
        if self.reading:
            self.text.insert("insert", "\n")
            self.text.see("insert")
        else:
            self.newline_and_indent_event(event)
        self.text.tag_add("stdin", "iomark", "end-1c")
        self.text.update_idletasks()
        if self.reading:
            self.top.quit() # Break out of recursive mainloop()
        else:
            self.runit()
        return "break"

    def recall(self, s, event):
        # remove leading and trailing empty or whitespace lines
        s = re.sub(r'^\s*\n', '' , s)
        s = re.sub(r'\n\s*$', '', s)
        lines = s.split('\n')
        self.text.undo_block_start()
        try:
            self.text.tag_remove("sel", "1.0", "end")
            self.text.mark_set("insert", "end-1c")
            prefix = self.text.get("insert linestart", "insert")
            if prefix.rstrip().endswith(':'):
                self.newline_and_indent_event(event)
                prefix = self.text.get("insert linestart", "insert")
            self.text.insert("insert", lines[0].strip())
            if len(lines) > 1:
                orig_base_indent = re.search(r'^([ \t]*)', lines[0]).group(0)
                new_base_indent  = re.search(r'^([ \t]*)', prefix).group(0)
                for line in lines[1:]:
                    if line.startswith(orig_base_indent):
                        # replace orig base indentation with new indentation
                        line = new_base_indent + line[len(orig_base_indent):]
                    self.text.insert('insert', '\n'+line.rstrip())
        finally:
            self.text.see("insert")
            self.text.undo_block_stop()

    def runit(self):
        line = self.text.get("iomark", "end-1c")
        # Strip off last newline and surrounding whitespace.
        # (To allow you to hit return twice to end a statement.)
        i = len(line)
        while i > 0 and line[i-1] in " \t":
            i = i-1
        if i > 0 and line[i-1] == "\n":
            i = i-1
        while i > 0 and line[i-1] in " \t":
            i = i-1
        line = line[:i]
        self.interp.runsource(line)

    def open_stack_viewer(self, event=None):
        if self.interp.rpcclt:
            return self.interp.remote_stack_viewer()
        try:
            sys.last_traceback
        except:
            tkMessageBox.showerror("No stack trace",
                "There is no stack trace yet.\n"
                "(sys.last_traceback is not defined)",
                parent=self.text)
            return
        from idlelib.StackViewer import StackBrowser
        StackBrowser(self.root, self.flist)

    def view_restart_mark(self, event=None):
        self.text.see("iomark")
        self.text.see("restart")

    def restart_shell(self, event=None):
        "Callback for Run/Restart Shell Cntl-F6"
        self.interp.restart_subprocess(with_cwd=True)

    def showprompt(self):
        self.resetoutput()
        try:
            s = str(sys.ps1)
        except:
            s = ""
        self.console.write(s)
        self.text.mark_set("insert", "end-1c")
        self.set_line_and_column()
        self.io.reset_undo()

    def resetoutput(self):
        source = self.text.get("iomark", "end-1c")
        if self.history:
            self.history.store(source)
        if self.text.get("end-2c") != "\n":
            self.text.insert("end-1c", "\n")
        self.text.mark_set("iomark", "end-1c")
        self.set_line_and_column()

    def write(self, s, tags=()):
        if isinstance(s, str) and len(s) and max(s) > '\uffff':
            # Tk doesn't support outputting non-BMP characters
            # Let's assume what printed string is not very long,
            # find first non-BMP character and construct informative
            # UnicodeEncodeError exception.
            for start, char in enumerate(s):
                if char > '\uffff':
                    break
            raise UnicodeEncodeError("UCS-2", char, start, start+1,
                                     'Non-BMP character not supported in Tk')
        try:
            self.text.mark_gravity("iomark", "right")
            count = OutputWindow.write(self, s, tags, "iomark")
            self.text.mark_gravity("iomark", "left")
        except:
            raise ###pass  # ### 11Aug07 KBK if we are expecting exceptions
                           # let's find out what they are and be specific.
        if self.canceled:
            self.canceled = 0
            if not use_subprocess:
                raise KeyboardInterrupt
        return count

    def rmenu_check_cut(self):
        try:
            if self.text.compare('sel.first', '<', 'iomark'):
                return 'disabled'
        except TclError: # no selection, so the index 'sel.first' doesn't exist
            return 'disabled'
        return super().rmenu_check_cut()

    def rmenu_check_paste(self):
        if self.text.compare('insert','<','iomark'):
            return 'disabled'
        return super().rmenu_check_paste()

class PseudoFile(io.TextIOBase):

    def __init__(self, shell, tags, encoding=None):
        self.shell = shell
        self.tags = tags
        self._encoding = encoding

    @property
    def encoding(self):
        return self._encoding

    @property
    def name(self):
        return '<%s>' % self.tags

    def isatty(self):
        return True


class PseudoOutputFile(PseudoFile):

    def writable(self):
        return True

    def write(self, s):
        if self.closed:
            raise ValueError("write to closed file")
        if type(s) is not str:
            if not isinstance(s, str):
                raise TypeError('must be str, not ' + type(s).__name__)
            # See issue #19481
            s = str.__str__(s)
        return self.shell.write(s, self.tags)


class PseudoInputFile(PseudoFile):

    def __init__(self, shell, tags, encoding=None):
        PseudoFile.__init__(self, shell, tags, encoding)
        self._line_buffer = ''

    def readable(self):
        return True

    def read(self, size=-1):
        if self.closed:
            raise ValueError("read from closed file")
        if size is None:
            size = -1
        elif not isinstance(size, int):
            raise TypeError('must be int, not ' + type(size).__name__)
        result = self._line_buffer
        self._line_buffer = ''
        if size < 0:
            while True:
                line = self.shell.readline()
                if not line: break
                result += line
        else:
            while len(result) < size:
                line = self.shell.readline()
                if not line: break
                result += line
            self._line_buffer = result[size:]
            result = result[:size]
        return result

    def readline(self, size=-1):
        if self.closed:
            raise ValueError("read from closed file")
        if size is None:
            size = -1
        elif not isinstance(size, int):
            raise TypeError('must be int, not ' + type(size).__name__)
        line = self._line_buffer or self.shell.readline()
        if size < 0:
            size = len(line)
        eol = line.find('\n', 0, size)
        if eol >= 0:
            size = eol + 1
        self._line_buffer = line[size:]
        return line[:size]

    def close(self):
        self.shell.close()


def fix_x11_paste(root):
    "Make paste replace selection on x11.  See issue #5124."
    if root._windowingsystem == 'x11':
        for cls in 'Text', 'Entry', 'Spinbox':
            root.bind_class(
                cls,
                '<<Paste>>',
                'catch {%W delete sel.first sel.last}\n' +
                        root.bind_class(cls, '<<Paste>>'))


usage_msg = """\

USAGE: idle  [-deins] [-t title] [file]*
       idle  [-dns] [-t title] (-c cmd | -r file) [arg]*
       idle  [-dns] [-t title] - [arg]*

  -h         print this help message and exit
  -n         run IDLE without a subprocess (DEPRECATED,
             see Help/IDLE Help for details)

The following options will override the IDLE 'settings' configuration:

  -e         open an edit window
  -i         open a shell window

The following options imply -i and will open a shell:

  -c cmd     run the command in a shell, or
  -r file    run script from file

  -d         enable the debugger
  -s         run $IDLESTARTUP or $PYTHONSTARTUP before anything else
  -t title   set title of shell window

A default edit window will be bypassed when -c, -r, or - are used.

[arg]* are passed to the command (-c) or script (-r) in sys.argv[1:].

Examples:

idle
        Open an edit window or shell depending on IDLE's configuration.

idle foo.py foobar.py
        Edit the files, also open a shell if configured to start with shell.

idle -est "Baz" foo.py
        Run $IDLESTARTUP or $PYTHONSTARTUP, edit foo.py, and open a shell
        window with the title "Baz".

idle -c "import sys; print(sys.argv)" "foo"
        Open a shell window and run the command, passing "-c" in sys.argv[0]
        and "foo" in sys.argv[1].

idle -d -s -r foo.py "Hello World"
        Open a shell window, run a startup script, enable the debugger, and
        run foo.py, passing "foo.py" in sys.argv[0] and "Hello World" in
        sys.argv[1].

echo "import sys; print(sys.argv)" | idle - "foobar"
        Open a shell window, run the script piped in, passing '' in sys.argv[0]
        and "foobar" in sys.argv[1].
"""

def main():
    global flist, root, use_subprocess

    capture_warnings(True)
    use_subprocess = True
    enable_shell = False
    enable_edit = False
    debug = False
    cmd = None
    script = None
    startup = False
    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:deihnr:st:")
    except getopt.error as msg:
        print("Error: %s\n%s" % (msg, usage_msg), file=sys.stderr)
        sys.exit(2)
    for o, a in opts:
        if o == '-c':
            cmd = a
            enable_shell = True
        if o == '-d':
            debug = True
            enable_shell = True
        if o == '-e':
            enable_edit = True
        if o == '-h':
            sys.stdout.write(usage_msg)
            sys.exit()
        if o == '-i':
            enable_shell = True
        if o == '-n':
            print(" Warning: running IDLE without a subprocess is deprecated.",
                  file=sys.stderr)
            use_subprocess = False
        if o == '-r':
            script = a
            if os.path.isfile(script):
                pass
            else:
                print("No script file: ", script)
                sys.exit()
            enable_shell = True
        if o == '-s':
            startup = True
            enable_shell = True
        if o == '-t':
            PyShell.shell_title = a
            enable_shell = True
    if args and args[0] == '-':
        cmd = sys.stdin.read()
        enable_shell = True
    # process sys.argv and sys.path:
    for i in range(len(sys.path)):
        sys.path[i] = os.path.abspath(sys.path[i])
    if args and args[0] == '-':
        sys.argv = [''] + args[1:]
    elif cmd:
        sys.argv = ['-c'] + args
    elif script:
        sys.argv = [script] + args
    elif args:
        enable_edit = True
        pathx = []
        for filename in args:
            pathx.append(os.path.dirname(filename))
        for dir in pathx:
            dir = os.path.abspath(dir)
            if not dir in sys.path:
                sys.path.insert(0, dir)
    else:
        dir = os.getcwd()
        if dir not in sys.path:
            sys.path.insert(0, dir)
    # check the IDLE settings configuration (but command line overrides)
    edit_start = idleConf.GetOption('main', 'General',
                                    'editor-on-startup', type='bool')
    enable_edit = enable_edit or edit_start
    enable_shell = enable_shell or not enable_edit

    # start editor and/or shell windows:
    root = Tk(className="Idle")
    root.withdraw()

    # set application icon
    icondir = os.path.join(os.path.dirname(__file__), 'Icons')
    if system() == 'Windows':
        iconfile = os.path.join(icondir, 'idle.ico')
        root.wm_iconbitmap(default=iconfile)
    elif TkVersion >= 8.5:
        ext = '.png' if TkVersion >= 8.6 else '.gif'
        iconfiles = [os.path.join(icondir, 'idle_%d%s' % (size, ext))
                     for size in (16, 32, 48)]
        icons = [PhotoImage(file=iconfile) for iconfile in iconfiles]
        root.wm_iconphoto(True, *icons)

    fixwordbreaks(root)
    fix_x11_paste(root)
    flist = PyShellFileList(root)
    macosxSupport.setupApp(root, flist)

    if macosxSupport.isAquaTk():
        # There are some screwed up <2> class bindings for text
        # widgets defined in Tk which we need to do away with.
        # See issue #24801.
        root.unbind_class('Text', '<B2>')
        root.unbind_class('Text', '<B2-Motion>')
        root.unbind_class('Text', '<<PasteSelection>>')

    if enable_edit:
        if not (cmd or script):
            for filename in args[:]:
                if flist.open(filename) is None:
                    # filename is a directory actually, disconsider it
                    args.remove(filename)
            if not args:
                flist.new()

    if enable_shell:
        shell = flist.open_shell()
        if not shell:
            return # couldn't open shell
        if macosxSupport.isAquaTk() and flist.dict:
            # On OSX: when the user has double-clicked on a file that causes
            # IDLE to be launched the shell window will open just in front of
            # the file she wants to see. Lower the interpreter window when
            # there are open files.
            shell.top.lower()
    else:
        shell = flist.pyshell

    # Handle remaining options. If any of these are set, enable_shell
    # was set also, so shell must be true to reach here.
    if debug:
        shell.open_debugger()
    if startup:
        filename = os.environ.get("IDLESTARTUP") or \
                   os.environ.get("PYTHONSTARTUP")
        if filename and os.path.isfile(filename):
            shell.interp.execfile(filename)
    if cmd or script:
        shell.interp.runcommand("""if 1:
            import sys as _sys
            _sys.argv = %r
            del _sys
            \n""" % (sys.argv,))
        if cmd:
            shell.interp.execsource(cmd)
        elif script:
            shell.interp.prepend_syspath(script)
            shell.interp.execfile(script)
    elif shell:
        # If there is a shell window and no cmd or script in progress,
        # check for problematic OS X Tk versions and print a warning
        # message in the IDLE shell window; this is less intrusive
        # than always opening a separate window.
        tkversionwarning = macosxSupport.tkVersionWarning(root)
        if tkversionwarning:
            shell.interp.runcommand("print('%s')" % tkversionwarning)

    while flist.inversedict:  # keep IDLE running while files are open.
        root.mainloop()
    root.destroy()
    capture_warnings(False)

if __name__ == "__main__":
    sys.modules['PyShell'] = sys.modules['__main__']
    main()

capture_warnings(False)  # Make sure turned off; see issue 18081
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from idlelib import rpc

def remote_object_tree_item(item):
    wrapper = WrappedObjectTreeItem(item)
    oid = id(wrapper)
    rpc.objecttable[oid] = wrapper
    return oid

class WrappedObjectTreeItem:
    # Lives in PYTHON subprocess

    def __init__(self, item):
        self.__item = item

    def __getattr__(self, name):
        value = getattr(self.__item, name)
        return value

    def _GetSubList(self):
        sub_list = self.__item._GetSubList()
        return list(map(remote_object_tree_item, sub_list))

class StubObjectTreeItem:
    # Lives in IDLE process

    def __init__(self, sockio, oid):
        self.sockio = sockio
        self.oid = oid

    def __getattr__(self, name):
        value = rpc.MethodProxy(self.sockio, self.oid, name)
        return value

    def _GetSubList(self):
        sub_list = self.sockio.remotecall(self.oid, "_GetSubList", (), {})
        return [StubObjectTreeItem(self.sockio, oid) for oid in sub_list]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            README.txt: an index to idlelib files and the IDLE menu.

IDLE is Python's Integrated Development and Learning
Environment.  The user documentation is part of the Library Reference and
is available in IDLE by selecting Help => IDLE Help.  This README documents
idlelib for IDLE developers and curious users.

IDLELIB FILES lists files alphabetically by category,
with a short description of each.

IDLE MENU show the menu tree, annotated with the module
or module object that implements the corresponding function.

This file is descriptive, not prescriptive, and may have errors
and omissions and lag behind changes in idlelib.


IDLELIB FILES
Implementation files not in IDLE MENU are marked (nim).
Deprecated files and objects are listed separately as the end.

Startup
-------
__init__.py  # import, does nothing
__main__.py  # -m, starts IDLE
idle.bat
idle.py
idle.pyw

Implementation
--------------
AutoComplete.py   # Complete attribute names or filenames.
AutoCompleteWindow.py  # Display completions.
AutoExpand.py     # Expand word with previous word in file.
Bindings.py       # Define most of IDLE menu.
CallTipWindow.py  # Display calltip.
CallTips.py       # Create calltip text.
ClassBrowser.py   # Create module browser window.
CodeContext.py    # Show compound statement headers otherwise not visible.
ColorDelegator.py # Colorize text (nim).
Debugger.py       # Debug code run from editor; show window.
Delegator.py      # Define base class for delegators (nim).
EditorWindow.py   # Define most of editor and utility functions.
FileList.py       # Open files and manage list of open windows (nim).
FormatParagraph.py# Re-wrap multiline strings and comments.
GrepDialog.py     # Find all occurrences of pattern in multiple files.
HyperParser.py    # Parse code around a given index.
IOBinding.py      # Open, read, and write files
IdleHistory.py    # Get previous or next user input in shell (nim)
MultiCall.py      # Wrap tk widget to allow multiple calls per event (nim).
MultiStatusBar.py # Define status bar for windows (nim).
ObjectBrowser.py  # Define class used in StackViewer (nim).
OutputWindow.py   # Create window for grep output.
ParenMatch.py     # Match fenceposts: (), [], and {}.
PathBrowser.py    # Create path browser window.
Percolator.py     # Manage delegator stack (nim).
PyParse.py        # Give information on code indentation
PyShell.py        # Start IDLE, manage shell, complete editor window
RemoteDebugger.py # Debug code run in remote process.
RemoteObjectBrowser.py # Communicate objects between processes with rpc (nim).
ReplaceDialog.py  # Search and replace pattern in text.
RstripExtension.py# Strip trailing whitespace
ScriptBinding.py  # Check and run user code.
ScrolledList.py   # Define ScrolledList widget for IDLE (nim).
SearchDialog.py   # Search for pattern in text.
SearchDialogBase.py  # Define base for search, replace, and grep dialogs.
SearchEngine.py   # Define engine for all 3 search dialogs.
StackViewer.py    # View stack after exception.
TreeWidget.py     # Define tree widger, used in browsers (nim).
UndoDelegator.py  # Manage undo stack.
WidgetRedirector.py # Intercept widget subcommands (for percolator) (nim).
WindowList.py     # Manage window list and define listed top level.
ZoomHeight.py     # Zoom window to full height of screen.
aboutDialog.py    # Display About IDLE dialog.
configDialog.py   # Display user configuration dialogs.
configHandler.py  # Load, fetch, and save configuration (nim).
configHelpSourceEdit.py  # Specify help source.
configSectionNameDialog.py  # Spefify user config section name
dynOptionMenuWidget.py  # define mutable OptionMenu widget (nim).
help.py           # Display IDLE's html doc.
keybindingDialog.py  # Change keybindings.
macosxSupport.py  # Help IDLE run on Macs (nim).
rpc.py            # Commuicate between idle and user processes (nim).
run.py            # Manage user code execution subprocess.
tabbedpages.py    # Define tabbed pages widget (nim).
textView.py       # Define read-only text widget (nim).

Configuration
-------------
config-extensions.def # Defaults for extensions
config-highlight.def  # Defaults for colorizing
config-keys.def       # Defaults for key bindings
config-main.def       # Defai;ts fpr font and geneal

Text
----
CREDITS.txt  # not maintained, displayed by About IDLE
HISTORY.txt  # NEWS up to July 2001
NEWS.txt     # commits, displayed by About IDLE
README.txt   # this file, displeyed by About IDLE
TODO.txt     # needs review
extend.txt   # about writing extensions
help.html    # copy of idle.html in docs, displayed by IDLE Help

Subdirectories
--------------
Icons  # small image files
idle_test  # files for human test and automated unit tests

Unused and Deprecated files and objects (nim)
---------------------------------------------
EditorWindow.py: Helpdialog and helpDialog
ToolTip.py: unused.
help.txt
idlever.py


IDLE MENUS
Top level items and most submenu items are defined in Bindings.
Extenstions add submenu items when active.  The names given are
found, quoted, in one of these modules, paired with a '<<pseudoevent>>'.
Each pseudoevent is bound to an event handler.  Some event handlers
call another function that does the actual work.  The annotations below
are intended to at least give the module where the actual work is done.

File  # IOBindig except as noted
  New File
  Open...  # IOBinding.open
  Open Module
  Recent Files
  Class Browser  # Class Browser
  Path Browser  # Path Browser
  ---
  Save  # IDBinding.save
  Save As...  # IOBinding.save_as
  Save Copy As...  # IOBindling.save_a_copy
  ---
  Print Window  # IOBinding.print_window
  ---
  Close
  Exit

Edit
  Undo  # undoDelegator
  Redo  # undoDelegator
  ---
  Cut
  Copy
  Paste
  Select All
  ---  # Next 5 items use SearchEngine; dialogs use SearchDialogBase
  Find  # Search Dialog
  Find Again
  Find Selection
  Find in Files...  # GrepDialog
  Replace...  # ReplaceDialog
  Go to Line
  Show Completions  # AutoComplete extension and AutoCompleteWidow (&HP)
  Expand Word  # AutoExpand extension
  Show call tip  # Calltips extension and CalltipWindow (& Hyperparser)
  Show surrounding parens  # ParenMatch (& Hyperparser)

Shell  # PyShell
  View Last Restart    # PyShell.PyShell.view_restart_mark
  Restart Shell        # PyShell.PyShell.restart_shell
  Interrupt Execution  # pyshell.PyShell.cancel_callback

Debug (Shell only)
  Go to File/Line
  Debugger               # Debugger, RemoteDebugger, PyShell.toggle_debuger
  Stack Viewer           # StackViewer, PyShell.open_stack_viewer
  Auto-open Stack Viewer # StackViewer

Format (Editor only)
  Indent Region
  Dedent Region
  Comment Out Region
  Uncomment Region
  Tabify Region
  Untabify Region
  Toggle Tabs
  New Indent Width
  Format Paragraph  # FormatParagraph extension
  ---
  Strip tailing whitespace  # RstripExtension extension

Run (Editor only)
  Python Shell  # PyShell
  ---
  Check Module  # ScriptBinding
  Run Module  # ScriptBinding

Options
  Configure IDLE  # configDialog
    (tabs in the dialog)
    Font tab  # onfig-main.def
    Highlight tab  # configSectionNameDialog, config-highlight.def
    Keys tab  # keybindingDialog, configSectionNameDialog, onfig-keus.def
    General tab  # configHelpSourceEdit, config-main.def
  Configure Extensions  # configDialog
    Xyz tab  # xyz.py, config-extensions.def
  ---
  Code Context (editor only)  # CodeContext extension

Window
  Zoomheight  # ZoomHeight extension
  ---
  <open windows>  # WindowList

Help
  About IDLE  # aboutDialog
  ---
  IDLE Help  # help
  Python Doc
  Turtle Demo
  ---
  <other help sources>

<Context Menu> (right click)
Defined in EditorWindow, PyShell, Output
   Cut
   Copy
   Paste
   ---
   Go to file/line (shell and output only)
   Set Breakpoint (editor only)
   Clear Breakpoint (editor only)
 Defined in Debugger
   Go to source line
   Show stack frame
                                                                                                                                                                                                                                                                                                             """Support for remote Python debugging.

Some ASCII art to describe the structure:

       IN PYTHON SUBPROCESS          #             IN IDLE PROCESS
                                     #
                                     #        oid='gui_adapter'
                 +----------+        #       +------------+          +-----+
                 | GUIProxy |--remote#call-->| GUIAdapter |--calls-->| GUI |
+-----+--calls-->+----------+        #       +------------+          +-----+
| Idb |                               #                             /
+-----+<-calls--+------------+         #      +----------+<--calls-/
                | IdbAdapter |<--remote#call--| IdbProxy |
                +------------+         #      +----------+
                oid='idb_adapter'      #

The purpose of the Proxy and Adapter classes is to translate certain
arguments and return values that cannot be transported through the RPC
barrier, in particular frame and traceback objects.

"""

import types
from idlelib import Debugger

debugging = 0

idb_adap_oid = "idb_adapter"
gui_adap_oid = "gui_adapter"

#=======================================
#
# In the PYTHON subprocess:

frametable = {}
dicttable = {}
codetable = {}
tracebacktable = {}

def wrap_frame(frame):
    fid = id(frame)
    frametable[fid] = frame
    return fid

def wrap_info(info):
    "replace info[2], a traceback instance, by its ID"
    if info is None:
        return None
    else:
        traceback = info[2]
        assert isinstance(traceback, types.TracebackType)
        traceback_id = id(traceback)
        tracebacktable[traceback_id] = traceback
        modified_info = (info[0], info[1], traceback_id)
        return modified_info

class GUIProxy:

    def __init__(self, conn, gui_adap_oid):
        self.conn = conn
        self.oid = gui_adap_oid

    def interaction(self, message, frame, info=None):
        # calls rpc.SocketIO.remotecall() via run.MyHandler instance
        # pass frame and traceback object IDs instead of the objects themselves
        self.conn.remotecall(self.oid, "interaction",
                             (message, wrap_frame(frame), wrap_info(info)),
                             {})

class IdbAdapter:

    def __init__(self, idb):
        self.idb = idb

    #----------called by an IdbProxy----------

    def set_step(self):
        self.idb.set_step()

    def set_quit(self):
        self.idb.set_quit()

    def set_continue(self):
        self.idb.set_continue()

    def set_next(self, fid):
        frame = frametable[fid]
        self.idb.set_next(frame)

    def set_return(self, fid):
        frame = frametable[fid]
        self.idb.set_return(frame)

    def get_stack(self, fid, tbid):
        frame = frametable[fid]
        if tbid is None:
            tb = None
        else:
            tb = tracebacktable[tbid]
        stack, i = self.idb.get_stack(frame, tb)
        stack = [(wrap_frame(frame2), k) for frame2, k in stack]
        return stack, i

    def run(self, cmd):
        import __main__
        self.idb.run(cmd, __main__.__dict__)

    def set_break(self, filename, lineno):
        msg = self.idb.set_break(filename, lineno)
        return msg

    def clear_break(self, filename, lineno):
        msg = self.idb.clear_break(filename, lineno)
        return msg

    def clear_all_file_breaks(self, filename):
        msg = self.idb.clear_all_file_breaks(filename)
        return msg

    #----------called by a FrameProxy----------

    def frame_attr(self, fid, name):
        frame = frametable[fid]
        return getattr(frame, name)

    def frame_globals(self, fid):
        frame = frametable[fid]
        dict = frame.f_globals
        did = id(dict)
        dicttable[did] = dict
        return did

    def frame_locals(self, fid):
        frame = frametable[fid]
        dict = frame.f_locals
        did = id(dict)
        dicttable[did] = dict
        return did

    def frame_code(self, fid):
        frame = frametable[fid]
        code = frame.f_code
        cid = id(code)
        codetable[cid] = code
        return cid

    #----------called by a CodeProxy----------

    def code_name(self, cid):
        code = codetable[cid]
        return code.co_name

    def code_filename(self, cid):
        code = codetable[cid]
        return code.co_filename

    #----------called by a DictProxy----------

    def dict_keys(self, did):
        raise NotImplemented("dict_keys not public or pickleable")
##         dict = dicttable[did]
##         return dict.keys()

    ### Needed until dict_keys is type is finished and pickealable.
    ### Will probably need to extend rpc.py:SocketIO._proxify at that time.
    def dict_keys_list(self, did):
        dict = dicttable[did]
        return list(dict.keys())

    def dict_item(self, did, key):
        dict = dicttable[did]
        value = dict[key]
        value = repr(value) ### can't pickle module 'builtins'
        return value

#----------end class IdbAdapter----------


def start_debugger(rpchandler, gui_adap_oid):
    """Start the debugger and its RPC link in the Python subprocess

    Start the subprocess side of the split debugger and set up that side of the
    RPC link by instantiating the GUIProxy, Idb debugger, and IdbAdapter
    objects and linking them together.  Register the IdbAdapter with the
    RPCServer to handle RPC requests from the split debugger GUI via the
    IdbProxy.

    """
    gui_proxy = GUIProxy(rpchandler, gui_adap_oid)
    idb = Debugger.Idb(gui_proxy)
    idb_adap = IdbAdapter(idb)
    rpchandler.register(idb_adap_oid, idb_adap)
    return idb_adap_oid


#=======================================
#
# In the IDLE process:


class FrameProxy:

    def __init__(self, conn, fid):
        self._conn = conn
        self._fid = fid
        self._oid = "idb_adapter"
        self._dictcache = {}

    def __getattr__(self, name):
        if name[:1] == "_":
            raise AttributeError(name)
        if name == "f_code":
            return self._get_f_code()
        if name == "f_globals":
            return self._get_f_globals()
        if name == "f_locals":
            return self._get_f_locals()
        return self._conn.remotecall(self._oid, "frame_attr",
                                     (self._fid, name), {})

    def _get_f_code(self):
        cid = self._conn.remotecall(self._oid, "frame_code", (self._fid,), {})
        return CodeProxy(self._conn, self._oid, cid)

    def _get_f_globals(self):
        did = self._conn.remotecall(self._oid, "frame_globals",
                                    (self._fid,), {})
        return self._get_dict_proxy(did)

    def _get_f_locals(self):
        did = self._conn.remotecall(self._oid, "frame_locals",
                                    (self._fid,), {})
        return self._get_dict_proxy(did)

    def _get_dict_proxy(self, did):
        if did in self._dictcache:
            return self._dictcache[did]
        dp = DictProxy(self._conn, self._oid, did)
        self._dictcache[did] = dp
        return dp


class CodeProxy:

    def __init__(self, conn, oid, cid):
        self._conn = conn
        self._oid = oid
        self._cid = cid

    def __getattr__(self, name):
        if name == "co_name":
            return self._conn.remotecall(self._oid, "code_name",
                                         (self._cid,), {})
        if name == "co_filename":
            return self._conn.remotecall(self._oid, "code_filename",
                                         (self._cid,), {})


class DictProxy:

    def __init__(self, conn, oid, did):
        self._conn = conn
        self._oid = oid
        self._did = did

##    def keys(self):
##        return self._conn.remotecall(self._oid, "dict_keys", (self._did,), {})

    # 'temporary' until dict_keys is a pickleable built-in type
    def keys(self):
        return self._conn.remotecall(self._oid,
                                     "dict_keys_list", (self._did,), {})

    def __getitem__(self, key):
        return self._conn.remotecall(self._oid, "dict_item",
                                     (self._did, key), {})

    def __getattr__(self, name):
        ##print("*** Failed DictProxy.__getattr__:", name)
        raise AttributeError(name)


class GUIAdapter:

    def __init__(self, conn, gui):
        self.conn = conn
        self.gui = gui

    def interaction(self, message, fid, modified_info):
        ##print("*** Interaction: (%s, %s, %s)" % (message, fid, modified_info))
        frame = FrameProxy(self.conn, fid)
        self.gui.interaction(message, frame, modified_info)


class IdbProxy:

    def __init__(self, conn, shell, oid):
        self.oid = oid
        self.conn = conn
        self.shell = shell

    def call(self, methodname, *args, **kwargs):
        ##print("*** IdbProxy.call %s %s %s" % (methodname, args, kwargs))
        value = self.conn.remotecall(self.oid, methodname, args, kwargs)
        ##print("*** IdbProxy.call %s returns %r" % (methodname, value))
        return value

    def run(self, cmd, locals):
        # Ignores locals on purpose!
        seq = self.conn.asyncqueue(self.oid, "run", (cmd,), {})
        self.shell.interp.active_seq = seq

    def get_stack(self, frame, tbid):
        # passing frame and traceback IDs, not the objects themselves
        stack, i = self.call("get_stack", frame._fid, tbid)
        stack = [(FrameProxy(self.conn, fid), k) for fid, k in stack]
        return stack, i

    def set_continue(self):
        self.call("set_continue")

    def set_step(self):
        self.call("set_step")

    def set_next(self, frame):
        self.call("set_next", frame._fid)

    def set_return(self, frame):
        self.call("set_return", frame._fid)

    def set_quit(self):
        self.call("set_quit")

    def set_break(self, filename, lineno):
        msg = self.call("set_break", filename, lineno)
        return msg

    def clear_break(self, filename, lineno):
        msg = self.call("clear_break", filename, lineno)
        return msg

    def clear_all_file_breaks(self, filename):
        msg = self.call("clear_all_file_breaks", filename)
        return msg

def start_remote_debugger(rpcclt, pyshell):
    """Start the subprocess debugger, initialize the debugger GUI and RPC link

    Request the RPCServer start the Python subprocess debugger and link.  Set
    up the Idle side of the split debugger by instantiating the IdbProxy,
    debugger GUI, and debugger GUIAdapter objects and linking them together.

    Register the GUIAdapter with the RPCClient to handle debugger GUI
    interaction requests coming from the subprocess debugger via the GUIProxy.

    The IdbAdapter will pass execution and environment requests coming from the
    Idle debugger GUI to the subprocess debugger via the IdbProxy.

    """
    global idb_adap_oid

    idb_adap_oid = rpcclt.remotecall("exec", "start_the_debugger",\
                                   (gui_adap_oid,), {})
    idb_proxy = IdbProxy(rpcclt, pyshell, idb_adap_oid)
    gui = Debugger.Debugger(pyshell, idb_proxy)
    gui_adap = GUIAdapter(rpcclt, gui)
    rpcclt.register(gui_adap_oid, gui_adap)
    return gui

def close_remote_debugger(rpcclt):
    """Shut down subprocess debugger and Idle side of debugger RPC link

    Request that the RPCServer shut down the subprocess debugger and link.
    Unregister the GUIAdapter, which will cause a GC on the Idle process
    debugger and RPC link objects.  (The second reference to the debugger GUI
    is deleted in PyShell.close_remote_debugger().)

    """
    close_subprocess_debugger(rpcclt)
    rpcclt.unregister(gui_adap_oid)

def close_subprocess_debugger(rpcclt):
    rpcclt.remotecall("exec", "stop_the_debugger", (idb_adap_oid,), {})

def restart_subprocess_debugger(rpcclt):
    idb_adap_oid_ret = rpcclt.remotecall("exec", "start_the_debugger",\
                                         (gui_adap_oid,), {})
    assert idb_adap_oid_ret == idb_adap_oid, 'Idb restarted with different oid'
                                                                                                                                                                                                                                                                                         'Provides "Strip trailing whitespace" under the "Format" menu.'

class RstripExtension:

    menudefs = [
        ('format', [None, ('Strip trailing whitespace', '<<do-rstrip>>'), ] ), ]

    def __init__(self, editwin):
        self.editwin = editwin
        self.editwin.text.bind("<<do-rstrip>>", self.do_rstrip)

    def do_rstrip(self, event=None):

        text = self.editwin.text
        undo = self.editwin.undo

        undo.undo_block_start()

        end_line = int(float(text.index('end')))
        for cur in range(1, end_line):
            txt = text.get('%i.0' % cur, '%i.end' % cur)
            raw = len(txt)
            cut = len(txt.rstrip())
            # Since text.delete() marks file as changed, even if not,
            # only call it when needed to actually delete something.
            if cut < raw:
                text.delete('%i.%i' % (cur, cut), '%i.end' % cur)

        undo.undo_block_stop()

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_rstrip', verbosity=2, exit=False)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """Replace dialog for IDLE. Inherits SearchDialogBase for GUI.
Uses idlelib.SearchEngine for search capability.
Defines various replace related functions like replace, replace all,
replace+find.
"""
from tkinter import *

from idlelib import SearchEngine
from idlelib.SearchDialogBase import SearchDialogBase
import re


def replace(text):
    """Returns a singleton ReplaceDialog instance.The single dialog
     saves user entries and preferences across instances."""
    root = text._root()
    engine = SearchEngine.get(root)
    if not hasattr(engine, "_replacedialog"):
        engine._replacedialog = ReplaceDialog(root, engine)
    dialog = engine._replacedialog
    dialog.open(text)


class ReplaceDialog(SearchDialogBase):

    title = "Replace Dialog"
    icon = "Replace"

    def __init__(self, root, engine):
        SearchDialogBase.__init__(self, root, engine)
        self.replvar = StringVar(root)

    def open(self, text):
        """Display the replace dialog"""
        SearchDialogBase.open(self, text)
        try:
            first = text.index("sel.first")
        except TclError:
            first = None
        try:
            last = text.index("sel.last")
        except TclError:
            last = None
        first = first or text.index("insert")
        last = last or first
        self.show_hit(first, last)
        self.ok = 1

    def create_entries(self):
        """Create label and text entry widgets"""
        SearchDialogBase.create_entries(self)
        self.replent = self.make_entry("Replace with:", self.replvar)[0]

    def create_command_buttons(self):
        SearchDialogBase.create_command_buttons(self)
        self.make_button("Find", self.find_it)
        self.make_button("Replace", self.replace_it)
        self.make_button("Replace+Find", self.default_command, 1)
        self.make_button("Replace All", self.replace_all)

    def find_it(self, event=None):
        self.do_find(0)

    def replace_it(self, event=None):
        if self.do_find(self.ok):
            self.do_replace()

    def default_command(self, event=None):
        "Replace and find next."
        if self.do_find(self.ok):
            if self.do_replace():  # Only find next match if replace succeeded.
                                   # A bad re can cause it to fail.
                self.do_find(0)

    def _replace_expand(self, m, repl):
        """ Helper function for expanding a regular expression
            in the replace field, if needed. """
        if self.engine.isre():
            try:
                new = m.expand(repl)
            except re.error:
                self.engine.report_error(repl, 'Invalid Replace Expression')
                new = None
        else:
            new = repl

        return new

    def replace_all(self, event=None):
        """Replace all instances of patvar with replvar in text"""
        prog = self.engine.getprog()
        if not prog:
            return
        repl = self.replvar.get()
        text = self.text
        res = self.engine.search_text(text, prog)
        if not res:
            text.bell()
            return
        text.tag_remove("sel", "1.0", "end")
        text.tag_remove("hit", "1.0", "end")
        line = res[0]
        col = res[1].start()
        if self.engine.iswrap():
            line = 1
            col = 0
        ok = 1
        first = last = None
        # XXX ought to replace circular instead of top-to-bottom when wrapping
        text.undo_block_start()
        while 1:
            res = self.engine.search_forward(text, prog, line, col, 0, ok)
            if not res:
                break
            line, m = res
            chars = text.get("%d.0" % line, "%d.0" % (line+1))
            orig = m.group()
            new = self._replace_expand(m, repl)
            if new is None:
                break
            i, j = m.span()
            first = "%d.%d" % (line, i)
            last = "%d.%d" % (line, j)
            if new == orig:
                text.mark_set("insert", last)
            else:
                text.mark_set("insert", first)
                if first != last:
                    text.delete(first, last)
                if new:
                    text.insert(first, new)
            col = i + len(new)
            ok = 0
        text.undo_block_stop()
        if first and last:
            self.show_hit(first, last)
        self.close()

    def do_find(self, ok=0):
        if not self.engine.getprog():
            return False
        text = self.text
        res = self.engine.search_text(text, None, ok)
        if not res:
            text.bell()
            return False
        line, m = res
        i, j = m.span()
        first = "%d.%d" % (line, i)
        last = "%d.%d" % (line, j)
        self.show_hit(first, last)
        self.ok = 1
        return True

    def do_replace(self):
        prog = self.engine.getprog()
        if not prog:
            return False
        text = self.text
        try:
            first = pos = text.index("sel.first")
            last = text.index("sel.last")
        except TclError:
            pos = None
        if not pos:
            first = last = pos = text.index("insert")
        line, col = SearchEngine.get_line_col(pos)
        chars = text.get("%d.0" % line, "%d.0" % (line+1))
        m = prog.match(chars, col)
        if not prog:
            return False
        new = self._replace_expand(m, self.replvar.get())
        if new is None:
            return False
        text.mark_set("insert", first)
        text.undo_block_start()
        if m.group():
            text.delete(first, last)
        if new:
            text.insert(first, new)
        text.undo_block_stop()
        self.show_hit(first, text.index("insert"))
        self.ok = 0
        return True

    def show_hit(self, first, last):
        """Highlight text from 'first' to 'last'.
        'first', 'last' - Text indices"""
        text = self.text
        text.mark_set("insert", first)
        text.tag_remove("sel", "1.0", "end")
        text.tag_add("sel", first, last)
        text.tag_remove("hit", "1.0", "end")
        if first == last:
            text.tag_add("hit", first)
        else:
            text.tag_add("hit", first, last)
        text.see("insert")
        text.update_idletasks()

    def close(self, event=None):
        SearchDialogBase.close(self, event)
        self.text.tag_remove("hit", "1.0", "end")


def _replace_dialog(parent):  # htest #
    """htest wrapper function"""
    box = Toplevel(parent)
    box.title("Test ReplaceDialog")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    box.geometry("+%d+%d"%(x, y + 150))

    # mock undo delegator methods
    def undo_block_start():
        pass

    def undo_block_stop():
        pass

    text = Text(box, inactiveselectbackground='gray')
    text.undo_block_start = undo_block_start
    text.undo_block_stop = undo_block_stop
    text.pack()
    text.insert("insert","This is a sample sTring\nPlus MORE.")
    text.focus_set()

    def show_replace():
        text.tag_add(SEL, "1.0", END)
        replace(text)
        text.tag_remove(SEL, "1.0", END)

    button = Button(box, text="Replace", command=show_replace)
    button.pack()

if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_replacedialog',
                verbosity=2, exit=False)

    from idlelib.idle_test.htest import run
    run(_replace_dialog)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Extension to execute code outside the Python shell window.

This adds the following commands:

- Check module does a full syntax check of the current module.
  It also runs the tabnanny to catch any inconsistent tabs.

- Run module executes the module's code in the __main__ namespace.  The window
  must have been saved previously. The module is added to sys.modules, and is
  also added to the __main__ namespace.

XXX GvR Redesign this interface (yet again) as follows:

- Present a dialog box for ``Run Module''

- Allow specify command line arguments in the dialog box

"""

import os
import tabnanny
import tokenize
import tkinter.messagebox as tkMessageBox
from idlelib import PyShell

from idlelib.configHandler import idleConf
from idlelib import macosxSupport

indent_message = """Error: Inconsistent indentation detected!

1) Your indentation is outright incorrect (easy to fix), OR

2) Your indentation mixes tabs and spaces.

To fix case 2, change all tabs to spaces by using Edit->Select All followed \
by Format->Untabify Region and specify the number of columns used by each tab.
"""


class ScriptBinding:

    menudefs = [
        ('run', [None,
                 ('Check Module', '<<check-module>>'),
                 ('Run Module', '<<run-module>>'), ]), ]

    def __init__(self, editwin):
        self.editwin = editwin
        # Provide instance variables referenced by Debugger
        # XXX This should be done differently
        self.flist = self.editwin.flist
        self.root = self.editwin.root

        if macosxSupport.isCocoaTk():
            self.editwin.text_frame.bind('<<run-module-event-2>>', self._run_module_event)

    def check_module_event(self, event):
        filename = self.getfilename()
        if not filename:
            return 'break'
        if not self.checksyntax(filename):
            return 'break'
        if not self.tabnanny(filename):
            return 'break'

    def tabnanny(self, filename):
        # XXX: tabnanny should work on binary files as well
        with tokenize.open(filename) as f:
            try:
                tabnanny.process_tokens(tokenize.generate_tokens(f.readline))
            except tokenize.TokenError as msg:
                msgtxt, (lineno, start) = msg.args
                self.editwin.gotoline(lineno)
                self.errorbox("Tabnanny Tokenizing Error",
                              "Token Error: %s" % msgtxt)
                return False
            except tabnanny.NannyNag as nag:
                # The error messages from tabnanny are too confusing...
                self.editwin.gotoline(nag.get_lineno())
                self.errorbox("Tab/space error", indent_message)
                return False
        return True

    def checksyntax(self, filename):
        self.shell = shell = self.flist.open_shell()
        saved_stream = shell.get_warning_stream()
        shell.set_warning_stream(shell.stderr)
        with open(filename, 'rb') as f:
            source = f.read()
        if b'\r' in source:
            source = source.replace(b'\r\n', b'\n')
            source = source.replace(b'\r', b'\n')
        if source and source[-1] != ord(b'\n'):
            source = source + b'\n'
        editwin = self.editwin
        text = editwin.text
        text.tag_remove("ERROR", "1.0", "end")
        try:
            # If successful, return the compiled code
            return compile(source, filename, "exec")
        except (SyntaxError, OverflowError, ValueError) as value:
            msg = getattr(value, 'msg', '') or value or "<no detail available>"
            lineno = getattr(value, 'lineno', '') or 1
            offset = getattr(value, 'offset', '') or 0
            if offset == 0:
                lineno += 1  #mark end of offending line
            pos = "0.0 + %d lines + %d chars" % (lineno-1, offset-1)
            editwin.colorize_syntax_error(text, pos)
            self.errorbox("SyntaxError", "%-20s" % msg)
            return False
        finally:
            shell.set_warning_stream(saved_stream)

    def run_module_event(self, event):
        if macosxSupport.isCocoaTk():
            # Tk-Cocoa in MacOSX is broken until at least
            # Tk 8.5.9, and without this rather
            # crude workaround IDLE would hang when a user
            # tries to run a module using the keyboard shortcut
            # (the menu item works fine).
            self.editwin.text_frame.after(200,
                lambda: self.editwin.text_frame.event_generate('<<run-module-event-2>>'))
            return 'break'
        else:
            return self._run_module_event(event)

    def _run_module_event(self, event):
        """Run the module after setting up the environment.

        First check the syntax.  If OK, make sure the shell is active and
        then transfer the arguments, set the run environment's working
        directory to the directory of the module being executed and also
        add that directory to its sys.path if not already included.
        """

        filename = self.getfilename()
        if not filename:
            return 'break'
        code = self.checksyntax(filename)
        if not code:
            return 'break'
        if not self.tabnanny(filename):
            return 'break'
        interp = self.shell.interp
        if PyShell.use_subprocess:
            interp.restart_subprocess(with_cwd=False, filename=
                        self.editwin._filename_to_unicode(filename))
        dirname = os.path.dirname(filename)
        # XXX Too often this discards arguments the user just set...
        interp.runcommand("""if 1:
            __file__ = {filename!r}
            import sys as _sys
            from os.path import basename as _basename
            if (not _sys.argv or
                _basename(_sys.argv[0]) != _basename(__file__)):
                _sys.argv = [__file__]
            import os as _os
            _os.chdir({dirname!r})
            del _sys, _basename, _os
            \n""".format(filename=filename, dirname=dirname))
        interp.prepend_syspath(filename)
        # XXX KBK 03Jul04 When run w/o subprocess, runtime warnings still
        #         go to __stderr__.  With subprocess, they go to the shell.
        #         Need to change streams in PyShell.ModifiedInterpreter.
        interp.runcode(code)
        return 'break'

    def getfilename(self):
        """Get source filename.  If not saved, offer to save (or create) file

        The debugger requires a source file.  Make sure there is one, and that
        the current version of the source buffer has been saved.  If the user
        declines to save or cancels the Save As dialog, return None.

        If the user has configured IDLE for Autosave, the file will be
        silently saved if it already exists and is dirty.

        """
        filename = self.editwin.io.filename
        if not self.editwin.get_saved():
            autosave = idleConf.GetOption('main', 'General',
                                          'autosave', type='bool')
            if autosave and filename:
                self.editwin.io.save(None)
            else:
                confirm = self.ask_save_dialog()
                self.editwin.text.focus_set()
                if confirm:
                    self.editwin.io.save(None)
                    filename = self.editwin.io.filename
                else:
                    filename = None
        return filename

    def ask_save_dialog(self):
        msg = "Source Must Be Saved\n" + 5*' ' + "OK to Save?"
        confirm = tkMessageBox.askokcancel(title="Save Before Run or Check",
                                           message=msg,
                                           default=tkMessageBox.OK,
                                           parent=self.editwin.text)
        return confirm

    def errorbox(self, title, message):
        # XXX This should really be a function of EditorWindow...
        tkMessageBox.showerror(title, message, parent=self.editwin.text)
        self.editwin.text.focus_set()
                                                                                                                                   from tkinter import *
from idlelib import macosxSupport

class ScrolledList:

    default = "(None)"

    def __init__(self, master, **options):
        # Create top frame, with scrollbar and listbox
        self.master = master
        self.frame = frame = Frame(master)
        self.frame.pack(fill="both", expand=1)
        self.vbar = vbar = Scrollbar(frame, name="vbar")
        self.vbar.pack(side="right", fill="y")
        self.listbox = listbox = Listbox(frame, exportselection=0,
            background="white")
        if options:
            listbox.configure(options)
        listbox.pack(expand=1, fill="both")
        # Tie listbox and scrollbar together
        vbar["command"] = listbox.yview
        listbox["yscrollcommand"] = vbar.set
        # Bind events to the list box
        listbox.bind("<ButtonRelease-1>", self.click_event)
        listbox.bind("<Double-ButtonRelease-1>", self.double_click_event)
        if macosxSupport.isAquaTk():
            listbox.bind("<ButtonPress-2>", self.popup_event)
            listbox.bind("<Control-Button-1>", self.popup_event)
        else:
            listbox.bind("<ButtonPress-3>", self.popup_event)
        listbox.bind("<Key-Up>", self.up_event)
        listbox.bind("<Key-Down>", self.down_event)
        # Mark as empty
        self.clear()

    def close(self):
        self.frame.destroy()

    def clear(self):
        self.listbox.delete(0, "end")
        self.empty = 1
        self.listbox.insert("end", self.default)

    def append(self, item):
        if self.empty:
            self.listbox.delete(0, "end")
            self.empty = 0
        self.listbox.insert("end", str(item))

    def get(self, index):
        return self.listbox.get(index)

    def click_event(self, event):
        self.listbox.activate("@%d,%d" % (event.x, event.y))
        index = self.listbox.index("active")
        self.select(index)
        self.on_select(index)
        return "break"

    def double_click_event(self, event):
        index = self.listbox.index("active")
        self.select(index)
        self.on_double(index)
        return "break"

    menu = None

    def popup_event(self, event):
        if not self.menu:
            self.make_menu()
        menu = self.menu
        self.listbox.activate("@%d,%d" % (event.x, event.y))
        index = self.listbox.index("active")
        self.select(index)
        menu.tk_popup(event.x_root, event.y_root)

    def make_menu(self):
        menu = Menu(self.listbox, tearoff=0)
        self.menu = menu
        self.fill_menu()

    def up_event(self, event):
        index = self.listbox.index("active")
        if self.listbox.selection_includes(index):
            index = index - 1
        else:
            index = self.listbox.size() - 1
        if index < 0:
            self.listbox.bell()
        else:
            self.select(index)
            self.on_select(index)
        return "break"

    def down_event(self, event):
        index = self.listbox.index("active")
        if self.listbox.selection_includes(index):
            index = index + 1
        else:
            index = 0
        if index >= self.listbox.size():
            self.listbox.bell()
        else:
            self.select(index)
            self.on_select(index)
        return "break"

    def select(self, index):
        self.listbox.focus_set()
        self.listbox.activate(index)
        self.listbox.selection_clear(0, "end")
        self.listbox.selection_set(index)
        self.listbox.see(index)

    # Methods to override for specific actions

    def fill_menu(self):
        pass

    def on_select(self, index):
        pass

    def on_double(self, index):
        pass


def _scrolled_list(parent):
    root = Tk()
    root.title("Test ScrolledList")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    class MyScrolledList(ScrolledList):
        def fill_menu(self): self.menu.add_command(label="right click")
        def on_select(self, index): print("select", self.get(index))
        def on_double(self, index): print("double", self.get(index))

    scrolled_list = MyScrolledList(root)
    for i in range(30):
        scrolled_list.append("Item %02d" % i)

    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_scrolled_list)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from tkinter import *

from idlelib import SearchEngine
from idlelib.SearchDialogBase import SearchDialogBase

def _setup(text):
    "Create or find the singleton SearchDialog instance."
    root = text._root()
    engine = SearchEngine.get(root)
    if not hasattr(engine, "_searchdialog"):
        engine._searchdialog = SearchDialog(root, engine)
    return engine._searchdialog

def find(text):
    "Handle the editor edit menu item and corresponding event."
    pat = text.get("sel.first", "sel.last")
    return _setup(text).open(text, pat)  # Open is inherited from SDBase.

def find_again(text):
    "Handle the editor edit menu item and corresponding event."
    return _setup(text).find_again(text)

def find_selection(text):
    "Handle the editor edit menu item and corresponding event."
    return _setup(text).find_selection(text)

class SearchDialog(SearchDialogBase):

    def create_widgets(self):
        SearchDialogBase.create_widgets(self)
        self.make_button("Find Next", self.default_command, 1)

    def default_command(self, event=None):
        if not self.engine.getprog():
            return
        self.find_again(self.text)

    def find_again(self, text):
        if not self.engine.getpat():
            self.open(text)
            return False
        if not self.engine.getprog():
            return False
        res = self.engine.search_text(text)
        if res:
            line, m = res
            i, j = m.span()
            first = "%d.%d" % (line, i)
            last = "%d.%d" % (line, j)
            try:
                selfirst = text.index("sel.first")
                sellast = text.index("sel.last")
                if selfirst == first and sellast == last:
                    text.bell()
                    return False
            except TclError:
                pass
            text.tag_remove("sel", "1.0", "end")
            text.tag_add("sel", first, last)
            text.mark_set("insert", self.engine.isback() and first or last)
            text.see("insert")
            return True
        else:
            text.bell()
            return False

    def find_selection(self, text):
        pat = text.get("sel.first", "sel.last")
        if pat:
            self.engine.setcookedpat(pat)
        return self.find_again(text)


def _search_dialog(parent):  # htest #
    '''Display search test box.'''
    box = Toplevel(parent)
    box.title("Test SearchDialog")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    box.geometry("+%d+%d"%(x, y + 150))
    text = Text(box, inactiveselectbackground='gray')
    text.pack()
    text.insert("insert","This is a sample string.\n"*5)

    def show_find():
        text.tag_add(SEL, "1.0", END)
        _setup(text).open(text)
        text.tag_remove(SEL, "1.0", END)

    button = Button(box, text="Search (selection ignored)", command=show_find)
    button.pack()

if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_searchdialog',
                  verbosity=2, exit=False)
    from idlelib.idle_test.htest import run
    run(_search_dialog)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # general purpose 'tooltip' routines - currently unused in idlefork
# (although the 'calltips' extension is partly based on this code)
# may be useful for some purposes in (or almost in ;) the current project scope
# Ideas gleaned from PySol

from tkinter import *

class ToolTipBase:

    def __init__(self, button):
        self.button = button
        self.tipwindow = None
        self.id = None
        self.x = self.y = 0
        self._id1 = self.button.bind("<Enter>", self.enter)
        self._id2 = self.button.bind("<Leave>", self.leave)
        self._id3 = self.button.bind("<ButtonPress>", self.leave)

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.button.after(1500, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.button.after_cancel(id)

    def showtip(self):
        if self.tipwindow:
            return
        # The tip window must be completely outside the button;
        # otherwise when the mouse enters the tip window we get
        # a leave event and it disappears, and then we get an enter
        # event and it reappears, and so on forever :-(
        x = self.button.winfo_rootx() + 20
        y = self.button.winfo_rooty() + self.button.winfo_height() + 1
        self.tipwindow = tw = Toplevel(self.button)
        tw.wm_overrideredirect(1)
        tw.wm_geometry("+%d+%d" % (x, y))
        self.showcontents()

    def showcontents(self, text="Your text here"):
        # Override this in derived class
        label = Label(self.tipwindow, text=text, justify=LEFT,
                      background="#ffffe0", relief=SOLID, borderwidth=1)
        label.pack()

    def hidetip(self):
        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy()

class ToolTip(ToolTipBase):
    def __init__(self, button, text):
        ToolTipBase.__init__(self, button)
        self.text = text
    def showcontents(self):
        ToolTipBase.showcontents(self, self.text)

class ListboxToolTip(ToolTipBase):
    def __init__(self, button, items):
        ToolTipBase.__init__(self, button)
        self.items = items
    def showcontents(self):
        listbox = Listbox(self.tipwindow, background="#ffffe0")
        listbox.pack()
        for item in self.items:
            listbox.insert(END, item)

def _tooltip(parent):
    root = Tk()
    root.title("Test tooltip")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    label = Label(root, text="Place your mouse over buttons")
    label.pack()
    button1 = Button(root, text="Button 1")
    button2 = Button(root, text="Button 2")
    button1.pack()
    button2.pack()
    ToolTip(button1, "This is tooltip text for button1.")
    ListboxToolTip(button2, ["This is","multiple line",
                            "tooltip text","for button2"])
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_tooltip)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           